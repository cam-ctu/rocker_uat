
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:18:57.245] plan(): Setting new future strategy stack:
[13:18:57.245] List of future strategies:
[13:18:57.245] 1. sequential:
[13:18:57.245]    - args: function (..., envir = parent.frame())
[13:18:57.245]    - tweaked: FALSE
[13:18:57.245]    - call: future::plan("sequential")
[13:18:57.256] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:18:57.363] plan(): Setting new future strategy stack:
[13:18:57.364] List of future strategies:
[13:18:57.364] 1. sequential:
[13:18:57.364]    - args: function (..., envir = parent.frame())
[13:18:57.364]    - tweaked: FALSE
[13:18:57.364]    - call: plan(strategy)
[13:18:57.376] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:18:57.382] future_lapply() ...
[13:18:57.389] Number of chunks: 1
[13:18:57.389] getGlobalsAndPackagesXApply() ...
[13:18:57.389]  - future.globals: TRUE
[13:18:57.390] getGlobalsAndPackages() ...
[13:18:57.390] Searching for globals...
[13:18:57.394] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:57.394] Searching for globals ... DONE
[13:18:57.394] Resolving globals: FALSE
[13:18:57.396] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:18:57.396] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.397] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.397] - packages: [1] ‘future.apply’
[13:18:57.397] getGlobalsAndPackages() ... DONE
[13:18:57.397]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.397]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.397] Finding globals ... DONE
[13:18:57.397]  - use_args: TRUE
[13:18:57.397]  - Getting '...' globals ...
[13:18:57.398] resolve() on list ...
[13:18:57.398]  recursive: 0
[13:18:57.399]  length: 1
[13:18:57.399]  elements: ‘...’
[13:18:57.399]  length: 0 (resolved future 1)
[13:18:57.399] resolve() on list ... DONE
[13:18:57.399]    - '...' content: [n=0] 
[13:18:57.399] List of 1
[13:18:57.399]  $ ...: list()
[13:18:57.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.399]  - attr(*, "where")=List of 1
[13:18:57.399]   ..$ ...:<environment: 0x555f7b573bc8> 
[13:18:57.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.399]  - attr(*, "resolved")= logi TRUE
[13:18:57.399]  - attr(*, "total_size")= num NA
[13:18:57.405]  - Getting '...' globals ... DONE
[13:18:57.405] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.405] List of 8
[13:18:57.405]  $ ...future.FUN:function (x, ...)  
[13:18:57.405]  $ x_FUN        :function (x)  
[13:18:57.405]  $ times        : int 1
[13:18:57.405]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.405]  $ stop_if_not  :function (...)  
[13:18:57.405]  $ dim          : NULL
[13:18:57.405]  $ valid_types  : chr "character"
[13:18:57.405]  $ ...          : list()
[13:18:57.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.405]  - attr(*, "where")=List of 8
[13:18:57.405]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.405]   ..$ ...          :<environment: 0x555f7b573bc8> 
[13:18:57.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.405]  - attr(*, "resolved")= logi FALSE
[13:18:57.405]  - attr(*, "total_size")= num 94208
[13:18:57.410] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.411] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.411] Number of futures (= number of chunks): 1
[13:18:57.411] Launching 1 futures (chunks) ...
[13:18:57.411] Chunk #1 of 1 ...
[13:18:57.411]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.412] getGlobalsAndPackages() ...
[13:18:57.412] Searching for globals...
[13:18:57.412] 
[13:18:57.412] Searching for globals ... DONE
[13:18:57.412] - globals: [0] <none>
[13:18:57.412] getGlobalsAndPackages() ... DONE
[13:18:57.412]    + additional globals found: [n=0] 
[13:18:57.412]    + additional namespaces needed: [n=0] 
[13:18:57.412]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.413]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:18:57.413]  - seeds: <none>
[13:18:57.413] getGlobalsAndPackages() ...
[13:18:57.413] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.413] Resolving globals: FALSE
[13:18:57.413] Tweak future expression to call with '...' arguments ...
[13:18:57.413] {
[13:18:57.413]     do.call(function(...) {
[13:18:57.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.413]             on.exit(options(oopts), add = TRUE)
[13:18:57.413]         }
[13:18:57.413]         {
[13:18:57.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.413]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.413]             })
[13:18:57.413]         }
[13:18:57.413]     }, args = future.call.arguments)
[13:18:57.413] }
[13:18:57.414] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.414] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.414] - packages: [1] ‘future.apply’
[13:18:57.415] getGlobalsAndPackages() ... DONE
[13:18:57.415] run() for ‘Future’ ...
[13:18:57.415] - state: ‘created’
[13:18:57.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.416]   - Field: ‘label’
[13:18:57.416]   - Field: ‘local’
[13:18:57.416]   - Field: ‘owner’
[13:18:57.417]   - Field: ‘envir’
[13:18:57.417]   - Field: ‘packages’
[13:18:57.417]   - Field: ‘gc’
[13:18:57.417]   - Field: ‘conditions’
[13:18:57.417]   - Field: ‘expr’
[13:18:57.417]   - Field: ‘uuid’
[13:18:57.417]   - Field: ‘seed’
[13:18:57.417]   - Field: ‘version’
[13:18:57.417]   - Field: ‘result’
[13:18:57.417]   - Field: ‘asynchronous’
[13:18:57.417]   - Field: ‘calls’
[13:18:57.418]   - Field: ‘globals’
[13:18:57.418]   - Field: ‘stdout’
[13:18:57.418]   - Field: ‘earlySignal’
[13:18:57.418]   - Field: ‘lazy’
[13:18:57.418]   - Field: ‘state’
[13:18:57.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.418] - Launch lazy future ...
[13:18:57.419] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.419] Packages needed by future strategies (n = 0): <none>
[13:18:57.420] {
[13:18:57.420]     {
[13:18:57.420]         {
[13:18:57.420]             ...future.startTime <- base::Sys.time()
[13:18:57.420]             {
[13:18:57.420]                 {
[13:18:57.420]                   {
[13:18:57.420]                     {
[13:18:57.420]                       base::local({
[13:18:57.420]                         has_future <- base::requireNamespace("future", 
[13:18:57.420]                           quietly = TRUE)
[13:18:57.420]                         if (has_future) {
[13:18:57.420]                           ns <- base::getNamespace("future")
[13:18:57.420]                           version <- ns[[".package"]][["version"]]
[13:18:57.420]                           if (is.null(version)) 
[13:18:57.420]                             version <- utils::packageVersion("future")
[13:18:57.420]                         }
[13:18:57.420]                         else {
[13:18:57.420]                           version <- NULL
[13:18:57.420]                         }
[13:18:57.420]                         if (!has_future || version < "1.8.0") {
[13:18:57.420]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.420]                             "", base::R.version$version.string), 
[13:18:57.420]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.420]                               "release", "version")], collapse = " "), 
[13:18:57.420]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.420]                             info)
[13:18:57.420]                           info <- base::paste(info, collapse = "; ")
[13:18:57.420]                           if (!has_future) {
[13:18:57.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.420]                               info)
[13:18:57.420]                           }
[13:18:57.420]                           else {
[13:18:57.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.420]                               info, version)
[13:18:57.420]                           }
[13:18:57.420]                           base::stop(msg)
[13:18:57.420]                         }
[13:18:57.420]                       })
[13:18:57.420]                     }
[13:18:57.420]                     base::local({
[13:18:57.420]                       for (pkg in "future.apply") {
[13:18:57.420]                         base::loadNamespace(pkg)
[13:18:57.420]                         base::library(pkg, character.only = TRUE)
[13:18:57.420]                       }
[13:18:57.420]                     })
[13:18:57.420]                   }
[13:18:57.420]                   options(future.plan = NULL)
[13:18:57.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.420]                 }
[13:18:57.420]                 ...future.workdir <- getwd()
[13:18:57.420]             }
[13:18:57.420]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.420]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.420]         }
[13:18:57.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.420]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:18:57.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.420]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.420]             base::names(...future.oldOptions))
[13:18:57.420]     }
[13:18:57.420]     if (FALSE) {
[13:18:57.420]     }
[13:18:57.420]     else {
[13:18:57.420]         if (TRUE) {
[13:18:57.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.420]                 open = "w")
[13:18:57.420]         }
[13:18:57.420]         else {
[13:18:57.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.420]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.420]         }
[13:18:57.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.420]             base::sink(type = "output", split = FALSE)
[13:18:57.420]             base::close(...future.stdout)
[13:18:57.420]         }, add = TRUE)
[13:18:57.420]     }
[13:18:57.420]     ...future.frame <- base::sys.nframe()
[13:18:57.420]     ...future.conditions <- base::list()
[13:18:57.420]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.420]     if (FALSE) {
[13:18:57.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.420]     }
[13:18:57.420]     ...future.result <- base::tryCatch({
[13:18:57.420]         base::withCallingHandlers({
[13:18:57.420]             ...future.value <- base::withVisible(base::local({
[13:18:57.420]                 do.call(function(...) {
[13:18:57.420]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.420]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.420]                     ...future.globals.maxSize)) {
[13:18:57.420]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.420]                     on.exit(options(oopts), add = TRUE)
[13:18:57.420]                   }
[13:18:57.420]                   {
[13:18:57.420]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.420]                       FUN = function(jj) {
[13:18:57.420]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.420]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.420]                       })
[13:18:57.420]                   }
[13:18:57.420]                 }, args = future.call.arguments)
[13:18:57.420]             }))
[13:18:57.420]             future::FutureResult(value = ...future.value$value, 
[13:18:57.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.420]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.420]                     ...future.globalenv.names))
[13:18:57.420]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.420]         }, condition = base::local({
[13:18:57.420]             c <- base::c
[13:18:57.420]             inherits <- base::inherits
[13:18:57.420]             invokeRestart <- base::invokeRestart
[13:18:57.420]             length <- base::length
[13:18:57.420]             list <- base::list
[13:18:57.420]             seq.int <- base::seq.int
[13:18:57.420]             signalCondition <- base::signalCondition
[13:18:57.420]             sys.calls <- base::sys.calls
[13:18:57.420]             `[[` <- base::`[[`
[13:18:57.420]             `+` <- base::`+`
[13:18:57.420]             `<<-` <- base::`<<-`
[13:18:57.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.420]                   3L)]
[13:18:57.420]             }
[13:18:57.420]             function(cond) {
[13:18:57.420]                 is_error <- inherits(cond, "error")
[13:18:57.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.420]                   NULL)
[13:18:57.420]                 if (is_error) {
[13:18:57.420]                   sessionInformation <- function() {
[13:18:57.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.420]                       search = base::search(), system = base::Sys.info())
[13:18:57.420]                   }
[13:18:57.420]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.420]                     cond$call), session = sessionInformation(), 
[13:18:57.420]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.420]                   signalCondition(cond)
[13:18:57.420]                 }
[13:18:57.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.420]                 "immediateCondition"))) {
[13:18:57.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.420]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.420]                   if (TRUE && !signal) {
[13:18:57.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.420]                     {
[13:18:57.420]                       inherits <- base::inherits
[13:18:57.420]                       invokeRestart <- base::invokeRestart
[13:18:57.420]                       is.null <- base::is.null
[13:18:57.420]                       muffled <- FALSE
[13:18:57.420]                       if (inherits(cond, "message")) {
[13:18:57.420]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.420]                         if (muffled) 
[13:18:57.420]                           invokeRestart("muffleMessage")
[13:18:57.420]                       }
[13:18:57.420]                       else if (inherits(cond, "warning")) {
[13:18:57.420]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.420]                         if (muffled) 
[13:18:57.420]                           invokeRestart("muffleWarning")
[13:18:57.420]                       }
[13:18:57.420]                       else if (inherits(cond, "condition")) {
[13:18:57.420]                         if (!is.null(pattern)) {
[13:18:57.420]                           computeRestarts <- base::computeRestarts
[13:18:57.420]                           grepl <- base::grepl
[13:18:57.420]                           restarts <- computeRestarts(cond)
[13:18:57.420]                           for (restart in restarts) {
[13:18:57.420]                             name <- restart$name
[13:18:57.420]                             if (is.null(name)) 
[13:18:57.420]                               next
[13:18:57.420]                             if (!grepl(pattern, name)) 
[13:18:57.420]                               next
[13:18:57.420]                             invokeRestart(restart)
[13:18:57.420]                             muffled <- TRUE
[13:18:57.420]                             break
[13:18:57.420]                           }
[13:18:57.420]                         }
[13:18:57.420]                       }
[13:18:57.420]                       invisible(muffled)
[13:18:57.420]                     }
[13:18:57.420]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.420]                   }
[13:18:57.420]                 }
[13:18:57.420]                 else {
[13:18:57.420]                   if (TRUE) {
[13:18:57.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.420]                     {
[13:18:57.420]                       inherits <- base::inherits
[13:18:57.420]                       invokeRestart <- base::invokeRestart
[13:18:57.420]                       is.null <- base::is.null
[13:18:57.420]                       muffled <- FALSE
[13:18:57.420]                       if (inherits(cond, "message")) {
[13:18:57.420]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.420]                         if (muffled) 
[13:18:57.420]                           invokeRestart("muffleMessage")
[13:18:57.420]                       }
[13:18:57.420]                       else if (inherits(cond, "warning")) {
[13:18:57.420]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.420]                         if (muffled) 
[13:18:57.420]                           invokeRestart("muffleWarning")
[13:18:57.420]                       }
[13:18:57.420]                       else if (inherits(cond, "condition")) {
[13:18:57.420]                         if (!is.null(pattern)) {
[13:18:57.420]                           computeRestarts <- base::computeRestarts
[13:18:57.420]                           grepl <- base::grepl
[13:18:57.420]                           restarts <- computeRestarts(cond)
[13:18:57.420]                           for (restart in restarts) {
[13:18:57.420]                             name <- restart$name
[13:18:57.420]                             if (is.null(name)) 
[13:18:57.420]                               next
[13:18:57.420]                             if (!grepl(pattern, name)) 
[13:18:57.420]                               next
[13:18:57.420]                             invokeRestart(restart)
[13:18:57.420]                             muffled <- TRUE
[13:18:57.420]                             break
[13:18:57.420]                           }
[13:18:57.420]                         }
[13:18:57.420]                       }
[13:18:57.420]                       invisible(muffled)
[13:18:57.420]                     }
[13:18:57.420]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.420]                   }
[13:18:57.420]                 }
[13:18:57.420]             }
[13:18:57.420]         }))
[13:18:57.420]     }, error = function(ex) {
[13:18:57.420]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.420]                 ...future.rng), started = ...future.startTime, 
[13:18:57.420]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.420]             version = "1.8"), class = "FutureResult")
[13:18:57.420]     }, finally = {
[13:18:57.420]         if (!identical(...future.workdir, getwd())) 
[13:18:57.420]             setwd(...future.workdir)
[13:18:57.420]         {
[13:18:57.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.420]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.420]             }
[13:18:57.420]             base::options(...future.oldOptions)
[13:18:57.420]             if (.Platform$OS.type == "windows") {
[13:18:57.420]                 old_names <- names(...future.oldEnvVars)
[13:18:57.420]                 envs <- base::Sys.getenv()
[13:18:57.420]                 names <- names(envs)
[13:18:57.420]                 common <- intersect(names, old_names)
[13:18:57.420]                 added <- setdiff(names, old_names)
[13:18:57.420]                 removed <- setdiff(old_names, names)
[13:18:57.420]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.420]                   envs[common]]
[13:18:57.420]                 NAMES <- toupper(changed)
[13:18:57.420]                 args <- list()
[13:18:57.420]                 for (kk in seq_along(NAMES)) {
[13:18:57.420]                   name <- changed[[kk]]
[13:18:57.420]                   NAME <- NAMES[[kk]]
[13:18:57.420]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.420]                     next
[13:18:57.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.420]                 }
[13:18:57.420]                 NAMES <- toupper(added)
[13:18:57.420]                 for (kk in seq_along(NAMES)) {
[13:18:57.420]                   name <- added[[kk]]
[13:18:57.420]                   NAME <- NAMES[[kk]]
[13:18:57.420]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.420]                     next
[13:18:57.420]                   args[[name]] <- ""
[13:18:57.420]                 }
[13:18:57.420]                 NAMES <- toupper(removed)
[13:18:57.420]                 for (kk in seq_along(NAMES)) {
[13:18:57.420]                   name <- removed[[kk]]
[13:18:57.420]                   NAME <- NAMES[[kk]]
[13:18:57.420]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.420]                     next
[13:18:57.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.420]                 }
[13:18:57.420]                 if (length(args) > 0) 
[13:18:57.420]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.420]             }
[13:18:57.420]             else {
[13:18:57.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.420]             }
[13:18:57.420]             {
[13:18:57.420]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.420]                   0L) {
[13:18:57.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.420]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.420]                   base::options(opts)
[13:18:57.420]                 }
[13:18:57.420]                 {
[13:18:57.420]                   {
[13:18:57.420]                     NULL
[13:18:57.420]                     RNGkind("Mersenne-Twister")
[13:18:57.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.420]                       inherits = FALSE)
[13:18:57.420]                   }
[13:18:57.420]                   options(future.plan = NULL)
[13:18:57.420]                   if (is.na(NA_character_)) 
[13:18:57.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.420]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.420]                   {
[13:18:57.420]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.420]                     if (!future$lazy) 
[13:18:57.420]                       future <- run(future)
[13:18:57.420]                     invisible(future)
[13:18:57.420]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.420]                 }
[13:18:57.420]             }
[13:18:57.420]         }
[13:18:57.420]     })
[13:18:57.420]     if (TRUE) {
[13:18:57.420]         base::sink(type = "output", split = FALSE)
[13:18:57.420]         if (TRUE) {
[13:18:57.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.420]         }
[13:18:57.420]         else {
[13:18:57.420]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.420]         }
[13:18:57.420]         base::close(...future.stdout)
[13:18:57.420]         ...future.stdout <- NULL
[13:18:57.420]     }
[13:18:57.420]     ...future.result$conditions <- ...future.conditions
[13:18:57.420]     ...future.result$finished <- base::Sys.time()
[13:18:57.420]     ...future.result
[13:18:57.420] }
[13:18:57.422] assign_globals() ...
[13:18:57.422] List of 11
[13:18:57.422]  $ ...future.FUN            :function (x, ...)  
[13:18:57.422]  $ x_FUN                    :function (x)  
[13:18:57.422]  $ times                    : int 1
[13:18:57.422]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.422]  $ stop_if_not              :function (...)  
[13:18:57.422]  $ dim                      : NULL
[13:18:57.422]  $ valid_types              : chr "character"
[13:18:57.422]  $ future.call.arguments    : list()
[13:18:57.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.422]  $ ...future.elements_ii    :List of 2
[13:18:57.422]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:18:57.422]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[13:18:57.422]  $ ...future.seeds_ii       : NULL
[13:18:57.422]  $ ...future.globals.maxSize: NULL
[13:18:57.422]  - attr(*, "resolved")= logi FALSE
[13:18:57.422]  - attr(*, "total_size")= num 94208
[13:18:57.422]  - attr(*, "where")=List of 11
[13:18:57.422]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.422]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.422]  - attr(*, "already-done")= logi TRUE
[13:18:57.432] - copied ‘...future.FUN’ to environment
[13:18:57.432] - copied ‘x_FUN’ to environment
[13:18:57.432] - copied ‘times’ to environment
[13:18:57.432] - copied ‘stopf’ to environment
[13:18:57.432] - copied ‘stop_if_not’ to environment
[13:18:57.432] - copied ‘dim’ to environment
[13:18:57.432] - copied ‘valid_types’ to environment
[13:18:57.432] - copied ‘future.call.arguments’ to environment
[13:18:57.433] - copied ‘...future.elements_ii’ to environment
[13:18:57.433] - copied ‘...future.seeds_ii’ to environment
[13:18:57.433] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.433] assign_globals() ... done
[13:18:57.433] plan(): Setting new future strategy stack:
[13:18:57.433] List of future strategies:
[13:18:57.433] 1. sequential:
[13:18:57.433]    - args: function (..., envir = parent.frame())
[13:18:57.433]    - tweaked: FALSE
[13:18:57.433]    - call: NULL
[13:18:57.434] plan(): nbrOfWorkers() = 1
[13:18:57.435] plan(): Setting new future strategy stack:
[13:18:57.435] List of future strategies:
[13:18:57.435] 1. sequential:
[13:18:57.435]    - args: function (..., envir = parent.frame())
[13:18:57.435]    - tweaked: FALSE
[13:18:57.435]    - call: plan(strategy)
[13:18:57.436] plan(): nbrOfWorkers() = 1
[13:18:57.436] SequentialFuture started (and completed)
[13:18:57.436] - Launch lazy future ... done
[13:18:57.436] run() for ‘SequentialFuture’ ... done
[13:18:57.436] Created future:
[13:18:57.437] SequentialFuture:
[13:18:57.437] Label: ‘future_vapply-1’
[13:18:57.437] Expression:
[13:18:57.437] {
[13:18:57.437]     do.call(function(...) {
[13:18:57.437]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.437]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.437]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.437]             on.exit(options(oopts), add = TRUE)
[13:18:57.437]         }
[13:18:57.437]         {
[13:18:57.437]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.437]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.437]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.437]             })
[13:18:57.437]         }
[13:18:57.437]     }, args = future.call.arguments)
[13:18:57.437] }
[13:18:57.437] Lazy evaluation: FALSE
[13:18:57.437] Asynchronous evaluation: FALSE
[13:18:57.437] Local evaluation: TRUE
[13:18:57.437] Environment: R_GlobalEnv
[13:18:57.437] Capture standard output: TRUE
[13:18:57.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.437] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.437] Packages: 1 packages (‘future.apply’)
[13:18:57.437] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.437] Resolved: TRUE
[13:18:57.437] Value: 232 bytes of class ‘list’
[13:18:57.437] Early signaling: FALSE
[13:18:57.437] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.437] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.438] Chunk #1 of 1 ... DONE
[13:18:57.438] Launching 1 futures (chunks) ... DONE
[13:18:57.439] Resolving 1 futures (chunks) ...
[13:18:57.439] resolve() on list ...
[13:18:57.439]  recursive: 0
[13:18:57.439]  length: 1
[13:18:57.439] 
[13:18:57.439] resolved() for ‘SequentialFuture’ ...
[13:18:57.439] - state: ‘finished’
[13:18:57.439] - run: TRUE
[13:18:57.440] - result: ‘FutureResult’
[13:18:57.440] resolved() for ‘SequentialFuture’ ... done
[13:18:57.440] Future #1
[13:18:57.440] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.440] - nx: 1
[13:18:57.440] - relay: TRUE
[13:18:57.440] - stdout: TRUE
[13:18:57.441] - signal: TRUE
[13:18:57.441] - resignal: FALSE
[13:18:57.441] - force: TRUE
[13:18:57.441] - relayed: [n=1] FALSE
[13:18:57.441] - queued futures: [n=1] FALSE
[13:18:57.441]  - until=1
[13:18:57.441]  - relaying element #1
[13:18:57.441] - relayed: [n=1] TRUE
[13:18:57.441] - queued futures: [n=1] TRUE
[13:18:57.441] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.442]  length: 0 (resolved future 1)
[13:18:57.442] Relaying remaining futures
[13:18:57.442] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.442] - nx: 1
[13:18:57.442] - relay: TRUE
[13:18:57.442] - stdout: TRUE
[13:18:57.442] - signal: TRUE
[13:18:57.442] - resignal: FALSE
[13:18:57.442] - force: TRUE
[13:18:57.442] - relayed: [n=1] TRUE
[13:18:57.443] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.443] - relayed: [n=1] TRUE
[13:18:57.443] - queued futures: [n=1] TRUE
[13:18:57.443] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.443] resolve() on list ... DONE
[13:18:57.443]  - Number of value chunks collected: 1
[13:18:57.443] Resolving 1 futures (chunks) ... DONE
[13:18:57.443] Reducing values from 1 chunks ...
[13:18:57.443]  - Number of values collected after concatenation: 2
[13:18:57.443]  - Number of values expected: 2
[13:18:57.444] Reducing values from 1 chunks ... DONE
[13:18:57.444] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:18:57.445] future_lapply() ...
[13:18:57.447] Number of chunks: 1
[13:18:57.447] getGlobalsAndPackagesXApply() ...
[13:18:57.447]  - future.globals: TRUE
[13:18:57.447] getGlobalsAndPackages() ...
[13:18:57.447] Searching for globals...
[13:18:57.451] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:18:57.451] Searching for globals ... DONE
[13:18:57.451] Resolving globals: FALSE
[13:18:57.452] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:18:57.452] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.452] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.453] - packages: [1] ‘future.apply’
[13:18:57.453] getGlobalsAndPackages() ... DONE
[13:18:57.453]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.453]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.453] Finding globals ... DONE
[13:18:57.453]  - use_args: TRUE
[13:18:57.453]  - Getting '...' globals ...
[13:18:57.453] resolve() on list ...
[13:18:57.454]  recursive: 0
[13:18:57.454]  length: 1
[13:18:57.454]  elements: ‘...’
[13:18:57.454]  length: 0 (resolved future 1)
[13:18:57.454] resolve() on list ... DONE
[13:18:57.454]    - '...' content: [n=0] 
[13:18:57.454] List of 1
[13:18:57.454]  $ ...: list()
[13:18:57.454]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.454]  - attr(*, "where")=List of 1
[13:18:57.454]   ..$ ...:<environment: 0x555f7b420230> 
[13:18:57.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.454]  - attr(*, "resolved")= logi TRUE
[13:18:57.454]  - attr(*, "total_size")= num NA
[13:18:57.459]  - Getting '...' globals ... DONE
[13:18:57.459] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.459] List of 8
[13:18:57.459]  $ ...future.FUN:function (x, ...)  
[13:18:57.459]  $ x_FUN        :function (x)  
[13:18:57.459]  $ times        : int 0
[13:18:57.459]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.459]  $ stop_if_not  :function (...)  
[13:18:57.459]  $ dim          : NULL
[13:18:57.459]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.459]  $ ...          : list()
[13:18:57.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.459]  - attr(*, "where")=List of 8
[13:18:57.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.459]   ..$ ...          :<environment: 0x555f7b420230> 
[13:18:57.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.459]  - attr(*, "resolved")= logi FALSE
[13:18:57.459]  - attr(*, "total_size")= num 95472
[13:18:57.465] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.465] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.465] Number of futures (= number of chunks): 1
[13:18:57.465] Launching 1 futures (chunks) ...
[13:18:57.465] Chunk #1 of 1 ...
[13:18:57.466]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.466] getGlobalsAndPackages() ...
[13:18:57.466] Searching for globals...
[13:18:57.466] 
[13:18:57.466] Searching for globals ... DONE
[13:18:57.466] - globals: [0] <none>
[13:18:57.466] getGlobalsAndPackages() ... DONE
[13:18:57.466]    + additional globals found: [n=0] 
[13:18:57.467]    + additional namespaces needed: [n=0] 
[13:18:57.467]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.467]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.467]  - seeds: <none>
[13:18:57.467] getGlobalsAndPackages() ...
[13:18:57.467] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.467] Resolving globals: FALSE
[13:18:57.467] Tweak future expression to call with '...' arguments ...
[13:18:57.467] {
[13:18:57.467]     do.call(function(...) {
[13:18:57.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.467]             on.exit(options(oopts), add = TRUE)
[13:18:57.467]         }
[13:18:57.467]         {
[13:18:57.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.467]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.467]             })
[13:18:57.467]         }
[13:18:57.467]     }, args = future.call.arguments)
[13:18:57.467] }
[13:18:57.468] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.468] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.468] - packages: [1] ‘future.apply’
[13:18:57.468] getGlobalsAndPackages() ... DONE
[13:18:57.469] run() for ‘Future’ ...
[13:18:57.469] - state: ‘created’
[13:18:57.469] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.469] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.470]   - Field: ‘label’
[13:18:57.470]   - Field: ‘local’
[13:18:57.470]   - Field: ‘owner’
[13:18:57.470]   - Field: ‘envir’
[13:18:57.470]   - Field: ‘packages’
[13:18:57.470]   - Field: ‘gc’
[13:18:57.470]   - Field: ‘conditions’
[13:18:57.470]   - Field: ‘expr’
[13:18:57.470]   - Field: ‘uuid’
[13:18:57.470]   - Field: ‘seed’
[13:18:57.470]   - Field: ‘version’
[13:18:57.471]   - Field: ‘result’
[13:18:57.471]   - Field: ‘asynchronous’
[13:18:57.471]   - Field: ‘calls’
[13:18:57.471]   - Field: ‘globals’
[13:18:57.471]   - Field: ‘stdout’
[13:18:57.471]   - Field: ‘earlySignal’
[13:18:57.471]   - Field: ‘lazy’
[13:18:57.471]   - Field: ‘state’
[13:18:57.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.471] - Launch lazy future ...
[13:18:57.472] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.472] Packages needed by future strategies (n = 0): <none>
[13:18:57.472] {
[13:18:57.472]     {
[13:18:57.472]         {
[13:18:57.472]             ...future.startTime <- base::Sys.time()
[13:18:57.472]             {
[13:18:57.472]                 {
[13:18:57.472]                   {
[13:18:57.472]                     {
[13:18:57.472]                       base::local({
[13:18:57.472]                         has_future <- base::requireNamespace("future", 
[13:18:57.472]                           quietly = TRUE)
[13:18:57.472]                         if (has_future) {
[13:18:57.472]                           ns <- base::getNamespace("future")
[13:18:57.472]                           version <- ns[[".package"]][["version"]]
[13:18:57.472]                           if (is.null(version)) 
[13:18:57.472]                             version <- utils::packageVersion("future")
[13:18:57.472]                         }
[13:18:57.472]                         else {
[13:18:57.472]                           version <- NULL
[13:18:57.472]                         }
[13:18:57.472]                         if (!has_future || version < "1.8.0") {
[13:18:57.472]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.472]                             "", base::R.version$version.string), 
[13:18:57.472]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.472]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.472]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.472]                               "release", "version")], collapse = " "), 
[13:18:57.472]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.472]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.472]                             info)
[13:18:57.472]                           info <- base::paste(info, collapse = "; ")
[13:18:57.472]                           if (!has_future) {
[13:18:57.472]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.472]                               info)
[13:18:57.472]                           }
[13:18:57.472]                           else {
[13:18:57.472]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.472]                               info, version)
[13:18:57.472]                           }
[13:18:57.472]                           base::stop(msg)
[13:18:57.472]                         }
[13:18:57.472]                       })
[13:18:57.472]                     }
[13:18:57.472]                     base::local({
[13:18:57.472]                       for (pkg in "future.apply") {
[13:18:57.472]                         base::loadNamespace(pkg)
[13:18:57.472]                         base::library(pkg, character.only = TRUE)
[13:18:57.472]                       }
[13:18:57.472]                     })
[13:18:57.472]                   }
[13:18:57.472]                   options(future.plan = NULL)
[13:18:57.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.472]                 }
[13:18:57.472]                 ...future.workdir <- getwd()
[13:18:57.472]             }
[13:18:57.472]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.472]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.472]         }
[13:18:57.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.472]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.472]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.472]             base::names(...future.oldOptions))
[13:18:57.472]     }
[13:18:57.472]     if (FALSE) {
[13:18:57.472]     }
[13:18:57.472]     else {
[13:18:57.472]         if (TRUE) {
[13:18:57.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.472]                 open = "w")
[13:18:57.472]         }
[13:18:57.472]         else {
[13:18:57.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.472]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.472]         }
[13:18:57.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.472]             base::sink(type = "output", split = FALSE)
[13:18:57.472]             base::close(...future.stdout)
[13:18:57.472]         }, add = TRUE)
[13:18:57.472]     }
[13:18:57.472]     ...future.frame <- base::sys.nframe()
[13:18:57.472]     ...future.conditions <- base::list()
[13:18:57.472]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.472]     if (FALSE) {
[13:18:57.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.472]     }
[13:18:57.472]     ...future.result <- base::tryCatch({
[13:18:57.472]         base::withCallingHandlers({
[13:18:57.472]             ...future.value <- base::withVisible(base::local({
[13:18:57.472]                 do.call(function(...) {
[13:18:57.472]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.472]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.472]                     ...future.globals.maxSize)) {
[13:18:57.472]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.472]                     on.exit(options(oopts), add = TRUE)
[13:18:57.472]                   }
[13:18:57.472]                   {
[13:18:57.472]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.472]                       FUN = function(jj) {
[13:18:57.472]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.472]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.472]                       })
[13:18:57.472]                   }
[13:18:57.472]                 }, args = future.call.arguments)
[13:18:57.472]             }))
[13:18:57.472]             future::FutureResult(value = ...future.value$value, 
[13:18:57.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.472]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.472]                     ...future.globalenv.names))
[13:18:57.472]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.472]         }, condition = base::local({
[13:18:57.472]             c <- base::c
[13:18:57.472]             inherits <- base::inherits
[13:18:57.472]             invokeRestart <- base::invokeRestart
[13:18:57.472]             length <- base::length
[13:18:57.472]             list <- base::list
[13:18:57.472]             seq.int <- base::seq.int
[13:18:57.472]             signalCondition <- base::signalCondition
[13:18:57.472]             sys.calls <- base::sys.calls
[13:18:57.472]             `[[` <- base::`[[`
[13:18:57.472]             `+` <- base::`+`
[13:18:57.472]             `<<-` <- base::`<<-`
[13:18:57.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.472]                   3L)]
[13:18:57.472]             }
[13:18:57.472]             function(cond) {
[13:18:57.472]                 is_error <- inherits(cond, "error")
[13:18:57.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.472]                   NULL)
[13:18:57.472]                 if (is_error) {
[13:18:57.472]                   sessionInformation <- function() {
[13:18:57.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.472]                       search = base::search(), system = base::Sys.info())
[13:18:57.472]                   }
[13:18:57.472]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.472]                     cond$call), session = sessionInformation(), 
[13:18:57.472]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.472]                   signalCondition(cond)
[13:18:57.472]                 }
[13:18:57.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.472]                 "immediateCondition"))) {
[13:18:57.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.472]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.472]                   if (TRUE && !signal) {
[13:18:57.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.472]                     {
[13:18:57.472]                       inherits <- base::inherits
[13:18:57.472]                       invokeRestart <- base::invokeRestart
[13:18:57.472]                       is.null <- base::is.null
[13:18:57.472]                       muffled <- FALSE
[13:18:57.472]                       if (inherits(cond, "message")) {
[13:18:57.472]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.472]                         if (muffled) 
[13:18:57.472]                           invokeRestart("muffleMessage")
[13:18:57.472]                       }
[13:18:57.472]                       else if (inherits(cond, "warning")) {
[13:18:57.472]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.472]                         if (muffled) 
[13:18:57.472]                           invokeRestart("muffleWarning")
[13:18:57.472]                       }
[13:18:57.472]                       else if (inherits(cond, "condition")) {
[13:18:57.472]                         if (!is.null(pattern)) {
[13:18:57.472]                           computeRestarts <- base::computeRestarts
[13:18:57.472]                           grepl <- base::grepl
[13:18:57.472]                           restarts <- computeRestarts(cond)
[13:18:57.472]                           for (restart in restarts) {
[13:18:57.472]                             name <- restart$name
[13:18:57.472]                             if (is.null(name)) 
[13:18:57.472]                               next
[13:18:57.472]                             if (!grepl(pattern, name)) 
[13:18:57.472]                               next
[13:18:57.472]                             invokeRestart(restart)
[13:18:57.472]                             muffled <- TRUE
[13:18:57.472]                             break
[13:18:57.472]                           }
[13:18:57.472]                         }
[13:18:57.472]                       }
[13:18:57.472]                       invisible(muffled)
[13:18:57.472]                     }
[13:18:57.472]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.472]                   }
[13:18:57.472]                 }
[13:18:57.472]                 else {
[13:18:57.472]                   if (TRUE) {
[13:18:57.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.472]                     {
[13:18:57.472]                       inherits <- base::inherits
[13:18:57.472]                       invokeRestart <- base::invokeRestart
[13:18:57.472]                       is.null <- base::is.null
[13:18:57.472]                       muffled <- FALSE
[13:18:57.472]                       if (inherits(cond, "message")) {
[13:18:57.472]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.472]                         if (muffled) 
[13:18:57.472]                           invokeRestart("muffleMessage")
[13:18:57.472]                       }
[13:18:57.472]                       else if (inherits(cond, "warning")) {
[13:18:57.472]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.472]                         if (muffled) 
[13:18:57.472]                           invokeRestart("muffleWarning")
[13:18:57.472]                       }
[13:18:57.472]                       else if (inherits(cond, "condition")) {
[13:18:57.472]                         if (!is.null(pattern)) {
[13:18:57.472]                           computeRestarts <- base::computeRestarts
[13:18:57.472]                           grepl <- base::grepl
[13:18:57.472]                           restarts <- computeRestarts(cond)
[13:18:57.472]                           for (restart in restarts) {
[13:18:57.472]                             name <- restart$name
[13:18:57.472]                             if (is.null(name)) 
[13:18:57.472]                               next
[13:18:57.472]                             if (!grepl(pattern, name)) 
[13:18:57.472]                               next
[13:18:57.472]                             invokeRestart(restart)
[13:18:57.472]                             muffled <- TRUE
[13:18:57.472]                             break
[13:18:57.472]                           }
[13:18:57.472]                         }
[13:18:57.472]                       }
[13:18:57.472]                       invisible(muffled)
[13:18:57.472]                     }
[13:18:57.472]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.472]                   }
[13:18:57.472]                 }
[13:18:57.472]             }
[13:18:57.472]         }))
[13:18:57.472]     }, error = function(ex) {
[13:18:57.472]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.472]                 ...future.rng), started = ...future.startTime, 
[13:18:57.472]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.472]             version = "1.8"), class = "FutureResult")
[13:18:57.472]     }, finally = {
[13:18:57.472]         if (!identical(...future.workdir, getwd())) 
[13:18:57.472]             setwd(...future.workdir)
[13:18:57.472]         {
[13:18:57.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.472]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.472]             }
[13:18:57.472]             base::options(...future.oldOptions)
[13:18:57.472]             if (.Platform$OS.type == "windows") {
[13:18:57.472]                 old_names <- names(...future.oldEnvVars)
[13:18:57.472]                 envs <- base::Sys.getenv()
[13:18:57.472]                 names <- names(envs)
[13:18:57.472]                 common <- intersect(names, old_names)
[13:18:57.472]                 added <- setdiff(names, old_names)
[13:18:57.472]                 removed <- setdiff(old_names, names)
[13:18:57.472]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.472]                   envs[common]]
[13:18:57.472]                 NAMES <- toupper(changed)
[13:18:57.472]                 args <- list()
[13:18:57.472]                 for (kk in seq_along(NAMES)) {
[13:18:57.472]                   name <- changed[[kk]]
[13:18:57.472]                   NAME <- NAMES[[kk]]
[13:18:57.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.472]                     next
[13:18:57.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.472]                 }
[13:18:57.472]                 NAMES <- toupper(added)
[13:18:57.472]                 for (kk in seq_along(NAMES)) {
[13:18:57.472]                   name <- added[[kk]]
[13:18:57.472]                   NAME <- NAMES[[kk]]
[13:18:57.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.472]                     next
[13:18:57.472]                   args[[name]] <- ""
[13:18:57.472]                 }
[13:18:57.472]                 NAMES <- toupper(removed)
[13:18:57.472]                 for (kk in seq_along(NAMES)) {
[13:18:57.472]                   name <- removed[[kk]]
[13:18:57.472]                   NAME <- NAMES[[kk]]
[13:18:57.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.472]                     next
[13:18:57.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.472]                 }
[13:18:57.472]                 if (length(args) > 0) 
[13:18:57.472]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.472]             }
[13:18:57.472]             else {
[13:18:57.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.472]             }
[13:18:57.472]             {
[13:18:57.472]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.472]                   0L) {
[13:18:57.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.472]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.472]                   base::options(opts)
[13:18:57.472]                 }
[13:18:57.472]                 {
[13:18:57.472]                   {
[13:18:57.472]                     NULL
[13:18:57.472]                     RNGkind("Mersenne-Twister")
[13:18:57.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.472]                       inherits = FALSE)
[13:18:57.472]                   }
[13:18:57.472]                   options(future.plan = NULL)
[13:18:57.472]                   if (is.na(NA_character_)) 
[13:18:57.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.472]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.472]                   {
[13:18:57.472]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.472]                     if (!future$lazy) 
[13:18:57.472]                       future <- run(future)
[13:18:57.472]                     invisible(future)
[13:18:57.472]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.472]                 }
[13:18:57.472]             }
[13:18:57.472]         }
[13:18:57.472]     })
[13:18:57.472]     if (TRUE) {
[13:18:57.472]         base::sink(type = "output", split = FALSE)
[13:18:57.472]         if (TRUE) {
[13:18:57.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.472]         }
[13:18:57.472]         else {
[13:18:57.472]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.472]         }
[13:18:57.472]         base::close(...future.stdout)
[13:18:57.472]         ...future.stdout <- NULL
[13:18:57.472]     }
[13:18:57.472]     ...future.result$conditions <- ...future.conditions
[13:18:57.472]     ...future.result$finished <- base::Sys.time()
[13:18:57.472]     ...future.result
[13:18:57.472] }
[13:18:57.474] assign_globals() ...
[13:18:57.474] List of 11
[13:18:57.474]  $ ...future.FUN            :function (x, ...)  
[13:18:57.474]  $ x_FUN                    :function (x)  
[13:18:57.474]  $ times                    : int 0
[13:18:57.474]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.474]  $ stop_if_not              :function (...)  
[13:18:57.474]  $ dim                      : NULL
[13:18:57.474]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.474]  $ future.call.arguments    : list()
[13:18:57.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.474]  $ ...future.elements_ii    :List of 10
[13:18:57.474]   ..$ : int 1
[13:18:57.474]   ..$ : int 2
[13:18:57.474]   ..$ : int 3
[13:18:57.474]   ..$ : int 4
[13:18:57.474]   ..$ : int 5
[13:18:57.474]   ..$ : int 6
[13:18:57.474]   ..$ : int 7
[13:18:57.474]   ..$ : int 8
[13:18:57.474]   ..$ : int 9
[13:18:57.474]   ..$ : int 10
[13:18:57.474]  $ ...future.seeds_ii       : NULL
[13:18:57.474]  $ ...future.globals.maxSize: NULL
[13:18:57.474]  - attr(*, "resolved")= logi FALSE
[13:18:57.474]  - attr(*, "total_size")= num 95472
[13:18:57.474]  - attr(*, "where")=List of 11
[13:18:57.474]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.474]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.474]  - attr(*, "already-done")= logi TRUE
[13:18:57.486] - copied ‘...future.FUN’ to environment
[13:18:57.486] - reassign environment for ‘x_FUN’
[13:18:57.486] - copied ‘x_FUN’ to environment
[13:18:57.486] - copied ‘times’ to environment
[13:18:57.486] - copied ‘stopf’ to environment
[13:18:57.487] - copied ‘stop_if_not’ to environment
[13:18:57.487] - copied ‘dim’ to environment
[13:18:57.487] - copied ‘valid_types’ to environment
[13:18:57.487] - copied ‘future.call.arguments’ to environment
[13:18:57.487] - copied ‘...future.elements_ii’ to environment
[13:18:57.487] - copied ‘...future.seeds_ii’ to environment
[13:18:57.487] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.487] assign_globals() ... done
[13:18:57.488] plan(): Setting new future strategy stack:
[13:18:57.488] List of future strategies:
[13:18:57.488] 1. sequential:
[13:18:57.488]    - args: function (..., envir = parent.frame())
[13:18:57.488]    - tweaked: FALSE
[13:18:57.488]    - call: NULL
[13:18:57.488] plan(): nbrOfWorkers() = 1
[13:18:57.489] plan(): Setting new future strategy stack:
[13:18:57.489] List of future strategies:
[13:18:57.489] 1. sequential:
[13:18:57.489]    - args: function (..., envir = parent.frame())
[13:18:57.489]    - tweaked: FALSE
[13:18:57.489]    - call: plan(strategy)
[13:18:57.489] plan(): nbrOfWorkers() = 1
[13:18:57.490] SequentialFuture started (and completed)
[13:18:57.490] - Launch lazy future ... done
[13:18:57.490] run() for ‘SequentialFuture’ ... done
[13:18:57.490] Created future:
[13:18:57.490] SequentialFuture:
[13:18:57.490] Label: ‘future_vapply-1’
[13:18:57.490] Expression:
[13:18:57.490] {
[13:18:57.490]     do.call(function(...) {
[13:18:57.490]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.490]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.490]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.490]             on.exit(options(oopts), add = TRUE)
[13:18:57.490]         }
[13:18:57.490]         {
[13:18:57.490]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.490]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.490]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.490]             })
[13:18:57.490]         }
[13:18:57.490]     }, args = future.call.arguments)
[13:18:57.490] }
[13:18:57.490] Lazy evaluation: FALSE
[13:18:57.490] Asynchronous evaluation: FALSE
[13:18:57.490] Local evaluation: TRUE
[13:18:57.490] Environment: R_GlobalEnv
[13:18:57.490] Capture standard output: TRUE
[13:18:57.490] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.490] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.490] Packages: 1 packages (‘future.apply’)
[13:18:57.490] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.490] Resolved: TRUE
[13:18:57.490] Value: 480 bytes of class ‘list’
[13:18:57.490] Early signaling: FALSE
[13:18:57.490] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.490] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.491] Chunk #1 of 1 ... DONE
[13:18:57.491] Launching 1 futures (chunks) ... DONE
[13:18:57.491] Resolving 1 futures (chunks) ...
[13:18:57.492] resolve() on list ...
[13:18:57.492]  recursive: 0
[13:18:57.492]  length: 1
[13:18:57.492] 
[13:18:57.492] resolved() for ‘SequentialFuture’ ...
[13:18:57.492] - state: ‘finished’
[13:18:57.492] - run: TRUE
[13:18:57.492] - result: ‘FutureResult’
[13:18:57.492] resolved() for ‘SequentialFuture’ ... done
[13:18:57.492] Future #1
[13:18:57.493] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.493] - nx: 1
[13:18:57.493] - relay: TRUE
[13:18:57.493] - stdout: TRUE
[13:18:57.493] - signal: TRUE
[13:18:57.493] - resignal: FALSE
[13:18:57.493] - force: TRUE
[13:18:57.493] - relayed: [n=1] FALSE
[13:18:57.493] - queued futures: [n=1] FALSE
[13:18:57.493]  - until=1
[13:18:57.493]  - relaying element #1
[13:18:57.494] - relayed: [n=1] TRUE
[13:18:57.494] - queued futures: [n=1] TRUE
[13:18:57.494] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.494]  length: 0 (resolved future 1)
[13:18:57.494] Relaying remaining futures
[13:18:57.494] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.494] - nx: 1
[13:18:57.494] - relay: TRUE
[13:18:57.494] - stdout: TRUE
[13:18:57.494] - signal: TRUE
[13:18:57.495] - resignal: FALSE
[13:18:57.495] - force: TRUE
[13:18:57.495] - relayed: [n=1] TRUE
[13:18:57.495] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.495] - relayed: [n=1] TRUE
[13:18:57.495] - queued futures: [n=1] TRUE
[13:18:57.495] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.495] resolve() on list ... DONE
[13:18:57.495]  - Number of value chunks collected: 1
[13:18:57.495] Resolving 1 futures (chunks) ... DONE
[13:18:57.496] Reducing values from 1 chunks ...
[13:18:57.496]  - Number of values collected after concatenation: 10
[13:18:57.496]  - Number of values expected: 10
[13:18:57.496] Reducing values from 1 chunks ... DONE
[13:18:57.496] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:18:57.497] future_lapply() ...
[13:18:57.499] Number of chunks: 1
[13:18:57.499] getGlobalsAndPackagesXApply() ...
[13:18:57.499]  - future.globals: TRUE
[13:18:57.499] getGlobalsAndPackages() ...
[13:18:57.499] Searching for globals...
[13:18:57.503] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:18:57.504] Searching for globals ... DONE
[13:18:57.505] Resolving globals: FALSE
[13:18:57.505] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:18:57.506] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.506] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.506] - packages: [1] ‘future.apply’
[13:18:57.506] getGlobalsAndPackages() ... DONE
[13:18:57.506]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.506]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.507] Finding globals ... DONE
[13:18:57.507]  - use_args: TRUE
[13:18:57.507]  - Getting '...' globals ...
[13:18:57.507] resolve() on list ...
[13:18:57.507]  recursive: 0
[13:18:57.507]  length: 1
[13:18:57.507]  elements: ‘...’
[13:18:57.507]  length: 0 (resolved future 1)
[13:18:57.508] resolve() on list ... DONE
[13:18:57.508]    - '...' content: [n=0] 
[13:18:57.508] List of 1
[13:18:57.508]  $ ...: list()
[13:18:57.508]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.508]  - attr(*, "where")=List of 1
[13:18:57.508]   ..$ ...:<environment: 0x555f7b7fd260> 
[13:18:57.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.508]  - attr(*, "resolved")= logi TRUE
[13:18:57.508]  - attr(*, "total_size")= num NA
[13:18:57.510]  - Getting '...' globals ... DONE
[13:18:57.511] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.511] List of 8
[13:18:57.511]  $ ...future.FUN:function (x, ...)  
[13:18:57.511]  $ x_FUN        :function (x)  
[13:18:57.511]  $ times        : int 0
[13:18:57.511]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.511]  $ stop_if_not  :function (...)  
[13:18:57.511]  $ dim          : NULL
[13:18:57.511]  $ valid_types  : chr [1:2] "logical" "integer"
[13:18:57.511]  $ ...          : list()
[13:18:57.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.511]  - attr(*, "where")=List of 8
[13:18:57.511]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.511]   ..$ ...          :<environment: 0x555f7b7fd260> 
[13:18:57.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.511]  - attr(*, "resolved")= logi FALSE
[13:18:57.511]  - attr(*, "total_size")= num 95400
[13:18:57.516] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.516] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.516] Number of futures (= number of chunks): 1
[13:18:57.517] Launching 1 futures (chunks) ...
[13:18:57.517] Chunk #1 of 1 ...
[13:18:57.517]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.517] getGlobalsAndPackages() ...
[13:18:57.517] Searching for globals...
[13:18:57.517] 
[13:18:57.517] Searching for globals ... DONE
[13:18:57.517] - globals: [0] <none>
[13:18:57.518] getGlobalsAndPackages() ... DONE
[13:18:57.518]    + additional globals found: [n=0] 
[13:18:57.518]    + additional namespaces needed: [n=0] 
[13:18:57.518]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.518]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.518]  - seeds: <none>
[13:18:57.518] getGlobalsAndPackages() ...
[13:18:57.518] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.518] Resolving globals: FALSE
[13:18:57.518] Tweak future expression to call with '...' arguments ...
[13:18:57.519] {
[13:18:57.519]     do.call(function(...) {
[13:18:57.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.519]             on.exit(options(oopts), add = TRUE)
[13:18:57.519]         }
[13:18:57.519]         {
[13:18:57.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.519]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.519]             })
[13:18:57.519]         }
[13:18:57.519]     }, args = future.call.arguments)
[13:18:57.519] }
[13:18:57.519] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.519] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.520] - packages: [1] ‘future.apply’
[13:18:57.520] getGlobalsAndPackages() ... DONE
[13:18:57.520] run() for ‘Future’ ...
[13:18:57.520] - state: ‘created’
[13:18:57.520] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.521]   - Field: ‘label’
[13:18:57.521]   - Field: ‘local’
[13:18:57.521]   - Field: ‘owner’
[13:18:57.521]   - Field: ‘envir’
[13:18:57.521]   - Field: ‘packages’
[13:18:57.521]   - Field: ‘gc’
[13:18:57.521]   - Field: ‘conditions’
[13:18:57.521]   - Field: ‘expr’
[13:18:57.521]   - Field: ‘uuid’
[13:18:57.522]   - Field: ‘seed’
[13:18:57.522]   - Field: ‘version’
[13:18:57.522]   - Field: ‘result’
[13:18:57.522]   - Field: ‘asynchronous’
[13:18:57.522]   - Field: ‘calls’
[13:18:57.522]   - Field: ‘globals’
[13:18:57.522]   - Field: ‘stdout’
[13:18:57.522]   - Field: ‘earlySignal’
[13:18:57.522]   - Field: ‘lazy’
[13:18:57.522]   - Field: ‘state’
[13:18:57.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.523] - Launch lazy future ...
[13:18:57.523] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.523] Packages needed by future strategies (n = 0): <none>
[13:18:57.523] {
[13:18:57.523]     {
[13:18:57.523]         {
[13:18:57.523]             ...future.startTime <- base::Sys.time()
[13:18:57.523]             {
[13:18:57.523]                 {
[13:18:57.523]                   {
[13:18:57.523]                     {
[13:18:57.523]                       base::local({
[13:18:57.523]                         has_future <- base::requireNamespace("future", 
[13:18:57.523]                           quietly = TRUE)
[13:18:57.523]                         if (has_future) {
[13:18:57.523]                           ns <- base::getNamespace("future")
[13:18:57.523]                           version <- ns[[".package"]][["version"]]
[13:18:57.523]                           if (is.null(version)) 
[13:18:57.523]                             version <- utils::packageVersion("future")
[13:18:57.523]                         }
[13:18:57.523]                         else {
[13:18:57.523]                           version <- NULL
[13:18:57.523]                         }
[13:18:57.523]                         if (!has_future || version < "1.8.0") {
[13:18:57.523]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.523]                             "", base::R.version$version.string), 
[13:18:57.523]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.523]                               "release", "version")], collapse = " "), 
[13:18:57.523]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.523]                             info)
[13:18:57.523]                           info <- base::paste(info, collapse = "; ")
[13:18:57.523]                           if (!has_future) {
[13:18:57.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.523]                               info)
[13:18:57.523]                           }
[13:18:57.523]                           else {
[13:18:57.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.523]                               info, version)
[13:18:57.523]                           }
[13:18:57.523]                           base::stop(msg)
[13:18:57.523]                         }
[13:18:57.523]                       })
[13:18:57.523]                     }
[13:18:57.523]                     base::local({
[13:18:57.523]                       for (pkg in "future.apply") {
[13:18:57.523]                         base::loadNamespace(pkg)
[13:18:57.523]                         base::library(pkg, character.only = TRUE)
[13:18:57.523]                       }
[13:18:57.523]                     })
[13:18:57.523]                   }
[13:18:57.523]                   options(future.plan = NULL)
[13:18:57.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.523]                 }
[13:18:57.523]                 ...future.workdir <- getwd()
[13:18:57.523]             }
[13:18:57.523]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.523]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.523]         }
[13:18:57.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.523]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.523]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.523]             base::names(...future.oldOptions))
[13:18:57.523]     }
[13:18:57.523]     if (FALSE) {
[13:18:57.523]     }
[13:18:57.523]     else {
[13:18:57.523]         if (TRUE) {
[13:18:57.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.523]                 open = "w")
[13:18:57.523]         }
[13:18:57.523]         else {
[13:18:57.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.523]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.523]         }
[13:18:57.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.523]             base::sink(type = "output", split = FALSE)
[13:18:57.523]             base::close(...future.stdout)
[13:18:57.523]         }, add = TRUE)
[13:18:57.523]     }
[13:18:57.523]     ...future.frame <- base::sys.nframe()
[13:18:57.523]     ...future.conditions <- base::list()
[13:18:57.523]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.523]     if (FALSE) {
[13:18:57.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.523]     }
[13:18:57.523]     ...future.result <- base::tryCatch({
[13:18:57.523]         base::withCallingHandlers({
[13:18:57.523]             ...future.value <- base::withVisible(base::local({
[13:18:57.523]                 do.call(function(...) {
[13:18:57.523]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.523]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.523]                     ...future.globals.maxSize)) {
[13:18:57.523]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.523]                     on.exit(options(oopts), add = TRUE)
[13:18:57.523]                   }
[13:18:57.523]                   {
[13:18:57.523]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.523]                       FUN = function(jj) {
[13:18:57.523]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.523]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.523]                       })
[13:18:57.523]                   }
[13:18:57.523]                 }, args = future.call.arguments)
[13:18:57.523]             }))
[13:18:57.523]             future::FutureResult(value = ...future.value$value, 
[13:18:57.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.523]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.523]                     ...future.globalenv.names))
[13:18:57.523]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.523]         }, condition = base::local({
[13:18:57.523]             c <- base::c
[13:18:57.523]             inherits <- base::inherits
[13:18:57.523]             invokeRestart <- base::invokeRestart
[13:18:57.523]             length <- base::length
[13:18:57.523]             list <- base::list
[13:18:57.523]             seq.int <- base::seq.int
[13:18:57.523]             signalCondition <- base::signalCondition
[13:18:57.523]             sys.calls <- base::sys.calls
[13:18:57.523]             `[[` <- base::`[[`
[13:18:57.523]             `+` <- base::`+`
[13:18:57.523]             `<<-` <- base::`<<-`
[13:18:57.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.523]                   3L)]
[13:18:57.523]             }
[13:18:57.523]             function(cond) {
[13:18:57.523]                 is_error <- inherits(cond, "error")
[13:18:57.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.523]                   NULL)
[13:18:57.523]                 if (is_error) {
[13:18:57.523]                   sessionInformation <- function() {
[13:18:57.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.523]                       search = base::search(), system = base::Sys.info())
[13:18:57.523]                   }
[13:18:57.523]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.523]                     cond$call), session = sessionInformation(), 
[13:18:57.523]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.523]                   signalCondition(cond)
[13:18:57.523]                 }
[13:18:57.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.523]                 "immediateCondition"))) {
[13:18:57.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.523]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.523]                   if (TRUE && !signal) {
[13:18:57.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.523]                     {
[13:18:57.523]                       inherits <- base::inherits
[13:18:57.523]                       invokeRestart <- base::invokeRestart
[13:18:57.523]                       is.null <- base::is.null
[13:18:57.523]                       muffled <- FALSE
[13:18:57.523]                       if (inherits(cond, "message")) {
[13:18:57.523]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.523]                         if (muffled) 
[13:18:57.523]                           invokeRestart("muffleMessage")
[13:18:57.523]                       }
[13:18:57.523]                       else if (inherits(cond, "warning")) {
[13:18:57.523]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.523]                         if (muffled) 
[13:18:57.523]                           invokeRestart("muffleWarning")
[13:18:57.523]                       }
[13:18:57.523]                       else if (inherits(cond, "condition")) {
[13:18:57.523]                         if (!is.null(pattern)) {
[13:18:57.523]                           computeRestarts <- base::computeRestarts
[13:18:57.523]                           grepl <- base::grepl
[13:18:57.523]                           restarts <- computeRestarts(cond)
[13:18:57.523]                           for (restart in restarts) {
[13:18:57.523]                             name <- restart$name
[13:18:57.523]                             if (is.null(name)) 
[13:18:57.523]                               next
[13:18:57.523]                             if (!grepl(pattern, name)) 
[13:18:57.523]                               next
[13:18:57.523]                             invokeRestart(restart)
[13:18:57.523]                             muffled <- TRUE
[13:18:57.523]                             break
[13:18:57.523]                           }
[13:18:57.523]                         }
[13:18:57.523]                       }
[13:18:57.523]                       invisible(muffled)
[13:18:57.523]                     }
[13:18:57.523]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.523]                   }
[13:18:57.523]                 }
[13:18:57.523]                 else {
[13:18:57.523]                   if (TRUE) {
[13:18:57.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.523]                     {
[13:18:57.523]                       inherits <- base::inherits
[13:18:57.523]                       invokeRestart <- base::invokeRestart
[13:18:57.523]                       is.null <- base::is.null
[13:18:57.523]                       muffled <- FALSE
[13:18:57.523]                       if (inherits(cond, "message")) {
[13:18:57.523]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.523]                         if (muffled) 
[13:18:57.523]                           invokeRestart("muffleMessage")
[13:18:57.523]                       }
[13:18:57.523]                       else if (inherits(cond, "warning")) {
[13:18:57.523]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.523]                         if (muffled) 
[13:18:57.523]                           invokeRestart("muffleWarning")
[13:18:57.523]                       }
[13:18:57.523]                       else if (inherits(cond, "condition")) {
[13:18:57.523]                         if (!is.null(pattern)) {
[13:18:57.523]                           computeRestarts <- base::computeRestarts
[13:18:57.523]                           grepl <- base::grepl
[13:18:57.523]                           restarts <- computeRestarts(cond)
[13:18:57.523]                           for (restart in restarts) {
[13:18:57.523]                             name <- restart$name
[13:18:57.523]                             if (is.null(name)) 
[13:18:57.523]                               next
[13:18:57.523]                             if (!grepl(pattern, name)) 
[13:18:57.523]                               next
[13:18:57.523]                             invokeRestart(restart)
[13:18:57.523]                             muffled <- TRUE
[13:18:57.523]                             break
[13:18:57.523]                           }
[13:18:57.523]                         }
[13:18:57.523]                       }
[13:18:57.523]                       invisible(muffled)
[13:18:57.523]                     }
[13:18:57.523]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.523]                   }
[13:18:57.523]                 }
[13:18:57.523]             }
[13:18:57.523]         }))
[13:18:57.523]     }, error = function(ex) {
[13:18:57.523]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.523]                 ...future.rng), started = ...future.startTime, 
[13:18:57.523]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.523]             version = "1.8"), class = "FutureResult")
[13:18:57.523]     }, finally = {
[13:18:57.523]         if (!identical(...future.workdir, getwd())) 
[13:18:57.523]             setwd(...future.workdir)
[13:18:57.523]         {
[13:18:57.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.523]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.523]             }
[13:18:57.523]             base::options(...future.oldOptions)
[13:18:57.523]             if (.Platform$OS.type == "windows") {
[13:18:57.523]                 old_names <- names(...future.oldEnvVars)
[13:18:57.523]                 envs <- base::Sys.getenv()
[13:18:57.523]                 names <- names(envs)
[13:18:57.523]                 common <- intersect(names, old_names)
[13:18:57.523]                 added <- setdiff(names, old_names)
[13:18:57.523]                 removed <- setdiff(old_names, names)
[13:18:57.523]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.523]                   envs[common]]
[13:18:57.523]                 NAMES <- toupper(changed)
[13:18:57.523]                 args <- list()
[13:18:57.523]                 for (kk in seq_along(NAMES)) {
[13:18:57.523]                   name <- changed[[kk]]
[13:18:57.523]                   NAME <- NAMES[[kk]]
[13:18:57.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.523]                     next
[13:18:57.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.523]                 }
[13:18:57.523]                 NAMES <- toupper(added)
[13:18:57.523]                 for (kk in seq_along(NAMES)) {
[13:18:57.523]                   name <- added[[kk]]
[13:18:57.523]                   NAME <- NAMES[[kk]]
[13:18:57.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.523]                     next
[13:18:57.523]                   args[[name]] <- ""
[13:18:57.523]                 }
[13:18:57.523]                 NAMES <- toupper(removed)
[13:18:57.523]                 for (kk in seq_along(NAMES)) {
[13:18:57.523]                   name <- removed[[kk]]
[13:18:57.523]                   NAME <- NAMES[[kk]]
[13:18:57.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.523]                     next
[13:18:57.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.523]                 }
[13:18:57.523]                 if (length(args) > 0) 
[13:18:57.523]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.523]             }
[13:18:57.523]             else {
[13:18:57.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.523]             }
[13:18:57.523]             {
[13:18:57.523]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.523]                   0L) {
[13:18:57.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.523]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.523]                   base::options(opts)
[13:18:57.523]                 }
[13:18:57.523]                 {
[13:18:57.523]                   {
[13:18:57.523]                     NULL
[13:18:57.523]                     RNGkind("Mersenne-Twister")
[13:18:57.523]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.523]                       inherits = FALSE)
[13:18:57.523]                   }
[13:18:57.523]                   options(future.plan = NULL)
[13:18:57.523]                   if (is.na(NA_character_)) 
[13:18:57.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.523]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.523]                   {
[13:18:57.523]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.523]                     if (!future$lazy) 
[13:18:57.523]                       future <- run(future)
[13:18:57.523]                     invisible(future)
[13:18:57.523]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.523]                 }
[13:18:57.523]             }
[13:18:57.523]         }
[13:18:57.523]     })
[13:18:57.523]     if (TRUE) {
[13:18:57.523]         base::sink(type = "output", split = FALSE)
[13:18:57.523]         if (TRUE) {
[13:18:57.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.523]         }
[13:18:57.523]         else {
[13:18:57.523]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.523]         }
[13:18:57.523]         base::close(...future.stdout)
[13:18:57.523]         ...future.stdout <- NULL
[13:18:57.523]     }
[13:18:57.523]     ...future.result$conditions <- ...future.conditions
[13:18:57.523]     ...future.result$finished <- base::Sys.time()
[13:18:57.523]     ...future.result
[13:18:57.523] }
[13:18:57.525] assign_globals() ...
[13:18:57.525] List of 11
[13:18:57.525]  $ ...future.FUN            :function (x, ...)  
[13:18:57.525]  $ x_FUN                    :function (x)  
[13:18:57.525]  $ times                    : int 0
[13:18:57.525]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.525]  $ stop_if_not              :function (...)  
[13:18:57.525]  $ dim                      : NULL
[13:18:57.525]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:57.525]  $ future.call.arguments    : list()
[13:18:57.525]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.525]  $ ...future.elements_ii    :List of 10
[13:18:57.525]   ..$ : int 1
[13:18:57.525]   ..$ : int 2
[13:18:57.525]   ..$ : int 3
[13:18:57.525]   ..$ : int 4
[13:18:57.525]   ..$ : int 5
[13:18:57.525]   ..$ : int 6
[13:18:57.525]   ..$ : int 7
[13:18:57.525]   ..$ : int 8
[13:18:57.525]   ..$ : int 9
[13:18:57.525]   ..$ : int 10
[13:18:57.525]  $ ...future.seeds_ii       : NULL
[13:18:57.525]  $ ...future.globals.maxSize: NULL
[13:18:57.525]  - attr(*, "resolved")= logi FALSE
[13:18:57.525]  - attr(*, "total_size")= num 95400
[13:18:57.525]  - attr(*, "where")=List of 11
[13:18:57.525]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.525]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.525]  - attr(*, "already-done")= logi TRUE
[13:18:57.537] - copied ‘...future.FUN’ to environment
[13:18:57.538] - reassign environment for ‘x_FUN’
[13:18:57.538] - copied ‘x_FUN’ to environment
[13:18:57.538] - copied ‘times’ to environment
[13:18:57.538] - copied ‘stopf’ to environment
[13:18:57.538] - copied ‘stop_if_not’ to environment
[13:18:57.538] - copied ‘dim’ to environment
[13:18:57.538] - copied ‘valid_types’ to environment
[13:18:57.538] - copied ‘future.call.arguments’ to environment
[13:18:57.538] - copied ‘...future.elements_ii’ to environment
[13:18:57.539] - copied ‘...future.seeds_ii’ to environment
[13:18:57.539] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.539] assign_globals() ... done
[13:18:57.539] plan(): Setting new future strategy stack:
[13:18:57.539] List of future strategies:
[13:18:57.539] 1. sequential:
[13:18:57.539]    - args: function (..., envir = parent.frame())
[13:18:57.539]    - tweaked: FALSE
[13:18:57.539]    - call: NULL
[13:18:57.540] plan(): nbrOfWorkers() = 1
[13:18:57.541] plan(): Setting new future strategy stack:
[13:18:57.541] List of future strategies:
[13:18:57.541] 1. sequential:
[13:18:57.541]    - args: function (..., envir = parent.frame())
[13:18:57.541]    - tweaked: FALSE
[13:18:57.541]    - call: plan(strategy)
[13:18:57.541] plan(): nbrOfWorkers() = 1
[13:18:57.541] SequentialFuture started (and completed)
[13:18:57.542] - Launch lazy future ... done
[13:18:57.542] run() for ‘SequentialFuture’ ... done
[13:18:57.542] Created future:
[13:18:57.542] SequentialFuture:
[13:18:57.542] Label: ‘future_vapply-1’
[13:18:57.542] Expression:
[13:18:57.542] {
[13:18:57.542]     do.call(function(...) {
[13:18:57.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.542]             on.exit(options(oopts), add = TRUE)
[13:18:57.542]         }
[13:18:57.542]         {
[13:18:57.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.542]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.542]             })
[13:18:57.542]         }
[13:18:57.542]     }, args = future.call.arguments)
[13:18:57.542] }
[13:18:57.542] Lazy evaluation: FALSE
[13:18:57.542] Asynchronous evaluation: FALSE
[13:18:57.542] Local evaluation: TRUE
[13:18:57.542] Environment: R_GlobalEnv
[13:18:57.542] Capture standard output: TRUE
[13:18:57.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.542] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.542] Packages: 1 packages (‘future.apply’)
[13:18:57.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.542] Resolved: TRUE
[13:18:57.542] Value: 480 bytes of class ‘list’
[13:18:57.542] Early signaling: FALSE
[13:18:57.542] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.542] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.543] Chunk #1 of 1 ... DONE
[13:18:57.543] Launching 1 futures (chunks) ... DONE
[13:18:57.544] Resolving 1 futures (chunks) ...
[13:18:57.544] resolve() on list ...
[13:18:57.544]  recursive: 0
[13:18:57.544]  length: 1
[13:18:57.544] 
[13:18:57.544] resolved() for ‘SequentialFuture’ ...
[13:18:57.544] - state: ‘finished’
[13:18:57.544] - run: TRUE
[13:18:57.544] - result: ‘FutureResult’
[13:18:57.544] resolved() for ‘SequentialFuture’ ... done
[13:18:57.545] Future #1
[13:18:57.545] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.545] - nx: 1
[13:18:57.545] - relay: TRUE
[13:18:57.545] - stdout: TRUE
[13:18:57.545] - signal: TRUE
[13:18:57.545] - resignal: FALSE
[13:18:57.545] - force: TRUE
[13:18:57.545] - relayed: [n=1] FALSE
[13:18:57.545] - queued futures: [n=1] FALSE
[13:18:57.546]  - until=1
[13:18:57.546]  - relaying element #1
[13:18:57.546] - relayed: [n=1] TRUE
[13:18:57.546] - queued futures: [n=1] TRUE
[13:18:57.546] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.546]  length: 0 (resolved future 1)
[13:18:57.546] Relaying remaining futures
[13:18:57.546] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.546] - nx: 1
[13:18:57.546] - relay: TRUE
[13:18:57.547] - stdout: TRUE
[13:18:57.547] - signal: TRUE
[13:18:57.547] - resignal: FALSE
[13:18:57.547] - force: TRUE
[13:18:57.547] - relayed: [n=1] TRUE
[13:18:57.547] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.547] - relayed: [n=1] TRUE
[13:18:57.547] - queued futures: [n=1] TRUE
[13:18:57.547] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.547] resolve() on list ... DONE
[13:18:57.548]  - Number of value chunks collected: 1
[13:18:57.548] Resolving 1 futures (chunks) ... DONE
[13:18:57.548] Reducing values from 1 chunks ...
[13:18:57.548]  - Number of values collected after concatenation: 10
[13:18:57.548]  - Number of values expected: 10
[13:18:57.548] Reducing values from 1 chunks ... DONE
[13:18:57.548] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:18:57.549] future_lapply() ...
[13:18:57.551] Number of chunks: 1
[13:18:57.551] getGlobalsAndPackagesXApply() ...
[13:18:57.551]  - future.globals: TRUE
[13:18:57.553] getGlobalsAndPackages() ...
[13:18:57.553] Searching for globals...
[13:18:57.556] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:57.556] Searching for globals ... DONE
[13:18:57.556] Resolving globals: FALSE
[13:18:57.557] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:18:57.558] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.558] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.558] - packages: [1] ‘future.apply’
[13:18:57.558] getGlobalsAndPackages() ... DONE
[13:18:57.558]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.558]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.558] Finding globals ... DONE
[13:18:57.558]  - use_args: TRUE
[13:18:57.558]  - Getting '...' globals ...
[13:18:57.559] resolve() on list ...
[13:18:57.559]  recursive: 0
[13:18:57.559]  length: 1
[13:18:57.559]  elements: ‘...’
[13:18:57.559]  length: 0 (resolved future 1)
[13:18:57.559] resolve() on list ... DONE
[13:18:57.559]    - '...' content: [n=0] 
[13:18:57.559] List of 1
[13:18:57.559]  $ ...: list()
[13:18:57.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.559]  - attr(*, "where")=List of 1
[13:18:57.559]   ..$ ...:<environment: 0x555f7bb0a348> 
[13:18:57.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.559]  - attr(*, "resolved")= logi TRUE
[13:18:57.559]  - attr(*, "total_size")= num NA
[13:18:57.562]  - Getting '...' globals ... DONE
[13:18:57.562] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.562] List of 8
[13:18:57.562]  $ ...future.FUN:function (x, ...)  
[13:18:57.562]  $ x_FUN        :function (x)  
[13:18:57.562]  $ times        : int 1
[13:18:57.562]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.562]  $ stop_if_not  :function (...)  
[13:18:57.562]  $ dim          : NULL
[13:18:57.562]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.562]  $ ...          : list()
[13:18:57.562]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.562]  - attr(*, "where")=List of 8
[13:18:57.562]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.562]   ..$ ...          :<environment: 0x555f7bb0a348> 
[13:18:57.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.562]  - attr(*, "resolved")= logi FALSE
[13:18:57.562]  - attr(*, "total_size")= num 94336
[13:18:57.568] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.568] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.568] Number of futures (= number of chunks): 1
[13:18:57.568] Launching 1 futures (chunks) ...
[13:18:57.568] Chunk #1 of 1 ...
[13:18:57.568]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.568] getGlobalsAndPackages() ...
[13:18:57.568] Searching for globals...
[13:18:57.569] 
[13:18:57.569] Searching for globals ... DONE
[13:18:57.569] - globals: [0] <none>
[13:18:57.569] getGlobalsAndPackages() ... DONE
[13:18:57.569]    + additional globals found: [n=0] 
[13:18:57.569]    + additional namespaces needed: [n=0] 
[13:18:57.569]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.569]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.569]  - seeds: <none>
[13:18:57.570] getGlobalsAndPackages() ...
[13:18:57.570] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.570] Resolving globals: FALSE
[13:18:57.570] Tweak future expression to call with '...' arguments ...
[13:18:57.570] {
[13:18:57.570]     do.call(function(...) {
[13:18:57.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.570]             on.exit(options(oopts), add = TRUE)
[13:18:57.570]         }
[13:18:57.570]         {
[13:18:57.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.570]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.570]             })
[13:18:57.570]         }
[13:18:57.570]     }, args = future.call.arguments)
[13:18:57.570] }
[13:18:57.570] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.571] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.571] - packages: [1] ‘future.apply’
[13:18:57.571] getGlobalsAndPackages() ... DONE
[13:18:57.571] run() for ‘Future’ ...
[13:18:57.571] - state: ‘created’
[13:18:57.572] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.572] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.572]   - Field: ‘label’
[13:18:57.572]   - Field: ‘local’
[13:18:57.572]   - Field: ‘owner’
[13:18:57.572]   - Field: ‘envir’
[13:18:57.572]   - Field: ‘packages’
[13:18:57.573]   - Field: ‘gc’
[13:18:57.573]   - Field: ‘conditions’
[13:18:57.573]   - Field: ‘expr’
[13:18:57.573]   - Field: ‘uuid’
[13:18:57.573]   - Field: ‘seed’
[13:18:57.573]   - Field: ‘version’
[13:18:57.573]   - Field: ‘result’
[13:18:57.573]   - Field: ‘asynchronous’
[13:18:57.573]   - Field: ‘calls’
[13:18:57.573]   - Field: ‘globals’
[13:18:57.575]   - Field: ‘stdout’
[13:18:57.575]   - Field: ‘earlySignal’
[13:18:57.575]   - Field: ‘lazy’
[13:18:57.575]   - Field: ‘state’
[13:18:57.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.575] - Launch lazy future ...
[13:18:57.576] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.576] Packages needed by future strategies (n = 0): <none>
[13:18:57.576] {
[13:18:57.576]     {
[13:18:57.576]         {
[13:18:57.576]             ...future.startTime <- base::Sys.time()
[13:18:57.576]             {
[13:18:57.576]                 {
[13:18:57.576]                   {
[13:18:57.576]                     {
[13:18:57.576]                       base::local({
[13:18:57.576]                         has_future <- base::requireNamespace("future", 
[13:18:57.576]                           quietly = TRUE)
[13:18:57.576]                         if (has_future) {
[13:18:57.576]                           ns <- base::getNamespace("future")
[13:18:57.576]                           version <- ns[[".package"]][["version"]]
[13:18:57.576]                           if (is.null(version)) 
[13:18:57.576]                             version <- utils::packageVersion("future")
[13:18:57.576]                         }
[13:18:57.576]                         else {
[13:18:57.576]                           version <- NULL
[13:18:57.576]                         }
[13:18:57.576]                         if (!has_future || version < "1.8.0") {
[13:18:57.576]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.576]                             "", base::R.version$version.string), 
[13:18:57.576]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.576]                               "release", "version")], collapse = " "), 
[13:18:57.576]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.576]                             info)
[13:18:57.576]                           info <- base::paste(info, collapse = "; ")
[13:18:57.576]                           if (!has_future) {
[13:18:57.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.576]                               info)
[13:18:57.576]                           }
[13:18:57.576]                           else {
[13:18:57.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.576]                               info, version)
[13:18:57.576]                           }
[13:18:57.576]                           base::stop(msg)
[13:18:57.576]                         }
[13:18:57.576]                       })
[13:18:57.576]                     }
[13:18:57.576]                     base::local({
[13:18:57.576]                       for (pkg in "future.apply") {
[13:18:57.576]                         base::loadNamespace(pkg)
[13:18:57.576]                         base::library(pkg, character.only = TRUE)
[13:18:57.576]                       }
[13:18:57.576]                     })
[13:18:57.576]                   }
[13:18:57.576]                   options(future.plan = NULL)
[13:18:57.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.576]                 }
[13:18:57.576]                 ...future.workdir <- getwd()
[13:18:57.576]             }
[13:18:57.576]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.576]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.576]         }
[13:18:57.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.576]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.576]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.576]             base::names(...future.oldOptions))
[13:18:57.576]     }
[13:18:57.576]     if (FALSE) {
[13:18:57.576]     }
[13:18:57.576]     else {
[13:18:57.576]         if (TRUE) {
[13:18:57.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.576]                 open = "w")
[13:18:57.576]         }
[13:18:57.576]         else {
[13:18:57.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.576]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.576]         }
[13:18:57.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.576]             base::sink(type = "output", split = FALSE)
[13:18:57.576]             base::close(...future.stdout)
[13:18:57.576]         }, add = TRUE)
[13:18:57.576]     }
[13:18:57.576]     ...future.frame <- base::sys.nframe()
[13:18:57.576]     ...future.conditions <- base::list()
[13:18:57.576]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.576]     if (FALSE) {
[13:18:57.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.576]     }
[13:18:57.576]     ...future.result <- base::tryCatch({
[13:18:57.576]         base::withCallingHandlers({
[13:18:57.576]             ...future.value <- base::withVisible(base::local({
[13:18:57.576]                 do.call(function(...) {
[13:18:57.576]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.576]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.576]                     ...future.globals.maxSize)) {
[13:18:57.576]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.576]                     on.exit(options(oopts), add = TRUE)
[13:18:57.576]                   }
[13:18:57.576]                   {
[13:18:57.576]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.576]                       FUN = function(jj) {
[13:18:57.576]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.576]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.576]                       })
[13:18:57.576]                   }
[13:18:57.576]                 }, args = future.call.arguments)
[13:18:57.576]             }))
[13:18:57.576]             future::FutureResult(value = ...future.value$value, 
[13:18:57.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.576]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.576]                     ...future.globalenv.names))
[13:18:57.576]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.576]         }, condition = base::local({
[13:18:57.576]             c <- base::c
[13:18:57.576]             inherits <- base::inherits
[13:18:57.576]             invokeRestart <- base::invokeRestart
[13:18:57.576]             length <- base::length
[13:18:57.576]             list <- base::list
[13:18:57.576]             seq.int <- base::seq.int
[13:18:57.576]             signalCondition <- base::signalCondition
[13:18:57.576]             sys.calls <- base::sys.calls
[13:18:57.576]             `[[` <- base::`[[`
[13:18:57.576]             `+` <- base::`+`
[13:18:57.576]             `<<-` <- base::`<<-`
[13:18:57.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.576]                   3L)]
[13:18:57.576]             }
[13:18:57.576]             function(cond) {
[13:18:57.576]                 is_error <- inherits(cond, "error")
[13:18:57.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.576]                   NULL)
[13:18:57.576]                 if (is_error) {
[13:18:57.576]                   sessionInformation <- function() {
[13:18:57.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.576]                       search = base::search(), system = base::Sys.info())
[13:18:57.576]                   }
[13:18:57.576]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.576]                     cond$call), session = sessionInformation(), 
[13:18:57.576]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.576]                   signalCondition(cond)
[13:18:57.576]                 }
[13:18:57.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.576]                 "immediateCondition"))) {
[13:18:57.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.576]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.576]                   if (TRUE && !signal) {
[13:18:57.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.576]                     {
[13:18:57.576]                       inherits <- base::inherits
[13:18:57.576]                       invokeRestart <- base::invokeRestart
[13:18:57.576]                       is.null <- base::is.null
[13:18:57.576]                       muffled <- FALSE
[13:18:57.576]                       if (inherits(cond, "message")) {
[13:18:57.576]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.576]                         if (muffled) 
[13:18:57.576]                           invokeRestart("muffleMessage")
[13:18:57.576]                       }
[13:18:57.576]                       else if (inherits(cond, "warning")) {
[13:18:57.576]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.576]                         if (muffled) 
[13:18:57.576]                           invokeRestart("muffleWarning")
[13:18:57.576]                       }
[13:18:57.576]                       else if (inherits(cond, "condition")) {
[13:18:57.576]                         if (!is.null(pattern)) {
[13:18:57.576]                           computeRestarts <- base::computeRestarts
[13:18:57.576]                           grepl <- base::grepl
[13:18:57.576]                           restarts <- computeRestarts(cond)
[13:18:57.576]                           for (restart in restarts) {
[13:18:57.576]                             name <- restart$name
[13:18:57.576]                             if (is.null(name)) 
[13:18:57.576]                               next
[13:18:57.576]                             if (!grepl(pattern, name)) 
[13:18:57.576]                               next
[13:18:57.576]                             invokeRestart(restart)
[13:18:57.576]                             muffled <- TRUE
[13:18:57.576]                             break
[13:18:57.576]                           }
[13:18:57.576]                         }
[13:18:57.576]                       }
[13:18:57.576]                       invisible(muffled)
[13:18:57.576]                     }
[13:18:57.576]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.576]                   }
[13:18:57.576]                 }
[13:18:57.576]                 else {
[13:18:57.576]                   if (TRUE) {
[13:18:57.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.576]                     {
[13:18:57.576]                       inherits <- base::inherits
[13:18:57.576]                       invokeRestart <- base::invokeRestart
[13:18:57.576]                       is.null <- base::is.null
[13:18:57.576]                       muffled <- FALSE
[13:18:57.576]                       if (inherits(cond, "message")) {
[13:18:57.576]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.576]                         if (muffled) 
[13:18:57.576]                           invokeRestart("muffleMessage")
[13:18:57.576]                       }
[13:18:57.576]                       else if (inherits(cond, "warning")) {
[13:18:57.576]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.576]                         if (muffled) 
[13:18:57.576]                           invokeRestart("muffleWarning")
[13:18:57.576]                       }
[13:18:57.576]                       else if (inherits(cond, "condition")) {
[13:18:57.576]                         if (!is.null(pattern)) {
[13:18:57.576]                           computeRestarts <- base::computeRestarts
[13:18:57.576]                           grepl <- base::grepl
[13:18:57.576]                           restarts <- computeRestarts(cond)
[13:18:57.576]                           for (restart in restarts) {
[13:18:57.576]                             name <- restart$name
[13:18:57.576]                             if (is.null(name)) 
[13:18:57.576]                               next
[13:18:57.576]                             if (!grepl(pattern, name)) 
[13:18:57.576]                               next
[13:18:57.576]                             invokeRestart(restart)
[13:18:57.576]                             muffled <- TRUE
[13:18:57.576]                             break
[13:18:57.576]                           }
[13:18:57.576]                         }
[13:18:57.576]                       }
[13:18:57.576]                       invisible(muffled)
[13:18:57.576]                     }
[13:18:57.576]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.576]                   }
[13:18:57.576]                 }
[13:18:57.576]             }
[13:18:57.576]         }))
[13:18:57.576]     }, error = function(ex) {
[13:18:57.576]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.576]                 ...future.rng), started = ...future.startTime, 
[13:18:57.576]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.576]             version = "1.8"), class = "FutureResult")
[13:18:57.576]     }, finally = {
[13:18:57.576]         if (!identical(...future.workdir, getwd())) 
[13:18:57.576]             setwd(...future.workdir)
[13:18:57.576]         {
[13:18:57.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.576]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.576]             }
[13:18:57.576]             base::options(...future.oldOptions)
[13:18:57.576]             if (.Platform$OS.type == "windows") {
[13:18:57.576]                 old_names <- names(...future.oldEnvVars)
[13:18:57.576]                 envs <- base::Sys.getenv()
[13:18:57.576]                 names <- names(envs)
[13:18:57.576]                 common <- intersect(names, old_names)
[13:18:57.576]                 added <- setdiff(names, old_names)
[13:18:57.576]                 removed <- setdiff(old_names, names)
[13:18:57.576]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.576]                   envs[common]]
[13:18:57.576]                 NAMES <- toupper(changed)
[13:18:57.576]                 args <- list()
[13:18:57.576]                 for (kk in seq_along(NAMES)) {
[13:18:57.576]                   name <- changed[[kk]]
[13:18:57.576]                   NAME <- NAMES[[kk]]
[13:18:57.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.576]                     next
[13:18:57.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.576]                 }
[13:18:57.576]                 NAMES <- toupper(added)
[13:18:57.576]                 for (kk in seq_along(NAMES)) {
[13:18:57.576]                   name <- added[[kk]]
[13:18:57.576]                   NAME <- NAMES[[kk]]
[13:18:57.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.576]                     next
[13:18:57.576]                   args[[name]] <- ""
[13:18:57.576]                 }
[13:18:57.576]                 NAMES <- toupper(removed)
[13:18:57.576]                 for (kk in seq_along(NAMES)) {
[13:18:57.576]                   name <- removed[[kk]]
[13:18:57.576]                   NAME <- NAMES[[kk]]
[13:18:57.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.576]                     next
[13:18:57.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.576]                 }
[13:18:57.576]                 if (length(args) > 0) 
[13:18:57.576]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.576]             }
[13:18:57.576]             else {
[13:18:57.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.576]             }
[13:18:57.576]             {
[13:18:57.576]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.576]                   0L) {
[13:18:57.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.576]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.576]                   base::options(opts)
[13:18:57.576]                 }
[13:18:57.576]                 {
[13:18:57.576]                   {
[13:18:57.576]                     NULL
[13:18:57.576]                     RNGkind("Mersenne-Twister")
[13:18:57.576]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.576]                       inherits = FALSE)
[13:18:57.576]                   }
[13:18:57.576]                   options(future.plan = NULL)
[13:18:57.576]                   if (is.na(NA_character_)) 
[13:18:57.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.576]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.576]                   {
[13:18:57.576]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.576]                     if (!future$lazy) 
[13:18:57.576]                       future <- run(future)
[13:18:57.576]                     invisible(future)
[13:18:57.576]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.576]                 }
[13:18:57.576]             }
[13:18:57.576]         }
[13:18:57.576]     })
[13:18:57.576]     if (TRUE) {
[13:18:57.576]         base::sink(type = "output", split = FALSE)
[13:18:57.576]         if (TRUE) {
[13:18:57.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.576]         }
[13:18:57.576]         else {
[13:18:57.576]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.576]         }
[13:18:57.576]         base::close(...future.stdout)
[13:18:57.576]         ...future.stdout <- NULL
[13:18:57.576]     }
[13:18:57.576]     ...future.result$conditions <- ...future.conditions
[13:18:57.576]     ...future.result$finished <- base::Sys.time()
[13:18:57.576]     ...future.result
[13:18:57.576] }
[13:18:57.578] assign_globals() ...
[13:18:57.578] List of 11
[13:18:57.578]  $ ...future.FUN            :function (x, ...)  
[13:18:57.578]  $ x_FUN                    :function (x)  
[13:18:57.578]  $ times                    : int 1
[13:18:57.578]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.578]  $ stop_if_not              :function (...)  
[13:18:57.578]  $ dim                      : NULL
[13:18:57.578]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.578]  $ future.call.arguments    : list()
[13:18:57.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.578]  $ ...future.elements_ii    :List of 10
[13:18:57.578]   ..$ : int 1
[13:18:57.578]   ..$ : int 2
[13:18:57.578]   ..$ : int 3
[13:18:57.578]   ..$ : int 4
[13:18:57.578]   ..$ : int 5
[13:18:57.578]   ..$ : int 6
[13:18:57.578]   ..$ : int 7
[13:18:57.578]   ..$ : int 8
[13:18:57.578]   ..$ : int 9
[13:18:57.578]   ..$ : int 10
[13:18:57.578]  $ ...future.seeds_ii       : NULL
[13:18:57.578]  $ ...future.globals.maxSize: NULL
[13:18:57.578]  - attr(*, "resolved")= logi FALSE
[13:18:57.578]  - attr(*, "total_size")= num 94336
[13:18:57.578]  - attr(*, "where")=List of 11
[13:18:57.578]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.578]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.578]  - attr(*, "already-done")= logi TRUE
[13:18:57.588] - copied ‘...future.FUN’ to environment
[13:18:57.588] - copied ‘x_FUN’ to environment
[13:18:57.588] - copied ‘times’ to environment
[13:18:57.588] - copied ‘stopf’ to environment
[13:18:57.588] - copied ‘stop_if_not’ to environment
[13:18:57.588] - copied ‘dim’ to environment
[13:18:57.588] - copied ‘valid_types’ to environment
[13:18:57.588] - copied ‘future.call.arguments’ to environment
[13:18:57.589] - copied ‘...future.elements_ii’ to environment
[13:18:57.589] - copied ‘...future.seeds_ii’ to environment
[13:18:57.589] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.589] assign_globals() ... done
[13:18:57.589] plan(): Setting new future strategy stack:
[13:18:57.589] List of future strategies:
[13:18:57.589] 1. sequential:
[13:18:57.589]    - args: function (..., envir = parent.frame())
[13:18:57.589]    - tweaked: FALSE
[13:18:57.589]    - call: NULL
[13:18:57.590] plan(): nbrOfWorkers() = 1
[13:18:57.590] plan(): Setting new future strategy stack:
[13:18:57.591] List of future strategies:
[13:18:57.591] 1. sequential:
[13:18:57.591]    - args: function (..., envir = parent.frame())
[13:18:57.591]    - tweaked: FALSE
[13:18:57.591]    - call: plan(strategy)
[13:18:57.591] plan(): nbrOfWorkers() = 1
[13:18:57.591] SequentialFuture started (and completed)
[13:18:57.591] - Launch lazy future ... done
[13:18:57.591] run() for ‘SequentialFuture’ ... done
[13:18:57.591] Created future:
[13:18:57.592] SequentialFuture:
[13:18:57.592] Label: ‘future_vapply-1’
[13:18:57.592] Expression:
[13:18:57.592] {
[13:18:57.592]     do.call(function(...) {
[13:18:57.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.592]             on.exit(options(oopts), add = TRUE)
[13:18:57.592]         }
[13:18:57.592]         {
[13:18:57.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.592]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.592]             })
[13:18:57.592]         }
[13:18:57.592]     }, args = future.call.arguments)
[13:18:57.592] }
[13:18:57.592] Lazy evaluation: FALSE
[13:18:57.592] Asynchronous evaluation: FALSE
[13:18:57.592] Local evaluation: TRUE
[13:18:57.592] Environment: R_GlobalEnv
[13:18:57.592] Capture standard output: TRUE
[13:18:57.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.592] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.592] Packages: 1 packages (‘future.apply’)
[13:18:57.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.592] Resolved: TRUE
[13:18:57.592] Value: 560 bytes of class ‘list’
[13:18:57.592] Early signaling: FALSE
[13:18:57.592] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.592] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.593] Chunk #1 of 1 ... DONE
[13:18:57.593] Launching 1 futures (chunks) ... DONE
[13:18:57.593] Resolving 1 futures (chunks) ...
[13:18:57.593] resolve() on list ...
[13:18:57.593]  recursive: 0
[13:18:57.593]  length: 1
[13:18:57.593] 
[13:18:57.593] resolved() for ‘SequentialFuture’ ...
[13:18:57.593] - state: ‘finished’
[13:18:57.594] - run: TRUE
[13:18:57.594] - result: ‘FutureResult’
[13:18:57.594] resolved() for ‘SequentialFuture’ ... done
[13:18:57.594] Future #1
[13:18:57.594] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.594] - nx: 1
[13:18:57.594] - relay: TRUE
[13:18:57.594] - stdout: TRUE
[13:18:57.594] - signal: TRUE
[13:18:57.594] - resignal: FALSE
[13:18:57.594] - force: TRUE
[13:18:57.594] - relayed: [n=1] FALSE
[13:18:57.595] - queued futures: [n=1] FALSE
[13:18:57.595]  - until=1
[13:18:57.595]  - relaying element #1
[13:18:57.595] - relayed: [n=1] TRUE
[13:18:57.595] - queued futures: [n=1] TRUE
[13:18:57.595] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.595]  length: 0 (resolved future 1)
[13:18:57.595] Relaying remaining futures
[13:18:57.595] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.595] - nx: 1
[13:18:57.596] - relay: TRUE
[13:18:57.596] - stdout: TRUE
[13:18:57.596] - signal: TRUE
[13:18:57.596] - resignal: FALSE
[13:18:57.596] - force: TRUE
[13:18:57.596] - relayed: [n=1] TRUE
[13:18:57.596] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.598] - relayed: [n=1] TRUE
[13:18:57.598] - queued futures: [n=1] TRUE
[13:18:57.598] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.598] resolve() on list ... DONE
[13:18:57.598]  - Number of value chunks collected: 1
[13:18:57.598] Resolving 1 futures (chunks) ... DONE
[13:18:57.598] Reducing values from 1 chunks ...
[13:18:57.598]  - Number of values collected after concatenation: 10
[13:18:57.598]  - Number of values expected: 10
[13:18:57.598] Reducing values from 1 chunks ... DONE
[13:18:57.599] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:18:57.599] future_lapply() ...
[13:18:57.601] Number of chunks: 1
[13:18:57.601] getGlobalsAndPackagesXApply() ...
[13:18:57.601]  - future.globals: TRUE
[13:18:57.601] getGlobalsAndPackages() ...
[13:18:57.601] Searching for globals...
[13:18:57.605] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:18:57.605] Searching for globals ... DONE
[13:18:57.605] Resolving globals: FALSE
[13:18:57.606] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:18:57.606] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.606] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.607] - packages: [1] ‘future.apply’
[13:18:57.607] getGlobalsAndPackages() ... DONE
[13:18:57.607]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.607]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.607] Finding globals ... DONE
[13:18:57.607]  - use_args: TRUE
[13:18:57.607]  - Getting '...' globals ...
[13:18:57.607] resolve() on list ...
[13:18:57.607]  recursive: 0
[13:18:57.608]  length: 1
[13:18:57.608]  elements: ‘...’
[13:18:57.608]  length: 0 (resolved future 1)
[13:18:57.608] resolve() on list ... DONE
[13:18:57.608]    - '...' content: [n=0] 
[13:18:57.608] List of 1
[13:18:57.608]  $ ...: list()
[13:18:57.608]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.608]  - attr(*, "where")=List of 1
[13:18:57.608]   ..$ ...:<environment: 0x555f7a2e9d60> 
[13:18:57.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.608]  - attr(*, "resolved")= logi TRUE
[13:18:57.608]  - attr(*, "total_size")= num NA
[13:18:57.610]  - Getting '...' globals ... DONE
[13:18:57.611] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.611] List of 8
[13:18:57.611]  $ ...future.FUN:function (x, ...)  
[13:18:57.611]  $ x_FUN        :function (x)  
[13:18:57.611]  $ times        : int 2
[13:18:57.611]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.611]  $ stop_if_not  :function (...)  
[13:18:57.611]  $ dim          : NULL
[13:18:57.611]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.611]  $ ...          : list()
[13:18:57.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.611]  - attr(*, "where")=List of 8
[13:18:57.611]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.611]   ..$ ...          :<environment: 0x555f7a2e9d60> 
[13:18:57.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.611]  - attr(*, "resolved")= logi FALSE
[13:18:57.611]  - attr(*, "total_size")= num 96456
[13:18:57.616] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.616] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.616] Number of futures (= number of chunks): 1
[13:18:57.616] Launching 1 futures (chunks) ...
[13:18:57.617] Chunk #1 of 1 ...
[13:18:57.617]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.617] getGlobalsAndPackages() ...
[13:18:57.618] Searching for globals...
[13:18:57.619] 
[13:18:57.619] Searching for globals ... DONE
[13:18:57.619] - globals: [0] <none>
[13:18:57.619] getGlobalsAndPackages() ... DONE
[13:18:57.619]    + additional globals found: [n=0] 
[13:18:57.619]    + additional namespaces needed: [n=0] 
[13:18:57.619]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.619]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.619]  - seeds: <none>
[13:18:57.620] getGlobalsAndPackages() ...
[13:18:57.620] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.620] Resolving globals: FALSE
[13:18:57.620] Tweak future expression to call with '...' arguments ...
[13:18:57.620] {
[13:18:57.620]     do.call(function(...) {
[13:18:57.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.620]             on.exit(options(oopts), add = TRUE)
[13:18:57.620]         }
[13:18:57.620]         {
[13:18:57.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.620]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.620]             })
[13:18:57.620]         }
[13:18:57.620]     }, args = future.call.arguments)
[13:18:57.620] }
[13:18:57.620] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.621] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.621] - packages: [1] ‘future.apply’
[13:18:57.621] getGlobalsAndPackages() ... DONE
[13:18:57.621] run() for ‘Future’ ...
[13:18:57.621] - state: ‘created’
[13:18:57.621] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.622]   - Field: ‘label’
[13:18:57.622]   - Field: ‘local’
[13:18:57.622]   - Field: ‘owner’
[13:18:57.622]   - Field: ‘envir’
[13:18:57.622]   - Field: ‘packages’
[13:18:57.622]   - Field: ‘gc’
[13:18:57.623]   - Field: ‘conditions’
[13:18:57.623]   - Field: ‘expr’
[13:18:57.623]   - Field: ‘uuid’
[13:18:57.623]   - Field: ‘seed’
[13:18:57.623]   - Field: ‘version’
[13:18:57.623]   - Field: ‘result’
[13:18:57.623]   - Field: ‘asynchronous’
[13:18:57.623]   - Field: ‘calls’
[13:18:57.623]   - Field: ‘globals’
[13:18:57.623]   - Field: ‘stdout’
[13:18:57.623]   - Field: ‘earlySignal’
[13:18:57.624]   - Field: ‘lazy’
[13:18:57.624]   - Field: ‘state’
[13:18:57.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.624] - Launch lazy future ...
[13:18:57.624] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.624] Packages needed by future strategies (n = 0): <none>
[13:18:57.625] {
[13:18:57.625]     {
[13:18:57.625]         {
[13:18:57.625]             ...future.startTime <- base::Sys.time()
[13:18:57.625]             {
[13:18:57.625]                 {
[13:18:57.625]                   {
[13:18:57.625]                     {
[13:18:57.625]                       base::local({
[13:18:57.625]                         has_future <- base::requireNamespace("future", 
[13:18:57.625]                           quietly = TRUE)
[13:18:57.625]                         if (has_future) {
[13:18:57.625]                           ns <- base::getNamespace("future")
[13:18:57.625]                           version <- ns[[".package"]][["version"]]
[13:18:57.625]                           if (is.null(version)) 
[13:18:57.625]                             version <- utils::packageVersion("future")
[13:18:57.625]                         }
[13:18:57.625]                         else {
[13:18:57.625]                           version <- NULL
[13:18:57.625]                         }
[13:18:57.625]                         if (!has_future || version < "1.8.0") {
[13:18:57.625]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.625]                             "", base::R.version$version.string), 
[13:18:57.625]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.625]                               "release", "version")], collapse = " "), 
[13:18:57.625]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.625]                             info)
[13:18:57.625]                           info <- base::paste(info, collapse = "; ")
[13:18:57.625]                           if (!has_future) {
[13:18:57.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.625]                               info)
[13:18:57.625]                           }
[13:18:57.625]                           else {
[13:18:57.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.625]                               info, version)
[13:18:57.625]                           }
[13:18:57.625]                           base::stop(msg)
[13:18:57.625]                         }
[13:18:57.625]                       })
[13:18:57.625]                     }
[13:18:57.625]                     base::local({
[13:18:57.625]                       for (pkg in "future.apply") {
[13:18:57.625]                         base::loadNamespace(pkg)
[13:18:57.625]                         base::library(pkg, character.only = TRUE)
[13:18:57.625]                       }
[13:18:57.625]                     })
[13:18:57.625]                   }
[13:18:57.625]                   options(future.plan = NULL)
[13:18:57.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.625]                 }
[13:18:57.625]                 ...future.workdir <- getwd()
[13:18:57.625]             }
[13:18:57.625]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.625]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.625]         }
[13:18:57.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.625]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.625]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.625]             base::names(...future.oldOptions))
[13:18:57.625]     }
[13:18:57.625]     if (FALSE) {
[13:18:57.625]     }
[13:18:57.625]     else {
[13:18:57.625]         if (TRUE) {
[13:18:57.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.625]                 open = "w")
[13:18:57.625]         }
[13:18:57.625]         else {
[13:18:57.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.625]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.625]         }
[13:18:57.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.625]             base::sink(type = "output", split = FALSE)
[13:18:57.625]             base::close(...future.stdout)
[13:18:57.625]         }, add = TRUE)
[13:18:57.625]     }
[13:18:57.625]     ...future.frame <- base::sys.nframe()
[13:18:57.625]     ...future.conditions <- base::list()
[13:18:57.625]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.625]     if (FALSE) {
[13:18:57.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.625]     }
[13:18:57.625]     ...future.result <- base::tryCatch({
[13:18:57.625]         base::withCallingHandlers({
[13:18:57.625]             ...future.value <- base::withVisible(base::local({
[13:18:57.625]                 do.call(function(...) {
[13:18:57.625]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.625]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.625]                     ...future.globals.maxSize)) {
[13:18:57.625]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.625]                     on.exit(options(oopts), add = TRUE)
[13:18:57.625]                   }
[13:18:57.625]                   {
[13:18:57.625]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.625]                       FUN = function(jj) {
[13:18:57.625]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.625]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.625]                       })
[13:18:57.625]                   }
[13:18:57.625]                 }, args = future.call.arguments)
[13:18:57.625]             }))
[13:18:57.625]             future::FutureResult(value = ...future.value$value, 
[13:18:57.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.625]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.625]                     ...future.globalenv.names))
[13:18:57.625]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.625]         }, condition = base::local({
[13:18:57.625]             c <- base::c
[13:18:57.625]             inherits <- base::inherits
[13:18:57.625]             invokeRestart <- base::invokeRestart
[13:18:57.625]             length <- base::length
[13:18:57.625]             list <- base::list
[13:18:57.625]             seq.int <- base::seq.int
[13:18:57.625]             signalCondition <- base::signalCondition
[13:18:57.625]             sys.calls <- base::sys.calls
[13:18:57.625]             `[[` <- base::`[[`
[13:18:57.625]             `+` <- base::`+`
[13:18:57.625]             `<<-` <- base::`<<-`
[13:18:57.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.625]                   3L)]
[13:18:57.625]             }
[13:18:57.625]             function(cond) {
[13:18:57.625]                 is_error <- inherits(cond, "error")
[13:18:57.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.625]                   NULL)
[13:18:57.625]                 if (is_error) {
[13:18:57.625]                   sessionInformation <- function() {
[13:18:57.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.625]                       search = base::search(), system = base::Sys.info())
[13:18:57.625]                   }
[13:18:57.625]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.625]                     cond$call), session = sessionInformation(), 
[13:18:57.625]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.625]                   signalCondition(cond)
[13:18:57.625]                 }
[13:18:57.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.625]                 "immediateCondition"))) {
[13:18:57.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.625]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.625]                   if (TRUE && !signal) {
[13:18:57.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.625]                     {
[13:18:57.625]                       inherits <- base::inherits
[13:18:57.625]                       invokeRestart <- base::invokeRestart
[13:18:57.625]                       is.null <- base::is.null
[13:18:57.625]                       muffled <- FALSE
[13:18:57.625]                       if (inherits(cond, "message")) {
[13:18:57.625]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.625]                         if (muffled) 
[13:18:57.625]                           invokeRestart("muffleMessage")
[13:18:57.625]                       }
[13:18:57.625]                       else if (inherits(cond, "warning")) {
[13:18:57.625]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.625]                         if (muffled) 
[13:18:57.625]                           invokeRestart("muffleWarning")
[13:18:57.625]                       }
[13:18:57.625]                       else if (inherits(cond, "condition")) {
[13:18:57.625]                         if (!is.null(pattern)) {
[13:18:57.625]                           computeRestarts <- base::computeRestarts
[13:18:57.625]                           grepl <- base::grepl
[13:18:57.625]                           restarts <- computeRestarts(cond)
[13:18:57.625]                           for (restart in restarts) {
[13:18:57.625]                             name <- restart$name
[13:18:57.625]                             if (is.null(name)) 
[13:18:57.625]                               next
[13:18:57.625]                             if (!grepl(pattern, name)) 
[13:18:57.625]                               next
[13:18:57.625]                             invokeRestart(restart)
[13:18:57.625]                             muffled <- TRUE
[13:18:57.625]                             break
[13:18:57.625]                           }
[13:18:57.625]                         }
[13:18:57.625]                       }
[13:18:57.625]                       invisible(muffled)
[13:18:57.625]                     }
[13:18:57.625]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.625]                   }
[13:18:57.625]                 }
[13:18:57.625]                 else {
[13:18:57.625]                   if (TRUE) {
[13:18:57.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.625]                     {
[13:18:57.625]                       inherits <- base::inherits
[13:18:57.625]                       invokeRestart <- base::invokeRestart
[13:18:57.625]                       is.null <- base::is.null
[13:18:57.625]                       muffled <- FALSE
[13:18:57.625]                       if (inherits(cond, "message")) {
[13:18:57.625]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.625]                         if (muffled) 
[13:18:57.625]                           invokeRestart("muffleMessage")
[13:18:57.625]                       }
[13:18:57.625]                       else if (inherits(cond, "warning")) {
[13:18:57.625]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.625]                         if (muffled) 
[13:18:57.625]                           invokeRestart("muffleWarning")
[13:18:57.625]                       }
[13:18:57.625]                       else if (inherits(cond, "condition")) {
[13:18:57.625]                         if (!is.null(pattern)) {
[13:18:57.625]                           computeRestarts <- base::computeRestarts
[13:18:57.625]                           grepl <- base::grepl
[13:18:57.625]                           restarts <- computeRestarts(cond)
[13:18:57.625]                           for (restart in restarts) {
[13:18:57.625]                             name <- restart$name
[13:18:57.625]                             if (is.null(name)) 
[13:18:57.625]                               next
[13:18:57.625]                             if (!grepl(pattern, name)) 
[13:18:57.625]                               next
[13:18:57.625]                             invokeRestart(restart)
[13:18:57.625]                             muffled <- TRUE
[13:18:57.625]                             break
[13:18:57.625]                           }
[13:18:57.625]                         }
[13:18:57.625]                       }
[13:18:57.625]                       invisible(muffled)
[13:18:57.625]                     }
[13:18:57.625]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.625]                   }
[13:18:57.625]                 }
[13:18:57.625]             }
[13:18:57.625]         }))
[13:18:57.625]     }, error = function(ex) {
[13:18:57.625]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.625]                 ...future.rng), started = ...future.startTime, 
[13:18:57.625]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.625]             version = "1.8"), class = "FutureResult")
[13:18:57.625]     }, finally = {
[13:18:57.625]         if (!identical(...future.workdir, getwd())) 
[13:18:57.625]             setwd(...future.workdir)
[13:18:57.625]         {
[13:18:57.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.625]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.625]             }
[13:18:57.625]             base::options(...future.oldOptions)
[13:18:57.625]             if (.Platform$OS.type == "windows") {
[13:18:57.625]                 old_names <- names(...future.oldEnvVars)
[13:18:57.625]                 envs <- base::Sys.getenv()
[13:18:57.625]                 names <- names(envs)
[13:18:57.625]                 common <- intersect(names, old_names)
[13:18:57.625]                 added <- setdiff(names, old_names)
[13:18:57.625]                 removed <- setdiff(old_names, names)
[13:18:57.625]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.625]                   envs[common]]
[13:18:57.625]                 NAMES <- toupper(changed)
[13:18:57.625]                 args <- list()
[13:18:57.625]                 for (kk in seq_along(NAMES)) {
[13:18:57.625]                   name <- changed[[kk]]
[13:18:57.625]                   NAME <- NAMES[[kk]]
[13:18:57.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.625]                     next
[13:18:57.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.625]                 }
[13:18:57.625]                 NAMES <- toupper(added)
[13:18:57.625]                 for (kk in seq_along(NAMES)) {
[13:18:57.625]                   name <- added[[kk]]
[13:18:57.625]                   NAME <- NAMES[[kk]]
[13:18:57.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.625]                     next
[13:18:57.625]                   args[[name]] <- ""
[13:18:57.625]                 }
[13:18:57.625]                 NAMES <- toupper(removed)
[13:18:57.625]                 for (kk in seq_along(NAMES)) {
[13:18:57.625]                   name <- removed[[kk]]
[13:18:57.625]                   NAME <- NAMES[[kk]]
[13:18:57.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.625]                     next
[13:18:57.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.625]                 }
[13:18:57.625]                 if (length(args) > 0) 
[13:18:57.625]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.625]             }
[13:18:57.625]             else {
[13:18:57.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.625]             }
[13:18:57.625]             {
[13:18:57.625]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.625]                   0L) {
[13:18:57.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.625]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.625]                   base::options(opts)
[13:18:57.625]                 }
[13:18:57.625]                 {
[13:18:57.625]                   {
[13:18:57.625]                     NULL
[13:18:57.625]                     RNGkind("Mersenne-Twister")
[13:18:57.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.625]                       inherits = FALSE)
[13:18:57.625]                   }
[13:18:57.625]                   options(future.plan = NULL)
[13:18:57.625]                   if (is.na(NA_character_)) 
[13:18:57.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.625]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.625]                   {
[13:18:57.625]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.625]                     if (!future$lazy) 
[13:18:57.625]                       future <- run(future)
[13:18:57.625]                     invisible(future)
[13:18:57.625]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.625]                 }
[13:18:57.625]             }
[13:18:57.625]         }
[13:18:57.625]     })
[13:18:57.625]     if (TRUE) {
[13:18:57.625]         base::sink(type = "output", split = FALSE)
[13:18:57.625]         if (TRUE) {
[13:18:57.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.625]         }
[13:18:57.625]         else {
[13:18:57.625]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.625]         }
[13:18:57.625]         base::close(...future.stdout)
[13:18:57.625]         ...future.stdout <- NULL
[13:18:57.625]     }
[13:18:57.625]     ...future.result$conditions <- ...future.conditions
[13:18:57.625]     ...future.result$finished <- base::Sys.time()
[13:18:57.625]     ...future.result
[13:18:57.625] }
[13:18:57.626] assign_globals() ...
[13:18:57.627] List of 11
[13:18:57.627]  $ ...future.FUN            :function (x, ...)  
[13:18:57.627]  $ x_FUN                    :function (x)  
[13:18:57.627]  $ times                    : int 2
[13:18:57.627]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.627]  $ stop_if_not              :function (...)  
[13:18:57.627]  $ dim                      : NULL
[13:18:57.627]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.627]  $ future.call.arguments    : list()
[13:18:57.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.627]  $ ...future.elements_ii    :List of 10
[13:18:57.627]   ..$ : int 1
[13:18:57.627]   ..$ : int 2
[13:18:57.627]   ..$ : int 3
[13:18:57.627]   ..$ : int 4
[13:18:57.627]   ..$ : int 5
[13:18:57.627]   ..$ : int 6
[13:18:57.627]   ..$ : int 7
[13:18:57.627]   ..$ : int 8
[13:18:57.627]   ..$ : int 9
[13:18:57.627]   ..$ : int 10
[13:18:57.627]  $ ...future.seeds_ii       : NULL
[13:18:57.627]  $ ...future.globals.maxSize: NULL
[13:18:57.627]  - attr(*, "resolved")= logi FALSE
[13:18:57.627]  - attr(*, "total_size")= num 96456
[13:18:57.627]  - attr(*, "where")=List of 11
[13:18:57.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.627]  - attr(*, "already-done")= logi TRUE
[13:18:57.636] - copied ‘...future.FUN’ to environment
[13:18:57.636] - reassign environment for ‘x_FUN’
[13:18:57.636] - copied ‘x_FUN’ to environment
[13:18:57.636] - copied ‘times’ to environment
[13:18:57.636] - copied ‘stopf’ to environment
[13:18:57.637] - copied ‘stop_if_not’ to environment
[13:18:57.637] - copied ‘dim’ to environment
[13:18:57.637] - copied ‘valid_types’ to environment
[13:18:57.637] - copied ‘future.call.arguments’ to environment
[13:18:57.637] - copied ‘...future.elements_ii’ to environment
[13:18:57.637] - copied ‘...future.seeds_ii’ to environment
[13:18:57.637] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.637] assign_globals() ... done
[13:18:57.638] plan(): Setting new future strategy stack:
[13:18:57.638] List of future strategies:
[13:18:57.638] 1. sequential:
[13:18:57.638]    - args: function (..., envir = parent.frame())
[13:18:57.638]    - tweaked: FALSE
[13:18:57.638]    - call: NULL
[13:18:57.638] plan(): nbrOfWorkers() = 1
[13:18:57.639] plan(): Setting new future strategy stack:
[13:18:57.639] List of future strategies:
[13:18:57.639] 1. sequential:
[13:18:57.639]    - args: function (..., envir = parent.frame())
[13:18:57.639]    - tweaked: FALSE
[13:18:57.639]    - call: plan(strategy)
[13:18:57.639] plan(): nbrOfWorkers() = 1
[13:18:57.639] SequentialFuture started (and completed)
[13:18:57.641] - Launch lazy future ... done
[13:18:57.641] run() for ‘SequentialFuture’ ... done
[13:18:57.641] Created future:
[13:18:57.641] SequentialFuture:
[13:18:57.641] Label: ‘future_vapply-1’
[13:18:57.641] Expression:
[13:18:57.641] {
[13:18:57.641]     do.call(function(...) {
[13:18:57.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.641]             on.exit(options(oopts), add = TRUE)
[13:18:57.641]         }
[13:18:57.641]         {
[13:18:57.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.641]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.641]             })
[13:18:57.641]         }
[13:18:57.641]     }, args = future.call.arguments)
[13:18:57.641] }
[13:18:57.641] Lazy evaluation: FALSE
[13:18:57.641] Asynchronous evaluation: FALSE
[13:18:57.641] Local evaluation: TRUE
[13:18:57.641] Environment: R_GlobalEnv
[13:18:57.641] Capture standard output: TRUE
[13:18:57.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.641] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.641] Packages: 1 packages (‘future.apply’)
[13:18:57.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.641] Resolved: TRUE
[13:18:57.641] Value: 640 bytes of class ‘list’
[13:18:57.641] Early signaling: FALSE
[13:18:57.641] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.641] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.643] Chunk #1 of 1 ... DONE
[13:18:57.643] Launching 1 futures (chunks) ... DONE
[13:18:57.643] Resolving 1 futures (chunks) ...
[13:18:57.643] resolve() on list ...
[13:18:57.643]  recursive: 0
[13:18:57.643]  length: 1
[13:18:57.643] 
[13:18:57.643] resolved() for ‘SequentialFuture’ ...
[13:18:57.643] - state: ‘finished’
[13:18:57.643] - run: TRUE
[13:18:57.644] - result: ‘FutureResult’
[13:18:57.644] resolved() for ‘SequentialFuture’ ... done
[13:18:57.644] Future #1
[13:18:57.644] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.644] - nx: 1
[13:18:57.644] - relay: TRUE
[13:18:57.644] - stdout: TRUE
[13:18:57.644] - signal: TRUE
[13:18:57.644] - resignal: FALSE
[13:18:57.644] - force: TRUE
[13:18:57.644] - relayed: [n=1] FALSE
[13:18:57.645] - queued futures: [n=1] FALSE
[13:18:57.645]  - until=1
[13:18:57.645]  - relaying element #1
[13:18:57.645] - relayed: [n=1] TRUE
[13:18:57.645] - queued futures: [n=1] TRUE
[13:18:57.645] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.645]  length: 0 (resolved future 1)
[13:18:57.645] Relaying remaining futures
[13:18:57.645] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.646] - nx: 1
[13:18:57.646] - relay: TRUE
[13:18:57.646] - stdout: TRUE
[13:18:57.646] - signal: TRUE
[13:18:57.646] - resignal: FALSE
[13:18:57.646] - force: TRUE
[13:18:57.646] - relayed: [n=1] TRUE
[13:18:57.646] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.646] - relayed: [n=1] TRUE
[13:18:57.646] - queued futures: [n=1] TRUE
[13:18:57.646] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.646] resolve() on list ... DONE
[13:18:57.647]  - Number of value chunks collected: 1
[13:18:57.647] Resolving 1 futures (chunks) ... DONE
[13:18:57.647] Reducing values from 1 chunks ...
[13:18:57.647]  - Number of values collected after concatenation: 10
[13:18:57.647]  - Number of values expected: 10
[13:18:57.647] Reducing values from 1 chunks ... DONE
[13:18:57.647] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:18:57.648] future_lapply() ...
[13:18:57.650] Number of chunks: 1
[13:18:57.650] getGlobalsAndPackagesXApply() ...
[13:18:57.650]  - future.globals: TRUE
[13:18:57.650] getGlobalsAndPackages() ...
[13:18:57.650] Searching for globals...
[13:18:57.653] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:18:57.653] Searching for globals ... DONE
[13:18:57.654] Resolving globals: FALSE
[13:18:57.654] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:18:57.655] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.655] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.655] - packages: [1] ‘future.apply’
[13:18:57.655] getGlobalsAndPackages() ... DONE
[13:18:57.655]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.655]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.655] Finding globals ... DONE
[13:18:57.655]  - use_args: TRUE
[13:18:57.656]  - Getting '...' globals ...
[13:18:57.656] resolve() on list ...
[13:18:57.656]  recursive: 0
[13:18:57.656]  length: 1
[13:18:57.656]  elements: ‘...’
[13:18:57.656]  length: 0 (resolved future 1)
[13:18:57.656] resolve() on list ... DONE
[13:18:57.656]    - '...' content: [n=0] 
[13:18:57.656] List of 1
[13:18:57.656]  $ ...: list()
[13:18:57.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.656]  - attr(*, "where")=List of 1
[13:18:57.656]   ..$ ...:<environment: 0x555f7a1d0c00> 
[13:18:57.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.656]  - attr(*, "resolved")= logi TRUE
[13:18:57.656]  - attr(*, "total_size")= num NA
[13:18:57.659]  - Getting '...' globals ... DONE
[13:18:57.659] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.659] List of 8
[13:18:57.659]  $ ...future.FUN:function (x, ...)  
[13:18:57.659]  $ x_FUN        :function (x)  
[13:18:57.659]  $ times        : int 4
[13:18:57.659]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.659]  $ stop_if_not  :function (...)  
[13:18:57.659]  $ dim          : int [1:2] 2 2
[13:18:57.659]  $ valid_types  : chr [1:2] "logical" "integer"
[13:18:57.659]  $ ...          : list()
[13:18:57.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.659]  - attr(*, "where")=List of 8
[13:18:57.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.659]   ..$ ...          :<environment: 0x555f7a1d0c00> 
[13:18:57.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.659]  - attr(*, "resolved")= logi FALSE
[13:18:57.659]  - attr(*, "total_size")= num 97232
[13:18:57.666] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.666] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.666] Number of futures (= number of chunks): 1
[13:18:57.666] Launching 1 futures (chunks) ...
[13:18:57.666] Chunk #1 of 1 ...
[13:18:57.666]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.666] getGlobalsAndPackages() ...
[13:18:57.667] Searching for globals...
[13:18:57.667] 
[13:18:57.667] Searching for globals ... DONE
[13:18:57.667] - globals: [0] <none>
[13:18:57.667] getGlobalsAndPackages() ... DONE
[13:18:57.667]    + additional globals found: [n=0] 
[13:18:57.667]    + additional namespaces needed: [n=0] 
[13:18:57.667]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.667]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.668]  - seeds: <none>
[13:18:57.668] getGlobalsAndPackages() ...
[13:18:57.668] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.668] Resolving globals: FALSE
[13:18:57.668] Tweak future expression to call with '...' arguments ...
[13:18:57.668] {
[13:18:57.668]     do.call(function(...) {
[13:18:57.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.668]             on.exit(options(oopts), add = TRUE)
[13:18:57.668]         }
[13:18:57.668]         {
[13:18:57.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.668]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.668]             })
[13:18:57.668]         }
[13:18:57.668]     }, args = future.call.arguments)
[13:18:57.668] }
[13:18:57.668] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.669] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.669] - packages: [1] ‘future.apply’
[13:18:57.669] getGlobalsAndPackages() ... DONE
[13:18:57.669] run() for ‘Future’ ...
[13:18:57.669] - state: ‘created’
[13:18:57.669] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.670] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.670] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.670]   - Field: ‘label’
[13:18:57.670]   - Field: ‘local’
[13:18:57.670]   - Field: ‘owner’
[13:18:57.670]   - Field: ‘envir’
[13:18:57.670]   - Field: ‘packages’
[13:18:57.670]   - Field: ‘gc’
[13:18:57.671]   - Field: ‘conditions’
[13:18:57.671]   - Field: ‘expr’
[13:18:57.671]   - Field: ‘uuid’
[13:18:57.671]   - Field: ‘seed’
[13:18:57.671]   - Field: ‘version’
[13:18:57.671]   - Field: ‘result’
[13:18:57.671]   - Field: ‘asynchronous’
[13:18:57.671]   - Field: ‘calls’
[13:18:57.671]   - Field: ‘globals’
[13:18:57.671]   - Field: ‘stdout’
[13:18:57.671]   - Field: ‘earlySignal’
[13:18:57.671]   - Field: ‘lazy’
[13:18:57.672]   - Field: ‘state’
[13:18:57.672] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.672] - Launch lazy future ...
[13:18:57.672] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.672] Packages needed by future strategies (n = 0): <none>
[13:18:57.673] {
[13:18:57.673]     {
[13:18:57.673]         {
[13:18:57.673]             ...future.startTime <- base::Sys.time()
[13:18:57.673]             {
[13:18:57.673]                 {
[13:18:57.673]                   {
[13:18:57.673]                     {
[13:18:57.673]                       base::local({
[13:18:57.673]                         has_future <- base::requireNamespace("future", 
[13:18:57.673]                           quietly = TRUE)
[13:18:57.673]                         if (has_future) {
[13:18:57.673]                           ns <- base::getNamespace("future")
[13:18:57.673]                           version <- ns[[".package"]][["version"]]
[13:18:57.673]                           if (is.null(version)) 
[13:18:57.673]                             version <- utils::packageVersion("future")
[13:18:57.673]                         }
[13:18:57.673]                         else {
[13:18:57.673]                           version <- NULL
[13:18:57.673]                         }
[13:18:57.673]                         if (!has_future || version < "1.8.0") {
[13:18:57.673]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.673]                             "", base::R.version$version.string), 
[13:18:57.673]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.673]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.673]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.673]                               "release", "version")], collapse = " "), 
[13:18:57.673]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.673]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.673]                             info)
[13:18:57.673]                           info <- base::paste(info, collapse = "; ")
[13:18:57.673]                           if (!has_future) {
[13:18:57.673]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.673]                               info)
[13:18:57.673]                           }
[13:18:57.673]                           else {
[13:18:57.673]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.673]                               info, version)
[13:18:57.673]                           }
[13:18:57.673]                           base::stop(msg)
[13:18:57.673]                         }
[13:18:57.673]                       })
[13:18:57.673]                     }
[13:18:57.673]                     base::local({
[13:18:57.673]                       for (pkg in "future.apply") {
[13:18:57.673]                         base::loadNamespace(pkg)
[13:18:57.673]                         base::library(pkg, character.only = TRUE)
[13:18:57.673]                       }
[13:18:57.673]                     })
[13:18:57.673]                   }
[13:18:57.673]                   options(future.plan = NULL)
[13:18:57.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.673]                 }
[13:18:57.673]                 ...future.workdir <- getwd()
[13:18:57.673]             }
[13:18:57.673]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.673]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.673]         }
[13:18:57.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.673]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.673]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.673]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.673]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.673]             base::names(...future.oldOptions))
[13:18:57.673]     }
[13:18:57.673]     if (FALSE) {
[13:18:57.673]     }
[13:18:57.673]     else {
[13:18:57.673]         if (TRUE) {
[13:18:57.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.673]                 open = "w")
[13:18:57.673]         }
[13:18:57.673]         else {
[13:18:57.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.673]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.673]         }
[13:18:57.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.673]             base::sink(type = "output", split = FALSE)
[13:18:57.673]             base::close(...future.stdout)
[13:18:57.673]         }, add = TRUE)
[13:18:57.673]     }
[13:18:57.673]     ...future.frame <- base::sys.nframe()
[13:18:57.673]     ...future.conditions <- base::list()
[13:18:57.673]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.673]     if (FALSE) {
[13:18:57.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.673]     }
[13:18:57.673]     ...future.result <- base::tryCatch({
[13:18:57.673]         base::withCallingHandlers({
[13:18:57.673]             ...future.value <- base::withVisible(base::local({
[13:18:57.673]                 do.call(function(...) {
[13:18:57.673]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.673]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.673]                     ...future.globals.maxSize)) {
[13:18:57.673]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.673]                     on.exit(options(oopts), add = TRUE)
[13:18:57.673]                   }
[13:18:57.673]                   {
[13:18:57.673]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.673]                       FUN = function(jj) {
[13:18:57.673]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.673]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.673]                       })
[13:18:57.673]                   }
[13:18:57.673]                 }, args = future.call.arguments)
[13:18:57.673]             }))
[13:18:57.673]             future::FutureResult(value = ...future.value$value, 
[13:18:57.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.673]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.673]                     ...future.globalenv.names))
[13:18:57.673]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.673]         }, condition = base::local({
[13:18:57.673]             c <- base::c
[13:18:57.673]             inherits <- base::inherits
[13:18:57.673]             invokeRestart <- base::invokeRestart
[13:18:57.673]             length <- base::length
[13:18:57.673]             list <- base::list
[13:18:57.673]             seq.int <- base::seq.int
[13:18:57.673]             signalCondition <- base::signalCondition
[13:18:57.673]             sys.calls <- base::sys.calls
[13:18:57.673]             `[[` <- base::`[[`
[13:18:57.673]             `+` <- base::`+`
[13:18:57.673]             `<<-` <- base::`<<-`
[13:18:57.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.673]                   3L)]
[13:18:57.673]             }
[13:18:57.673]             function(cond) {
[13:18:57.673]                 is_error <- inherits(cond, "error")
[13:18:57.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.673]                   NULL)
[13:18:57.673]                 if (is_error) {
[13:18:57.673]                   sessionInformation <- function() {
[13:18:57.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.673]                       search = base::search(), system = base::Sys.info())
[13:18:57.673]                   }
[13:18:57.673]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.673]                     cond$call), session = sessionInformation(), 
[13:18:57.673]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.673]                   signalCondition(cond)
[13:18:57.673]                 }
[13:18:57.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.673]                 "immediateCondition"))) {
[13:18:57.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.673]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.673]                   if (TRUE && !signal) {
[13:18:57.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.673]                     {
[13:18:57.673]                       inherits <- base::inherits
[13:18:57.673]                       invokeRestart <- base::invokeRestart
[13:18:57.673]                       is.null <- base::is.null
[13:18:57.673]                       muffled <- FALSE
[13:18:57.673]                       if (inherits(cond, "message")) {
[13:18:57.673]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.673]                         if (muffled) 
[13:18:57.673]                           invokeRestart("muffleMessage")
[13:18:57.673]                       }
[13:18:57.673]                       else if (inherits(cond, "warning")) {
[13:18:57.673]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.673]                         if (muffled) 
[13:18:57.673]                           invokeRestart("muffleWarning")
[13:18:57.673]                       }
[13:18:57.673]                       else if (inherits(cond, "condition")) {
[13:18:57.673]                         if (!is.null(pattern)) {
[13:18:57.673]                           computeRestarts <- base::computeRestarts
[13:18:57.673]                           grepl <- base::grepl
[13:18:57.673]                           restarts <- computeRestarts(cond)
[13:18:57.673]                           for (restart in restarts) {
[13:18:57.673]                             name <- restart$name
[13:18:57.673]                             if (is.null(name)) 
[13:18:57.673]                               next
[13:18:57.673]                             if (!grepl(pattern, name)) 
[13:18:57.673]                               next
[13:18:57.673]                             invokeRestart(restart)
[13:18:57.673]                             muffled <- TRUE
[13:18:57.673]                             break
[13:18:57.673]                           }
[13:18:57.673]                         }
[13:18:57.673]                       }
[13:18:57.673]                       invisible(muffled)
[13:18:57.673]                     }
[13:18:57.673]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.673]                   }
[13:18:57.673]                 }
[13:18:57.673]                 else {
[13:18:57.673]                   if (TRUE) {
[13:18:57.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.673]                     {
[13:18:57.673]                       inherits <- base::inherits
[13:18:57.673]                       invokeRestart <- base::invokeRestart
[13:18:57.673]                       is.null <- base::is.null
[13:18:57.673]                       muffled <- FALSE
[13:18:57.673]                       if (inherits(cond, "message")) {
[13:18:57.673]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.673]                         if (muffled) 
[13:18:57.673]                           invokeRestart("muffleMessage")
[13:18:57.673]                       }
[13:18:57.673]                       else if (inherits(cond, "warning")) {
[13:18:57.673]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.673]                         if (muffled) 
[13:18:57.673]                           invokeRestart("muffleWarning")
[13:18:57.673]                       }
[13:18:57.673]                       else if (inherits(cond, "condition")) {
[13:18:57.673]                         if (!is.null(pattern)) {
[13:18:57.673]                           computeRestarts <- base::computeRestarts
[13:18:57.673]                           grepl <- base::grepl
[13:18:57.673]                           restarts <- computeRestarts(cond)
[13:18:57.673]                           for (restart in restarts) {
[13:18:57.673]                             name <- restart$name
[13:18:57.673]                             if (is.null(name)) 
[13:18:57.673]                               next
[13:18:57.673]                             if (!grepl(pattern, name)) 
[13:18:57.673]                               next
[13:18:57.673]                             invokeRestart(restart)
[13:18:57.673]                             muffled <- TRUE
[13:18:57.673]                             break
[13:18:57.673]                           }
[13:18:57.673]                         }
[13:18:57.673]                       }
[13:18:57.673]                       invisible(muffled)
[13:18:57.673]                     }
[13:18:57.673]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.673]                   }
[13:18:57.673]                 }
[13:18:57.673]             }
[13:18:57.673]         }))
[13:18:57.673]     }, error = function(ex) {
[13:18:57.673]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.673]                 ...future.rng), started = ...future.startTime, 
[13:18:57.673]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.673]             version = "1.8"), class = "FutureResult")
[13:18:57.673]     }, finally = {
[13:18:57.673]         if (!identical(...future.workdir, getwd())) 
[13:18:57.673]             setwd(...future.workdir)
[13:18:57.673]         {
[13:18:57.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.673]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.673]             }
[13:18:57.673]             base::options(...future.oldOptions)
[13:18:57.673]             if (.Platform$OS.type == "windows") {
[13:18:57.673]                 old_names <- names(...future.oldEnvVars)
[13:18:57.673]                 envs <- base::Sys.getenv()
[13:18:57.673]                 names <- names(envs)
[13:18:57.673]                 common <- intersect(names, old_names)
[13:18:57.673]                 added <- setdiff(names, old_names)
[13:18:57.673]                 removed <- setdiff(old_names, names)
[13:18:57.673]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.673]                   envs[common]]
[13:18:57.673]                 NAMES <- toupper(changed)
[13:18:57.673]                 args <- list()
[13:18:57.673]                 for (kk in seq_along(NAMES)) {
[13:18:57.673]                   name <- changed[[kk]]
[13:18:57.673]                   NAME <- NAMES[[kk]]
[13:18:57.673]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.673]                     next
[13:18:57.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.673]                 }
[13:18:57.673]                 NAMES <- toupper(added)
[13:18:57.673]                 for (kk in seq_along(NAMES)) {
[13:18:57.673]                   name <- added[[kk]]
[13:18:57.673]                   NAME <- NAMES[[kk]]
[13:18:57.673]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.673]                     next
[13:18:57.673]                   args[[name]] <- ""
[13:18:57.673]                 }
[13:18:57.673]                 NAMES <- toupper(removed)
[13:18:57.673]                 for (kk in seq_along(NAMES)) {
[13:18:57.673]                   name <- removed[[kk]]
[13:18:57.673]                   NAME <- NAMES[[kk]]
[13:18:57.673]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.673]                     next
[13:18:57.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.673]                 }
[13:18:57.673]                 if (length(args) > 0) 
[13:18:57.673]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.673]             }
[13:18:57.673]             else {
[13:18:57.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.673]             }
[13:18:57.673]             {
[13:18:57.673]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.673]                   0L) {
[13:18:57.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.673]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.673]                   base::options(opts)
[13:18:57.673]                 }
[13:18:57.673]                 {
[13:18:57.673]                   {
[13:18:57.673]                     NULL
[13:18:57.673]                     RNGkind("Mersenne-Twister")
[13:18:57.673]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.673]                       inherits = FALSE)
[13:18:57.673]                   }
[13:18:57.673]                   options(future.plan = NULL)
[13:18:57.673]                   if (is.na(NA_character_)) 
[13:18:57.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.673]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.673]                   {
[13:18:57.673]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.673]                     if (!future$lazy) 
[13:18:57.673]                       future <- run(future)
[13:18:57.673]                     invisible(future)
[13:18:57.673]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.673]                 }
[13:18:57.673]             }
[13:18:57.673]         }
[13:18:57.673]     })
[13:18:57.673]     if (TRUE) {
[13:18:57.673]         base::sink(type = "output", split = FALSE)
[13:18:57.673]         if (TRUE) {
[13:18:57.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.673]         }
[13:18:57.673]         else {
[13:18:57.673]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.673]         }
[13:18:57.673]         base::close(...future.stdout)
[13:18:57.673]         ...future.stdout <- NULL
[13:18:57.673]     }
[13:18:57.673]     ...future.result$conditions <- ...future.conditions
[13:18:57.673]     ...future.result$finished <- base::Sys.time()
[13:18:57.673]     ...future.result
[13:18:57.673] }
[13:18:57.674] assign_globals() ...
[13:18:57.674] List of 11
[13:18:57.674]  $ ...future.FUN            :function (x, ...)  
[13:18:57.674]  $ x_FUN                    :function (x)  
[13:18:57.674]  $ times                    : int 4
[13:18:57.674]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.674]  $ stop_if_not              :function (...)  
[13:18:57.674]  $ dim                      : int [1:2] 2 2
[13:18:57.674]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:57.674]  $ future.call.arguments    : list()
[13:18:57.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.674]  $ ...future.elements_ii    :List of 10
[13:18:57.674]   ..$ : int 1
[13:18:57.674]   ..$ : int 2
[13:18:57.674]   ..$ : int 3
[13:18:57.674]   ..$ : int 4
[13:18:57.674]   ..$ : int 5
[13:18:57.674]   ..$ : int 6
[13:18:57.674]   ..$ : int 7
[13:18:57.674]   ..$ : int 8
[13:18:57.674]   ..$ : int 9
[13:18:57.674]   ..$ : int 10
[13:18:57.674]  $ ...future.seeds_ii       : NULL
[13:18:57.674]  $ ...future.globals.maxSize: NULL
[13:18:57.674]  - attr(*, "resolved")= logi FALSE
[13:18:57.674]  - attr(*, "total_size")= num 97232
[13:18:57.674]  - attr(*, "where")=List of 11
[13:18:57.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.674]  - attr(*, "already-done")= logi TRUE
[13:18:57.685] - copied ‘...future.FUN’ to environment
[13:18:57.685] - reassign environment for ‘x_FUN’
[13:18:57.685] - copied ‘x_FUN’ to environment
[13:18:57.686] - copied ‘times’ to environment
[13:18:57.686] - copied ‘stopf’ to environment
[13:18:57.686] - copied ‘stop_if_not’ to environment
[13:18:57.686] - copied ‘dim’ to environment
[13:18:57.686] - copied ‘valid_types’ to environment
[13:18:57.686] - copied ‘future.call.arguments’ to environment
[13:18:57.686] - copied ‘...future.elements_ii’ to environment
[13:18:57.686] - copied ‘...future.seeds_ii’ to environment
[13:18:57.686] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.686] assign_globals() ... done
[13:18:57.687] plan(): Setting new future strategy stack:
[13:18:57.687] List of future strategies:
[13:18:57.687] 1. sequential:
[13:18:57.687]    - args: function (..., envir = parent.frame())
[13:18:57.687]    - tweaked: FALSE
[13:18:57.687]    - call: NULL
[13:18:57.687] plan(): nbrOfWorkers() = 1
[13:18:57.688] plan(): Setting new future strategy stack:
[13:18:57.688] List of future strategies:
[13:18:57.688] 1. sequential:
[13:18:57.688]    - args: function (..., envir = parent.frame())
[13:18:57.688]    - tweaked: FALSE
[13:18:57.688]    - call: plan(strategy)
[13:18:57.688] plan(): nbrOfWorkers() = 1
[13:18:57.689] SequentialFuture started (and completed)
[13:18:57.689] - Launch lazy future ... done
[13:18:57.689] run() for ‘SequentialFuture’ ... done
[13:18:57.689] Created future:
[13:18:57.689] SequentialFuture:
[13:18:57.689] Label: ‘future_vapply-1’
[13:18:57.689] Expression:
[13:18:57.689] {
[13:18:57.689]     do.call(function(...) {
[13:18:57.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.689]             on.exit(options(oopts), add = TRUE)
[13:18:57.689]         }
[13:18:57.689]         {
[13:18:57.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.689]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.689]             })
[13:18:57.689]         }
[13:18:57.689]     }, args = future.call.arguments)
[13:18:57.689] }
[13:18:57.689] Lazy evaluation: FALSE
[13:18:57.689] Asynchronous evaluation: FALSE
[13:18:57.689] Local evaluation: TRUE
[13:18:57.689] Environment: R_GlobalEnv
[13:18:57.689] Capture standard output: TRUE
[13:18:57.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.689] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.689] Packages: 1 packages (‘future.apply’)
[13:18:57.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.689] Resolved: TRUE
[13:18:57.689] Value: 2.27 KiB of class ‘list’
[13:18:57.689] Early signaling: FALSE
[13:18:57.689] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.689] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.690] Chunk #1 of 1 ... DONE
[13:18:57.690] Launching 1 futures (chunks) ... DONE
[13:18:57.690] Resolving 1 futures (chunks) ...
[13:18:57.691] resolve() on list ...
[13:18:57.691]  recursive: 0
[13:18:57.691]  length: 1
[13:18:57.691] 
[13:18:57.691] resolved() for ‘SequentialFuture’ ...
[13:18:57.691] - state: ‘finished’
[13:18:57.691] - run: TRUE
[13:18:57.691] - result: ‘FutureResult’
[13:18:57.691] resolved() for ‘SequentialFuture’ ... done
[13:18:57.691] Future #1
[13:18:57.691] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.692] - nx: 1
[13:18:57.692] - relay: TRUE
[13:18:57.692] - stdout: TRUE
[13:18:57.692] - signal: TRUE
[13:18:57.692] - resignal: FALSE
[13:18:57.692] - force: TRUE
[13:18:57.692] - relayed: [n=1] FALSE
[13:18:57.692] - queued futures: [n=1] FALSE
[13:18:57.692]  - until=1
[13:18:57.692]  - relaying element #1
[13:18:57.693] - relayed: [n=1] TRUE
[13:18:57.693] - queued futures: [n=1] TRUE
[13:18:57.693] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.693]  length: 0 (resolved future 1)
[13:18:57.693] Relaying remaining futures
[13:18:57.693] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.693] - nx: 1
[13:18:57.693] - relay: TRUE
[13:18:57.693] - stdout: TRUE
[13:18:57.693] - signal: TRUE
[13:18:57.693] - resignal: FALSE
[13:18:57.693] - force: TRUE
[13:18:57.694] - relayed: [n=1] TRUE
[13:18:57.694] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.694] - relayed: [n=1] TRUE
[13:18:57.694] - queued futures: [n=1] TRUE
[13:18:57.694] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.694] resolve() on list ... DONE
[13:18:57.694]  - Number of value chunks collected: 1
[13:18:57.694] Resolving 1 futures (chunks) ... DONE
[13:18:57.694] Reducing values from 1 chunks ...
[13:18:57.694]  - Number of values collected after concatenation: 10
[13:18:57.694]  - Number of values expected: 10
[13:18:57.695] Reducing values from 1 chunks ... DONE
[13:18:57.695] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:18:57.695] future_lapply() ...
[13:18:57.697] Number of chunks: 1
[13:18:57.697] getGlobalsAndPackagesXApply() ...
[13:18:57.697]  - future.globals: TRUE
[13:18:57.697] getGlobalsAndPackages() ...
[13:18:57.698] Searching for globals...
[13:18:57.701] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:18:57.701] Searching for globals ... DONE
[13:18:57.701] Resolving globals: FALSE
[13:18:57.702] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:18:57.703] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.703] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.704] - packages: [1] ‘future.apply’
[13:18:57.704] getGlobalsAndPackages() ... DONE
[13:18:57.704]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.704]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.704] Finding globals ... DONE
[13:18:57.704]  - use_args: TRUE
[13:18:57.704]  - Getting '...' globals ...
[13:18:57.704] resolve() on list ...
[13:18:57.705]  recursive: 0
[13:18:57.705]  length: 1
[13:18:57.705]  elements: ‘...’
[13:18:57.705]  length: 0 (resolved future 1)
[13:18:57.705] resolve() on list ... DONE
[13:18:57.705]    - '...' content: [n=0] 
[13:18:57.705] List of 1
[13:18:57.705]  $ ...: list()
[13:18:57.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.705]  - attr(*, "where")=List of 1
[13:18:57.705]   ..$ ...:<environment: 0x555f7b5527c0> 
[13:18:57.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.705]  - attr(*, "resolved")= logi TRUE
[13:18:57.705]  - attr(*, "total_size")= num NA
[13:18:57.707]  - Getting '...' globals ... DONE
[13:18:57.708] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.708] List of 8
[13:18:57.708]  $ ...future.FUN:function (x, ...)  
[13:18:57.708]  $ x_FUN        :function (x)  
[13:18:57.708]  $ times        : int 4
[13:18:57.708]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.708]  $ stop_if_not  :function (...)  
[13:18:57.708]  $ dim          : int [1:2] 2 2
[13:18:57.708]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.708]  $ ...          : list()
[13:18:57.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.708]  - attr(*, "where")=List of 8
[13:18:57.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.708]   ..$ ...          :<environment: 0x555f7b5527c0> 
[13:18:57.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.708]  - attr(*, "resolved")= logi FALSE
[13:18:57.708]  - attr(*, "total_size")= num 97304
[13:18:57.713] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.713] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.713] Number of futures (= number of chunks): 1
[13:18:57.713] Launching 1 futures (chunks) ...
[13:18:57.713] Chunk #1 of 1 ...
[13:18:57.714]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.714] getGlobalsAndPackages() ...
[13:18:57.714] Searching for globals...
[13:18:57.714] 
[13:18:57.714] Searching for globals ... DONE
[13:18:57.714] - globals: [0] <none>
[13:18:57.714] getGlobalsAndPackages() ... DONE
[13:18:57.714]    + additional globals found: [n=0] 
[13:18:57.714]    + additional namespaces needed: [n=0] 
[13:18:57.714]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.715]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.715]  - seeds: <none>
[13:18:57.715] getGlobalsAndPackages() ...
[13:18:57.715] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.715] Resolving globals: FALSE
[13:18:57.715] Tweak future expression to call with '...' arguments ...
[13:18:57.715] {
[13:18:57.715]     do.call(function(...) {
[13:18:57.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.715]             on.exit(options(oopts), add = TRUE)
[13:18:57.715]         }
[13:18:57.715]         {
[13:18:57.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.715]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.715]             })
[13:18:57.715]         }
[13:18:57.715]     }, args = future.call.arguments)
[13:18:57.715] }
[13:18:57.715] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.716] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.716] - packages: [1] ‘future.apply’
[13:18:57.716] getGlobalsAndPackages() ... DONE
[13:18:57.716] run() for ‘Future’ ...
[13:18:57.716] - state: ‘created’
[13:18:57.717] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.717]   - Field: ‘label’
[13:18:57.717]   - Field: ‘local’
[13:18:57.717]   - Field: ‘owner’
[13:18:57.717]   - Field: ‘envir’
[13:18:57.717]   - Field: ‘packages’
[13:18:57.718]   - Field: ‘gc’
[13:18:57.718]   - Field: ‘conditions’
[13:18:57.718]   - Field: ‘expr’
[13:18:57.718]   - Field: ‘uuid’
[13:18:57.718]   - Field: ‘seed’
[13:18:57.718]   - Field: ‘version’
[13:18:57.718]   - Field: ‘result’
[13:18:57.718]   - Field: ‘asynchronous’
[13:18:57.718]   - Field: ‘calls’
[13:18:57.718]   - Field: ‘globals’
[13:18:57.718]   - Field: ‘stdout’
[13:18:57.719]   - Field: ‘earlySignal’
[13:18:57.719]   - Field: ‘lazy’
[13:18:57.719]   - Field: ‘state’
[13:18:57.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.719] - Launch lazy future ...
[13:18:57.719] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.719] Packages needed by future strategies (n = 0): <none>
[13:18:57.720] {
[13:18:57.720]     {
[13:18:57.720]         {
[13:18:57.720]             ...future.startTime <- base::Sys.time()
[13:18:57.720]             {
[13:18:57.720]                 {
[13:18:57.720]                   {
[13:18:57.720]                     {
[13:18:57.720]                       base::local({
[13:18:57.720]                         has_future <- base::requireNamespace("future", 
[13:18:57.720]                           quietly = TRUE)
[13:18:57.720]                         if (has_future) {
[13:18:57.720]                           ns <- base::getNamespace("future")
[13:18:57.720]                           version <- ns[[".package"]][["version"]]
[13:18:57.720]                           if (is.null(version)) 
[13:18:57.720]                             version <- utils::packageVersion("future")
[13:18:57.720]                         }
[13:18:57.720]                         else {
[13:18:57.720]                           version <- NULL
[13:18:57.720]                         }
[13:18:57.720]                         if (!has_future || version < "1.8.0") {
[13:18:57.720]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.720]                             "", base::R.version$version.string), 
[13:18:57.720]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.720]                               "release", "version")], collapse = " "), 
[13:18:57.720]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.720]                             info)
[13:18:57.720]                           info <- base::paste(info, collapse = "; ")
[13:18:57.720]                           if (!has_future) {
[13:18:57.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.720]                               info)
[13:18:57.720]                           }
[13:18:57.720]                           else {
[13:18:57.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.720]                               info, version)
[13:18:57.720]                           }
[13:18:57.720]                           base::stop(msg)
[13:18:57.720]                         }
[13:18:57.720]                       })
[13:18:57.720]                     }
[13:18:57.720]                     base::local({
[13:18:57.720]                       for (pkg in "future.apply") {
[13:18:57.720]                         base::loadNamespace(pkg)
[13:18:57.720]                         base::library(pkg, character.only = TRUE)
[13:18:57.720]                       }
[13:18:57.720]                     })
[13:18:57.720]                   }
[13:18:57.720]                   options(future.plan = NULL)
[13:18:57.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.720]                 }
[13:18:57.720]                 ...future.workdir <- getwd()
[13:18:57.720]             }
[13:18:57.720]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.720]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.720]         }
[13:18:57.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.720]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.720]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.720]             base::names(...future.oldOptions))
[13:18:57.720]     }
[13:18:57.720]     if (FALSE) {
[13:18:57.720]     }
[13:18:57.720]     else {
[13:18:57.720]         if (TRUE) {
[13:18:57.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.720]                 open = "w")
[13:18:57.720]         }
[13:18:57.720]         else {
[13:18:57.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.720]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.720]         }
[13:18:57.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.720]             base::sink(type = "output", split = FALSE)
[13:18:57.720]             base::close(...future.stdout)
[13:18:57.720]         }, add = TRUE)
[13:18:57.720]     }
[13:18:57.720]     ...future.frame <- base::sys.nframe()
[13:18:57.720]     ...future.conditions <- base::list()
[13:18:57.720]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.720]     if (FALSE) {
[13:18:57.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.720]     }
[13:18:57.720]     ...future.result <- base::tryCatch({
[13:18:57.720]         base::withCallingHandlers({
[13:18:57.720]             ...future.value <- base::withVisible(base::local({
[13:18:57.720]                 do.call(function(...) {
[13:18:57.720]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.720]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.720]                     ...future.globals.maxSize)) {
[13:18:57.720]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.720]                     on.exit(options(oopts), add = TRUE)
[13:18:57.720]                   }
[13:18:57.720]                   {
[13:18:57.720]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.720]                       FUN = function(jj) {
[13:18:57.720]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.720]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.720]                       })
[13:18:57.720]                   }
[13:18:57.720]                 }, args = future.call.arguments)
[13:18:57.720]             }))
[13:18:57.720]             future::FutureResult(value = ...future.value$value, 
[13:18:57.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.720]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.720]                     ...future.globalenv.names))
[13:18:57.720]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.720]         }, condition = base::local({
[13:18:57.720]             c <- base::c
[13:18:57.720]             inherits <- base::inherits
[13:18:57.720]             invokeRestart <- base::invokeRestart
[13:18:57.720]             length <- base::length
[13:18:57.720]             list <- base::list
[13:18:57.720]             seq.int <- base::seq.int
[13:18:57.720]             signalCondition <- base::signalCondition
[13:18:57.720]             sys.calls <- base::sys.calls
[13:18:57.720]             `[[` <- base::`[[`
[13:18:57.720]             `+` <- base::`+`
[13:18:57.720]             `<<-` <- base::`<<-`
[13:18:57.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.720]                   3L)]
[13:18:57.720]             }
[13:18:57.720]             function(cond) {
[13:18:57.720]                 is_error <- inherits(cond, "error")
[13:18:57.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.720]                   NULL)
[13:18:57.720]                 if (is_error) {
[13:18:57.720]                   sessionInformation <- function() {
[13:18:57.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.720]                       search = base::search(), system = base::Sys.info())
[13:18:57.720]                   }
[13:18:57.720]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.720]                     cond$call), session = sessionInformation(), 
[13:18:57.720]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.720]                   signalCondition(cond)
[13:18:57.720]                 }
[13:18:57.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.720]                 "immediateCondition"))) {
[13:18:57.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.720]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.720]                   if (TRUE && !signal) {
[13:18:57.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.720]                     {
[13:18:57.720]                       inherits <- base::inherits
[13:18:57.720]                       invokeRestart <- base::invokeRestart
[13:18:57.720]                       is.null <- base::is.null
[13:18:57.720]                       muffled <- FALSE
[13:18:57.720]                       if (inherits(cond, "message")) {
[13:18:57.720]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.720]                         if (muffled) 
[13:18:57.720]                           invokeRestart("muffleMessage")
[13:18:57.720]                       }
[13:18:57.720]                       else if (inherits(cond, "warning")) {
[13:18:57.720]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.720]                         if (muffled) 
[13:18:57.720]                           invokeRestart("muffleWarning")
[13:18:57.720]                       }
[13:18:57.720]                       else if (inherits(cond, "condition")) {
[13:18:57.720]                         if (!is.null(pattern)) {
[13:18:57.720]                           computeRestarts <- base::computeRestarts
[13:18:57.720]                           grepl <- base::grepl
[13:18:57.720]                           restarts <- computeRestarts(cond)
[13:18:57.720]                           for (restart in restarts) {
[13:18:57.720]                             name <- restart$name
[13:18:57.720]                             if (is.null(name)) 
[13:18:57.720]                               next
[13:18:57.720]                             if (!grepl(pattern, name)) 
[13:18:57.720]                               next
[13:18:57.720]                             invokeRestart(restart)
[13:18:57.720]                             muffled <- TRUE
[13:18:57.720]                             break
[13:18:57.720]                           }
[13:18:57.720]                         }
[13:18:57.720]                       }
[13:18:57.720]                       invisible(muffled)
[13:18:57.720]                     }
[13:18:57.720]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.720]                   }
[13:18:57.720]                 }
[13:18:57.720]                 else {
[13:18:57.720]                   if (TRUE) {
[13:18:57.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.720]                     {
[13:18:57.720]                       inherits <- base::inherits
[13:18:57.720]                       invokeRestart <- base::invokeRestart
[13:18:57.720]                       is.null <- base::is.null
[13:18:57.720]                       muffled <- FALSE
[13:18:57.720]                       if (inherits(cond, "message")) {
[13:18:57.720]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.720]                         if (muffled) 
[13:18:57.720]                           invokeRestart("muffleMessage")
[13:18:57.720]                       }
[13:18:57.720]                       else if (inherits(cond, "warning")) {
[13:18:57.720]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.720]                         if (muffled) 
[13:18:57.720]                           invokeRestart("muffleWarning")
[13:18:57.720]                       }
[13:18:57.720]                       else if (inherits(cond, "condition")) {
[13:18:57.720]                         if (!is.null(pattern)) {
[13:18:57.720]                           computeRestarts <- base::computeRestarts
[13:18:57.720]                           grepl <- base::grepl
[13:18:57.720]                           restarts <- computeRestarts(cond)
[13:18:57.720]                           for (restart in restarts) {
[13:18:57.720]                             name <- restart$name
[13:18:57.720]                             if (is.null(name)) 
[13:18:57.720]                               next
[13:18:57.720]                             if (!grepl(pattern, name)) 
[13:18:57.720]                               next
[13:18:57.720]                             invokeRestart(restart)
[13:18:57.720]                             muffled <- TRUE
[13:18:57.720]                             break
[13:18:57.720]                           }
[13:18:57.720]                         }
[13:18:57.720]                       }
[13:18:57.720]                       invisible(muffled)
[13:18:57.720]                     }
[13:18:57.720]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.720]                   }
[13:18:57.720]                 }
[13:18:57.720]             }
[13:18:57.720]         }))
[13:18:57.720]     }, error = function(ex) {
[13:18:57.720]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.720]                 ...future.rng), started = ...future.startTime, 
[13:18:57.720]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.720]             version = "1.8"), class = "FutureResult")
[13:18:57.720]     }, finally = {
[13:18:57.720]         if (!identical(...future.workdir, getwd())) 
[13:18:57.720]             setwd(...future.workdir)
[13:18:57.720]         {
[13:18:57.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.720]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.720]             }
[13:18:57.720]             base::options(...future.oldOptions)
[13:18:57.720]             if (.Platform$OS.type == "windows") {
[13:18:57.720]                 old_names <- names(...future.oldEnvVars)
[13:18:57.720]                 envs <- base::Sys.getenv()
[13:18:57.720]                 names <- names(envs)
[13:18:57.720]                 common <- intersect(names, old_names)
[13:18:57.720]                 added <- setdiff(names, old_names)
[13:18:57.720]                 removed <- setdiff(old_names, names)
[13:18:57.720]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.720]                   envs[common]]
[13:18:57.720]                 NAMES <- toupper(changed)
[13:18:57.720]                 args <- list()
[13:18:57.720]                 for (kk in seq_along(NAMES)) {
[13:18:57.720]                   name <- changed[[kk]]
[13:18:57.720]                   NAME <- NAMES[[kk]]
[13:18:57.720]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.720]                     next
[13:18:57.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.720]                 }
[13:18:57.720]                 NAMES <- toupper(added)
[13:18:57.720]                 for (kk in seq_along(NAMES)) {
[13:18:57.720]                   name <- added[[kk]]
[13:18:57.720]                   NAME <- NAMES[[kk]]
[13:18:57.720]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.720]                     next
[13:18:57.720]                   args[[name]] <- ""
[13:18:57.720]                 }
[13:18:57.720]                 NAMES <- toupper(removed)
[13:18:57.720]                 for (kk in seq_along(NAMES)) {
[13:18:57.720]                   name <- removed[[kk]]
[13:18:57.720]                   NAME <- NAMES[[kk]]
[13:18:57.720]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.720]                     next
[13:18:57.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.720]                 }
[13:18:57.720]                 if (length(args) > 0) 
[13:18:57.720]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.720]             }
[13:18:57.720]             else {
[13:18:57.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.720]             }
[13:18:57.720]             {
[13:18:57.720]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.720]                   0L) {
[13:18:57.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.720]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.720]                   base::options(opts)
[13:18:57.720]                 }
[13:18:57.720]                 {
[13:18:57.720]                   {
[13:18:57.720]                     NULL
[13:18:57.720]                     RNGkind("Mersenne-Twister")
[13:18:57.720]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.720]                       inherits = FALSE)
[13:18:57.720]                   }
[13:18:57.720]                   options(future.plan = NULL)
[13:18:57.720]                   if (is.na(NA_character_)) 
[13:18:57.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.720]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.720]                   {
[13:18:57.720]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.720]                     if (!future$lazy) 
[13:18:57.720]                       future <- run(future)
[13:18:57.720]                     invisible(future)
[13:18:57.720]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.720]                 }
[13:18:57.720]             }
[13:18:57.720]         }
[13:18:57.720]     })
[13:18:57.720]     if (TRUE) {
[13:18:57.720]         base::sink(type = "output", split = FALSE)
[13:18:57.720]         if (TRUE) {
[13:18:57.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.720]         }
[13:18:57.720]         else {
[13:18:57.720]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.720]         }
[13:18:57.720]         base::close(...future.stdout)
[13:18:57.720]         ...future.stdout <- NULL
[13:18:57.720]     }
[13:18:57.720]     ...future.result$conditions <- ...future.conditions
[13:18:57.720]     ...future.result$finished <- base::Sys.time()
[13:18:57.720]     ...future.result
[13:18:57.720] }
[13:18:57.721] assign_globals() ...
[13:18:57.721] List of 11
[13:18:57.721]  $ ...future.FUN            :function (x, ...)  
[13:18:57.721]  $ x_FUN                    :function (x)  
[13:18:57.721]  $ times                    : int 4
[13:18:57.721]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.721]  $ stop_if_not              :function (...)  
[13:18:57.721]  $ dim                      : int [1:2] 2 2
[13:18:57.721]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.721]  $ future.call.arguments    : list()
[13:18:57.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.721]  $ ...future.elements_ii    :List of 10
[13:18:57.721]   ..$ : int 1
[13:18:57.721]   ..$ : int 2
[13:18:57.721]   ..$ : int 3
[13:18:57.721]   ..$ : int 4
[13:18:57.721]   ..$ : int 5
[13:18:57.721]   ..$ : int 6
[13:18:57.721]   ..$ : int 7
[13:18:57.721]   ..$ : int 8
[13:18:57.721]   ..$ : int 9
[13:18:57.721]   ..$ : int 10
[13:18:57.721]  $ ...future.seeds_ii       : NULL
[13:18:57.721]  $ ...future.globals.maxSize: NULL
[13:18:57.721]  - attr(*, "resolved")= logi FALSE
[13:18:57.721]  - attr(*, "total_size")= num 97304
[13:18:57.721]  - attr(*, "where")=List of 11
[13:18:57.721]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.721]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.721]  - attr(*, "already-done")= logi TRUE
[13:18:57.754] - copied ‘...future.FUN’ to environment
[13:18:57.755] - reassign environment for ‘x_FUN’
[13:18:57.755] - copied ‘x_FUN’ to environment
[13:18:57.755] - copied ‘times’ to environment
[13:18:57.755] - copied ‘stopf’ to environment
[13:18:57.755] - copied ‘stop_if_not’ to environment
[13:18:57.755] - copied ‘dim’ to environment
[13:18:57.755] - copied ‘valid_types’ to environment
[13:18:57.755] - copied ‘future.call.arguments’ to environment
[13:18:57.755] - copied ‘...future.elements_ii’ to environment
[13:18:57.755] - copied ‘...future.seeds_ii’ to environment
[13:18:57.756] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.756] assign_globals() ... done
[13:18:57.756] plan(): Setting new future strategy stack:
[13:18:57.756] List of future strategies:
[13:18:57.756] 1. sequential:
[13:18:57.756]    - args: function (..., envir = parent.frame())
[13:18:57.756]    - tweaked: FALSE
[13:18:57.756]    - call: NULL
[13:18:57.756] plan(): nbrOfWorkers() = 1
[13:18:57.757] plan(): Setting new future strategy stack:
[13:18:57.757] List of future strategies:
[13:18:57.757] 1. sequential:
[13:18:57.757]    - args: function (..., envir = parent.frame())
[13:18:57.757]    - tweaked: FALSE
[13:18:57.757]    - call: plan(strategy)
[13:18:57.758] plan(): nbrOfWorkers() = 1
[13:18:57.758] SequentialFuture started (and completed)
[13:18:57.758] - Launch lazy future ... done
[13:18:57.758] run() for ‘SequentialFuture’ ... done
[13:18:57.758] Created future:
[13:18:57.758] SequentialFuture:
[13:18:57.758] Label: ‘future_vapply-1’
[13:18:57.758] Expression:
[13:18:57.758] {
[13:18:57.758]     do.call(function(...) {
[13:18:57.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.758]             on.exit(options(oopts), add = TRUE)
[13:18:57.758]         }
[13:18:57.758]         {
[13:18:57.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.758]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.758]             })
[13:18:57.758]         }
[13:18:57.758]     }, args = future.call.arguments)
[13:18:57.758] }
[13:18:57.758] Lazy evaluation: FALSE
[13:18:57.758] Asynchronous evaluation: FALSE
[13:18:57.758] Local evaluation: TRUE
[13:18:57.758] Environment: R_GlobalEnv
[13:18:57.758] Capture standard output: TRUE
[13:18:57.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.758] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.758] Packages: 1 packages (‘future.apply’)
[13:18:57.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.758] Resolved: TRUE
[13:18:57.758] Value: 2.27 KiB of class ‘list’
[13:18:57.758] Early signaling: FALSE
[13:18:57.758] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.758] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.759] Chunk #1 of 1 ... DONE
[13:18:57.760] Launching 1 futures (chunks) ... DONE
[13:18:57.760] Resolving 1 futures (chunks) ...
[13:18:57.760] resolve() on list ...
[13:18:57.760]  recursive: 0
[13:18:57.760]  length: 1
[13:18:57.760] 
[13:18:57.760] resolved() for ‘SequentialFuture’ ...
[13:18:57.760] - state: ‘finished’
[13:18:57.760] - run: TRUE
[13:18:57.760] - result: ‘FutureResult’
[13:18:57.760] resolved() for ‘SequentialFuture’ ... done
[13:18:57.761] Future #1
[13:18:57.761] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.761] - nx: 1
[13:18:57.761] - relay: TRUE
[13:18:57.761] - stdout: TRUE
[13:18:57.761] - signal: TRUE
[13:18:57.761] - resignal: FALSE
[13:18:57.761] - force: TRUE
[13:18:57.761] - relayed: [n=1] FALSE
[13:18:57.761] - queued futures: [n=1] FALSE
[13:18:57.762]  - until=1
[13:18:57.762]  - relaying element #1
[13:18:57.762] - relayed: [n=1] TRUE
[13:18:57.762] - queued futures: [n=1] TRUE
[13:18:57.762] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.762]  length: 0 (resolved future 1)
[13:18:57.762] Relaying remaining futures
[13:18:57.762] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.762] - nx: 1
[13:18:57.762] - relay: TRUE
[13:18:57.762] - stdout: TRUE
[13:18:57.763] - signal: TRUE
[13:18:57.763] - resignal: FALSE
[13:18:57.763] - force: TRUE
[13:18:57.763] - relayed: [n=1] TRUE
[13:18:57.763] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.763] - relayed: [n=1] TRUE
[13:18:57.763] - queued futures: [n=1] TRUE
[13:18:57.763] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.763] resolve() on list ... DONE
[13:18:57.763]  - Number of value chunks collected: 1
[13:18:57.764] Resolving 1 futures (chunks) ... DONE
[13:18:57.764] Reducing values from 1 chunks ...
[13:18:57.764]  - Number of values collected after concatenation: 10
[13:18:57.764]  - Number of values expected: 10
[13:18:57.764] Reducing values from 1 chunks ... DONE
[13:18:57.764] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:18:57.766] future_lapply() ...
[13:18:57.768] Number of chunks: 1
[13:18:57.768] getGlobalsAndPackagesXApply() ...
[13:18:57.768]  - future.globals: TRUE
[13:18:57.768] getGlobalsAndPackages() ...
[13:18:57.768] Searching for globals...
[13:18:57.773] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:18:57.773] Searching for globals ... DONE
[13:18:57.773] Resolving globals: FALSE
[13:18:57.774] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:18:57.774] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.775] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.775] - packages: [1] ‘future.apply’
[13:18:57.775] getGlobalsAndPackages() ... DONE
[13:18:57.775]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.775]  - needed namespaces: [n=1] ‘future.apply’
[13:18:57.775] Finding globals ... DONE
[13:18:57.775]  - use_args: TRUE
[13:18:57.775]  - Getting '...' globals ...
[13:18:57.776] resolve() on list ...
[13:18:57.776]  recursive: 0
[13:18:57.776]  length: 1
[13:18:57.776]  elements: ‘...’
[13:18:57.776]  length: 0 (resolved future 1)
[13:18:57.776] resolve() on list ... DONE
[13:18:57.776]    - '...' content: [n=0] 
[13:18:57.776] List of 1
[13:18:57.776]  $ ...: list()
[13:18:57.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.776]  - attr(*, "where")=List of 1
[13:18:57.776]   ..$ ...:<environment: 0x555f7bb1c0e0> 
[13:18:57.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.776]  - attr(*, "resolved")= logi TRUE
[13:18:57.776]  - attr(*, "total_size")= num NA
[13:18:57.779]  - Getting '...' globals ... DONE
[13:18:57.779] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.779] List of 8
[13:18:57.779]  $ ...future.FUN:function (x, ...)  
[13:18:57.779]  $ x_FUN        :function (x)  
[13:18:57.779]  $ times        : int 4
[13:18:57.779]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.779]  $ stop_if_not  :function (...)  
[13:18:57.779]  $ dim          : int [1:2] 2 2
[13:18:57.779]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.779]  $ ...          : list()
[13:18:57.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.779]  - attr(*, "where")=List of 8
[13:18:57.779]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.779]   ..$ ...          :<environment: 0x555f7bb1c0e0> 
[13:18:57.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.779]  - attr(*, "resolved")= logi FALSE
[13:18:57.779]  - attr(*, "total_size")= num 105552
[13:18:57.784] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:57.784] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.784] Number of futures (= number of chunks): 1
[13:18:57.785] Launching 1 futures (chunks) ...
[13:18:57.785] Chunk #1 of 1 ...
[13:18:57.785]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.785] getGlobalsAndPackages() ...
[13:18:57.785] Searching for globals...
[13:18:57.785] 
[13:18:57.785] Searching for globals ... DONE
[13:18:57.785] - globals: [0] <none>
[13:18:57.785] getGlobalsAndPackages() ... DONE
[13:18:57.786]    + additional globals found: [n=0] 
[13:18:57.786]    + additional namespaces needed: [n=0] 
[13:18:57.786]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.786]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[13:18:57.786]  - seeds: <none>
[13:18:57.786] getGlobalsAndPackages() ...
[13:18:57.786] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.786] Resolving globals: FALSE
[13:18:57.786] Tweak future expression to call with '...' arguments ...
[13:18:57.786] {
[13:18:57.786]     do.call(function(...) {
[13:18:57.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.786]             on.exit(options(oopts), add = TRUE)
[13:18:57.786]         }
[13:18:57.786]         {
[13:18:57.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.786]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.786]             })
[13:18:57.786]         }
[13:18:57.786]     }, args = future.call.arguments)
[13:18:57.786] }
[13:18:57.787] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.787] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.787] - packages: [1] ‘future.apply’
[13:18:57.787] getGlobalsAndPackages() ... DONE
[13:18:57.788] run() for ‘Future’ ...
[13:18:57.788] - state: ‘created’
[13:18:57.788] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.788] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.788]   - Field: ‘label’
[13:18:57.789]   - Field: ‘local’
[13:18:57.789]   - Field: ‘owner’
[13:18:57.789]   - Field: ‘envir’
[13:18:57.789]   - Field: ‘packages’
[13:18:57.789]   - Field: ‘gc’
[13:18:57.789]   - Field: ‘conditions’
[13:18:57.789]   - Field: ‘expr’
[13:18:57.789]   - Field: ‘uuid’
[13:18:57.789]   - Field: ‘seed’
[13:18:57.789]   - Field: ‘version’
[13:18:57.790]   - Field: ‘result’
[13:18:57.790]   - Field: ‘asynchronous’
[13:18:57.790]   - Field: ‘calls’
[13:18:57.790]   - Field: ‘globals’
[13:18:57.790]   - Field: ‘stdout’
[13:18:57.790]   - Field: ‘earlySignal’
[13:18:57.790]   - Field: ‘lazy’
[13:18:57.790]   - Field: ‘state’
[13:18:57.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.791] - Launch lazy future ...
[13:18:57.792] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:57.792] Packages needed by future strategies (n = 0): <none>
[13:18:57.792] {
[13:18:57.792]     {
[13:18:57.792]         {
[13:18:57.792]             ...future.startTime <- base::Sys.time()
[13:18:57.792]             {
[13:18:57.792]                 {
[13:18:57.792]                   {
[13:18:57.792]                     {
[13:18:57.792]                       base::local({
[13:18:57.792]                         has_future <- base::requireNamespace("future", 
[13:18:57.792]                           quietly = TRUE)
[13:18:57.792]                         if (has_future) {
[13:18:57.792]                           ns <- base::getNamespace("future")
[13:18:57.792]                           version <- ns[[".package"]][["version"]]
[13:18:57.792]                           if (is.null(version)) 
[13:18:57.792]                             version <- utils::packageVersion("future")
[13:18:57.792]                         }
[13:18:57.792]                         else {
[13:18:57.792]                           version <- NULL
[13:18:57.792]                         }
[13:18:57.792]                         if (!has_future || version < "1.8.0") {
[13:18:57.792]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.792]                             "", base::R.version$version.string), 
[13:18:57.792]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.792]                               "release", "version")], collapse = " "), 
[13:18:57.792]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.792]                             info)
[13:18:57.792]                           info <- base::paste(info, collapse = "; ")
[13:18:57.792]                           if (!has_future) {
[13:18:57.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.792]                               info)
[13:18:57.792]                           }
[13:18:57.792]                           else {
[13:18:57.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.792]                               info, version)
[13:18:57.792]                           }
[13:18:57.792]                           base::stop(msg)
[13:18:57.792]                         }
[13:18:57.792]                       })
[13:18:57.792]                     }
[13:18:57.792]                     base::local({
[13:18:57.792]                       for (pkg in "future.apply") {
[13:18:57.792]                         base::loadNamespace(pkg)
[13:18:57.792]                         base::library(pkg, character.only = TRUE)
[13:18:57.792]                       }
[13:18:57.792]                     })
[13:18:57.792]                   }
[13:18:57.792]                   options(future.plan = NULL)
[13:18:57.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.792]                 }
[13:18:57.792]                 ...future.workdir <- getwd()
[13:18:57.792]             }
[13:18:57.792]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.792]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.792]         }
[13:18:57.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.792]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[13:18:57.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.792]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.792]             base::names(...future.oldOptions))
[13:18:57.792]     }
[13:18:57.792]     if (FALSE) {
[13:18:57.792]     }
[13:18:57.792]     else {
[13:18:57.792]         if (TRUE) {
[13:18:57.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.792]                 open = "w")
[13:18:57.792]         }
[13:18:57.792]         else {
[13:18:57.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.792]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.792]         }
[13:18:57.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.792]             base::sink(type = "output", split = FALSE)
[13:18:57.792]             base::close(...future.stdout)
[13:18:57.792]         }, add = TRUE)
[13:18:57.792]     }
[13:18:57.792]     ...future.frame <- base::sys.nframe()
[13:18:57.792]     ...future.conditions <- base::list()
[13:18:57.792]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.792]     if (FALSE) {
[13:18:57.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.792]     }
[13:18:57.792]     ...future.result <- base::tryCatch({
[13:18:57.792]         base::withCallingHandlers({
[13:18:57.792]             ...future.value <- base::withVisible(base::local({
[13:18:57.792]                 do.call(function(...) {
[13:18:57.792]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.792]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.792]                     ...future.globals.maxSize)) {
[13:18:57.792]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.792]                     on.exit(options(oopts), add = TRUE)
[13:18:57.792]                   }
[13:18:57.792]                   {
[13:18:57.792]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.792]                       FUN = function(jj) {
[13:18:57.792]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.792]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.792]                       })
[13:18:57.792]                   }
[13:18:57.792]                 }, args = future.call.arguments)
[13:18:57.792]             }))
[13:18:57.792]             future::FutureResult(value = ...future.value$value, 
[13:18:57.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.792]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.792]                     ...future.globalenv.names))
[13:18:57.792]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.792]         }, condition = base::local({
[13:18:57.792]             c <- base::c
[13:18:57.792]             inherits <- base::inherits
[13:18:57.792]             invokeRestart <- base::invokeRestart
[13:18:57.792]             length <- base::length
[13:18:57.792]             list <- base::list
[13:18:57.792]             seq.int <- base::seq.int
[13:18:57.792]             signalCondition <- base::signalCondition
[13:18:57.792]             sys.calls <- base::sys.calls
[13:18:57.792]             `[[` <- base::`[[`
[13:18:57.792]             `+` <- base::`+`
[13:18:57.792]             `<<-` <- base::`<<-`
[13:18:57.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.792]                   3L)]
[13:18:57.792]             }
[13:18:57.792]             function(cond) {
[13:18:57.792]                 is_error <- inherits(cond, "error")
[13:18:57.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.792]                   NULL)
[13:18:57.792]                 if (is_error) {
[13:18:57.792]                   sessionInformation <- function() {
[13:18:57.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.792]                       search = base::search(), system = base::Sys.info())
[13:18:57.792]                   }
[13:18:57.792]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.792]                     cond$call), session = sessionInformation(), 
[13:18:57.792]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.792]                   signalCondition(cond)
[13:18:57.792]                 }
[13:18:57.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.792]                 "immediateCondition"))) {
[13:18:57.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.792]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.792]                   if (TRUE && !signal) {
[13:18:57.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.792]                     {
[13:18:57.792]                       inherits <- base::inherits
[13:18:57.792]                       invokeRestart <- base::invokeRestart
[13:18:57.792]                       is.null <- base::is.null
[13:18:57.792]                       muffled <- FALSE
[13:18:57.792]                       if (inherits(cond, "message")) {
[13:18:57.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.792]                         if (muffled) 
[13:18:57.792]                           invokeRestart("muffleMessage")
[13:18:57.792]                       }
[13:18:57.792]                       else if (inherits(cond, "warning")) {
[13:18:57.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.792]                         if (muffled) 
[13:18:57.792]                           invokeRestart("muffleWarning")
[13:18:57.792]                       }
[13:18:57.792]                       else if (inherits(cond, "condition")) {
[13:18:57.792]                         if (!is.null(pattern)) {
[13:18:57.792]                           computeRestarts <- base::computeRestarts
[13:18:57.792]                           grepl <- base::grepl
[13:18:57.792]                           restarts <- computeRestarts(cond)
[13:18:57.792]                           for (restart in restarts) {
[13:18:57.792]                             name <- restart$name
[13:18:57.792]                             if (is.null(name)) 
[13:18:57.792]                               next
[13:18:57.792]                             if (!grepl(pattern, name)) 
[13:18:57.792]                               next
[13:18:57.792]                             invokeRestart(restart)
[13:18:57.792]                             muffled <- TRUE
[13:18:57.792]                             break
[13:18:57.792]                           }
[13:18:57.792]                         }
[13:18:57.792]                       }
[13:18:57.792]                       invisible(muffled)
[13:18:57.792]                     }
[13:18:57.792]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.792]                   }
[13:18:57.792]                 }
[13:18:57.792]                 else {
[13:18:57.792]                   if (TRUE) {
[13:18:57.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.792]                     {
[13:18:57.792]                       inherits <- base::inherits
[13:18:57.792]                       invokeRestart <- base::invokeRestart
[13:18:57.792]                       is.null <- base::is.null
[13:18:57.792]                       muffled <- FALSE
[13:18:57.792]                       if (inherits(cond, "message")) {
[13:18:57.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.792]                         if (muffled) 
[13:18:57.792]                           invokeRestart("muffleMessage")
[13:18:57.792]                       }
[13:18:57.792]                       else if (inherits(cond, "warning")) {
[13:18:57.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.792]                         if (muffled) 
[13:18:57.792]                           invokeRestart("muffleWarning")
[13:18:57.792]                       }
[13:18:57.792]                       else if (inherits(cond, "condition")) {
[13:18:57.792]                         if (!is.null(pattern)) {
[13:18:57.792]                           computeRestarts <- base::computeRestarts
[13:18:57.792]                           grepl <- base::grepl
[13:18:57.792]                           restarts <- computeRestarts(cond)
[13:18:57.792]                           for (restart in restarts) {
[13:18:57.792]                             name <- restart$name
[13:18:57.792]                             if (is.null(name)) 
[13:18:57.792]                               next
[13:18:57.792]                             if (!grepl(pattern, name)) 
[13:18:57.792]                               next
[13:18:57.792]                             invokeRestart(restart)
[13:18:57.792]                             muffled <- TRUE
[13:18:57.792]                             break
[13:18:57.792]                           }
[13:18:57.792]                         }
[13:18:57.792]                       }
[13:18:57.792]                       invisible(muffled)
[13:18:57.792]                     }
[13:18:57.792]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.792]                   }
[13:18:57.792]                 }
[13:18:57.792]             }
[13:18:57.792]         }))
[13:18:57.792]     }, error = function(ex) {
[13:18:57.792]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.792]                 ...future.rng), started = ...future.startTime, 
[13:18:57.792]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.792]             version = "1.8"), class = "FutureResult")
[13:18:57.792]     }, finally = {
[13:18:57.792]         if (!identical(...future.workdir, getwd())) 
[13:18:57.792]             setwd(...future.workdir)
[13:18:57.792]         {
[13:18:57.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.792]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.792]             }
[13:18:57.792]             base::options(...future.oldOptions)
[13:18:57.792]             if (.Platform$OS.type == "windows") {
[13:18:57.792]                 old_names <- names(...future.oldEnvVars)
[13:18:57.792]                 envs <- base::Sys.getenv()
[13:18:57.792]                 names <- names(envs)
[13:18:57.792]                 common <- intersect(names, old_names)
[13:18:57.792]                 added <- setdiff(names, old_names)
[13:18:57.792]                 removed <- setdiff(old_names, names)
[13:18:57.792]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.792]                   envs[common]]
[13:18:57.792]                 NAMES <- toupper(changed)
[13:18:57.792]                 args <- list()
[13:18:57.792]                 for (kk in seq_along(NAMES)) {
[13:18:57.792]                   name <- changed[[kk]]
[13:18:57.792]                   NAME <- NAMES[[kk]]
[13:18:57.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.792]                     next
[13:18:57.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.792]                 }
[13:18:57.792]                 NAMES <- toupper(added)
[13:18:57.792]                 for (kk in seq_along(NAMES)) {
[13:18:57.792]                   name <- added[[kk]]
[13:18:57.792]                   NAME <- NAMES[[kk]]
[13:18:57.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.792]                     next
[13:18:57.792]                   args[[name]] <- ""
[13:18:57.792]                 }
[13:18:57.792]                 NAMES <- toupper(removed)
[13:18:57.792]                 for (kk in seq_along(NAMES)) {
[13:18:57.792]                   name <- removed[[kk]]
[13:18:57.792]                   NAME <- NAMES[[kk]]
[13:18:57.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.792]                     next
[13:18:57.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.792]                 }
[13:18:57.792]                 if (length(args) > 0) 
[13:18:57.792]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.792]             }
[13:18:57.792]             else {
[13:18:57.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.792]             }
[13:18:57.792]             {
[13:18:57.792]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.792]                   0L) {
[13:18:57.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.792]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.792]                   base::options(opts)
[13:18:57.792]                 }
[13:18:57.792]                 {
[13:18:57.792]                   {
[13:18:57.792]                     NULL
[13:18:57.792]                     RNGkind("Mersenne-Twister")
[13:18:57.792]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.792]                       inherits = FALSE)
[13:18:57.792]                   }
[13:18:57.792]                   options(future.plan = NULL)
[13:18:57.792]                   if (is.na(NA_character_)) 
[13:18:57.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.792]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.792]                   {
[13:18:57.792]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.792]                     if (!future$lazy) 
[13:18:57.792]                       future <- run(future)
[13:18:57.792]                     invisible(future)
[13:18:57.792]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.792]                 }
[13:18:57.792]             }
[13:18:57.792]         }
[13:18:57.792]     })
[13:18:57.792]     if (TRUE) {
[13:18:57.792]         base::sink(type = "output", split = FALSE)
[13:18:57.792]         if (TRUE) {
[13:18:57.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.792]         }
[13:18:57.792]         else {
[13:18:57.792]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.792]         }
[13:18:57.792]         base::close(...future.stdout)
[13:18:57.792]         ...future.stdout <- NULL
[13:18:57.792]     }
[13:18:57.792]     ...future.result$conditions <- ...future.conditions
[13:18:57.792]     ...future.result$finished <- base::Sys.time()
[13:18:57.792]     ...future.result
[13:18:57.792] }
[13:18:57.794] assign_globals() ...
[13:18:57.794] List of 11
[13:18:57.794]  $ ...future.FUN            :function (x, ...)  
[13:18:57.794]  $ x_FUN                    :function (x)  
[13:18:57.794]  $ times                    : int 4
[13:18:57.794]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.794]  $ stop_if_not              :function (...)  
[13:18:57.794]  $ dim                      : int [1:2] 2 2
[13:18:57.794]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.794]  $ future.call.arguments    : list()
[13:18:57.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.794]  $ ...future.elements_ii    :List of 10
[13:18:57.794]   ..$ : int 1
[13:18:57.794]   ..$ : int 2
[13:18:57.794]   ..$ : int 3
[13:18:57.794]   ..$ : int 4
[13:18:57.794]   ..$ : int 5
[13:18:57.794]   ..$ : int 6
[13:18:57.794]   ..$ : int 7
[13:18:57.794]   ..$ : int 8
[13:18:57.794]   ..$ : int 9
[13:18:57.794]   ..$ : int 10
[13:18:57.794]  $ ...future.seeds_ii       : NULL
[13:18:57.794]  $ ...future.globals.maxSize: NULL
[13:18:57.794]  - attr(*, "resolved")= logi FALSE
[13:18:57.794]  - attr(*, "total_size")= num 105552
[13:18:57.794]  - attr(*, "where")=List of 11
[13:18:57.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.794]  - attr(*, "already-done")= logi TRUE
[13:18:57.804] - copied ‘...future.FUN’ to environment
[13:18:57.804] - reassign environment for ‘x_FUN’
[13:18:57.804] - copied ‘x_FUN’ to environment
[13:18:57.805] - copied ‘times’ to environment
[13:18:57.805] - copied ‘stopf’ to environment
[13:18:57.805] - copied ‘stop_if_not’ to environment
[13:18:57.805] - copied ‘dim’ to environment
[13:18:57.805] - copied ‘valid_types’ to environment
[13:18:57.805] - copied ‘future.call.arguments’ to environment
[13:18:57.805] - copied ‘...future.elements_ii’ to environment
[13:18:57.805] - copied ‘...future.seeds_ii’ to environment
[13:18:57.805] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.805] assign_globals() ... done
[13:18:57.806] plan(): Setting new future strategy stack:
[13:18:57.806] List of future strategies:
[13:18:57.806] 1. sequential:
[13:18:57.806]    - args: function (..., envir = parent.frame())
[13:18:57.806]    - tweaked: FALSE
[13:18:57.806]    - call: NULL
[13:18:57.806] plan(): nbrOfWorkers() = 1
[13:18:57.807] plan(): Setting new future strategy stack:
[13:18:57.807] List of future strategies:
[13:18:57.807] 1. sequential:
[13:18:57.807]    - args: function (..., envir = parent.frame())
[13:18:57.807]    - tweaked: FALSE
[13:18:57.807]    - call: plan(strategy)
[13:18:57.808] plan(): nbrOfWorkers() = 1
[13:18:57.808] SequentialFuture started (and completed)
[13:18:57.808] - Launch lazy future ... done
[13:18:57.808] run() for ‘SequentialFuture’ ... done
[13:18:57.808] Created future:
[13:18:57.808] SequentialFuture:
[13:18:57.808] Label: ‘future_vapply-1’
[13:18:57.808] Expression:
[13:18:57.808] {
[13:18:57.808]     do.call(function(...) {
[13:18:57.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.808]             on.exit(options(oopts), add = TRUE)
[13:18:57.808]         }
[13:18:57.808]         {
[13:18:57.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.808]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.808]             })
[13:18:57.808]         }
[13:18:57.808]     }, args = future.call.arguments)
[13:18:57.808] }
[13:18:57.808] Lazy evaluation: FALSE
[13:18:57.808] Asynchronous evaluation: FALSE
[13:18:57.808] Local evaluation: TRUE
[13:18:57.808] Environment: R_GlobalEnv
[13:18:57.808] Capture standard output: TRUE
[13:18:57.808] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.808] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.808] Packages: 1 packages (‘future.apply’)
[13:18:57.808] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.808] Resolved: TRUE
[13:18:57.808] Value: 7.42 KiB of class ‘list’
[13:18:57.808] Early signaling: FALSE
[13:18:57.808] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.808] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.809] Chunk #1 of 1 ... DONE
[13:18:57.809] Launching 1 futures (chunks) ... DONE
[13:18:57.810] Resolving 1 futures (chunks) ...
[13:18:57.810] resolve() on list ...
[13:18:57.810]  recursive: 0
[13:18:57.810]  length: 1
[13:18:57.810] 
[13:18:57.810] resolved() for ‘SequentialFuture’ ...
[13:18:57.810] - state: ‘finished’
[13:18:57.810] - run: TRUE
[13:18:57.810] - result: ‘FutureResult’
[13:18:57.810] resolved() for ‘SequentialFuture’ ... done
[13:18:57.811] Future #1
[13:18:57.811] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.811] - nx: 1
[13:18:57.811] - relay: TRUE
[13:18:57.811] - stdout: TRUE
[13:18:57.811] - signal: TRUE
[13:18:57.811] - resignal: FALSE
[13:18:57.811] - force: TRUE
[13:18:57.811] - relayed: [n=1] FALSE
[13:18:57.811] - queued futures: [n=1] FALSE
[13:18:57.811]  - until=1
[13:18:57.812]  - relaying element #1
[13:18:57.812] - relayed: [n=1] TRUE
[13:18:57.812] - queued futures: [n=1] TRUE
[13:18:57.812] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.812]  length: 0 (resolved future 1)
[13:18:57.812] Relaying remaining futures
[13:18:57.812] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.812] - nx: 1
[13:18:57.812] - relay: TRUE
[13:18:57.812] - stdout: TRUE
[13:18:57.813] - signal: TRUE
[13:18:57.813] - resignal: FALSE
[13:18:57.813] - force: TRUE
[13:18:57.813] - relayed: [n=1] TRUE
[13:18:57.813] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.813] - relayed: [n=1] TRUE
[13:18:57.813] - queued futures: [n=1] TRUE
[13:18:57.813] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.813] resolve() on list ... DONE
[13:18:57.813]  - Number of value chunks collected: 1
[13:18:57.814] Resolving 1 futures (chunks) ... DONE
[13:18:57.814] Reducing values from 1 chunks ...
[13:18:57.814]  - Number of values collected after concatenation: 10
[13:18:57.814]  - Number of values expected: 10
[13:18:57.814] Reducing values from 1 chunks ... DONE
[13:18:57.814] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:18:57.819] future_lapply() ...
[13:18:57.821] Number of chunks: 1
[13:18:57.821] getGlobalsAndPackagesXApply() ...
[13:18:57.821]  - future.globals: TRUE
[13:18:57.821] getGlobalsAndPackages() ...
[13:18:57.821] Searching for globals...
[13:18:57.825] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:18:57.825] Searching for globals ... DONE
[13:18:57.825] Resolving globals: FALSE
[13:18:57.826] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:18:57.826] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:57.826] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.826] - packages: [2] ‘stats’, ‘future.apply’
[13:18:57.827] getGlobalsAndPackages() ... DONE
[13:18:57.827]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.827]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:18:57.827] Finding globals ... DONE
[13:18:57.827]  - use_args: TRUE
[13:18:57.827]  - Getting '...' globals ...
[13:18:57.827] resolve() on list ...
[13:18:57.827]  recursive: 0
[13:18:57.828]  length: 1
[13:18:57.828]  elements: ‘...’
[13:18:57.828]  length: 0 (resolved future 1)
[13:18:57.828] resolve() on list ... DONE
[13:18:57.828]    - '...' content: [n=0] 
[13:18:57.828] List of 1
[13:18:57.828]  $ ...: list()
[13:18:57.828]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.828]  - attr(*, "where")=List of 1
[13:18:57.828]   ..$ ...:<environment: 0x555f7abb3498> 
[13:18:57.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.828]  - attr(*, "resolved")= logi TRUE
[13:18:57.828]  - attr(*, "total_size")= num NA
[13:18:57.830]  - Getting '...' globals ... DONE
[13:18:57.831] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.831] List of 8
[13:18:57.831]  $ ...future.FUN:function (x, ...)  
[13:18:57.831]  $ x_FUN        :function (x, ...)  
[13:18:57.831]  $ times        : int 5
[13:18:57.831]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.831]  $ stop_if_not  :function (...)  
[13:18:57.831]  $ dim          : NULL
[13:18:57.831]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.831]  $ ...          : list()
[13:18:57.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.831]  - attr(*, "where")=List of 8
[13:18:57.831]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.831]   ..$ ...          :<environment: 0x555f7abb3498> 
[13:18:57.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.831]  - attr(*, "resolved")= logi FALSE
[13:18:57.831]  - attr(*, "total_size")= num 95528
[13:18:57.836] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:18:57.836] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.836] Number of futures (= number of chunks): 1
[13:18:57.836] Launching 1 futures (chunks) ...
[13:18:57.836] Chunk #1 of 1 ...
[13:18:57.837]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.837] getGlobalsAndPackages() ...
[13:18:57.837] Searching for globals...
[13:18:57.837] 
[13:18:57.837] Searching for globals ... DONE
[13:18:57.837] - globals: [0] <none>
[13:18:57.837] getGlobalsAndPackages() ... DONE
[13:18:57.837]    + additional globals found: [n=0] 
[13:18:57.837]    + additional namespaces needed: [n=0] 
[13:18:57.838]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.839]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:18:57.839]  - seeds: <none>
[13:18:57.839] getGlobalsAndPackages() ...
[13:18:57.839] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.840] Resolving globals: FALSE
[13:18:57.840] Tweak future expression to call with '...' arguments ...
[13:18:57.840] {
[13:18:57.840]     do.call(function(...) {
[13:18:57.840]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.840]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.840]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.840]             on.exit(options(oopts), add = TRUE)
[13:18:57.840]         }
[13:18:57.840]         {
[13:18:57.840]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.840]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.840]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.840]             })
[13:18:57.840]         }
[13:18:57.840]     }, args = future.call.arguments)
[13:18:57.840] }
[13:18:57.840] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.841] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.841] - packages: [2] ‘stats’, ‘future.apply’
[13:18:57.841] getGlobalsAndPackages() ... DONE
[13:18:57.841] run() for ‘Future’ ...
[13:18:57.841] - state: ‘created’
[13:18:57.841] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.842] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.842]   - Field: ‘label’
[13:18:57.842]   - Field: ‘local’
[13:18:57.842]   - Field: ‘owner’
[13:18:57.842]   - Field: ‘envir’
[13:18:57.842]   - Field: ‘packages’
[13:18:57.842]   - Field: ‘gc’
[13:18:57.842]   - Field: ‘conditions’
[13:18:57.842]   - Field: ‘expr’
[13:18:57.843]   - Field: ‘uuid’
[13:18:57.843]   - Field: ‘seed’
[13:18:57.843]   - Field: ‘version’
[13:18:57.843]   - Field: ‘result’
[13:18:57.843]   - Field: ‘asynchronous’
[13:18:57.843]   - Field: ‘calls’
[13:18:57.843]   - Field: ‘globals’
[13:18:57.843]   - Field: ‘stdout’
[13:18:57.843]   - Field: ‘earlySignal’
[13:18:57.843]   - Field: ‘lazy’
[13:18:57.843]   - Field: ‘state’
[13:18:57.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.844] - Launch lazy future ...
[13:18:57.844] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:18:57.844] Packages needed by future strategies (n = 0): <none>
[13:18:57.844] {
[13:18:57.844]     {
[13:18:57.844]         {
[13:18:57.844]             ...future.startTime <- base::Sys.time()
[13:18:57.844]             {
[13:18:57.844]                 {
[13:18:57.844]                   {
[13:18:57.844]                     {
[13:18:57.844]                       base::local({
[13:18:57.844]                         has_future <- base::requireNamespace("future", 
[13:18:57.844]                           quietly = TRUE)
[13:18:57.844]                         if (has_future) {
[13:18:57.844]                           ns <- base::getNamespace("future")
[13:18:57.844]                           version <- ns[[".package"]][["version"]]
[13:18:57.844]                           if (is.null(version)) 
[13:18:57.844]                             version <- utils::packageVersion("future")
[13:18:57.844]                         }
[13:18:57.844]                         else {
[13:18:57.844]                           version <- NULL
[13:18:57.844]                         }
[13:18:57.844]                         if (!has_future || version < "1.8.0") {
[13:18:57.844]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.844]                             "", base::R.version$version.string), 
[13:18:57.844]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.844]                               "release", "version")], collapse = " "), 
[13:18:57.844]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.844]                             info)
[13:18:57.844]                           info <- base::paste(info, collapse = "; ")
[13:18:57.844]                           if (!has_future) {
[13:18:57.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.844]                               info)
[13:18:57.844]                           }
[13:18:57.844]                           else {
[13:18:57.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.844]                               info, version)
[13:18:57.844]                           }
[13:18:57.844]                           base::stop(msg)
[13:18:57.844]                         }
[13:18:57.844]                       })
[13:18:57.844]                     }
[13:18:57.844]                     base::local({
[13:18:57.844]                       for (pkg in c("stats", "future.apply")) {
[13:18:57.844]                         base::loadNamespace(pkg)
[13:18:57.844]                         base::library(pkg, character.only = TRUE)
[13:18:57.844]                       }
[13:18:57.844]                     })
[13:18:57.844]                   }
[13:18:57.844]                   options(future.plan = NULL)
[13:18:57.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.844]                 }
[13:18:57.844]                 ...future.workdir <- getwd()
[13:18:57.844]             }
[13:18:57.844]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.844]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.844]         }
[13:18:57.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.844]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:18:57.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.844]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.844]             base::names(...future.oldOptions))
[13:18:57.844]     }
[13:18:57.844]     if (FALSE) {
[13:18:57.844]     }
[13:18:57.844]     else {
[13:18:57.844]         if (TRUE) {
[13:18:57.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.844]                 open = "w")
[13:18:57.844]         }
[13:18:57.844]         else {
[13:18:57.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.844]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.844]         }
[13:18:57.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.844]             base::sink(type = "output", split = FALSE)
[13:18:57.844]             base::close(...future.stdout)
[13:18:57.844]         }, add = TRUE)
[13:18:57.844]     }
[13:18:57.844]     ...future.frame <- base::sys.nframe()
[13:18:57.844]     ...future.conditions <- base::list()
[13:18:57.844]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.844]     if (FALSE) {
[13:18:57.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.844]     }
[13:18:57.844]     ...future.result <- base::tryCatch({
[13:18:57.844]         base::withCallingHandlers({
[13:18:57.844]             ...future.value <- base::withVisible(base::local({
[13:18:57.844]                 do.call(function(...) {
[13:18:57.844]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.844]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.844]                     ...future.globals.maxSize)) {
[13:18:57.844]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.844]                     on.exit(options(oopts), add = TRUE)
[13:18:57.844]                   }
[13:18:57.844]                   {
[13:18:57.844]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.844]                       FUN = function(jj) {
[13:18:57.844]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.844]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.844]                       })
[13:18:57.844]                   }
[13:18:57.844]                 }, args = future.call.arguments)
[13:18:57.844]             }))
[13:18:57.844]             future::FutureResult(value = ...future.value$value, 
[13:18:57.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.844]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.844]                     ...future.globalenv.names))
[13:18:57.844]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.844]         }, condition = base::local({
[13:18:57.844]             c <- base::c
[13:18:57.844]             inherits <- base::inherits
[13:18:57.844]             invokeRestart <- base::invokeRestart
[13:18:57.844]             length <- base::length
[13:18:57.844]             list <- base::list
[13:18:57.844]             seq.int <- base::seq.int
[13:18:57.844]             signalCondition <- base::signalCondition
[13:18:57.844]             sys.calls <- base::sys.calls
[13:18:57.844]             `[[` <- base::`[[`
[13:18:57.844]             `+` <- base::`+`
[13:18:57.844]             `<<-` <- base::`<<-`
[13:18:57.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.844]                   3L)]
[13:18:57.844]             }
[13:18:57.844]             function(cond) {
[13:18:57.844]                 is_error <- inherits(cond, "error")
[13:18:57.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.844]                   NULL)
[13:18:57.844]                 if (is_error) {
[13:18:57.844]                   sessionInformation <- function() {
[13:18:57.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.844]                       search = base::search(), system = base::Sys.info())
[13:18:57.844]                   }
[13:18:57.844]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.844]                     cond$call), session = sessionInformation(), 
[13:18:57.844]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.844]                   signalCondition(cond)
[13:18:57.844]                 }
[13:18:57.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.844]                 "immediateCondition"))) {
[13:18:57.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.844]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.844]                   if (TRUE && !signal) {
[13:18:57.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.844]                     {
[13:18:57.844]                       inherits <- base::inherits
[13:18:57.844]                       invokeRestart <- base::invokeRestart
[13:18:57.844]                       is.null <- base::is.null
[13:18:57.844]                       muffled <- FALSE
[13:18:57.844]                       if (inherits(cond, "message")) {
[13:18:57.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.844]                         if (muffled) 
[13:18:57.844]                           invokeRestart("muffleMessage")
[13:18:57.844]                       }
[13:18:57.844]                       else if (inherits(cond, "warning")) {
[13:18:57.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.844]                         if (muffled) 
[13:18:57.844]                           invokeRestart("muffleWarning")
[13:18:57.844]                       }
[13:18:57.844]                       else if (inherits(cond, "condition")) {
[13:18:57.844]                         if (!is.null(pattern)) {
[13:18:57.844]                           computeRestarts <- base::computeRestarts
[13:18:57.844]                           grepl <- base::grepl
[13:18:57.844]                           restarts <- computeRestarts(cond)
[13:18:57.844]                           for (restart in restarts) {
[13:18:57.844]                             name <- restart$name
[13:18:57.844]                             if (is.null(name)) 
[13:18:57.844]                               next
[13:18:57.844]                             if (!grepl(pattern, name)) 
[13:18:57.844]                               next
[13:18:57.844]                             invokeRestart(restart)
[13:18:57.844]                             muffled <- TRUE
[13:18:57.844]                             break
[13:18:57.844]                           }
[13:18:57.844]                         }
[13:18:57.844]                       }
[13:18:57.844]                       invisible(muffled)
[13:18:57.844]                     }
[13:18:57.844]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.844]                   }
[13:18:57.844]                 }
[13:18:57.844]                 else {
[13:18:57.844]                   if (TRUE) {
[13:18:57.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.844]                     {
[13:18:57.844]                       inherits <- base::inherits
[13:18:57.844]                       invokeRestart <- base::invokeRestart
[13:18:57.844]                       is.null <- base::is.null
[13:18:57.844]                       muffled <- FALSE
[13:18:57.844]                       if (inherits(cond, "message")) {
[13:18:57.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.844]                         if (muffled) 
[13:18:57.844]                           invokeRestart("muffleMessage")
[13:18:57.844]                       }
[13:18:57.844]                       else if (inherits(cond, "warning")) {
[13:18:57.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.844]                         if (muffled) 
[13:18:57.844]                           invokeRestart("muffleWarning")
[13:18:57.844]                       }
[13:18:57.844]                       else if (inherits(cond, "condition")) {
[13:18:57.844]                         if (!is.null(pattern)) {
[13:18:57.844]                           computeRestarts <- base::computeRestarts
[13:18:57.844]                           grepl <- base::grepl
[13:18:57.844]                           restarts <- computeRestarts(cond)
[13:18:57.844]                           for (restart in restarts) {
[13:18:57.844]                             name <- restart$name
[13:18:57.844]                             if (is.null(name)) 
[13:18:57.844]                               next
[13:18:57.844]                             if (!grepl(pattern, name)) 
[13:18:57.844]                               next
[13:18:57.844]                             invokeRestart(restart)
[13:18:57.844]                             muffled <- TRUE
[13:18:57.844]                             break
[13:18:57.844]                           }
[13:18:57.844]                         }
[13:18:57.844]                       }
[13:18:57.844]                       invisible(muffled)
[13:18:57.844]                     }
[13:18:57.844]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.844]                   }
[13:18:57.844]                 }
[13:18:57.844]             }
[13:18:57.844]         }))
[13:18:57.844]     }, error = function(ex) {
[13:18:57.844]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.844]                 ...future.rng), started = ...future.startTime, 
[13:18:57.844]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.844]             version = "1.8"), class = "FutureResult")
[13:18:57.844]     }, finally = {
[13:18:57.844]         if (!identical(...future.workdir, getwd())) 
[13:18:57.844]             setwd(...future.workdir)
[13:18:57.844]         {
[13:18:57.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.844]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.844]             }
[13:18:57.844]             base::options(...future.oldOptions)
[13:18:57.844]             if (.Platform$OS.type == "windows") {
[13:18:57.844]                 old_names <- names(...future.oldEnvVars)
[13:18:57.844]                 envs <- base::Sys.getenv()
[13:18:57.844]                 names <- names(envs)
[13:18:57.844]                 common <- intersect(names, old_names)
[13:18:57.844]                 added <- setdiff(names, old_names)
[13:18:57.844]                 removed <- setdiff(old_names, names)
[13:18:57.844]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.844]                   envs[common]]
[13:18:57.844]                 NAMES <- toupper(changed)
[13:18:57.844]                 args <- list()
[13:18:57.844]                 for (kk in seq_along(NAMES)) {
[13:18:57.844]                   name <- changed[[kk]]
[13:18:57.844]                   NAME <- NAMES[[kk]]
[13:18:57.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.844]                     next
[13:18:57.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.844]                 }
[13:18:57.844]                 NAMES <- toupper(added)
[13:18:57.844]                 for (kk in seq_along(NAMES)) {
[13:18:57.844]                   name <- added[[kk]]
[13:18:57.844]                   NAME <- NAMES[[kk]]
[13:18:57.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.844]                     next
[13:18:57.844]                   args[[name]] <- ""
[13:18:57.844]                 }
[13:18:57.844]                 NAMES <- toupper(removed)
[13:18:57.844]                 for (kk in seq_along(NAMES)) {
[13:18:57.844]                   name <- removed[[kk]]
[13:18:57.844]                   NAME <- NAMES[[kk]]
[13:18:57.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.844]                     next
[13:18:57.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.844]                 }
[13:18:57.844]                 if (length(args) > 0) 
[13:18:57.844]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.844]             }
[13:18:57.844]             else {
[13:18:57.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.844]             }
[13:18:57.844]             {
[13:18:57.844]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.844]                   0L) {
[13:18:57.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.844]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.844]                   base::options(opts)
[13:18:57.844]                 }
[13:18:57.844]                 {
[13:18:57.844]                   {
[13:18:57.844]                     NULL
[13:18:57.844]                     RNGkind("Mersenne-Twister")
[13:18:57.844]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.844]                       inherits = FALSE)
[13:18:57.844]                   }
[13:18:57.844]                   options(future.plan = NULL)
[13:18:57.844]                   if (is.na(NA_character_)) 
[13:18:57.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.844]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.844]                   {
[13:18:57.844]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.844]                     if (!future$lazy) 
[13:18:57.844]                       future <- run(future)
[13:18:57.844]                     invisible(future)
[13:18:57.844]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.844]                 }
[13:18:57.844]             }
[13:18:57.844]         }
[13:18:57.844]     })
[13:18:57.844]     if (TRUE) {
[13:18:57.844]         base::sink(type = "output", split = FALSE)
[13:18:57.844]         if (TRUE) {
[13:18:57.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.844]         }
[13:18:57.844]         else {
[13:18:57.844]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.844]         }
[13:18:57.844]         base::close(...future.stdout)
[13:18:57.844]         ...future.stdout <- NULL
[13:18:57.844]     }
[13:18:57.844]     ...future.result$conditions <- ...future.conditions
[13:18:57.844]     ...future.result$finished <- base::Sys.time()
[13:18:57.844]     ...future.result
[13:18:57.844] }
[13:18:57.846] assign_globals() ...
[13:18:57.846] List of 11
[13:18:57.846]  $ ...future.FUN            :function (x, ...)  
[13:18:57.846]  $ x_FUN                    :function (x, ...)  
[13:18:57.846]  $ times                    : int 5
[13:18:57.846]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.846]  $ stop_if_not              :function (...)  
[13:18:57.846]  $ dim                      : NULL
[13:18:57.846]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.846]  $ future.call.arguments    : list()
[13:18:57.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.846]  $ ...future.elements_ii    :List of 3
[13:18:57.846]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:18:57.846]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:18:57.846]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:18:57.846]  $ ...future.seeds_ii       : NULL
[13:18:57.846]  $ ...future.globals.maxSize: NULL
[13:18:57.846]  - attr(*, "resolved")= logi FALSE
[13:18:57.846]  - attr(*, "total_size")= num 95528
[13:18:57.846]  - attr(*, "where")=List of 11
[13:18:57.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.846]  - attr(*, "already-done")= logi TRUE
[13:18:57.854] - copied ‘...future.FUN’ to environment
[13:18:57.854] - copied ‘x_FUN’ to environment
[13:18:57.854] - copied ‘times’ to environment
[13:18:57.854] - copied ‘stopf’ to environment
[13:18:57.854] - copied ‘stop_if_not’ to environment
[13:18:57.855] - copied ‘dim’ to environment
[13:18:57.855] - copied ‘valid_types’ to environment
[13:18:57.855] - copied ‘future.call.arguments’ to environment
[13:18:57.855] - copied ‘...future.elements_ii’ to environment
[13:18:57.855] - copied ‘...future.seeds_ii’ to environment
[13:18:57.855] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.855] assign_globals() ... done
[13:18:57.856] plan(): Setting new future strategy stack:
[13:18:57.856] List of future strategies:
[13:18:57.856] 1. sequential:
[13:18:57.856]    - args: function (..., envir = parent.frame())
[13:18:57.856]    - tweaked: FALSE
[13:18:57.856]    - call: NULL
[13:18:57.856] plan(): nbrOfWorkers() = 1
[13:18:57.857] plan(): Setting new future strategy stack:
[13:18:57.857] List of future strategies:
[13:18:57.857] 1. sequential:
[13:18:57.857]    - args: function (..., envir = parent.frame())
[13:18:57.857]    - tweaked: FALSE
[13:18:57.857]    - call: plan(strategy)
[13:18:57.858] plan(): nbrOfWorkers() = 1
[13:18:57.858] SequentialFuture started (and completed)
[13:18:57.858] - Launch lazy future ... done
[13:18:57.858] run() for ‘SequentialFuture’ ... done
[13:18:57.858] Created future:
[13:18:57.858] SequentialFuture:
[13:18:57.858] Label: ‘future_vapply-1’
[13:18:57.858] Expression:
[13:18:57.858] {
[13:18:57.858]     do.call(function(...) {
[13:18:57.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.858]             on.exit(options(oopts), add = TRUE)
[13:18:57.858]         }
[13:18:57.858]         {
[13:18:57.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.858]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.858]             })
[13:18:57.858]         }
[13:18:57.858]     }, args = future.call.arguments)
[13:18:57.858] }
[13:18:57.858] Lazy evaluation: FALSE
[13:18:57.858] Asynchronous evaluation: FALSE
[13:18:57.858] Local evaluation: TRUE
[13:18:57.858] Environment: R_GlobalEnv
[13:18:57.858] Capture standard output: TRUE
[13:18:57.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.858] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.858] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:18:57.858] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.858] Resolved: TRUE
[13:18:57.858] Value: 1.71 KiB of class ‘list’
[13:18:57.858] Early signaling: FALSE
[13:18:57.858] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.858] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.859] Chunk #1 of 1 ... DONE
[13:18:57.859] Launching 1 futures (chunks) ... DONE
[13:18:57.860] Resolving 1 futures (chunks) ...
[13:18:57.860] resolve() on list ...
[13:18:57.860]  recursive: 0
[13:18:57.860]  length: 1
[13:18:57.860] 
[13:18:57.860] resolved() for ‘SequentialFuture’ ...
[13:18:57.860] - state: ‘finished’
[13:18:57.860] - run: TRUE
[13:18:57.860] - result: ‘FutureResult’
[13:18:57.860] resolved() for ‘SequentialFuture’ ... done
[13:18:57.861] Future #1
[13:18:57.861] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.861] - nx: 1
[13:18:57.861] - relay: TRUE
[13:18:57.861] - stdout: TRUE
[13:18:57.861] - signal: TRUE
[13:18:57.861] - resignal: FALSE
[13:18:57.861] - force: TRUE
[13:18:57.861] - relayed: [n=1] FALSE
[13:18:57.861] - queued futures: [n=1] FALSE
[13:18:57.862]  - until=1
[13:18:57.863]  - relaying element #1
[13:18:57.863] - relayed: [n=1] TRUE
[13:18:57.863] - queued futures: [n=1] TRUE
[13:18:57.863] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.863]  length: 0 (resolved future 1)
[13:18:57.863] Relaying remaining futures
[13:18:57.864] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.864] - nx: 1
[13:18:57.864] - relay: TRUE
[13:18:57.864] - stdout: TRUE
[13:18:57.864] - signal: TRUE
[13:18:57.864] - resignal: FALSE
[13:18:57.864] - force: TRUE
[13:18:57.864] - relayed: [n=1] TRUE
[13:18:57.864] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.864] - relayed: [n=1] TRUE
[13:18:57.864] - queued futures: [n=1] TRUE
[13:18:57.865] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.865] resolve() on list ... DONE
[13:18:57.865]  - Number of value chunks collected: 1
[13:18:57.865] Resolving 1 futures (chunks) ... DONE
[13:18:57.865] Reducing values from 1 chunks ...
[13:18:57.865]  - Number of values collected after concatenation: 3
[13:18:57.865]  - Number of values expected: 3
[13:18:57.865] Reducing values from 1 chunks ... DONE
[13:18:57.865] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:18:57.867] future_lapply() ...
[13:18:57.871] Number of chunks: 1
[13:18:57.871] getGlobalsAndPackagesXApply() ...
[13:18:57.871]  - future.globals: TRUE
[13:18:57.871] getGlobalsAndPackages() ...
[13:18:57.871] Searching for globals...
[13:18:57.876] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:18:57.876] Searching for globals ... DONE
[13:18:57.876] Resolving globals: FALSE
[13:18:57.877] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:18:57.877] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:18:57.877] - globals: [1] ‘FUN’
[13:18:57.877] - packages: [1] ‘stats’
[13:18:57.877] getGlobalsAndPackages() ... DONE
[13:18:57.878]  - globals found/used: [n=1] ‘FUN’
[13:18:57.878]  - needed namespaces: [n=1] ‘stats’
[13:18:57.878] Finding globals ... DONE
[13:18:57.878]  - use_args: TRUE
[13:18:57.878]  - Getting '...' globals ...
[13:18:57.878] resolve() on list ...
[13:18:57.878]  recursive: 0
[13:18:57.878]  length: 1
[13:18:57.878]  elements: ‘...’
[13:18:57.879]  length: 0 (resolved future 1)
[13:18:57.879] resolve() on list ... DONE
[13:18:57.879]    - '...' content: [n=0] 
[13:18:57.879] List of 1
[13:18:57.879]  $ ...: list()
[13:18:57.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.879]  - attr(*, "where")=List of 1
[13:18:57.879]   ..$ ...:<environment: 0x555f79e6ac18> 
[13:18:57.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.879]  - attr(*, "resolved")= logi TRUE
[13:18:57.879]  - attr(*, "total_size")= num NA
[13:18:57.881]  - Getting '...' globals ... DONE
[13:18:57.881] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:18:57.882] List of 2
[13:18:57.882]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:18:57.882]  $ ...          : list()
[13:18:57.882]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.882]  - attr(*, "where")=List of 2
[13:18:57.882]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.882]   ..$ ...          :<environment: 0x555f79e6ac18> 
[13:18:57.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.882]  - attr(*, "resolved")= logi FALSE
[13:18:57.882]  - attr(*, "total_size")= num 46960
[13:18:57.885] Packages to be attached in all futures: [n=1] ‘stats’
[13:18:57.886] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.886] Number of futures (= number of chunks): 1
[13:18:57.886] Launching 1 futures (chunks) ...
[13:18:57.886] Chunk #1 of 1 ...
[13:18:57.886]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.886] getGlobalsAndPackages() ...
[13:18:57.886] Searching for globals...
[13:18:57.886] 
[13:18:57.887] Searching for globals ... DONE
[13:18:57.887] - globals: [0] <none>
[13:18:57.887] getGlobalsAndPackages() ... DONE
[13:18:57.887]    + additional globals found: [n=0] 
[13:18:57.887]    + additional namespaces needed: [n=0] 
[13:18:57.887]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.887]  - Adjusted option 'future.globals.maxSize': 524288000 -> 7 * 524288000 = 3670016000 (bytes)
[13:18:57.887]  - seeds: <none>
[13:18:57.887] getGlobalsAndPackages() ...
[13:18:57.887] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.888] Resolving globals: FALSE
[13:18:57.888] Tweak future expression to call with '...' arguments ...
[13:18:57.888] {
[13:18:57.888]     do.call(function(...) {
[13:18:57.888]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.888]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.888]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.888]             on.exit(options(oopts), add = TRUE)
[13:18:57.888]         }
[13:18:57.888]         {
[13:18:57.888]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.888]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.888]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.888]             })
[13:18:57.888]         }
[13:18:57.888]     }, args = future.call.arguments)
[13:18:57.888] }
[13:18:57.888] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.888] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.888] - packages: [1] ‘stats’
[13:18:57.889] getGlobalsAndPackages() ... DONE
[13:18:57.889] run() for ‘Future’ ...
[13:18:57.889] - state: ‘created’
[13:18:57.889] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.889] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.890]   - Field: ‘label’
[13:18:57.890]   - Field: ‘local’
[13:18:57.890]   - Field: ‘owner’
[13:18:57.890]   - Field: ‘envir’
[13:18:57.890]   - Field: ‘packages’
[13:18:57.890]   - Field: ‘gc’
[13:18:57.890]   - Field: ‘conditions’
[13:18:57.890]   - Field: ‘expr’
[13:18:57.890]   - Field: ‘uuid’
[13:18:57.890]   - Field: ‘seed’
[13:18:57.891]   - Field: ‘version’
[13:18:57.891]   - Field: ‘result’
[13:18:57.891]   - Field: ‘asynchronous’
[13:18:57.891]   - Field: ‘calls’
[13:18:57.891]   - Field: ‘globals’
[13:18:57.891]   - Field: ‘stdout’
[13:18:57.891]   - Field: ‘earlySignal’
[13:18:57.891]   - Field: ‘lazy’
[13:18:57.891]   - Field: ‘state’
[13:18:57.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.891] - Launch lazy future ...
[13:18:57.892] Packages needed by the future expression (n = 1): ‘stats’
[13:18:57.892] Packages needed by future strategies (n = 0): <none>
[13:18:57.892] {
[13:18:57.892]     {
[13:18:57.892]         {
[13:18:57.892]             ...future.startTime <- base::Sys.time()
[13:18:57.892]             {
[13:18:57.892]                 {
[13:18:57.892]                   {
[13:18:57.892]                     {
[13:18:57.892]                       base::local({
[13:18:57.892]                         has_future <- base::requireNamespace("future", 
[13:18:57.892]                           quietly = TRUE)
[13:18:57.892]                         if (has_future) {
[13:18:57.892]                           ns <- base::getNamespace("future")
[13:18:57.892]                           version <- ns[[".package"]][["version"]]
[13:18:57.892]                           if (is.null(version)) 
[13:18:57.892]                             version <- utils::packageVersion("future")
[13:18:57.892]                         }
[13:18:57.892]                         else {
[13:18:57.892]                           version <- NULL
[13:18:57.892]                         }
[13:18:57.892]                         if (!has_future || version < "1.8.0") {
[13:18:57.892]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.892]                             "", base::R.version$version.string), 
[13:18:57.892]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.892]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.892]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.892]                               "release", "version")], collapse = " "), 
[13:18:57.892]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.892]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.892]                             info)
[13:18:57.892]                           info <- base::paste(info, collapse = "; ")
[13:18:57.892]                           if (!has_future) {
[13:18:57.892]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.892]                               info)
[13:18:57.892]                           }
[13:18:57.892]                           else {
[13:18:57.892]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.892]                               info, version)
[13:18:57.892]                           }
[13:18:57.892]                           base::stop(msg)
[13:18:57.892]                         }
[13:18:57.892]                       })
[13:18:57.892]                     }
[13:18:57.892]                     base::local({
[13:18:57.892]                       for (pkg in "stats") {
[13:18:57.892]                         base::loadNamespace(pkg)
[13:18:57.892]                         base::library(pkg, character.only = TRUE)
[13:18:57.892]                       }
[13:18:57.892]                     })
[13:18:57.892]                   }
[13:18:57.892]                   options(future.plan = NULL)
[13:18:57.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.892]                 }
[13:18:57.892]                 ...future.workdir <- getwd()
[13:18:57.892]             }
[13:18:57.892]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.892]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.892]         }
[13:18:57.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.892]             future.globals.maxSize = 3670016000, future.globals.method = NULL, 
[13:18:57.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.892]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.892]             base::names(...future.oldOptions))
[13:18:57.892]     }
[13:18:57.892]     if (FALSE) {
[13:18:57.892]     }
[13:18:57.892]     else {
[13:18:57.892]         if (TRUE) {
[13:18:57.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.892]                 open = "w")
[13:18:57.892]         }
[13:18:57.892]         else {
[13:18:57.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.892]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.892]         }
[13:18:57.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.892]             base::sink(type = "output", split = FALSE)
[13:18:57.892]             base::close(...future.stdout)
[13:18:57.892]         }, add = TRUE)
[13:18:57.892]     }
[13:18:57.892]     ...future.frame <- base::sys.nframe()
[13:18:57.892]     ...future.conditions <- base::list()
[13:18:57.892]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.892]     if (FALSE) {
[13:18:57.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.892]     }
[13:18:57.892]     ...future.result <- base::tryCatch({
[13:18:57.892]         base::withCallingHandlers({
[13:18:57.892]             ...future.value <- base::withVisible(base::local({
[13:18:57.892]                 do.call(function(...) {
[13:18:57.892]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.892]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.892]                     ...future.globals.maxSize)) {
[13:18:57.892]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.892]                     on.exit(options(oopts), add = TRUE)
[13:18:57.892]                   }
[13:18:57.892]                   {
[13:18:57.892]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.892]                       FUN = function(jj) {
[13:18:57.892]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.892]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.892]                       })
[13:18:57.892]                   }
[13:18:57.892]                 }, args = future.call.arguments)
[13:18:57.892]             }))
[13:18:57.892]             future::FutureResult(value = ...future.value$value, 
[13:18:57.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.892]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.892]                     ...future.globalenv.names))
[13:18:57.892]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.892]         }, condition = base::local({
[13:18:57.892]             c <- base::c
[13:18:57.892]             inherits <- base::inherits
[13:18:57.892]             invokeRestart <- base::invokeRestart
[13:18:57.892]             length <- base::length
[13:18:57.892]             list <- base::list
[13:18:57.892]             seq.int <- base::seq.int
[13:18:57.892]             signalCondition <- base::signalCondition
[13:18:57.892]             sys.calls <- base::sys.calls
[13:18:57.892]             `[[` <- base::`[[`
[13:18:57.892]             `+` <- base::`+`
[13:18:57.892]             `<<-` <- base::`<<-`
[13:18:57.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.892]                   3L)]
[13:18:57.892]             }
[13:18:57.892]             function(cond) {
[13:18:57.892]                 is_error <- inherits(cond, "error")
[13:18:57.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.892]                   NULL)
[13:18:57.892]                 if (is_error) {
[13:18:57.892]                   sessionInformation <- function() {
[13:18:57.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.892]                       search = base::search(), system = base::Sys.info())
[13:18:57.892]                   }
[13:18:57.892]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.892]                     cond$call), session = sessionInformation(), 
[13:18:57.892]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.892]                   signalCondition(cond)
[13:18:57.892]                 }
[13:18:57.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.892]                 "immediateCondition"))) {
[13:18:57.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.892]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.892]                   if (TRUE && !signal) {
[13:18:57.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.892]                     {
[13:18:57.892]                       inherits <- base::inherits
[13:18:57.892]                       invokeRestart <- base::invokeRestart
[13:18:57.892]                       is.null <- base::is.null
[13:18:57.892]                       muffled <- FALSE
[13:18:57.892]                       if (inherits(cond, "message")) {
[13:18:57.892]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.892]                         if (muffled) 
[13:18:57.892]                           invokeRestart("muffleMessage")
[13:18:57.892]                       }
[13:18:57.892]                       else if (inherits(cond, "warning")) {
[13:18:57.892]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.892]                         if (muffled) 
[13:18:57.892]                           invokeRestart("muffleWarning")
[13:18:57.892]                       }
[13:18:57.892]                       else if (inherits(cond, "condition")) {
[13:18:57.892]                         if (!is.null(pattern)) {
[13:18:57.892]                           computeRestarts <- base::computeRestarts
[13:18:57.892]                           grepl <- base::grepl
[13:18:57.892]                           restarts <- computeRestarts(cond)
[13:18:57.892]                           for (restart in restarts) {
[13:18:57.892]                             name <- restart$name
[13:18:57.892]                             if (is.null(name)) 
[13:18:57.892]                               next
[13:18:57.892]                             if (!grepl(pattern, name)) 
[13:18:57.892]                               next
[13:18:57.892]                             invokeRestart(restart)
[13:18:57.892]                             muffled <- TRUE
[13:18:57.892]                             break
[13:18:57.892]                           }
[13:18:57.892]                         }
[13:18:57.892]                       }
[13:18:57.892]                       invisible(muffled)
[13:18:57.892]                     }
[13:18:57.892]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.892]                   }
[13:18:57.892]                 }
[13:18:57.892]                 else {
[13:18:57.892]                   if (TRUE) {
[13:18:57.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.892]                     {
[13:18:57.892]                       inherits <- base::inherits
[13:18:57.892]                       invokeRestart <- base::invokeRestart
[13:18:57.892]                       is.null <- base::is.null
[13:18:57.892]                       muffled <- FALSE
[13:18:57.892]                       if (inherits(cond, "message")) {
[13:18:57.892]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.892]                         if (muffled) 
[13:18:57.892]                           invokeRestart("muffleMessage")
[13:18:57.892]                       }
[13:18:57.892]                       else if (inherits(cond, "warning")) {
[13:18:57.892]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.892]                         if (muffled) 
[13:18:57.892]                           invokeRestart("muffleWarning")
[13:18:57.892]                       }
[13:18:57.892]                       else if (inherits(cond, "condition")) {
[13:18:57.892]                         if (!is.null(pattern)) {
[13:18:57.892]                           computeRestarts <- base::computeRestarts
[13:18:57.892]                           grepl <- base::grepl
[13:18:57.892]                           restarts <- computeRestarts(cond)
[13:18:57.892]                           for (restart in restarts) {
[13:18:57.892]                             name <- restart$name
[13:18:57.892]                             if (is.null(name)) 
[13:18:57.892]                               next
[13:18:57.892]                             if (!grepl(pattern, name)) 
[13:18:57.892]                               next
[13:18:57.892]                             invokeRestart(restart)
[13:18:57.892]                             muffled <- TRUE
[13:18:57.892]                             break
[13:18:57.892]                           }
[13:18:57.892]                         }
[13:18:57.892]                       }
[13:18:57.892]                       invisible(muffled)
[13:18:57.892]                     }
[13:18:57.892]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.892]                   }
[13:18:57.892]                 }
[13:18:57.892]             }
[13:18:57.892]         }))
[13:18:57.892]     }, error = function(ex) {
[13:18:57.892]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.892]                 ...future.rng), started = ...future.startTime, 
[13:18:57.892]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.892]             version = "1.8"), class = "FutureResult")
[13:18:57.892]     }, finally = {
[13:18:57.892]         if (!identical(...future.workdir, getwd())) 
[13:18:57.892]             setwd(...future.workdir)
[13:18:57.892]         {
[13:18:57.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.892]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.892]             }
[13:18:57.892]             base::options(...future.oldOptions)
[13:18:57.892]             if (.Platform$OS.type == "windows") {
[13:18:57.892]                 old_names <- names(...future.oldEnvVars)
[13:18:57.892]                 envs <- base::Sys.getenv()
[13:18:57.892]                 names <- names(envs)
[13:18:57.892]                 common <- intersect(names, old_names)
[13:18:57.892]                 added <- setdiff(names, old_names)
[13:18:57.892]                 removed <- setdiff(old_names, names)
[13:18:57.892]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.892]                   envs[common]]
[13:18:57.892]                 NAMES <- toupper(changed)
[13:18:57.892]                 args <- list()
[13:18:57.892]                 for (kk in seq_along(NAMES)) {
[13:18:57.892]                   name <- changed[[kk]]
[13:18:57.892]                   NAME <- NAMES[[kk]]
[13:18:57.892]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.892]                     next
[13:18:57.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.892]                 }
[13:18:57.892]                 NAMES <- toupper(added)
[13:18:57.892]                 for (kk in seq_along(NAMES)) {
[13:18:57.892]                   name <- added[[kk]]
[13:18:57.892]                   NAME <- NAMES[[kk]]
[13:18:57.892]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.892]                     next
[13:18:57.892]                   args[[name]] <- ""
[13:18:57.892]                 }
[13:18:57.892]                 NAMES <- toupper(removed)
[13:18:57.892]                 for (kk in seq_along(NAMES)) {
[13:18:57.892]                   name <- removed[[kk]]
[13:18:57.892]                   NAME <- NAMES[[kk]]
[13:18:57.892]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.892]                     next
[13:18:57.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.892]                 }
[13:18:57.892]                 if (length(args) > 0) 
[13:18:57.892]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.892]             }
[13:18:57.892]             else {
[13:18:57.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.892]             }
[13:18:57.892]             {
[13:18:57.892]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.892]                   0L) {
[13:18:57.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.892]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.892]                   base::options(opts)
[13:18:57.892]                 }
[13:18:57.892]                 {
[13:18:57.892]                   {
[13:18:57.892]                     NULL
[13:18:57.892]                     RNGkind("Mersenne-Twister")
[13:18:57.892]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.892]                       inherits = FALSE)
[13:18:57.892]                   }
[13:18:57.892]                   options(future.plan = NULL)
[13:18:57.892]                   if (is.na(NA_character_)) 
[13:18:57.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.892]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.892]                   {
[13:18:57.892]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.892]                     if (!future$lazy) 
[13:18:57.892]                       future <- run(future)
[13:18:57.892]                     invisible(future)
[13:18:57.892]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.892]                 }
[13:18:57.892]             }
[13:18:57.892]         }
[13:18:57.892]     })
[13:18:57.892]     if (TRUE) {
[13:18:57.892]         base::sink(type = "output", split = FALSE)
[13:18:57.892]         if (TRUE) {
[13:18:57.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.892]         }
[13:18:57.892]         else {
[13:18:57.892]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.892]         }
[13:18:57.892]         base::close(...future.stdout)
[13:18:57.892]         ...future.stdout <- NULL
[13:18:57.892]     }
[13:18:57.892]     ...future.result$conditions <- ...future.conditions
[13:18:57.892]     ...future.result$finished <- base::Sys.time()
[13:18:57.892]     ...future.result
[13:18:57.892] }
[13:18:57.894] assign_globals() ...
[13:18:57.894] List of 5
[13:18:57.894]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:18:57.894]  $ future.call.arguments    : list()
[13:18:57.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.894]  $ ...future.elements_ii    :List of 7
[13:18:57.894]   ..$ : int [1:3] 1 2 3
[13:18:57.894]   ..$ : int [1:4] 1 2 3 4
[13:18:57.894]   ..$ : int [1:5] 1 2 3 4 5
[13:18:57.894]   ..$ : int [1:6] 1 2 3 4 5 6
[13:18:57.894]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:18:57.894]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:18:57.894]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:18:57.894]  $ ...future.seeds_ii       : NULL
[13:18:57.894]  $ ...future.globals.maxSize: NULL
[13:18:57.894]  - attr(*, "resolved")= logi FALSE
[13:18:57.894]  - attr(*, "total_size")= num 46960
[13:18:57.894]  - attr(*, "where")=List of 5
[13:18:57.894]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.894]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.894]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.894]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.894]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.894]  - attr(*, "already-done")= logi TRUE
[13:18:57.900] - copied ‘...future.FUN’ to environment
[13:18:57.900] - copied ‘future.call.arguments’ to environment
[13:18:57.900] - copied ‘...future.elements_ii’ to environment
[13:18:57.900] - copied ‘...future.seeds_ii’ to environment
[13:18:57.901] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.901] assign_globals() ... done
[13:18:57.901] plan(): Setting new future strategy stack:
[13:18:57.901] List of future strategies:
[13:18:57.901] 1. sequential:
[13:18:57.901]    - args: function (..., envir = parent.frame())
[13:18:57.901]    - tweaked: FALSE
[13:18:57.901]    - call: NULL
[13:18:57.901] plan(): nbrOfWorkers() = 1
[13:18:57.902] plan(): Setting new future strategy stack:
[13:18:57.902] List of future strategies:
[13:18:57.902] 1. sequential:
[13:18:57.902]    - args: function (..., envir = parent.frame())
[13:18:57.902]    - tweaked: FALSE
[13:18:57.902]    - call: plan(strategy)
[13:18:57.903] plan(): nbrOfWorkers() = 1
[13:18:57.903] SequentialFuture started (and completed)
[13:18:57.903] - Launch lazy future ... done
[13:18:57.903] run() for ‘SequentialFuture’ ... done
[13:18:57.903] Created future:
[13:18:57.903] SequentialFuture:
[13:18:57.903] Label: ‘future_sapply-1’
[13:18:57.903] Expression:
[13:18:57.903] {
[13:18:57.903]     do.call(function(...) {
[13:18:57.903]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.903]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.903]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.903]             on.exit(options(oopts), add = TRUE)
[13:18:57.903]         }
[13:18:57.903]         {
[13:18:57.903]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.903]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.903]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.903]             })
[13:18:57.903]         }
[13:18:57.903]     }, args = future.call.arguments)
[13:18:57.903] }
[13:18:57.903] Lazy evaluation: FALSE
[13:18:57.903] Asynchronous evaluation: FALSE
[13:18:57.903] Local evaluation: TRUE
[13:18:57.903] Environment: R_GlobalEnv
[13:18:57.903] Capture standard output: TRUE
[13:18:57.903] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.903] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:18:57.903] Packages: 1 packages (‘stats’)
[13:18:57.903] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.903] Resolved: TRUE
[13:18:57.903] Value: 672 bytes of class ‘list’
[13:18:57.903] Early signaling: FALSE
[13:18:57.903] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.903] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.904] Chunk #1 of 1 ... DONE
[13:18:57.904] Launching 1 futures (chunks) ... DONE
[13:18:57.905] Resolving 1 futures (chunks) ...
[13:18:57.905] resolve() on list ...
[13:18:57.905]  recursive: 0
[13:18:57.905]  length: 1
[13:18:57.905] 
[13:18:57.905] resolved() for ‘SequentialFuture’ ...
[13:18:57.905] - state: ‘finished’
[13:18:57.906] - run: TRUE
[13:18:57.907] - result: ‘FutureResult’
[13:18:57.907] resolved() for ‘SequentialFuture’ ... done
[13:18:57.907] Future #1
[13:18:57.907] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.907] - nx: 1
[13:18:57.907] - relay: TRUE
[13:18:57.907] - stdout: TRUE
[13:18:57.907] - signal: TRUE
[13:18:57.907] - resignal: FALSE
[13:18:57.907] - force: TRUE
[13:18:57.908] - relayed: [n=1] FALSE
[13:18:57.908] - queued futures: [n=1] FALSE
[13:18:57.908]  - until=1
[13:18:57.908]  - relaying element #1
[13:18:57.908] - relayed: [n=1] TRUE
[13:18:57.908] - queued futures: [n=1] TRUE
[13:18:57.908] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.908]  length: 0 (resolved future 1)
[13:18:57.908] Relaying remaining futures
[13:18:57.908] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.909] - nx: 1
[13:18:57.909] - relay: TRUE
[13:18:57.909] - stdout: TRUE
[13:18:57.909] - signal: TRUE
[13:18:57.909] - resignal: FALSE
[13:18:57.909] - force: TRUE
[13:18:57.909] - relayed: [n=1] TRUE
[13:18:57.909] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.909] - relayed: [n=1] TRUE
[13:18:57.909] - queued futures: [n=1] TRUE
[13:18:57.909] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.909] resolve() on list ... DONE
[13:18:57.910]  - Number of value chunks collected: 1
[13:18:57.910] Resolving 1 futures (chunks) ... DONE
[13:18:57.910] Reducing values from 1 chunks ...
[13:18:57.910]  - Number of values collected after concatenation: 7
[13:18:57.910]  - Number of values expected: 7
[13:18:57.910] Reducing values from 1 chunks ... DONE
[13:18:57.910] future_lapply() ... DONE
[13:18:57.911] future_lapply() ...
[13:18:57.912] Number of chunks: 1
[13:18:57.912] getGlobalsAndPackagesXApply() ...
[13:18:57.912]  - future.globals: TRUE
[13:18:57.912] getGlobalsAndPackages() ...
[13:18:57.913] Searching for globals...
[13:18:57.919] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:18:57.920] Searching for globals ... DONE
[13:18:57.920] Resolving globals: FALSE
[13:18:57.921] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:18:57.921] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:18:57.921] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.921] - packages: [2] ‘stats’, ‘future.apply’
[13:18:57.922] getGlobalsAndPackages() ... DONE
[13:18:57.922]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:57.922]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:18:57.922] Finding globals ... DONE
[13:18:57.922]  - use_args: TRUE
[13:18:57.922]  - Getting '...' globals ...
[13:18:57.922] resolve() on list ...
[13:18:57.922]  recursive: 0
[13:18:57.922]  length: 1
[13:18:57.923]  elements: ‘...’
[13:18:57.923]  length: 0 (resolved future 1)
[13:18:57.923] resolve() on list ... DONE
[13:18:57.923]    - '...' content: [n=0] 
[13:18:57.923] List of 1
[13:18:57.923]  $ ...: list()
[13:18:57.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.923]  - attr(*, "where")=List of 1
[13:18:57.923]   ..$ ...:<environment: 0x555f79e0bf20> 
[13:18:57.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.923]  - attr(*, "resolved")= logi TRUE
[13:18:57.923]  - attr(*, "total_size")= num NA
[13:18:57.927]  - Getting '...' globals ... DONE
[13:18:57.927] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:57.927] List of 8
[13:18:57.927]  $ ...future.FUN:function (x, ...)  
[13:18:57.927]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:18:57.927]  $ times        : int 5
[13:18:57.927]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.927]  $ stop_if_not  :function (...)  
[13:18:57.927]  $ dim          : NULL
[13:18:57.927]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:57.927]  $ ...          : list()
[13:18:57.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.927]  - attr(*, "where")=List of 8
[13:18:57.927]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:57.927]   ..$ ...          :<environment: 0x555f79e0bf20> 
[13:18:57.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.927]  - attr(*, "resolved")= logi FALSE
[13:18:57.927]  - attr(*, "total_size")= num 141240
[13:18:57.932] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:18:57.932] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.932] Number of futures (= number of chunks): 1
[13:18:57.933] Launching 1 futures (chunks) ...
[13:18:57.933] Chunk #1 of 1 ...
[13:18:57.933]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.933] getGlobalsAndPackages() ...
[13:18:57.933] Searching for globals...
[13:18:57.933] 
[13:18:57.933] Searching for globals ... DONE
[13:18:57.933] - globals: [0] <none>
[13:18:57.933] getGlobalsAndPackages() ... DONE
[13:18:57.934]    + additional globals found: [n=0] 
[13:18:57.934]    + additional namespaces needed: [n=0] 
[13:18:57.934]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.934]  - Adjusted option 'future.globals.maxSize': 524288000 -> 7 * 524288000 = 3670016000 (bytes)
[13:18:57.934]  - seeds: <none>
[13:18:57.934] getGlobalsAndPackages() ...
[13:18:57.934] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.934] Resolving globals: FALSE
[13:18:57.934] Tweak future expression to call with '...' arguments ...
[13:18:57.935] {
[13:18:57.935]     do.call(function(...) {
[13:18:57.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.935]             on.exit(options(oopts), add = TRUE)
[13:18:57.935]         }
[13:18:57.935]         {
[13:18:57.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.935]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.935]             })
[13:18:57.935]         }
[13:18:57.935]     }, args = future.call.arguments)
[13:18:57.935] }
[13:18:57.935] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.935] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.935] - packages: [2] ‘stats’, ‘future.apply’
[13:18:57.936] getGlobalsAndPackages() ... DONE
[13:18:57.936] run() for ‘Future’ ...
[13:18:57.936] - state: ‘created’
[13:18:57.936] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.936] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.937]   - Field: ‘label’
[13:18:57.937]   - Field: ‘local’
[13:18:57.937]   - Field: ‘owner’
[13:18:57.937]   - Field: ‘envir’
[13:18:57.937]   - Field: ‘packages’
[13:18:57.937]   - Field: ‘gc’
[13:18:57.937]   - Field: ‘conditions’
[13:18:57.937]   - Field: ‘expr’
[13:18:57.937]   - Field: ‘uuid’
[13:18:57.937]   - Field: ‘seed’
[13:18:57.937]   - Field: ‘version’
[13:18:57.938]   - Field: ‘result’
[13:18:57.938]   - Field: ‘asynchronous’
[13:18:57.938]   - Field: ‘calls’
[13:18:57.938]   - Field: ‘globals’
[13:18:57.938]   - Field: ‘stdout’
[13:18:57.938]   - Field: ‘earlySignal’
[13:18:57.938]   - Field: ‘lazy’
[13:18:57.938]   - Field: ‘state’
[13:18:57.938] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.938] - Launch lazy future ...
[13:18:57.939] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:18:57.939] Packages needed by future strategies (n = 0): <none>
[13:18:57.939] {
[13:18:57.939]     {
[13:18:57.939]         {
[13:18:57.939]             ...future.startTime <- base::Sys.time()
[13:18:57.939]             {
[13:18:57.939]                 {
[13:18:57.939]                   {
[13:18:57.939]                     {
[13:18:57.939]                       base::local({
[13:18:57.939]                         has_future <- base::requireNamespace("future", 
[13:18:57.939]                           quietly = TRUE)
[13:18:57.939]                         if (has_future) {
[13:18:57.939]                           ns <- base::getNamespace("future")
[13:18:57.939]                           version <- ns[[".package"]][["version"]]
[13:18:57.939]                           if (is.null(version)) 
[13:18:57.939]                             version <- utils::packageVersion("future")
[13:18:57.939]                         }
[13:18:57.939]                         else {
[13:18:57.939]                           version <- NULL
[13:18:57.939]                         }
[13:18:57.939]                         if (!has_future || version < "1.8.0") {
[13:18:57.939]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.939]                             "", base::R.version$version.string), 
[13:18:57.939]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:57.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.939]                               "release", "version")], collapse = " "), 
[13:18:57.939]                             hostname = base::Sys.info()[["nodename"]])
[13:18:57.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.939]                             info)
[13:18:57.939]                           info <- base::paste(info, collapse = "; ")
[13:18:57.939]                           if (!has_future) {
[13:18:57.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.939]                               info)
[13:18:57.939]                           }
[13:18:57.939]                           else {
[13:18:57.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.939]                               info, version)
[13:18:57.939]                           }
[13:18:57.939]                           base::stop(msg)
[13:18:57.939]                         }
[13:18:57.939]                       })
[13:18:57.939]                     }
[13:18:57.939]                     base::local({
[13:18:57.939]                       for (pkg in c("stats", "future.apply")) {
[13:18:57.939]                         base::loadNamespace(pkg)
[13:18:57.939]                         base::library(pkg, character.only = TRUE)
[13:18:57.939]                       }
[13:18:57.939]                     })
[13:18:57.939]                   }
[13:18:57.939]                   options(future.plan = NULL)
[13:18:57.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.939]                 }
[13:18:57.939]                 ...future.workdir <- getwd()
[13:18:57.939]             }
[13:18:57.939]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.939]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.939]         }
[13:18:57.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.939]             future.globals.maxSize = 3670016000, future.globals.method = NULL, 
[13:18:57.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.939]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.939]             base::names(...future.oldOptions))
[13:18:57.939]     }
[13:18:57.939]     if (FALSE) {
[13:18:57.939]     }
[13:18:57.939]     else {
[13:18:57.939]         if (TRUE) {
[13:18:57.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.939]                 open = "w")
[13:18:57.939]         }
[13:18:57.939]         else {
[13:18:57.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.939]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.939]         }
[13:18:57.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.939]             base::sink(type = "output", split = FALSE)
[13:18:57.939]             base::close(...future.stdout)
[13:18:57.939]         }, add = TRUE)
[13:18:57.939]     }
[13:18:57.939]     ...future.frame <- base::sys.nframe()
[13:18:57.939]     ...future.conditions <- base::list()
[13:18:57.939]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.939]     if (FALSE) {
[13:18:57.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.939]     }
[13:18:57.939]     ...future.result <- base::tryCatch({
[13:18:57.939]         base::withCallingHandlers({
[13:18:57.939]             ...future.value <- base::withVisible(base::local({
[13:18:57.939]                 do.call(function(...) {
[13:18:57.939]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.939]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.939]                     ...future.globals.maxSize)) {
[13:18:57.939]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.939]                     on.exit(options(oopts), add = TRUE)
[13:18:57.939]                   }
[13:18:57.939]                   {
[13:18:57.939]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.939]                       FUN = function(jj) {
[13:18:57.939]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.939]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.939]                       })
[13:18:57.939]                   }
[13:18:57.939]                 }, args = future.call.arguments)
[13:18:57.939]             }))
[13:18:57.939]             future::FutureResult(value = ...future.value$value, 
[13:18:57.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.939]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.939]                     ...future.globalenv.names))
[13:18:57.939]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.939]         }, condition = base::local({
[13:18:57.939]             c <- base::c
[13:18:57.939]             inherits <- base::inherits
[13:18:57.939]             invokeRestart <- base::invokeRestart
[13:18:57.939]             length <- base::length
[13:18:57.939]             list <- base::list
[13:18:57.939]             seq.int <- base::seq.int
[13:18:57.939]             signalCondition <- base::signalCondition
[13:18:57.939]             sys.calls <- base::sys.calls
[13:18:57.939]             `[[` <- base::`[[`
[13:18:57.939]             `+` <- base::`+`
[13:18:57.939]             `<<-` <- base::`<<-`
[13:18:57.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.939]                   3L)]
[13:18:57.939]             }
[13:18:57.939]             function(cond) {
[13:18:57.939]                 is_error <- inherits(cond, "error")
[13:18:57.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.939]                   NULL)
[13:18:57.939]                 if (is_error) {
[13:18:57.939]                   sessionInformation <- function() {
[13:18:57.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.939]                       search = base::search(), system = base::Sys.info())
[13:18:57.939]                   }
[13:18:57.939]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.939]                     cond$call), session = sessionInformation(), 
[13:18:57.939]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.939]                   signalCondition(cond)
[13:18:57.939]                 }
[13:18:57.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.939]                 "immediateCondition"))) {
[13:18:57.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.939]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.939]                   if (TRUE && !signal) {
[13:18:57.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.939]                     {
[13:18:57.939]                       inherits <- base::inherits
[13:18:57.939]                       invokeRestart <- base::invokeRestart
[13:18:57.939]                       is.null <- base::is.null
[13:18:57.939]                       muffled <- FALSE
[13:18:57.939]                       if (inherits(cond, "message")) {
[13:18:57.939]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.939]                         if (muffled) 
[13:18:57.939]                           invokeRestart("muffleMessage")
[13:18:57.939]                       }
[13:18:57.939]                       else if (inherits(cond, "warning")) {
[13:18:57.939]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.939]                         if (muffled) 
[13:18:57.939]                           invokeRestart("muffleWarning")
[13:18:57.939]                       }
[13:18:57.939]                       else if (inherits(cond, "condition")) {
[13:18:57.939]                         if (!is.null(pattern)) {
[13:18:57.939]                           computeRestarts <- base::computeRestarts
[13:18:57.939]                           grepl <- base::grepl
[13:18:57.939]                           restarts <- computeRestarts(cond)
[13:18:57.939]                           for (restart in restarts) {
[13:18:57.939]                             name <- restart$name
[13:18:57.939]                             if (is.null(name)) 
[13:18:57.939]                               next
[13:18:57.939]                             if (!grepl(pattern, name)) 
[13:18:57.939]                               next
[13:18:57.939]                             invokeRestart(restart)
[13:18:57.939]                             muffled <- TRUE
[13:18:57.939]                             break
[13:18:57.939]                           }
[13:18:57.939]                         }
[13:18:57.939]                       }
[13:18:57.939]                       invisible(muffled)
[13:18:57.939]                     }
[13:18:57.939]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.939]                   }
[13:18:57.939]                 }
[13:18:57.939]                 else {
[13:18:57.939]                   if (TRUE) {
[13:18:57.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.939]                     {
[13:18:57.939]                       inherits <- base::inherits
[13:18:57.939]                       invokeRestart <- base::invokeRestart
[13:18:57.939]                       is.null <- base::is.null
[13:18:57.939]                       muffled <- FALSE
[13:18:57.939]                       if (inherits(cond, "message")) {
[13:18:57.939]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.939]                         if (muffled) 
[13:18:57.939]                           invokeRestart("muffleMessage")
[13:18:57.939]                       }
[13:18:57.939]                       else if (inherits(cond, "warning")) {
[13:18:57.939]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.939]                         if (muffled) 
[13:18:57.939]                           invokeRestart("muffleWarning")
[13:18:57.939]                       }
[13:18:57.939]                       else if (inherits(cond, "condition")) {
[13:18:57.939]                         if (!is.null(pattern)) {
[13:18:57.939]                           computeRestarts <- base::computeRestarts
[13:18:57.939]                           grepl <- base::grepl
[13:18:57.939]                           restarts <- computeRestarts(cond)
[13:18:57.939]                           for (restart in restarts) {
[13:18:57.939]                             name <- restart$name
[13:18:57.939]                             if (is.null(name)) 
[13:18:57.939]                               next
[13:18:57.939]                             if (!grepl(pattern, name)) 
[13:18:57.939]                               next
[13:18:57.939]                             invokeRestart(restart)
[13:18:57.939]                             muffled <- TRUE
[13:18:57.939]                             break
[13:18:57.939]                           }
[13:18:57.939]                         }
[13:18:57.939]                       }
[13:18:57.939]                       invisible(muffled)
[13:18:57.939]                     }
[13:18:57.939]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.939]                   }
[13:18:57.939]                 }
[13:18:57.939]             }
[13:18:57.939]         }))
[13:18:57.939]     }, error = function(ex) {
[13:18:57.939]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.939]                 ...future.rng), started = ...future.startTime, 
[13:18:57.939]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.939]             version = "1.8"), class = "FutureResult")
[13:18:57.939]     }, finally = {
[13:18:57.939]         if (!identical(...future.workdir, getwd())) 
[13:18:57.939]             setwd(...future.workdir)
[13:18:57.939]         {
[13:18:57.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.939]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.939]             }
[13:18:57.939]             base::options(...future.oldOptions)
[13:18:57.939]             if (.Platform$OS.type == "windows") {
[13:18:57.939]                 old_names <- names(...future.oldEnvVars)
[13:18:57.939]                 envs <- base::Sys.getenv()
[13:18:57.939]                 names <- names(envs)
[13:18:57.939]                 common <- intersect(names, old_names)
[13:18:57.939]                 added <- setdiff(names, old_names)
[13:18:57.939]                 removed <- setdiff(old_names, names)
[13:18:57.939]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.939]                   envs[common]]
[13:18:57.939]                 NAMES <- toupper(changed)
[13:18:57.939]                 args <- list()
[13:18:57.939]                 for (kk in seq_along(NAMES)) {
[13:18:57.939]                   name <- changed[[kk]]
[13:18:57.939]                   NAME <- NAMES[[kk]]
[13:18:57.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.939]                     next
[13:18:57.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.939]                 }
[13:18:57.939]                 NAMES <- toupper(added)
[13:18:57.939]                 for (kk in seq_along(NAMES)) {
[13:18:57.939]                   name <- added[[kk]]
[13:18:57.939]                   NAME <- NAMES[[kk]]
[13:18:57.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.939]                     next
[13:18:57.939]                   args[[name]] <- ""
[13:18:57.939]                 }
[13:18:57.939]                 NAMES <- toupper(removed)
[13:18:57.939]                 for (kk in seq_along(NAMES)) {
[13:18:57.939]                   name <- removed[[kk]]
[13:18:57.939]                   NAME <- NAMES[[kk]]
[13:18:57.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.939]                     next
[13:18:57.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.939]                 }
[13:18:57.939]                 if (length(args) > 0) 
[13:18:57.939]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.939]             }
[13:18:57.939]             else {
[13:18:57.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.939]             }
[13:18:57.939]             {
[13:18:57.939]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.939]                   0L) {
[13:18:57.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.939]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.939]                   base::options(opts)
[13:18:57.939]                 }
[13:18:57.939]                 {
[13:18:57.939]                   {
[13:18:57.939]                     NULL
[13:18:57.939]                     RNGkind("Mersenne-Twister")
[13:18:57.939]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.939]                       inherits = FALSE)
[13:18:57.939]                   }
[13:18:57.939]                   options(future.plan = NULL)
[13:18:57.939]                   if (is.na(NA_character_)) 
[13:18:57.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.939]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.939]                   {
[13:18:57.939]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.939]                     if (!future$lazy) 
[13:18:57.939]                       future <- run(future)
[13:18:57.939]                     invisible(future)
[13:18:57.939]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.939]                 }
[13:18:57.939]             }
[13:18:57.939]         }
[13:18:57.939]     })
[13:18:57.939]     if (TRUE) {
[13:18:57.939]         base::sink(type = "output", split = FALSE)
[13:18:57.939]         if (TRUE) {
[13:18:57.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.939]         }
[13:18:57.939]         else {
[13:18:57.939]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.939]         }
[13:18:57.939]         base::close(...future.stdout)
[13:18:57.939]         ...future.stdout <- NULL
[13:18:57.939]     }
[13:18:57.939]     ...future.result$conditions <- ...future.conditions
[13:18:57.939]     ...future.result$finished <- base::Sys.time()
[13:18:57.939]     ...future.result
[13:18:57.939] }
[13:18:57.941] assign_globals() ...
[13:18:57.941] List of 11
[13:18:57.941]  $ ...future.FUN            :function (x, ...)  
[13:18:57.941]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:18:57.941]  $ times                    : int 5
[13:18:57.941]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:57.941]  $ stop_if_not              :function (...)  
[13:18:57.941]  $ dim                      : NULL
[13:18:57.941]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:57.941]  $ future.call.arguments    : list()
[13:18:57.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.941]  $ ...future.elements_ii    :List of 7
[13:18:57.941]   ..$ : int [1:3] 1 2 3
[13:18:57.941]   ..$ : int [1:4] 1 2 3 4
[13:18:57.941]   ..$ : int [1:5] 1 2 3 4 5
[13:18:57.941]   ..$ : int [1:6] 1 2 3 4 5 6
[13:18:57.941]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:18:57.941]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:18:57.941]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:18:57.941]  $ ...future.seeds_ii       : NULL
[13:18:57.941]  $ ...future.globals.maxSize: NULL
[13:18:57.941]  - attr(*, "resolved")= logi FALSE
[13:18:57.941]  - attr(*, "total_size")= num 141240
[13:18:57.941]  - attr(*, "where")=List of 11
[13:18:57.941]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.941]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.941]  - attr(*, "already-done")= logi TRUE
[13:18:57.952] - copied ‘...future.FUN’ to environment
[13:18:57.952] - copied ‘x_FUN’ to environment
[13:18:57.952] - copied ‘times’ to environment
[13:18:57.952] - copied ‘stopf’ to environment
[13:18:57.952] - copied ‘stop_if_not’ to environment
[13:18:57.952] - copied ‘dim’ to environment
[13:18:57.952] - copied ‘valid_types’ to environment
[13:18:57.952] - copied ‘future.call.arguments’ to environment
[13:18:57.952] - copied ‘...future.elements_ii’ to environment
[13:18:57.953] - copied ‘...future.seeds_ii’ to environment
[13:18:57.953] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.953] assign_globals() ... done
[13:18:57.953] plan(): Setting new future strategy stack:
[13:18:57.953] List of future strategies:
[13:18:57.953] 1. sequential:
[13:18:57.953]    - args: function (..., envir = parent.frame())
[13:18:57.953]    - tweaked: FALSE
[13:18:57.953]    - call: NULL
[13:18:57.954] plan(): nbrOfWorkers() = 1
[13:18:57.954] plan(): Setting new future strategy stack:
[13:18:57.955] List of future strategies:
[13:18:57.955] 1. sequential:
[13:18:57.955]    - args: function (..., envir = parent.frame())
[13:18:57.955]    - tweaked: FALSE
[13:18:57.955]    - call: plan(strategy)
[13:18:57.955] plan(): nbrOfWorkers() = 1
[13:18:57.955] SequentialFuture started (and completed)
[13:18:57.955] - Launch lazy future ... done
[13:18:57.955] run() for ‘SequentialFuture’ ... done
[13:18:57.955] Created future:
[13:18:57.956] SequentialFuture:
[13:18:57.956] Label: ‘future_vapply-1’
[13:18:57.956] Expression:
[13:18:57.956] {
[13:18:57.956]     do.call(function(...) {
[13:18:57.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.956]             on.exit(options(oopts), add = TRUE)
[13:18:57.956]         }
[13:18:57.956]         {
[13:18:57.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.956]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.956]             })
[13:18:57.956]         }
[13:18:57.956]     }, args = future.call.arguments)
[13:18:57.956] }
[13:18:57.956] Lazy evaluation: FALSE
[13:18:57.956] Asynchronous evaluation: FALSE
[13:18:57.956] Local evaluation: TRUE
[13:18:57.956] Environment: R_GlobalEnv
[13:18:57.956] Capture standard output: TRUE
[13:18:57.956] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.956] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:57.956] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:18:57.956] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.956] Resolved: TRUE
[13:18:57.956] Value: 672 bytes of class ‘list’
[13:18:57.956] Early signaling: FALSE
[13:18:57.956] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.956] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.957] Chunk #1 of 1 ... DONE
[13:18:57.957] Launching 1 futures (chunks) ... DONE
[13:18:57.957] Resolving 1 futures (chunks) ...
[13:18:57.957] resolve() on list ...
[13:18:57.957]  recursive: 0
[13:18:57.957]  length: 1
[13:18:57.957] 
[13:18:57.957] resolved() for ‘SequentialFuture’ ...
[13:18:57.957] - state: ‘finished’
[13:18:57.958] - run: TRUE
[13:18:57.958] - result: ‘FutureResult’
[13:18:57.958] resolved() for ‘SequentialFuture’ ... done
[13:18:57.958] Future #1
[13:18:57.958] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.958] - nx: 1
[13:18:57.958] - relay: TRUE
[13:18:57.958] - stdout: TRUE
[13:18:57.958] - signal: TRUE
[13:18:57.958] - resignal: FALSE
[13:18:57.958] - force: TRUE
[13:18:57.958] - relayed: [n=1] FALSE
[13:18:57.959] - queued futures: [n=1] FALSE
[13:18:57.959]  - until=1
[13:18:57.959]  - relaying element #1
[13:18:57.959] - relayed: [n=1] TRUE
[13:18:57.959] - queued futures: [n=1] TRUE
[13:18:57.959] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.959]  length: 0 (resolved future 1)
[13:18:57.959] Relaying remaining futures
[13:18:57.959] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.959] - nx: 1
[13:18:57.960] - relay: TRUE
[13:18:57.960] - stdout: TRUE
[13:18:57.960] - signal: TRUE
[13:18:57.960] - resignal: FALSE
[13:18:57.960] - force: TRUE
[13:18:57.960] - relayed: [n=1] TRUE
[13:18:57.960] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.960] - relayed: [n=1] TRUE
[13:18:57.960] - queued futures: [n=1] TRUE
[13:18:57.960] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.960] resolve() on list ... DONE
[13:18:57.961]  - Number of value chunks collected: 1
[13:18:57.961] Resolving 1 futures (chunks) ... DONE
[13:18:57.961] Reducing values from 1 chunks ...
[13:18:57.961]  - Number of values collected after concatenation: 7
[13:18:57.961]  - Number of values expected: 7
[13:18:57.961] Reducing values from 1 chunks ... DONE
[13:18:57.961] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:18:57.963] future_lapply() ...
[13:18:57.963] Number of chunks: 1
[13:18:57.964] getGlobalsAndPackagesXApply() ...
[13:18:57.964]  - future.globals: TRUE
[13:18:57.964] getGlobalsAndPackages() ...
[13:18:57.964] Searching for globals...
[13:18:57.965] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:18:57.965] Searching for globals ... DONE
[13:18:57.965] Resolving globals: FALSE
[13:18:57.966] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:18:57.966] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:18:57.966] - globals: [1] ‘FUN’
[13:18:57.966] 
[13:18:57.966] getGlobalsAndPackages() ... DONE
[13:18:57.966]  - globals found/used: [n=1] ‘FUN’
[13:18:57.966]  - needed namespaces: [n=0] 
[13:18:57.967] Finding globals ... DONE
[13:18:57.967]  - use_args: TRUE
[13:18:57.967]  - Getting '...' globals ...
[13:18:57.967] resolve() on list ...
[13:18:57.967]  recursive: 0
[13:18:57.967]  length: 1
[13:18:57.967]  elements: ‘...’
[13:18:57.967]  length: 0 (resolved future 1)
[13:18:57.968] resolve() on list ... DONE
[13:18:57.968]    - '...' content: [n=1] ‘y’
[13:18:57.968] List of 1
[13:18:57.968]  $ ...:List of 1
[13:18:57.968]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:57.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.968]  - attr(*, "where")=List of 1
[13:18:57.968]   ..$ ...:<environment: 0x555f7b631ee0> 
[13:18:57.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.968]  - attr(*, "resolved")= logi TRUE
[13:18:57.968]  - attr(*, "total_size")= num NA
[13:18:57.972]  - Getting '...' globals ... DONE
[13:18:57.972] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:18:57.972] List of 2
[13:18:57.972]  $ ...future.FUN:function (x, y)  
[13:18:57.972]  $ ...          :List of 1
[13:18:57.972]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:57.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.972]  - attr(*, "where")=List of 2
[13:18:57.972]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:57.972]   ..$ ...          :<environment: 0x555f7b631ee0> 
[13:18:57.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.972]  - attr(*, "resolved")= logi FALSE
[13:18:57.972]  - attr(*, "total_size")= num 4264
[13:18:57.975] Packages to be attached in all futures: [n=0] 
[13:18:57.976] getGlobalsAndPackagesXApply() ... DONE
[13:18:57.976] Number of futures (= number of chunks): 1
[13:18:57.976] Launching 1 futures (chunks) ...
[13:18:57.976] Chunk #1 of 1 ...
[13:18:57.976]  - Finding globals in 'X' for chunk #1 ...
[13:18:57.976] getGlobalsAndPackages() ...
[13:18:57.976] Searching for globals...
[13:18:57.976] 
[13:18:57.977] Searching for globals ... DONE
[13:18:57.977] - globals: [0] <none>
[13:18:57.977] getGlobalsAndPackages() ... DONE
[13:18:57.977]    + additional globals found: [n=0] 
[13:18:57.977]    + additional namespaces needed: [n=0] 
[13:18:57.977]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:57.977]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[13:18:57.977]  - seeds: <none>
[13:18:57.977] getGlobalsAndPackages() ...
[13:18:57.977] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.978] Resolving globals: FALSE
[13:18:57.978] Tweak future expression to call with '...' arguments ...
[13:18:57.978] {
[13:18:57.978]     do.call(function(...) {
[13:18:57.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.978]             on.exit(options(oopts), add = TRUE)
[13:18:57.978]         }
[13:18:57.978]         {
[13:18:57.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.978]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.978]             })
[13:18:57.978]         }
[13:18:57.978]     }, args = future.call.arguments)
[13:18:57.978] }
[13:18:57.978] Tweak future expression to call with '...' arguments ... DONE
[13:18:57.978] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:57.978] 
[13:18:57.979] getGlobalsAndPackages() ... DONE
[13:18:57.979] run() for ‘Future’ ...
[13:18:57.979] - state: ‘created’
[13:18:57.979] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:57.979] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:57.980]   - Field: ‘label’
[13:18:57.980]   - Field: ‘local’
[13:18:57.980]   - Field: ‘owner’
[13:18:57.980]   - Field: ‘envir’
[13:18:57.980]   - Field: ‘packages’
[13:18:57.980]   - Field: ‘gc’
[13:18:57.980]   - Field: ‘conditions’
[13:18:57.980]   - Field: ‘expr’
[13:18:57.980]   - Field: ‘uuid’
[13:18:57.980]   - Field: ‘seed’
[13:18:57.980]   - Field: ‘version’
[13:18:57.981]   - Field: ‘result’
[13:18:57.981]   - Field: ‘asynchronous’
[13:18:57.981]   - Field: ‘calls’
[13:18:57.981]   - Field: ‘globals’
[13:18:57.981]   - Field: ‘stdout’
[13:18:57.981]   - Field: ‘earlySignal’
[13:18:57.981]   - Field: ‘lazy’
[13:18:57.981]   - Field: ‘state’
[13:18:57.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:57.981] - Launch lazy future ...
[13:18:57.982] Packages needed by the future expression (n = 0): <none>
[13:18:57.982] Packages needed by future strategies (n = 0): <none>
[13:18:57.982] {
[13:18:57.982]     {
[13:18:57.982]         {
[13:18:57.982]             ...future.startTime <- base::Sys.time()
[13:18:57.982]             {
[13:18:57.982]                 {
[13:18:57.982]                   {
[13:18:57.982]                     base::local({
[13:18:57.982]                       has_future <- base::requireNamespace("future", 
[13:18:57.982]                         quietly = TRUE)
[13:18:57.982]                       if (has_future) {
[13:18:57.982]                         ns <- base::getNamespace("future")
[13:18:57.982]                         version <- ns[[".package"]][["version"]]
[13:18:57.982]                         if (is.null(version)) 
[13:18:57.982]                           version <- utils::packageVersion("future")
[13:18:57.982]                       }
[13:18:57.982]                       else {
[13:18:57.982]                         version <- NULL
[13:18:57.982]                       }
[13:18:57.982]                       if (!has_future || version < "1.8.0") {
[13:18:57.982]                         info <- base::c(r_version = base::gsub("R version ", 
[13:18:57.982]                           "", base::R.version$version.string), 
[13:18:57.982]                           platform = base::sprintf("%s (%s-bit)", 
[13:18:57.982]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:57.982]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:57.982]                             "release", "version")], collapse = " "), 
[13:18:57.982]                           hostname = base::Sys.info()[["nodename"]])
[13:18:57.982]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:18:57.982]                           info)
[13:18:57.982]                         info <- base::paste(info, collapse = "; ")
[13:18:57.982]                         if (!has_future) {
[13:18:57.982]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:57.982]                             info)
[13:18:57.982]                         }
[13:18:57.982]                         else {
[13:18:57.982]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:57.982]                             info, version)
[13:18:57.982]                         }
[13:18:57.982]                         base::stop(msg)
[13:18:57.982]                       }
[13:18:57.982]                     })
[13:18:57.982]                   }
[13:18:57.982]                   options(future.plan = NULL)
[13:18:57.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:57.982]                 }
[13:18:57.982]                 ...future.workdir <- getwd()
[13:18:57.982]             }
[13:18:57.982]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:57.982]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:57.982]         }
[13:18:57.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:57.982]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[13:18:57.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:57.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:57.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:57.982]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:57.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:57.982]             base::names(...future.oldOptions))
[13:18:57.982]     }
[13:18:57.982]     if (FALSE) {
[13:18:57.982]     }
[13:18:57.982]     else {
[13:18:57.982]         if (TRUE) {
[13:18:57.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:57.982]                 open = "w")
[13:18:57.982]         }
[13:18:57.982]         else {
[13:18:57.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:57.982]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:57.982]         }
[13:18:57.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:57.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:57.982]             base::sink(type = "output", split = FALSE)
[13:18:57.982]             base::close(...future.stdout)
[13:18:57.982]         }, add = TRUE)
[13:18:57.982]     }
[13:18:57.982]     ...future.frame <- base::sys.nframe()
[13:18:57.982]     ...future.conditions <- base::list()
[13:18:57.982]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:57.982]     if (FALSE) {
[13:18:57.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:57.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:57.982]     }
[13:18:57.982]     ...future.result <- base::tryCatch({
[13:18:57.982]         base::withCallingHandlers({
[13:18:57.982]             ...future.value <- base::withVisible(base::local({
[13:18:57.982]                 do.call(function(...) {
[13:18:57.982]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.982]                   if (!identical(...future.globals.maxSize.org, 
[13:18:57.982]                     ...future.globals.maxSize)) {
[13:18:57.982]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.982]                     on.exit(options(oopts), add = TRUE)
[13:18:57.982]                   }
[13:18:57.982]                   {
[13:18:57.982]                     lapply(seq_along(...future.elements_ii), 
[13:18:57.982]                       FUN = function(jj) {
[13:18:57.982]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.982]                         ...future.FUN(...future.X_jj, ...)
[13:18:57.982]                       })
[13:18:57.982]                   }
[13:18:57.982]                 }, args = future.call.arguments)
[13:18:57.982]             }))
[13:18:57.982]             future::FutureResult(value = ...future.value$value, 
[13:18:57.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.982]                   ...future.rng), globalenv = if (FALSE) 
[13:18:57.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:57.982]                     ...future.globalenv.names))
[13:18:57.982]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:57.982]         }, condition = base::local({
[13:18:57.982]             c <- base::c
[13:18:57.982]             inherits <- base::inherits
[13:18:57.982]             invokeRestart <- base::invokeRestart
[13:18:57.982]             length <- base::length
[13:18:57.982]             list <- base::list
[13:18:57.982]             seq.int <- base::seq.int
[13:18:57.982]             signalCondition <- base::signalCondition
[13:18:57.982]             sys.calls <- base::sys.calls
[13:18:57.982]             `[[` <- base::`[[`
[13:18:57.982]             `+` <- base::`+`
[13:18:57.982]             `<<-` <- base::`<<-`
[13:18:57.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:57.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:57.982]                   3L)]
[13:18:57.982]             }
[13:18:57.982]             function(cond) {
[13:18:57.982]                 is_error <- inherits(cond, "error")
[13:18:57.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:57.982]                   NULL)
[13:18:57.982]                 if (is_error) {
[13:18:57.982]                   sessionInformation <- function() {
[13:18:57.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:57.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:57.982]                       search = base::search(), system = base::Sys.info())
[13:18:57.982]                   }
[13:18:57.982]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:57.982]                     cond$call), session = sessionInformation(), 
[13:18:57.982]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:57.982]                   signalCondition(cond)
[13:18:57.982]                 }
[13:18:57.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:57.982]                 "immediateCondition"))) {
[13:18:57.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:57.982]                   ...future.conditions[[length(...future.conditions) + 
[13:18:57.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:57.982]                   if (TRUE && !signal) {
[13:18:57.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.982]                     {
[13:18:57.982]                       inherits <- base::inherits
[13:18:57.982]                       invokeRestart <- base::invokeRestart
[13:18:57.982]                       is.null <- base::is.null
[13:18:57.982]                       muffled <- FALSE
[13:18:57.982]                       if (inherits(cond, "message")) {
[13:18:57.982]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.982]                         if (muffled) 
[13:18:57.982]                           invokeRestart("muffleMessage")
[13:18:57.982]                       }
[13:18:57.982]                       else if (inherits(cond, "warning")) {
[13:18:57.982]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.982]                         if (muffled) 
[13:18:57.982]                           invokeRestart("muffleWarning")
[13:18:57.982]                       }
[13:18:57.982]                       else if (inherits(cond, "condition")) {
[13:18:57.982]                         if (!is.null(pattern)) {
[13:18:57.982]                           computeRestarts <- base::computeRestarts
[13:18:57.982]                           grepl <- base::grepl
[13:18:57.982]                           restarts <- computeRestarts(cond)
[13:18:57.982]                           for (restart in restarts) {
[13:18:57.982]                             name <- restart$name
[13:18:57.982]                             if (is.null(name)) 
[13:18:57.982]                               next
[13:18:57.982]                             if (!grepl(pattern, name)) 
[13:18:57.982]                               next
[13:18:57.982]                             invokeRestart(restart)
[13:18:57.982]                             muffled <- TRUE
[13:18:57.982]                             break
[13:18:57.982]                           }
[13:18:57.982]                         }
[13:18:57.982]                       }
[13:18:57.982]                       invisible(muffled)
[13:18:57.982]                     }
[13:18:57.982]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.982]                   }
[13:18:57.982]                 }
[13:18:57.982]                 else {
[13:18:57.982]                   if (TRUE) {
[13:18:57.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:57.982]                     {
[13:18:57.982]                       inherits <- base::inherits
[13:18:57.982]                       invokeRestart <- base::invokeRestart
[13:18:57.982]                       is.null <- base::is.null
[13:18:57.982]                       muffled <- FALSE
[13:18:57.982]                       if (inherits(cond, "message")) {
[13:18:57.982]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:57.982]                         if (muffled) 
[13:18:57.982]                           invokeRestart("muffleMessage")
[13:18:57.982]                       }
[13:18:57.982]                       else if (inherits(cond, "warning")) {
[13:18:57.982]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:57.982]                         if (muffled) 
[13:18:57.982]                           invokeRestart("muffleWarning")
[13:18:57.982]                       }
[13:18:57.982]                       else if (inherits(cond, "condition")) {
[13:18:57.982]                         if (!is.null(pattern)) {
[13:18:57.982]                           computeRestarts <- base::computeRestarts
[13:18:57.982]                           grepl <- base::grepl
[13:18:57.982]                           restarts <- computeRestarts(cond)
[13:18:57.982]                           for (restart in restarts) {
[13:18:57.982]                             name <- restart$name
[13:18:57.982]                             if (is.null(name)) 
[13:18:57.982]                               next
[13:18:57.982]                             if (!grepl(pattern, name)) 
[13:18:57.982]                               next
[13:18:57.982]                             invokeRestart(restart)
[13:18:57.982]                             muffled <- TRUE
[13:18:57.982]                             break
[13:18:57.982]                           }
[13:18:57.982]                         }
[13:18:57.982]                       }
[13:18:57.982]                       invisible(muffled)
[13:18:57.982]                     }
[13:18:57.982]                     muffleCondition(cond, pattern = "^muffle")
[13:18:57.982]                   }
[13:18:57.982]                 }
[13:18:57.982]             }
[13:18:57.982]         }))
[13:18:57.982]     }, error = function(ex) {
[13:18:57.982]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:57.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:57.982]                 ...future.rng), started = ...future.startTime, 
[13:18:57.982]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:57.982]             version = "1.8"), class = "FutureResult")
[13:18:57.982]     }, finally = {
[13:18:57.982]         if (!identical(...future.workdir, getwd())) 
[13:18:57.982]             setwd(...future.workdir)
[13:18:57.982]         {
[13:18:57.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:57.982]                 ...future.oldOptions$nwarnings <- NULL
[13:18:57.982]             }
[13:18:57.982]             base::options(...future.oldOptions)
[13:18:57.982]             if (.Platform$OS.type == "windows") {
[13:18:57.982]                 old_names <- names(...future.oldEnvVars)
[13:18:57.982]                 envs <- base::Sys.getenv()
[13:18:57.982]                 names <- names(envs)
[13:18:57.982]                 common <- intersect(names, old_names)
[13:18:57.982]                 added <- setdiff(names, old_names)
[13:18:57.982]                 removed <- setdiff(old_names, names)
[13:18:57.982]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:57.982]                   envs[common]]
[13:18:57.982]                 NAMES <- toupper(changed)
[13:18:57.982]                 args <- list()
[13:18:57.982]                 for (kk in seq_along(NAMES)) {
[13:18:57.982]                   name <- changed[[kk]]
[13:18:57.982]                   NAME <- NAMES[[kk]]
[13:18:57.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.982]                     next
[13:18:57.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.982]                 }
[13:18:57.982]                 NAMES <- toupper(added)
[13:18:57.982]                 for (kk in seq_along(NAMES)) {
[13:18:57.982]                   name <- added[[kk]]
[13:18:57.982]                   NAME <- NAMES[[kk]]
[13:18:57.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.982]                     next
[13:18:57.982]                   args[[name]] <- ""
[13:18:57.982]                 }
[13:18:57.982]                 NAMES <- toupper(removed)
[13:18:57.982]                 for (kk in seq_along(NAMES)) {
[13:18:57.982]                   name <- removed[[kk]]
[13:18:57.982]                   NAME <- NAMES[[kk]]
[13:18:57.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:57.982]                     next
[13:18:57.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:57.982]                 }
[13:18:57.982]                 if (length(args) > 0) 
[13:18:57.982]                   base::do.call(base::Sys.setenv, args = args)
[13:18:57.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:57.982]             }
[13:18:57.982]             else {
[13:18:57.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:57.982]             }
[13:18:57.982]             {
[13:18:57.982]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:57.982]                   0L) {
[13:18:57.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:57.982]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:57.982]                   base::options(opts)
[13:18:57.982]                 }
[13:18:57.982]                 {
[13:18:57.982]                   {
[13:18:57.982]                     NULL
[13:18:57.982]                     RNGkind("Mersenne-Twister")
[13:18:57.982]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:57.982]                       inherits = FALSE)
[13:18:57.982]                   }
[13:18:57.982]                   options(future.plan = NULL)
[13:18:57.982]                   if (is.na(NA_character_)) 
[13:18:57.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:57.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:57.982]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:57.982]                   {
[13:18:57.982]                     future <- SequentialFuture(..., envir = envir)
[13:18:57.982]                     if (!future$lazy) 
[13:18:57.982]                       future <- run(future)
[13:18:57.982]                     invisible(future)
[13:18:57.982]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:57.982]                 }
[13:18:57.982]             }
[13:18:57.982]         }
[13:18:57.982]     })
[13:18:57.982]     if (TRUE) {
[13:18:57.982]         base::sink(type = "output", split = FALSE)
[13:18:57.982]         if (TRUE) {
[13:18:57.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:57.982]         }
[13:18:57.982]         else {
[13:18:57.982]             ...future.result["stdout"] <- base::list(NULL)
[13:18:57.982]         }
[13:18:57.982]         base::close(...future.stdout)
[13:18:57.982]         ...future.stdout <- NULL
[13:18:57.982]     }
[13:18:57.982]     ...future.result$conditions <- ...future.conditions
[13:18:57.982]     ...future.result$finished <- base::Sys.time()
[13:18:57.982]     ...future.result
[13:18:57.982] }
[13:18:57.984] assign_globals() ...
[13:18:57.984] List of 5
[13:18:57.984]  $ ...future.FUN            :function (x, y)  
[13:18:57.984]  $ future.call.arguments    :List of 1
[13:18:57.984]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:57.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:57.984]  $ ...future.elements_ii    :List of 4
[13:18:57.984]   ..$ A: num 50
[13:18:57.984]   ..$ B: num 60
[13:18:57.984]   ..$ C: num 70
[13:18:57.984]   ..$ D: num 80
[13:18:57.984]  $ ...future.seeds_ii       : NULL
[13:18:57.984]  $ ...future.globals.maxSize: NULL
[13:18:57.984]  - attr(*, "resolved")= logi FALSE
[13:18:57.984]  - attr(*, "total_size")= num 4264
[13:18:57.984]  - attr(*, "where")=List of 5
[13:18:57.984]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:57.984]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:57.984]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:57.984]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:57.984]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:57.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:57.984]  - attr(*, "already-done")= logi TRUE
[13:18:57.990] - reassign environment for ‘...future.FUN’
[13:18:57.990] - copied ‘...future.FUN’ to environment
[13:18:57.990] - copied ‘future.call.arguments’ to environment
[13:18:57.990] - copied ‘...future.elements_ii’ to environment
[13:18:57.990] - copied ‘...future.seeds_ii’ to environment
[13:18:57.990] - copied ‘...future.globals.maxSize’ to environment
[13:18:57.990] assign_globals() ... done
[13:18:57.990] plan(): Setting new future strategy stack:
[13:18:57.991] List of future strategies:
[13:18:57.991] 1. sequential:
[13:18:57.991]    - args: function (..., envir = parent.frame())
[13:18:57.991]    - tweaked: FALSE
[13:18:57.991]    - call: NULL
[13:18:57.991] plan(): nbrOfWorkers() = 1
[13:18:57.992] plan(): Setting new future strategy stack:
[13:18:57.992] List of future strategies:
[13:18:57.992] 1. sequential:
[13:18:57.992]    - args: function (..., envir = parent.frame())
[13:18:57.992]    - tweaked: FALSE
[13:18:57.992]    - call: plan(strategy)
[13:18:57.992] plan(): nbrOfWorkers() = 1
[13:18:57.992] SequentialFuture started (and completed)
[13:18:57.992] - Launch lazy future ... done
[13:18:57.994] run() for ‘SequentialFuture’ ... done
[13:18:57.994] Created future:
[13:18:57.994] SequentialFuture:
[13:18:57.994] Label: ‘future_sapply-1’
[13:18:57.994] Expression:
[13:18:57.994] {
[13:18:57.994]     do.call(function(...) {
[13:18:57.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:57.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:57.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:57.994]             on.exit(options(oopts), add = TRUE)
[13:18:57.994]         }
[13:18:57.994]         {
[13:18:57.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:57.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:57.994]                 ...future.FUN(...future.X_jj, ...)
[13:18:57.994]             })
[13:18:57.994]         }
[13:18:57.994]     }, args = future.call.arguments)
[13:18:57.994] }
[13:18:57.994] Lazy evaluation: FALSE
[13:18:57.994] Asynchronous evaluation: FALSE
[13:18:57.994] Local evaluation: TRUE
[13:18:57.994] Environment: R_GlobalEnv
[13:18:57.994] Capture standard output: TRUE
[13:18:57.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:57.994] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:18:57.994] Packages: <none>
[13:18:57.994] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:57.994] Resolved: TRUE
[13:18:57.994] Value: 1.34 KiB of class ‘list’
[13:18:57.994] Early signaling: FALSE
[13:18:57.994] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:57.994] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:57.995] Chunk #1 of 1 ... DONE
[13:18:57.995] Launching 1 futures (chunks) ... DONE
[13:18:57.995] Resolving 1 futures (chunks) ...
[13:18:57.995] resolve() on list ...
[13:18:57.996]  recursive: 0
[13:18:57.996]  length: 1
[13:18:57.996] 
[13:18:57.996] resolved() for ‘SequentialFuture’ ...
[13:18:57.996] - state: ‘finished’
[13:18:57.996] - run: TRUE
[13:18:57.996] - result: ‘FutureResult’
[13:18:57.996] resolved() for ‘SequentialFuture’ ... done
[13:18:57.996] Future #1
[13:18:57.997] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:57.997] - nx: 1
[13:18:57.997] - relay: TRUE
[13:18:57.997] - stdout: TRUE
[13:18:57.997] - signal: TRUE
[13:18:57.997] - resignal: FALSE
[13:18:57.997] - force: TRUE
[13:18:57.997] - relayed: [n=1] FALSE
[13:18:57.997] - queued futures: [n=1] FALSE
[13:18:57.997]  - until=1
[13:18:57.997]  - relaying element #1
[13:18:57.998] - relayed: [n=1] TRUE
[13:18:57.998] - queued futures: [n=1] TRUE
[13:18:57.998] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:57.998]  length: 0 (resolved future 1)
[13:18:57.998] Relaying remaining futures
[13:18:57.998] signalConditionsASAP(NULL, pos=0) ...
[13:18:57.998] - nx: 1
[13:18:57.998] - relay: TRUE
[13:18:57.998] - stdout: TRUE
[13:18:57.998] - signal: TRUE
[13:18:57.998] - resignal: FALSE
[13:18:57.999] - force: TRUE
[13:18:57.999] - relayed: [n=1] TRUE
[13:18:57.999] - queued futures: [n=1] TRUE
 - flush all
[13:18:57.999] - relayed: [n=1] TRUE
[13:18:57.999] - queued futures: [n=1] TRUE
[13:18:57.999] signalConditionsASAP(NULL, pos=0) ... done
[13:18:57.999] resolve() on list ... DONE
[13:18:57.999]  - Number of value chunks collected: 1
[13:18:57.999] Resolving 1 futures (chunks) ... DONE
[13:18:57.999] Reducing values from 1 chunks ...
[13:18:58.000]  - Number of values collected after concatenation: 4
[13:18:58.000]  - Number of values expected: 4
[13:18:58.000] Reducing values from 1 chunks ... DONE
[13:18:58.000] future_lapply() ... DONE
[13:18:58.000] future_lapply() ...
[13:18:58.002] Number of chunks: 1
[13:18:58.002] getGlobalsAndPackagesXApply() ...
[13:18:58.002]  - future.globals: TRUE
[13:18:58.002] getGlobalsAndPackages() ...
[13:18:58.002] Searching for globals...
[13:18:58.006] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:18:58.006] Searching for globals ... DONE
[13:18:58.006] Resolving globals: FALSE
[13:18:58.007] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:18:58.007] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.007] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.008] - packages: [1] ‘future.apply’
[13:18:58.008] getGlobalsAndPackages() ... DONE
[13:18:58.008]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.008]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.008] Finding globals ... DONE
[13:18:58.008]  - use_args: TRUE
[13:18:58.008]  - Getting '...' globals ...
[13:18:58.008] resolve() on list ...
[13:18:58.009]  recursive: 0
[13:18:58.009]  length: 1
[13:18:58.009]  elements: ‘...’
[13:18:58.009]  length: 0 (resolved future 1)
[13:18:58.009] resolve() on list ... DONE
[13:18:58.009]    - '...' content: [n=1] ‘y’
[13:18:58.009] List of 1
[13:18:58.009]  $ ...:List of 1
[13:18:58.009]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:58.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.009]  - attr(*, "where")=List of 1
[13:18:58.009]   ..$ ...:<environment: 0x555f794ce860> 
[13:18:58.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.009]  - attr(*, "resolved")= logi TRUE
[13:18:58.009]  - attr(*, "total_size")= num NA
[13:18:58.012]  - Getting '...' globals ... DONE
[13:18:58.012] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.012] List of 8
[13:18:58.012]  $ ...future.FUN:function (x, ...)  
[13:18:58.012]  $ x_FUN        :function (x, y)  
[13:18:58.012]  $ times        : int 15
[13:18:58.012]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.012]  $ stop_if_not  :function (...)  
[13:18:58.012]  $ dim          : int [1:2] 3 5
[13:18:58.012]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:58.012]  $ ...          :List of 1
[13:18:58.012]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:58.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.012]  - attr(*, "where")=List of 8
[13:18:58.012]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.012]   ..$ ...          :<environment: 0x555f794ce860> 
[13:18:58.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.012]  - attr(*, "resolved")= logi FALSE
[13:18:58.012]  - attr(*, "total_size")= num 98600
[13:18:58.020] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.020] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.020] Number of futures (= number of chunks): 1
[13:18:58.021] Launching 1 futures (chunks) ...
[13:18:58.021] Chunk #1 of 1 ...
[13:18:58.021]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.021] getGlobalsAndPackages() ...
[13:18:58.021] Searching for globals...
[13:18:58.021] 
[13:18:58.021] Searching for globals ... DONE
[13:18:58.021] - globals: [0] <none>
[13:18:58.021] getGlobalsAndPackages() ... DONE
[13:18:58.022]    + additional globals found: [n=0] 
[13:18:58.022]    + additional namespaces needed: [n=0] 
[13:18:58.022]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.022]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[13:18:58.022]  - seeds: <none>
[13:18:58.022] getGlobalsAndPackages() ...
[13:18:58.022] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.022] Resolving globals: FALSE
[13:18:58.022] Tweak future expression to call with '...' arguments ...
[13:18:58.023] {
[13:18:58.023]     do.call(function(...) {
[13:18:58.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.023]             on.exit(options(oopts), add = TRUE)
[13:18:58.023]         }
[13:18:58.023]         {
[13:18:58.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.023]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.023]             })
[13:18:58.023]         }
[13:18:58.023]     }, args = future.call.arguments)
[13:18:58.023] }
[13:18:58.023] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.023] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.023] - packages: [1] ‘future.apply’
[13:18:58.024] getGlobalsAndPackages() ... DONE
[13:18:58.024] run() for ‘Future’ ...
[13:18:58.024] - state: ‘created’
[13:18:58.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:58.024] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:58.025]   - Field: ‘label’
[13:18:58.025]   - Field: ‘local’
[13:18:58.025]   - Field: ‘owner’
[13:18:58.025]   - Field: ‘envir’
[13:18:58.025]   - Field: ‘packages’
[13:18:58.025]   - Field: ‘gc’
[13:18:58.025]   - Field: ‘conditions’
[13:18:58.025]   - Field: ‘expr’
[13:18:58.025]   - Field: ‘uuid’
[13:18:58.026]   - Field: ‘seed’
[13:18:58.026]   - Field: ‘version’
[13:18:58.026]   - Field: ‘result’
[13:18:58.026]   - Field: ‘asynchronous’
[13:18:58.026]   - Field: ‘calls’
[13:18:58.026]   - Field: ‘globals’
[13:18:58.026]   - Field: ‘stdout’
[13:18:58.026]   - Field: ‘earlySignal’
[13:18:58.026]   - Field: ‘lazy’
[13:18:58.026]   - Field: ‘state’
[13:18:58.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:58.027] - Launch lazy future ...
[13:18:58.027] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.027] Packages needed by future strategies (n = 0): <none>
[13:18:58.027] {
[13:18:58.027]     {
[13:18:58.027]         {
[13:18:58.027]             ...future.startTime <- base::Sys.time()
[13:18:58.027]             {
[13:18:58.027]                 {
[13:18:58.027]                   {
[13:18:58.027]                     {
[13:18:58.027]                       base::local({
[13:18:58.027]                         has_future <- base::requireNamespace("future", 
[13:18:58.027]                           quietly = TRUE)
[13:18:58.027]                         if (has_future) {
[13:18:58.027]                           ns <- base::getNamespace("future")
[13:18:58.027]                           version <- ns[[".package"]][["version"]]
[13:18:58.027]                           if (is.null(version)) 
[13:18:58.027]                             version <- utils::packageVersion("future")
[13:18:58.027]                         }
[13:18:58.027]                         else {
[13:18:58.027]                           version <- NULL
[13:18:58.027]                         }
[13:18:58.027]                         if (!has_future || version < "1.8.0") {
[13:18:58.027]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.027]                             "", base::R.version$version.string), 
[13:18:58.027]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:58.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:58.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.027]                               "release", "version")], collapse = " "), 
[13:18:58.027]                             hostname = base::Sys.info()[["nodename"]])
[13:18:58.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.027]                             info)
[13:18:58.027]                           info <- base::paste(info, collapse = "; ")
[13:18:58.027]                           if (!has_future) {
[13:18:58.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.027]                               info)
[13:18:58.027]                           }
[13:18:58.027]                           else {
[13:18:58.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.027]                               info, version)
[13:18:58.027]                           }
[13:18:58.027]                           base::stop(msg)
[13:18:58.027]                         }
[13:18:58.027]                       })
[13:18:58.027]                     }
[13:18:58.027]                     base::local({
[13:18:58.027]                       for (pkg in "future.apply") {
[13:18:58.027]                         base::loadNamespace(pkg)
[13:18:58.027]                         base::library(pkg, character.only = TRUE)
[13:18:58.027]                       }
[13:18:58.027]                     })
[13:18:58.027]                   }
[13:18:58.027]                   options(future.plan = NULL)
[13:18:58.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.027]                 }
[13:18:58.027]                 ...future.workdir <- getwd()
[13:18:58.027]             }
[13:18:58.027]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.027]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.027]         }
[13:18:58.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.027]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[13:18:58.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.027]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.027]             base::names(...future.oldOptions))
[13:18:58.027]     }
[13:18:58.027]     if (FALSE) {
[13:18:58.027]     }
[13:18:58.027]     else {
[13:18:58.027]         if (TRUE) {
[13:18:58.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.027]                 open = "w")
[13:18:58.027]         }
[13:18:58.027]         else {
[13:18:58.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.027]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.027]         }
[13:18:58.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.027]             base::sink(type = "output", split = FALSE)
[13:18:58.027]             base::close(...future.stdout)
[13:18:58.027]         }, add = TRUE)
[13:18:58.027]     }
[13:18:58.027]     ...future.frame <- base::sys.nframe()
[13:18:58.027]     ...future.conditions <- base::list()
[13:18:58.027]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.027]     if (FALSE) {
[13:18:58.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.027]     }
[13:18:58.027]     ...future.result <- base::tryCatch({
[13:18:58.027]         base::withCallingHandlers({
[13:18:58.027]             ...future.value <- base::withVisible(base::local({
[13:18:58.027]                 do.call(function(...) {
[13:18:58.027]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.027]                   if (!identical(...future.globals.maxSize.org, 
[13:18:58.027]                     ...future.globals.maxSize)) {
[13:18:58.027]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.027]                     on.exit(options(oopts), add = TRUE)
[13:18:58.027]                   }
[13:18:58.027]                   {
[13:18:58.027]                     lapply(seq_along(...future.elements_ii), 
[13:18:58.027]                       FUN = function(jj) {
[13:18:58.027]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.027]                         ...future.FUN(...future.X_jj, ...)
[13:18:58.027]                       })
[13:18:58.027]                   }
[13:18:58.027]                 }, args = future.call.arguments)
[13:18:58.027]             }))
[13:18:58.027]             future::FutureResult(value = ...future.value$value, 
[13:18:58.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.027]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.027]                     ...future.globalenv.names))
[13:18:58.027]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.027]         }, condition = base::local({
[13:18:58.027]             c <- base::c
[13:18:58.027]             inherits <- base::inherits
[13:18:58.027]             invokeRestart <- base::invokeRestart
[13:18:58.027]             length <- base::length
[13:18:58.027]             list <- base::list
[13:18:58.027]             seq.int <- base::seq.int
[13:18:58.027]             signalCondition <- base::signalCondition
[13:18:58.027]             sys.calls <- base::sys.calls
[13:18:58.027]             `[[` <- base::`[[`
[13:18:58.027]             `+` <- base::`+`
[13:18:58.027]             `<<-` <- base::`<<-`
[13:18:58.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.027]                   3L)]
[13:18:58.027]             }
[13:18:58.027]             function(cond) {
[13:18:58.027]                 is_error <- inherits(cond, "error")
[13:18:58.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.027]                   NULL)
[13:18:58.027]                 if (is_error) {
[13:18:58.027]                   sessionInformation <- function() {
[13:18:58.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.027]                       search = base::search(), system = base::Sys.info())
[13:18:58.027]                   }
[13:18:58.027]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.027]                     cond$call), session = sessionInformation(), 
[13:18:58.027]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.027]                   signalCondition(cond)
[13:18:58.027]                 }
[13:18:58.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.027]                 "immediateCondition"))) {
[13:18:58.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.027]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.027]                   if (TRUE && !signal) {
[13:18:58.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.027]                     {
[13:18:58.027]                       inherits <- base::inherits
[13:18:58.027]                       invokeRestart <- base::invokeRestart
[13:18:58.027]                       is.null <- base::is.null
[13:18:58.027]                       muffled <- FALSE
[13:18:58.027]                       if (inherits(cond, "message")) {
[13:18:58.027]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.027]                         if (muffled) 
[13:18:58.027]                           invokeRestart("muffleMessage")
[13:18:58.027]                       }
[13:18:58.027]                       else if (inherits(cond, "warning")) {
[13:18:58.027]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.027]                         if (muffled) 
[13:18:58.027]                           invokeRestart("muffleWarning")
[13:18:58.027]                       }
[13:18:58.027]                       else if (inherits(cond, "condition")) {
[13:18:58.027]                         if (!is.null(pattern)) {
[13:18:58.027]                           computeRestarts <- base::computeRestarts
[13:18:58.027]                           grepl <- base::grepl
[13:18:58.027]                           restarts <- computeRestarts(cond)
[13:18:58.027]                           for (restart in restarts) {
[13:18:58.027]                             name <- restart$name
[13:18:58.027]                             if (is.null(name)) 
[13:18:58.027]                               next
[13:18:58.027]                             if (!grepl(pattern, name)) 
[13:18:58.027]                               next
[13:18:58.027]                             invokeRestart(restart)
[13:18:58.027]                             muffled <- TRUE
[13:18:58.027]                             break
[13:18:58.027]                           }
[13:18:58.027]                         }
[13:18:58.027]                       }
[13:18:58.027]                       invisible(muffled)
[13:18:58.027]                     }
[13:18:58.027]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.027]                   }
[13:18:58.027]                 }
[13:18:58.027]                 else {
[13:18:58.027]                   if (TRUE) {
[13:18:58.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.027]                     {
[13:18:58.027]                       inherits <- base::inherits
[13:18:58.027]                       invokeRestart <- base::invokeRestart
[13:18:58.027]                       is.null <- base::is.null
[13:18:58.027]                       muffled <- FALSE
[13:18:58.027]                       if (inherits(cond, "message")) {
[13:18:58.027]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.027]                         if (muffled) 
[13:18:58.027]                           invokeRestart("muffleMessage")
[13:18:58.027]                       }
[13:18:58.027]                       else if (inherits(cond, "warning")) {
[13:18:58.027]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.027]                         if (muffled) 
[13:18:58.027]                           invokeRestart("muffleWarning")
[13:18:58.027]                       }
[13:18:58.027]                       else if (inherits(cond, "condition")) {
[13:18:58.027]                         if (!is.null(pattern)) {
[13:18:58.027]                           computeRestarts <- base::computeRestarts
[13:18:58.027]                           grepl <- base::grepl
[13:18:58.027]                           restarts <- computeRestarts(cond)
[13:18:58.027]                           for (restart in restarts) {
[13:18:58.027]                             name <- restart$name
[13:18:58.027]                             if (is.null(name)) 
[13:18:58.027]                               next
[13:18:58.027]                             if (!grepl(pattern, name)) 
[13:18:58.027]                               next
[13:18:58.027]                             invokeRestart(restart)
[13:18:58.027]                             muffled <- TRUE
[13:18:58.027]                             break
[13:18:58.027]                           }
[13:18:58.027]                         }
[13:18:58.027]                       }
[13:18:58.027]                       invisible(muffled)
[13:18:58.027]                     }
[13:18:58.027]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.027]                   }
[13:18:58.027]                 }
[13:18:58.027]             }
[13:18:58.027]         }))
[13:18:58.027]     }, error = function(ex) {
[13:18:58.027]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.027]                 ...future.rng), started = ...future.startTime, 
[13:18:58.027]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.027]             version = "1.8"), class = "FutureResult")
[13:18:58.027]     }, finally = {
[13:18:58.027]         if (!identical(...future.workdir, getwd())) 
[13:18:58.027]             setwd(...future.workdir)
[13:18:58.027]         {
[13:18:58.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.027]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.027]             }
[13:18:58.027]             base::options(...future.oldOptions)
[13:18:58.027]             if (.Platform$OS.type == "windows") {
[13:18:58.027]                 old_names <- names(...future.oldEnvVars)
[13:18:58.027]                 envs <- base::Sys.getenv()
[13:18:58.027]                 names <- names(envs)
[13:18:58.027]                 common <- intersect(names, old_names)
[13:18:58.027]                 added <- setdiff(names, old_names)
[13:18:58.027]                 removed <- setdiff(old_names, names)
[13:18:58.027]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.027]                   envs[common]]
[13:18:58.027]                 NAMES <- toupper(changed)
[13:18:58.027]                 args <- list()
[13:18:58.027]                 for (kk in seq_along(NAMES)) {
[13:18:58.027]                   name <- changed[[kk]]
[13:18:58.027]                   NAME <- NAMES[[kk]]
[13:18:58.027]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.027]                     next
[13:18:58.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.027]                 }
[13:18:58.027]                 NAMES <- toupper(added)
[13:18:58.027]                 for (kk in seq_along(NAMES)) {
[13:18:58.027]                   name <- added[[kk]]
[13:18:58.027]                   NAME <- NAMES[[kk]]
[13:18:58.027]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.027]                     next
[13:18:58.027]                   args[[name]] <- ""
[13:18:58.027]                 }
[13:18:58.027]                 NAMES <- toupper(removed)
[13:18:58.027]                 for (kk in seq_along(NAMES)) {
[13:18:58.027]                   name <- removed[[kk]]
[13:18:58.027]                   NAME <- NAMES[[kk]]
[13:18:58.027]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.027]                     next
[13:18:58.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.027]                 }
[13:18:58.027]                 if (length(args) > 0) 
[13:18:58.027]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.027]             }
[13:18:58.027]             else {
[13:18:58.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.027]             }
[13:18:58.027]             {
[13:18:58.027]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.027]                   0L) {
[13:18:58.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.027]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.027]                   base::options(opts)
[13:18:58.027]                 }
[13:18:58.027]                 {
[13:18:58.027]                   {
[13:18:58.027]                     NULL
[13:18:58.027]                     RNGkind("Mersenne-Twister")
[13:18:58.027]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:58.027]                       inherits = FALSE)
[13:18:58.027]                   }
[13:18:58.027]                   options(future.plan = NULL)
[13:18:58.027]                   if (is.na(NA_character_)) 
[13:18:58.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.027]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:58.027]                   {
[13:18:58.027]                     future <- SequentialFuture(..., envir = envir)
[13:18:58.027]                     if (!future$lazy) 
[13:18:58.027]                       future <- run(future)
[13:18:58.027]                     invisible(future)
[13:18:58.027]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.027]                 }
[13:18:58.027]             }
[13:18:58.027]         }
[13:18:58.027]     })
[13:18:58.027]     if (TRUE) {
[13:18:58.027]         base::sink(type = "output", split = FALSE)
[13:18:58.027]         if (TRUE) {
[13:18:58.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.027]         }
[13:18:58.027]         else {
[13:18:58.027]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.027]         }
[13:18:58.027]         base::close(...future.stdout)
[13:18:58.027]         ...future.stdout <- NULL
[13:18:58.027]     }
[13:18:58.027]     ...future.result$conditions <- ...future.conditions
[13:18:58.027]     ...future.result$finished <- base::Sys.time()
[13:18:58.027]     ...future.result
[13:18:58.027] }
[13:18:58.029] assign_globals() ...
[13:18:58.029] List of 11
[13:18:58.029]  $ ...future.FUN            :function (x, ...)  
[13:18:58.029]  $ x_FUN                    :function (x, y)  
[13:18:58.029]  $ times                    : int 15
[13:18:58.029]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.029]  $ stop_if_not              :function (...)  
[13:18:58.029]  $ dim                      : int [1:2] 3 5
[13:18:58.029]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.029]  $ future.call.arguments    :List of 1
[13:18:58.029]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:58.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.029]  $ ...future.elements_ii    :List of 4
[13:18:58.029]   ..$ A: num 50
[13:18:58.029]   ..$ B: num 60
[13:18:58.029]   ..$ C: num 70
[13:18:58.029]   ..$ D: num 80
[13:18:58.029]  $ ...future.seeds_ii       : NULL
[13:18:58.029]  $ ...future.globals.maxSize: NULL
[13:18:58.029]  - attr(*, "resolved")= logi FALSE
[13:18:58.029]  - attr(*, "total_size")= num 98600
[13:18:58.029]  - attr(*, "where")=List of 11
[13:18:58.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.029]  - attr(*, "already-done")= logi TRUE
[13:18:58.041] - copied ‘...future.FUN’ to environment
[13:18:58.041] - reassign environment for ‘x_FUN’
[13:18:58.041] - copied ‘x_FUN’ to environment
[13:18:58.041] - copied ‘times’ to environment
[13:18:58.041] - copied ‘stopf’ to environment
[13:18:58.041] - copied ‘stop_if_not’ to environment
[13:18:58.042] - copied ‘dim’ to environment
[13:18:58.042] - copied ‘valid_types’ to environment
[13:18:58.042] - copied ‘future.call.arguments’ to environment
[13:18:58.042] - copied ‘...future.elements_ii’ to environment
[13:18:58.042] - copied ‘...future.seeds_ii’ to environment
[13:18:58.042] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.042] assign_globals() ... done
[13:18:58.043] plan(): Setting new future strategy stack:
[13:18:58.043] List of future strategies:
[13:18:58.043] 1. sequential:
[13:18:58.043]    - args: function (..., envir = parent.frame())
[13:18:58.043]    - tweaked: FALSE
[13:18:58.043]    - call: NULL
[13:18:58.043] plan(): nbrOfWorkers() = 1
[13:18:58.044] plan(): Setting new future strategy stack:
[13:18:58.044] List of future strategies:
[13:18:58.044] 1. sequential:
[13:18:58.044]    - args: function (..., envir = parent.frame())
[13:18:58.044]    - tweaked: FALSE
[13:18:58.044]    - call: plan(strategy)
[13:18:58.044] plan(): nbrOfWorkers() = 1
[13:18:58.045] SequentialFuture started (and completed)
[13:18:58.045] - Launch lazy future ... done
[13:18:58.045] run() for ‘SequentialFuture’ ... done
[13:18:58.045] Created future:
[13:18:58.045] SequentialFuture:
[13:18:58.045] Label: ‘future_vapply-1’
[13:18:58.045] Expression:
[13:18:58.045] {
[13:18:58.045]     do.call(function(...) {
[13:18:58.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.045]             on.exit(options(oopts), add = TRUE)
[13:18:58.045]         }
[13:18:58.045]         {
[13:18:58.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.045]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.045]             })
[13:18:58.045]         }
[13:18:58.045]     }, args = future.call.arguments)
[13:18:58.045] }
[13:18:58.045] Lazy evaluation: FALSE
[13:18:58.045] Asynchronous evaluation: FALSE
[13:18:58.045] Local evaluation: TRUE
[13:18:58.045] Environment: R_GlobalEnv
[13:18:58.045] Capture standard output: TRUE
[13:18:58.045] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.045] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.045] Packages: 1 packages (‘future.apply’)
[13:18:58.045] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.045] Resolved: TRUE
[13:18:58.045] Value: 1.34 KiB of class ‘list’
[13:18:58.045] Early signaling: FALSE
[13:18:58.045] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.045] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.046] Chunk #1 of 1 ... DONE
[13:18:58.046] Launching 1 futures (chunks) ... DONE
[13:18:58.046] Resolving 1 futures (chunks) ...
[13:18:58.047] resolve() on list ...
[13:18:58.047]  recursive: 0
[13:18:58.047]  length: 1
[13:18:58.047] 
[13:18:58.047] resolved() for ‘SequentialFuture’ ...
[13:18:58.047] - state: ‘finished’
[13:18:58.047] - run: TRUE
[13:18:58.047] - result: ‘FutureResult’
[13:18:58.047] resolved() for ‘SequentialFuture’ ... done
[13:18:58.047] Future #1
[13:18:58.048] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:58.048] - nx: 1
[13:18:58.048] - relay: TRUE
[13:18:58.048] - stdout: TRUE
[13:18:58.048] - signal: TRUE
[13:18:58.048] - resignal: FALSE
[13:18:58.048] - force: TRUE
[13:18:58.048] - relayed: [n=1] FALSE
[13:18:58.048] - queued futures: [n=1] FALSE
[13:18:58.048]  - until=1
[13:18:58.048]  - relaying element #1
[13:18:58.049] - relayed: [n=1] TRUE
[13:18:58.049] - queued futures: [n=1] TRUE
[13:18:58.049] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:58.049]  length: 0 (resolved future 1)
[13:18:58.049] Relaying remaining futures
[13:18:58.049] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.049] - nx: 1
[13:18:58.049] - relay: TRUE
[13:18:58.049] - stdout: TRUE
[13:18:58.049] - signal: TRUE
[13:18:58.050] - resignal: FALSE
[13:18:58.050] - force: TRUE
[13:18:58.050] - relayed: [n=1] TRUE
[13:18:58.050] - queued futures: [n=1] TRUE
 - flush all
[13:18:58.050] - relayed: [n=1] TRUE
[13:18:58.050] - queued futures: [n=1] TRUE
[13:18:58.050] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.050] resolve() on list ... DONE
[13:18:58.050]  - Number of value chunks collected: 1
[13:18:58.050] Resolving 1 futures (chunks) ... DONE
[13:18:58.051] Reducing values from 1 chunks ...
[13:18:58.051]  - Number of values collected after concatenation: 4
[13:18:58.051]  - Number of values expected: 4
[13:18:58.051] Reducing values from 1 chunks ... DONE
[13:18:58.051] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:18:58.053] future_lapply() ...
[13:18:58.055] Number of chunks: 1
[13:18:58.055] getGlobalsAndPackagesXApply() ...
[13:18:58.055]  - future.globals: TRUE
[13:18:58.055] getGlobalsAndPackages() ...
[13:18:58.055] Searching for globals...
[13:18:58.058] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:58.058] Searching for globals ... DONE
[13:18:58.058] Resolving globals: FALSE
[13:18:58.059] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:18:58.059] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.060] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.060] - packages: [1] ‘future.apply’
[13:18:58.060] getGlobalsAndPackages() ... DONE
[13:18:58.060]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.062]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.062] Finding globals ... DONE
[13:18:58.062]  - use_args: TRUE
[13:18:58.062]  - Getting '...' globals ...
[13:18:58.062] resolve() on list ...
[13:18:58.063]  recursive: 0
[13:18:58.063]  length: 1
[13:18:58.063]  elements: ‘...’
[13:18:58.063]  length: 0 (resolved future 1)
[13:18:58.063] resolve() on list ... DONE
[13:18:58.063]    - '...' content: [n=0] 
[13:18:58.063] List of 1
[13:18:58.063]  $ ...: list()
[13:18:58.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.063]  - attr(*, "where")=List of 1
[13:18:58.063]   ..$ ...:<environment: 0x555f7b4c7ba8> 
[13:18:58.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.063]  - attr(*, "resolved")= logi TRUE
[13:18:58.063]  - attr(*, "total_size")= num NA
[13:18:58.066]  - Getting '...' globals ... DONE
[13:18:58.066] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.066] List of 8
[13:18:58.066]  $ ...future.FUN:function (x, ...)  
[13:18:58.066]  $ x_FUN        :function (x)  
[13:18:58.066]  $ times        : int 1
[13:18:58.066]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.066]  $ stop_if_not  :function (...)  
[13:18:58.066]  $ dim          : NULL
[13:18:58.066]  $ valid_types  : chr "logical"
[13:18:58.066]  $ ...          : list()
[13:18:58.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.066]  - attr(*, "where")=List of 8
[13:18:58.066]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.066]   ..$ ...          :<environment: 0x555f7b4c7ba8> 
[13:18:58.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.066]  - attr(*, "resolved")= logi FALSE
[13:18:58.066]  - attr(*, "total_size")= num 94200
[13:18:58.071] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.071] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.072] Number of futures (= number of chunks): 1
[13:18:58.072] Launching 1 futures (chunks) ...
[13:18:58.072] Chunk #1 of 1 ...
[13:18:58.072]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.072] getGlobalsAndPackages() ...
[13:18:58.072] Searching for globals...
[13:18:58.072] 
[13:18:58.072] Searching for globals ... DONE
[13:18:58.073] - globals: [0] <none>
[13:18:58.073] getGlobalsAndPackages() ... DONE
[13:18:58.073]    + additional globals found: [n=0] 
[13:18:58.073]    + additional namespaces needed: [n=0] 
[13:18:58.073]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 11 * 524288000 = 5767168000 (bytes)
[13:18:58.073]  - seeds: <none>
[13:18:58.073] getGlobalsAndPackages() ...
[13:18:58.073] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.074] Resolving globals: FALSE
[13:18:58.074] Tweak future expression to call with '...' arguments ...
[13:18:58.074] {
[13:18:58.074]     do.call(function(...) {
[13:18:58.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.074]             on.exit(options(oopts), add = TRUE)
[13:18:58.074]         }
[13:18:58.074]         {
[13:18:58.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.074]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.074]             })
[13:18:58.074]         }
[13:18:58.074]     }, args = future.call.arguments)
[13:18:58.074] }
[13:18:58.074] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.074] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.075] - packages: [1] ‘future.apply’
[13:18:58.075] getGlobalsAndPackages() ... DONE
[13:18:58.075] run() for ‘Future’ ...
[13:18:58.075] - state: ‘created’
[13:18:58.075] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:58.076] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:58.076]   - Field: ‘label’
[13:18:58.076]   - Field: ‘local’
[13:18:58.076]   - Field: ‘owner’
[13:18:58.076]   - Field: ‘envir’
[13:18:58.076]   - Field: ‘packages’
[13:18:58.076]   - Field: ‘gc’
[13:18:58.076]   - Field: ‘conditions’
[13:18:58.076]   - Field: ‘expr’
[13:18:58.077]   - Field: ‘uuid’
[13:18:58.077]   - Field: ‘seed’
[13:18:58.077]   - Field: ‘version’
[13:18:58.077]   - Field: ‘result’
[13:18:58.077]   - Field: ‘asynchronous’
[13:18:58.077]   - Field: ‘calls’
[13:18:58.077]   - Field: ‘globals’
[13:18:58.077]   - Field: ‘stdout’
[13:18:58.077]   - Field: ‘earlySignal’
[13:18:58.077]   - Field: ‘lazy’
[13:18:58.077]   - Field: ‘state’
[13:18:58.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:58.078] - Launch lazy future ...
[13:18:58.078] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.078] Packages needed by future strategies (n = 0): <none>
[13:18:58.078] {
[13:18:58.078]     {
[13:18:58.078]         {
[13:18:58.078]             ...future.startTime <- base::Sys.time()
[13:18:58.078]             {
[13:18:58.078]                 {
[13:18:58.078]                   {
[13:18:58.078]                     {
[13:18:58.078]                       base::local({
[13:18:58.078]                         has_future <- base::requireNamespace("future", 
[13:18:58.078]                           quietly = TRUE)
[13:18:58.078]                         if (has_future) {
[13:18:58.078]                           ns <- base::getNamespace("future")
[13:18:58.078]                           version <- ns[[".package"]][["version"]]
[13:18:58.078]                           if (is.null(version)) 
[13:18:58.078]                             version <- utils::packageVersion("future")
[13:18:58.078]                         }
[13:18:58.078]                         else {
[13:18:58.078]                           version <- NULL
[13:18:58.078]                         }
[13:18:58.078]                         if (!has_future || version < "1.8.0") {
[13:18:58.078]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.078]                             "", base::R.version$version.string), 
[13:18:58.078]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:58.078]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:58.078]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.078]                               "release", "version")], collapse = " "), 
[13:18:58.078]                             hostname = base::Sys.info()[["nodename"]])
[13:18:58.078]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.078]                             info)
[13:18:58.078]                           info <- base::paste(info, collapse = "; ")
[13:18:58.078]                           if (!has_future) {
[13:18:58.078]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.078]                               info)
[13:18:58.078]                           }
[13:18:58.078]                           else {
[13:18:58.078]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.078]                               info, version)
[13:18:58.078]                           }
[13:18:58.078]                           base::stop(msg)
[13:18:58.078]                         }
[13:18:58.078]                       })
[13:18:58.078]                     }
[13:18:58.078]                     base::local({
[13:18:58.078]                       for (pkg in "future.apply") {
[13:18:58.078]                         base::loadNamespace(pkg)
[13:18:58.078]                         base::library(pkg, character.only = TRUE)
[13:18:58.078]                       }
[13:18:58.078]                     })
[13:18:58.078]                   }
[13:18:58.078]                   options(future.plan = NULL)
[13:18:58.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.078]                 }
[13:18:58.078]                 ...future.workdir <- getwd()
[13:18:58.078]             }
[13:18:58.078]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.078]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.078]         }
[13:18:58.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.078]             future.globals.maxSize = 5767168000, future.globals.method = NULL, 
[13:18:58.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.078]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.078]             base::names(...future.oldOptions))
[13:18:58.078]     }
[13:18:58.078]     if (FALSE) {
[13:18:58.078]     }
[13:18:58.078]     else {
[13:18:58.078]         if (TRUE) {
[13:18:58.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.078]                 open = "w")
[13:18:58.078]         }
[13:18:58.078]         else {
[13:18:58.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.078]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.078]         }
[13:18:58.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.078]             base::sink(type = "output", split = FALSE)
[13:18:58.078]             base::close(...future.stdout)
[13:18:58.078]         }, add = TRUE)
[13:18:58.078]     }
[13:18:58.078]     ...future.frame <- base::sys.nframe()
[13:18:58.078]     ...future.conditions <- base::list()
[13:18:58.078]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.078]     if (FALSE) {
[13:18:58.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.078]     }
[13:18:58.078]     ...future.result <- base::tryCatch({
[13:18:58.078]         base::withCallingHandlers({
[13:18:58.078]             ...future.value <- base::withVisible(base::local({
[13:18:58.078]                 do.call(function(...) {
[13:18:58.078]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.078]                   if (!identical(...future.globals.maxSize.org, 
[13:18:58.078]                     ...future.globals.maxSize)) {
[13:18:58.078]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.078]                     on.exit(options(oopts), add = TRUE)
[13:18:58.078]                   }
[13:18:58.078]                   {
[13:18:58.078]                     lapply(seq_along(...future.elements_ii), 
[13:18:58.078]                       FUN = function(jj) {
[13:18:58.078]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.078]                         ...future.FUN(...future.X_jj, ...)
[13:18:58.078]                       })
[13:18:58.078]                   }
[13:18:58.078]                 }, args = future.call.arguments)
[13:18:58.078]             }))
[13:18:58.078]             future::FutureResult(value = ...future.value$value, 
[13:18:58.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.078]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.078]                     ...future.globalenv.names))
[13:18:58.078]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.078]         }, condition = base::local({
[13:18:58.078]             c <- base::c
[13:18:58.078]             inherits <- base::inherits
[13:18:58.078]             invokeRestart <- base::invokeRestart
[13:18:58.078]             length <- base::length
[13:18:58.078]             list <- base::list
[13:18:58.078]             seq.int <- base::seq.int
[13:18:58.078]             signalCondition <- base::signalCondition
[13:18:58.078]             sys.calls <- base::sys.calls
[13:18:58.078]             `[[` <- base::`[[`
[13:18:58.078]             `+` <- base::`+`
[13:18:58.078]             `<<-` <- base::`<<-`
[13:18:58.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.078]                   3L)]
[13:18:58.078]             }
[13:18:58.078]             function(cond) {
[13:18:58.078]                 is_error <- inherits(cond, "error")
[13:18:58.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.078]                   NULL)
[13:18:58.078]                 if (is_error) {
[13:18:58.078]                   sessionInformation <- function() {
[13:18:58.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.078]                       search = base::search(), system = base::Sys.info())
[13:18:58.078]                   }
[13:18:58.078]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.078]                     cond$call), session = sessionInformation(), 
[13:18:58.078]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.078]                   signalCondition(cond)
[13:18:58.078]                 }
[13:18:58.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.078]                 "immediateCondition"))) {
[13:18:58.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.078]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.078]                   if (TRUE && !signal) {
[13:18:58.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.078]                     {
[13:18:58.078]                       inherits <- base::inherits
[13:18:58.078]                       invokeRestart <- base::invokeRestart
[13:18:58.078]                       is.null <- base::is.null
[13:18:58.078]                       muffled <- FALSE
[13:18:58.078]                       if (inherits(cond, "message")) {
[13:18:58.078]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.078]                         if (muffled) 
[13:18:58.078]                           invokeRestart("muffleMessage")
[13:18:58.078]                       }
[13:18:58.078]                       else if (inherits(cond, "warning")) {
[13:18:58.078]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.078]                         if (muffled) 
[13:18:58.078]                           invokeRestart("muffleWarning")
[13:18:58.078]                       }
[13:18:58.078]                       else if (inherits(cond, "condition")) {
[13:18:58.078]                         if (!is.null(pattern)) {
[13:18:58.078]                           computeRestarts <- base::computeRestarts
[13:18:58.078]                           grepl <- base::grepl
[13:18:58.078]                           restarts <- computeRestarts(cond)
[13:18:58.078]                           for (restart in restarts) {
[13:18:58.078]                             name <- restart$name
[13:18:58.078]                             if (is.null(name)) 
[13:18:58.078]                               next
[13:18:58.078]                             if (!grepl(pattern, name)) 
[13:18:58.078]                               next
[13:18:58.078]                             invokeRestart(restart)
[13:18:58.078]                             muffled <- TRUE
[13:18:58.078]                             break
[13:18:58.078]                           }
[13:18:58.078]                         }
[13:18:58.078]                       }
[13:18:58.078]                       invisible(muffled)
[13:18:58.078]                     }
[13:18:58.078]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.078]                   }
[13:18:58.078]                 }
[13:18:58.078]                 else {
[13:18:58.078]                   if (TRUE) {
[13:18:58.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.078]                     {
[13:18:58.078]                       inherits <- base::inherits
[13:18:58.078]                       invokeRestart <- base::invokeRestart
[13:18:58.078]                       is.null <- base::is.null
[13:18:58.078]                       muffled <- FALSE
[13:18:58.078]                       if (inherits(cond, "message")) {
[13:18:58.078]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.078]                         if (muffled) 
[13:18:58.078]                           invokeRestart("muffleMessage")
[13:18:58.078]                       }
[13:18:58.078]                       else if (inherits(cond, "warning")) {
[13:18:58.078]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.078]                         if (muffled) 
[13:18:58.078]                           invokeRestart("muffleWarning")
[13:18:58.078]                       }
[13:18:58.078]                       else if (inherits(cond, "condition")) {
[13:18:58.078]                         if (!is.null(pattern)) {
[13:18:58.078]                           computeRestarts <- base::computeRestarts
[13:18:58.078]                           grepl <- base::grepl
[13:18:58.078]                           restarts <- computeRestarts(cond)
[13:18:58.078]                           for (restart in restarts) {
[13:18:58.078]                             name <- restart$name
[13:18:58.078]                             if (is.null(name)) 
[13:18:58.078]                               next
[13:18:58.078]                             if (!grepl(pattern, name)) 
[13:18:58.078]                               next
[13:18:58.078]                             invokeRestart(restart)
[13:18:58.078]                             muffled <- TRUE
[13:18:58.078]                             break
[13:18:58.078]                           }
[13:18:58.078]                         }
[13:18:58.078]                       }
[13:18:58.078]                       invisible(muffled)
[13:18:58.078]                     }
[13:18:58.078]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.078]                   }
[13:18:58.078]                 }
[13:18:58.078]             }
[13:18:58.078]         }))
[13:18:58.078]     }, error = function(ex) {
[13:18:58.078]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.078]                 ...future.rng), started = ...future.startTime, 
[13:18:58.078]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.078]             version = "1.8"), class = "FutureResult")
[13:18:58.078]     }, finally = {
[13:18:58.078]         if (!identical(...future.workdir, getwd())) 
[13:18:58.078]             setwd(...future.workdir)
[13:18:58.078]         {
[13:18:58.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.078]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.078]             }
[13:18:58.078]             base::options(...future.oldOptions)
[13:18:58.078]             if (.Platform$OS.type == "windows") {
[13:18:58.078]                 old_names <- names(...future.oldEnvVars)
[13:18:58.078]                 envs <- base::Sys.getenv()
[13:18:58.078]                 names <- names(envs)
[13:18:58.078]                 common <- intersect(names, old_names)
[13:18:58.078]                 added <- setdiff(names, old_names)
[13:18:58.078]                 removed <- setdiff(old_names, names)
[13:18:58.078]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.078]                   envs[common]]
[13:18:58.078]                 NAMES <- toupper(changed)
[13:18:58.078]                 args <- list()
[13:18:58.078]                 for (kk in seq_along(NAMES)) {
[13:18:58.078]                   name <- changed[[kk]]
[13:18:58.078]                   NAME <- NAMES[[kk]]
[13:18:58.078]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.078]                     next
[13:18:58.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.078]                 }
[13:18:58.078]                 NAMES <- toupper(added)
[13:18:58.078]                 for (kk in seq_along(NAMES)) {
[13:18:58.078]                   name <- added[[kk]]
[13:18:58.078]                   NAME <- NAMES[[kk]]
[13:18:58.078]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.078]                     next
[13:18:58.078]                   args[[name]] <- ""
[13:18:58.078]                 }
[13:18:58.078]                 NAMES <- toupper(removed)
[13:18:58.078]                 for (kk in seq_along(NAMES)) {
[13:18:58.078]                   name <- removed[[kk]]
[13:18:58.078]                   NAME <- NAMES[[kk]]
[13:18:58.078]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.078]                     next
[13:18:58.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.078]                 }
[13:18:58.078]                 if (length(args) > 0) 
[13:18:58.078]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.078]             }
[13:18:58.078]             else {
[13:18:58.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.078]             }
[13:18:58.078]             {
[13:18:58.078]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.078]                   0L) {
[13:18:58.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.078]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.078]                   base::options(opts)
[13:18:58.078]                 }
[13:18:58.078]                 {
[13:18:58.078]                   {
[13:18:58.078]                     NULL
[13:18:58.078]                     RNGkind("Mersenne-Twister")
[13:18:58.078]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:58.078]                       inherits = FALSE)
[13:18:58.078]                   }
[13:18:58.078]                   options(future.plan = NULL)
[13:18:58.078]                   if (is.na(NA_character_)) 
[13:18:58.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.078]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:58.078]                   {
[13:18:58.078]                     future <- SequentialFuture(..., envir = envir)
[13:18:58.078]                     if (!future$lazy) 
[13:18:58.078]                       future <- run(future)
[13:18:58.078]                     invisible(future)
[13:18:58.078]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.078]                 }
[13:18:58.078]             }
[13:18:58.078]         }
[13:18:58.078]     })
[13:18:58.078]     if (TRUE) {
[13:18:58.078]         base::sink(type = "output", split = FALSE)
[13:18:58.078]         if (TRUE) {
[13:18:58.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.078]         }
[13:18:58.078]         else {
[13:18:58.078]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.078]         }
[13:18:58.078]         base::close(...future.stdout)
[13:18:58.078]         ...future.stdout <- NULL
[13:18:58.078]     }
[13:18:58.078]     ...future.result$conditions <- ...future.conditions
[13:18:58.078]     ...future.result$finished <- base::Sys.time()
[13:18:58.078]     ...future.result
[13:18:58.078] }
[13:18:58.080] assign_globals() ...
[13:18:58.080] List of 11
[13:18:58.080]  $ ...future.FUN            :function (x, ...)  
[13:18:58.080]  $ x_FUN                    :function (x)  
[13:18:58.080]  $ times                    : int 1
[13:18:58.080]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.080]  $ stop_if_not              :function (...)  
[13:18:58.080]  $ dim                      : NULL
[13:18:58.080]  $ valid_types              : chr "logical"
[13:18:58.080]  $ future.call.arguments    : list()
[13:18:58.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.080]  $ ...future.elements_ii    :List of 11
[13:18:58.080]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[13:18:58.080]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[13:18:58.080]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[13:18:58.080]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[13:18:58.080]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[13:18:58.080]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[13:18:58.080]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[13:18:58.080]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[13:18:58.080]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[13:18:58.080]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[13:18:58.080]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[13:18:58.080]  $ ...future.seeds_ii       : NULL
[13:18:58.080]  $ ...future.globals.maxSize: NULL
[13:18:58.080]  - attr(*, "resolved")= logi FALSE
[13:18:58.080]  - attr(*, "total_size")= num 94200
[13:18:58.080]  - attr(*, "where")=List of 11
[13:18:58.080]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.080]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.080]  - attr(*, "already-done")= logi TRUE
[13:18:58.093] - copied ‘...future.FUN’ to environment
[13:18:58.093] - copied ‘x_FUN’ to environment
[13:18:58.093] - copied ‘times’ to environment
[13:18:58.093] - copied ‘stopf’ to environment
[13:18:58.094] - copied ‘stop_if_not’ to environment
[13:18:58.094] - copied ‘dim’ to environment
[13:18:58.094] - copied ‘valid_types’ to environment
[13:18:58.094] - copied ‘future.call.arguments’ to environment
[13:18:58.094] - copied ‘...future.elements_ii’ to environment
[13:18:58.094] - copied ‘...future.seeds_ii’ to environment
[13:18:58.094] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.094] assign_globals() ... done
[13:18:58.095] plan(): Setting new future strategy stack:
[13:18:58.095] List of future strategies:
[13:18:58.095] 1. sequential:
[13:18:58.095]    - args: function (..., envir = parent.frame())
[13:18:58.095]    - tweaked: FALSE
[13:18:58.095]    - call: NULL
[13:18:58.095] plan(): nbrOfWorkers() = 1
[13:18:58.096] plan(): Setting new future strategy stack:
[13:18:58.096] List of future strategies:
[13:18:58.096] 1. sequential:
[13:18:58.096]    - args: function (..., envir = parent.frame())
[13:18:58.096]    - tweaked: FALSE
[13:18:58.096]    - call: plan(strategy)
[13:18:58.096] plan(): nbrOfWorkers() = 1
[13:18:58.097] SequentialFuture started (and completed)
[13:18:58.097] - Launch lazy future ... done
[13:18:58.097] run() for ‘SequentialFuture’ ... done
[13:18:58.097] Created future:
[13:18:58.097] SequentialFuture:
[13:18:58.097] Label: ‘future_vapply-1’
[13:18:58.097] Expression:
[13:18:58.097] {
[13:18:58.097]     do.call(function(...) {
[13:18:58.097]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.097]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.097]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.097]             on.exit(options(oopts), add = TRUE)
[13:18:58.097]         }
[13:18:58.097]         {
[13:18:58.097]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.097]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.097]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.097]             })
[13:18:58.097]         }
[13:18:58.097]     }, args = future.call.arguments)
[13:18:58.097] }
[13:18:58.097] Lazy evaluation: FALSE
[13:18:58.097] Asynchronous evaluation: FALSE
[13:18:58.097] Local evaluation: TRUE
[13:18:58.097] Environment: R_GlobalEnv
[13:18:58.097] Capture standard output: TRUE
[13:18:58.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.097] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.097] Packages: 1 packages (‘future.apply’)
[13:18:58.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.097] Resolved: TRUE
[13:18:58.097] Value: 616 bytes of class ‘list’
[13:18:58.097] Early signaling: FALSE
[13:18:58.097] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.097] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.098] Chunk #1 of 1 ... DONE
[13:18:58.098] Launching 1 futures (chunks) ... DONE
[13:18:58.098] Resolving 1 futures (chunks) ...
[13:18:58.099] resolve() on list ...
[13:18:58.099]  recursive: 0
[13:18:58.099]  length: 1
[13:18:58.099] 
[13:18:58.099] resolved() for ‘SequentialFuture’ ...
[13:18:58.099] - state: ‘finished’
[13:18:58.099] - run: TRUE
[13:18:58.099] - result: ‘FutureResult’
[13:18:58.099] resolved() for ‘SequentialFuture’ ... done
[13:18:58.099] Future #1
[13:18:58.100] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:58.100] - nx: 1
[13:18:58.100] - relay: TRUE
[13:18:58.100] - stdout: TRUE
[13:18:58.100] - signal: TRUE
[13:18:58.100] - resignal: FALSE
[13:18:58.100] - force: TRUE
[13:18:58.100] - relayed: [n=1] FALSE
[13:18:58.100] - queued futures: [n=1] FALSE
[13:18:58.100]  - until=1
[13:18:58.100]  - relaying element #1
[13:18:58.101] - relayed: [n=1] TRUE
[13:18:58.101] - queued futures: [n=1] TRUE
[13:18:58.101] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:58.101]  length: 0 (resolved future 1)
[13:18:58.101] Relaying remaining futures
[13:18:58.101] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.101] - nx: 1
[13:18:58.101] - relay: TRUE
[13:18:58.101] - stdout: TRUE
[13:18:58.101] - signal: TRUE
[13:18:58.102] - resignal: FALSE
[13:18:58.102] - force: TRUE
[13:18:58.102] - relayed: [n=1] TRUE
[13:18:58.102] - queued futures: [n=1] TRUE
 - flush all
[13:18:58.102] - relayed: [n=1] TRUE
[13:18:58.102] - queued futures: [n=1] TRUE
[13:18:58.102] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.102] resolve() on list ... DONE
[13:18:58.102]  - Number of value chunks collected: 1
[13:18:58.102] Resolving 1 futures (chunks) ... DONE
[13:18:58.103] Reducing values from 1 chunks ...
[13:18:58.103]  - Number of values collected after concatenation: 11
[13:18:58.103]  - Number of values expected: 11
[13:18:58.103] Reducing values from 1 chunks ... DONE
[13:18:58.103] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:18:58.104] future_lapply() ...
[13:18:58.108] Number of chunks: 1
[13:18:58.108] getGlobalsAndPackagesXApply() ...
[13:18:58.108]  - future.globals: TRUE
[13:18:58.108] getGlobalsAndPackages() ...
[13:18:58.108] Searching for globals...
[13:18:58.111] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:58.111] Searching for globals ... DONE
[13:18:58.112] Resolving globals: FALSE
[13:18:58.112] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:18:58.113] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.113] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.113] - packages: [1] ‘future.apply’
[13:18:58.113] getGlobalsAndPackages() ... DONE
[13:18:58.113]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.113]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.114] Finding globals ... DONE
[13:18:58.114]  - use_args: TRUE
[13:18:58.114]  - Getting '...' globals ...
[13:18:58.114] resolve() on list ...
[13:18:58.114]  recursive: 0
[13:18:58.114]  length: 1
[13:18:58.114]  elements: ‘...’
[13:18:58.114]  length: 0 (resolved future 1)
[13:18:58.114] resolve() on list ... DONE
[13:18:58.115]    - '...' content: [n=0] 
[13:18:58.115] List of 1
[13:18:58.115]  $ ...: list()
[13:18:58.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.115]  - attr(*, "where")=List of 1
[13:18:58.115]   ..$ ...:<environment: 0x555f7bc08c10> 
[13:18:58.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.115]  - attr(*, "resolved")= logi TRUE
[13:18:58.115]  - attr(*, "total_size")= num NA
[13:18:58.117]  - Getting '...' globals ... DONE
[13:18:58.117] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.118] List of 8
[13:18:58.118]  $ ...future.FUN:function (x, ...)  
[13:18:58.118]  $ x_FUN        :function (x)  
[13:18:58.118]  $ times        : int 1
[13:18:58.118]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.118]  $ stop_if_not  :function (...)  
[13:18:58.118]  $ dim          : NULL
[13:18:58.118]  $ valid_types  : chr [1:2] "logical" "integer"
[13:18:58.118]  $ ...          : list()
[13:18:58.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.118]  - attr(*, "where")=List of 8
[13:18:58.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.118]   ..$ ...          :<environment: 0x555f7bc08c10> 
[13:18:58.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.118]  - attr(*, "resolved")= logi FALSE
[13:18:58.118]  - attr(*, "total_size")= num 94264
[13:18:58.123] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.123] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.123] Number of futures (= number of chunks): 1
[13:18:58.123] Launching 1 futures (chunks) ...
[13:18:58.123] Chunk #1 of 1 ...
[13:18:58.124]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.124] getGlobalsAndPackages() ...
[13:18:58.124] Searching for globals...
[13:18:58.124] 
[13:18:58.124] Searching for globals ... DONE
[13:18:58.124] - globals: [0] <none>
[13:18:58.124] getGlobalsAndPackages() ... DONE
[13:18:58.124]    + additional globals found: [n=0] 
[13:18:58.124]    + additional namespaces needed: [n=0] 
[13:18:58.125]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.125]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:18:58.125]  - seeds: <none>
[13:18:58.125] getGlobalsAndPackages() ...
[13:18:58.125] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.125] Resolving globals: FALSE
[13:18:58.125] Tweak future expression to call with '...' arguments ...
[13:18:58.125] {
[13:18:58.125]     do.call(function(...) {
[13:18:58.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.125]             on.exit(options(oopts), add = TRUE)
[13:18:58.125]         }
[13:18:58.125]         {
[13:18:58.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.125]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.125]             })
[13:18:58.125]         }
[13:18:58.125]     }, args = future.call.arguments)
[13:18:58.125] }
[13:18:58.126] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.128] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.128] - packages: [1] ‘future.apply’
[13:18:58.128] getGlobalsAndPackages() ... DONE
[13:18:58.128] run() for ‘Future’ ...
[13:18:58.128] - state: ‘created’
[13:18:58.129] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:58.129] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.129] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:58.129]   - Field: ‘label’
[13:18:58.129]   - Field: ‘local’
[13:18:58.129]   - Field: ‘owner’
[13:18:58.130]   - Field: ‘envir’
[13:18:58.130]   - Field: ‘packages’
[13:18:58.130]   - Field: ‘gc’
[13:18:58.130]   - Field: ‘conditions’
[13:18:58.130]   - Field: ‘expr’
[13:18:58.130]   - Field: ‘uuid’
[13:18:58.130]   - Field: ‘seed’
[13:18:58.130]   - Field: ‘version’
[13:18:58.130]   - Field: ‘result’
[13:18:58.130]   - Field: ‘asynchronous’
[13:18:58.130]   - Field: ‘calls’
[13:18:58.131]   - Field: ‘globals’
[13:18:58.131]   - Field: ‘stdout’
[13:18:58.131]   - Field: ‘earlySignal’
[13:18:58.131]   - Field: ‘lazy’
[13:18:58.131]   - Field: ‘state’
[13:18:58.131] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:58.131] - Launch lazy future ...
[13:18:58.131] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.131] Packages needed by future strategies (n = 0): <none>
[13:18:58.132] {
[13:18:58.132]     {
[13:18:58.132]         {
[13:18:58.132]             ...future.startTime <- base::Sys.time()
[13:18:58.132]             {
[13:18:58.132]                 {
[13:18:58.132]                   {
[13:18:58.132]                     {
[13:18:58.132]                       base::local({
[13:18:58.132]                         has_future <- base::requireNamespace("future", 
[13:18:58.132]                           quietly = TRUE)
[13:18:58.132]                         if (has_future) {
[13:18:58.132]                           ns <- base::getNamespace("future")
[13:18:58.132]                           version <- ns[[".package"]][["version"]]
[13:18:58.132]                           if (is.null(version)) 
[13:18:58.132]                             version <- utils::packageVersion("future")
[13:18:58.132]                         }
[13:18:58.132]                         else {
[13:18:58.132]                           version <- NULL
[13:18:58.132]                         }
[13:18:58.132]                         if (!has_future || version < "1.8.0") {
[13:18:58.132]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.132]                             "", base::R.version$version.string), 
[13:18:58.132]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:58.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:58.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.132]                               "release", "version")], collapse = " "), 
[13:18:58.132]                             hostname = base::Sys.info()[["nodename"]])
[13:18:58.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.132]                             info)
[13:18:58.132]                           info <- base::paste(info, collapse = "; ")
[13:18:58.132]                           if (!has_future) {
[13:18:58.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.132]                               info)
[13:18:58.132]                           }
[13:18:58.132]                           else {
[13:18:58.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.132]                               info, version)
[13:18:58.132]                           }
[13:18:58.132]                           base::stop(msg)
[13:18:58.132]                         }
[13:18:58.132]                       })
[13:18:58.132]                     }
[13:18:58.132]                     base::local({
[13:18:58.132]                       for (pkg in "future.apply") {
[13:18:58.132]                         base::loadNamespace(pkg)
[13:18:58.132]                         base::library(pkg, character.only = TRUE)
[13:18:58.132]                       }
[13:18:58.132]                     })
[13:18:58.132]                   }
[13:18:58.132]                   options(future.plan = NULL)
[13:18:58.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.132]                 }
[13:18:58.132]                 ...future.workdir <- getwd()
[13:18:58.132]             }
[13:18:58.132]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.132]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.132]         }
[13:18:58.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.132]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:18:58.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.132]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.132]             base::names(...future.oldOptions))
[13:18:58.132]     }
[13:18:58.132]     if (FALSE) {
[13:18:58.132]     }
[13:18:58.132]     else {
[13:18:58.132]         if (TRUE) {
[13:18:58.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.132]                 open = "w")
[13:18:58.132]         }
[13:18:58.132]         else {
[13:18:58.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.132]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.132]         }
[13:18:58.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.132]             base::sink(type = "output", split = FALSE)
[13:18:58.132]             base::close(...future.stdout)
[13:18:58.132]         }, add = TRUE)
[13:18:58.132]     }
[13:18:58.132]     ...future.frame <- base::sys.nframe()
[13:18:58.132]     ...future.conditions <- base::list()
[13:18:58.132]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.132]     if (FALSE) {
[13:18:58.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.132]     }
[13:18:58.132]     ...future.result <- base::tryCatch({
[13:18:58.132]         base::withCallingHandlers({
[13:18:58.132]             ...future.value <- base::withVisible(base::local({
[13:18:58.132]                 do.call(function(...) {
[13:18:58.132]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.132]                   if (!identical(...future.globals.maxSize.org, 
[13:18:58.132]                     ...future.globals.maxSize)) {
[13:18:58.132]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.132]                     on.exit(options(oopts), add = TRUE)
[13:18:58.132]                   }
[13:18:58.132]                   {
[13:18:58.132]                     lapply(seq_along(...future.elements_ii), 
[13:18:58.132]                       FUN = function(jj) {
[13:18:58.132]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.132]                         ...future.FUN(...future.X_jj, ...)
[13:18:58.132]                       })
[13:18:58.132]                   }
[13:18:58.132]                 }, args = future.call.arguments)
[13:18:58.132]             }))
[13:18:58.132]             future::FutureResult(value = ...future.value$value, 
[13:18:58.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.132]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.132]                     ...future.globalenv.names))
[13:18:58.132]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.132]         }, condition = base::local({
[13:18:58.132]             c <- base::c
[13:18:58.132]             inherits <- base::inherits
[13:18:58.132]             invokeRestart <- base::invokeRestart
[13:18:58.132]             length <- base::length
[13:18:58.132]             list <- base::list
[13:18:58.132]             seq.int <- base::seq.int
[13:18:58.132]             signalCondition <- base::signalCondition
[13:18:58.132]             sys.calls <- base::sys.calls
[13:18:58.132]             `[[` <- base::`[[`
[13:18:58.132]             `+` <- base::`+`
[13:18:58.132]             `<<-` <- base::`<<-`
[13:18:58.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.132]                   3L)]
[13:18:58.132]             }
[13:18:58.132]             function(cond) {
[13:18:58.132]                 is_error <- inherits(cond, "error")
[13:18:58.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.132]                   NULL)
[13:18:58.132]                 if (is_error) {
[13:18:58.132]                   sessionInformation <- function() {
[13:18:58.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.132]                       search = base::search(), system = base::Sys.info())
[13:18:58.132]                   }
[13:18:58.132]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.132]                     cond$call), session = sessionInformation(), 
[13:18:58.132]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.132]                   signalCondition(cond)
[13:18:58.132]                 }
[13:18:58.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.132]                 "immediateCondition"))) {
[13:18:58.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.132]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.132]                   if (TRUE && !signal) {
[13:18:58.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.132]                     {
[13:18:58.132]                       inherits <- base::inherits
[13:18:58.132]                       invokeRestart <- base::invokeRestart
[13:18:58.132]                       is.null <- base::is.null
[13:18:58.132]                       muffled <- FALSE
[13:18:58.132]                       if (inherits(cond, "message")) {
[13:18:58.132]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.132]                         if (muffled) 
[13:18:58.132]                           invokeRestart("muffleMessage")
[13:18:58.132]                       }
[13:18:58.132]                       else if (inherits(cond, "warning")) {
[13:18:58.132]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.132]                         if (muffled) 
[13:18:58.132]                           invokeRestart("muffleWarning")
[13:18:58.132]                       }
[13:18:58.132]                       else if (inherits(cond, "condition")) {
[13:18:58.132]                         if (!is.null(pattern)) {
[13:18:58.132]                           computeRestarts <- base::computeRestarts
[13:18:58.132]                           grepl <- base::grepl
[13:18:58.132]                           restarts <- computeRestarts(cond)
[13:18:58.132]                           for (restart in restarts) {
[13:18:58.132]                             name <- restart$name
[13:18:58.132]                             if (is.null(name)) 
[13:18:58.132]                               next
[13:18:58.132]                             if (!grepl(pattern, name)) 
[13:18:58.132]                               next
[13:18:58.132]                             invokeRestart(restart)
[13:18:58.132]                             muffled <- TRUE
[13:18:58.132]                             break
[13:18:58.132]                           }
[13:18:58.132]                         }
[13:18:58.132]                       }
[13:18:58.132]                       invisible(muffled)
[13:18:58.132]                     }
[13:18:58.132]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.132]                   }
[13:18:58.132]                 }
[13:18:58.132]                 else {
[13:18:58.132]                   if (TRUE) {
[13:18:58.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.132]                     {
[13:18:58.132]                       inherits <- base::inherits
[13:18:58.132]                       invokeRestart <- base::invokeRestart
[13:18:58.132]                       is.null <- base::is.null
[13:18:58.132]                       muffled <- FALSE
[13:18:58.132]                       if (inherits(cond, "message")) {
[13:18:58.132]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.132]                         if (muffled) 
[13:18:58.132]                           invokeRestart("muffleMessage")
[13:18:58.132]                       }
[13:18:58.132]                       else if (inherits(cond, "warning")) {
[13:18:58.132]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.132]                         if (muffled) 
[13:18:58.132]                           invokeRestart("muffleWarning")
[13:18:58.132]                       }
[13:18:58.132]                       else if (inherits(cond, "condition")) {
[13:18:58.132]                         if (!is.null(pattern)) {
[13:18:58.132]                           computeRestarts <- base::computeRestarts
[13:18:58.132]                           grepl <- base::grepl
[13:18:58.132]                           restarts <- computeRestarts(cond)
[13:18:58.132]                           for (restart in restarts) {
[13:18:58.132]                             name <- restart$name
[13:18:58.132]                             if (is.null(name)) 
[13:18:58.132]                               next
[13:18:58.132]                             if (!grepl(pattern, name)) 
[13:18:58.132]                               next
[13:18:58.132]                             invokeRestart(restart)
[13:18:58.132]                             muffled <- TRUE
[13:18:58.132]                             break
[13:18:58.132]                           }
[13:18:58.132]                         }
[13:18:58.132]                       }
[13:18:58.132]                       invisible(muffled)
[13:18:58.132]                     }
[13:18:58.132]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.132]                   }
[13:18:58.132]                 }
[13:18:58.132]             }
[13:18:58.132]         }))
[13:18:58.132]     }, error = function(ex) {
[13:18:58.132]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.132]                 ...future.rng), started = ...future.startTime, 
[13:18:58.132]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.132]             version = "1.8"), class = "FutureResult")
[13:18:58.132]     }, finally = {
[13:18:58.132]         if (!identical(...future.workdir, getwd())) 
[13:18:58.132]             setwd(...future.workdir)
[13:18:58.132]         {
[13:18:58.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.132]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.132]             }
[13:18:58.132]             base::options(...future.oldOptions)
[13:18:58.132]             if (.Platform$OS.type == "windows") {
[13:18:58.132]                 old_names <- names(...future.oldEnvVars)
[13:18:58.132]                 envs <- base::Sys.getenv()
[13:18:58.132]                 names <- names(envs)
[13:18:58.132]                 common <- intersect(names, old_names)
[13:18:58.132]                 added <- setdiff(names, old_names)
[13:18:58.132]                 removed <- setdiff(old_names, names)
[13:18:58.132]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.132]                   envs[common]]
[13:18:58.132]                 NAMES <- toupper(changed)
[13:18:58.132]                 args <- list()
[13:18:58.132]                 for (kk in seq_along(NAMES)) {
[13:18:58.132]                   name <- changed[[kk]]
[13:18:58.132]                   NAME <- NAMES[[kk]]
[13:18:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.132]                     next
[13:18:58.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.132]                 }
[13:18:58.132]                 NAMES <- toupper(added)
[13:18:58.132]                 for (kk in seq_along(NAMES)) {
[13:18:58.132]                   name <- added[[kk]]
[13:18:58.132]                   NAME <- NAMES[[kk]]
[13:18:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.132]                     next
[13:18:58.132]                   args[[name]] <- ""
[13:18:58.132]                 }
[13:18:58.132]                 NAMES <- toupper(removed)
[13:18:58.132]                 for (kk in seq_along(NAMES)) {
[13:18:58.132]                   name <- removed[[kk]]
[13:18:58.132]                   NAME <- NAMES[[kk]]
[13:18:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.132]                     next
[13:18:58.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.132]                 }
[13:18:58.132]                 if (length(args) > 0) 
[13:18:58.132]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.132]             }
[13:18:58.132]             else {
[13:18:58.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.132]             }
[13:18:58.132]             {
[13:18:58.132]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.132]                   0L) {
[13:18:58.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.132]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.132]                   base::options(opts)
[13:18:58.132]                 }
[13:18:58.132]                 {
[13:18:58.132]                   {
[13:18:58.132]                     NULL
[13:18:58.132]                     RNGkind("Mersenne-Twister")
[13:18:58.132]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:58.132]                       inherits = FALSE)
[13:18:58.132]                   }
[13:18:58.132]                   options(future.plan = NULL)
[13:18:58.132]                   if (is.na(NA_character_)) 
[13:18:58.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.132]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:58.132]                   {
[13:18:58.132]                     future <- SequentialFuture(..., envir = envir)
[13:18:58.132]                     if (!future$lazy) 
[13:18:58.132]                       future <- run(future)
[13:18:58.132]                     invisible(future)
[13:18:58.132]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.132]                 }
[13:18:58.132]             }
[13:18:58.132]         }
[13:18:58.132]     })
[13:18:58.132]     if (TRUE) {
[13:18:58.132]         base::sink(type = "output", split = FALSE)
[13:18:58.132]         if (TRUE) {
[13:18:58.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.132]         }
[13:18:58.132]         else {
[13:18:58.132]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.132]         }
[13:18:58.132]         base::close(...future.stdout)
[13:18:58.132]         ...future.stdout <- NULL
[13:18:58.132]     }
[13:18:58.132]     ...future.result$conditions <- ...future.conditions
[13:18:58.132]     ...future.result$finished <- base::Sys.time()
[13:18:58.132]     ...future.result
[13:18:58.132] }
[13:18:58.134] assign_globals() ...
[13:18:58.134] List of 11
[13:18:58.134]  $ ...future.FUN            :function (x, ...)  
[13:18:58.134]  $ x_FUN                    :function (x)  
[13:18:58.134]  $ times                    : int 1
[13:18:58.134]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.134]  $ stop_if_not              :function (...)  
[13:18:58.134]  $ dim                      : NULL
[13:18:58.134]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:58.134]  $ future.call.arguments    : list()
[13:18:58.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.134]  $ ...future.elements_ii    :List of 3
[13:18:58.134]   ..$ a: num 1
[13:18:58.134]   ..$ b: num 2
[13:18:58.134]   ..$ c: num 3
[13:18:58.134]  $ ...future.seeds_ii       : NULL
[13:18:58.134]  $ ...future.globals.maxSize: NULL
[13:18:58.134]  - attr(*, "resolved")= logi FALSE
[13:18:58.134]  - attr(*, "total_size")= num 94264
[13:18:58.134]  - attr(*, "where")=List of 11
[13:18:58.134]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.134]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.134]  - attr(*, "already-done")= logi TRUE
[13:18:58.142] - copied ‘...future.FUN’ to environment
[13:18:58.142] - copied ‘x_FUN’ to environment
[13:18:58.142] - copied ‘times’ to environment
[13:18:58.142] - copied ‘stopf’ to environment
[13:18:58.142] - copied ‘stop_if_not’ to environment
[13:18:58.142] - copied ‘dim’ to environment
[13:18:58.142] - copied ‘valid_types’ to environment
[13:18:58.142] - copied ‘future.call.arguments’ to environment
[13:18:58.142] - copied ‘...future.elements_ii’ to environment
[13:18:58.143] - copied ‘...future.seeds_ii’ to environment
[13:18:58.143] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.143] assign_globals() ... done
[13:18:58.143] plan(): Setting new future strategy stack:
[13:18:58.143] List of future strategies:
[13:18:58.143] 1. sequential:
[13:18:58.143]    - args: function (..., envir = parent.frame())
[13:18:58.143]    - tweaked: FALSE
[13:18:58.143]    - call: NULL
[13:18:58.144] plan(): nbrOfWorkers() = 1
[13:18:58.144] plan(): Setting new future strategy stack:
[13:18:58.144] List of future strategies:
[13:18:58.144] 1. sequential:
[13:18:58.144]    - args: function (..., envir = parent.frame())
[13:18:58.144]    - tweaked: FALSE
[13:18:58.144]    - call: plan(strategy)
[13:18:58.145] plan(): nbrOfWorkers() = 1
[13:18:58.145] SequentialFuture started (and completed)
[13:18:58.145] - Launch lazy future ... done
[13:18:58.145] run() for ‘SequentialFuture’ ... done
[13:18:58.145] Created future:
[13:18:58.145] SequentialFuture:
[13:18:58.145] Label: ‘future_vapply-1’
[13:18:58.145] Expression:
[13:18:58.145] {
[13:18:58.145]     do.call(function(...) {
[13:18:58.145]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.145]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.145]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.145]             on.exit(options(oopts), add = TRUE)
[13:18:58.145]         }
[13:18:58.145]         {
[13:18:58.145]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.145]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.145]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.145]             })
[13:18:58.145]         }
[13:18:58.145]     }, args = future.call.arguments)
[13:18:58.145] }
[13:18:58.145] Lazy evaluation: FALSE
[13:18:58.145] Asynchronous evaluation: FALSE
[13:18:58.145] Local evaluation: TRUE
[13:18:58.145] Environment: R_GlobalEnv
[13:18:58.145] Capture standard output: TRUE
[13:18:58.145] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.145] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.145] Packages: 1 packages (‘future.apply’)
[13:18:58.145] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.145] Resolved: TRUE
[13:18:58.145] Value: 168 bytes of class ‘list’
[13:18:58.145] Early signaling: FALSE
[13:18:58.145] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.145] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.147] Chunk #1 of 1 ... DONE
[13:18:58.147] Launching 1 futures (chunks) ... DONE
[13:18:58.147] Resolving 1 futures (chunks) ...
[13:18:58.147] resolve() on list ...
[13:18:58.147]  recursive: 0
[13:18:58.147]  length: 1
[13:18:58.147] 
[13:18:58.147] resolved() for ‘SequentialFuture’ ...
[13:18:58.147] - state: ‘finished’
[13:18:58.147] - run: TRUE
[13:18:58.147] - result: ‘FutureResult’
[13:18:58.148] resolved() for ‘SequentialFuture’ ... done
[13:18:58.148] Future #1
[13:18:58.148] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:58.148] - nx: 1
[13:18:58.148] - relay: TRUE
[13:18:58.148] - stdout: TRUE
[13:18:58.148] - signal: TRUE
[13:18:58.148] - resignal: FALSE
[13:18:58.150] - force: TRUE
[13:18:58.150] - relayed: [n=1] FALSE
[13:18:58.150] - queued futures: [n=1] FALSE
[13:18:58.150]  - until=1
[13:18:58.150]  - relaying element #1
[13:18:58.151] - relayed: [n=1] TRUE
[13:18:58.151] - queued futures: [n=1] TRUE
[13:18:58.151] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:58.151]  length: 0 (resolved future 1)
[13:18:58.151] Relaying remaining futures
[13:18:58.151] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.151] - nx: 1
[13:18:58.151] - relay: TRUE
[13:18:58.151] - stdout: TRUE
[13:18:58.152] - signal: TRUE
[13:18:58.152] - resignal: FALSE
[13:18:58.152] - force: TRUE
[13:18:58.152] - relayed: [n=1] TRUE
[13:18:58.152] - queued futures: [n=1] TRUE
 - flush all
[13:18:58.152] - relayed: [n=1] TRUE
[13:18:58.152] - queued futures: [n=1] TRUE
[13:18:58.152] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.152] resolve() on list ... DONE
[13:18:58.153]  - Number of value chunks collected: 1
[13:18:58.153] Resolving 1 futures (chunks) ... DONE
[13:18:58.153] Reducing values from 1 chunks ...
[13:18:58.153]  - Number of values collected after concatenation: 3
[13:18:58.153]  - Number of values expected: 3
[13:18:58.153] Reducing values from 1 chunks ... DONE
[13:18:58.153] future_lapply() ... DONE
- exceptions ...
[13:18:58.153] future_lapply() ...
[13:18:58.155] Number of chunks: 1
[13:18:58.155] getGlobalsAndPackagesXApply() ...
[13:18:58.155]  - future.globals: TRUE
[13:18:58.155] getGlobalsAndPackages() ...
[13:18:58.156] Searching for globals...
[13:18:58.159] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:58.159] Searching for globals ... DONE
[13:18:58.159] Resolving globals: FALSE
[13:18:58.160] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:18:58.160] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.161] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.161] - packages: [1] ‘future.apply’
[13:18:58.161] getGlobalsAndPackages() ... DONE
[13:18:58.161]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.161]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.161] Finding globals ... DONE
[13:18:58.161]  - use_args: TRUE
[13:18:58.161]  - Getting '...' globals ...
[13:18:58.162] resolve() on list ...
[13:18:58.162]  recursive: 0
[13:18:58.162]  length: 1
[13:18:58.162]  elements: ‘...’
[13:18:58.162]  length: 0 (resolved future 1)
[13:18:58.162] resolve() on list ... DONE
[13:18:58.162]    - '...' content: [n=0] 
[13:18:58.162] List of 1
[13:18:58.162]  $ ...: list()
[13:18:58.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.162]  - attr(*, "where")=List of 1
[13:18:58.162]   ..$ ...:<environment: 0x555f7a12b098> 
[13:18:58.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.162]  - attr(*, "resolved")= logi TRUE
[13:18:58.162]  - attr(*, "total_size")= num NA
[13:18:58.165]  - Getting '...' globals ... DONE
[13:18:58.165] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.165] List of 8
[13:18:58.165]  $ ...future.FUN:function (x, ...)  
[13:18:58.165]  $ x_FUN        :function (x)  
[13:18:58.165]  $ times        : int 2
[13:18:58.165]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.165]  $ stop_if_not  :function (...)  
[13:18:58.165]  $ dim          : NULL
[13:18:58.165]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:58.165]  $ ...          : list()
[13:18:58.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.165]  - attr(*, "where")=List of 8
[13:18:58.165]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.165]   ..$ ...          :<environment: 0x555f7a12b098> 
[13:18:58.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.165]  - attr(*, "resolved")= logi FALSE
[13:18:58.165]  - attr(*, "total_size")= num 95128
[13:18:58.172] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.172] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.172] Number of futures (= number of chunks): 1
[13:18:58.172] Launching 1 futures (chunks) ...
[13:18:58.173] Chunk #1 of 1 ...
[13:18:58.173]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.173] getGlobalsAndPackages() ...
[13:18:58.173] Searching for globals...
[13:18:58.173] 
[13:18:58.173] Searching for globals ... DONE
[13:18:58.173] - globals: [0] <none>
[13:18:58.173] getGlobalsAndPackages() ... DONE
[13:18:58.173]    + additional globals found: [n=0] 
[13:18:58.174]    + additional namespaces needed: [n=0] 
[13:18:58.174]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.174]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:18:58.174]  - seeds: <none>
[13:18:58.174] getGlobalsAndPackages() ...
[13:18:58.174] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.174] Resolving globals: FALSE
[13:18:58.174] Tweak future expression to call with '...' arguments ...
[13:18:58.174] {
[13:18:58.174]     do.call(function(...) {
[13:18:58.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.174]             on.exit(options(oopts), add = TRUE)
[13:18:58.174]         }
[13:18:58.174]         {
[13:18:58.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.174]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.174]             })
[13:18:58.174]         }
[13:18:58.174]     }, args = future.call.arguments)
[13:18:58.174] }
[13:18:58.175] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.175] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.175] - packages: [1] ‘future.apply’
[13:18:58.175] getGlobalsAndPackages() ... DONE
[13:18:58.176] run() for ‘Future’ ...
[13:18:58.176] - state: ‘created’
[13:18:58.176] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:18:58.176] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:18:58.176]   - Field: ‘label’
[13:18:58.177]   - Field: ‘local’
[13:18:58.177]   - Field: ‘owner’
[13:18:58.177]   - Field: ‘envir’
[13:18:58.177]   - Field: ‘packages’
[13:18:58.177]   - Field: ‘gc’
[13:18:58.177]   - Field: ‘conditions’
[13:18:58.177]   - Field: ‘expr’
[13:18:58.177]   - Field: ‘uuid’
[13:18:58.177]   - Field: ‘seed’
[13:18:58.177]   - Field: ‘version’
[13:18:58.178]   - Field: ‘result’
[13:18:58.178]   - Field: ‘asynchronous’
[13:18:58.178]   - Field: ‘calls’
[13:18:58.178]   - Field: ‘globals’
[13:18:58.178]   - Field: ‘stdout’
[13:18:58.178]   - Field: ‘earlySignal’
[13:18:58.178]   - Field: ‘lazy’
[13:18:58.178]   - Field: ‘state’
[13:18:58.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:18:58.178] - Launch lazy future ...
[13:18:58.179] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.179] Packages needed by future strategies (n = 0): <none>
[13:18:58.179] {
[13:18:58.179]     {
[13:18:58.179]         {
[13:18:58.179]             ...future.startTime <- base::Sys.time()
[13:18:58.179]             {
[13:18:58.179]                 {
[13:18:58.179]                   {
[13:18:58.179]                     {
[13:18:58.179]                       base::local({
[13:18:58.179]                         has_future <- base::requireNamespace("future", 
[13:18:58.179]                           quietly = TRUE)
[13:18:58.179]                         if (has_future) {
[13:18:58.179]                           ns <- base::getNamespace("future")
[13:18:58.179]                           version <- ns[[".package"]][["version"]]
[13:18:58.179]                           if (is.null(version)) 
[13:18:58.179]                             version <- utils::packageVersion("future")
[13:18:58.179]                         }
[13:18:58.179]                         else {
[13:18:58.179]                           version <- NULL
[13:18:58.179]                         }
[13:18:58.179]                         if (!has_future || version < "1.8.0") {
[13:18:58.179]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.179]                             "", base::R.version$version.string), 
[13:18:58.179]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:58.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:58.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.179]                               "release", "version")], collapse = " "), 
[13:18:58.179]                             hostname = base::Sys.info()[["nodename"]])
[13:18:58.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.179]                             info)
[13:18:58.179]                           info <- base::paste(info, collapse = "; ")
[13:18:58.179]                           if (!has_future) {
[13:18:58.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.179]                               info)
[13:18:58.179]                           }
[13:18:58.179]                           else {
[13:18:58.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.179]                               info, version)
[13:18:58.179]                           }
[13:18:58.179]                           base::stop(msg)
[13:18:58.179]                         }
[13:18:58.179]                       })
[13:18:58.179]                     }
[13:18:58.179]                     base::local({
[13:18:58.179]                       for (pkg in "future.apply") {
[13:18:58.179]                         base::loadNamespace(pkg)
[13:18:58.179]                         base::library(pkg, character.only = TRUE)
[13:18:58.179]                       }
[13:18:58.179]                     })
[13:18:58.179]                   }
[13:18:58.179]                   options(future.plan = NULL)
[13:18:58.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.179]                 }
[13:18:58.179]                 ...future.workdir <- getwd()
[13:18:58.179]             }
[13:18:58.179]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.179]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.179]         }
[13:18:58.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.179]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:18:58.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.179]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.179]             base::names(...future.oldOptions))
[13:18:58.179]     }
[13:18:58.179]     if (FALSE) {
[13:18:58.179]     }
[13:18:58.179]     else {
[13:18:58.179]         if (TRUE) {
[13:18:58.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.179]                 open = "w")
[13:18:58.179]         }
[13:18:58.179]         else {
[13:18:58.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.179]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.179]         }
[13:18:58.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.179]             base::sink(type = "output", split = FALSE)
[13:18:58.179]             base::close(...future.stdout)
[13:18:58.179]         }, add = TRUE)
[13:18:58.179]     }
[13:18:58.179]     ...future.frame <- base::sys.nframe()
[13:18:58.179]     ...future.conditions <- base::list()
[13:18:58.179]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.179]     if (FALSE) {
[13:18:58.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.179]     }
[13:18:58.179]     ...future.result <- base::tryCatch({
[13:18:58.179]         base::withCallingHandlers({
[13:18:58.179]             ...future.value <- base::withVisible(base::local({
[13:18:58.179]                 do.call(function(...) {
[13:18:58.179]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.179]                   if (!identical(...future.globals.maxSize.org, 
[13:18:58.179]                     ...future.globals.maxSize)) {
[13:18:58.179]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.179]                     on.exit(options(oopts), add = TRUE)
[13:18:58.179]                   }
[13:18:58.179]                   {
[13:18:58.179]                     lapply(seq_along(...future.elements_ii), 
[13:18:58.179]                       FUN = function(jj) {
[13:18:58.179]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.179]                         ...future.FUN(...future.X_jj, ...)
[13:18:58.179]                       })
[13:18:58.179]                   }
[13:18:58.179]                 }, args = future.call.arguments)
[13:18:58.179]             }))
[13:18:58.179]             future::FutureResult(value = ...future.value$value, 
[13:18:58.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.179]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.179]                     ...future.globalenv.names))
[13:18:58.179]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.179]         }, condition = base::local({
[13:18:58.179]             c <- base::c
[13:18:58.179]             inherits <- base::inherits
[13:18:58.179]             invokeRestart <- base::invokeRestart
[13:18:58.179]             length <- base::length
[13:18:58.179]             list <- base::list
[13:18:58.179]             seq.int <- base::seq.int
[13:18:58.179]             signalCondition <- base::signalCondition
[13:18:58.179]             sys.calls <- base::sys.calls
[13:18:58.179]             `[[` <- base::`[[`
[13:18:58.179]             `+` <- base::`+`
[13:18:58.179]             `<<-` <- base::`<<-`
[13:18:58.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.179]                   3L)]
[13:18:58.179]             }
[13:18:58.179]             function(cond) {
[13:18:58.179]                 is_error <- inherits(cond, "error")
[13:18:58.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.179]                   NULL)
[13:18:58.179]                 if (is_error) {
[13:18:58.179]                   sessionInformation <- function() {
[13:18:58.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.179]                       search = base::search(), system = base::Sys.info())
[13:18:58.179]                   }
[13:18:58.179]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.179]                     cond$call), session = sessionInformation(), 
[13:18:58.179]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.179]                   signalCondition(cond)
[13:18:58.179]                 }
[13:18:58.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.179]                 "immediateCondition"))) {
[13:18:58.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.179]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.179]                   if (TRUE && !signal) {
[13:18:58.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.179]                     {
[13:18:58.179]                       inherits <- base::inherits
[13:18:58.179]                       invokeRestart <- base::invokeRestart
[13:18:58.179]                       is.null <- base::is.null
[13:18:58.179]                       muffled <- FALSE
[13:18:58.179]                       if (inherits(cond, "message")) {
[13:18:58.179]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.179]                         if (muffled) 
[13:18:58.179]                           invokeRestart("muffleMessage")
[13:18:58.179]                       }
[13:18:58.179]                       else if (inherits(cond, "warning")) {
[13:18:58.179]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.179]                         if (muffled) 
[13:18:58.179]                           invokeRestart("muffleWarning")
[13:18:58.179]                       }
[13:18:58.179]                       else if (inherits(cond, "condition")) {
[13:18:58.179]                         if (!is.null(pattern)) {
[13:18:58.179]                           computeRestarts <- base::computeRestarts
[13:18:58.179]                           grepl <- base::grepl
[13:18:58.179]                           restarts <- computeRestarts(cond)
[13:18:58.179]                           for (restart in restarts) {
[13:18:58.179]                             name <- restart$name
[13:18:58.179]                             if (is.null(name)) 
[13:18:58.179]                               next
[13:18:58.179]                             if (!grepl(pattern, name)) 
[13:18:58.179]                               next
[13:18:58.179]                             invokeRestart(restart)
[13:18:58.179]                             muffled <- TRUE
[13:18:58.179]                             break
[13:18:58.179]                           }
[13:18:58.179]                         }
[13:18:58.179]                       }
[13:18:58.179]                       invisible(muffled)
[13:18:58.179]                     }
[13:18:58.179]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.179]                   }
[13:18:58.179]                 }
[13:18:58.179]                 else {
[13:18:58.179]                   if (TRUE) {
[13:18:58.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.179]                     {
[13:18:58.179]                       inherits <- base::inherits
[13:18:58.179]                       invokeRestart <- base::invokeRestart
[13:18:58.179]                       is.null <- base::is.null
[13:18:58.179]                       muffled <- FALSE
[13:18:58.179]                       if (inherits(cond, "message")) {
[13:18:58.179]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.179]                         if (muffled) 
[13:18:58.179]                           invokeRestart("muffleMessage")
[13:18:58.179]                       }
[13:18:58.179]                       else if (inherits(cond, "warning")) {
[13:18:58.179]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.179]                         if (muffled) 
[13:18:58.179]                           invokeRestart("muffleWarning")
[13:18:58.179]                       }
[13:18:58.179]                       else if (inherits(cond, "condition")) {
[13:18:58.179]                         if (!is.null(pattern)) {
[13:18:58.179]                           computeRestarts <- base::computeRestarts
[13:18:58.179]                           grepl <- base::grepl
[13:18:58.179]                           restarts <- computeRestarts(cond)
[13:18:58.179]                           for (restart in restarts) {
[13:18:58.179]                             name <- restart$name
[13:18:58.179]                             if (is.null(name)) 
[13:18:58.179]                               next
[13:18:58.179]                             if (!grepl(pattern, name)) 
[13:18:58.179]                               next
[13:18:58.179]                             invokeRestart(restart)
[13:18:58.179]                             muffled <- TRUE
[13:18:58.179]                             break
[13:18:58.179]                           }
[13:18:58.179]                         }
[13:18:58.179]                       }
[13:18:58.179]                       invisible(muffled)
[13:18:58.179]                     }
[13:18:58.179]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.179]                   }
[13:18:58.179]                 }
[13:18:58.179]             }
[13:18:58.179]         }))
[13:18:58.179]     }, error = function(ex) {
[13:18:58.179]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.179]                 ...future.rng), started = ...future.startTime, 
[13:18:58.179]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.179]             version = "1.8"), class = "FutureResult")
[13:18:58.179]     }, finally = {
[13:18:58.179]         if (!identical(...future.workdir, getwd())) 
[13:18:58.179]             setwd(...future.workdir)
[13:18:58.179]         {
[13:18:58.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.179]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.179]             }
[13:18:58.179]             base::options(...future.oldOptions)
[13:18:58.179]             if (.Platform$OS.type == "windows") {
[13:18:58.179]                 old_names <- names(...future.oldEnvVars)
[13:18:58.179]                 envs <- base::Sys.getenv()
[13:18:58.179]                 names <- names(envs)
[13:18:58.179]                 common <- intersect(names, old_names)
[13:18:58.179]                 added <- setdiff(names, old_names)
[13:18:58.179]                 removed <- setdiff(old_names, names)
[13:18:58.179]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.179]                   envs[common]]
[13:18:58.179]                 NAMES <- toupper(changed)
[13:18:58.179]                 args <- list()
[13:18:58.179]                 for (kk in seq_along(NAMES)) {
[13:18:58.179]                   name <- changed[[kk]]
[13:18:58.179]                   NAME <- NAMES[[kk]]
[13:18:58.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.179]                     next
[13:18:58.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.179]                 }
[13:18:58.179]                 NAMES <- toupper(added)
[13:18:58.179]                 for (kk in seq_along(NAMES)) {
[13:18:58.179]                   name <- added[[kk]]
[13:18:58.179]                   NAME <- NAMES[[kk]]
[13:18:58.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.179]                     next
[13:18:58.179]                   args[[name]] <- ""
[13:18:58.179]                 }
[13:18:58.179]                 NAMES <- toupper(removed)
[13:18:58.179]                 for (kk in seq_along(NAMES)) {
[13:18:58.179]                   name <- removed[[kk]]
[13:18:58.179]                   NAME <- NAMES[[kk]]
[13:18:58.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.179]                     next
[13:18:58.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.179]                 }
[13:18:58.179]                 if (length(args) > 0) 
[13:18:58.179]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.179]             }
[13:18:58.179]             else {
[13:18:58.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.179]             }
[13:18:58.179]             {
[13:18:58.179]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.179]                   0L) {
[13:18:58.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.179]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.179]                   base::options(opts)
[13:18:58.179]                 }
[13:18:58.179]                 {
[13:18:58.179]                   {
[13:18:58.179]                     NULL
[13:18:58.179]                     RNGkind("Mersenne-Twister")
[13:18:58.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:18:58.179]                       inherits = FALSE)
[13:18:58.179]                   }
[13:18:58.179]                   options(future.plan = NULL)
[13:18:58.179]                   if (is.na(NA_character_)) 
[13:18:58.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.179]                   future::plan(list(function (..., envir = parent.frame()) 
[13:18:58.179]                   {
[13:18:58.179]                     future <- SequentialFuture(..., envir = envir)
[13:18:58.179]                     if (!future$lazy) 
[13:18:58.179]                       future <- run(future)
[13:18:58.179]                     invisible(future)
[13:18:58.179]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.179]                 }
[13:18:58.179]             }
[13:18:58.179]         }
[13:18:58.179]     })
[13:18:58.179]     if (TRUE) {
[13:18:58.179]         base::sink(type = "output", split = FALSE)
[13:18:58.179]         if (TRUE) {
[13:18:58.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.179]         }
[13:18:58.179]         else {
[13:18:58.179]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.179]         }
[13:18:58.179]         base::close(...future.stdout)
[13:18:58.179]         ...future.stdout <- NULL
[13:18:58.179]     }
[13:18:58.179]     ...future.result$conditions <- ...future.conditions
[13:18:58.179]     ...future.result$finished <- base::Sys.time()
[13:18:58.179]     ...future.result
[13:18:58.179] }
[13:18:58.181] assign_globals() ...
[13:18:58.181] List of 11
[13:18:58.181]  $ ...future.FUN            :function (x, ...)  
[13:18:58.181]  $ x_FUN                    :function (x)  
[13:18:58.181]  $ times                    : int 2
[13:18:58.181]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.181]  $ stop_if_not              :function (...)  
[13:18:58.181]  $ dim                      : NULL
[13:18:58.181]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.181]  $ future.call.arguments    : list()
[13:18:58.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.181]  $ ...future.elements_ii    :List of 3
[13:18:58.181]   ..$ : int 1
[13:18:58.181]   ..$ : int 2
[13:18:58.181]   ..$ : int 3
[13:18:58.181]  $ ...future.seeds_ii       : NULL
[13:18:58.181]  $ ...future.globals.maxSize: NULL
[13:18:58.181]  - attr(*, "resolved")= logi FALSE
[13:18:58.181]  - attr(*, "total_size")= num 95128
[13:18:58.181]  - attr(*, "where")=List of 11
[13:18:58.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.181]  - attr(*, "already-done")= logi TRUE
[13:18:58.189] - copied ‘...future.FUN’ to environment
[13:18:58.189] - copied ‘x_FUN’ to environment
[13:18:58.189] - copied ‘times’ to environment
[13:18:58.189] - copied ‘stopf’ to environment
[13:18:58.189] - copied ‘stop_if_not’ to environment
[13:18:58.189] - copied ‘dim’ to environment
[13:18:58.189] - copied ‘valid_types’ to environment
[13:18:58.189] - copied ‘future.call.arguments’ to environment
[13:18:58.190] - copied ‘...future.elements_ii’ to environment
[13:18:58.190] - copied ‘...future.seeds_ii’ to environment
[13:18:58.190] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.190] assign_globals() ... done
[13:18:58.192] plan(): Setting new future strategy stack:
[13:18:58.192] List of future strategies:
[13:18:58.192] 1. sequential:
[13:18:58.192]    - args: function (..., envir = parent.frame())
[13:18:58.192]    - tweaked: FALSE
[13:18:58.192]    - call: NULL
[13:18:58.192] plan(): nbrOfWorkers() = 1
[13:18:58.193] plan(): Setting new future strategy stack:
[13:18:58.193] List of future strategies:
[13:18:58.193] 1. sequential:
[13:18:58.193]    - args: function (..., envir = parent.frame())
[13:18:58.193]    - tweaked: FALSE
[13:18:58.193]    - call: plan(strategy)
[13:18:58.194] plan(): nbrOfWorkers() = 1
[13:18:58.194] SequentialFuture started (and completed)
[13:18:58.194] signalConditions() ...
[13:18:58.194]  - include = ‘immediateCondition’
[13:18:58.194]  - exclude = 
[13:18:58.194]  - resignal = FALSE
[13:18:58.194]  - Number of conditions: 1
[13:18:58.195] signalConditions() ... done
[13:18:58.195] - Launch lazy future ... done
[13:18:58.195] run() for ‘SequentialFuture’ ... done
[13:18:58.195] Created future:
[13:18:58.195] SequentialFuture:
[13:18:58.195] Label: ‘future_vapply-1’
[13:18:58.195] Expression:
[13:18:58.195] {
[13:18:58.195]     do.call(function(...) {
[13:18:58.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.195]             on.exit(options(oopts), add = TRUE)
[13:18:58.195]         }
[13:18:58.195]         {
[13:18:58.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.195]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.195]             })
[13:18:58.195]         }
[13:18:58.195]     }, args = future.call.arguments)
[13:18:58.195] }
[13:18:58.195] Lazy evaluation: FALSE
[13:18:58.195] Asynchronous evaluation: FALSE
[13:18:58.195] Local evaluation: TRUE
[13:18:58.195] Environment: R_GlobalEnv
[13:18:58.195] Capture standard output: TRUE
[13:18:58.195] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.195] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.195] Packages: 1 packages (‘future.apply’)
[13:18:58.195] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.195] Resolved: TRUE
[13:18:58.195] Value: 0 bytes of class ‘NULL’
[13:18:58.195] Conditions captured: [n=1] ‘simpleError’
[13:18:58.195] Early signaling: FALSE
[13:18:58.195] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.195] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:18:58.196] Chunk #1 of 1 ... DONE
[13:18:58.196] Launching 1 futures (chunks) ... DONE
[13:18:58.196] Resolving 1 futures (chunks) ...
[13:18:58.196] resolve() on list ...
[13:18:58.197]  recursive: 0
[13:18:58.197]  length: 1
[13:18:58.197] 
[13:18:58.197] resolved() for ‘SequentialFuture’ ...
[13:18:58.197] - state: ‘finished’
[13:18:58.197] - run: TRUE
[13:18:58.197] - result: ‘FutureResult’
[13:18:58.197] resolved() for ‘SequentialFuture’ ... done
[13:18:58.197] Future #1
[13:18:58.198] signalConditions() ...
[13:18:58.198]  - include = ‘immediateCondition’
[13:18:58.198]  - exclude = 
[13:18:58.198]  - resignal = FALSE
[13:18:58.198]  - Number of conditions: 1
[13:18:58.198] signalConditions() ... done
[13:18:58.198] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:18:58.198] - nx: 1
[13:18:58.198] - relay: TRUE
[13:18:58.198] - stdout: TRUE
[13:18:58.198] - signal: TRUE
[13:18:58.199] - resignal: FALSE
[13:18:58.199] - force: TRUE
[13:18:58.199] - relayed: [n=1] FALSE
[13:18:58.199] - queued futures: [n=1] FALSE
[13:18:58.199]  - until=1
[13:18:58.199]  - relaying element #1
[13:18:58.199] signalConditions() ...
[13:18:58.199]  - include = ‘immediateCondition’
[13:18:58.199]  - exclude = 
[13:18:58.199]  - resignal = FALSE
[13:18:58.199]  - Number of conditions: 1
[13:18:58.200] signalConditions() ... done
[13:18:58.200] signalConditions() ...
[13:18:58.200]  - include = ‘immediateCondition’
[13:18:58.200]  - exclude = 
[13:18:58.200]  - resignal = FALSE
[13:18:58.200]  - Number of conditions: 1
[13:18:58.200] signalConditions() ... done
[13:18:58.200] signalConditions() ...
[13:18:58.200]  - include = ‘condition’
[13:18:58.200]  - exclude = ‘immediateCondition’
[13:18:58.200]  - resignal = TRUE
[13:18:58.201]  - Number of conditions: 1
[13:18:58.201]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:18:58.201] signalConditions() ... done
[13:18:58.201] - relayed: [n=1] FALSE
[13:18:58.201] - queued futures: [n=1] TRUE
[13:18:58.201] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:18:58.201] plan(): Setting new future strategy stack:
[13:18:58.201] List of future strategies:
[13:18:58.201] 1. sequential:
[13:18:58.201]    - args: function (..., envir = parent.frame())
[13:18:58.201]    - tweaked: FALSE
[13:18:58.201]    - call: plan(sequential)
[13:18:58.202] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:18:58.202] plan(): Setting new future strategy stack:
[13:18:58.202] List of future strategies:
[13:18:58.202] 1. multicore:
[13:18:58.202]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.202]    - tweaked: FALSE
[13:18:58.202]    - call: plan(strategy)
[13:18:58.206] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:18:58.209] future_lapply() ...
[13:18:58.214] Number of chunks: 2
[13:18:58.214] getGlobalsAndPackagesXApply() ...
[13:18:58.214]  - future.globals: TRUE
[13:18:58.214] getGlobalsAndPackages() ...
[13:18:58.214] Searching for globals...
[13:18:58.221] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:58.221] Searching for globals ... DONE
[13:18:58.221] Resolving globals: FALSE
[13:18:58.222] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:18:58.222] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.222] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.222] - packages: [1] ‘future.apply’
[13:18:58.223] getGlobalsAndPackages() ... DONE
[13:18:58.223]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.223]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.223] Finding globals ... DONE
[13:18:58.223]  - use_args: TRUE
[13:18:58.223]  - Getting '...' globals ...
[13:18:58.223] resolve() on list ...
[13:18:58.223]  recursive: 0
[13:18:58.224]  length: 1
[13:18:58.224]  elements: ‘...’
[13:18:58.224]  length: 0 (resolved future 1)
[13:18:58.224] resolve() on list ... DONE
[13:18:58.224]    - '...' content: [n=0] 
[13:18:58.224] List of 1
[13:18:58.224]  $ ...: list()
[13:18:58.224]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.224]  - attr(*, "where")=List of 1
[13:18:58.224]   ..$ ...:<environment: 0x555f7b54c130> 
[13:18:58.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.224]  - attr(*, "resolved")= logi TRUE
[13:18:58.224]  - attr(*, "total_size")= num NA
[13:18:58.227]  - Getting '...' globals ... DONE
[13:18:58.227] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.227] List of 8
[13:18:58.227]  $ ...future.FUN:function (x, ...)  
[13:18:58.227]  $ x_FUN        :function (x)  
[13:18:58.227]  $ times        : int 1
[13:18:58.227]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.227]  $ stop_if_not  :function (...)  
[13:18:58.227]  $ dim          : NULL
[13:18:58.227]  $ valid_types  : chr "character"
[13:18:58.227]  $ ...          : list()
[13:18:58.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.227]  - attr(*, "where")=List of 8
[13:18:58.227]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.227]   ..$ ...          :<environment: 0x555f7b54c130> 
[13:18:58.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.227]  - attr(*, "resolved")= logi FALSE
[13:18:58.227]  - attr(*, "total_size")= num 94208
[13:18:58.232] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.232] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.232] Number of futures (= number of chunks): 2
[13:18:58.233] Launching 2 futures (chunks) ...
[13:18:58.233] Chunk #1 of 2 ...
[13:18:58.233]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.233] getGlobalsAndPackages() ...
[13:18:58.233] Searching for globals...
[13:18:58.233] 
[13:18:58.233] Searching for globals ... DONE
[13:18:58.234] - globals: [0] <none>
[13:18:58.234] getGlobalsAndPackages() ... DONE
[13:18:58.234]    + additional globals found: [n=0] 
[13:18:58.234]    + additional namespaces needed: [n=0] 
[13:18:58.234]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.234]  - seeds: <none>
[13:18:58.234] getGlobalsAndPackages() ...
[13:18:58.234] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.234] Resolving globals: FALSE
[13:18:58.234] Tweak future expression to call with '...' arguments ...
[13:18:58.234] {
[13:18:58.234]     do.call(function(...) {
[13:18:58.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.234]             on.exit(options(oopts), add = TRUE)
[13:18:58.234]         }
[13:18:58.234]         {
[13:18:58.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.234]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.234]             })
[13:18:58.234]         }
[13:18:58.234]     }, args = future.call.arguments)
[13:18:58.234] }
[13:18:58.235] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.235] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.235] - packages: [1] ‘future.apply’
[13:18:58.235] getGlobalsAndPackages() ... DONE
[13:18:58.236] run() for ‘Future’ ...
[13:18:58.236] - state: ‘created’
[13:18:58.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.240]   - Field: ‘label’
[13:18:58.240]   - Field: ‘local’
[13:18:58.240]   - Field: ‘owner’
[13:18:58.240]   - Field: ‘envir’
[13:18:58.240]   - Field: ‘workers’
[13:18:58.241]   - Field: ‘packages’
[13:18:58.241]   - Field: ‘gc’
[13:18:58.241]   - Field: ‘job’
[13:18:58.241]   - Field: ‘conditions’
[13:18:58.241]   - Field: ‘expr’
[13:18:58.241]   - Field: ‘uuid’
[13:18:58.241]   - Field: ‘seed’
[13:18:58.241]   - Field: ‘version’
[13:18:58.241]   - Field: ‘result’
[13:18:58.241]   - Field: ‘asynchronous’
[13:18:58.241]   - Field: ‘calls’
[13:18:58.242]   - Field: ‘globals’
[13:18:58.242]   - Field: ‘stdout’
[13:18:58.242]   - Field: ‘earlySignal’
[13:18:58.242]   - Field: ‘lazy’
[13:18:58.242]   - Field: ‘state’
[13:18:58.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.242] - Launch lazy future ...
[13:18:58.243] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.243] Packages needed by future strategies (n = 0): <none>
[13:18:58.246] {
[13:18:58.246]     {
[13:18:58.246]         {
[13:18:58.246]             ...future.startTime <- base::Sys.time()
[13:18:58.246]             {
[13:18:58.246]                 {
[13:18:58.246]                   {
[13:18:58.246]                     {
[13:18:58.246]                       {
[13:18:58.246]                         base::local({
[13:18:58.246]                           has_future <- base::requireNamespace("future", 
[13:18:58.246]                             quietly = TRUE)
[13:18:58.246]                           if (has_future) {
[13:18:58.246]                             ns <- base::getNamespace("future")
[13:18:58.246]                             version <- ns[[".package"]][["version"]]
[13:18:58.246]                             if (is.null(version)) 
[13:18:58.246]                               version <- utils::packageVersion("future")
[13:18:58.246]                           }
[13:18:58.246]                           else {
[13:18:58.246]                             version <- NULL
[13:18:58.246]                           }
[13:18:58.246]                           if (!has_future || version < "1.8.0") {
[13:18:58.246]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.246]                               "", base::R.version$version.string), 
[13:18:58.246]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.246]                                 base::R.version$platform, 8 * 
[13:18:58.246]                                   base::.Machine$sizeof.pointer), 
[13:18:58.246]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.246]                                 "release", "version")], collapse = " "), 
[13:18:58.246]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.246]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.246]                               info)
[13:18:58.246]                             info <- base::paste(info, collapse = "; ")
[13:18:58.246]                             if (!has_future) {
[13:18:58.246]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.246]                                 info)
[13:18:58.246]                             }
[13:18:58.246]                             else {
[13:18:58.246]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.246]                                 info, version)
[13:18:58.246]                             }
[13:18:58.246]                             base::stop(msg)
[13:18:58.246]                           }
[13:18:58.246]                         })
[13:18:58.246]                       }
[13:18:58.246]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.246]                       base::options(mc.cores = 1L)
[13:18:58.246]                     }
[13:18:58.246]                     base::local({
[13:18:58.246]                       for (pkg in "future.apply") {
[13:18:58.246]                         base::loadNamespace(pkg)
[13:18:58.246]                         base::library(pkg, character.only = TRUE)
[13:18:58.246]                       }
[13:18:58.246]                     })
[13:18:58.246]                   }
[13:18:58.246]                   options(future.plan = NULL)
[13:18:58.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.246]                 }
[13:18:58.246]                 ...future.workdir <- getwd()
[13:18:58.246]             }
[13:18:58.246]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.246]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.246]         }
[13:18:58.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:18:58.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.246]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.246]             base::names(...future.oldOptions))
[13:18:58.246]     }
[13:18:58.246]     if (FALSE) {
[13:18:58.246]     }
[13:18:58.246]     else {
[13:18:58.246]         if (TRUE) {
[13:18:58.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.246]                 open = "w")
[13:18:58.246]         }
[13:18:58.246]         else {
[13:18:58.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.246]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.246]         }
[13:18:58.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.246]             base::sink(type = "output", split = FALSE)
[13:18:58.246]             base::close(...future.stdout)
[13:18:58.246]         }, add = TRUE)
[13:18:58.246]     }
[13:18:58.246]     ...future.frame <- base::sys.nframe()
[13:18:58.246]     ...future.conditions <- base::list()
[13:18:58.246]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.246]     if (FALSE) {
[13:18:58.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.246]     }
[13:18:58.246]     ...future.result <- base::tryCatch({
[13:18:58.246]         base::withCallingHandlers({
[13:18:58.246]             ...future.value <- base::withVisible(base::local({
[13:18:58.246]                 withCallingHandlers({
[13:18:58.246]                   {
[13:18:58.246]                     do.call(function(...) {
[13:18:58.246]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.246]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.246]                         ...future.globals.maxSize)) {
[13:18:58.246]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.246]                         on.exit(options(oopts), add = TRUE)
[13:18:58.246]                       }
[13:18:58.246]                       {
[13:18:58.246]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.246]                           FUN = function(jj) {
[13:18:58.246]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.246]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.246]                           })
[13:18:58.246]                       }
[13:18:58.246]                     }, args = future.call.arguments)
[13:18:58.246]                   }
[13:18:58.246]                 }, immediateCondition = function(cond) {
[13:18:58.246]                   save_rds <- function (object, pathname, ...) 
[13:18:58.246]                   {
[13:18:58.246]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.246]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.246]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.246]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.246]                         fi_tmp[["mtime"]])
[13:18:58.246]                     }
[13:18:58.246]                     tryCatch({
[13:18:58.246]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.246]                     }, error = function(ex) {
[13:18:58.246]                       msg <- conditionMessage(ex)
[13:18:58.246]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.246]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.246]                         fi_tmp[["mtime"]], msg)
[13:18:58.246]                       ex$message <- msg
[13:18:58.246]                       stop(ex)
[13:18:58.246]                     })
[13:18:58.246]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.246]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.246]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.246]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.246]                       fi <- file.info(pathname)
[13:18:58.246]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.246]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.246]                         fi[["size"]], fi[["mtime"]])
[13:18:58.246]                       stop(msg)
[13:18:58.246]                     }
[13:18:58.246]                     invisible(pathname)
[13:18:58.246]                   }
[13:18:58.246]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.246]                     rootPath = tempdir()) 
[13:18:58.246]                   {
[13:18:58.246]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.246]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.246]                       tmpdir = path, fileext = ".rds")
[13:18:58.246]                     save_rds(obj, file)
[13:18:58.246]                   }
[13:18:58.246]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.246]                   {
[13:18:58.246]                     inherits <- base::inherits
[13:18:58.246]                     invokeRestart <- base::invokeRestart
[13:18:58.246]                     is.null <- base::is.null
[13:18:58.246]                     muffled <- FALSE
[13:18:58.246]                     if (inherits(cond, "message")) {
[13:18:58.246]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.246]                       if (muffled) 
[13:18:58.246]                         invokeRestart("muffleMessage")
[13:18:58.246]                     }
[13:18:58.246]                     else if (inherits(cond, "warning")) {
[13:18:58.246]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.246]                       if (muffled) 
[13:18:58.246]                         invokeRestart("muffleWarning")
[13:18:58.246]                     }
[13:18:58.246]                     else if (inherits(cond, "condition")) {
[13:18:58.246]                       if (!is.null(pattern)) {
[13:18:58.246]                         computeRestarts <- base::computeRestarts
[13:18:58.246]                         grepl <- base::grepl
[13:18:58.246]                         restarts <- computeRestarts(cond)
[13:18:58.246]                         for (restart in restarts) {
[13:18:58.246]                           name <- restart$name
[13:18:58.246]                           if (is.null(name)) 
[13:18:58.246]                             next
[13:18:58.246]                           if (!grepl(pattern, name)) 
[13:18:58.246]                             next
[13:18:58.246]                           invokeRestart(restart)
[13:18:58.246]                           muffled <- TRUE
[13:18:58.246]                           break
[13:18:58.246]                         }
[13:18:58.246]                       }
[13:18:58.246]                     }
[13:18:58.246]                     invisible(muffled)
[13:18:58.246]                   }
[13:18:58.246]                   muffleCondition(cond)
[13:18:58.246]                 })
[13:18:58.246]             }))
[13:18:58.246]             future::FutureResult(value = ...future.value$value, 
[13:18:58.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.246]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.246]                     ...future.globalenv.names))
[13:18:58.246]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.246]         }, condition = base::local({
[13:18:58.246]             c <- base::c
[13:18:58.246]             inherits <- base::inherits
[13:18:58.246]             invokeRestart <- base::invokeRestart
[13:18:58.246]             length <- base::length
[13:18:58.246]             list <- base::list
[13:18:58.246]             seq.int <- base::seq.int
[13:18:58.246]             signalCondition <- base::signalCondition
[13:18:58.246]             sys.calls <- base::sys.calls
[13:18:58.246]             `[[` <- base::`[[`
[13:18:58.246]             `+` <- base::`+`
[13:18:58.246]             `<<-` <- base::`<<-`
[13:18:58.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.246]                   3L)]
[13:18:58.246]             }
[13:18:58.246]             function(cond) {
[13:18:58.246]                 is_error <- inherits(cond, "error")
[13:18:58.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.246]                   NULL)
[13:18:58.246]                 if (is_error) {
[13:18:58.246]                   sessionInformation <- function() {
[13:18:58.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.246]                       search = base::search(), system = base::Sys.info())
[13:18:58.246]                   }
[13:18:58.246]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.246]                     cond$call), session = sessionInformation(), 
[13:18:58.246]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.246]                   signalCondition(cond)
[13:18:58.246]                 }
[13:18:58.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.246]                 "immediateCondition"))) {
[13:18:58.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.246]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.246]                   if (TRUE && !signal) {
[13:18:58.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.246]                     {
[13:18:58.246]                       inherits <- base::inherits
[13:18:58.246]                       invokeRestart <- base::invokeRestart
[13:18:58.246]                       is.null <- base::is.null
[13:18:58.246]                       muffled <- FALSE
[13:18:58.246]                       if (inherits(cond, "message")) {
[13:18:58.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.246]                         if (muffled) 
[13:18:58.246]                           invokeRestart("muffleMessage")
[13:18:58.246]                       }
[13:18:58.246]                       else if (inherits(cond, "warning")) {
[13:18:58.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.246]                         if (muffled) 
[13:18:58.246]                           invokeRestart("muffleWarning")
[13:18:58.246]                       }
[13:18:58.246]                       else if (inherits(cond, "condition")) {
[13:18:58.246]                         if (!is.null(pattern)) {
[13:18:58.246]                           computeRestarts <- base::computeRestarts
[13:18:58.246]                           grepl <- base::grepl
[13:18:58.246]                           restarts <- computeRestarts(cond)
[13:18:58.246]                           for (restart in restarts) {
[13:18:58.246]                             name <- restart$name
[13:18:58.246]                             if (is.null(name)) 
[13:18:58.246]                               next
[13:18:58.246]                             if (!grepl(pattern, name)) 
[13:18:58.246]                               next
[13:18:58.246]                             invokeRestart(restart)
[13:18:58.246]                             muffled <- TRUE
[13:18:58.246]                             break
[13:18:58.246]                           }
[13:18:58.246]                         }
[13:18:58.246]                       }
[13:18:58.246]                       invisible(muffled)
[13:18:58.246]                     }
[13:18:58.246]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.246]                   }
[13:18:58.246]                 }
[13:18:58.246]                 else {
[13:18:58.246]                   if (TRUE) {
[13:18:58.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.246]                     {
[13:18:58.246]                       inherits <- base::inherits
[13:18:58.246]                       invokeRestart <- base::invokeRestart
[13:18:58.246]                       is.null <- base::is.null
[13:18:58.246]                       muffled <- FALSE
[13:18:58.246]                       if (inherits(cond, "message")) {
[13:18:58.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.246]                         if (muffled) 
[13:18:58.246]                           invokeRestart("muffleMessage")
[13:18:58.246]                       }
[13:18:58.246]                       else if (inherits(cond, "warning")) {
[13:18:58.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.246]                         if (muffled) 
[13:18:58.246]                           invokeRestart("muffleWarning")
[13:18:58.246]                       }
[13:18:58.246]                       else if (inherits(cond, "condition")) {
[13:18:58.246]                         if (!is.null(pattern)) {
[13:18:58.246]                           computeRestarts <- base::computeRestarts
[13:18:58.246]                           grepl <- base::grepl
[13:18:58.246]                           restarts <- computeRestarts(cond)
[13:18:58.246]                           for (restart in restarts) {
[13:18:58.246]                             name <- restart$name
[13:18:58.246]                             if (is.null(name)) 
[13:18:58.246]                               next
[13:18:58.246]                             if (!grepl(pattern, name)) 
[13:18:58.246]                               next
[13:18:58.246]                             invokeRestart(restart)
[13:18:58.246]                             muffled <- TRUE
[13:18:58.246]                             break
[13:18:58.246]                           }
[13:18:58.246]                         }
[13:18:58.246]                       }
[13:18:58.246]                       invisible(muffled)
[13:18:58.246]                     }
[13:18:58.246]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.246]                   }
[13:18:58.246]                 }
[13:18:58.246]             }
[13:18:58.246]         }))
[13:18:58.246]     }, error = function(ex) {
[13:18:58.246]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.246]                 ...future.rng), started = ...future.startTime, 
[13:18:58.246]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.246]             version = "1.8"), class = "FutureResult")
[13:18:58.246]     }, finally = {
[13:18:58.246]         if (!identical(...future.workdir, getwd())) 
[13:18:58.246]             setwd(...future.workdir)
[13:18:58.246]         {
[13:18:58.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.246]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.246]             }
[13:18:58.246]             base::options(...future.oldOptions)
[13:18:58.246]             if (.Platform$OS.type == "windows") {
[13:18:58.246]                 old_names <- names(...future.oldEnvVars)
[13:18:58.246]                 envs <- base::Sys.getenv()
[13:18:58.246]                 names <- names(envs)
[13:18:58.246]                 common <- intersect(names, old_names)
[13:18:58.246]                 added <- setdiff(names, old_names)
[13:18:58.246]                 removed <- setdiff(old_names, names)
[13:18:58.246]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.246]                   envs[common]]
[13:18:58.246]                 NAMES <- toupper(changed)
[13:18:58.246]                 args <- list()
[13:18:58.246]                 for (kk in seq_along(NAMES)) {
[13:18:58.246]                   name <- changed[[kk]]
[13:18:58.246]                   NAME <- NAMES[[kk]]
[13:18:58.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.246]                     next
[13:18:58.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.246]                 }
[13:18:58.246]                 NAMES <- toupper(added)
[13:18:58.246]                 for (kk in seq_along(NAMES)) {
[13:18:58.246]                   name <- added[[kk]]
[13:18:58.246]                   NAME <- NAMES[[kk]]
[13:18:58.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.246]                     next
[13:18:58.246]                   args[[name]] <- ""
[13:18:58.246]                 }
[13:18:58.246]                 NAMES <- toupper(removed)
[13:18:58.246]                 for (kk in seq_along(NAMES)) {
[13:18:58.246]                   name <- removed[[kk]]
[13:18:58.246]                   NAME <- NAMES[[kk]]
[13:18:58.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.246]                     next
[13:18:58.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.246]                 }
[13:18:58.246]                 if (length(args) > 0) 
[13:18:58.246]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.246]             }
[13:18:58.246]             else {
[13:18:58.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.246]             }
[13:18:58.246]             {
[13:18:58.246]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.246]                   0L) {
[13:18:58.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.246]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.246]                   base::options(opts)
[13:18:58.246]                 }
[13:18:58.246]                 {
[13:18:58.246]                   {
[13:18:58.246]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.246]                     NULL
[13:18:58.246]                   }
[13:18:58.246]                   options(future.plan = NULL)
[13:18:58.246]                   if (is.na(NA_character_)) 
[13:18:58.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.246]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.246]                     envir = parent.frame()) 
[13:18:58.246]                   {
[13:18:58.246]                     default_workers <- missing(workers)
[13:18:58.246]                     if (is.function(workers)) 
[13:18:58.246]                       workers <- workers()
[13:18:58.246]                     workers <- structure(as.integer(workers), 
[13:18:58.246]                       class = class(workers))
[13:18:58.246]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.246]                       1L)
[13:18:58.246]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.246]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.246]                       if (default_workers) 
[13:18:58.246]                         supportsMulticore(warn = TRUE)
[13:18:58.246]                       return(sequential(..., envir = envir))
[13:18:58.246]                     }
[13:18:58.246]                     oopts <- options(mc.cores = workers)
[13:18:58.246]                     on.exit(options(oopts))
[13:18:58.246]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.246]                       envir = envir)
[13:18:58.246]                     if (!future$lazy) 
[13:18:58.246]                       future <- run(future)
[13:18:58.246]                     invisible(future)
[13:18:58.246]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.246]                 }
[13:18:58.246]             }
[13:18:58.246]         }
[13:18:58.246]     })
[13:18:58.246]     if (TRUE) {
[13:18:58.246]         base::sink(type = "output", split = FALSE)
[13:18:58.246]         if (TRUE) {
[13:18:58.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.246]         }
[13:18:58.246]         else {
[13:18:58.246]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.246]         }
[13:18:58.246]         base::close(...future.stdout)
[13:18:58.246]         ...future.stdout <- NULL
[13:18:58.246]     }
[13:18:58.246]     ...future.result$conditions <- ...future.conditions
[13:18:58.246]     ...future.result$finished <- base::Sys.time()
[13:18:58.246]     ...future.result
[13:18:58.246] }
[13:18:58.248] assign_globals() ...
[13:18:58.248] List of 11
[13:18:58.248]  $ ...future.FUN            :function (x, ...)  
[13:18:58.248]  $ x_FUN                    :function (x)  
[13:18:58.248]  $ times                    : int 1
[13:18:58.248]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.248]  $ stop_if_not              :function (...)  
[13:18:58.248]  $ dim                      : NULL
[13:18:58.248]  $ valid_types              : chr "character"
[13:18:58.248]  $ future.call.arguments    : list()
[13:18:58.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.248]  $ ...future.elements_ii    :List of 1
[13:18:58.248]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:18:58.248]  $ ...future.seeds_ii       : NULL
[13:18:58.248]  $ ...future.globals.maxSize: NULL
[13:18:58.248]  - attr(*, "where")=List of 11
[13:18:58.248]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.248]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.248]  - attr(*, "resolved")= logi FALSE
[13:18:58.248]  - attr(*, "total_size")= num 94208
[13:18:58.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.248]  - attr(*, "already-done")= logi TRUE
[13:18:58.256] - copied ‘...future.FUN’ to environment
[13:18:58.256] - copied ‘x_FUN’ to environment
[13:18:58.256] - copied ‘times’ to environment
[13:18:58.256] - copied ‘stopf’ to environment
[13:18:58.256] - copied ‘stop_if_not’ to environment
[13:18:58.256] - copied ‘dim’ to environment
[13:18:58.256] - copied ‘valid_types’ to environment
[13:18:58.257] - copied ‘future.call.arguments’ to environment
[13:18:58.257] - copied ‘...future.elements_ii’ to environment
[13:18:58.257] - copied ‘...future.seeds_ii’ to environment
[13:18:58.257] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.257] assign_globals() ... done
[13:18:58.257] requestCore(): workers = 2
[13:18:58.260] MulticoreFuture started
[13:18:58.261] - Launch lazy future ... done
[13:18:58.261] run() for ‘MulticoreFuture’ ... done
[13:18:58.261] Created future:
[13:18:58.262] plan(): Setting new future strategy stack:
[13:18:58.262] List of future strategies:
[13:18:58.262] 1. sequential:
[13:18:58.262]    - args: function (..., envir = parent.frame())
[13:18:58.262]    - tweaked: FALSE
[13:18:58.262]    - call: NULL
[13:18:58.263] plan(): nbrOfWorkers() = 1
[13:18:58.265] plan(): Setting new future strategy stack:
[13:18:58.265] List of future strategies:
[13:18:58.265] 1. multicore:
[13:18:58.265]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.265]    - tweaked: FALSE
[13:18:58.265]    - call: plan(strategy)
[13:18:58.270] plan(): nbrOfWorkers() = 2
[13:18:58.262] MulticoreFuture:
[13:18:58.262] Label: ‘future_vapply-1’
[13:18:58.262] Expression:
[13:18:58.262] {
[13:18:58.262]     do.call(function(...) {
[13:18:58.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.262]             on.exit(options(oopts), add = TRUE)
[13:18:58.262]         }
[13:18:58.262]         {
[13:18:58.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.262]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.262]             })
[13:18:58.262]         }
[13:18:58.262]     }, args = future.call.arguments)
[13:18:58.262] }
[13:18:58.262] Lazy evaluation: FALSE
[13:18:58.262] Asynchronous evaluation: TRUE
[13:18:58.262] Local evaluation: TRUE
[13:18:58.262] Environment: R_GlobalEnv
[13:18:58.262] Capture standard output: TRUE
[13:18:58.262] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.262] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.262] Packages: 1 packages (‘future.apply’)
[13:18:58.262] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.262] Resolved: TRUE
[13:18:58.262] Value: <not collected>
[13:18:58.262] Conditions captured: <none>
[13:18:58.262] Early signaling: FALSE
[13:18:58.262] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.262] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.272] Chunk #1 of 2 ... DONE
[13:18:58.272] Chunk #2 of 2 ...
[13:18:58.272]  - Finding globals in 'X' for chunk #2 ...
[13:18:58.272] getGlobalsAndPackages() ...
[13:18:58.273] Searching for globals...
[13:18:58.273] 
[13:18:58.273] Searching for globals ... DONE
[13:18:58.273] - globals: [0] <none>
[13:18:58.274] getGlobalsAndPackages() ... DONE
[13:18:58.274]    + additional globals found: [n=0] 
[13:18:58.274]    + additional namespaces needed: [n=0] 
[13:18:58.274]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:58.274]  - seeds: <none>
[13:18:58.274] getGlobalsAndPackages() ...
[13:18:58.275] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.275] Resolving globals: FALSE
[13:18:58.275] Tweak future expression to call with '...' arguments ...
[13:18:58.275] {
[13:18:58.275]     do.call(function(...) {
[13:18:58.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.275]             on.exit(options(oopts), add = TRUE)
[13:18:58.275]         }
[13:18:58.275]         {
[13:18:58.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.275]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.275]             })
[13:18:58.275]         }
[13:18:58.275]     }, args = future.call.arguments)
[13:18:58.275] }
[13:18:58.276] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.276] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.277] - packages: [1] ‘future.apply’
[13:18:58.277] getGlobalsAndPackages() ... DONE
[13:18:58.277] run() for ‘Future’ ...
[13:18:58.278] - state: ‘created’
[13:18:58.278] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.283]   - Field: ‘label’
[13:18:58.283]   - Field: ‘local’
[13:18:58.283]   - Field: ‘owner’
[13:18:58.283]   - Field: ‘envir’
[13:18:58.283]   - Field: ‘workers’
[13:18:58.283]   - Field: ‘packages’
[13:18:58.284]   - Field: ‘gc’
[13:18:58.284]   - Field: ‘job’
[13:18:58.284]   - Field: ‘conditions’
[13:18:58.284]   - Field: ‘expr’
[13:18:58.284]   - Field: ‘uuid’
[13:18:58.284]   - Field: ‘seed’
[13:18:58.284]   - Field: ‘version’
[13:18:58.285]   - Field: ‘result’
[13:18:58.285]   - Field: ‘asynchronous’
[13:18:58.285]   - Field: ‘calls’
[13:18:58.285]   - Field: ‘globals’
[13:18:58.285]   - Field: ‘stdout’
[13:18:58.285]   - Field: ‘earlySignal’
[13:18:58.285]   - Field: ‘lazy’
[13:18:58.286]   - Field: ‘state’
[13:18:58.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.286] - Launch lazy future ...
[13:18:58.286] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.286] Packages needed by future strategies (n = 0): <none>
[13:18:58.287] {
[13:18:58.287]     {
[13:18:58.287]         {
[13:18:58.287]             ...future.startTime <- base::Sys.time()
[13:18:58.287]             {
[13:18:58.287]                 {
[13:18:58.287]                   {
[13:18:58.287]                     {
[13:18:58.287]                       {
[13:18:58.287]                         base::local({
[13:18:58.287]                           has_future <- base::requireNamespace("future", 
[13:18:58.287]                             quietly = TRUE)
[13:18:58.287]                           if (has_future) {
[13:18:58.287]                             ns <- base::getNamespace("future")
[13:18:58.287]                             version <- ns[[".package"]][["version"]]
[13:18:58.287]                             if (is.null(version)) 
[13:18:58.287]                               version <- utils::packageVersion("future")
[13:18:58.287]                           }
[13:18:58.287]                           else {
[13:18:58.287]                             version <- NULL
[13:18:58.287]                           }
[13:18:58.287]                           if (!has_future || version < "1.8.0") {
[13:18:58.287]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.287]                               "", base::R.version$version.string), 
[13:18:58.287]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.287]                                 base::R.version$platform, 8 * 
[13:18:58.287]                                   base::.Machine$sizeof.pointer), 
[13:18:58.287]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.287]                                 "release", "version")], collapse = " "), 
[13:18:58.287]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.287]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.287]                               info)
[13:18:58.287]                             info <- base::paste(info, collapse = "; ")
[13:18:58.287]                             if (!has_future) {
[13:18:58.287]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.287]                                 info)
[13:18:58.287]                             }
[13:18:58.287]                             else {
[13:18:58.287]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.287]                                 info, version)
[13:18:58.287]                             }
[13:18:58.287]                             base::stop(msg)
[13:18:58.287]                           }
[13:18:58.287]                         })
[13:18:58.287]                       }
[13:18:58.287]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.287]                       base::options(mc.cores = 1L)
[13:18:58.287]                     }
[13:18:58.287]                     base::local({
[13:18:58.287]                       for (pkg in "future.apply") {
[13:18:58.287]                         base::loadNamespace(pkg)
[13:18:58.287]                         base::library(pkg, character.only = TRUE)
[13:18:58.287]                       }
[13:18:58.287]                     })
[13:18:58.287]                   }
[13:18:58.287]                   options(future.plan = NULL)
[13:18:58.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.287]                 }
[13:18:58.287]                 ...future.workdir <- getwd()
[13:18:58.287]             }
[13:18:58.287]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.287]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.287]         }
[13:18:58.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:18:58.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.287]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.287]             base::names(...future.oldOptions))
[13:18:58.287]     }
[13:18:58.287]     if (FALSE) {
[13:18:58.287]     }
[13:18:58.287]     else {
[13:18:58.287]         if (TRUE) {
[13:18:58.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.287]                 open = "w")
[13:18:58.287]         }
[13:18:58.287]         else {
[13:18:58.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.287]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.287]         }
[13:18:58.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.287]             base::sink(type = "output", split = FALSE)
[13:18:58.287]             base::close(...future.stdout)
[13:18:58.287]         }, add = TRUE)
[13:18:58.287]     }
[13:18:58.287]     ...future.frame <- base::sys.nframe()
[13:18:58.287]     ...future.conditions <- base::list()
[13:18:58.287]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.287]     if (FALSE) {
[13:18:58.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.287]     }
[13:18:58.287]     ...future.result <- base::tryCatch({
[13:18:58.287]         base::withCallingHandlers({
[13:18:58.287]             ...future.value <- base::withVisible(base::local({
[13:18:58.287]                 withCallingHandlers({
[13:18:58.287]                   {
[13:18:58.287]                     do.call(function(...) {
[13:18:58.287]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.287]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.287]                         ...future.globals.maxSize)) {
[13:18:58.287]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.287]                         on.exit(options(oopts), add = TRUE)
[13:18:58.287]                       }
[13:18:58.287]                       {
[13:18:58.287]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.287]                           FUN = function(jj) {
[13:18:58.287]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.287]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.287]                           })
[13:18:58.287]                       }
[13:18:58.287]                     }, args = future.call.arguments)
[13:18:58.287]                   }
[13:18:58.287]                 }, immediateCondition = function(cond) {
[13:18:58.287]                   save_rds <- function (object, pathname, ...) 
[13:18:58.287]                   {
[13:18:58.287]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.287]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.287]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.287]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.287]                         fi_tmp[["mtime"]])
[13:18:58.287]                     }
[13:18:58.287]                     tryCatch({
[13:18:58.287]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.287]                     }, error = function(ex) {
[13:18:58.287]                       msg <- conditionMessage(ex)
[13:18:58.287]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.287]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.287]                         fi_tmp[["mtime"]], msg)
[13:18:58.287]                       ex$message <- msg
[13:18:58.287]                       stop(ex)
[13:18:58.287]                     })
[13:18:58.287]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.287]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.287]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.287]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.287]                       fi <- file.info(pathname)
[13:18:58.287]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.287]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.287]                         fi[["size"]], fi[["mtime"]])
[13:18:58.287]                       stop(msg)
[13:18:58.287]                     }
[13:18:58.287]                     invisible(pathname)
[13:18:58.287]                   }
[13:18:58.287]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.287]                     rootPath = tempdir()) 
[13:18:58.287]                   {
[13:18:58.287]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.287]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.287]                       tmpdir = path, fileext = ".rds")
[13:18:58.287]                     save_rds(obj, file)
[13:18:58.287]                   }
[13:18:58.287]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.287]                   {
[13:18:58.287]                     inherits <- base::inherits
[13:18:58.287]                     invokeRestart <- base::invokeRestart
[13:18:58.287]                     is.null <- base::is.null
[13:18:58.287]                     muffled <- FALSE
[13:18:58.287]                     if (inherits(cond, "message")) {
[13:18:58.287]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.287]                       if (muffled) 
[13:18:58.287]                         invokeRestart("muffleMessage")
[13:18:58.287]                     }
[13:18:58.287]                     else if (inherits(cond, "warning")) {
[13:18:58.287]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.287]                       if (muffled) 
[13:18:58.287]                         invokeRestart("muffleWarning")
[13:18:58.287]                     }
[13:18:58.287]                     else if (inherits(cond, "condition")) {
[13:18:58.287]                       if (!is.null(pattern)) {
[13:18:58.287]                         computeRestarts <- base::computeRestarts
[13:18:58.287]                         grepl <- base::grepl
[13:18:58.287]                         restarts <- computeRestarts(cond)
[13:18:58.287]                         for (restart in restarts) {
[13:18:58.287]                           name <- restart$name
[13:18:58.287]                           if (is.null(name)) 
[13:18:58.287]                             next
[13:18:58.287]                           if (!grepl(pattern, name)) 
[13:18:58.287]                             next
[13:18:58.287]                           invokeRestart(restart)
[13:18:58.287]                           muffled <- TRUE
[13:18:58.287]                           break
[13:18:58.287]                         }
[13:18:58.287]                       }
[13:18:58.287]                     }
[13:18:58.287]                     invisible(muffled)
[13:18:58.287]                   }
[13:18:58.287]                   muffleCondition(cond)
[13:18:58.287]                 })
[13:18:58.287]             }))
[13:18:58.287]             future::FutureResult(value = ...future.value$value, 
[13:18:58.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.287]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.287]                     ...future.globalenv.names))
[13:18:58.287]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.287]         }, condition = base::local({
[13:18:58.287]             c <- base::c
[13:18:58.287]             inherits <- base::inherits
[13:18:58.287]             invokeRestart <- base::invokeRestart
[13:18:58.287]             length <- base::length
[13:18:58.287]             list <- base::list
[13:18:58.287]             seq.int <- base::seq.int
[13:18:58.287]             signalCondition <- base::signalCondition
[13:18:58.287]             sys.calls <- base::sys.calls
[13:18:58.287]             `[[` <- base::`[[`
[13:18:58.287]             `+` <- base::`+`
[13:18:58.287]             `<<-` <- base::`<<-`
[13:18:58.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.287]                   3L)]
[13:18:58.287]             }
[13:18:58.287]             function(cond) {
[13:18:58.287]                 is_error <- inherits(cond, "error")
[13:18:58.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.287]                   NULL)
[13:18:58.287]                 if (is_error) {
[13:18:58.287]                   sessionInformation <- function() {
[13:18:58.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.287]                       search = base::search(), system = base::Sys.info())
[13:18:58.287]                   }
[13:18:58.287]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.287]                     cond$call), session = sessionInformation(), 
[13:18:58.287]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.287]                   signalCondition(cond)
[13:18:58.287]                 }
[13:18:58.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.287]                 "immediateCondition"))) {
[13:18:58.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.287]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.287]                   if (TRUE && !signal) {
[13:18:58.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.287]                     {
[13:18:58.287]                       inherits <- base::inherits
[13:18:58.287]                       invokeRestart <- base::invokeRestart
[13:18:58.287]                       is.null <- base::is.null
[13:18:58.287]                       muffled <- FALSE
[13:18:58.287]                       if (inherits(cond, "message")) {
[13:18:58.287]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.287]                         if (muffled) 
[13:18:58.287]                           invokeRestart("muffleMessage")
[13:18:58.287]                       }
[13:18:58.287]                       else if (inherits(cond, "warning")) {
[13:18:58.287]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.287]                         if (muffled) 
[13:18:58.287]                           invokeRestart("muffleWarning")
[13:18:58.287]                       }
[13:18:58.287]                       else if (inherits(cond, "condition")) {
[13:18:58.287]                         if (!is.null(pattern)) {
[13:18:58.287]                           computeRestarts <- base::computeRestarts
[13:18:58.287]                           grepl <- base::grepl
[13:18:58.287]                           restarts <- computeRestarts(cond)
[13:18:58.287]                           for (restart in restarts) {
[13:18:58.287]                             name <- restart$name
[13:18:58.287]                             if (is.null(name)) 
[13:18:58.287]                               next
[13:18:58.287]                             if (!grepl(pattern, name)) 
[13:18:58.287]                               next
[13:18:58.287]                             invokeRestart(restart)
[13:18:58.287]                             muffled <- TRUE
[13:18:58.287]                             break
[13:18:58.287]                           }
[13:18:58.287]                         }
[13:18:58.287]                       }
[13:18:58.287]                       invisible(muffled)
[13:18:58.287]                     }
[13:18:58.287]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.287]                   }
[13:18:58.287]                 }
[13:18:58.287]                 else {
[13:18:58.287]                   if (TRUE) {
[13:18:58.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.287]                     {
[13:18:58.287]                       inherits <- base::inherits
[13:18:58.287]                       invokeRestart <- base::invokeRestart
[13:18:58.287]                       is.null <- base::is.null
[13:18:58.287]                       muffled <- FALSE
[13:18:58.287]                       if (inherits(cond, "message")) {
[13:18:58.287]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.287]                         if (muffled) 
[13:18:58.287]                           invokeRestart("muffleMessage")
[13:18:58.287]                       }
[13:18:58.287]                       else if (inherits(cond, "warning")) {
[13:18:58.287]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.287]                         if (muffled) 
[13:18:58.287]                           invokeRestart("muffleWarning")
[13:18:58.287]                       }
[13:18:58.287]                       else if (inherits(cond, "condition")) {
[13:18:58.287]                         if (!is.null(pattern)) {
[13:18:58.287]                           computeRestarts <- base::computeRestarts
[13:18:58.287]                           grepl <- base::grepl
[13:18:58.287]                           restarts <- computeRestarts(cond)
[13:18:58.287]                           for (restart in restarts) {
[13:18:58.287]                             name <- restart$name
[13:18:58.287]                             if (is.null(name)) 
[13:18:58.287]                               next
[13:18:58.287]                             if (!grepl(pattern, name)) 
[13:18:58.287]                               next
[13:18:58.287]                             invokeRestart(restart)
[13:18:58.287]                             muffled <- TRUE
[13:18:58.287]                             break
[13:18:58.287]                           }
[13:18:58.287]                         }
[13:18:58.287]                       }
[13:18:58.287]                       invisible(muffled)
[13:18:58.287]                     }
[13:18:58.287]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.287]                   }
[13:18:58.287]                 }
[13:18:58.287]             }
[13:18:58.287]         }))
[13:18:58.287]     }, error = function(ex) {
[13:18:58.287]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.287]                 ...future.rng), started = ...future.startTime, 
[13:18:58.287]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.287]             version = "1.8"), class = "FutureResult")
[13:18:58.287]     }, finally = {
[13:18:58.287]         if (!identical(...future.workdir, getwd())) 
[13:18:58.287]             setwd(...future.workdir)
[13:18:58.287]         {
[13:18:58.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.287]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.287]             }
[13:18:58.287]             base::options(...future.oldOptions)
[13:18:58.287]             if (.Platform$OS.type == "windows") {
[13:18:58.287]                 old_names <- names(...future.oldEnvVars)
[13:18:58.287]                 envs <- base::Sys.getenv()
[13:18:58.287]                 names <- names(envs)
[13:18:58.287]                 common <- intersect(names, old_names)
[13:18:58.287]                 added <- setdiff(names, old_names)
[13:18:58.287]                 removed <- setdiff(old_names, names)
[13:18:58.287]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.287]                   envs[common]]
[13:18:58.287]                 NAMES <- toupper(changed)
[13:18:58.287]                 args <- list()
[13:18:58.287]                 for (kk in seq_along(NAMES)) {
[13:18:58.287]                   name <- changed[[kk]]
[13:18:58.287]                   NAME <- NAMES[[kk]]
[13:18:58.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.287]                     next
[13:18:58.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.287]                 }
[13:18:58.287]                 NAMES <- toupper(added)
[13:18:58.287]                 for (kk in seq_along(NAMES)) {
[13:18:58.287]                   name <- added[[kk]]
[13:18:58.287]                   NAME <- NAMES[[kk]]
[13:18:58.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.287]                     next
[13:18:58.287]                   args[[name]] <- ""
[13:18:58.287]                 }
[13:18:58.287]                 NAMES <- toupper(removed)
[13:18:58.287]                 for (kk in seq_along(NAMES)) {
[13:18:58.287]                   name <- removed[[kk]]
[13:18:58.287]                   NAME <- NAMES[[kk]]
[13:18:58.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.287]                     next
[13:18:58.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.287]                 }
[13:18:58.287]                 if (length(args) > 0) 
[13:18:58.287]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.287]             }
[13:18:58.287]             else {
[13:18:58.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.287]             }
[13:18:58.287]             {
[13:18:58.287]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.287]                   0L) {
[13:18:58.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.287]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.287]                   base::options(opts)
[13:18:58.287]                 }
[13:18:58.287]                 {
[13:18:58.287]                   {
[13:18:58.287]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.287]                     NULL
[13:18:58.287]                   }
[13:18:58.287]                   options(future.plan = NULL)
[13:18:58.287]                   if (is.na(NA_character_)) 
[13:18:58.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.287]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.287]                     envir = parent.frame()) 
[13:18:58.287]                   {
[13:18:58.287]                     default_workers <- missing(workers)
[13:18:58.287]                     if (is.function(workers)) 
[13:18:58.287]                       workers <- workers()
[13:18:58.287]                     workers <- structure(as.integer(workers), 
[13:18:58.287]                       class = class(workers))
[13:18:58.287]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.287]                       1L)
[13:18:58.287]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.287]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.287]                       if (default_workers) 
[13:18:58.287]                         supportsMulticore(warn = TRUE)
[13:18:58.287]                       return(sequential(..., envir = envir))
[13:18:58.287]                     }
[13:18:58.287]                     oopts <- options(mc.cores = workers)
[13:18:58.287]                     on.exit(options(oopts))
[13:18:58.287]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.287]                       envir = envir)
[13:18:58.287]                     if (!future$lazy) 
[13:18:58.287]                       future <- run(future)
[13:18:58.287]                     invisible(future)
[13:18:58.287]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.287]                 }
[13:18:58.287]             }
[13:18:58.287]         }
[13:18:58.287]     })
[13:18:58.287]     if (TRUE) {
[13:18:58.287]         base::sink(type = "output", split = FALSE)
[13:18:58.287]         if (TRUE) {
[13:18:58.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.287]         }
[13:18:58.287]         else {
[13:18:58.287]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.287]         }
[13:18:58.287]         base::close(...future.stdout)
[13:18:58.287]         ...future.stdout <- NULL
[13:18:58.287]     }
[13:18:58.287]     ...future.result$conditions <- ...future.conditions
[13:18:58.287]     ...future.result$finished <- base::Sys.time()
[13:18:58.287]     ...future.result
[13:18:58.287] }
[13:18:58.294] assign_globals() ...
[13:18:58.295] List of 11
[13:18:58.295]  $ ...future.FUN            :function (x, ...)  
[13:18:58.295]  $ x_FUN                    :function (x)  
[13:18:58.295]  $ times                    : int 1
[13:18:58.295]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.295]  $ stop_if_not              :function (...)  
[13:18:58.295]  $ dim                      : NULL
[13:18:58.295]  $ valid_types              : chr "character"
[13:18:58.295]  $ future.call.arguments    : list()
[13:18:58.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.295]  $ ...future.elements_ii    :List of 1
[13:18:58.295]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[13:18:58.295]  $ ...future.seeds_ii       : NULL
[13:18:58.295]  $ ...future.globals.maxSize: NULL
[13:18:58.295]  - attr(*, "where")=List of 11
[13:18:58.295]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.295]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.295]  - attr(*, "resolved")= logi FALSE
[13:18:58.295]  - attr(*, "total_size")= num 94208
[13:18:58.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.295]  - attr(*, "already-done")= logi TRUE
[13:18:58.308] - copied ‘...future.FUN’ to environment
[13:18:58.308] - copied ‘x_FUN’ to environment
[13:18:58.308] - copied ‘times’ to environment
[13:18:58.309] - copied ‘stopf’ to environment
[13:18:58.309] - copied ‘stop_if_not’ to environment
[13:18:58.309] - copied ‘dim’ to environment
[13:18:58.309] - copied ‘valid_types’ to environment
[13:18:58.309] - copied ‘future.call.arguments’ to environment
[13:18:58.309] - copied ‘...future.elements_ii’ to environment
[13:18:58.309] - copied ‘...future.seeds_ii’ to environment
[13:18:58.310] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.310] assign_globals() ... done
[13:18:58.310] requestCore(): workers = 2
[13:18:58.315] MulticoreFuture started
[13:18:58.315] - Launch lazy future ... done
[13:18:58.315] run() for ‘MulticoreFuture’ ... done
[13:18:58.316] Created future:
[13:18:58.316] plan(): Setting new future strategy stack:
[13:18:58.317] List of future strategies:
[13:18:58.317] 1. sequential:
[13:18:58.317]    - args: function (..., envir = parent.frame())
[13:18:58.317]    - tweaked: FALSE
[13:18:58.317]    - call: NULL
[13:18:58.317] plan(): nbrOfWorkers() = 1
[13:18:58.319] plan(): Setting new future strategy stack:
[13:18:58.320] List of future strategies:
[13:18:58.320] 1. multicore:
[13:18:58.320]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.320]    - tweaked: FALSE
[13:18:58.320]    - call: plan(strategy)
[13:18:58.325] plan(): nbrOfWorkers() = 2
[13:18:58.316] MulticoreFuture:
[13:18:58.316] Label: ‘future_vapply-2’
[13:18:58.316] Expression:
[13:18:58.316] {
[13:18:58.316]     do.call(function(...) {
[13:18:58.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.316]             on.exit(options(oopts), add = TRUE)
[13:18:58.316]         }
[13:18:58.316]         {
[13:18:58.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.316]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.316]             })
[13:18:58.316]         }
[13:18:58.316]     }, args = future.call.arguments)
[13:18:58.316] }
[13:18:58.316] Lazy evaluation: FALSE
[13:18:58.316] Asynchronous evaluation: TRUE
[13:18:58.316] Local evaluation: TRUE
[13:18:58.316] Environment: R_GlobalEnv
[13:18:58.316] Capture standard output: TRUE
[13:18:58.316] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.316] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.316] Packages: 1 packages (‘future.apply’)
[13:18:58.316] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.316] Resolved: TRUE
[13:18:58.316] Value: <not collected>
[13:18:58.316] Conditions captured: <none>
[13:18:58.316] Early signaling: FALSE
[13:18:58.316] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.316] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.326] Chunk #2 of 2 ... DONE
[13:18:58.326] Launching 2 futures (chunks) ... DONE
[13:18:58.326] Resolving 2 futures (chunks) ...
[13:18:58.326] resolve() on list ...
[13:18:58.326]  recursive: 0
[13:18:58.327]  length: 2
[13:18:58.327] 
[13:18:58.327] Future #1
[13:18:58.329] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:58.330] - nx: 2
[13:18:58.330] - relay: TRUE
[13:18:58.330] - stdout: TRUE
[13:18:58.330] - signal: TRUE
[13:18:58.330] - resignal: FALSE
[13:18:58.330] - force: TRUE
[13:18:58.330] - relayed: [n=2] FALSE, FALSE
[13:18:58.331] - queued futures: [n=2] FALSE, FALSE
[13:18:58.331]  - until=1
[13:18:58.331]  - relaying element #1
[13:18:58.331] - relayed: [n=2] TRUE, FALSE
[13:18:58.331] - queued futures: [n=2] TRUE, FALSE
[13:18:58.332] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:58.332]  length: 1 (resolved future 1)
[13:18:58.332] Future #2
[13:18:58.333] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:58.333] - nx: 2
[13:18:58.333] - relay: TRUE
[13:18:58.333] - stdout: TRUE
[13:18:58.333] - signal: TRUE
[13:18:58.333] - resignal: FALSE
[13:18:58.334] - force: TRUE
[13:18:58.334] - relayed: [n=2] TRUE, FALSE
[13:18:58.334] - queued futures: [n=2] TRUE, FALSE
[13:18:58.334]  - until=2
[13:18:58.334]  - relaying element #2
[13:18:58.334] - relayed: [n=2] TRUE, TRUE
[13:18:58.334] - queued futures: [n=2] TRUE, TRUE
[13:18:58.335] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:58.335]  length: 0 (resolved future 2)
[13:18:58.335] Relaying remaining futures
[13:18:58.335] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.335] - nx: 2
[13:18:58.335] - relay: TRUE
[13:18:58.335] - stdout: TRUE
[13:18:58.335] - signal: TRUE
[13:18:58.335] - resignal: FALSE
[13:18:58.336] - force: TRUE
[13:18:58.336] - relayed: [n=2] TRUE, TRUE
[13:18:58.336] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:58.336] - relayed: [n=2] TRUE, TRUE
[13:18:58.336] - queued futures: [n=2] TRUE, TRUE
[13:18:58.338] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.338] resolve() on list ... DONE
[13:18:58.339]  - Number of value chunks collected: 2
[13:18:58.339] Resolving 2 futures (chunks) ... DONE
[13:18:58.339] Reducing values from 2 chunks ...
[13:18:58.339]  - Number of values collected after concatenation: 2
[13:18:58.340]  - Number of values expected: 2
[13:18:58.340] Reducing values from 2 chunks ... DONE
[13:18:58.340] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:18:58.342] future_lapply() ...
[13:18:58.349] Number of chunks: 2
[13:18:58.349] getGlobalsAndPackagesXApply() ...
[13:18:58.349]  - future.globals: TRUE
[13:18:58.349] getGlobalsAndPackages() ...
[13:18:58.350] Searching for globals...
[13:18:58.354] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:18:58.354] Searching for globals ... DONE
[13:18:58.355] Resolving globals: FALSE
[13:18:58.355] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:18:58.356] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.356] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.356] - packages: [1] ‘future.apply’
[13:18:58.356] getGlobalsAndPackages() ... DONE
[13:18:58.356]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.357]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.357] Finding globals ... DONE
[13:18:58.357]  - use_args: TRUE
[13:18:58.357]  - Getting '...' globals ...
[13:18:58.357] resolve() on list ...
[13:18:58.357]  recursive: 0
[13:18:58.358]  length: 1
[13:18:58.358]  elements: ‘...’
[13:18:58.358]  length: 0 (resolved future 1)
[13:18:58.358] resolve() on list ... DONE
[13:18:58.358]    - '...' content: [n=0] 
[13:18:58.358] List of 1
[13:18:58.358]  $ ...: list()
[13:18:58.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.358]  - attr(*, "where")=List of 1
[13:18:58.358]   ..$ ...:<environment: 0x555f7a080b00> 
[13:18:58.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.358]  - attr(*, "resolved")= logi TRUE
[13:18:58.358]  - attr(*, "total_size")= num NA
[13:18:58.361]  - Getting '...' globals ... DONE
[13:18:58.361] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.361] List of 8
[13:18:58.361]  $ ...future.FUN:function (x, ...)  
[13:18:58.361]  $ x_FUN        :function (x)  
[13:18:58.361]  $ times        : int 0
[13:18:58.361]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.361]  $ stop_if_not  :function (...)  
[13:18:58.361]  $ dim          : NULL
[13:18:58.361]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:58.361]  $ ...          : list()
[13:18:58.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.361]  - attr(*, "where")=List of 8
[13:18:58.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.361]   ..$ ...          :<environment: 0x555f7a080b00> 
[13:18:58.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.361]  - attr(*, "resolved")= logi FALSE
[13:18:58.361]  - attr(*, "total_size")= num 95472
[13:18:58.369] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.369] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.369] Number of futures (= number of chunks): 2
[13:18:58.369] Launching 2 futures (chunks) ...
[13:18:58.370] Chunk #1 of 2 ...
[13:18:58.370]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.370] getGlobalsAndPackages() ...
[13:18:58.370] Searching for globals...
[13:18:58.370] 
[13:18:58.370] Searching for globals ... DONE
[13:18:58.370] - globals: [0] <none>
[13:18:58.371] getGlobalsAndPackages() ... DONE
[13:18:58.371]    + additional globals found: [n=0] 
[13:18:58.371]    + additional namespaces needed: [n=0] 
[13:18:58.371]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.371]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.371]  - seeds: <none>
[13:18:58.371] getGlobalsAndPackages() ...
[13:18:58.371] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.371] Resolving globals: FALSE
[13:18:58.372] Tweak future expression to call with '...' arguments ...
[13:18:58.372] {
[13:18:58.372]     do.call(function(...) {
[13:18:58.372]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.372]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.372]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.372]             on.exit(options(oopts), add = TRUE)
[13:18:58.372]         }
[13:18:58.372]         {
[13:18:58.372]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.372]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.372]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.372]             })
[13:18:58.372]         }
[13:18:58.372]     }, args = future.call.arguments)
[13:18:58.372] }
[13:18:58.372] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.372] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.373] - packages: [1] ‘future.apply’
[13:18:58.373] getGlobalsAndPackages() ... DONE
[13:18:58.373] run() for ‘Future’ ...
[13:18:58.373] - state: ‘created’
[13:18:58.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.377] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.377]   - Field: ‘label’
[13:18:58.378]   - Field: ‘local’
[13:18:58.378]   - Field: ‘owner’
[13:18:58.378]   - Field: ‘envir’
[13:18:58.378]   - Field: ‘workers’
[13:18:58.378]   - Field: ‘packages’
[13:18:58.378]   - Field: ‘gc’
[13:18:58.378]   - Field: ‘job’
[13:18:58.378]   - Field: ‘conditions’
[13:18:58.378]   - Field: ‘expr’
[13:18:58.378]   - Field: ‘uuid’
[13:18:58.379]   - Field: ‘seed’
[13:18:58.379]   - Field: ‘version’
[13:18:58.379]   - Field: ‘result’
[13:18:58.379]   - Field: ‘asynchronous’
[13:18:58.379]   - Field: ‘calls’
[13:18:58.379]   - Field: ‘globals’
[13:18:58.379]   - Field: ‘stdout’
[13:18:58.379]   - Field: ‘earlySignal’
[13:18:58.379]   - Field: ‘lazy’
[13:18:58.379]   - Field: ‘state’
[13:18:58.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.380] - Launch lazy future ...
[13:18:58.380] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.380] Packages needed by future strategies (n = 0): <none>
[13:18:58.381] {
[13:18:58.381]     {
[13:18:58.381]         {
[13:18:58.381]             ...future.startTime <- base::Sys.time()
[13:18:58.381]             {
[13:18:58.381]                 {
[13:18:58.381]                   {
[13:18:58.381]                     {
[13:18:58.381]                       {
[13:18:58.381]                         base::local({
[13:18:58.381]                           has_future <- base::requireNamespace("future", 
[13:18:58.381]                             quietly = TRUE)
[13:18:58.381]                           if (has_future) {
[13:18:58.381]                             ns <- base::getNamespace("future")
[13:18:58.381]                             version <- ns[[".package"]][["version"]]
[13:18:58.381]                             if (is.null(version)) 
[13:18:58.381]                               version <- utils::packageVersion("future")
[13:18:58.381]                           }
[13:18:58.381]                           else {
[13:18:58.381]                             version <- NULL
[13:18:58.381]                           }
[13:18:58.381]                           if (!has_future || version < "1.8.0") {
[13:18:58.381]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.381]                               "", base::R.version$version.string), 
[13:18:58.381]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.381]                                 base::R.version$platform, 8 * 
[13:18:58.381]                                   base::.Machine$sizeof.pointer), 
[13:18:58.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.381]                                 "release", "version")], collapse = " "), 
[13:18:58.381]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.381]                               info)
[13:18:58.381]                             info <- base::paste(info, collapse = "; ")
[13:18:58.381]                             if (!has_future) {
[13:18:58.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.381]                                 info)
[13:18:58.381]                             }
[13:18:58.381]                             else {
[13:18:58.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.381]                                 info, version)
[13:18:58.381]                             }
[13:18:58.381]                             base::stop(msg)
[13:18:58.381]                           }
[13:18:58.381]                         })
[13:18:58.381]                       }
[13:18:58.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.381]                       base::options(mc.cores = 1L)
[13:18:58.381]                     }
[13:18:58.381]                     base::local({
[13:18:58.381]                       for (pkg in "future.apply") {
[13:18:58.381]                         base::loadNamespace(pkg)
[13:18:58.381]                         base::library(pkg, character.only = TRUE)
[13:18:58.381]                       }
[13:18:58.381]                     })
[13:18:58.381]                   }
[13:18:58.381]                   options(future.plan = NULL)
[13:18:58.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.381]                 }
[13:18:58.381]                 ...future.workdir <- getwd()
[13:18:58.381]             }
[13:18:58.381]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.381]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.381]         }
[13:18:58.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.381]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.381]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.381]             base::names(...future.oldOptions))
[13:18:58.381]     }
[13:18:58.381]     if (FALSE) {
[13:18:58.381]     }
[13:18:58.381]     else {
[13:18:58.381]         if (TRUE) {
[13:18:58.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.381]                 open = "w")
[13:18:58.381]         }
[13:18:58.381]         else {
[13:18:58.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.381]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.381]         }
[13:18:58.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.381]             base::sink(type = "output", split = FALSE)
[13:18:58.381]             base::close(...future.stdout)
[13:18:58.381]         }, add = TRUE)
[13:18:58.381]     }
[13:18:58.381]     ...future.frame <- base::sys.nframe()
[13:18:58.381]     ...future.conditions <- base::list()
[13:18:58.381]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.381]     if (FALSE) {
[13:18:58.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.381]     }
[13:18:58.381]     ...future.result <- base::tryCatch({
[13:18:58.381]         base::withCallingHandlers({
[13:18:58.381]             ...future.value <- base::withVisible(base::local({
[13:18:58.381]                 withCallingHandlers({
[13:18:58.381]                   {
[13:18:58.381]                     do.call(function(...) {
[13:18:58.381]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.381]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.381]                         ...future.globals.maxSize)) {
[13:18:58.381]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.381]                         on.exit(options(oopts), add = TRUE)
[13:18:58.381]                       }
[13:18:58.381]                       {
[13:18:58.381]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.381]                           FUN = function(jj) {
[13:18:58.381]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.381]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.381]                           })
[13:18:58.381]                       }
[13:18:58.381]                     }, args = future.call.arguments)
[13:18:58.381]                   }
[13:18:58.381]                 }, immediateCondition = function(cond) {
[13:18:58.381]                   save_rds <- function (object, pathname, ...) 
[13:18:58.381]                   {
[13:18:58.381]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.381]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.381]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.381]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.381]                         fi_tmp[["mtime"]])
[13:18:58.381]                     }
[13:18:58.381]                     tryCatch({
[13:18:58.381]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.381]                     }, error = function(ex) {
[13:18:58.381]                       msg <- conditionMessage(ex)
[13:18:58.381]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.381]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.381]                         fi_tmp[["mtime"]], msg)
[13:18:58.381]                       ex$message <- msg
[13:18:58.381]                       stop(ex)
[13:18:58.381]                     })
[13:18:58.381]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.381]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.381]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.381]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.381]                       fi <- file.info(pathname)
[13:18:58.381]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.381]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.381]                         fi[["size"]], fi[["mtime"]])
[13:18:58.381]                       stop(msg)
[13:18:58.381]                     }
[13:18:58.381]                     invisible(pathname)
[13:18:58.381]                   }
[13:18:58.381]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.381]                     rootPath = tempdir()) 
[13:18:58.381]                   {
[13:18:58.381]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.381]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.381]                       tmpdir = path, fileext = ".rds")
[13:18:58.381]                     save_rds(obj, file)
[13:18:58.381]                   }
[13:18:58.381]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.381]                   {
[13:18:58.381]                     inherits <- base::inherits
[13:18:58.381]                     invokeRestart <- base::invokeRestart
[13:18:58.381]                     is.null <- base::is.null
[13:18:58.381]                     muffled <- FALSE
[13:18:58.381]                     if (inherits(cond, "message")) {
[13:18:58.381]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.381]                       if (muffled) 
[13:18:58.381]                         invokeRestart("muffleMessage")
[13:18:58.381]                     }
[13:18:58.381]                     else if (inherits(cond, "warning")) {
[13:18:58.381]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.381]                       if (muffled) 
[13:18:58.381]                         invokeRestart("muffleWarning")
[13:18:58.381]                     }
[13:18:58.381]                     else if (inherits(cond, "condition")) {
[13:18:58.381]                       if (!is.null(pattern)) {
[13:18:58.381]                         computeRestarts <- base::computeRestarts
[13:18:58.381]                         grepl <- base::grepl
[13:18:58.381]                         restarts <- computeRestarts(cond)
[13:18:58.381]                         for (restart in restarts) {
[13:18:58.381]                           name <- restart$name
[13:18:58.381]                           if (is.null(name)) 
[13:18:58.381]                             next
[13:18:58.381]                           if (!grepl(pattern, name)) 
[13:18:58.381]                             next
[13:18:58.381]                           invokeRestart(restart)
[13:18:58.381]                           muffled <- TRUE
[13:18:58.381]                           break
[13:18:58.381]                         }
[13:18:58.381]                       }
[13:18:58.381]                     }
[13:18:58.381]                     invisible(muffled)
[13:18:58.381]                   }
[13:18:58.381]                   muffleCondition(cond)
[13:18:58.381]                 })
[13:18:58.381]             }))
[13:18:58.381]             future::FutureResult(value = ...future.value$value, 
[13:18:58.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.381]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.381]                     ...future.globalenv.names))
[13:18:58.381]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.381]         }, condition = base::local({
[13:18:58.381]             c <- base::c
[13:18:58.381]             inherits <- base::inherits
[13:18:58.381]             invokeRestart <- base::invokeRestart
[13:18:58.381]             length <- base::length
[13:18:58.381]             list <- base::list
[13:18:58.381]             seq.int <- base::seq.int
[13:18:58.381]             signalCondition <- base::signalCondition
[13:18:58.381]             sys.calls <- base::sys.calls
[13:18:58.381]             `[[` <- base::`[[`
[13:18:58.381]             `+` <- base::`+`
[13:18:58.381]             `<<-` <- base::`<<-`
[13:18:58.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.381]                   3L)]
[13:18:58.381]             }
[13:18:58.381]             function(cond) {
[13:18:58.381]                 is_error <- inherits(cond, "error")
[13:18:58.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.381]                   NULL)
[13:18:58.381]                 if (is_error) {
[13:18:58.381]                   sessionInformation <- function() {
[13:18:58.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.381]                       search = base::search(), system = base::Sys.info())
[13:18:58.381]                   }
[13:18:58.381]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.381]                     cond$call), session = sessionInformation(), 
[13:18:58.381]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.381]                   signalCondition(cond)
[13:18:58.381]                 }
[13:18:58.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.381]                 "immediateCondition"))) {
[13:18:58.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.381]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.381]                   if (TRUE && !signal) {
[13:18:58.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.381]                     {
[13:18:58.381]                       inherits <- base::inherits
[13:18:58.381]                       invokeRestart <- base::invokeRestart
[13:18:58.381]                       is.null <- base::is.null
[13:18:58.381]                       muffled <- FALSE
[13:18:58.381]                       if (inherits(cond, "message")) {
[13:18:58.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.381]                         if (muffled) 
[13:18:58.381]                           invokeRestart("muffleMessage")
[13:18:58.381]                       }
[13:18:58.381]                       else if (inherits(cond, "warning")) {
[13:18:58.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.381]                         if (muffled) 
[13:18:58.381]                           invokeRestart("muffleWarning")
[13:18:58.381]                       }
[13:18:58.381]                       else if (inherits(cond, "condition")) {
[13:18:58.381]                         if (!is.null(pattern)) {
[13:18:58.381]                           computeRestarts <- base::computeRestarts
[13:18:58.381]                           grepl <- base::grepl
[13:18:58.381]                           restarts <- computeRestarts(cond)
[13:18:58.381]                           for (restart in restarts) {
[13:18:58.381]                             name <- restart$name
[13:18:58.381]                             if (is.null(name)) 
[13:18:58.381]                               next
[13:18:58.381]                             if (!grepl(pattern, name)) 
[13:18:58.381]                               next
[13:18:58.381]                             invokeRestart(restart)
[13:18:58.381]                             muffled <- TRUE
[13:18:58.381]                             break
[13:18:58.381]                           }
[13:18:58.381]                         }
[13:18:58.381]                       }
[13:18:58.381]                       invisible(muffled)
[13:18:58.381]                     }
[13:18:58.381]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.381]                   }
[13:18:58.381]                 }
[13:18:58.381]                 else {
[13:18:58.381]                   if (TRUE) {
[13:18:58.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.381]                     {
[13:18:58.381]                       inherits <- base::inherits
[13:18:58.381]                       invokeRestart <- base::invokeRestart
[13:18:58.381]                       is.null <- base::is.null
[13:18:58.381]                       muffled <- FALSE
[13:18:58.381]                       if (inherits(cond, "message")) {
[13:18:58.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.381]                         if (muffled) 
[13:18:58.381]                           invokeRestart("muffleMessage")
[13:18:58.381]                       }
[13:18:58.381]                       else if (inherits(cond, "warning")) {
[13:18:58.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.381]                         if (muffled) 
[13:18:58.381]                           invokeRestart("muffleWarning")
[13:18:58.381]                       }
[13:18:58.381]                       else if (inherits(cond, "condition")) {
[13:18:58.381]                         if (!is.null(pattern)) {
[13:18:58.381]                           computeRestarts <- base::computeRestarts
[13:18:58.381]                           grepl <- base::grepl
[13:18:58.381]                           restarts <- computeRestarts(cond)
[13:18:58.381]                           for (restart in restarts) {
[13:18:58.381]                             name <- restart$name
[13:18:58.381]                             if (is.null(name)) 
[13:18:58.381]                               next
[13:18:58.381]                             if (!grepl(pattern, name)) 
[13:18:58.381]                               next
[13:18:58.381]                             invokeRestart(restart)
[13:18:58.381]                             muffled <- TRUE
[13:18:58.381]                             break
[13:18:58.381]                           }
[13:18:58.381]                         }
[13:18:58.381]                       }
[13:18:58.381]                       invisible(muffled)
[13:18:58.381]                     }
[13:18:58.381]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.381]                   }
[13:18:58.381]                 }
[13:18:58.381]             }
[13:18:58.381]         }))
[13:18:58.381]     }, error = function(ex) {
[13:18:58.381]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.381]                 ...future.rng), started = ...future.startTime, 
[13:18:58.381]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.381]             version = "1.8"), class = "FutureResult")
[13:18:58.381]     }, finally = {
[13:18:58.381]         if (!identical(...future.workdir, getwd())) 
[13:18:58.381]             setwd(...future.workdir)
[13:18:58.381]         {
[13:18:58.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.381]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.381]             }
[13:18:58.381]             base::options(...future.oldOptions)
[13:18:58.381]             if (.Platform$OS.type == "windows") {
[13:18:58.381]                 old_names <- names(...future.oldEnvVars)
[13:18:58.381]                 envs <- base::Sys.getenv()
[13:18:58.381]                 names <- names(envs)
[13:18:58.381]                 common <- intersect(names, old_names)
[13:18:58.381]                 added <- setdiff(names, old_names)
[13:18:58.381]                 removed <- setdiff(old_names, names)
[13:18:58.381]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.381]                   envs[common]]
[13:18:58.381]                 NAMES <- toupper(changed)
[13:18:58.381]                 args <- list()
[13:18:58.381]                 for (kk in seq_along(NAMES)) {
[13:18:58.381]                   name <- changed[[kk]]
[13:18:58.381]                   NAME <- NAMES[[kk]]
[13:18:58.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.381]                     next
[13:18:58.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.381]                 }
[13:18:58.381]                 NAMES <- toupper(added)
[13:18:58.381]                 for (kk in seq_along(NAMES)) {
[13:18:58.381]                   name <- added[[kk]]
[13:18:58.381]                   NAME <- NAMES[[kk]]
[13:18:58.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.381]                     next
[13:18:58.381]                   args[[name]] <- ""
[13:18:58.381]                 }
[13:18:58.381]                 NAMES <- toupper(removed)
[13:18:58.381]                 for (kk in seq_along(NAMES)) {
[13:18:58.381]                   name <- removed[[kk]]
[13:18:58.381]                   NAME <- NAMES[[kk]]
[13:18:58.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.381]                     next
[13:18:58.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.381]                 }
[13:18:58.381]                 if (length(args) > 0) 
[13:18:58.381]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.381]             }
[13:18:58.381]             else {
[13:18:58.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.381]             }
[13:18:58.381]             {
[13:18:58.381]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.381]                   0L) {
[13:18:58.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.381]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.381]                   base::options(opts)
[13:18:58.381]                 }
[13:18:58.381]                 {
[13:18:58.381]                   {
[13:18:58.381]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.381]                     NULL
[13:18:58.381]                   }
[13:18:58.381]                   options(future.plan = NULL)
[13:18:58.381]                   if (is.na(NA_character_)) 
[13:18:58.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.381]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.381]                     envir = parent.frame()) 
[13:18:58.381]                   {
[13:18:58.381]                     default_workers <- missing(workers)
[13:18:58.381]                     if (is.function(workers)) 
[13:18:58.381]                       workers <- workers()
[13:18:58.381]                     workers <- structure(as.integer(workers), 
[13:18:58.381]                       class = class(workers))
[13:18:58.381]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.381]                       1L)
[13:18:58.381]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.381]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.381]                       if (default_workers) 
[13:18:58.381]                         supportsMulticore(warn = TRUE)
[13:18:58.381]                       return(sequential(..., envir = envir))
[13:18:58.381]                     }
[13:18:58.381]                     oopts <- options(mc.cores = workers)
[13:18:58.381]                     on.exit(options(oopts))
[13:18:58.381]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.381]                       envir = envir)
[13:18:58.381]                     if (!future$lazy) 
[13:18:58.381]                       future <- run(future)
[13:18:58.381]                     invisible(future)
[13:18:58.381]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.381]                 }
[13:18:58.381]             }
[13:18:58.381]         }
[13:18:58.381]     })
[13:18:58.381]     if (TRUE) {
[13:18:58.381]         base::sink(type = "output", split = FALSE)
[13:18:58.381]         if (TRUE) {
[13:18:58.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.381]         }
[13:18:58.381]         else {
[13:18:58.381]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.381]         }
[13:18:58.381]         base::close(...future.stdout)
[13:18:58.381]         ...future.stdout <- NULL
[13:18:58.381]     }
[13:18:58.381]     ...future.result$conditions <- ...future.conditions
[13:18:58.381]     ...future.result$finished <- base::Sys.time()
[13:18:58.381]     ...future.result
[13:18:58.381] }
[13:18:58.383] assign_globals() ...
[13:18:58.384] List of 11
[13:18:58.384]  $ ...future.FUN            :function (x, ...)  
[13:18:58.384]  $ x_FUN                    :function (x)  
[13:18:58.384]  $ times                    : int 0
[13:18:58.384]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.384]  $ stop_if_not              :function (...)  
[13:18:58.384]  $ dim                      : NULL
[13:18:58.384]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.384]  $ future.call.arguments    : list()
[13:18:58.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.384]  $ ...future.elements_ii    :List of 5
[13:18:58.384]   ..$ : int 1
[13:18:58.384]   ..$ : int 2
[13:18:58.384]   ..$ : int 3
[13:18:58.384]   ..$ : int 4
[13:18:58.384]   ..$ : int 5
[13:18:58.384]  $ ...future.seeds_ii       : NULL
[13:18:58.384]  $ ...future.globals.maxSize: NULL
[13:18:58.384]  - attr(*, "resolved")= logi FALSE
[13:18:58.384]  - attr(*, "total_size")= num 95472
[13:18:58.384]  - attr(*, "where")=List of 11
[13:18:58.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.384]  - attr(*, "already-done")= logi TRUE
[13:18:58.395] - copied ‘...future.FUN’ to environment
[13:18:58.395] - reassign environment for ‘x_FUN’
[13:18:58.395] - copied ‘x_FUN’ to environment
[13:18:58.395] - copied ‘times’ to environment
[13:18:58.395] - copied ‘stopf’ to environment
[13:18:58.395] - copied ‘stop_if_not’ to environment
[13:18:58.395] - copied ‘dim’ to environment
[13:18:58.395] - copied ‘valid_types’ to environment
[13:18:58.396] - copied ‘future.call.arguments’ to environment
[13:18:58.396] - copied ‘...future.elements_ii’ to environment
[13:18:58.396] - copied ‘...future.seeds_ii’ to environment
[13:18:58.396] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.396] assign_globals() ... done
[13:18:58.396] requestCore(): workers = 2
[13:18:58.399] MulticoreFuture started
[13:18:58.399] - Launch lazy future ... done
[13:18:58.400] run() for ‘MulticoreFuture’ ... done
[13:18:58.400] Created future:
[13:18:58.400] plan(): Setting new future strategy stack:
[13:18:58.401] List of future strategies:
[13:18:58.401] 1. sequential:
[13:18:58.401]    - args: function (..., envir = parent.frame())
[13:18:58.401]    - tweaked: FALSE
[13:18:58.401]    - call: NULL
[13:18:58.402] plan(): nbrOfWorkers() = 1
[13:18:58.405] plan(): Setting new future strategy stack:
[13:18:58.405] List of future strategies:
[13:18:58.405] 1. multicore:
[13:18:58.405]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.405]    - tweaked: FALSE
[13:18:58.405]    - call: plan(strategy)
[13:18:58.411] plan(): nbrOfWorkers() = 2
[13:18:58.401] MulticoreFuture:
[13:18:58.401] Label: ‘future_vapply-1’
[13:18:58.401] Expression:
[13:18:58.401] {
[13:18:58.401]     do.call(function(...) {
[13:18:58.401]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.401]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.401]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.401]             on.exit(options(oopts), add = TRUE)
[13:18:58.401]         }
[13:18:58.401]         {
[13:18:58.401]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.401]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.401]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.401]             })
[13:18:58.401]         }
[13:18:58.401]     }, args = future.call.arguments)
[13:18:58.401] }
[13:18:58.401] Lazy evaluation: FALSE
[13:18:58.401] Asynchronous evaluation: TRUE
[13:18:58.401] Local evaluation: TRUE
[13:18:58.401] Environment: R_GlobalEnv
[13:18:58.401] Capture standard output: TRUE
[13:18:58.401] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.401] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.401] Packages: 1 packages (‘future.apply’)
[13:18:58.401] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.401] Resolved: TRUE
[13:18:58.401] Value: <not collected>
[13:18:58.401] Conditions captured: <none>
[13:18:58.401] Early signaling: FALSE
[13:18:58.401] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.401] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.412] Chunk #1 of 2 ... DONE
[13:18:58.412] Chunk #2 of 2 ...
[13:18:58.412]  - Finding globals in 'X' for chunk #2 ...
[13:18:58.413] getGlobalsAndPackages() ...
[13:18:58.413] Searching for globals...
[13:18:58.413] 
[13:18:58.413] Searching for globals ... DONE
[13:18:58.414] - globals: [0] <none>
[13:18:58.414] getGlobalsAndPackages() ... DONE
[13:18:58.414]    + additional globals found: [n=0] 
[13:18:58.414]    + additional namespaces needed: [n=0] 
[13:18:58.414]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:58.415]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.415]  - seeds: <none>
[13:18:58.415] getGlobalsAndPackages() ...
[13:18:58.415] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.416] Resolving globals: FALSE
[13:18:58.416] Tweak future expression to call with '...' arguments ...
[13:18:58.416] {
[13:18:58.416]     do.call(function(...) {
[13:18:58.416]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.416]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.416]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.416]             on.exit(options(oopts), add = TRUE)
[13:18:58.416]         }
[13:18:58.416]         {
[13:18:58.416]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.416]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.416]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.416]             })
[13:18:58.416]         }
[13:18:58.416]     }, args = future.call.arguments)
[13:18:58.416] }
[13:18:58.416] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.418] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.418] - packages: [1] ‘future.apply’
[13:18:58.418] getGlobalsAndPackages() ... DONE
[13:18:58.419] run() for ‘Future’ ...
[13:18:58.419] - state: ‘created’
[13:18:58.419] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.424] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.425]   - Field: ‘label’
[13:18:58.425]   - Field: ‘local’
[13:18:58.425]   - Field: ‘owner’
[13:18:58.425]   - Field: ‘envir’
[13:18:58.425]   - Field: ‘workers’
[13:18:58.425]   - Field: ‘packages’
[13:18:58.426]   - Field: ‘gc’
[13:18:58.426]   - Field: ‘job’
[13:18:58.426]   - Field: ‘conditions’
[13:18:58.426]   - Field: ‘expr’
[13:18:58.426]   - Field: ‘uuid’
[13:18:58.426]   - Field: ‘seed’
[13:18:58.426]   - Field: ‘version’
[13:18:58.427]   - Field: ‘result’
[13:18:58.427]   - Field: ‘asynchronous’
[13:18:58.427]   - Field: ‘calls’
[13:18:58.427]   - Field: ‘globals’
[13:18:58.427]   - Field: ‘stdout’
[13:18:58.427]   - Field: ‘earlySignal’
[13:18:58.427]   - Field: ‘lazy’
[13:18:58.428]   - Field: ‘state’
[13:18:58.428] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.428] - Launch lazy future ...
[13:18:58.428] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.428] Packages needed by future strategies (n = 0): <none>
[13:18:58.429] {
[13:18:58.429]     {
[13:18:58.429]         {
[13:18:58.429]             ...future.startTime <- base::Sys.time()
[13:18:58.429]             {
[13:18:58.429]                 {
[13:18:58.429]                   {
[13:18:58.429]                     {
[13:18:58.429]                       {
[13:18:58.429]                         base::local({
[13:18:58.429]                           has_future <- base::requireNamespace("future", 
[13:18:58.429]                             quietly = TRUE)
[13:18:58.429]                           if (has_future) {
[13:18:58.429]                             ns <- base::getNamespace("future")
[13:18:58.429]                             version <- ns[[".package"]][["version"]]
[13:18:58.429]                             if (is.null(version)) 
[13:18:58.429]                               version <- utils::packageVersion("future")
[13:18:58.429]                           }
[13:18:58.429]                           else {
[13:18:58.429]                             version <- NULL
[13:18:58.429]                           }
[13:18:58.429]                           if (!has_future || version < "1.8.0") {
[13:18:58.429]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.429]                               "", base::R.version$version.string), 
[13:18:58.429]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.429]                                 base::R.version$platform, 8 * 
[13:18:58.429]                                   base::.Machine$sizeof.pointer), 
[13:18:58.429]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.429]                                 "release", "version")], collapse = " "), 
[13:18:58.429]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.429]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.429]                               info)
[13:18:58.429]                             info <- base::paste(info, collapse = "; ")
[13:18:58.429]                             if (!has_future) {
[13:18:58.429]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.429]                                 info)
[13:18:58.429]                             }
[13:18:58.429]                             else {
[13:18:58.429]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.429]                                 info, version)
[13:18:58.429]                             }
[13:18:58.429]                             base::stop(msg)
[13:18:58.429]                           }
[13:18:58.429]                         })
[13:18:58.429]                       }
[13:18:58.429]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.429]                       base::options(mc.cores = 1L)
[13:18:58.429]                     }
[13:18:58.429]                     base::local({
[13:18:58.429]                       for (pkg in "future.apply") {
[13:18:58.429]                         base::loadNamespace(pkg)
[13:18:58.429]                         base::library(pkg, character.only = TRUE)
[13:18:58.429]                       }
[13:18:58.429]                     })
[13:18:58.429]                   }
[13:18:58.429]                   options(future.plan = NULL)
[13:18:58.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.429]                 }
[13:18:58.429]                 ...future.workdir <- getwd()
[13:18:58.429]             }
[13:18:58.429]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.429]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.429]         }
[13:18:58.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.429]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.429]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.429]             base::names(...future.oldOptions))
[13:18:58.429]     }
[13:18:58.429]     if (FALSE) {
[13:18:58.429]     }
[13:18:58.429]     else {
[13:18:58.429]         if (TRUE) {
[13:18:58.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.429]                 open = "w")
[13:18:58.429]         }
[13:18:58.429]         else {
[13:18:58.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.429]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.429]         }
[13:18:58.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.429]             base::sink(type = "output", split = FALSE)
[13:18:58.429]             base::close(...future.stdout)
[13:18:58.429]         }, add = TRUE)
[13:18:58.429]     }
[13:18:58.429]     ...future.frame <- base::sys.nframe()
[13:18:58.429]     ...future.conditions <- base::list()
[13:18:58.429]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.429]     if (FALSE) {
[13:18:58.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.429]     }
[13:18:58.429]     ...future.result <- base::tryCatch({
[13:18:58.429]         base::withCallingHandlers({
[13:18:58.429]             ...future.value <- base::withVisible(base::local({
[13:18:58.429]                 withCallingHandlers({
[13:18:58.429]                   {
[13:18:58.429]                     do.call(function(...) {
[13:18:58.429]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.429]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.429]                         ...future.globals.maxSize)) {
[13:18:58.429]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.429]                         on.exit(options(oopts), add = TRUE)
[13:18:58.429]                       }
[13:18:58.429]                       {
[13:18:58.429]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.429]                           FUN = function(jj) {
[13:18:58.429]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.429]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.429]                           })
[13:18:58.429]                       }
[13:18:58.429]                     }, args = future.call.arguments)
[13:18:58.429]                   }
[13:18:58.429]                 }, immediateCondition = function(cond) {
[13:18:58.429]                   save_rds <- function (object, pathname, ...) 
[13:18:58.429]                   {
[13:18:58.429]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.429]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.429]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.429]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.429]                         fi_tmp[["mtime"]])
[13:18:58.429]                     }
[13:18:58.429]                     tryCatch({
[13:18:58.429]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.429]                     }, error = function(ex) {
[13:18:58.429]                       msg <- conditionMessage(ex)
[13:18:58.429]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.429]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.429]                         fi_tmp[["mtime"]], msg)
[13:18:58.429]                       ex$message <- msg
[13:18:58.429]                       stop(ex)
[13:18:58.429]                     })
[13:18:58.429]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.429]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.429]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.429]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.429]                       fi <- file.info(pathname)
[13:18:58.429]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.429]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.429]                         fi[["size"]], fi[["mtime"]])
[13:18:58.429]                       stop(msg)
[13:18:58.429]                     }
[13:18:58.429]                     invisible(pathname)
[13:18:58.429]                   }
[13:18:58.429]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.429]                     rootPath = tempdir()) 
[13:18:58.429]                   {
[13:18:58.429]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.429]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.429]                       tmpdir = path, fileext = ".rds")
[13:18:58.429]                     save_rds(obj, file)
[13:18:58.429]                   }
[13:18:58.429]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.429]                   {
[13:18:58.429]                     inherits <- base::inherits
[13:18:58.429]                     invokeRestart <- base::invokeRestart
[13:18:58.429]                     is.null <- base::is.null
[13:18:58.429]                     muffled <- FALSE
[13:18:58.429]                     if (inherits(cond, "message")) {
[13:18:58.429]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.429]                       if (muffled) 
[13:18:58.429]                         invokeRestart("muffleMessage")
[13:18:58.429]                     }
[13:18:58.429]                     else if (inherits(cond, "warning")) {
[13:18:58.429]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.429]                       if (muffled) 
[13:18:58.429]                         invokeRestart("muffleWarning")
[13:18:58.429]                     }
[13:18:58.429]                     else if (inherits(cond, "condition")) {
[13:18:58.429]                       if (!is.null(pattern)) {
[13:18:58.429]                         computeRestarts <- base::computeRestarts
[13:18:58.429]                         grepl <- base::grepl
[13:18:58.429]                         restarts <- computeRestarts(cond)
[13:18:58.429]                         for (restart in restarts) {
[13:18:58.429]                           name <- restart$name
[13:18:58.429]                           if (is.null(name)) 
[13:18:58.429]                             next
[13:18:58.429]                           if (!grepl(pattern, name)) 
[13:18:58.429]                             next
[13:18:58.429]                           invokeRestart(restart)
[13:18:58.429]                           muffled <- TRUE
[13:18:58.429]                           break
[13:18:58.429]                         }
[13:18:58.429]                       }
[13:18:58.429]                     }
[13:18:58.429]                     invisible(muffled)
[13:18:58.429]                   }
[13:18:58.429]                   muffleCondition(cond)
[13:18:58.429]                 })
[13:18:58.429]             }))
[13:18:58.429]             future::FutureResult(value = ...future.value$value, 
[13:18:58.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.429]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.429]                     ...future.globalenv.names))
[13:18:58.429]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.429]         }, condition = base::local({
[13:18:58.429]             c <- base::c
[13:18:58.429]             inherits <- base::inherits
[13:18:58.429]             invokeRestart <- base::invokeRestart
[13:18:58.429]             length <- base::length
[13:18:58.429]             list <- base::list
[13:18:58.429]             seq.int <- base::seq.int
[13:18:58.429]             signalCondition <- base::signalCondition
[13:18:58.429]             sys.calls <- base::sys.calls
[13:18:58.429]             `[[` <- base::`[[`
[13:18:58.429]             `+` <- base::`+`
[13:18:58.429]             `<<-` <- base::`<<-`
[13:18:58.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.429]                   3L)]
[13:18:58.429]             }
[13:18:58.429]             function(cond) {
[13:18:58.429]                 is_error <- inherits(cond, "error")
[13:18:58.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.429]                   NULL)
[13:18:58.429]                 if (is_error) {
[13:18:58.429]                   sessionInformation <- function() {
[13:18:58.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.429]                       search = base::search(), system = base::Sys.info())
[13:18:58.429]                   }
[13:18:58.429]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.429]                     cond$call), session = sessionInformation(), 
[13:18:58.429]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.429]                   signalCondition(cond)
[13:18:58.429]                 }
[13:18:58.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.429]                 "immediateCondition"))) {
[13:18:58.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.429]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.429]                   if (TRUE && !signal) {
[13:18:58.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.429]                     {
[13:18:58.429]                       inherits <- base::inherits
[13:18:58.429]                       invokeRestart <- base::invokeRestart
[13:18:58.429]                       is.null <- base::is.null
[13:18:58.429]                       muffled <- FALSE
[13:18:58.429]                       if (inherits(cond, "message")) {
[13:18:58.429]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.429]                         if (muffled) 
[13:18:58.429]                           invokeRestart("muffleMessage")
[13:18:58.429]                       }
[13:18:58.429]                       else if (inherits(cond, "warning")) {
[13:18:58.429]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.429]                         if (muffled) 
[13:18:58.429]                           invokeRestart("muffleWarning")
[13:18:58.429]                       }
[13:18:58.429]                       else if (inherits(cond, "condition")) {
[13:18:58.429]                         if (!is.null(pattern)) {
[13:18:58.429]                           computeRestarts <- base::computeRestarts
[13:18:58.429]                           grepl <- base::grepl
[13:18:58.429]                           restarts <- computeRestarts(cond)
[13:18:58.429]                           for (restart in restarts) {
[13:18:58.429]                             name <- restart$name
[13:18:58.429]                             if (is.null(name)) 
[13:18:58.429]                               next
[13:18:58.429]                             if (!grepl(pattern, name)) 
[13:18:58.429]                               next
[13:18:58.429]                             invokeRestart(restart)
[13:18:58.429]                             muffled <- TRUE
[13:18:58.429]                             break
[13:18:58.429]                           }
[13:18:58.429]                         }
[13:18:58.429]                       }
[13:18:58.429]                       invisible(muffled)
[13:18:58.429]                     }
[13:18:58.429]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.429]                   }
[13:18:58.429]                 }
[13:18:58.429]                 else {
[13:18:58.429]                   if (TRUE) {
[13:18:58.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.429]                     {
[13:18:58.429]                       inherits <- base::inherits
[13:18:58.429]                       invokeRestart <- base::invokeRestart
[13:18:58.429]                       is.null <- base::is.null
[13:18:58.429]                       muffled <- FALSE
[13:18:58.429]                       if (inherits(cond, "message")) {
[13:18:58.429]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.429]                         if (muffled) 
[13:18:58.429]                           invokeRestart("muffleMessage")
[13:18:58.429]                       }
[13:18:58.429]                       else if (inherits(cond, "warning")) {
[13:18:58.429]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.429]                         if (muffled) 
[13:18:58.429]                           invokeRestart("muffleWarning")
[13:18:58.429]                       }
[13:18:58.429]                       else if (inherits(cond, "condition")) {
[13:18:58.429]                         if (!is.null(pattern)) {
[13:18:58.429]                           computeRestarts <- base::computeRestarts
[13:18:58.429]                           grepl <- base::grepl
[13:18:58.429]                           restarts <- computeRestarts(cond)
[13:18:58.429]                           for (restart in restarts) {
[13:18:58.429]                             name <- restart$name
[13:18:58.429]                             if (is.null(name)) 
[13:18:58.429]                               next
[13:18:58.429]                             if (!grepl(pattern, name)) 
[13:18:58.429]                               next
[13:18:58.429]                             invokeRestart(restart)
[13:18:58.429]                             muffled <- TRUE
[13:18:58.429]                             break
[13:18:58.429]                           }
[13:18:58.429]                         }
[13:18:58.429]                       }
[13:18:58.429]                       invisible(muffled)
[13:18:58.429]                     }
[13:18:58.429]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.429]                   }
[13:18:58.429]                 }
[13:18:58.429]             }
[13:18:58.429]         }))
[13:18:58.429]     }, error = function(ex) {
[13:18:58.429]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.429]                 ...future.rng), started = ...future.startTime, 
[13:18:58.429]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.429]             version = "1.8"), class = "FutureResult")
[13:18:58.429]     }, finally = {
[13:18:58.429]         if (!identical(...future.workdir, getwd())) 
[13:18:58.429]             setwd(...future.workdir)
[13:18:58.429]         {
[13:18:58.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.429]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.429]             }
[13:18:58.429]             base::options(...future.oldOptions)
[13:18:58.429]             if (.Platform$OS.type == "windows") {
[13:18:58.429]                 old_names <- names(...future.oldEnvVars)
[13:18:58.429]                 envs <- base::Sys.getenv()
[13:18:58.429]                 names <- names(envs)
[13:18:58.429]                 common <- intersect(names, old_names)
[13:18:58.429]                 added <- setdiff(names, old_names)
[13:18:58.429]                 removed <- setdiff(old_names, names)
[13:18:58.429]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.429]                   envs[common]]
[13:18:58.429]                 NAMES <- toupper(changed)
[13:18:58.429]                 args <- list()
[13:18:58.429]                 for (kk in seq_along(NAMES)) {
[13:18:58.429]                   name <- changed[[kk]]
[13:18:58.429]                   NAME <- NAMES[[kk]]
[13:18:58.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.429]                     next
[13:18:58.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.429]                 }
[13:18:58.429]                 NAMES <- toupper(added)
[13:18:58.429]                 for (kk in seq_along(NAMES)) {
[13:18:58.429]                   name <- added[[kk]]
[13:18:58.429]                   NAME <- NAMES[[kk]]
[13:18:58.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.429]                     next
[13:18:58.429]                   args[[name]] <- ""
[13:18:58.429]                 }
[13:18:58.429]                 NAMES <- toupper(removed)
[13:18:58.429]                 for (kk in seq_along(NAMES)) {
[13:18:58.429]                   name <- removed[[kk]]
[13:18:58.429]                   NAME <- NAMES[[kk]]
[13:18:58.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.429]                     next
[13:18:58.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.429]                 }
[13:18:58.429]                 if (length(args) > 0) 
[13:18:58.429]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.429]             }
[13:18:58.429]             else {
[13:18:58.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.429]             }
[13:18:58.429]             {
[13:18:58.429]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.429]                   0L) {
[13:18:58.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.429]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.429]                   base::options(opts)
[13:18:58.429]                 }
[13:18:58.429]                 {
[13:18:58.429]                   {
[13:18:58.429]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.429]                     NULL
[13:18:58.429]                   }
[13:18:58.429]                   options(future.plan = NULL)
[13:18:58.429]                   if (is.na(NA_character_)) 
[13:18:58.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.429]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.429]                     envir = parent.frame()) 
[13:18:58.429]                   {
[13:18:58.429]                     default_workers <- missing(workers)
[13:18:58.429]                     if (is.function(workers)) 
[13:18:58.429]                       workers <- workers()
[13:18:58.429]                     workers <- structure(as.integer(workers), 
[13:18:58.429]                       class = class(workers))
[13:18:58.429]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.429]                       1L)
[13:18:58.429]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.429]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.429]                       if (default_workers) 
[13:18:58.429]                         supportsMulticore(warn = TRUE)
[13:18:58.429]                       return(sequential(..., envir = envir))
[13:18:58.429]                     }
[13:18:58.429]                     oopts <- options(mc.cores = workers)
[13:18:58.429]                     on.exit(options(oopts))
[13:18:58.429]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.429]                       envir = envir)
[13:18:58.429]                     if (!future$lazy) 
[13:18:58.429]                       future <- run(future)
[13:18:58.429]                     invisible(future)
[13:18:58.429]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.429]                 }
[13:18:58.429]             }
[13:18:58.429]         }
[13:18:58.429]     })
[13:18:58.429]     if (TRUE) {
[13:18:58.429]         base::sink(type = "output", split = FALSE)
[13:18:58.429]         if (TRUE) {
[13:18:58.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.429]         }
[13:18:58.429]         else {
[13:18:58.429]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.429]         }
[13:18:58.429]         base::close(...future.stdout)
[13:18:58.429]         ...future.stdout <- NULL
[13:18:58.429]     }
[13:18:58.429]     ...future.result$conditions <- ...future.conditions
[13:18:58.429]     ...future.result$finished <- base::Sys.time()
[13:18:58.429]     ...future.result
[13:18:58.429] }
[13:18:58.433] assign_globals() ...
[13:18:58.433] List of 11
[13:18:58.433]  $ ...future.FUN            :function (x, ...)  
[13:18:58.433]  $ x_FUN                    :function (x)  
[13:18:58.433]  $ times                    : int 0
[13:18:58.433]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.433]  $ stop_if_not              :function (...)  
[13:18:58.433]  $ dim                      : NULL
[13:18:58.433]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.433]  $ future.call.arguments    : list()
[13:18:58.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.433]  $ ...future.elements_ii    :List of 5
[13:18:58.433]   ..$ : int 6
[13:18:58.433]   ..$ : int 7
[13:18:58.433]   ..$ : int 8
[13:18:58.433]   ..$ : int 9
[13:18:58.433]   ..$ : int 10
[13:18:58.433]  $ ...future.seeds_ii       : NULL
[13:18:58.433]  $ ...future.globals.maxSize: NULL
[13:18:58.433]  - attr(*, "resolved")= logi FALSE
[13:18:58.433]  - attr(*, "total_size")= num 95472
[13:18:58.433]  - attr(*, "where")=List of 11
[13:18:58.433]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.433]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.433]  - attr(*, "already-done")= logi TRUE
[13:18:58.447] - copied ‘...future.FUN’ to environment
[13:18:58.448] - reassign environment for ‘x_FUN’
[13:18:58.448] - copied ‘x_FUN’ to environment
[13:18:58.448] - copied ‘times’ to environment
[13:18:58.448] - copied ‘stopf’ to environment
[13:18:58.448] - copied ‘stop_if_not’ to environment
[13:18:58.448] - copied ‘dim’ to environment
[13:18:58.448] - copied ‘valid_types’ to environment
[13:18:58.448] - copied ‘future.call.arguments’ to environment
[13:18:58.449] - copied ‘...future.elements_ii’ to environment
[13:18:58.449] - copied ‘...future.seeds_ii’ to environment
[13:18:58.449] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.449] assign_globals() ... done
[13:18:58.449] requestCore(): workers = 2
[13:18:58.451] MulticoreFuture started
[13:18:58.452] - Launch lazy future ... done
[13:18:58.452] run() for ‘MulticoreFuture’ ... done
[13:18:58.453] Created future:
[13:18:58.453] plan(): Setting new future strategy stack:
[13:18:58.453] List of future strategies:
[13:18:58.453] 1. sequential:
[13:18:58.453]    - args: function (..., envir = parent.frame())
[13:18:58.453]    - tweaked: FALSE
[13:18:58.453]    - call: NULL
[13:18:58.454] plan(): nbrOfWorkers() = 1
[13:18:58.456] plan(): Setting new future strategy stack:
[13:18:58.457] List of future strategies:
[13:18:58.457] 1. multicore:
[13:18:58.457]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.457]    - tweaked: FALSE
[13:18:58.457]    - call: plan(strategy)
[13:18:58.463] plan(): nbrOfWorkers() = 2
[13:18:58.453] MulticoreFuture:
[13:18:58.453] Label: ‘future_vapply-2’
[13:18:58.453] Expression:
[13:18:58.453] {
[13:18:58.453]     do.call(function(...) {
[13:18:58.453]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.453]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.453]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.453]             on.exit(options(oopts), add = TRUE)
[13:18:58.453]         }
[13:18:58.453]         {
[13:18:58.453]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.453]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.453]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.453]             })
[13:18:58.453]         }
[13:18:58.453]     }, args = future.call.arguments)
[13:18:58.453] }
[13:18:58.453] Lazy evaluation: FALSE
[13:18:58.453] Asynchronous evaluation: TRUE
[13:18:58.453] Local evaluation: TRUE
[13:18:58.453] Environment: R_GlobalEnv
[13:18:58.453] Capture standard output: TRUE
[13:18:58.453] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.453] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.453] Packages: 1 packages (‘future.apply’)
[13:18:58.453] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.453] Resolved: TRUE
[13:18:58.453] Value: <not collected>
[13:18:58.453] Conditions captured: <none>
[13:18:58.453] Early signaling: FALSE
[13:18:58.453] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.453] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.464] Chunk #2 of 2 ... DONE
[13:18:58.464] Launching 2 futures (chunks) ... DONE
[13:18:58.464] Resolving 2 futures (chunks) ...
[13:18:58.464] resolve() on list ...
[13:18:58.465]  recursive: 0
[13:18:58.465]  length: 2
[13:18:58.465] 
[13:18:58.465] Future #1
[13:18:58.466] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:58.467] - nx: 2
[13:18:58.467] - relay: TRUE
[13:18:58.467] - stdout: TRUE
[13:18:58.467] - signal: TRUE
[13:18:58.467] - resignal: FALSE
[13:18:58.467] - force: TRUE
[13:18:58.467] - relayed: [n=2] FALSE, FALSE
[13:18:58.468] - queued futures: [n=2] FALSE, FALSE
[13:18:58.468]  - until=1
[13:18:58.468]  - relaying element #1
[13:18:58.468] - relayed: [n=2] TRUE, FALSE
[13:18:58.468] - queued futures: [n=2] TRUE, FALSE
[13:18:58.469] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:58.469]  length: 1 (resolved future 1)
[13:18:58.469] Future #2
[13:18:58.470] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:58.470] - nx: 2
[13:18:58.470] - relay: TRUE
[13:18:58.471] - stdout: TRUE
[13:18:58.471] - signal: TRUE
[13:18:58.471] - resignal: FALSE
[13:18:58.471] - force: TRUE
[13:18:58.471] - relayed: [n=2] TRUE, FALSE
[13:18:58.471] - queued futures: [n=2] TRUE, FALSE
[13:18:58.471]  - until=2
[13:18:58.471]  - relaying element #2
[13:18:58.472] - relayed: [n=2] TRUE, TRUE
[13:18:58.472] - queued futures: [n=2] TRUE, TRUE
[13:18:58.472] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:58.472]  length: 0 (resolved future 2)
[13:18:58.472] Relaying remaining futures
[13:18:58.472] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.472] - nx: 2
[13:18:58.473] - relay: TRUE
[13:18:58.473] - stdout: TRUE
[13:18:58.473] - signal: TRUE
[13:18:58.473] - resignal: FALSE
[13:18:58.473] - force: TRUE
[13:18:58.473] - relayed: [n=2] TRUE, TRUE
[13:18:58.473] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:58.473] - relayed: [n=2] TRUE, TRUE
[13:18:58.473] - queued futures: [n=2] TRUE, TRUE
[13:18:58.474] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.474] resolve() on list ... DONE
[13:18:58.474]  - Number of value chunks collected: 2
[13:18:58.474] Resolving 2 futures (chunks) ... DONE
[13:18:58.474] Reducing values from 2 chunks ...
[13:18:58.474]  - Number of values collected after concatenation: 10
[13:18:58.474]  - Number of values expected: 10
[13:18:58.474] Reducing values from 2 chunks ... DONE
[13:18:58.475] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:18:58.476] future_lapply() ...
[13:18:58.482] Number of chunks: 2
[13:18:58.483] getGlobalsAndPackagesXApply() ...
[13:18:58.483]  - future.globals: TRUE
[13:18:58.483] getGlobalsAndPackages() ...
[13:18:58.483] Searching for globals...
[13:18:58.490] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:18:58.491] Searching for globals ... DONE
[13:18:58.491] Resolving globals: FALSE
[13:18:58.492] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:18:58.493] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.493] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.493] - packages: [1] ‘future.apply’
[13:18:58.493] getGlobalsAndPackages() ... DONE
[13:18:58.494]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.494]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.494] Finding globals ... DONE
[13:18:58.494]  - use_args: TRUE
[13:18:58.494]  - Getting '...' globals ...
[13:18:58.495] resolve() on list ...
[13:18:58.495]  recursive: 0
[13:18:58.495]  length: 1
[13:18:58.495]  elements: ‘...’
[13:18:58.495]  length: 0 (resolved future 1)
[13:18:58.495] resolve() on list ... DONE
[13:18:58.495]    - '...' content: [n=0] 
[13:18:58.495] List of 1
[13:18:58.495]  $ ...: list()
[13:18:58.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.495]  - attr(*, "where")=List of 1
[13:18:58.495]   ..$ ...:<environment: 0x555f7b0f1450> 
[13:18:58.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.495]  - attr(*, "resolved")= logi TRUE
[13:18:58.495]  - attr(*, "total_size")= num NA
[13:18:58.498]  - Getting '...' globals ... DONE
[13:18:58.498] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.498] List of 8
[13:18:58.498]  $ ...future.FUN:function (x, ...)  
[13:18:58.498]  $ x_FUN        :function (x)  
[13:18:58.498]  $ times        : int 0
[13:18:58.498]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.498]  $ stop_if_not  :function (...)  
[13:18:58.498]  $ dim          : NULL
[13:18:58.498]  $ valid_types  : chr [1:2] "logical" "integer"
[13:18:58.498]  $ ...          : list()
[13:18:58.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.498]  - attr(*, "where")=List of 8
[13:18:58.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.498]   ..$ ...          :<environment: 0x555f7b0f1450> 
[13:18:58.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.498]  - attr(*, "resolved")= logi FALSE
[13:18:58.498]  - attr(*, "total_size")= num 95400
[13:18:58.504] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.504] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.504] Number of futures (= number of chunks): 2
[13:18:58.504] Launching 2 futures (chunks) ...
[13:18:58.504] Chunk #1 of 2 ...
[13:18:58.504]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.505] getGlobalsAndPackages() ...
[13:18:58.505] Searching for globals...
[13:18:58.505] 
[13:18:58.505] Searching for globals ... DONE
[13:18:58.505] - globals: [0] <none>
[13:18:58.505] getGlobalsAndPackages() ... DONE
[13:18:58.505]    + additional globals found: [n=0] 
[13:18:58.505]    + additional namespaces needed: [n=0] 
[13:18:58.505]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.506]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.506]  - seeds: <none>
[13:18:58.506] getGlobalsAndPackages() ...
[13:18:58.506] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.506] Resolving globals: FALSE
[13:18:58.506] Tweak future expression to call with '...' arguments ...
[13:18:58.506] {
[13:18:58.506]     do.call(function(...) {
[13:18:58.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.506]             on.exit(options(oopts), add = TRUE)
[13:18:58.506]         }
[13:18:58.506]         {
[13:18:58.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.506]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.506]             })
[13:18:58.506]         }
[13:18:58.506]     }, args = future.call.arguments)
[13:18:58.506] }
[13:18:58.507] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.507] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.507] - packages: [1] ‘future.apply’
[13:18:58.507] getGlobalsAndPackages() ... DONE
[13:18:58.508] run() for ‘Future’ ...
[13:18:58.508] - state: ‘created’
[13:18:58.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.512]   - Field: ‘label’
[13:18:58.512]   - Field: ‘local’
[13:18:58.512]   - Field: ‘owner’
[13:18:58.512]   - Field: ‘envir’
[13:18:58.512]   - Field: ‘workers’
[13:18:58.512]   - Field: ‘packages’
[13:18:58.512]   - Field: ‘gc’
[13:18:58.513]   - Field: ‘job’
[13:18:58.513]   - Field: ‘conditions’
[13:18:58.513]   - Field: ‘expr’
[13:18:58.513]   - Field: ‘uuid’
[13:18:58.513]   - Field: ‘seed’
[13:18:58.513]   - Field: ‘version’
[13:18:58.515]   - Field: ‘result’
[13:18:58.515]   - Field: ‘asynchronous’
[13:18:58.515]   - Field: ‘calls’
[13:18:58.515]   - Field: ‘globals’
[13:18:58.515]   - Field: ‘stdout’
[13:18:58.516]   - Field: ‘earlySignal’
[13:18:58.516]   - Field: ‘lazy’
[13:18:58.516]   - Field: ‘state’
[13:18:58.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.516] - Launch lazy future ...
[13:18:58.516] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.516] Packages needed by future strategies (n = 0): <none>
[13:18:58.517] {
[13:18:58.517]     {
[13:18:58.517]         {
[13:18:58.517]             ...future.startTime <- base::Sys.time()
[13:18:58.517]             {
[13:18:58.517]                 {
[13:18:58.517]                   {
[13:18:58.517]                     {
[13:18:58.517]                       {
[13:18:58.517]                         base::local({
[13:18:58.517]                           has_future <- base::requireNamespace("future", 
[13:18:58.517]                             quietly = TRUE)
[13:18:58.517]                           if (has_future) {
[13:18:58.517]                             ns <- base::getNamespace("future")
[13:18:58.517]                             version <- ns[[".package"]][["version"]]
[13:18:58.517]                             if (is.null(version)) 
[13:18:58.517]                               version <- utils::packageVersion("future")
[13:18:58.517]                           }
[13:18:58.517]                           else {
[13:18:58.517]                             version <- NULL
[13:18:58.517]                           }
[13:18:58.517]                           if (!has_future || version < "1.8.0") {
[13:18:58.517]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.517]                               "", base::R.version$version.string), 
[13:18:58.517]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.517]                                 base::R.version$platform, 8 * 
[13:18:58.517]                                   base::.Machine$sizeof.pointer), 
[13:18:58.517]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.517]                                 "release", "version")], collapse = " "), 
[13:18:58.517]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.517]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.517]                               info)
[13:18:58.517]                             info <- base::paste(info, collapse = "; ")
[13:18:58.517]                             if (!has_future) {
[13:18:58.517]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.517]                                 info)
[13:18:58.517]                             }
[13:18:58.517]                             else {
[13:18:58.517]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.517]                                 info, version)
[13:18:58.517]                             }
[13:18:58.517]                             base::stop(msg)
[13:18:58.517]                           }
[13:18:58.517]                         })
[13:18:58.517]                       }
[13:18:58.517]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.517]                       base::options(mc.cores = 1L)
[13:18:58.517]                     }
[13:18:58.517]                     base::local({
[13:18:58.517]                       for (pkg in "future.apply") {
[13:18:58.517]                         base::loadNamespace(pkg)
[13:18:58.517]                         base::library(pkg, character.only = TRUE)
[13:18:58.517]                       }
[13:18:58.517]                     })
[13:18:58.517]                   }
[13:18:58.517]                   options(future.plan = NULL)
[13:18:58.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.517]                 }
[13:18:58.517]                 ...future.workdir <- getwd()
[13:18:58.517]             }
[13:18:58.517]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.517]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.517]         }
[13:18:58.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.517]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.517]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.517]             base::names(...future.oldOptions))
[13:18:58.517]     }
[13:18:58.517]     if (FALSE) {
[13:18:58.517]     }
[13:18:58.517]     else {
[13:18:58.517]         if (TRUE) {
[13:18:58.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.517]                 open = "w")
[13:18:58.517]         }
[13:18:58.517]         else {
[13:18:58.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.517]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.517]         }
[13:18:58.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.517]             base::sink(type = "output", split = FALSE)
[13:18:58.517]             base::close(...future.stdout)
[13:18:58.517]         }, add = TRUE)
[13:18:58.517]     }
[13:18:58.517]     ...future.frame <- base::sys.nframe()
[13:18:58.517]     ...future.conditions <- base::list()
[13:18:58.517]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.517]     if (FALSE) {
[13:18:58.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.517]     }
[13:18:58.517]     ...future.result <- base::tryCatch({
[13:18:58.517]         base::withCallingHandlers({
[13:18:58.517]             ...future.value <- base::withVisible(base::local({
[13:18:58.517]                 withCallingHandlers({
[13:18:58.517]                   {
[13:18:58.517]                     do.call(function(...) {
[13:18:58.517]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.517]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.517]                         ...future.globals.maxSize)) {
[13:18:58.517]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.517]                         on.exit(options(oopts), add = TRUE)
[13:18:58.517]                       }
[13:18:58.517]                       {
[13:18:58.517]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.517]                           FUN = function(jj) {
[13:18:58.517]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.517]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.517]                           })
[13:18:58.517]                       }
[13:18:58.517]                     }, args = future.call.arguments)
[13:18:58.517]                   }
[13:18:58.517]                 }, immediateCondition = function(cond) {
[13:18:58.517]                   save_rds <- function (object, pathname, ...) 
[13:18:58.517]                   {
[13:18:58.517]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.517]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.517]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.517]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.517]                         fi_tmp[["mtime"]])
[13:18:58.517]                     }
[13:18:58.517]                     tryCatch({
[13:18:58.517]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.517]                     }, error = function(ex) {
[13:18:58.517]                       msg <- conditionMessage(ex)
[13:18:58.517]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.517]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.517]                         fi_tmp[["mtime"]], msg)
[13:18:58.517]                       ex$message <- msg
[13:18:58.517]                       stop(ex)
[13:18:58.517]                     })
[13:18:58.517]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.517]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.517]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.517]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.517]                       fi <- file.info(pathname)
[13:18:58.517]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.517]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.517]                         fi[["size"]], fi[["mtime"]])
[13:18:58.517]                       stop(msg)
[13:18:58.517]                     }
[13:18:58.517]                     invisible(pathname)
[13:18:58.517]                   }
[13:18:58.517]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.517]                     rootPath = tempdir()) 
[13:18:58.517]                   {
[13:18:58.517]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.517]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.517]                       tmpdir = path, fileext = ".rds")
[13:18:58.517]                     save_rds(obj, file)
[13:18:58.517]                   }
[13:18:58.517]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.517]                   {
[13:18:58.517]                     inherits <- base::inherits
[13:18:58.517]                     invokeRestart <- base::invokeRestart
[13:18:58.517]                     is.null <- base::is.null
[13:18:58.517]                     muffled <- FALSE
[13:18:58.517]                     if (inherits(cond, "message")) {
[13:18:58.517]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.517]                       if (muffled) 
[13:18:58.517]                         invokeRestart("muffleMessage")
[13:18:58.517]                     }
[13:18:58.517]                     else if (inherits(cond, "warning")) {
[13:18:58.517]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.517]                       if (muffled) 
[13:18:58.517]                         invokeRestart("muffleWarning")
[13:18:58.517]                     }
[13:18:58.517]                     else if (inherits(cond, "condition")) {
[13:18:58.517]                       if (!is.null(pattern)) {
[13:18:58.517]                         computeRestarts <- base::computeRestarts
[13:18:58.517]                         grepl <- base::grepl
[13:18:58.517]                         restarts <- computeRestarts(cond)
[13:18:58.517]                         for (restart in restarts) {
[13:18:58.517]                           name <- restart$name
[13:18:58.517]                           if (is.null(name)) 
[13:18:58.517]                             next
[13:18:58.517]                           if (!grepl(pattern, name)) 
[13:18:58.517]                             next
[13:18:58.517]                           invokeRestart(restart)
[13:18:58.517]                           muffled <- TRUE
[13:18:58.517]                           break
[13:18:58.517]                         }
[13:18:58.517]                       }
[13:18:58.517]                     }
[13:18:58.517]                     invisible(muffled)
[13:18:58.517]                   }
[13:18:58.517]                   muffleCondition(cond)
[13:18:58.517]                 })
[13:18:58.517]             }))
[13:18:58.517]             future::FutureResult(value = ...future.value$value, 
[13:18:58.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.517]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.517]                     ...future.globalenv.names))
[13:18:58.517]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.517]         }, condition = base::local({
[13:18:58.517]             c <- base::c
[13:18:58.517]             inherits <- base::inherits
[13:18:58.517]             invokeRestart <- base::invokeRestart
[13:18:58.517]             length <- base::length
[13:18:58.517]             list <- base::list
[13:18:58.517]             seq.int <- base::seq.int
[13:18:58.517]             signalCondition <- base::signalCondition
[13:18:58.517]             sys.calls <- base::sys.calls
[13:18:58.517]             `[[` <- base::`[[`
[13:18:58.517]             `+` <- base::`+`
[13:18:58.517]             `<<-` <- base::`<<-`
[13:18:58.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.517]                   3L)]
[13:18:58.517]             }
[13:18:58.517]             function(cond) {
[13:18:58.517]                 is_error <- inherits(cond, "error")
[13:18:58.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.517]                   NULL)
[13:18:58.517]                 if (is_error) {
[13:18:58.517]                   sessionInformation <- function() {
[13:18:58.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.517]                       search = base::search(), system = base::Sys.info())
[13:18:58.517]                   }
[13:18:58.517]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.517]                     cond$call), session = sessionInformation(), 
[13:18:58.517]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.517]                   signalCondition(cond)
[13:18:58.517]                 }
[13:18:58.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.517]                 "immediateCondition"))) {
[13:18:58.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.517]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.517]                   if (TRUE && !signal) {
[13:18:58.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.517]                     {
[13:18:58.517]                       inherits <- base::inherits
[13:18:58.517]                       invokeRestart <- base::invokeRestart
[13:18:58.517]                       is.null <- base::is.null
[13:18:58.517]                       muffled <- FALSE
[13:18:58.517]                       if (inherits(cond, "message")) {
[13:18:58.517]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.517]                         if (muffled) 
[13:18:58.517]                           invokeRestart("muffleMessage")
[13:18:58.517]                       }
[13:18:58.517]                       else if (inherits(cond, "warning")) {
[13:18:58.517]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.517]                         if (muffled) 
[13:18:58.517]                           invokeRestart("muffleWarning")
[13:18:58.517]                       }
[13:18:58.517]                       else if (inherits(cond, "condition")) {
[13:18:58.517]                         if (!is.null(pattern)) {
[13:18:58.517]                           computeRestarts <- base::computeRestarts
[13:18:58.517]                           grepl <- base::grepl
[13:18:58.517]                           restarts <- computeRestarts(cond)
[13:18:58.517]                           for (restart in restarts) {
[13:18:58.517]                             name <- restart$name
[13:18:58.517]                             if (is.null(name)) 
[13:18:58.517]                               next
[13:18:58.517]                             if (!grepl(pattern, name)) 
[13:18:58.517]                               next
[13:18:58.517]                             invokeRestart(restart)
[13:18:58.517]                             muffled <- TRUE
[13:18:58.517]                             break
[13:18:58.517]                           }
[13:18:58.517]                         }
[13:18:58.517]                       }
[13:18:58.517]                       invisible(muffled)
[13:18:58.517]                     }
[13:18:58.517]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.517]                   }
[13:18:58.517]                 }
[13:18:58.517]                 else {
[13:18:58.517]                   if (TRUE) {
[13:18:58.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.517]                     {
[13:18:58.517]                       inherits <- base::inherits
[13:18:58.517]                       invokeRestart <- base::invokeRestart
[13:18:58.517]                       is.null <- base::is.null
[13:18:58.517]                       muffled <- FALSE
[13:18:58.517]                       if (inherits(cond, "message")) {
[13:18:58.517]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.517]                         if (muffled) 
[13:18:58.517]                           invokeRestart("muffleMessage")
[13:18:58.517]                       }
[13:18:58.517]                       else if (inherits(cond, "warning")) {
[13:18:58.517]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.517]                         if (muffled) 
[13:18:58.517]                           invokeRestart("muffleWarning")
[13:18:58.517]                       }
[13:18:58.517]                       else if (inherits(cond, "condition")) {
[13:18:58.517]                         if (!is.null(pattern)) {
[13:18:58.517]                           computeRestarts <- base::computeRestarts
[13:18:58.517]                           grepl <- base::grepl
[13:18:58.517]                           restarts <- computeRestarts(cond)
[13:18:58.517]                           for (restart in restarts) {
[13:18:58.517]                             name <- restart$name
[13:18:58.517]                             if (is.null(name)) 
[13:18:58.517]                               next
[13:18:58.517]                             if (!grepl(pattern, name)) 
[13:18:58.517]                               next
[13:18:58.517]                             invokeRestart(restart)
[13:18:58.517]                             muffled <- TRUE
[13:18:58.517]                             break
[13:18:58.517]                           }
[13:18:58.517]                         }
[13:18:58.517]                       }
[13:18:58.517]                       invisible(muffled)
[13:18:58.517]                     }
[13:18:58.517]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.517]                   }
[13:18:58.517]                 }
[13:18:58.517]             }
[13:18:58.517]         }))
[13:18:58.517]     }, error = function(ex) {
[13:18:58.517]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.517]                 ...future.rng), started = ...future.startTime, 
[13:18:58.517]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.517]             version = "1.8"), class = "FutureResult")
[13:18:58.517]     }, finally = {
[13:18:58.517]         if (!identical(...future.workdir, getwd())) 
[13:18:58.517]             setwd(...future.workdir)
[13:18:58.517]         {
[13:18:58.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.517]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.517]             }
[13:18:58.517]             base::options(...future.oldOptions)
[13:18:58.517]             if (.Platform$OS.type == "windows") {
[13:18:58.517]                 old_names <- names(...future.oldEnvVars)
[13:18:58.517]                 envs <- base::Sys.getenv()
[13:18:58.517]                 names <- names(envs)
[13:18:58.517]                 common <- intersect(names, old_names)
[13:18:58.517]                 added <- setdiff(names, old_names)
[13:18:58.517]                 removed <- setdiff(old_names, names)
[13:18:58.517]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.517]                   envs[common]]
[13:18:58.517]                 NAMES <- toupper(changed)
[13:18:58.517]                 args <- list()
[13:18:58.517]                 for (kk in seq_along(NAMES)) {
[13:18:58.517]                   name <- changed[[kk]]
[13:18:58.517]                   NAME <- NAMES[[kk]]
[13:18:58.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.517]                     next
[13:18:58.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.517]                 }
[13:18:58.517]                 NAMES <- toupper(added)
[13:18:58.517]                 for (kk in seq_along(NAMES)) {
[13:18:58.517]                   name <- added[[kk]]
[13:18:58.517]                   NAME <- NAMES[[kk]]
[13:18:58.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.517]                     next
[13:18:58.517]                   args[[name]] <- ""
[13:18:58.517]                 }
[13:18:58.517]                 NAMES <- toupper(removed)
[13:18:58.517]                 for (kk in seq_along(NAMES)) {
[13:18:58.517]                   name <- removed[[kk]]
[13:18:58.517]                   NAME <- NAMES[[kk]]
[13:18:58.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.517]                     next
[13:18:58.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.517]                 }
[13:18:58.517]                 if (length(args) > 0) 
[13:18:58.517]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.517]             }
[13:18:58.517]             else {
[13:18:58.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.517]             }
[13:18:58.517]             {
[13:18:58.517]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.517]                   0L) {
[13:18:58.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.517]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.517]                   base::options(opts)
[13:18:58.517]                 }
[13:18:58.517]                 {
[13:18:58.517]                   {
[13:18:58.517]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.517]                     NULL
[13:18:58.517]                   }
[13:18:58.517]                   options(future.plan = NULL)
[13:18:58.517]                   if (is.na(NA_character_)) 
[13:18:58.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.517]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.517]                     envir = parent.frame()) 
[13:18:58.517]                   {
[13:18:58.517]                     default_workers <- missing(workers)
[13:18:58.517]                     if (is.function(workers)) 
[13:18:58.517]                       workers <- workers()
[13:18:58.517]                     workers <- structure(as.integer(workers), 
[13:18:58.517]                       class = class(workers))
[13:18:58.517]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.517]                       1L)
[13:18:58.517]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.517]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.517]                       if (default_workers) 
[13:18:58.517]                         supportsMulticore(warn = TRUE)
[13:18:58.517]                       return(sequential(..., envir = envir))
[13:18:58.517]                     }
[13:18:58.517]                     oopts <- options(mc.cores = workers)
[13:18:58.517]                     on.exit(options(oopts))
[13:18:58.517]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.517]                       envir = envir)
[13:18:58.517]                     if (!future$lazy) 
[13:18:58.517]                       future <- run(future)
[13:18:58.517]                     invisible(future)
[13:18:58.517]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.517]                 }
[13:18:58.517]             }
[13:18:58.517]         }
[13:18:58.517]     })
[13:18:58.517]     if (TRUE) {
[13:18:58.517]         base::sink(type = "output", split = FALSE)
[13:18:58.517]         if (TRUE) {
[13:18:58.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.517]         }
[13:18:58.517]         else {
[13:18:58.517]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.517]         }
[13:18:58.517]         base::close(...future.stdout)
[13:18:58.517]         ...future.stdout <- NULL
[13:18:58.517]     }
[13:18:58.517]     ...future.result$conditions <- ...future.conditions
[13:18:58.517]     ...future.result$finished <- base::Sys.time()
[13:18:58.517]     ...future.result
[13:18:58.517] }
[13:18:58.520] assign_globals() ...
[13:18:58.520] List of 11
[13:18:58.520]  $ ...future.FUN            :function (x, ...)  
[13:18:58.520]  $ x_FUN                    :function (x)  
[13:18:58.520]  $ times                    : int 0
[13:18:58.520]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.520]  $ stop_if_not              :function (...)  
[13:18:58.520]  $ dim                      : NULL
[13:18:58.520]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:58.520]  $ future.call.arguments    : list()
[13:18:58.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.520]  $ ...future.elements_ii    :List of 5
[13:18:58.520]   ..$ : int 1
[13:18:58.520]   ..$ : int 2
[13:18:58.520]   ..$ : int 3
[13:18:58.520]   ..$ : int 4
[13:18:58.520]   ..$ : int 5
[13:18:58.520]  $ ...future.seeds_ii       : NULL
[13:18:58.520]  $ ...future.globals.maxSize: NULL
[13:18:58.520]  - attr(*, "resolved")= logi FALSE
[13:18:58.520]  - attr(*, "total_size")= num 95400
[13:18:58.520]  - attr(*, "where")=List of 11
[13:18:58.520]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.520]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.520]  - attr(*, "already-done")= logi TRUE
[13:18:58.528] - copied ‘...future.FUN’ to environment
[13:18:58.529] - reassign environment for ‘x_FUN’
[13:18:58.529] - copied ‘x_FUN’ to environment
[13:18:58.529] - copied ‘times’ to environment
[13:18:58.529] - copied ‘stopf’ to environment
[13:18:58.529] - copied ‘stop_if_not’ to environment
[13:18:58.529] - copied ‘dim’ to environment
[13:18:58.529] - copied ‘valid_types’ to environment
[13:18:58.529] - copied ‘future.call.arguments’ to environment
[13:18:58.529] - copied ‘...future.elements_ii’ to environment
[13:18:58.529] - copied ‘...future.seeds_ii’ to environment
[13:18:58.530] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.530] assign_globals() ... done
[13:18:58.530] requestCore(): workers = 2
[13:18:58.532] MulticoreFuture started
[13:18:58.532] - Launch lazy future ... done
[13:18:58.532] run() for ‘MulticoreFuture’ ... done
[13:18:58.533] Created future:
[13:18:58.533] plan(): Setting new future strategy stack:
[13:18:58.534] List of future strategies:
[13:18:58.534] 1. sequential:
[13:18:58.534]    - args: function (..., envir = parent.frame())
[13:18:58.534]    - tweaked: FALSE
[13:18:58.534]    - call: NULL
[13:18:58.535] plan(): nbrOfWorkers() = 1
[13:18:58.537] plan(): Setting new future strategy stack:
[13:18:58.537] List of future strategies:
[13:18:58.537] 1. multicore:
[13:18:58.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.537]    - tweaked: FALSE
[13:18:58.537]    - call: plan(strategy)
[13:18:58.542] plan(): nbrOfWorkers() = 2
[13:18:58.533] MulticoreFuture:
[13:18:58.533] Label: ‘future_vapply-1’
[13:18:58.533] Expression:
[13:18:58.533] {
[13:18:58.533]     do.call(function(...) {
[13:18:58.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.533]             on.exit(options(oopts), add = TRUE)
[13:18:58.533]         }
[13:18:58.533]         {
[13:18:58.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.533]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.533]             })
[13:18:58.533]         }
[13:18:58.533]     }, args = future.call.arguments)
[13:18:58.533] }
[13:18:58.533] Lazy evaluation: FALSE
[13:18:58.533] Asynchronous evaluation: TRUE
[13:18:58.533] Local evaluation: TRUE
[13:18:58.533] Environment: R_GlobalEnv
[13:18:58.533] Capture standard output: TRUE
[13:18:58.533] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.533] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.533] Packages: 1 packages (‘future.apply’)
[13:18:58.533] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.533] Resolved: TRUE
[13:18:58.533] Value: <not collected>
[13:18:58.533] Conditions captured: <none>
[13:18:58.533] Early signaling: FALSE
[13:18:58.533] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.533] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.543] Chunk #1 of 2 ... DONE
[13:18:58.544] Chunk #2 of 2 ...
[13:18:58.544]  - Finding globals in 'X' for chunk #2 ...
[13:18:58.544] getGlobalsAndPackages() ...
[13:18:58.544] Searching for globals...
[13:18:58.545] 
[13:18:58.545] Searching for globals ... DONE
[13:18:58.545] - globals: [0] <none>
[13:18:58.545] getGlobalsAndPackages() ... DONE
[13:18:58.545]    + additional globals found: [n=0] 
[13:18:58.545]    + additional namespaces needed: [n=0] 
[13:18:58.545]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:58.546]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.546]  - seeds: <none>
[13:18:58.546] getGlobalsAndPackages() ...
[13:18:58.546] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.546] Resolving globals: FALSE
[13:18:58.547] Tweak future expression to call with '...' arguments ...
[13:18:58.547] {
[13:18:58.547]     do.call(function(...) {
[13:18:58.547]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.547]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.547]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.547]             on.exit(options(oopts), add = TRUE)
[13:18:58.547]         }
[13:18:58.547]         {
[13:18:58.547]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.547]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.547]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.547]             })
[13:18:58.547]         }
[13:18:58.547]     }, args = future.call.arguments)
[13:18:58.547] }
[13:18:58.547] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.548] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.548] - packages: [1] ‘future.apply’
[13:18:58.549] getGlobalsAndPackages() ... DONE
[13:18:58.549] run() for ‘Future’ ...
[13:18:58.549] - state: ‘created’
[13:18:58.550] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.558] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.559]   - Field: ‘label’
[13:18:58.559]   - Field: ‘local’
[13:18:58.560]   - Field: ‘owner’
[13:18:58.560]   - Field: ‘envir’
[13:18:58.560]   - Field: ‘workers’
[13:18:58.561]   - Field: ‘packages’
[13:18:58.561]   - Field: ‘gc’
[13:18:58.561]   - Field: ‘job’
[13:18:58.561]   - Field: ‘conditions’
[13:18:58.562]   - Field: ‘expr’
[13:18:58.562]   - Field: ‘uuid’
[13:18:58.562]   - Field: ‘seed’
[13:18:58.562]   - Field: ‘version’
[13:18:58.563]   - Field: ‘result’
[13:18:58.563]   - Field: ‘asynchronous’
[13:18:58.563]   - Field: ‘calls’
[13:18:58.563]   - Field: ‘globals’
[13:18:58.564]   - Field: ‘stdout’
[13:18:58.564]   - Field: ‘earlySignal’
[13:18:58.564]   - Field: ‘lazy’
[13:18:58.564]   - Field: ‘state’
[13:18:58.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.565] - Launch lazy future ...
[13:18:58.565] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.566] Packages needed by future strategies (n = 0): <none>
[13:18:58.567] {
[13:18:58.567]     {
[13:18:58.567]         {
[13:18:58.567]             ...future.startTime <- base::Sys.time()
[13:18:58.567]             {
[13:18:58.567]                 {
[13:18:58.567]                   {
[13:18:58.567]                     {
[13:18:58.567]                       {
[13:18:58.567]                         base::local({
[13:18:58.567]                           has_future <- base::requireNamespace("future", 
[13:18:58.567]                             quietly = TRUE)
[13:18:58.567]                           if (has_future) {
[13:18:58.567]                             ns <- base::getNamespace("future")
[13:18:58.567]                             version <- ns[[".package"]][["version"]]
[13:18:58.567]                             if (is.null(version)) 
[13:18:58.567]                               version <- utils::packageVersion("future")
[13:18:58.567]                           }
[13:18:58.567]                           else {
[13:18:58.567]                             version <- NULL
[13:18:58.567]                           }
[13:18:58.567]                           if (!has_future || version < "1.8.0") {
[13:18:58.567]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.567]                               "", base::R.version$version.string), 
[13:18:58.567]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.567]                                 base::R.version$platform, 8 * 
[13:18:58.567]                                   base::.Machine$sizeof.pointer), 
[13:18:58.567]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.567]                                 "release", "version")], collapse = " "), 
[13:18:58.567]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.567]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.567]                               info)
[13:18:58.567]                             info <- base::paste(info, collapse = "; ")
[13:18:58.567]                             if (!has_future) {
[13:18:58.567]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.567]                                 info)
[13:18:58.567]                             }
[13:18:58.567]                             else {
[13:18:58.567]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.567]                                 info, version)
[13:18:58.567]                             }
[13:18:58.567]                             base::stop(msg)
[13:18:58.567]                           }
[13:18:58.567]                         })
[13:18:58.567]                       }
[13:18:58.567]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.567]                       base::options(mc.cores = 1L)
[13:18:58.567]                     }
[13:18:58.567]                     base::local({
[13:18:58.567]                       for (pkg in "future.apply") {
[13:18:58.567]                         base::loadNamespace(pkg)
[13:18:58.567]                         base::library(pkg, character.only = TRUE)
[13:18:58.567]                       }
[13:18:58.567]                     })
[13:18:58.567]                   }
[13:18:58.567]                   options(future.plan = NULL)
[13:18:58.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.567]                 }
[13:18:58.567]                 ...future.workdir <- getwd()
[13:18:58.567]             }
[13:18:58.567]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.567]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.567]         }
[13:18:58.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.567]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.567]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.567]             base::names(...future.oldOptions))
[13:18:58.567]     }
[13:18:58.567]     if (FALSE) {
[13:18:58.567]     }
[13:18:58.567]     else {
[13:18:58.567]         if (TRUE) {
[13:18:58.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.567]                 open = "w")
[13:18:58.567]         }
[13:18:58.567]         else {
[13:18:58.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.567]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.567]         }
[13:18:58.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.567]             base::sink(type = "output", split = FALSE)
[13:18:58.567]             base::close(...future.stdout)
[13:18:58.567]         }, add = TRUE)
[13:18:58.567]     }
[13:18:58.567]     ...future.frame <- base::sys.nframe()
[13:18:58.567]     ...future.conditions <- base::list()
[13:18:58.567]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.567]     if (FALSE) {
[13:18:58.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.567]     }
[13:18:58.567]     ...future.result <- base::tryCatch({
[13:18:58.567]         base::withCallingHandlers({
[13:18:58.567]             ...future.value <- base::withVisible(base::local({
[13:18:58.567]                 withCallingHandlers({
[13:18:58.567]                   {
[13:18:58.567]                     do.call(function(...) {
[13:18:58.567]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.567]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.567]                         ...future.globals.maxSize)) {
[13:18:58.567]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.567]                         on.exit(options(oopts), add = TRUE)
[13:18:58.567]                       }
[13:18:58.567]                       {
[13:18:58.567]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.567]                           FUN = function(jj) {
[13:18:58.567]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.567]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.567]                           })
[13:18:58.567]                       }
[13:18:58.567]                     }, args = future.call.arguments)
[13:18:58.567]                   }
[13:18:58.567]                 }, immediateCondition = function(cond) {
[13:18:58.567]                   save_rds <- function (object, pathname, ...) 
[13:18:58.567]                   {
[13:18:58.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.567]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.567]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.567]                         fi_tmp[["mtime"]])
[13:18:58.567]                     }
[13:18:58.567]                     tryCatch({
[13:18:58.567]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.567]                     }, error = function(ex) {
[13:18:58.567]                       msg <- conditionMessage(ex)
[13:18:58.567]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.567]                         fi_tmp[["mtime"]], msg)
[13:18:58.567]                       ex$message <- msg
[13:18:58.567]                       stop(ex)
[13:18:58.567]                     })
[13:18:58.567]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.567]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.567]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.567]                       fi <- file.info(pathname)
[13:18:58.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.567]                         fi[["size"]], fi[["mtime"]])
[13:18:58.567]                       stop(msg)
[13:18:58.567]                     }
[13:18:58.567]                     invisible(pathname)
[13:18:58.567]                   }
[13:18:58.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.567]                     rootPath = tempdir()) 
[13:18:58.567]                   {
[13:18:58.567]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.567]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.567]                       tmpdir = path, fileext = ".rds")
[13:18:58.567]                     save_rds(obj, file)
[13:18:58.567]                   }
[13:18:58.567]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.567]                   {
[13:18:58.567]                     inherits <- base::inherits
[13:18:58.567]                     invokeRestart <- base::invokeRestart
[13:18:58.567]                     is.null <- base::is.null
[13:18:58.567]                     muffled <- FALSE
[13:18:58.567]                     if (inherits(cond, "message")) {
[13:18:58.567]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.567]                       if (muffled) 
[13:18:58.567]                         invokeRestart("muffleMessage")
[13:18:58.567]                     }
[13:18:58.567]                     else if (inherits(cond, "warning")) {
[13:18:58.567]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.567]                       if (muffled) 
[13:18:58.567]                         invokeRestart("muffleWarning")
[13:18:58.567]                     }
[13:18:58.567]                     else if (inherits(cond, "condition")) {
[13:18:58.567]                       if (!is.null(pattern)) {
[13:18:58.567]                         computeRestarts <- base::computeRestarts
[13:18:58.567]                         grepl <- base::grepl
[13:18:58.567]                         restarts <- computeRestarts(cond)
[13:18:58.567]                         for (restart in restarts) {
[13:18:58.567]                           name <- restart$name
[13:18:58.567]                           if (is.null(name)) 
[13:18:58.567]                             next
[13:18:58.567]                           if (!grepl(pattern, name)) 
[13:18:58.567]                             next
[13:18:58.567]                           invokeRestart(restart)
[13:18:58.567]                           muffled <- TRUE
[13:18:58.567]                           break
[13:18:58.567]                         }
[13:18:58.567]                       }
[13:18:58.567]                     }
[13:18:58.567]                     invisible(muffled)
[13:18:58.567]                   }
[13:18:58.567]                   muffleCondition(cond)
[13:18:58.567]                 })
[13:18:58.567]             }))
[13:18:58.567]             future::FutureResult(value = ...future.value$value, 
[13:18:58.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.567]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.567]                     ...future.globalenv.names))
[13:18:58.567]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.567]         }, condition = base::local({
[13:18:58.567]             c <- base::c
[13:18:58.567]             inherits <- base::inherits
[13:18:58.567]             invokeRestart <- base::invokeRestart
[13:18:58.567]             length <- base::length
[13:18:58.567]             list <- base::list
[13:18:58.567]             seq.int <- base::seq.int
[13:18:58.567]             signalCondition <- base::signalCondition
[13:18:58.567]             sys.calls <- base::sys.calls
[13:18:58.567]             `[[` <- base::`[[`
[13:18:58.567]             `+` <- base::`+`
[13:18:58.567]             `<<-` <- base::`<<-`
[13:18:58.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.567]                   3L)]
[13:18:58.567]             }
[13:18:58.567]             function(cond) {
[13:18:58.567]                 is_error <- inherits(cond, "error")
[13:18:58.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.567]                   NULL)
[13:18:58.567]                 if (is_error) {
[13:18:58.567]                   sessionInformation <- function() {
[13:18:58.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.567]                       search = base::search(), system = base::Sys.info())
[13:18:58.567]                   }
[13:18:58.567]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.567]                     cond$call), session = sessionInformation(), 
[13:18:58.567]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.567]                   signalCondition(cond)
[13:18:58.567]                 }
[13:18:58.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.567]                 "immediateCondition"))) {
[13:18:58.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.567]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.567]                   if (TRUE && !signal) {
[13:18:58.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.567]                     {
[13:18:58.567]                       inherits <- base::inherits
[13:18:58.567]                       invokeRestart <- base::invokeRestart
[13:18:58.567]                       is.null <- base::is.null
[13:18:58.567]                       muffled <- FALSE
[13:18:58.567]                       if (inherits(cond, "message")) {
[13:18:58.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.567]                         if (muffled) 
[13:18:58.567]                           invokeRestart("muffleMessage")
[13:18:58.567]                       }
[13:18:58.567]                       else if (inherits(cond, "warning")) {
[13:18:58.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.567]                         if (muffled) 
[13:18:58.567]                           invokeRestart("muffleWarning")
[13:18:58.567]                       }
[13:18:58.567]                       else if (inherits(cond, "condition")) {
[13:18:58.567]                         if (!is.null(pattern)) {
[13:18:58.567]                           computeRestarts <- base::computeRestarts
[13:18:58.567]                           grepl <- base::grepl
[13:18:58.567]                           restarts <- computeRestarts(cond)
[13:18:58.567]                           for (restart in restarts) {
[13:18:58.567]                             name <- restart$name
[13:18:58.567]                             if (is.null(name)) 
[13:18:58.567]                               next
[13:18:58.567]                             if (!grepl(pattern, name)) 
[13:18:58.567]                               next
[13:18:58.567]                             invokeRestart(restart)
[13:18:58.567]                             muffled <- TRUE
[13:18:58.567]                             break
[13:18:58.567]                           }
[13:18:58.567]                         }
[13:18:58.567]                       }
[13:18:58.567]                       invisible(muffled)
[13:18:58.567]                     }
[13:18:58.567]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.567]                   }
[13:18:58.567]                 }
[13:18:58.567]                 else {
[13:18:58.567]                   if (TRUE) {
[13:18:58.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.567]                     {
[13:18:58.567]                       inherits <- base::inherits
[13:18:58.567]                       invokeRestart <- base::invokeRestart
[13:18:58.567]                       is.null <- base::is.null
[13:18:58.567]                       muffled <- FALSE
[13:18:58.567]                       if (inherits(cond, "message")) {
[13:18:58.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.567]                         if (muffled) 
[13:18:58.567]                           invokeRestart("muffleMessage")
[13:18:58.567]                       }
[13:18:58.567]                       else if (inherits(cond, "warning")) {
[13:18:58.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.567]                         if (muffled) 
[13:18:58.567]                           invokeRestart("muffleWarning")
[13:18:58.567]                       }
[13:18:58.567]                       else if (inherits(cond, "condition")) {
[13:18:58.567]                         if (!is.null(pattern)) {
[13:18:58.567]                           computeRestarts <- base::computeRestarts
[13:18:58.567]                           grepl <- base::grepl
[13:18:58.567]                           restarts <- computeRestarts(cond)
[13:18:58.567]                           for (restart in restarts) {
[13:18:58.567]                             name <- restart$name
[13:18:58.567]                             if (is.null(name)) 
[13:18:58.567]                               next
[13:18:58.567]                             if (!grepl(pattern, name)) 
[13:18:58.567]                               next
[13:18:58.567]                             invokeRestart(restart)
[13:18:58.567]                             muffled <- TRUE
[13:18:58.567]                             break
[13:18:58.567]                           }
[13:18:58.567]                         }
[13:18:58.567]                       }
[13:18:58.567]                       invisible(muffled)
[13:18:58.567]                     }
[13:18:58.567]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.567]                   }
[13:18:58.567]                 }
[13:18:58.567]             }
[13:18:58.567]         }))
[13:18:58.567]     }, error = function(ex) {
[13:18:58.567]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.567]                 ...future.rng), started = ...future.startTime, 
[13:18:58.567]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.567]             version = "1.8"), class = "FutureResult")
[13:18:58.567]     }, finally = {
[13:18:58.567]         if (!identical(...future.workdir, getwd())) 
[13:18:58.567]             setwd(...future.workdir)
[13:18:58.567]         {
[13:18:58.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.567]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.567]             }
[13:18:58.567]             base::options(...future.oldOptions)
[13:18:58.567]             if (.Platform$OS.type == "windows") {
[13:18:58.567]                 old_names <- names(...future.oldEnvVars)
[13:18:58.567]                 envs <- base::Sys.getenv()
[13:18:58.567]                 names <- names(envs)
[13:18:58.567]                 common <- intersect(names, old_names)
[13:18:58.567]                 added <- setdiff(names, old_names)
[13:18:58.567]                 removed <- setdiff(old_names, names)
[13:18:58.567]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.567]                   envs[common]]
[13:18:58.567]                 NAMES <- toupper(changed)
[13:18:58.567]                 args <- list()
[13:18:58.567]                 for (kk in seq_along(NAMES)) {
[13:18:58.567]                   name <- changed[[kk]]
[13:18:58.567]                   NAME <- NAMES[[kk]]
[13:18:58.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.567]                     next
[13:18:58.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.567]                 }
[13:18:58.567]                 NAMES <- toupper(added)
[13:18:58.567]                 for (kk in seq_along(NAMES)) {
[13:18:58.567]                   name <- added[[kk]]
[13:18:58.567]                   NAME <- NAMES[[kk]]
[13:18:58.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.567]                     next
[13:18:58.567]                   args[[name]] <- ""
[13:18:58.567]                 }
[13:18:58.567]                 NAMES <- toupper(removed)
[13:18:58.567]                 for (kk in seq_along(NAMES)) {
[13:18:58.567]                   name <- removed[[kk]]
[13:18:58.567]                   NAME <- NAMES[[kk]]
[13:18:58.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.567]                     next
[13:18:58.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.567]                 }
[13:18:58.567]                 if (length(args) > 0) 
[13:18:58.567]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.567]             }
[13:18:58.567]             else {
[13:18:58.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.567]             }
[13:18:58.567]             {
[13:18:58.567]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.567]                   0L) {
[13:18:58.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.567]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.567]                   base::options(opts)
[13:18:58.567]                 }
[13:18:58.567]                 {
[13:18:58.567]                   {
[13:18:58.567]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.567]                     NULL
[13:18:58.567]                   }
[13:18:58.567]                   options(future.plan = NULL)
[13:18:58.567]                   if (is.na(NA_character_)) 
[13:18:58.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.567]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.567]                     envir = parent.frame()) 
[13:18:58.567]                   {
[13:18:58.567]                     default_workers <- missing(workers)
[13:18:58.567]                     if (is.function(workers)) 
[13:18:58.567]                       workers <- workers()
[13:18:58.567]                     workers <- structure(as.integer(workers), 
[13:18:58.567]                       class = class(workers))
[13:18:58.567]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.567]                       1L)
[13:18:58.567]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.567]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.567]                       if (default_workers) 
[13:18:58.567]                         supportsMulticore(warn = TRUE)
[13:18:58.567]                       return(sequential(..., envir = envir))
[13:18:58.567]                     }
[13:18:58.567]                     oopts <- options(mc.cores = workers)
[13:18:58.567]                     on.exit(options(oopts))
[13:18:58.567]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.567]                       envir = envir)
[13:18:58.567]                     if (!future$lazy) 
[13:18:58.567]                       future <- run(future)
[13:18:58.567]                     invisible(future)
[13:18:58.567]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.567]                 }
[13:18:58.567]             }
[13:18:58.567]         }
[13:18:58.567]     })
[13:18:58.567]     if (TRUE) {
[13:18:58.567]         base::sink(type = "output", split = FALSE)
[13:18:58.567]         if (TRUE) {
[13:18:58.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.567]         }
[13:18:58.567]         else {
[13:18:58.567]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.567]         }
[13:18:58.567]         base::close(...future.stdout)
[13:18:58.567]         ...future.stdout <- NULL
[13:18:58.567]     }
[13:18:58.567]     ...future.result$conditions <- ...future.conditions
[13:18:58.567]     ...future.result$finished <- base::Sys.time()
[13:18:58.567]     ...future.result
[13:18:58.567] }
[13:18:58.570] assign_globals() ...
[13:18:58.570] List of 11
[13:18:58.570]  $ ...future.FUN            :function (x, ...)  
[13:18:58.570]  $ x_FUN                    :function (x)  
[13:18:58.570]  $ times                    : int 0
[13:18:58.570]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.570]  $ stop_if_not              :function (...)  
[13:18:58.570]  $ dim                      : NULL
[13:18:58.570]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:58.570]  $ future.call.arguments    : list()
[13:18:58.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.570]  $ ...future.elements_ii    :List of 5
[13:18:58.570]   ..$ : int 6
[13:18:58.570]   ..$ : int 7
[13:18:58.570]   ..$ : int 8
[13:18:58.570]   ..$ : int 9
[13:18:58.570]   ..$ : int 10
[13:18:58.570]  $ ...future.seeds_ii       : NULL
[13:18:58.570]  $ ...future.globals.maxSize: NULL
[13:18:58.570]  - attr(*, "resolved")= logi FALSE
[13:18:58.570]  - attr(*, "total_size")= num 95400
[13:18:58.570]  - attr(*, "where")=List of 11
[13:18:58.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.570]  - attr(*, "already-done")= logi TRUE
[13:18:58.582] - copied ‘...future.FUN’ to environment
[13:18:58.582] - reassign environment for ‘x_FUN’
[13:18:58.583] - copied ‘x_FUN’ to environment
[13:18:58.583] - copied ‘times’ to environment
[13:18:58.583] - copied ‘stopf’ to environment
[13:18:58.583] - copied ‘stop_if_not’ to environment
[13:18:58.583] - copied ‘dim’ to environment
[13:18:58.583] - copied ‘valid_types’ to environment
[13:18:58.583] - copied ‘future.call.arguments’ to environment
[13:18:58.583] - copied ‘...future.elements_ii’ to environment
[13:18:58.583] - copied ‘...future.seeds_ii’ to environment
[13:18:58.583] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.584] assign_globals() ... done
[13:18:58.584] requestCore(): workers = 2
[13:18:58.586] MulticoreFuture started
[13:18:58.586] - Launch lazy future ... done
[13:18:58.587] run() for ‘MulticoreFuture’ ... done
[13:18:58.587] Created future:
[13:18:58.587] plan(): Setting new future strategy stack:
[13:18:58.588] List of future strategies:
[13:18:58.588] 1. sequential:
[13:18:58.588]    - args: function (..., envir = parent.frame())
[13:18:58.588]    - tweaked: FALSE
[13:18:58.588]    - call: NULL
[13:18:58.588] plan(): nbrOfWorkers() = 1
[13:18:58.591] plan(): Setting new future strategy stack:
[13:18:58.591] List of future strategies:
[13:18:58.591] 1. multicore:
[13:18:58.591]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.591]    - tweaked: FALSE
[13:18:58.591]    - call: plan(strategy)
[13:18:58.596] plan(): nbrOfWorkers() = 2
[13:18:58.587] MulticoreFuture:
[13:18:58.587] Label: ‘future_vapply-2’
[13:18:58.587] Expression:
[13:18:58.587] {
[13:18:58.587]     do.call(function(...) {
[13:18:58.587]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.587]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.587]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.587]             on.exit(options(oopts), add = TRUE)
[13:18:58.587]         }
[13:18:58.587]         {
[13:18:58.587]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.587]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.587]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.587]             })
[13:18:58.587]         }
[13:18:58.587]     }, args = future.call.arguments)
[13:18:58.587] }
[13:18:58.587] Lazy evaluation: FALSE
[13:18:58.587] Asynchronous evaluation: TRUE
[13:18:58.587] Local evaluation: TRUE
[13:18:58.587] Environment: R_GlobalEnv
[13:18:58.587] Capture standard output: TRUE
[13:18:58.587] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.587] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.587] Packages: 1 packages (‘future.apply’)
[13:18:58.587] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.587] Resolved: TRUE
[13:18:58.587] Value: <not collected>
[13:18:58.587] Conditions captured: <none>
[13:18:58.587] Early signaling: FALSE
[13:18:58.587] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.587] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.597] Chunk #2 of 2 ... DONE
[13:18:58.597] Launching 2 futures (chunks) ... DONE
[13:18:58.597] Resolving 2 futures (chunks) ...
[13:18:58.597] resolve() on list ...
[13:18:58.598]  recursive: 0
[13:18:58.598]  length: 2
[13:18:58.598] 
[13:18:58.598] Future #1
[13:18:58.599] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:58.599] - nx: 2
[13:18:58.599] - relay: TRUE
[13:18:58.600] - stdout: TRUE
[13:18:58.600] - signal: TRUE
[13:18:58.600] - resignal: FALSE
[13:18:58.600] - force: TRUE
[13:18:58.600] - relayed: [n=2] FALSE, FALSE
[13:18:58.600] - queued futures: [n=2] FALSE, FALSE
[13:18:58.600]  - until=1
[13:18:58.601]  - relaying element #1
[13:18:58.604] - relayed: [n=2] TRUE, FALSE
[13:18:58.605] - queued futures: [n=2] TRUE, FALSE
[13:18:58.605] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:58.606]  length: 1 (resolved future 1)
[13:18:58.606] Future #2
[13:18:58.608] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:58.608] - nx: 2
[13:18:58.608] - relay: TRUE
[13:18:58.609] - stdout: TRUE
[13:18:58.609] - signal: TRUE
[13:18:58.609] - resignal: FALSE
[13:18:58.609] - force: TRUE
[13:18:58.609] - relayed: [n=2] TRUE, FALSE
[13:18:58.610] - queued futures: [n=2] TRUE, FALSE
[13:18:58.610]  - until=2
[13:18:58.610]  - relaying element #2
[13:18:58.610] - relayed: [n=2] TRUE, TRUE
[13:18:58.610] - queued futures: [n=2] TRUE, TRUE
[13:18:58.611] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:58.611]  length: 0 (resolved future 2)
[13:18:58.611] Relaying remaining futures
[13:18:58.611] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.611] - nx: 2
[13:18:58.611] - relay: TRUE
[13:18:58.612] - stdout: TRUE
[13:18:58.612] - signal: TRUE
[13:18:58.612] - resignal: FALSE
[13:18:58.612] - force: TRUE
[13:18:58.612] - relayed: [n=2] TRUE, TRUE
[13:18:58.612] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:58.612] - relayed: [n=2] TRUE, TRUE
[13:18:58.612] - queued futures: [n=2] TRUE, TRUE
[13:18:58.612] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.613] resolve() on list ... DONE
[13:18:58.613]  - Number of value chunks collected: 2
[13:18:58.613] Resolving 2 futures (chunks) ... DONE
[13:18:58.613] Reducing values from 2 chunks ...
[13:18:58.613]  - Number of values collected after concatenation: 10
[13:18:58.613]  - Number of values expected: 10
[13:18:58.613] Reducing values from 2 chunks ... DONE
[13:18:58.614] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:18:58.615] future_lapply() ...
[13:18:58.621] Number of chunks: 2
[13:18:58.622] getGlobalsAndPackagesXApply() ...
[13:18:58.622]  - future.globals: TRUE
[13:18:58.622] getGlobalsAndPackages() ...
[13:18:58.622] Searching for globals...
[13:18:58.625] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:58.626] Searching for globals ... DONE
[13:18:58.626] Resolving globals: FALSE
[13:18:58.627] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:18:58.627] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.627] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.627] - packages: [1] ‘future.apply’
[13:18:58.627] getGlobalsAndPackages() ... DONE
[13:18:58.628]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.628]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.628] Finding globals ... DONE
[13:18:58.628]  - use_args: TRUE
[13:18:58.628]  - Getting '...' globals ...
[13:18:58.628] resolve() on list ...
[13:18:58.628]  recursive: 0
[13:18:58.629]  length: 1
[13:18:58.629]  elements: ‘...’
[13:18:58.629]  length: 0 (resolved future 1)
[13:18:58.629] resolve() on list ... DONE
[13:18:58.629]    - '...' content: [n=0] 
[13:18:58.629] List of 1
[13:18:58.629]  $ ...: list()
[13:18:58.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.629]  - attr(*, "where")=List of 1
[13:18:58.629]   ..$ ...:<environment: 0x555f79f879d0> 
[13:18:58.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.629]  - attr(*, "resolved")= logi TRUE
[13:18:58.629]  - attr(*, "total_size")= num NA
[13:18:58.632]  - Getting '...' globals ... DONE
[13:18:58.632] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.632] List of 8
[13:18:58.632]  $ ...future.FUN:function (x, ...)  
[13:18:58.632]  $ x_FUN        :function (x)  
[13:18:58.632]  $ times        : int 1
[13:18:58.632]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.632]  $ stop_if_not  :function (...)  
[13:18:58.632]  $ dim          : NULL
[13:18:58.632]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:58.632]  $ ...          : list()
[13:18:58.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.632]  - attr(*, "where")=List of 8
[13:18:58.632]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.632]   ..$ ...          :<environment: 0x555f79f879d0> 
[13:18:58.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.632]  - attr(*, "resolved")= logi FALSE
[13:18:58.632]  - attr(*, "total_size")= num 94336
[13:18:58.640] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.640] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.640] Number of futures (= number of chunks): 2
[13:18:58.641] Launching 2 futures (chunks) ...
[13:18:58.641] Chunk #1 of 2 ...
[13:18:58.641]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.641] getGlobalsAndPackages() ...
[13:18:58.641] Searching for globals...
[13:18:58.641] 
[13:18:58.641] Searching for globals ... DONE
[13:18:58.642] - globals: [0] <none>
[13:18:58.642] getGlobalsAndPackages() ... DONE
[13:18:58.642]    + additional globals found: [n=0] 
[13:18:58.642]    + additional namespaces needed: [n=0] 
[13:18:58.642]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.642]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.642]  - seeds: <none>
[13:18:58.642] getGlobalsAndPackages() ...
[13:18:58.642] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.642] Resolving globals: FALSE
[13:18:58.643] Tweak future expression to call with '...' arguments ...
[13:18:58.643] {
[13:18:58.643]     do.call(function(...) {
[13:18:58.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.643]             on.exit(options(oopts), add = TRUE)
[13:18:58.643]         }
[13:18:58.643]         {
[13:18:58.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.643]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.643]             })
[13:18:58.643]         }
[13:18:58.643]     }, args = future.call.arguments)
[13:18:58.643] }
[13:18:58.643] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.643] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.644] - packages: [1] ‘future.apply’
[13:18:58.644] getGlobalsAndPackages() ... DONE
[13:18:58.644] run() for ‘Future’ ...
[13:18:58.644] - state: ‘created’
[13:18:58.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.648]   - Field: ‘label’
[13:18:58.648]   - Field: ‘local’
[13:18:58.648]   - Field: ‘owner’
[13:18:58.649]   - Field: ‘envir’
[13:18:58.649]   - Field: ‘workers’
[13:18:58.649]   - Field: ‘packages’
[13:18:58.649]   - Field: ‘gc’
[13:18:58.649]   - Field: ‘job’
[13:18:58.649]   - Field: ‘conditions’
[13:18:58.649]   - Field: ‘expr’
[13:18:58.649]   - Field: ‘uuid’
[13:18:58.649]   - Field: ‘seed’
[13:18:58.649]   - Field: ‘version’
[13:18:58.650]   - Field: ‘result’
[13:18:58.650]   - Field: ‘asynchronous’
[13:18:58.650]   - Field: ‘calls’
[13:18:58.650]   - Field: ‘globals’
[13:18:58.650]   - Field: ‘stdout’
[13:18:58.650]   - Field: ‘earlySignal’
[13:18:58.650]   - Field: ‘lazy’
[13:18:58.650]   - Field: ‘state’
[13:18:58.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.650] - Launch lazy future ...
[13:18:58.651] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.651] Packages needed by future strategies (n = 0): <none>
[13:18:58.651] {
[13:18:58.651]     {
[13:18:58.651]         {
[13:18:58.651]             ...future.startTime <- base::Sys.time()
[13:18:58.651]             {
[13:18:58.651]                 {
[13:18:58.651]                   {
[13:18:58.651]                     {
[13:18:58.651]                       {
[13:18:58.651]                         base::local({
[13:18:58.651]                           has_future <- base::requireNamespace("future", 
[13:18:58.651]                             quietly = TRUE)
[13:18:58.651]                           if (has_future) {
[13:18:58.651]                             ns <- base::getNamespace("future")
[13:18:58.651]                             version <- ns[[".package"]][["version"]]
[13:18:58.651]                             if (is.null(version)) 
[13:18:58.651]                               version <- utils::packageVersion("future")
[13:18:58.651]                           }
[13:18:58.651]                           else {
[13:18:58.651]                             version <- NULL
[13:18:58.651]                           }
[13:18:58.651]                           if (!has_future || version < "1.8.0") {
[13:18:58.651]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.651]                               "", base::R.version$version.string), 
[13:18:58.651]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.651]                                 base::R.version$platform, 8 * 
[13:18:58.651]                                   base::.Machine$sizeof.pointer), 
[13:18:58.651]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.651]                                 "release", "version")], collapse = " "), 
[13:18:58.651]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.651]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.651]                               info)
[13:18:58.651]                             info <- base::paste(info, collapse = "; ")
[13:18:58.651]                             if (!has_future) {
[13:18:58.651]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.651]                                 info)
[13:18:58.651]                             }
[13:18:58.651]                             else {
[13:18:58.651]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.651]                                 info, version)
[13:18:58.651]                             }
[13:18:58.651]                             base::stop(msg)
[13:18:58.651]                           }
[13:18:58.651]                         })
[13:18:58.651]                       }
[13:18:58.651]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.651]                       base::options(mc.cores = 1L)
[13:18:58.651]                     }
[13:18:58.651]                     base::local({
[13:18:58.651]                       for (pkg in "future.apply") {
[13:18:58.651]                         base::loadNamespace(pkg)
[13:18:58.651]                         base::library(pkg, character.only = TRUE)
[13:18:58.651]                       }
[13:18:58.651]                     })
[13:18:58.651]                   }
[13:18:58.651]                   options(future.plan = NULL)
[13:18:58.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.651]                 }
[13:18:58.651]                 ...future.workdir <- getwd()
[13:18:58.651]             }
[13:18:58.651]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.651]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.651]         }
[13:18:58.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.651]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.651]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.651]             base::names(...future.oldOptions))
[13:18:58.651]     }
[13:18:58.651]     if (FALSE) {
[13:18:58.651]     }
[13:18:58.651]     else {
[13:18:58.651]         if (TRUE) {
[13:18:58.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.651]                 open = "w")
[13:18:58.651]         }
[13:18:58.651]         else {
[13:18:58.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.651]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.651]         }
[13:18:58.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.651]             base::sink(type = "output", split = FALSE)
[13:18:58.651]             base::close(...future.stdout)
[13:18:58.651]         }, add = TRUE)
[13:18:58.651]     }
[13:18:58.651]     ...future.frame <- base::sys.nframe()
[13:18:58.651]     ...future.conditions <- base::list()
[13:18:58.651]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.651]     if (FALSE) {
[13:18:58.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.651]     }
[13:18:58.651]     ...future.result <- base::tryCatch({
[13:18:58.651]         base::withCallingHandlers({
[13:18:58.651]             ...future.value <- base::withVisible(base::local({
[13:18:58.651]                 withCallingHandlers({
[13:18:58.651]                   {
[13:18:58.651]                     do.call(function(...) {
[13:18:58.651]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.651]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.651]                         ...future.globals.maxSize)) {
[13:18:58.651]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.651]                         on.exit(options(oopts), add = TRUE)
[13:18:58.651]                       }
[13:18:58.651]                       {
[13:18:58.651]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.651]                           FUN = function(jj) {
[13:18:58.651]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.651]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.651]                           })
[13:18:58.651]                       }
[13:18:58.651]                     }, args = future.call.arguments)
[13:18:58.651]                   }
[13:18:58.651]                 }, immediateCondition = function(cond) {
[13:18:58.651]                   save_rds <- function (object, pathname, ...) 
[13:18:58.651]                   {
[13:18:58.651]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.651]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.651]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.651]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.651]                         fi_tmp[["mtime"]])
[13:18:58.651]                     }
[13:18:58.651]                     tryCatch({
[13:18:58.651]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.651]                     }, error = function(ex) {
[13:18:58.651]                       msg <- conditionMessage(ex)
[13:18:58.651]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.651]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.651]                         fi_tmp[["mtime"]], msg)
[13:18:58.651]                       ex$message <- msg
[13:18:58.651]                       stop(ex)
[13:18:58.651]                     })
[13:18:58.651]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.651]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.651]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.651]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.651]                       fi <- file.info(pathname)
[13:18:58.651]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.651]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.651]                         fi[["size"]], fi[["mtime"]])
[13:18:58.651]                       stop(msg)
[13:18:58.651]                     }
[13:18:58.651]                     invisible(pathname)
[13:18:58.651]                   }
[13:18:58.651]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.651]                     rootPath = tempdir()) 
[13:18:58.651]                   {
[13:18:58.651]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.651]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.651]                       tmpdir = path, fileext = ".rds")
[13:18:58.651]                     save_rds(obj, file)
[13:18:58.651]                   }
[13:18:58.651]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.651]                   {
[13:18:58.651]                     inherits <- base::inherits
[13:18:58.651]                     invokeRestart <- base::invokeRestart
[13:18:58.651]                     is.null <- base::is.null
[13:18:58.651]                     muffled <- FALSE
[13:18:58.651]                     if (inherits(cond, "message")) {
[13:18:58.651]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.651]                       if (muffled) 
[13:18:58.651]                         invokeRestart("muffleMessage")
[13:18:58.651]                     }
[13:18:58.651]                     else if (inherits(cond, "warning")) {
[13:18:58.651]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.651]                       if (muffled) 
[13:18:58.651]                         invokeRestart("muffleWarning")
[13:18:58.651]                     }
[13:18:58.651]                     else if (inherits(cond, "condition")) {
[13:18:58.651]                       if (!is.null(pattern)) {
[13:18:58.651]                         computeRestarts <- base::computeRestarts
[13:18:58.651]                         grepl <- base::grepl
[13:18:58.651]                         restarts <- computeRestarts(cond)
[13:18:58.651]                         for (restart in restarts) {
[13:18:58.651]                           name <- restart$name
[13:18:58.651]                           if (is.null(name)) 
[13:18:58.651]                             next
[13:18:58.651]                           if (!grepl(pattern, name)) 
[13:18:58.651]                             next
[13:18:58.651]                           invokeRestart(restart)
[13:18:58.651]                           muffled <- TRUE
[13:18:58.651]                           break
[13:18:58.651]                         }
[13:18:58.651]                       }
[13:18:58.651]                     }
[13:18:58.651]                     invisible(muffled)
[13:18:58.651]                   }
[13:18:58.651]                   muffleCondition(cond)
[13:18:58.651]                 })
[13:18:58.651]             }))
[13:18:58.651]             future::FutureResult(value = ...future.value$value, 
[13:18:58.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.651]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.651]                     ...future.globalenv.names))
[13:18:58.651]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.651]         }, condition = base::local({
[13:18:58.651]             c <- base::c
[13:18:58.651]             inherits <- base::inherits
[13:18:58.651]             invokeRestart <- base::invokeRestart
[13:18:58.651]             length <- base::length
[13:18:58.651]             list <- base::list
[13:18:58.651]             seq.int <- base::seq.int
[13:18:58.651]             signalCondition <- base::signalCondition
[13:18:58.651]             sys.calls <- base::sys.calls
[13:18:58.651]             `[[` <- base::`[[`
[13:18:58.651]             `+` <- base::`+`
[13:18:58.651]             `<<-` <- base::`<<-`
[13:18:58.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.651]                   3L)]
[13:18:58.651]             }
[13:18:58.651]             function(cond) {
[13:18:58.651]                 is_error <- inherits(cond, "error")
[13:18:58.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.651]                   NULL)
[13:18:58.651]                 if (is_error) {
[13:18:58.651]                   sessionInformation <- function() {
[13:18:58.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.651]                       search = base::search(), system = base::Sys.info())
[13:18:58.651]                   }
[13:18:58.651]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.651]                     cond$call), session = sessionInformation(), 
[13:18:58.651]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.651]                   signalCondition(cond)
[13:18:58.651]                 }
[13:18:58.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.651]                 "immediateCondition"))) {
[13:18:58.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.651]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.651]                   if (TRUE && !signal) {
[13:18:58.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.651]                     {
[13:18:58.651]                       inherits <- base::inherits
[13:18:58.651]                       invokeRestart <- base::invokeRestart
[13:18:58.651]                       is.null <- base::is.null
[13:18:58.651]                       muffled <- FALSE
[13:18:58.651]                       if (inherits(cond, "message")) {
[13:18:58.651]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.651]                         if (muffled) 
[13:18:58.651]                           invokeRestart("muffleMessage")
[13:18:58.651]                       }
[13:18:58.651]                       else if (inherits(cond, "warning")) {
[13:18:58.651]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.651]                         if (muffled) 
[13:18:58.651]                           invokeRestart("muffleWarning")
[13:18:58.651]                       }
[13:18:58.651]                       else if (inherits(cond, "condition")) {
[13:18:58.651]                         if (!is.null(pattern)) {
[13:18:58.651]                           computeRestarts <- base::computeRestarts
[13:18:58.651]                           grepl <- base::grepl
[13:18:58.651]                           restarts <- computeRestarts(cond)
[13:18:58.651]                           for (restart in restarts) {
[13:18:58.651]                             name <- restart$name
[13:18:58.651]                             if (is.null(name)) 
[13:18:58.651]                               next
[13:18:58.651]                             if (!grepl(pattern, name)) 
[13:18:58.651]                               next
[13:18:58.651]                             invokeRestart(restart)
[13:18:58.651]                             muffled <- TRUE
[13:18:58.651]                             break
[13:18:58.651]                           }
[13:18:58.651]                         }
[13:18:58.651]                       }
[13:18:58.651]                       invisible(muffled)
[13:18:58.651]                     }
[13:18:58.651]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.651]                   }
[13:18:58.651]                 }
[13:18:58.651]                 else {
[13:18:58.651]                   if (TRUE) {
[13:18:58.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.651]                     {
[13:18:58.651]                       inherits <- base::inherits
[13:18:58.651]                       invokeRestart <- base::invokeRestart
[13:18:58.651]                       is.null <- base::is.null
[13:18:58.651]                       muffled <- FALSE
[13:18:58.651]                       if (inherits(cond, "message")) {
[13:18:58.651]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.651]                         if (muffled) 
[13:18:58.651]                           invokeRestart("muffleMessage")
[13:18:58.651]                       }
[13:18:58.651]                       else if (inherits(cond, "warning")) {
[13:18:58.651]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.651]                         if (muffled) 
[13:18:58.651]                           invokeRestart("muffleWarning")
[13:18:58.651]                       }
[13:18:58.651]                       else if (inherits(cond, "condition")) {
[13:18:58.651]                         if (!is.null(pattern)) {
[13:18:58.651]                           computeRestarts <- base::computeRestarts
[13:18:58.651]                           grepl <- base::grepl
[13:18:58.651]                           restarts <- computeRestarts(cond)
[13:18:58.651]                           for (restart in restarts) {
[13:18:58.651]                             name <- restart$name
[13:18:58.651]                             if (is.null(name)) 
[13:18:58.651]                               next
[13:18:58.651]                             if (!grepl(pattern, name)) 
[13:18:58.651]                               next
[13:18:58.651]                             invokeRestart(restart)
[13:18:58.651]                             muffled <- TRUE
[13:18:58.651]                             break
[13:18:58.651]                           }
[13:18:58.651]                         }
[13:18:58.651]                       }
[13:18:58.651]                       invisible(muffled)
[13:18:58.651]                     }
[13:18:58.651]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.651]                   }
[13:18:58.651]                 }
[13:18:58.651]             }
[13:18:58.651]         }))
[13:18:58.651]     }, error = function(ex) {
[13:18:58.651]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.651]                 ...future.rng), started = ...future.startTime, 
[13:18:58.651]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.651]             version = "1.8"), class = "FutureResult")
[13:18:58.651]     }, finally = {
[13:18:58.651]         if (!identical(...future.workdir, getwd())) 
[13:18:58.651]             setwd(...future.workdir)
[13:18:58.651]         {
[13:18:58.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.651]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.651]             }
[13:18:58.651]             base::options(...future.oldOptions)
[13:18:58.651]             if (.Platform$OS.type == "windows") {
[13:18:58.651]                 old_names <- names(...future.oldEnvVars)
[13:18:58.651]                 envs <- base::Sys.getenv()
[13:18:58.651]                 names <- names(envs)
[13:18:58.651]                 common <- intersect(names, old_names)
[13:18:58.651]                 added <- setdiff(names, old_names)
[13:18:58.651]                 removed <- setdiff(old_names, names)
[13:18:58.651]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.651]                   envs[common]]
[13:18:58.651]                 NAMES <- toupper(changed)
[13:18:58.651]                 args <- list()
[13:18:58.651]                 for (kk in seq_along(NAMES)) {
[13:18:58.651]                   name <- changed[[kk]]
[13:18:58.651]                   NAME <- NAMES[[kk]]
[13:18:58.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.651]                     next
[13:18:58.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.651]                 }
[13:18:58.651]                 NAMES <- toupper(added)
[13:18:58.651]                 for (kk in seq_along(NAMES)) {
[13:18:58.651]                   name <- added[[kk]]
[13:18:58.651]                   NAME <- NAMES[[kk]]
[13:18:58.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.651]                     next
[13:18:58.651]                   args[[name]] <- ""
[13:18:58.651]                 }
[13:18:58.651]                 NAMES <- toupper(removed)
[13:18:58.651]                 for (kk in seq_along(NAMES)) {
[13:18:58.651]                   name <- removed[[kk]]
[13:18:58.651]                   NAME <- NAMES[[kk]]
[13:18:58.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.651]                     next
[13:18:58.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.651]                 }
[13:18:58.651]                 if (length(args) > 0) 
[13:18:58.651]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.651]             }
[13:18:58.651]             else {
[13:18:58.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.651]             }
[13:18:58.651]             {
[13:18:58.651]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.651]                   0L) {
[13:18:58.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.651]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.651]                   base::options(opts)
[13:18:58.651]                 }
[13:18:58.651]                 {
[13:18:58.651]                   {
[13:18:58.651]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.651]                     NULL
[13:18:58.651]                   }
[13:18:58.651]                   options(future.plan = NULL)
[13:18:58.651]                   if (is.na(NA_character_)) 
[13:18:58.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.651]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.651]                     envir = parent.frame()) 
[13:18:58.651]                   {
[13:18:58.651]                     default_workers <- missing(workers)
[13:18:58.651]                     if (is.function(workers)) 
[13:18:58.651]                       workers <- workers()
[13:18:58.651]                     workers <- structure(as.integer(workers), 
[13:18:58.651]                       class = class(workers))
[13:18:58.651]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.651]                       1L)
[13:18:58.651]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.651]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.651]                       if (default_workers) 
[13:18:58.651]                         supportsMulticore(warn = TRUE)
[13:18:58.651]                       return(sequential(..., envir = envir))
[13:18:58.651]                     }
[13:18:58.651]                     oopts <- options(mc.cores = workers)
[13:18:58.651]                     on.exit(options(oopts))
[13:18:58.651]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.651]                       envir = envir)
[13:18:58.651]                     if (!future$lazy) 
[13:18:58.651]                       future <- run(future)
[13:18:58.651]                     invisible(future)
[13:18:58.651]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.651]                 }
[13:18:58.651]             }
[13:18:58.651]         }
[13:18:58.651]     })
[13:18:58.651]     if (TRUE) {
[13:18:58.651]         base::sink(type = "output", split = FALSE)
[13:18:58.651]         if (TRUE) {
[13:18:58.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.651]         }
[13:18:58.651]         else {
[13:18:58.651]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.651]         }
[13:18:58.651]         base::close(...future.stdout)
[13:18:58.651]         ...future.stdout <- NULL
[13:18:58.651]     }
[13:18:58.651]     ...future.result$conditions <- ...future.conditions
[13:18:58.651]     ...future.result$finished <- base::Sys.time()
[13:18:58.651]     ...future.result
[13:18:58.651] }
[13:18:58.654] assign_globals() ...
[13:18:58.654] List of 11
[13:18:58.654]  $ ...future.FUN            :function (x, ...)  
[13:18:58.654]  $ x_FUN                    :function (x)  
[13:18:58.654]  $ times                    : int 1
[13:18:58.654]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.654]  $ stop_if_not              :function (...)  
[13:18:58.654]  $ dim                      : NULL
[13:18:58.654]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.654]  $ future.call.arguments    : list()
[13:18:58.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.654]  $ ...future.elements_ii    :List of 5
[13:18:58.654]   ..$ : int 1
[13:18:58.654]   ..$ : int 2
[13:18:58.654]   ..$ : int 3
[13:18:58.654]   ..$ : int 4
[13:18:58.654]   ..$ : int 5
[13:18:58.654]  $ ...future.seeds_ii       : NULL
[13:18:58.654]  $ ...future.globals.maxSize: NULL
[13:18:58.654]  - attr(*, "resolved")= logi FALSE
[13:18:58.654]  - attr(*, "total_size")= num 94336
[13:18:58.654]  - attr(*, "where")=List of 11
[13:18:58.654]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.654]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.654]  - attr(*, "already-done")= logi TRUE
[13:18:58.665] - copied ‘...future.FUN’ to environment
[13:18:58.665] - copied ‘x_FUN’ to environment
[13:18:58.665] - copied ‘times’ to environment
[13:18:58.666] - copied ‘stopf’ to environment
[13:18:58.666] - copied ‘stop_if_not’ to environment
[13:18:58.666] - copied ‘dim’ to environment
[13:18:58.666] - copied ‘valid_types’ to environment
[13:18:58.666] - copied ‘future.call.arguments’ to environment
[13:18:58.666] - copied ‘...future.elements_ii’ to environment
[13:18:58.666] - copied ‘...future.seeds_ii’ to environment
[13:18:58.666] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.666] assign_globals() ... done
[13:18:58.667] requestCore(): workers = 2
[13:18:58.669] MulticoreFuture started
[13:18:58.669] - Launch lazy future ... done
[13:18:58.669] run() for ‘MulticoreFuture’ ... done
[13:18:58.670] Created future:
[13:18:58.670] plan(): Setting new future strategy stack:
[13:18:58.671] List of future strategies:
[13:18:58.671] 1. sequential:
[13:18:58.671]    - args: function (..., envir = parent.frame())
[13:18:58.671]    - tweaked: FALSE
[13:18:58.671]    - call: NULL
[13:18:58.672] plan(): nbrOfWorkers() = 1
[13:18:58.674] plan(): Setting new future strategy stack:
[13:18:58.674] List of future strategies:
[13:18:58.674] 1. multicore:
[13:18:58.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.674]    - tweaked: FALSE
[13:18:58.674]    - call: plan(strategy)
[13:18:58.679] plan(): nbrOfWorkers() = 2
[13:18:58.670] MulticoreFuture:
[13:18:58.670] Label: ‘future_vapply-1’
[13:18:58.670] Expression:
[13:18:58.670] {
[13:18:58.670]     do.call(function(...) {
[13:18:58.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.670]             on.exit(options(oopts), add = TRUE)
[13:18:58.670]         }
[13:18:58.670]         {
[13:18:58.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.670]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.670]             })
[13:18:58.670]         }
[13:18:58.670]     }, args = future.call.arguments)
[13:18:58.670] }
[13:18:58.670] Lazy evaluation: FALSE
[13:18:58.670] Asynchronous evaluation: TRUE
[13:18:58.670] Local evaluation: TRUE
[13:18:58.670] Environment: R_GlobalEnv
[13:18:58.670] Capture standard output: TRUE
[13:18:58.670] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.670] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.670] Packages: 1 packages (‘future.apply’)
[13:18:58.670] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.670] Resolved: TRUE
[13:18:58.670] Value: <not collected>
[13:18:58.670] Conditions captured: <none>
[13:18:58.670] Early signaling: FALSE
[13:18:58.670] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.670] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.680] Chunk #1 of 2 ... DONE
[13:18:58.680] Chunk #2 of 2 ...
[13:18:58.681]  - Finding globals in 'X' for chunk #2 ...
[13:18:58.681] getGlobalsAndPackages() ...
[13:18:58.681] Searching for globals...
[13:18:58.681] 
[13:18:58.682] Searching for globals ... DONE
[13:18:58.682] - globals: [0] <none>
[13:18:58.682] getGlobalsAndPackages() ... DONE
[13:18:58.682]    + additional globals found: [n=0] 
[13:18:58.682]    + additional namespaces needed: [n=0] 
[13:18:58.682]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:58.682]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.683]  - seeds: <none>
[13:18:58.683] getGlobalsAndPackages() ...
[13:18:58.683] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.683] Resolving globals: FALSE
[13:18:58.683] Tweak future expression to call with '...' arguments ...
[13:18:58.684] {
[13:18:58.684]     do.call(function(...) {
[13:18:58.684]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.684]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.684]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.684]             on.exit(options(oopts), add = TRUE)
[13:18:58.684]         }
[13:18:58.684]         {
[13:18:58.684]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.684]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.684]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.684]             })
[13:18:58.684]         }
[13:18:58.684]     }, args = future.call.arguments)
[13:18:58.684] }
[13:18:58.684] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.685] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.685] - packages: [1] ‘future.apply’
[13:18:58.685] getGlobalsAndPackages() ... DONE
[13:18:58.686] run() for ‘Future’ ...
[13:18:58.686] - state: ‘created’
[13:18:58.686] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.691] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.691] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.691]   - Field: ‘label’
[13:18:58.691]   - Field: ‘local’
[13:18:58.692]   - Field: ‘owner’
[13:18:58.692]   - Field: ‘envir’
[13:18:58.692]   - Field: ‘workers’
[13:18:58.692]   - Field: ‘packages’
[13:18:58.692]   - Field: ‘gc’
[13:18:58.692]   - Field: ‘job’
[13:18:58.693]   - Field: ‘conditions’
[13:18:58.693]   - Field: ‘expr’
[13:18:58.693]   - Field: ‘uuid’
[13:18:58.693]   - Field: ‘seed’
[13:18:58.693]   - Field: ‘version’
[13:18:58.693]   - Field: ‘result’
[13:18:58.694]   - Field: ‘asynchronous’
[13:18:58.694]   - Field: ‘calls’
[13:18:58.694]   - Field: ‘globals’
[13:18:58.694]   - Field: ‘stdout’
[13:18:58.694]   - Field: ‘earlySignal’
[13:18:58.694]   - Field: ‘lazy’
[13:18:58.694]   - Field: ‘state’
[13:18:58.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.695] - Launch lazy future ...
[13:18:58.695] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.695] Packages needed by future strategies (n = 0): <none>
[13:18:58.696] {
[13:18:58.696]     {
[13:18:58.696]         {
[13:18:58.696]             ...future.startTime <- base::Sys.time()
[13:18:58.696]             {
[13:18:58.696]                 {
[13:18:58.696]                   {
[13:18:58.696]                     {
[13:18:58.696]                       {
[13:18:58.696]                         base::local({
[13:18:58.696]                           has_future <- base::requireNamespace("future", 
[13:18:58.696]                             quietly = TRUE)
[13:18:58.696]                           if (has_future) {
[13:18:58.696]                             ns <- base::getNamespace("future")
[13:18:58.696]                             version <- ns[[".package"]][["version"]]
[13:18:58.696]                             if (is.null(version)) 
[13:18:58.696]                               version <- utils::packageVersion("future")
[13:18:58.696]                           }
[13:18:58.696]                           else {
[13:18:58.696]                             version <- NULL
[13:18:58.696]                           }
[13:18:58.696]                           if (!has_future || version < "1.8.0") {
[13:18:58.696]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.696]                               "", base::R.version$version.string), 
[13:18:58.696]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.696]                                 base::R.version$platform, 8 * 
[13:18:58.696]                                   base::.Machine$sizeof.pointer), 
[13:18:58.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.696]                                 "release", "version")], collapse = " "), 
[13:18:58.696]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.696]                               info)
[13:18:58.696]                             info <- base::paste(info, collapse = "; ")
[13:18:58.696]                             if (!has_future) {
[13:18:58.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.696]                                 info)
[13:18:58.696]                             }
[13:18:58.696]                             else {
[13:18:58.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.696]                                 info, version)
[13:18:58.696]                             }
[13:18:58.696]                             base::stop(msg)
[13:18:58.696]                           }
[13:18:58.696]                         })
[13:18:58.696]                       }
[13:18:58.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.696]                       base::options(mc.cores = 1L)
[13:18:58.696]                     }
[13:18:58.696]                     base::local({
[13:18:58.696]                       for (pkg in "future.apply") {
[13:18:58.696]                         base::loadNamespace(pkg)
[13:18:58.696]                         base::library(pkg, character.only = TRUE)
[13:18:58.696]                       }
[13:18:58.696]                     })
[13:18:58.696]                   }
[13:18:58.696]                   options(future.plan = NULL)
[13:18:58.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.696]                 }
[13:18:58.696]                 ...future.workdir <- getwd()
[13:18:58.696]             }
[13:18:58.696]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.696]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.696]         }
[13:18:58.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.696]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.696]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.696]             base::names(...future.oldOptions))
[13:18:58.696]     }
[13:18:58.696]     if (FALSE) {
[13:18:58.696]     }
[13:18:58.696]     else {
[13:18:58.696]         if (TRUE) {
[13:18:58.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.696]                 open = "w")
[13:18:58.696]         }
[13:18:58.696]         else {
[13:18:58.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.696]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.696]         }
[13:18:58.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.696]             base::sink(type = "output", split = FALSE)
[13:18:58.696]             base::close(...future.stdout)
[13:18:58.696]         }, add = TRUE)
[13:18:58.696]     }
[13:18:58.696]     ...future.frame <- base::sys.nframe()
[13:18:58.696]     ...future.conditions <- base::list()
[13:18:58.696]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.696]     if (FALSE) {
[13:18:58.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.696]     }
[13:18:58.696]     ...future.result <- base::tryCatch({
[13:18:58.696]         base::withCallingHandlers({
[13:18:58.696]             ...future.value <- base::withVisible(base::local({
[13:18:58.696]                 withCallingHandlers({
[13:18:58.696]                   {
[13:18:58.696]                     do.call(function(...) {
[13:18:58.696]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.696]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.696]                         ...future.globals.maxSize)) {
[13:18:58.696]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.696]                         on.exit(options(oopts), add = TRUE)
[13:18:58.696]                       }
[13:18:58.696]                       {
[13:18:58.696]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.696]                           FUN = function(jj) {
[13:18:58.696]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.696]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.696]                           })
[13:18:58.696]                       }
[13:18:58.696]                     }, args = future.call.arguments)
[13:18:58.696]                   }
[13:18:58.696]                 }, immediateCondition = function(cond) {
[13:18:58.696]                   save_rds <- function (object, pathname, ...) 
[13:18:58.696]                   {
[13:18:58.696]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.696]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.696]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.696]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.696]                         fi_tmp[["mtime"]])
[13:18:58.696]                     }
[13:18:58.696]                     tryCatch({
[13:18:58.696]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.696]                     }, error = function(ex) {
[13:18:58.696]                       msg <- conditionMessage(ex)
[13:18:58.696]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.696]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.696]                         fi_tmp[["mtime"]], msg)
[13:18:58.696]                       ex$message <- msg
[13:18:58.696]                       stop(ex)
[13:18:58.696]                     })
[13:18:58.696]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.696]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.696]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.696]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.696]                       fi <- file.info(pathname)
[13:18:58.696]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.696]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.696]                         fi[["size"]], fi[["mtime"]])
[13:18:58.696]                       stop(msg)
[13:18:58.696]                     }
[13:18:58.696]                     invisible(pathname)
[13:18:58.696]                   }
[13:18:58.696]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.696]                     rootPath = tempdir()) 
[13:18:58.696]                   {
[13:18:58.696]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.696]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.696]                       tmpdir = path, fileext = ".rds")
[13:18:58.696]                     save_rds(obj, file)
[13:18:58.696]                   }
[13:18:58.696]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.696]                   {
[13:18:58.696]                     inherits <- base::inherits
[13:18:58.696]                     invokeRestart <- base::invokeRestart
[13:18:58.696]                     is.null <- base::is.null
[13:18:58.696]                     muffled <- FALSE
[13:18:58.696]                     if (inherits(cond, "message")) {
[13:18:58.696]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.696]                       if (muffled) 
[13:18:58.696]                         invokeRestart("muffleMessage")
[13:18:58.696]                     }
[13:18:58.696]                     else if (inherits(cond, "warning")) {
[13:18:58.696]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.696]                       if (muffled) 
[13:18:58.696]                         invokeRestart("muffleWarning")
[13:18:58.696]                     }
[13:18:58.696]                     else if (inherits(cond, "condition")) {
[13:18:58.696]                       if (!is.null(pattern)) {
[13:18:58.696]                         computeRestarts <- base::computeRestarts
[13:18:58.696]                         grepl <- base::grepl
[13:18:58.696]                         restarts <- computeRestarts(cond)
[13:18:58.696]                         for (restart in restarts) {
[13:18:58.696]                           name <- restart$name
[13:18:58.696]                           if (is.null(name)) 
[13:18:58.696]                             next
[13:18:58.696]                           if (!grepl(pattern, name)) 
[13:18:58.696]                             next
[13:18:58.696]                           invokeRestart(restart)
[13:18:58.696]                           muffled <- TRUE
[13:18:58.696]                           break
[13:18:58.696]                         }
[13:18:58.696]                       }
[13:18:58.696]                     }
[13:18:58.696]                     invisible(muffled)
[13:18:58.696]                   }
[13:18:58.696]                   muffleCondition(cond)
[13:18:58.696]                 })
[13:18:58.696]             }))
[13:18:58.696]             future::FutureResult(value = ...future.value$value, 
[13:18:58.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.696]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.696]                     ...future.globalenv.names))
[13:18:58.696]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.696]         }, condition = base::local({
[13:18:58.696]             c <- base::c
[13:18:58.696]             inherits <- base::inherits
[13:18:58.696]             invokeRestart <- base::invokeRestart
[13:18:58.696]             length <- base::length
[13:18:58.696]             list <- base::list
[13:18:58.696]             seq.int <- base::seq.int
[13:18:58.696]             signalCondition <- base::signalCondition
[13:18:58.696]             sys.calls <- base::sys.calls
[13:18:58.696]             `[[` <- base::`[[`
[13:18:58.696]             `+` <- base::`+`
[13:18:58.696]             `<<-` <- base::`<<-`
[13:18:58.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.696]                   3L)]
[13:18:58.696]             }
[13:18:58.696]             function(cond) {
[13:18:58.696]                 is_error <- inherits(cond, "error")
[13:18:58.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.696]                   NULL)
[13:18:58.696]                 if (is_error) {
[13:18:58.696]                   sessionInformation <- function() {
[13:18:58.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.696]                       search = base::search(), system = base::Sys.info())
[13:18:58.696]                   }
[13:18:58.696]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.696]                     cond$call), session = sessionInformation(), 
[13:18:58.696]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.696]                   signalCondition(cond)
[13:18:58.696]                 }
[13:18:58.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.696]                 "immediateCondition"))) {
[13:18:58.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.696]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.696]                   if (TRUE && !signal) {
[13:18:58.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.696]                     {
[13:18:58.696]                       inherits <- base::inherits
[13:18:58.696]                       invokeRestart <- base::invokeRestart
[13:18:58.696]                       is.null <- base::is.null
[13:18:58.696]                       muffled <- FALSE
[13:18:58.696]                       if (inherits(cond, "message")) {
[13:18:58.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.696]                         if (muffled) 
[13:18:58.696]                           invokeRestart("muffleMessage")
[13:18:58.696]                       }
[13:18:58.696]                       else if (inherits(cond, "warning")) {
[13:18:58.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.696]                         if (muffled) 
[13:18:58.696]                           invokeRestart("muffleWarning")
[13:18:58.696]                       }
[13:18:58.696]                       else if (inherits(cond, "condition")) {
[13:18:58.696]                         if (!is.null(pattern)) {
[13:18:58.696]                           computeRestarts <- base::computeRestarts
[13:18:58.696]                           grepl <- base::grepl
[13:18:58.696]                           restarts <- computeRestarts(cond)
[13:18:58.696]                           for (restart in restarts) {
[13:18:58.696]                             name <- restart$name
[13:18:58.696]                             if (is.null(name)) 
[13:18:58.696]                               next
[13:18:58.696]                             if (!grepl(pattern, name)) 
[13:18:58.696]                               next
[13:18:58.696]                             invokeRestart(restart)
[13:18:58.696]                             muffled <- TRUE
[13:18:58.696]                             break
[13:18:58.696]                           }
[13:18:58.696]                         }
[13:18:58.696]                       }
[13:18:58.696]                       invisible(muffled)
[13:18:58.696]                     }
[13:18:58.696]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.696]                   }
[13:18:58.696]                 }
[13:18:58.696]                 else {
[13:18:58.696]                   if (TRUE) {
[13:18:58.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.696]                     {
[13:18:58.696]                       inherits <- base::inherits
[13:18:58.696]                       invokeRestart <- base::invokeRestart
[13:18:58.696]                       is.null <- base::is.null
[13:18:58.696]                       muffled <- FALSE
[13:18:58.696]                       if (inherits(cond, "message")) {
[13:18:58.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.696]                         if (muffled) 
[13:18:58.696]                           invokeRestart("muffleMessage")
[13:18:58.696]                       }
[13:18:58.696]                       else if (inherits(cond, "warning")) {
[13:18:58.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.696]                         if (muffled) 
[13:18:58.696]                           invokeRestart("muffleWarning")
[13:18:58.696]                       }
[13:18:58.696]                       else if (inherits(cond, "condition")) {
[13:18:58.696]                         if (!is.null(pattern)) {
[13:18:58.696]                           computeRestarts <- base::computeRestarts
[13:18:58.696]                           grepl <- base::grepl
[13:18:58.696]                           restarts <- computeRestarts(cond)
[13:18:58.696]                           for (restart in restarts) {
[13:18:58.696]                             name <- restart$name
[13:18:58.696]                             if (is.null(name)) 
[13:18:58.696]                               next
[13:18:58.696]                             if (!grepl(pattern, name)) 
[13:18:58.696]                               next
[13:18:58.696]                             invokeRestart(restart)
[13:18:58.696]                             muffled <- TRUE
[13:18:58.696]                             break
[13:18:58.696]                           }
[13:18:58.696]                         }
[13:18:58.696]                       }
[13:18:58.696]                       invisible(muffled)
[13:18:58.696]                     }
[13:18:58.696]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.696]                   }
[13:18:58.696]                 }
[13:18:58.696]             }
[13:18:58.696]         }))
[13:18:58.696]     }, error = function(ex) {
[13:18:58.696]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.696]                 ...future.rng), started = ...future.startTime, 
[13:18:58.696]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.696]             version = "1.8"), class = "FutureResult")
[13:18:58.696]     }, finally = {
[13:18:58.696]         if (!identical(...future.workdir, getwd())) 
[13:18:58.696]             setwd(...future.workdir)
[13:18:58.696]         {
[13:18:58.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.696]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.696]             }
[13:18:58.696]             base::options(...future.oldOptions)
[13:18:58.696]             if (.Platform$OS.type == "windows") {
[13:18:58.696]                 old_names <- names(...future.oldEnvVars)
[13:18:58.696]                 envs <- base::Sys.getenv()
[13:18:58.696]                 names <- names(envs)
[13:18:58.696]                 common <- intersect(names, old_names)
[13:18:58.696]                 added <- setdiff(names, old_names)
[13:18:58.696]                 removed <- setdiff(old_names, names)
[13:18:58.696]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.696]                   envs[common]]
[13:18:58.696]                 NAMES <- toupper(changed)
[13:18:58.696]                 args <- list()
[13:18:58.696]                 for (kk in seq_along(NAMES)) {
[13:18:58.696]                   name <- changed[[kk]]
[13:18:58.696]                   NAME <- NAMES[[kk]]
[13:18:58.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.696]                     next
[13:18:58.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.696]                 }
[13:18:58.696]                 NAMES <- toupper(added)
[13:18:58.696]                 for (kk in seq_along(NAMES)) {
[13:18:58.696]                   name <- added[[kk]]
[13:18:58.696]                   NAME <- NAMES[[kk]]
[13:18:58.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.696]                     next
[13:18:58.696]                   args[[name]] <- ""
[13:18:58.696]                 }
[13:18:58.696]                 NAMES <- toupper(removed)
[13:18:58.696]                 for (kk in seq_along(NAMES)) {
[13:18:58.696]                   name <- removed[[kk]]
[13:18:58.696]                   NAME <- NAMES[[kk]]
[13:18:58.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.696]                     next
[13:18:58.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.696]                 }
[13:18:58.696]                 if (length(args) > 0) 
[13:18:58.696]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.696]             }
[13:18:58.696]             else {
[13:18:58.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.696]             }
[13:18:58.696]             {
[13:18:58.696]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.696]                   0L) {
[13:18:58.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.696]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.696]                   base::options(opts)
[13:18:58.696]                 }
[13:18:58.696]                 {
[13:18:58.696]                   {
[13:18:58.696]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.696]                     NULL
[13:18:58.696]                   }
[13:18:58.696]                   options(future.plan = NULL)
[13:18:58.696]                   if (is.na(NA_character_)) 
[13:18:58.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.696]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.696]                     envir = parent.frame()) 
[13:18:58.696]                   {
[13:18:58.696]                     default_workers <- missing(workers)
[13:18:58.696]                     if (is.function(workers)) 
[13:18:58.696]                       workers <- workers()
[13:18:58.696]                     workers <- structure(as.integer(workers), 
[13:18:58.696]                       class = class(workers))
[13:18:58.696]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.696]                       1L)
[13:18:58.696]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.696]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.696]                       if (default_workers) 
[13:18:58.696]                         supportsMulticore(warn = TRUE)
[13:18:58.696]                       return(sequential(..., envir = envir))
[13:18:58.696]                     }
[13:18:58.696]                     oopts <- options(mc.cores = workers)
[13:18:58.696]                     on.exit(options(oopts))
[13:18:58.696]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.696]                       envir = envir)
[13:18:58.696]                     if (!future$lazy) 
[13:18:58.696]                       future <- run(future)
[13:18:58.696]                     invisible(future)
[13:18:58.696]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.696]                 }
[13:18:58.696]             }
[13:18:58.696]         }
[13:18:58.696]     })
[13:18:58.696]     if (TRUE) {
[13:18:58.696]         base::sink(type = "output", split = FALSE)
[13:18:58.696]         if (TRUE) {
[13:18:58.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.696]         }
[13:18:58.696]         else {
[13:18:58.696]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.696]         }
[13:18:58.696]         base::close(...future.stdout)
[13:18:58.696]         ...future.stdout <- NULL
[13:18:58.696]     }
[13:18:58.696]     ...future.result$conditions <- ...future.conditions
[13:18:58.696]     ...future.result$finished <- base::Sys.time()
[13:18:58.696]     ...future.result
[13:18:58.696] }
[13:18:58.700] assign_globals() ...
[13:18:58.700] List of 11
[13:18:58.700]  $ ...future.FUN            :function (x, ...)  
[13:18:58.700]  $ x_FUN                    :function (x)  
[13:18:58.700]  $ times                    : int 1
[13:18:58.700]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.700]  $ stop_if_not              :function (...)  
[13:18:58.700]  $ dim                      : NULL
[13:18:58.700]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.700]  $ future.call.arguments    : list()
[13:18:58.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.700]  $ ...future.elements_ii    :List of 5
[13:18:58.700]   ..$ : int 6
[13:18:58.700]   ..$ : int 7
[13:18:58.700]   ..$ : int 8
[13:18:58.700]   ..$ : int 9
[13:18:58.700]   ..$ : int 10
[13:18:58.700]  $ ...future.seeds_ii       : NULL
[13:18:58.700]  $ ...future.globals.maxSize: NULL
[13:18:58.700]  - attr(*, "resolved")= logi FALSE
[13:18:58.700]  - attr(*, "total_size")= num 94336
[13:18:58.700]  - attr(*, "where")=List of 11
[13:18:58.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.700]  - attr(*, "already-done")= logi TRUE
[13:18:58.718] - copied ‘...future.FUN’ to environment
[13:18:58.718] - copied ‘x_FUN’ to environment
[13:18:58.718] - copied ‘times’ to environment
[13:18:58.718] - copied ‘stopf’ to environment
[13:18:58.718] - copied ‘stop_if_not’ to environment
[13:18:58.718] - copied ‘dim’ to environment
[13:18:58.718] - copied ‘valid_types’ to environment
[13:18:58.718] - copied ‘future.call.arguments’ to environment
[13:18:58.718] - copied ‘...future.elements_ii’ to environment
[13:18:58.719] - copied ‘...future.seeds_ii’ to environment
[13:18:58.719] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.719] assign_globals() ... done
[13:18:58.719] requestCore(): workers = 2
[13:18:58.721] MulticoreFuture started
[13:18:58.722] - Launch lazy future ... done
[13:18:58.722] run() for ‘MulticoreFuture’ ... done
[13:18:58.722] Created future:
[13:18:58.723] plan(): Setting new future strategy stack:
[13:18:58.723] List of future strategies:
[13:18:58.723] 1. sequential:
[13:18:58.723]    - args: function (..., envir = parent.frame())
[13:18:58.723]    - tweaked: FALSE
[13:18:58.723]    - call: NULL
[13:18:58.724] plan(): nbrOfWorkers() = 1
[13:18:58.726] plan(): Setting new future strategy stack:
[13:18:58.726] List of future strategies:
[13:18:58.726] 1. multicore:
[13:18:58.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.726]    - tweaked: FALSE
[13:18:58.726]    - call: plan(strategy)
[13:18:58.732] plan(): nbrOfWorkers() = 2
[13:18:58.722] MulticoreFuture:
[13:18:58.722] Label: ‘future_vapply-2’
[13:18:58.722] Expression:
[13:18:58.722] {
[13:18:58.722]     do.call(function(...) {
[13:18:58.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.722]             on.exit(options(oopts), add = TRUE)
[13:18:58.722]         }
[13:18:58.722]         {
[13:18:58.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.722]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.722]             })
[13:18:58.722]         }
[13:18:58.722]     }, args = future.call.arguments)
[13:18:58.722] }
[13:18:58.722] Lazy evaluation: FALSE
[13:18:58.722] Asynchronous evaluation: TRUE
[13:18:58.722] Local evaluation: TRUE
[13:18:58.722] Environment: R_GlobalEnv
[13:18:58.722] Capture standard output: TRUE
[13:18:58.722] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.722] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.722] Packages: 1 packages (‘future.apply’)
[13:18:58.722] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.722] Resolved: TRUE
[13:18:58.722] Value: <not collected>
[13:18:58.722] Conditions captured: <none>
[13:18:58.722] Early signaling: FALSE
[13:18:58.722] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.722] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.733] Chunk #2 of 2 ... DONE
[13:18:58.733] Launching 2 futures (chunks) ... DONE
[13:18:58.733] Resolving 2 futures (chunks) ...
[13:18:58.734] resolve() on list ...
[13:18:58.734]  recursive: 0
[13:18:58.734]  length: 2
[13:18:58.734] 
[13:18:58.734] Future #1
[13:18:58.735] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:58.735] - nx: 2
[13:18:58.736] - relay: TRUE
[13:18:58.736] - stdout: TRUE
[13:18:58.736] - signal: TRUE
[13:18:58.736] - resignal: FALSE
[13:18:58.736] - force: TRUE
[13:18:58.736] - relayed: [n=2] FALSE, FALSE
[13:18:58.736] - queued futures: [n=2] FALSE, FALSE
[13:18:58.737]  - until=1
[13:18:58.737]  - relaying element #1
[13:18:58.737] - relayed: [n=2] TRUE, FALSE
[13:18:58.737] - queued futures: [n=2] TRUE, FALSE
[13:18:58.737] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:58.738]  length: 1 (resolved future 1)
[13:18:58.738] Future #2
[13:18:58.739] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:58.739] - nx: 2
[13:18:58.739] - relay: TRUE
[13:18:58.739] - stdout: TRUE
[13:18:58.739] - signal: TRUE
[13:18:58.739] - resignal: FALSE
[13:18:58.740] - force: TRUE
[13:18:58.740] - relayed: [n=2] TRUE, FALSE
[13:18:58.740] - queued futures: [n=2] TRUE, FALSE
[13:18:58.740]  - until=2
[13:18:58.740]  - relaying element #2
[13:18:58.740] - relayed: [n=2] TRUE, TRUE
[13:18:58.741] - queued futures: [n=2] TRUE, TRUE
[13:18:58.741] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:58.741]  length: 0 (resolved future 2)
[13:18:58.741] Relaying remaining futures
[13:18:58.741] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.741] - nx: 2
[13:18:58.741] - relay: TRUE
[13:18:58.741] - stdout: TRUE
[13:18:58.742] - signal: TRUE
[13:18:58.742] - resignal: FALSE
[13:18:58.742] - force: TRUE
[13:18:58.742] - relayed: [n=2] TRUE, TRUE
[13:18:58.742] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:58.742] - relayed: [n=2] TRUE, TRUE
[13:18:58.742] - queued futures: [n=2] TRUE, TRUE
[13:18:58.742] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.743] resolve() on list ... DONE
[13:18:58.743]  - Number of value chunks collected: 2
[13:18:58.743] Resolving 2 futures (chunks) ... DONE
[13:18:58.743] Reducing values from 2 chunks ...
[13:18:58.743]  - Number of values collected after concatenation: 10
[13:18:58.743]  - Number of values expected: 10
[13:18:58.743] Reducing values from 2 chunks ... DONE
[13:18:58.743] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:18:58.745] future_lapply() ...
[13:18:58.755] Number of chunks: 2
[13:18:58.755] getGlobalsAndPackagesXApply() ...
[13:18:58.755]  - future.globals: TRUE
[13:18:58.755] getGlobalsAndPackages() ...
[13:18:58.755] Searching for globals...
[13:18:58.760] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:18:58.760] Searching for globals ... DONE
[13:18:58.760] Resolving globals: FALSE
[13:18:58.761] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:18:58.762] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.762] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.762] - packages: [1] ‘future.apply’
[13:18:58.762] getGlobalsAndPackages() ... DONE
[13:18:58.762]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.763]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.763] Finding globals ... DONE
[13:18:58.763]  - use_args: TRUE
[13:18:58.763]  - Getting '...' globals ...
[13:18:58.763] resolve() on list ...
[13:18:58.763]  recursive: 0
[13:18:58.763]  length: 1
[13:18:58.763]  elements: ‘...’
[13:18:58.764]  length: 0 (resolved future 1)
[13:18:58.764] resolve() on list ... DONE
[13:18:58.764]    - '...' content: [n=0] 
[13:18:58.764] List of 1
[13:18:58.764]  $ ...: list()
[13:18:58.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.764]  - attr(*, "where")=List of 1
[13:18:58.764]   ..$ ...:<environment: 0x555f7ba3c358> 
[13:18:58.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.764]  - attr(*, "resolved")= logi TRUE
[13:18:58.764]  - attr(*, "total_size")= num NA
[13:18:58.767]  - Getting '...' globals ... DONE
[13:18:58.767] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.767] List of 8
[13:18:58.767]  $ ...future.FUN:function (x, ...)  
[13:18:58.767]  $ x_FUN        :function (x)  
[13:18:58.767]  $ times        : int 2
[13:18:58.767]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.767]  $ stop_if_not  :function (...)  
[13:18:58.767]  $ dim          : NULL
[13:18:58.767]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:58.767]  $ ...          : list()
[13:18:58.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.767]  - attr(*, "where")=List of 8
[13:18:58.767]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.767]   ..$ ...          :<environment: 0x555f7ba3c358> 
[13:18:58.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.767]  - attr(*, "resolved")= logi FALSE
[13:18:58.767]  - attr(*, "total_size")= num 96456
[13:18:58.775] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.775] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.775] Number of futures (= number of chunks): 2
[13:18:58.775] Launching 2 futures (chunks) ...
[13:18:58.775] Chunk #1 of 2 ...
[13:18:58.775]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.776] getGlobalsAndPackages() ...
[13:18:58.776] Searching for globals...
[13:18:58.776] 
[13:18:58.776] Searching for globals ... DONE
[13:18:58.776] - globals: [0] <none>
[13:18:58.776] getGlobalsAndPackages() ... DONE
[13:18:58.776]    + additional globals found: [n=0] 
[13:18:58.776]    + additional namespaces needed: [n=0] 
[13:18:58.777]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.777]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.777]  - seeds: <none>
[13:18:58.777] getGlobalsAndPackages() ...
[13:18:58.777] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.777] Resolving globals: FALSE
[13:18:58.777] Tweak future expression to call with '...' arguments ...
[13:18:58.777] {
[13:18:58.777]     do.call(function(...) {
[13:18:58.777]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.777]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.777]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.777]             on.exit(options(oopts), add = TRUE)
[13:18:58.777]         }
[13:18:58.777]         {
[13:18:58.777]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.777]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.777]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.777]             })
[13:18:58.777]         }
[13:18:58.777]     }, args = future.call.arguments)
[13:18:58.777] }
[13:18:58.778] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.778] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.778] - packages: [1] ‘future.apply’
[13:18:58.778] getGlobalsAndPackages() ... DONE
[13:18:58.779] run() for ‘Future’ ...
[13:18:58.779] - state: ‘created’
[13:18:58.779] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.783] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.783]   - Field: ‘label’
[13:18:58.783]   - Field: ‘local’
[13:18:58.783]   - Field: ‘owner’
[13:18:58.783]   - Field: ‘envir’
[13:18:58.783]   - Field: ‘workers’
[13:18:58.784]   - Field: ‘packages’
[13:18:58.784]   - Field: ‘gc’
[13:18:58.784]   - Field: ‘job’
[13:18:58.784]   - Field: ‘conditions’
[13:18:58.784]   - Field: ‘expr’
[13:18:58.784]   - Field: ‘uuid’
[13:18:58.784]   - Field: ‘seed’
[13:18:58.784]   - Field: ‘version’
[13:18:58.784]   - Field: ‘result’
[13:18:58.784]   - Field: ‘asynchronous’
[13:18:58.785]   - Field: ‘calls’
[13:18:58.785]   - Field: ‘globals’
[13:18:58.785]   - Field: ‘stdout’
[13:18:58.785]   - Field: ‘earlySignal’
[13:18:58.785]   - Field: ‘lazy’
[13:18:58.785]   - Field: ‘state’
[13:18:58.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.785] - Launch lazy future ...
[13:18:58.786] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.786] Packages needed by future strategies (n = 0): <none>
[13:18:58.786] {
[13:18:58.786]     {
[13:18:58.786]         {
[13:18:58.786]             ...future.startTime <- base::Sys.time()
[13:18:58.786]             {
[13:18:58.786]                 {
[13:18:58.786]                   {
[13:18:58.786]                     {
[13:18:58.786]                       {
[13:18:58.786]                         base::local({
[13:18:58.786]                           has_future <- base::requireNamespace("future", 
[13:18:58.786]                             quietly = TRUE)
[13:18:58.786]                           if (has_future) {
[13:18:58.786]                             ns <- base::getNamespace("future")
[13:18:58.786]                             version <- ns[[".package"]][["version"]]
[13:18:58.786]                             if (is.null(version)) 
[13:18:58.786]                               version <- utils::packageVersion("future")
[13:18:58.786]                           }
[13:18:58.786]                           else {
[13:18:58.786]                             version <- NULL
[13:18:58.786]                           }
[13:18:58.786]                           if (!has_future || version < "1.8.0") {
[13:18:58.786]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.786]                               "", base::R.version$version.string), 
[13:18:58.786]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.786]                                 base::R.version$platform, 8 * 
[13:18:58.786]                                   base::.Machine$sizeof.pointer), 
[13:18:58.786]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.786]                                 "release", "version")], collapse = " "), 
[13:18:58.786]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.786]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.786]                               info)
[13:18:58.786]                             info <- base::paste(info, collapse = "; ")
[13:18:58.786]                             if (!has_future) {
[13:18:58.786]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.786]                                 info)
[13:18:58.786]                             }
[13:18:58.786]                             else {
[13:18:58.786]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.786]                                 info, version)
[13:18:58.786]                             }
[13:18:58.786]                             base::stop(msg)
[13:18:58.786]                           }
[13:18:58.786]                         })
[13:18:58.786]                       }
[13:18:58.786]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.786]                       base::options(mc.cores = 1L)
[13:18:58.786]                     }
[13:18:58.786]                     base::local({
[13:18:58.786]                       for (pkg in "future.apply") {
[13:18:58.786]                         base::loadNamespace(pkg)
[13:18:58.786]                         base::library(pkg, character.only = TRUE)
[13:18:58.786]                       }
[13:18:58.786]                     })
[13:18:58.786]                   }
[13:18:58.786]                   options(future.plan = NULL)
[13:18:58.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.786]                 }
[13:18:58.786]                 ...future.workdir <- getwd()
[13:18:58.786]             }
[13:18:58.786]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.786]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.786]         }
[13:18:58.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.786]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.786]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.786]             base::names(...future.oldOptions))
[13:18:58.786]     }
[13:18:58.786]     if (FALSE) {
[13:18:58.786]     }
[13:18:58.786]     else {
[13:18:58.786]         if (TRUE) {
[13:18:58.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.786]                 open = "w")
[13:18:58.786]         }
[13:18:58.786]         else {
[13:18:58.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.786]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.786]         }
[13:18:58.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.786]             base::sink(type = "output", split = FALSE)
[13:18:58.786]             base::close(...future.stdout)
[13:18:58.786]         }, add = TRUE)
[13:18:58.786]     }
[13:18:58.786]     ...future.frame <- base::sys.nframe()
[13:18:58.786]     ...future.conditions <- base::list()
[13:18:58.786]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.786]     if (FALSE) {
[13:18:58.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.786]     }
[13:18:58.786]     ...future.result <- base::tryCatch({
[13:18:58.786]         base::withCallingHandlers({
[13:18:58.786]             ...future.value <- base::withVisible(base::local({
[13:18:58.786]                 withCallingHandlers({
[13:18:58.786]                   {
[13:18:58.786]                     do.call(function(...) {
[13:18:58.786]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.786]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.786]                         ...future.globals.maxSize)) {
[13:18:58.786]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.786]                         on.exit(options(oopts), add = TRUE)
[13:18:58.786]                       }
[13:18:58.786]                       {
[13:18:58.786]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.786]                           FUN = function(jj) {
[13:18:58.786]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.786]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.786]                           })
[13:18:58.786]                       }
[13:18:58.786]                     }, args = future.call.arguments)
[13:18:58.786]                   }
[13:18:58.786]                 }, immediateCondition = function(cond) {
[13:18:58.786]                   save_rds <- function (object, pathname, ...) 
[13:18:58.786]                   {
[13:18:58.786]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.786]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.786]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.786]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.786]                         fi_tmp[["mtime"]])
[13:18:58.786]                     }
[13:18:58.786]                     tryCatch({
[13:18:58.786]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.786]                     }, error = function(ex) {
[13:18:58.786]                       msg <- conditionMessage(ex)
[13:18:58.786]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.786]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.786]                         fi_tmp[["mtime"]], msg)
[13:18:58.786]                       ex$message <- msg
[13:18:58.786]                       stop(ex)
[13:18:58.786]                     })
[13:18:58.786]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.786]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.786]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.786]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.786]                       fi <- file.info(pathname)
[13:18:58.786]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.786]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.786]                         fi[["size"]], fi[["mtime"]])
[13:18:58.786]                       stop(msg)
[13:18:58.786]                     }
[13:18:58.786]                     invisible(pathname)
[13:18:58.786]                   }
[13:18:58.786]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.786]                     rootPath = tempdir()) 
[13:18:58.786]                   {
[13:18:58.786]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.786]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.786]                       tmpdir = path, fileext = ".rds")
[13:18:58.786]                     save_rds(obj, file)
[13:18:58.786]                   }
[13:18:58.786]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.786]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.786]                   {
[13:18:58.786]                     inherits <- base::inherits
[13:18:58.786]                     invokeRestart <- base::invokeRestart
[13:18:58.786]                     is.null <- base::is.null
[13:18:58.786]                     muffled <- FALSE
[13:18:58.786]                     if (inherits(cond, "message")) {
[13:18:58.786]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.786]                       if (muffled) 
[13:18:58.786]                         invokeRestart("muffleMessage")
[13:18:58.786]                     }
[13:18:58.786]                     else if (inherits(cond, "warning")) {
[13:18:58.786]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.786]                       if (muffled) 
[13:18:58.786]                         invokeRestart("muffleWarning")
[13:18:58.786]                     }
[13:18:58.786]                     else if (inherits(cond, "condition")) {
[13:18:58.786]                       if (!is.null(pattern)) {
[13:18:58.786]                         computeRestarts <- base::computeRestarts
[13:18:58.786]                         grepl <- base::grepl
[13:18:58.786]                         restarts <- computeRestarts(cond)
[13:18:58.786]                         for (restart in restarts) {
[13:18:58.786]                           name <- restart$name
[13:18:58.786]                           if (is.null(name)) 
[13:18:58.786]                             next
[13:18:58.786]                           if (!grepl(pattern, name)) 
[13:18:58.786]                             next
[13:18:58.786]                           invokeRestart(restart)
[13:18:58.786]                           muffled <- TRUE
[13:18:58.786]                           break
[13:18:58.786]                         }
[13:18:58.786]                       }
[13:18:58.786]                     }
[13:18:58.786]                     invisible(muffled)
[13:18:58.786]                   }
[13:18:58.786]                   muffleCondition(cond)
[13:18:58.786]                 })
[13:18:58.786]             }))
[13:18:58.786]             future::FutureResult(value = ...future.value$value, 
[13:18:58.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.786]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.786]                     ...future.globalenv.names))
[13:18:58.786]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.786]         }, condition = base::local({
[13:18:58.786]             c <- base::c
[13:18:58.786]             inherits <- base::inherits
[13:18:58.786]             invokeRestart <- base::invokeRestart
[13:18:58.786]             length <- base::length
[13:18:58.786]             list <- base::list
[13:18:58.786]             seq.int <- base::seq.int
[13:18:58.786]             signalCondition <- base::signalCondition
[13:18:58.786]             sys.calls <- base::sys.calls
[13:18:58.786]             `[[` <- base::`[[`
[13:18:58.786]             `+` <- base::`+`
[13:18:58.786]             `<<-` <- base::`<<-`
[13:18:58.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.786]                   3L)]
[13:18:58.786]             }
[13:18:58.786]             function(cond) {
[13:18:58.786]                 is_error <- inherits(cond, "error")
[13:18:58.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.786]                   NULL)
[13:18:58.786]                 if (is_error) {
[13:18:58.786]                   sessionInformation <- function() {
[13:18:58.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.786]                       search = base::search(), system = base::Sys.info())
[13:18:58.786]                   }
[13:18:58.786]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.786]                     cond$call), session = sessionInformation(), 
[13:18:58.786]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.786]                   signalCondition(cond)
[13:18:58.786]                 }
[13:18:58.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.786]                 "immediateCondition"))) {
[13:18:58.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.786]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.786]                   if (TRUE && !signal) {
[13:18:58.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.786]                     {
[13:18:58.786]                       inherits <- base::inherits
[13:18:58.786]                       invokeRestart <- base::invokeRestart
[13:18:58.786]                       is.null <- base::is.null
[13:18:58.786]                       muffled <- FALSE
[13:18:58.786]                       if (inherits(cond, "message")) {
[13:18:58.786]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.786]                         if (muffled) 
[13:18:58.786]                           invokeRestart("muffleMessage")
[13:18:58.786]                       }
[13:18:58.786]                       else if (inherits(cond, "warning")) {
[13:18:58.786]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.786]                         if (muffled) 
[13:18:58.786]                           invokeRestart("muffleWarning")
[13:18:58.786]                       }
[13:18:58.786]                       else if (inherits(cond, "condition")) {
[13:18:58.786]                         if (!is.null(pattern)) {
[13:18:58.786]                           computeRestarts <- base::computeRestarts
[13:18:58.786]                           grepl <- base::grepl
[13:18:58.786]                           restarts <- computeRestarts(cond)
[13:18:58.786]                           for (restart in restarts) {
[13:18:58.786]                             name <- restart$name
[13:18:58.786]                             if (is.null(name)) 
[13:18:58.786]                               next
[13:18:58.786]                             if (!grepl(pattern, name)) 
[13:18:58.786]                               next
[13:18:58.786]                             invokeRestart(restart)
[13:18:58.786]                             muffled <- TRUE
[13:18:58.786]                             break
[13:18:58.786]                           }
[13:18:58.786]                         }
[13:18:58.786]                       }
[13:18:58.786]                       invisible(muffled)
[13:18:58.786]                     }
[13:18:58.786]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.786]                   }
[13:18:58.786]                 }
[13:18:58.786]                 else {
[13:18:58.786]                   if (TRUE) {
[13:18:58.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.786]                     {
[13:18:58.786]                       inherits <- base::inherits
[13:18:58.786]                       invokeRestart <- base::invokeRestart
[13:18:58.786]                       is.null <- base::is.null
[13:18:58.786]                       muffled <- FALSE
[13:18:58.786]                       if (inherits(cond, "message")) {
[13:18:58.786]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.786]                         if (muffled) 
[13:18:58.786]                           invokeRestart("muffleMessage")
[13:18:58.786]                       }
[13:18:58.786]                       else if (inherits(cond, "warning")) {
[13:18:58.786]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.786]                         if (muffled) 
[13:18:58.786]                           invokeRestart("muffleWarning")
[13:18:58.786]                       }
[13:18:58.786]                       else if (inherits(cond, "condition")) {
[13:18:58.786]                         if (!is.null(pattern)) {
[13:18:58.786]                           computeRestarts <- base::computeRestarts
[13:18:58.786]                           grepl <- base::grepl
[13:18:58.786]                           restarts <- computeRestarts(cond)
[13:18:58.786]                           for (restart in restarts) {
[13:18:58.786]                             name <- restart$name
[13:18:58.786]                             if (is.null(name)) 
[13:18:58.786]                               next
[13:18:58.786]                             if (!grepl(pattern, name)) 
[13:18:58.786]                               next
[13:18:58.786]                             invokeRestart(restart)
[13:18:58.786]                             muffled <- TRUE
[13:18:58.786]                             break
[13:18:58.786]                           }
[13:18:58.786]                         }
[13:18:58.786]                       }
[13:18:58.786]                       invisible(muffled)
[13:18:58.786]                     }
[13:18:58.786]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.786]                   }
[13:18:58.786]                 }
[13:18:58.786]             }
[13:18:58.786]         }))
[13:18:58.786]     }, error = function(ex) {
[13:18:58.786]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.786]                 ...future.rng), started = ...future.startTime, 
[13:18:58.786]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.786]             version = "1.8"), class = "FutureResult")
[13:18:58.786]     }, finally = {
[13:18:58.786]         if (!identical(...future.workdir, getwd())) 
[13:18:58.786]             setwd(...future.workdir)
[13:18:58.786]         {
[13:18:58.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.786]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.786]             }
[13:18:58.786]             base::options(...future.oldOptions)
[13:18:58.786]             if (.Platform$OS.type == "windows") {
[13:18:58.786]                 old_names <- names(...future.oldEnvVars)
[13:18:58.786]                 envs <- base::Sys.getenv()
[13:18:58.786]                 names <- names(envs)
[13:18:58.786]                 common <- intersect(names, old_names)
[13:18:58.786]                 added <- setdiff(names, old_names)
[13:18:58.786]                 removed <- setdiff(old_names, names)
[13:18:58.786]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.786]                   envs[common]]
[13:18:58.786]                 NAMES <- toupper(changed)
[13:18:58.786]                 args <- list()
[13:18:58.786]                 for (kk in seq_along(NAMES)) {
[13:18:58.786]                   name <- changed[[kk]]
[13:18:58.786]                   NAME <- NAMES[[kk]]
[13:18:58.786]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.786]                     next
[13:18:58.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.786]                 }
[13:18:58.786]                 NAMES <- toupper(added)
[13:18:58.786]                 for (kk in seq_along(NAMES)) {
[13:18:58.786]                   name <- added[[kk]]
[13:18:58.786]                   NAME <- NAMES[[kk]]
[13:18:58.786]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.786]                     next
[13:18:58.786]                   args[[name]] <- ""
[13:18:58.786]                 }
[13:18:58.786]                 NAMES <- toupper(removed)
[13:18:58.786]                 for (kk in seq_along(NAMES)) {
[13:18:58.786]                   name <- removed[[kk]]
[13:18:58.786]                   NAME <- NAMES[[kk]]
[13:18:58.786]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.786]                     next
[13:18:58.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.786]                 }
[13:18:58.786]                 if (length(args) > 0) 
[13:18:58.786]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.786]             }
[13:18:58.786]             else {
[13:18:58.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.786]             }
[13:18:58.786]             {
[13:18:58.786]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.786]                   0L) {
[13:18:58.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.786]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.786]                   base::options(opts)
[13:18:58.786]                 }
[13:18:58.786]                 {
[13:18:58.786]                   {
[13:18:58.786]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.786]                     NULL
[13:18:58.786]                   }
[13:18:58.786]                   options(future.plan = NULL)
[13:18:58.786]                   if (is.na(NA_character_)) 
[13:18:58.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.786]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.786]                     envir = parent.frame()) 
[13:18:58.786]                   {
[13:18:58.786]                     default_workers <- missing(workers)
[13:18:58.786]                     if (is.function(workers)) 
[13:18:58.786]                       workers <- workers()
[13:18:58.786]                     workers <- structure(as.integer(workers), 
[13:18:58.786]                       class = class(workers))
[13:18:58.786]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.786]                       1L)
[13:18:58.786]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.786]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.786]                       if (default_workers) 
[13:18:58.786]                         supportsMulticore(warn = TRUE)
[13:18:58.786]                       return(sequential(..., envir = envir))
[13:18:58.786]                     }
[13:18:58.786]                     oopts <- options(mc.cores = workers)
[13:18:58.786]                     on.exit(options(oopts))
[13:18:58.786]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.786]                       envir = envir)
[13:18:58.786]                     if (!future$lazy) 
[13:18:58.786]                       future <- run(future)
[13:18:58.786]                     invisible(future)
[13:18:58.786]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.786]                 }
[13:18:58.786]             }
[13:18:58.786]         }
[13:18:58.786]     })
[13:18:58.786]     if (TRUE) {
[13:18:58.786]         base::sink(type = "output", split = FALSE)
[13:18:58.786]         if (TRUE) {
[13:18:58.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.786]         }
[13:18:58.786]         else {
[13:18:58.786]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.786]         }
[13:18:58.786]         base::close(...future.stdout)
[13:18:58.786]         ...future.stdout <- NULL
[13:18:58.786]     }
[13:18:58.786]     ...future.result$conditions <- ...future.conditions
[13:18:58.786]     ...future.result$finished <- base::Sys.time()
[13:18:58.786]     ...future.result
[13:18:58.786] }
[13:18:58.789] assign_globals() ...
[13:18:58.789] List of 11
[13:18:58.789]  $ ...future.FUN            :function (x, ...)  
[13:18:58.789]  $ x_FUN                    :function (x)  
[13:18:58.789]  $ times                    : int 2
[13:18:58.789]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.789]  $ stop_if_not              :function (...)  
[13:18:58.789]  $ dim                      : NULL
[13:18:58.789]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.789]  $ future.call.arguments    : list()
[13:18:58.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.789]  $ ...future.elements_ii    :List of 5
[13:18:58.789]   ..$ : int 1
[13:18:58.789]   ..$ : int 2
[13:18:58.789]   ..$ : int 3
[13:18:58.789]   ..$ : int 4
[13:18:58.789]   ..$ : int 5
[13:18:58.789]  $ ...future.seeds_ii       : NULL
[13:18:58.789]  $ ...future.globals.maxSize: NULL
[13:18:58.789]  - attr(*, "resolved")= logi FALSE
[13:18:58.789]  - attr(*, "total_size")= num 96456
[13:18:58.789]  - attr(*, "where")=List of 11
[13:18:58.789]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.789]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.789]  - attr(*, "already-done")= logi TRUE
[13:18:58.800] - copied ‘...future.FUN’ to environment
[13:18:58.800] - reassign environment for ‘x_FUN’
[13:18:58.801] - copied ‘x_FUN’ to environment
[13:18:58.801] - copied ‘times’ to environment
[13:18:58.801] - copied ‘stopf’ to environment
[13:18:58.801] - copied ‘stop_if_not’ to environment
[13:18:58.801] - copied ‘dim’ to environment
[13:18:58.801] - copied ‘valid_types’ to environment
[13:18:58.801] - copied ‘future.call.arguments’ to environment
[13:18:58.801] - copied ‘...future.elements_ii’ to environment
[13:18:58.802] - copied ‘...future.seeds_ii’ to environment
[13:18:58.802] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.802] assign_globals() ... done
[13:18:58.802] requestCore(): workers = 2
[13:18:58.804] MulticoreFuture started
[13:18:58.805] - Launch lazy future ... done
[13:18:58.805] run() for ‘MulticoreFuture’ ... done
[13:18:58.806] Created future:
[13:18:58.806] plan(): Setting new future strategy stack:
[13:18:58.806] List of future strategies:
[13:18:58.806] 1. sequential:
[13:18:58.806]    - args: function (..., envir = parent.frame())
[13:18:58.806]    - tweaked: FALSE
[13:18:58.806]    - call: NULL
[13:18:58.807] plan(): nbrOfWorkers() = 1
[13:18:58.809] plan(): Setting new future strategy stack:
[13:18:58.809] List of future strategies:
[13:18:58.809] 1. multicore:
[13:18:58.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.809]    - tweaked: FALSE
[13:18:58.809]    - call: plan(strategy)
[13:18:58.815] plan(): nbrOfWorkers() = 2
[13:18:58.806] MulticoreFuture:
[13:18:58.806] Label: ‘future_vapply-1’
[13:18:58.806] Expression:
[13:18:58.806] {
[13:18:58.806]     do.call(function(...) {
[13:18:58.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.806]             on.exit(options(oopts), add = TRUE)
[13:18:58.806]         }
[13:18:58.806]         {
[13:18:58.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.806]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.806]             })
[13:18:58.806]         }
[13:18:58.806]     }, args = future.call.arguments)
[13:18:58.806] }
[13:18:58.806] Lazy evaluation: FALSE
[13:18:58.806] Asynchronous evaluation: TRUE
[13:18:58.806] Local evaluation: TRUE
[13:18:58.806] Environment: R_GlobalEnv
[13:18:58.806] Capture standard output: TRUE
[13:18:58.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.806] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.806] Packages: 1 packages (‘future.apply’)
[13:18:58.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.806] Resolved: TRUE
[13:18:58.806] Value: <not collected>
[13:18:58.806] Conditions captured: <none>
[13:18:58.806] Early signaling: FALSE
[13:18:58.806] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.817] Chunk #1 of 2 ... DONE
[13:18:58.817] Chunk #2 of 2 ...
[13:18:58.817]  - Finding globals in 'X' for chunk #2 ...
[13:18:58.817] getGlobalsAndPackages() ...
[13:18:58.818] Searching for globals...
[13:18:58.818] 
[13:18:58.818] Searching for globals ... DONE
[13:18:58.818] - globals: [0] <none>
[13:18:58.819] getGlobalsAndPackages() ... DONE
[13:18:58.819]    + additional globals found: [n=0] 
[13:18:58.819]    + additional namespaces needed: [n=0] 
[13:18:58.819]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:58.819]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.819]  - seeds: <none>
[13:18:58.820] getGlobalsAndPackages() ...
[13:18:58.820] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.820] Resolving globals: FALSE
[13:18:58.820] Tweak future expression to call with '...' arguments ...
[13:18:58.821] {
[13:18:58.821]     do.call(function(...) {
[13:18:58.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.821]             on.exit(options(oopts), add = TRUE)
[13:18:58.821]         }
[13:18:58.821]         {
[13:18:58.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.821]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.821]             })
[13:18:58.821]         }
[13:18:58.821]     }, args = future.call.arguments)
[13:18:58.821] }
[13:18:58.821] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.822] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.822] - packages: [1] ‘future.apply’
[13:18:58.822] getGlobalsAndPackages() ... DONE
[13:18:58.823] run() for ‘Future’ ...
[13:18:58.823] - state: ‘created’
[13:18:58.823] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.828] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.828]   - Field: ‘label’
[13:18:58.829]   - Field: ‘local’
[13:18:58.829]   - Field: ‘owner’
[13:18:58.829]   - Field: ‘envir’
[13:18:58.829]   - Field: ‘workers’
[13:18:58.829]   - Field: ‘packages’
[13:18:58.829]   - Field: ‘gc’
[13:18:58.830]   - Field: ‘job’
[13:18:58.830]   - Field: ‘conditions’
[13:18:58.830]   - Field: ‘expr’
[13:18:58.830]   - Field: ‘uuid’
[13:18:58.830]   - Field: ‘seed’
[13:18:58.830]   - Field: ‘version’
[13:18:58.831]   - Field: ‘result’
[13:18:58.831]   - Field: ‘asynchronous’
[13:18:58.831]   - Field: ‘calls’
[13:18:58.831]   - Field: ‘globals’
[13:18:58.831]   - Field: ‘stdout’
[13:18:58.831]   - Field: ‘earlySignal’
[13:18:58.831]   - Field: ‘lazy’
[13:18:58.832]   - Field: ‘state’
[13:18:58.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.832] - Launch lazy future ...
[13:18:58.832] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.832] Packages needed by future strategies (n = 0): <none>
[13:18:58.833] {
[13:18:58.833]     {
[13:18:58.833]         {
[13:18:58.833]             ...future.startTime <- base::Sys.time()
[13:18:58.833]             {
[13:18:58.833]                 {
[13:18:58.833]                   {
[13:18:58.833]                     {
[13:18:58.833]                       {
[13:18:58.833]                         base::local({
[13:18:58.833]                           has_future <- base::requireNamespace("future", 
[13:18:58.833]                             quietly = TRUE)
[13:18:58.833]                           if (has_future) {
[13:18:58.833]                             ns <- base::getNamespace("future")
[13:18:58.833]                             version <- ns[[".package"]][["version"]]
[13:18:58.833]                             if (is.null(version)) 
[13:18:58.833]                               version <- utils::packageVersion("future")
[13:18:58.833]                           }
[13:18:58.833]                           else {
[13:18:58.833]                             version <- NULL
[13:18:58.833]                           }
[13:18:58.833]                           if (!has_future || version < "1.8.0") {
[13:18:58.833]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.833]                               "", base::R.version$version.string), 
[13:18:58.833]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.833]                                 base::R.version$platform, 8 * 
[13:18:58.833]                                   base::.Machine$sizeof.pointer), 
[13:18:58.833]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.833]                                 "release", "version")], collapse = " "), 
[13:18:58.833]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.833]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.833]                               info)
[13:18:58.833]                             info <- base::paste(info, collapse = "; ")
[13:18:58.833]                             if (!has_future) {
[13:18:58.833]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.833]                                 info)
[13:18:58.833]                             }
[13:18:58.833]                             else {
[13:18:58.833]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.833]                                 info, version)
[13:18:58.833]                             }
[13:18:58.833]                             base::stop(msg)
[13:18:58.833]                           }
[13:18:58.833]                         })
[13:18:58.833]                       }
[13:18:58.833]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.833]                       base::options(mc.cores = 1L)
[13:18:58.833]                     }
[13:18:58.833]                     base::local({
[13:18:58.833]                       for (pkg in "future.apply") {
[13:18:58.833]                         base::loadNamespace(pkg)
[13:18:58.833]                         base::library(pkg, character.only = TRUE)
[13:18:58.833]                       }
[13:18:58.833]                     })
[13:18:58.833]                   }
[13:18:58.833]                   options(future.plan = NULL)
[13:18:58.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.833]                 }
[13:18:58.833]                 ...future.workdir <- getwd()
[13:18:58.833]             }
[13:18:58.833]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.833]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.833]         }
[13:18:58.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.833]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.833]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.833]             base::names(...future.oldOptions))
[13:18:58.833]     }
[13:18:58.833]     if (FALSE) {
[13:18:58.833]     }
[13:18:58.833]     else {
[13:18:58.833]         if (TRUE) {
[13:18:58.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.833]                 open = "w")
[13:18:58.833]         }
[13:18:58.833]         else {
[13:18:58.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.833]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.833]         }
[13:18:58.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.833]             base::sink(type = "output", split = FALSE)
[13:18:58.833]             base::close(...future.stdout)
[13:18:58.833]         }, add = TRUE)
[13:18:58.833]     }
[13:18:58.833]     ...future.frame <- base::sys.nframe()
[13:18:58.833]     ...future.conditions <- base::list()
[13:18:58.833]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.833]     if (FALSE) {
[13:18:58.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.833]     }
[13:18:58.833]     ...future.result <- base::tryCatch({
[13:18:58.833]         base::withCallingHandlers({
[13:18:58.833]             ...future.value <- base::withVisible(base::local({
[13:18:58.833]                 withCallingHandlers({
[13:18:58.833]                   {
[13:18:58.833]                     do.call(function(...) {
[13:18:58.833]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.833]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.833]                         ...future.globals.maxSize)) {
[13:18:58.833]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.833]                         on.exit(options(oopts), add = TRUE)
[13:18:58.833]                       }
[13:18:58.833]                       {
[13:18:58.833]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.833]                           FUN = function(jj) {
[13:18:58.833]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.833]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.833]                           })
[13:18:58.833]                       }
[13:18:58.833]                     }, args = future.call.arguments)
[13:18:58.833]                   }
[13:18:58.833]                 }, immediateCondition = function(cond) {
[13:18:58.833]                   save_rds <- function (object, pathname, ...) 
[13:18:58.833]                   {
[13:18:58.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.833]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.833]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.833]                         fi_tmp[["mtime"]])
[13:18:58.833]                     }
[13:18:58.833]                     tryCatch({
[13:18:58.833]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.833]                     }, error = function(ex) {
[13:18:58.833]                       msg <- conditionMessage(ex)
[13:18:58.833]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.833]                         fi_tmp[["mtime"]], msg)
[13:18:58.833]                       ex$message <- msg
[13:18:58.833]                       stop(ex)
[13:18:58.833]                     })
[13:18:58.833]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.833]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.833]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.833]                       fi <- file.info(pathname)
[13:18:58.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.833]                         fi[["size"]], fi[["mtime"]])
[13:18:58.833]                       stop(msg)
[13:18:58.833]                     }
[13:18:58.833]                     invisible(pathname)
[13:18:58.833]                   }
[13:18:58.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.833]                     rootPath = tempdir()) 
[13:18:58.833]                   {
[13:18:58.833]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.833]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.833]                       tmpdir = path, fileext = ".rds")
[13:18:58.833]                     save_rds(obj, file)
[13:18:58.833]                   }
[13:18:58.833]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.833]                   {
[13:18:58.833]                     inherits <- base::inherits
[13:18:58.833]                     invokeRestart <- base::invokeRestart
[13:18:58.833]                     is.null <- base::is.null
[13:18:58.833]                     muffled <- FALSE
[13:18:58.833]                     if (inherits(cond, "message")) {
[13:18:58.833]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.833]                       if (muffled) 
[13:18:58.833]                         invokeRestart("muffleMessage")
[13:18:58.833]                     }
[13:18:58.833]                     else if (inherits(cond, "warning")) {
[13:18:58.833]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.833]                       if (muffled) 
[13:18:58.833]                         invokeRestart("muffleWarning")
[13:18:58.833]                     }
[13:18:58.833]                     else if (inherits(cond, "condition")) {
[13:18:58.833]                       if (!is.null(pattern)) {
[13:18:58.833]                         computeRestarts <- base::computeRestarts
[13:18:58.833]                         grepl <- base::grepl
[13:18:58.833]                         restarts <- computeRestarts(cond)
[13:18:58.833]                         for (restart in restarts) {
[13:18:58.833]                           name <- restart$name
[13:18:58.833]                           if (is.null(name)) 
[13:18:58.833]                             next
[13:18:58.833]                           if (!grepl(pattern, name)) 
[13:18:58.833]                             next
[13:18:58.833]                           invokeRestart(restart)
[13:18:58.833]                           muffled <- TRUE
[13:18:58.833]                           break
[13:18:58.833]                         }
[13:18:58.833]                       }
[13:18:58.833]                     }
[13:18:58.833]                     invisible(muffled)
[13:18:58.833]                   }
[13:18:58.833]                   muffleCondition(cond)
[13:18:58.833]                 })
[13:18:58.833]             }))
[13:18:58.833]             future::FutureResult(value = ...future.value$value, 
[13:18:58.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.833]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.833]                     ...future.globalenv.names))
[13:18:58.833]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.833]         }, condition = base::local({
[13:18:58.833]             c <- base::c
[13:18:58.833]             inherits <- base::inherits
[13:18:58.833]             invokeRestart <- base::invokeRestart
[13:18:58.833]             length <- base::length
[13:18:58.833]             list <- base::list
[13:18:58.833]             seq.int <- base::seq.int
[13:18:58.833]             signalCondition <- base::signalCondition
[13:18:58.833]             sys.calls <- base::sys.calls
[13:18:58.833]             `[[` <- base::`[[`
[13:18:58.833]             `+` <- base::`+`
[13:18:58.833]             `<<-` <- base::`<<-`
[13:18:58.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.833]                   3L)]
[13:18:58.833]             }
[13:18:58.833]             function(cond) {
[13:18:58.833]                 is_error <- inherits(cond, "error")
[13:18:58.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.833]                   NULL)
[13:18:58.833]                 if (is_error) {
[13:18:58.833]                   sessionInformation <- function() {
[13:18:58.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.833]                       search = base::search(), system = base::Sys.info())
[13:18:58.833]                   }
[13:18:58.833]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.833]                     cond$call), session = sessionInformation(), 
[13:18:58.833]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.833]                   signalCondition(cond)
[13:18:58.833]                 }
[13:18:58.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.833]                 "immediateCondition"))) {
[13:18:58.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.833]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.833]                   if (TRUE && !signal) {
[13:18:58.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.833]                     {
[13:18:58.833]                       inherits <- base::inherits
[13:18:58.833]                       invokeRestart <- base::invokeRestart
[13:18:58.833]                       is.null <- base::is.null
[13:18:58.833]                       muffled <- FALSE
[13:18:58.833]                       if (inherits(cond, "message")) {
[13:18:58.833]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.833]                         if (muffled) 
[13:18:58.833]                           invokeRestart("muffleMessage")
[13:18:58.833]                       }
[13:18:58.833]                       else if (inherits(cond, "warning")) {
[13:18:58.833]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.833]                         if (muffled) 
[13:18:58.833]                           invokeRestart("muffleWarning")
[13:18:58.833]                       }
[13:18:58.833]                       else if (inherits(cond, "condition")) {
[13:18:58.833]                         if (!is.null(pattern)) {
[13:18:58.833]                           computeRestarts <- base::computeRestarts
[13:18:58.833]                           grepl <- base::grepl
[13:18:58.833]                           restarts <- computeRestarts(cond)
[13:18:58.833]                           for (restart in restarts) {
[13:18:58.833]                             name <- restart$name
[13:18:58.833]                             if (is.null(name)) 
[13:18:58.833]                               next
[13:18:58.833]                             if (!grepl(pattern, name)) 
[13:18:58.833]                               next
[13:18:58.833]                             invokeRestart(restart)
[13:18:58.833]                             muffled <- TRUE
[13:18:58.833]                             break
[13:18:58.833]                           }
[13:18:58.833]                         }
[13:18:58.833]                       }
[13:18:58.833]                       invisible(muffled)
[13:18:58.833]                     }
[13:18:58.833]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.833]                   }
[13:18:58.833]                 }
[13:18:58.833]                 else {
[13:18:58.833]                   if (TRUE) {
[13:18:58.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.833]                     {
[13:18:58.833]                       inherits <- base::inherits
[13:18:58.833]                       invokeRestart <- base::invokeRestart
[13:18:58.833]                       is.null <- base::is.null
[13:18:58.833]                       muffled <- FALSE
[13:18:58.833]                       if (inherits(cond, "message")) {
[13:18:58.833]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.833]                         if (muffled) 
[13:18:58.833]                           invokeRestart("muffleMessage")
[13:18:58.833]                       }
[13:18:58.833]                       else if (inherits(cond, "warning")) {
[13:18:58.833]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.833]                         if (muffled) 
[13:18:58.833]                           invokeRestart("muffleWarning")
[13:18:58.833]                       }
[13:18:58.833]                       else if (inherits(cond, "condition")) {
[13:18:58.833]                         if (!is.null(pattern)) {
[13:18:58.833]                           computeRestarts <- base::computeRestarts
[13:18:58.833]                           grepl <- base::grepl
[13:18:58.833]                           restarts <- computeRestarts(cond)
[13:18:58.833]                           for (restart in restarts) {
[13:18:58.833]                             name <- restart$name
[13:18:58.833]                             if (is.null(name)) 
[13:18:58.833]                               next
[13:18:58.833]                             if (!grepl(pattern, name)) 
[13:18:58.833]                               next
[13:18:58.833]                             invokeRestart(restart)
[13:18:58.833]                             muffled <- TRUE
[13:18:58.833]                             break
[13:18:58.833]                           }
[13:18:58.833]                         }
[13:18:58.833]                       }
[13:18:58.833]                       invisible(muffled)
[13:18:58.833]                     }
[13:18:58.833]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.833]                   }
[13:18:58.833]                 }
[13:18:58.833]             }
[13:18:58.833]         }))
[13:18:58.833]     }, error = function(ex) {
[13:18:58.833]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.833]                 ...future.rng), started = ...future.startTime, 
[13:18:58.833]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.833]             version = "1.8"), class = "FutureResult")
[13:18:58.833]     }, finally = {
[13:18:58.833]         if (!identical(...future.workdir, getwd())) 
[13:18:58.833]             setwd(...future.workdir)
[13:18:58.833]         {
[13:18:58.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.833]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.833]             }
[13:18:58.833]             base::options(...future.oldOptions)
[13:18:58.833]             if (.Platform$OS.type == "windows") {
[13:18:58.833]                 old_names <- names(...future.oldEnvVars)
[13:18:58.833]                 envs <- base::Sys.getenv()
[13:18:58.833]                 names <- names(envs)
[13:18:58.833]                 common <- intersect(names, old_names)
[13:18:58.833]                 added <- setdiff(names, old_names)
[13:18:58.833]                 removed <- setdiff(old_names, names)
[13:18:58.833]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.833]                   envs[common]]
[13:18:58.833]                 NAMES <- toupper(changed)
[13:18:58.833]                 args <- list()
[13:18:58.833]                 for (kk in seq_along(NAMES)) {
[13:18:58.833]                   name <- changed[[kk]]
[13:18:58.833]                   NAME <- NAMES[[kk]]
[13:18:58.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.833]                     next
[13:18:58.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.833]                 }
[13:18:58.833]                 NAMES <- toupper(added)
[13:18:58.833]                 for (kk in seq_along(NAMES)) {
[13:18:58.833]                   name <- added[[kk]]
[13:18:58.833]                   NAME <- NAMES[[kk]]
[13:18:58.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.833]                     next
[13:18:58.833]                   args[[name]] <- ""
[13:18:58.833]                 }
[13:18:58.833]                 NAMES <- toupper(removed)
[13:18:58.833]                 for (kk in seq_along(NAMES)) {
[13:18:58.833]                   name <- removed[[kk]]
[13:18:58.833]                   NAME <- NAMES[[kk]]
[13:18:58.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.833]                     next
[13:18:58.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.833]                 }
[13:18:58.833]                 if (length(args) > 0) 
[13:18:58.833]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.833]             }
[13:18:58.833]             else {
[13:18:58.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.833]             }
[13:18:58.833]             {
[13:18:58.833]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.833]                   0L) {
[13:18:58.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.833]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.833]                   base::options(opts)
[13:18:58.833]                 }
[13:18:58.833]                 {
[13:18:58.833]                   {
[13:18:58.833]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.833]                     NULL
[13:18:58.833]                   }
[13:18:58.833]                   options(future.plan = NULL)
[13:18:58.833]                   if (is.na(NA_character_)) 
[13:18:58.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.833]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.833]                     envir = parent.frame()) 
[13:18:58.833]                   {
[13:18:58.833]                     default_workers <- missing(workers)
[13:18:58.833]                     if (is.function(workers)) 
[13:18:58.833]                       workers <- workers()
[13:18:58.833]                     workers <- structure(as.integer(workers), 
[13:18:58.833]                       class = class(workers))
[13:18:58.833]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.833]                       1L)
[13:18:58.833]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.833]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.833]                       if (default_workers) 
[13:18:58.833]                         supportsMulticore(warn = TRUE)
[13:18:58.833]                       return(sequential(..., envir = envir))
[13:18:58.833]                     }
[13:18:58.833]                     oopts <- options(mc.cores = workers)
[13:18:58.833]                     on.exit(options(oopts))
[13:18:58.833]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.833]                       envir = envir)
[13:18:58.833]                     if (!future$lazy) 
[13:18:58.833]                       future <- run(future)
[13:18:58.833]                     invisible(future)
[13:18:58.833]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.833]                 }
[13:18:58.833]             }
[13:18:58.833]         }
[13:18:58.833]     })
[13:18:58.833]     if (TRUE) {
[13:18:58.833]         base::sink(type = "output", split = FALSE)
[13:18:58.833]         if (TRUE) {
[13:18:58.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.833]         }
[13:18:58.833]         else {
[13:18:58.833]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.833]         }
[13:18:58.833]         base::close(...future.stdout)
[13:18:58.833]         ...future.stdout <- NULL
[13:18:58.833]     }
[13:18:58.833]     ...future.result$conditions <- ...future.conditions
[13:18:58.833]     ...future.result$finished <- base::Sys.time()
[13:18:58.833]     ...future.result
[13:18:58.833] }
[13:18:58.837] assign_globals() ...
[13:18:58.837] List of 11
[13:18:58.837]  $ ...future.FUN            :function (x, ...)  
[13:18:58.837]  $ x_FUN                    :function (x)  
[13:18:58.837]  $ times                    : int 2
[13:18:58.837]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.837]  $ stop_if_not              :function (...)  
[13:18:58.837]  $ dim                      : NULL
[13:18:58.837]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:58.837]  $ future.call.arguments    : list()
[13:18:58.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.837]  $ ...future.elements_ii    :List of 5
[13:18:58.837]   ..$ : int 6
[13:18:58.837]   ..$ : int 7
[13:18:58.837]   ..$ : int 8
[13:18:58.837]   ..$ : int 9
[13:18:58.837]   ..$ : int 10
[13:18:58.837]  $ ...future.seeds_ii       : NULL
[13:18:58.837]  $ ...future.globals.maxSize: NULL
[13:18:58.837]  - attr(*, "resolved")= logi FALSE
[13:18:58.837]  - attr(*, "total_size")= num 96456
[13:18:58.837]  - attr(*, "where")=List of 11
[13:18:58.837]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.837]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.837]  - attr(*, "already-done")= logi TRUE
[13:18:58.853] - copied ‘...future.FUN’ to environment
[13:18:58.853] - reassign environment for ‘x_FUN’
[13:18:58.853] - copied ‘x_FUN’ to environment
[13:18:58.854] - copied ‘times’ to environment
[13:18:58.854] - copied ‘stopf’ to environment
[13:18:58.854] - copied ‘stop_if_not’ to environment
[13:18:58.854] - copied ‘dim’ to environment
[13:18:58.854] - copied ‘valid_types’ to environment
[13:18:58.854] - copied ‘future.call.arguments’ to environment
[13:18:58.854] - copied ‘...future.elements_ii’ to environment
[13:18:58.854] - copied ‘...future.seeds_ii’ to environment
[13:18:58.854] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.854] assign_globals() ... done
[13:18:58.855] requestCore(): workers = 2
[13:18:58.857] MulticoreFuture started
[13:18:58.857] - Launch lazy future ... done
[13:18:58.858] run() for ‘MulticoreFuture’ ... done
[13:18:58.858] Created future:
[13:18:58.858] plan(): Setting new future strategy stack:
[13:18:58.859] List of future strategies:
[13:18:58.859] 1. sequential:
[13:18:58.859]    - args: function (..., envir = parent.frame())
[13:18:58.859]    - tweaked: FALSE
[13:18:58.859]    - call: NULL
[13:18:58.860] plan(): nbrOfWorkers() = 1
[13:18:58.862] plan(): Setting new future strategy stack:
[13:18:58.862] List of future strategies:
[13:18:58.862] 1. multicore:
[13:18:58.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.862]    - tweaked: FALSE
[13:18:58.862]    - call: plan(strategy)
[13:18:58.867] plan(): nbrOfWorkers() = 2
[13:18:58.858] MulticoreFuture:
[13:18:58.858] Label: ‘future_vapply-2’
[13:18:58.858] Expression:
[13:18:58.858] {
[13:18:58.858]     do.call(function(...) {
[13:18:58.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.858]             on.exit(options(oopts), add = TRUE)
[13:18:58.858]         }
[13:18:58.858]         {
[13:18:58.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.858]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.858]             })
[13:18:58.858]         }
[13:18:58.858]     }, args = future.call.arguments)
[13:18:58.858] }
[13:18:58.858] Lazy evaluation: FALSE
[13:18:58.858] Asynchronous evaluation: TRUE
[13:18:58.858] Local evaluation: TRUE
[13:18:58.858] Environment: R_GlobalEnv
[13:18:58.858] Capture standard output: TRUE
[13:18:58.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.858] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.858] Packages: 1 packages (‘future.apply’)
[13:18:58.858] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.858] Resolved: TRUE
[13:18:58.858] Value: <not collected>
[13:18:58.858] Conditions captured: <none>
[13:18:58.858] Early signaling: FALSE
[13:18:58.858] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.858] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.868] Chunk #2 of 2 ... DONE
[13:18:58.868] Launching 2 futures (chunks) ... DONE
[13:18:58.869] Resolving 2 futures (chunks) ...
[13:18:58.869] resolve() on list ...
[13:18:58.869]  recursive: 0
[13:18:58.869]  length: 2
[13:18:58.869] 
[13:18:58.870] Future #1
[13:18:58.871] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:58.871] - nx: 2
[13:18:58.871] - relay: TRUE
[13:18:58.871] - stdout: TRUE
[13:18:58.871] - signal: TRUE
[13:18:58.871] - resignal: FALSE
[13:18:58.871] - force: TRUE
[13:18:58.872] - relayed: [n=2] FALSE, FALSE
[13:18:58.872] - queued futures: [n=2] FALSE, FALSE
[13:18:58.872]  - until=1
[13:18:58.872]  - relaying element #1
[13:18:58.872] - relayed: [n=2] TRUE, FALSE
[13:18:58.873] - queued futures: [n=2] TRUE, FALSE
[13:18:58.873] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:58.873]  length: 1 (resolved future 1)
[13:18:58.873] Future #2
[13:18:58.874] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:58.874] - nx: 2
[13:18:58.875] - relay: TRUE
[13:18:58.875] - stdout: TRUE
[13:18:58.875] - signal: TRUE
[13:18:58.875] - resignal: FALSE
[13:18:58.875] - force: TRUE
[13:18:58.875] - relayed: [n=2] TRUE, FALSE
[13:18:58.875] - queued futures: [n=2] TRUE, FALSE
[13:18:58.875]  - until=2
[13:18:58.876]  - relaying element #2
[13:18:58.876] - relayed: [n=2] TRUE, TRUE
[13:18:58.876] - queued futures: [n=2] TRUE, TRUE
[13:18:58.876] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:58.876]  length: 0 (resolved future 2)
[13:18:58.876] Relaying remaining futures
[13:18:58.876] signalConditionsASAP(NULL, pos=0) ...
[13:18:58.877] - nx: 2
[13:18:58.877] - relay: TRUE
[13:18:58.877] - stdout: TRUE
[13:18:58.877] - signal: TRUE
[13:18:58.877] - resignal: FALSE
[13:18:58.877] - force: TRUE
[13:18:58.877] - relayed: [n=2] TRUE, TRUE
[13:18:58.877] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:58.878] - relayed: [n=2] TRUE, TRUE
[13:18:58.878] - queued futures: [n=2] TRUE, TRUE
[13:18:58.878] signalConditionsASAP(NULL, pos=0) ... done
[13:18:58.878] resolve() on list ... DONE
[13:18:58.878]  - Number of value chunks collected: 2
[13:18:58.878] Resolving 2 futures (chunks) ... DONE
[13:18:58.878] Reducing values from 2 chunks ...
[13:18:58.878]  - Number of values collected after concatenation: 10
[13:18:58.879]  - Number of values expected: 10
[13:18:58.879] Reducing values from 2 chunks ... DONE
[13:18:58.879] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:18:58.880] future_lapply() ...
[13:18:58.889] Number of chunks: 2
[13:18:58.889] getGlobalsAndPackagesXApply() ...
[13:18:58.889]  - future.globals: TRUE
[13:18:58.889] getGlobalsAndPackages() ...
[13:18:58.890] Searching for globals...
[13:18:58.895] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:18:58.895] Searching for globals ... DONE
[13:18:58.895] Resolving globals: FALSE
[13:18:58.896] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:18:58.896] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:58.897] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.897] - packages: [1] ‘future.apply’
[13:18:58.897] getGlobalsAndPackages() ... DONE
[13:18:58.897]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:58.897]  - needed namespaces: [n=1] ‘future.apply’
[13:18:58.897] Finding globals ... DONE
[13:18:58.897]  - use_args: TRUE
[13:18:58.897]  - Getting '...' globals ...
[13:18:58.898] resolve() on list ...
[13:18:58.898]  recursive: 0
[13:18:58.898]  length: 1
[13:18:58.898]  elements: ‘...’
[13:18:58.898]  length: 0 (resolved future 1)
[13:18:58.898] resolve() on list ... DONE
[13:18:58.898]    - '...' content: [n=0] 
[13:18:58.898] List of 1
[13:18:58.898]  $ ...: list()
[13:18:58.898]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.898]  - attr(*, "where")=List of 1
[13:18:58.898]   ..$ ...:<environment: 0x555f7b7f7af8> 
[13:18:58.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.898]  - attr(*, "resolved")= logi TRUE
[13:18:58.898]  - attr(*, "total_size")= num NA
[13:18:58.901]  - Getting '...' globals ... DONE
[13:18:58.901] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:58.901] List of 8
[13:18:58.901]  $ ...future.FUN:function (x, ...)  
[13:18:58.901]  $ x_FUN        :function (x)  
[13:18:58.901]  $ times        : int 4
[13:18:58.901]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.901]  $ stop_if_not  :function (...)  
[13:18:58.901]  $ dim          : int [1:2] 2 2
[13:18:58.901]  $ valid_types  : chr [1:2] "logical" "integer"
[13:18:58.901]  $ ...          : list()
[13:18:58.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.901]  - attr(*, "where")=List of 8
[13:18:58.901]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:58.901]   ..$ ...          :<environment: 0x555f7b7f7af8> 
[13:18:58.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.901]  - attr(*, "resolved")= logi FALSE
[13:18:58.901]  - attr(*, "total_size")= num 97232
[13:18:58.909] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:58.909] getGlobalsAndPackagesXApply() ... DONE
[13:18:58.909] Number of futures (= number of chunks): 2
[13:18:58.909] Launching 2 futures (chunks) ...
[13:18:58.909] Chunk #1 of 2 ...
[13:18:58.909]  - Finding globals in 'X' for chunk #1 ...
[13:18:58.909] getGlobalsAndPackages() ...
[13:18:58.910] Searching for globals...
[13:18:58.910] 
[13:18:58.910] Searching for globals ... DONE
[13:18:58.910] - globals: [0] <none>
[13:18:58.910] getGlobalsAndPackages() ... DONE
[13:18:58.910]    + additional globals found: [n=0] 
[13:18:58.910]    + additional namespaces needed: [n=0] 
[13:18:58.910]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:58.911]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.911]  - seeds: <none>
[13:18:58.911] getGlobalsAndPackages() ...
[13:18:58.911] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.911] Resolving globals: FALSE
[13:18:58.911] Tweak future expression to call with '...' arguments ...
[13:18:58.911] {
[13:18:58.911]     do.call(function(...) {
[13:18:58.911]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.911]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.911]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.911]             on.exit(options(oopts), add = TRUE)
[13:18:58.911]         }
[13:18:58.911]         {
[13:18:58.911]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.911]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.911]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.911]             })
[13:18:58.911]         }
[13:18:58.911]     }, args = future.call.arguments)
[13:18:58.911] }
[13:18:58.912] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.912] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.912] - packages: [1] ‘future.apply’
[13:18:58.912] getGlobalsAndPackages() ... DONE
[13:18:58.913] run() for ‘Future’ ...
[13:18:58.913] - state: ‘created’
[13:18:58.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.917]   - Field: ‘label’
[13:18:58.917]   - Field: ‘local’
[13:18:58.917]   - Field: ‘owner’
[13:18:58.917]   - Field: ‘envir’
[13:18:58.917]   - Field: ‘workers’
[13:18:58.917]   - Field: ‘packages’
[13:18:58.918]   - Field: ‘gc’
[13:18:58.918]   - Field: ‘job’
[13:18:58.918]   - Field: ‘conditions’
[13:18:58.918]   - Field: ‘expr’
[13:18:58.918]   - Field: ‘uuid’
[13:18:58.918]   - Field: ‘seed’
[13:18:58.918]   - Field: ‘version’
[13:18:58.918]   - Field: ‘result’
[13:18:58.918]   - Field: ‘asynchronous’
[13:18:58.918]   - Field: ‘calls’
[13:18:58.918]   - Field: ‘globals’
[13:18:58.919]   - Field: ‘stdout’
[13:18:58.919]   - Field: ‘earlySignal’
[13:18:58.919]   - Field: ‘lazy’
[13:18:58.919]   - Field: ‘state’
[13:18:58.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.919] - Launch lazy future ...
[13:18:58.919] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.919] Packages needed by future strategies (n = 0): <none>
[13:18:58.920] {
[13:18:58.920]     {
[13:18:58.920]         {
[13:18:58.920]             ...future.startTime <- base::Sys.time()
[13:18:58.920]             {
[13:18:58.920]                 {
[13:18:58.920]                   {
[13:18:58.920]                     {
[13:18:58.920]                       {
[13:18:58.920]                         base::local({
[13:18:58.920]                           has_future <- base::requireNamespace("future", 
[13:18:58.920]                             quietly = TRUE)
[13:18:58.920]                           if (has_future) {
[13:18:58.920]                             ns <- base::getNamespace("future")
[13:18:58.920]                             version <- ns[[".package"]][["version"]]
[13:18:58.920]                             if (is.null(version)) 
[13:18:58.920]                               version <- utils::packageVersion("future")
[13:18:58.920]                           }
[13:18:58.920]                           else {
[13:18:58.920]                             version <- NULL
[13:18:58.920]                           }
[13:18:58.920]                           if (!has_future || version < "1.8.0") {
[13:18:58.920]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.920]                               "", base::R.version$version.string), 
[13:18:58.920]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.920]                                 base::R.version$platform, 8 * 
[13:18:58.920]                                   base::.Machine$sizeof.pointer), 
[13:18:58.920]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.920]                                 "release", "version")], collapse = " "), 
[13:18:58.920]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.920]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.920]                               info)
[13:18:58.920]                             info <- base::paste(info, collapse = "; ")
[13:18:58.920]                             if (!has_future) {
[13:18:58.920]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.920]                                 info)
[13:18:58.920]                             }
[13:18:58.920]                             else {
[13:18:58.920]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.920]                                 info, version)
[13:18:58.920]                             }
[13:18:58.920]                             base::stop(msg)
[13:18:58.920]                           }
[13:18:58.920]                         })
[13:18:58.920]                       }
[13:18:58.920]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.920]                       base::options(mc.cores = 1L)
[13:18:58.920]                     }
[13:18:58.920]                     base::local({
[13:18:58.920]                       for (pkg in "future.apply") {
[13:18:58.920]                         base::loadNamespace(pkg)
[13:18:58.920]                         base::library(pkg, character.only = TRUE)
[13:18:58.920]                       }
[13:18:58.920]                     })
[13:18:58.920]                   }
[13:18:58.920]                   options(future.plan = NULL)
[13:18:58.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.920]                 }
[13:18:58.920]                 ...future.workdir <- getwd()
[13:18:58.920]             }
[13:18:58.920]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.920]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.920]         }
[13:18:58.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.920]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.920]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.920]             base::names(...future.oldOptions))
[13:18:58.920]     }
[13:18:58.920]     if (FALSE) {
[13:18:58.920]     }
[13:18:58.920]     else {
[13:18:58.920]         if (TRUE) {
[13:18:58.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.920]                 open = "w")
[13:18:58.920]         }
[13:18:58.920]         else {
[13:18:58.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.920]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.920]         }
[13:18:58.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.920]             base::sink(type = "output", split = FALSE)
[13:18:58.920]             base::close(...future.stdout)
[13:18:58.920]         }, add = TRUE)
[13:18:58.920]     }
[13:18:58.920]     ...future.frame <- base::sys.nframe()
[13:18:58.920]     ...future.conditions <- base::list()
[13:18:58.920]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.920]     if (FALSE) {
[13:18:58.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.920]     }
[13:18:58.920]     ...future.result <- base::tryCatch({
[13:18:58.920]         base::withCallingHandlers({
[13:18:58.920]             ...future.value <- base::withVisible(base::local({
[13:18:58.920]                 withCallingHandlers({
[13:18:58.920]                   {
[13:18:58.920]                     do.call(function(...) {
[13:18:58.920]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.920]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.920]                         ...future.globals.maxSize)) {
[13:18:58.920]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.920]                         on.exit(options(oopts), add = TRUE)
[13:18:58.920]                       }
[13:18:58.920]                       {
[13:18:58.920]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.920]                           FUN = function(jj) {
[13:18:58.920]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.920]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.920]                           })
[13:18:58.920]                       }
[13:18:58.920]                     }, args = future.call.arguments)
[13:18:58.920]                   }
[13:18:58.920]                 }, immediateCondition = function(cond) {
[13:18:58.920]                   save_rds <- function (object, pathname, ...) 
[13:18:58.920]                   {
[13:18:58.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.920]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.920]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.920]                         fi_tmp[["mtime"]])
[13:18:58.920]                     }
[13:18:58.920]                     tryCatch({
[13:18:58.920]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.920]                     }, error = function(ex) {
[13:18:58.920]                       msg <- conditionMessage(ex)
[13:18:58.920]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.920]                         fi_tmp[["mtime"]], msg)
[13:18:58.920]                       ex$message <- msg
[13:18:58.920]                       stop(ex)
[13:18:58.920]                     })
[13:18:58.920]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.920]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.920]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.920]                       fi <- file.info(pathname)
[13:18:58.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.920]                         fi[["size"]], fi[["mtime"]])
[13:18:58.920]                       stop(msg)
[13:18:58.920]                     }
[13:18:58.920]                     invisible(pathname)
[13:18:58.920]                   }
[13:18:58.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.920]                     rootPath = tempdir()) 
[13:18:58.920]                   {
[13:18:58.920]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.920]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.920]                       tmpdir = path, fileext = ".rds")
[13:18:58.920]                     save_rds(obj, file)
[13:18:58.920]                   }
[13:18:58.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.920]                   {
[13:18:58.920]                     inherits <- base::inherits
[13:18:58.920]                     invokeRestart <- base::invokeRestart
[13:18:58.920]                     is.null <- base::is.null
[13:18:58.920]                     muffled <- FALSE
[13:18:58.920]                     if (inherits(cond, "message")) {
[13:18:58.920]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.920]                       if (muffled) 
[13:18:58.920]                         invokeRestart("muffleMessage")
[13:18:58.920]                     }
[13:18:58.920]                     else if (inherits(cond, "warning")) {
[13:18:58.920]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.920]                       if (muffled) 
[13:18:58.920]                         invokeRestart("muffleWarning")
[13:18:58.920]                     }
[13:18:58.920]                     else if (inherits(cond, "condition")) {
[13:18:58.920]                       if (!is.null(pattern)) {
[13:18:58.920]                         computeRestarts <- base::computeRestarts
[13:18:58.920]                         grepl <- base::grepl
[13:18:58.920]                         restarts <- computeRestarts(cond)
[13:18:58.920]                         for (restart in restarts) {
[13:18:58.920]                           name <- restart$name
[13:18:58.920]                           if (is.null(name)) 
[13:18:58.920]                             next
[13:18:58.920]                           if (!grepl(pattern, name)) 
[13:18:58.920]                             next
[13:18:58.920]                           invokeRestart(restart)
[13:18:58.920]                           muffled <- TRUE
[13:18:58.920]                           break
[13:18:58.920]                         }
[13:18:58.920]                       }
[13:18:58.920]                     }
[13:18:58.920]                     invisible(muffled)
[13:18:58.920]                   }
[13:18:58.920]                   muffleCondition(cond)
[13:18:58.920]                 })
[13:18:58.920]             }))
[13:18:58.920]             future::FutureResult(value = ...future.value$value, 
[13:18:58.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.920]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.920]                     ...future.globalenv.names))
[13:18:58.920]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.920]         }, condition = base::local({
[13:18:58.920]             c <- base::c
[13:18:58.920]             inherits <- base::inherits
[13:18:58.920]             invokeRestart <- base::invokeRestart
[13:18:58.920]             length <- base::length
[13:18:58.920]             list <- base::list
[13:18:58.920]             seq.int <- base::seq.int
[13:18:58.920]             signalCondition <- base::signalCondition
[13:18:58.920]             sys.calls <- base::sys.calls
[13:18:58.920]             `[[` <- base::`[[`
[13:18:58.920]             `+` <- base::`+`
[13:18:58.920]             `<<-` <- base::`<<-`
[13:18:58.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.920]                   3L)]
[13:18:58.920]             }
[13:18:58.920]             function(cond) {
[13:18:58.920]                 is_error <- inherits(cond, "error")
[13:18:58.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.920]                   NULL)
[13:18:58.920]                 if (is_error) {
[13:18:58.920]                   sessionInformation <- function() {
[13:18:58.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.920]                       search = base::search(), system = base::Sys.info())
[13:18:58.920]                   }
[13:18:58.920]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.920]                     cond$call), session = sessionInformation(), 
[13:18:58.920]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.920]                   signalCondition(cond)
[13:18:58.920]                 }
[13:18:58.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.920]                 "immediateCondition"))) {
[13:18:58.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.920]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.920]                   if (TRUE && !signal) {
[13:18:58.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.920]                     {
[13:18:58.920]                       inherits <- base::inherits
[13:18:58.920]                       invokeRestart <- base::invokeRestart
[13:18:58.920]                       is.null <- base::is.null
[13:18:58.920]                       muffled <- FALSE
[13:18:58.920]                       if (inherits(cond, "message")) {
[13:18:58.920]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.920]                         if (muffled) 
[13:18:58.920]                           invokeRestart("muffleMessage")
[13:18:58.920]                       }
[13:18:58.920]                       else if (inherits(cond, "warning")) {
[13:18:58.920]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.920]                         if (muffled) 
[13:18:58.920]                           invokeRestart("muffleWarning")
[13:18:58.920]                       }
[13:18:58.920]                       else if (inherits(cond, "condition")) {
[13:18:58.920]                         if (!is.null(pattern)) {
[13:18:58.920]                           computeRestarts <- base::computeRestarts
[13:18:58.920]                           grepl <- base::grepl
[13:18:58.920]                           restarts <- computeRestarts(cond)
[13:18:58.920]                           for (restart in restarts) {
[13:18:58.920]                             name <- restart$name
[13:18:58.920]                             if (is.null(name)) 
[13:18:58.920]                               next
[13:18:58.920]                             if (!grepl(pattern, name)) 
[13:18:58.920]                               next
[13:18:58.920]                             invokeRestart(restart)
[13:18:58.920]                             muffled <- TRUE
[13:18:58.920]                             break
[13:18:58.920]                           }
[13:18:58.920]                         }
[13:18:58.920]                       }
[13:18:58.920]                       invisible(muffled)
[13:18:58.920]                     }
[13:18:58.920]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.920]                   }
[13:18:58.920]                 }
[13:18:58.920]                 else {
[13:18:58.920]                   if (TRUE) {
[13:18:58.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.920]                     {
[13:18:58.920]                       inherits <- base::inherits
[13:18:58.920]                       invokeRestart <- base::invokeRestart
[13:18:58.920]                       is.null <- base::is.null
[13:18:58.920]                       muffled <- FALSE
[13:18:58.920]                       if (inherits(cond, "message")) {
[13:18:58.920]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.920]                         if (muffled) 
[13:18:58.920]                           invokeRestart("muffleMessage")
[13:18:58.920]                       }
[13:18:58.920]                       else if (inherits(cond, "warning")) {
[13:18:58.920]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.920]                         if (muffled) 
[13:18:58.920]                           invokeRestart("muffleWarning")
[13:18:58.920]                       }
[13:18:58.920]                       else if (inherits(cond, "condition")) {
[13:18:58.920]                         if (!is.null(pattern)) {
[13:18:58.920]                           computeRestarts <- base::computeRestarts
[13:18:58.920]                           grepl <- base::grepl
[13:18:58.920]                           restarts <- computeRestarts(cond)
[13:18:58.920]                           for (restart in restarts) {
[13:18:58.920]                             name <- restart$name
[13:18:58.920]                             if (is.null(name)) 
[13:18:58.920]                               next
[13:18:58.920]                             if (!grepl(pattern, name)) 
[13:18:58.920]                               next
[13:18:58.920]                             invokeRestart(restart)
[13:18:58.920]                             muffled <- TRUE
[13:18:58.920]                             break
[13:18:58.920]                           }
[13:18:58.920]                         }
[13:18:58.920]                       }
[13:18:58.920]                       invisible(muffled)
[13:18:58.920]                     }
[13:18:58.920]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.920]                   }
[13:18:58.920]                 }
[13:18:58.920]             }
[13:18:58.920]         }))
[13:18:58.920]     }, error = function(ex) {
[13:18:58.920]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.920]                 ...future.rng), started = ...future.startTime, 
[13:18:58.920]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.920]             version = "1.8"), class = "FutureResult")
[13:18:58.920]     }, finally = {
[13:18:58.920]         if (!identical(...future.workdir, getwd())) 
[13:18:58.920]             setwd(...future.workdir)
[13:18:58.920]         {
[13:18:58.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.920]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.920]             }
[13:18:58.920]             base::options(...future.oldOptions)
[13:18:58.920]             if (.Platform$OS.type == "windows") {
[13:18:58.920]                 old_names <- names(...future.oldEnvVars)
[13:18:58.920]                 envs <- base::Sys.getenv()
[13:18:58.920]                 names <- names(envs)
[13:18:58.920]                 common <- intersect(names, old_names)
[13:18:58.920]                 added <- setdiff(names, old_names)
[13:18:58.920]                 removed <- setdiff(old_names, names)
[13:18:58.920]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.920]                   envs[common]]
[13:18:58.920]                 NAMES <- toupper(changed)
[13:18:58.920]                 args <- list()
[13:18:58.920]                 for (kk in seq_along(NAMES)) {
[13:18:58.920]                   name <- changed[[kk]]
[13:18:58.920]                   NAME <- NAMES[[kk]]
[13:18:58.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.920]                     next
[13:18:58.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.920]                 }
[13:18:58.920]                 NAMES <- toupper(added)
[13:18:58.920]                 for (kk in seq_along(NAMES)) {
[13:18:58.920]                   name <- added[[kk]]
[13:18:58.920]                   NAME <- NAMES[[kk]]
[13:18:58.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.920]                     next
[13:18:58.920]                   args[[name]] <- ""
[13:18:58.920]                 }
[13:18:58.920]                 NAMES <- toupper(removed)
[13:18:58.920]                 for (kk in seq_along(NAMES)) {
[13:18:58.920]                   name <- removed[[kk]]
[13:18:58.920]                   NAME <- NAMES[[kk]]
[13:18:58.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.920]                     next
[13:18:58.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.920]                 }
[13:18:58.920]                 if (length(args) > 0) 
[13:18:58.920]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.920]             }
[13:18:58.920]             else {
[13:18:58.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.920]             }
[13:18:58.920]             {
[13:18:58.920]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.920]                   0L) {
[13:18:58.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.920]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.920]                   base::options(opts)
[13:18:58.920]                 }
[13:18:58.920]                 {
[13:18:58.920]                   {
[13:18:58.920]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.920]                     NULL
[13:18:58.920]                   }
[13:18:58.920]                   options(future.plan = NULL)
[13:18:58.920]                   if (is.na(NA_character_)) 
[13:18:58.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.920]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.920]                     envir = parent.frame()) 
[13:18:58.920]                   {
[13:18:58.920]                     default_workers <- missing(workers)
[13:18:58.920]                     if (is.function(workers)) 
[13:18:58.920]                       workers <- workers()
[13:18:58.920]                     workers <- structure(as.integer(workers), 
[13:18:58.920]                       class = class(workers))
[13:18:58.920]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.920]                       1L)
[13:18:58.920]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.920]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.920]                       if (default_workers) 
[13:18:58.920]                         supportsMulticore(warn = TRUE)
[13:18:58.920]                       return(sequential(..., envir = envir))
[13:18:58.920]                     }
[13:18:58.920]                     oopts <- options(mc.cores = workers)
[13:18:58.920]                     on.exit(options(oopts))
[13:18:58.920]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.920]                       envir = envir)
[13:18:58.920]                     if (!future$lazy) 
[13:18:58.920]                       future <- run(future)
[13:18:58.920]                     invisible(future)
[13:18:58.920]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.920]                 }
[13:18:58.920]             }
[13:18:58.920]         }
[13:18:58.920]     })
[13:18:58.920]     if (TRUE) {
[13:18:58.920]         base::sink(type = "output", split = FALSE)
[13:18:58.920]         if (TRUE) {
[13:18:58.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.920]         }
[13:18:58.920]         else {
[13:18:58.920]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.920]         }
[13:18:58.920]         base::close(...future.stdout)
[13:18:58.920]         ...future.stdout <- NULL
[13:18:58.920]     }
[13:18:58.920]     ...future.result$conditions <- ...future.conditions
[13:18:58.920]     ...future.result$finished <- base::Sys.time()
[13:18:58.920]     ...future.result
[13:18:58.920] }
[13:18:58.923] assign_globals() ...
[13:18:58.923] List of 11
[13:18:58.923]  $ ...future.FUN            :function (x, ...)  
[13:18:58.923]  $ x_FUN                    :function (x)  
[13:18:58.923]  $ times                    : int 4
[13:18:58.923]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.923]  $ stop_if_not              :function (...)  
[13:18:58.923]  $ dim                      : int [1:2] 2 2
[13:18:58.923]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:58.923]  $ future.call.arguments    : list()
[13:18:58.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.923]  $ ...future.elements_ii    :List of 5
[13:18:58.923]   ..$ : int 1
[13:18:58.923]   ..$ : int 2
[13:18:58.923]   ..$ : int 3
[13:18:58.923]   ..$ : int 4
[13:18:58.923]   ..$ : int 5
[13:18:58.923]  $ ...future.seeds_ii       : NULL
[13:18:58.923]  $ ...future.globals.maxSize: NULL
[13:18:58.923]  - attr(*, "resolved")= logi FALSE
[13:18:58.923]  - attr(*, "total_size")= num 97232
[13:18:58.923]  - attr(*, "where")=List of 11
[13:18:58.923]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.923]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.923]  - attr(*, "already-done")= logi TRUE
[13:18:58.934] - copied ‘...future.FUN’ to environment
[13:18:58.934] - reassign environment for ‘x_FUN’
[13:18:58.934] - copied ‘x_FUN’ to environment
[13:18:58.934] - copied ‘times’ to environment
[13:18:58.935] - copied ‘stopf’ to environment
[13:18:58.935] - copied ‘stop_if_not’ to environment
[13:18:58.935] - copied ‘dim’ to environment
[13:18:58.935] - copied ‘valid_types’ to environment
[13:18:58.935] - copied ‘future.call.arguments’ to environment
[13:18:58.935] - copied ‘...future.elements_ii’ to environment
[13:18:58.935] - copied ‘...future.seeds_ii’ to environment
[13:18:58.935] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.935] assign_globals() ... done
[13:18:58.936] requestCore(): workers = 2
[13:18:58.938] MulticoreFuture started
[13:18:58.938] - Launch lazy future ... done
[13:18:58.939] run() for ‘MulticoreFuture’ ... done
[13:18:58.939] Created future:
[13:18:58.939] plan(): Setting new future strategy stack:
[13:18:58.940] List of future strategies:
[13:18:58.940] 1. sequential:
[13:18:58.940]    - args: function (..., envir = parent.frame())
[13:18:58.940]    - tweaked: FALSE
[13:18:58.940]    - call: NULL
[13:18:58.941] plan(): nbrOfWorkers() = 1
[13:18:58.943] plan(): Setting new future strategy stack:
[13:18:58.943] List of future strategies:
[13:18:58.943] 1. multicore:
[13:18:58.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.943]    - tweaked: FALSE
[13:18:58.943]    - call: plan(strategy)
[13:18:58.949] plan(): nbrOfWorkers() = 2
[13:18:58.939] MulticoreFuture:
[13:18:58.939] Label: ‘future_vapply-1’
[13:18:58.939] Expression:
[13:18:58.939] {
[13:18:58.939]     do.call(function(...) {
[13:18:58.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.939]             on.exit(options(oopts), add = TRUE)
[13:18:58.939]         }
[13:18:58.939]         {
[13:18:58.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.939]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.939]             })
[13:18:58.939]         }
[13:18:58.939]     }, args = future.call.arguments)
[13:18:58.939] }
[13:18:58.939] Lazy evaluation: FALSE
[13:18:58.939] Asynchronous evaluation: TRUE
[13:18:58.939] Local evaluation: TRUE
[13:18:58.939] Environment: R_GlobalEnv
[13:18:58.939] Capture standard output: TRUE
[13:18:58.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.939] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.939] Packages: 1 packages (‘future.apply’)
[13:18:58.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.939] Resolved: TRUE
[13:18:58.939] Value: <not collected>
[13:18:58.939] Conditions captured: <none>
[13:18:58.939] Early signaling: FALSE
[13:18:58.939] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.939] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.951] Chunk #1 of 2 ... DONE
[13:18:58.951] Chunk #2 of 2 ...
[13:18:58.951]  - Finding globals in 'X' for chunk #2 ...
[13:18:58.951] getGlobalsAndPackages() ...
[13:18:58.951] Searching for globals...
[13:18:58.952] 
[13:18:58.952] Searching for globals ... DONE
[13:18:58.952] - globals: [0] <none>
[13:18:58.952] getGlobalsAndPackages() ... DONE
[13:18:58.953]    + additional globals found: [n=0] 
[13:18:58.953]    + additional namespaces needed: [n=0] 
[13:18:58.953]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:58.953]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:58.953]  - seeds: <none>
[13:18:58.953] getGlobalsAndPackages() ...
[13:18:58.954] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.954] Resolving globals: FALSE
[13:18:58.954] Tweak future expression to call with '...' arguments ...
[13:18:58.954] {
[13:18:58.954]     do.call(function(...) {
[13:18:58.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.954]             on.exit(options(oopts), add = TRUE)
[13:18:58.954]         }
[13:18:58.954]         {
[13:18:58.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.954]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.954]             })
[13:18:58.954]         }
[13:18:58.954]     }, args = future.call.arguments)
[13:18:58.954] }
[13:18:58.955] Tweak future expression to call with '...' arguments ... DONE
[13:18:58.956] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:58.956] - packages: [1] ‘future.apply’
[13:18:58.956] getGlobalsAndPackages() ... DONE
[13:18:58.957] run() for ‘Future’ ...
[13:18:58.957] - state: ‘created’
[13:18:58.957] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:58.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:58.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:58.962]   - Field: ‘label’
[13:18:58.962]   - Field: ‘local’
[13:18:58.962]   - Field: ‘owner’
[13:18:58.963]   - Field: ‘envir’
[13:18:58.963]   - Field: ‘workers’
[13:18:58.963]   - Field: ‘packages’
[13:18:58.963]   - Field: ‘gc’
[13:18:58.963]   - Field: ‘job’
[13:18:58.963]   - Field: ‘conditions’
[13:18:58.963]   - Field: ‘expr’
[13:18:58.964]   - Field: ‘uuid’
[13:18:58.964]   - Field: ‘seed’
[13:18:58.964]   - Field: ‘version’
[13:18:58.964]   - Field: ‘result’
[13:18:58.964]   - Field: ‘asynchronous’
[13:18:58.964]   - Field: ‘calls’
[13:18:58.964]   - Field: ‘globals’
[13:18:58.965]   - Field: ‘stdout’
[13:18:58.965]   - Field: ‘earlySignal’
[13:18:58.965]   - Field: ‘lazy’
[13:18:58.965]   - Field: ‘state’
[13:18:58.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:58.965] - Launch lazy future ...
[13:18:58.966] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:58.966] Packages needed by future strategies (n = 0): <none>
[13:18:58.967] {
[13:18:58.967]     {
[13:18:58.967]         {
[13:18:58.967]             ...future.startTime <- base::Sys.time()
[13:18:58.967]             {
[13:18:58.967]                 {
[13:18:58.967]                   {
[13:18:58.967]                     {
[13:18:58.967]                       {
[13:18:58.967]                         base::local({
[13:18:58.967]                           has_future <- base::requireNamespace("future", 
[13:18:58.967]                             quietly = TRUE)
[13:18:58.967]                           if (has_future) {
[13:18:58.967]                             ns <- base::getNamespace("future")
[13:18:58.967]                             version <- ns[[".package"]][["version"]]
[13:18:58.967]                             if (is.null(version)) 
[13:18:58.967]                               version <- utils::packageVersion("future")
[13:18:58.967]                           }
[13:18:58.967]                           else {
[13:18:58.967]                             version <- NULL
[13:18:58.967]                           }
[13:18:58.967]                           if (!has_future || version < "1.8.0") {
[13:18:58.967]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:58.967]                               "", base::R.version$version.string), 
[13:18:58.967]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:58.967]                                 base::R.version$platform, 8 * 
[13:18:58.967]                                   base::.Machine$sizeof.pointer), 
[13:18:58.967]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:58.967]                                 "release", "version")], collapse = " "), 
[13:18:58.967]                               hostname = base::Sys.info()[["nodename"]])
[13:18:58.967]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:58.967]                               info)
[13:18:58.967]                             info <- base::paste(info, collapse = "; ")
[13:18:58.967]                             if (!has_future) {
[13:18:58.967]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:58.967]                                 info)
[13:18:58.967]                             }
[13:18:58.967]                             else {
[13:18:58.967]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:58.967]                                 info, version)
[13:18:58.967]                             }
[13:18:58.967]                             base::stop(msg)
[13:18:58.967]                           }
[13:18:58.967]                         })
[13:18:58.967]                       }
[13:18:58.967]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:58.967]                       base::options(mc.cores = 1L)
[13:18:58.967]                     }
[13:18:58.967]                     base::local({
[13:18:58.967]                       for (pkg in "future.apply") {
[13:18:58.967]                         base::loadNamespace(pkg)
[13:18:58.967]                         base::library(pkg, character.only = TRUE)
[13:18:58.967]                       }
[13:18:58.967]                     })
[13:18:58.967]                   }
[13:18:58.967]                   options(future.plan = NULL)
[13:18:58.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:58.967]                 }
[13:18:58.967]                 ...future.workdir <- getwd()
[13:18:58.967]             }
[13:18:58.967]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:58.967]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:58.967]         }
[13:18:58.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:58.967]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:58.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:58.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:58.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:58.967]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:58.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:58.967]             base::names(...future.oldOptions))
[13:18:58.967]     }
[13:18:58.967]     if (FALSE) {
[13:18:58.967]     }
[13:18:58.967]     else {
[13:18:58.967]         if (TRUE) {
[13:18:58.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:58.967]                 open = "w")
[13:18:58.967]         }
[13:18:58.967]         else {
[13:18:58.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:58.967]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:58.967]         }
[13:18:58.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:58.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:58.967]             base::sink(type = "output", split = FALSE)
[13:18:58.967]             base::close(...future.stdout)
[13:18:58.967]         }, add = TRUE)
[13:18:58.967]     }
[13:18:58.967]     ...future.frame <- base::sys.nframe()
[13:18:58.967]     ...future.conditions <- base::list()
[13:18:58.967]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:58.967]     if (FALSE) {
[13:18:58.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:58.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:58.967]     }
[13:18:58.967]     ...future.result <- base::tryCatch({
[13:18:58.967]         base::withCallingHandlers({
[13:18:58.967]             ...future.value <- base::withVisible(base::local({
[13:18:58.967]                 withCallingHandlers({
[13:18:58.967]                   {
[13:18:58.967]                     do.call(function(...) {
[13:18:58.967]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.967]                       if (!identical(...future.globals.maxSize.org, 
[13:18:58.967]                         ...future.globals.maxSize)) {
[13:18:58.967]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.967]                         on.exit(options(oopts), add = TRUE)
[13:18:58.967]                       }
[13:18:58.967]                       {
[13:18:58.967]                         lapply(seq_along(...future.elements_ii), 
[13:18:58.967]                           FUN = function(jj) {
[13:18:58.967]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.967]                             ...future.FUN(...future.X_jj, ...)
[13:18:58.967]                           })
[13:18:58.967]                       }
[13:18:58.967]                     }, args = future.call.arguments)
[13:18:58.967]                   }
[13:18:58.967]                 }, immediateCondition = function(cond) {
[13:18:58.967]                   save_rds <- function (object, pathname, ...) 
[13:18:58.967]                   {
[13:18:58.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:58.967]                     if (file_test("-f", pathname_tmp)) {
[13:18:58.967]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:58.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.967]                         fi_tmp[["mtime"]])
[13:18:58.967]                     }
[13:18:58.967]                     tryCatch({
[13:18:58.967]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:58.967]                     }, error = function(ex) {
[13:18:58.967]                       msg <- conditionMessage(ex)
[13:18:58.967]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:58.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.967]                         fi_tmp[["mtime"]], msg)
[13:18:58.967]                       ex$message <- msg
[13:18:58.967]                       stop(ex)
[13:18:58.967]                     })
[13:18:58.967]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:58.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:58.967]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:58.967]                       fi_tmp <- file.info(pathname_tmp)
[13:18:58.967]                       fi <- file.info(pathname)
[13:18:58.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:58.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:58.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:58.967]                         fi[["size"]], fi[["mtime"]])
[13:18:58.967]                       stop(msg)
[13:18:58.967]                     }
[13:18:58.967]                     invisible(pathname)
[13:18:58.967]                   }
[13:18:58.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:58.967]                     rootPath = tempdir()) 
[13:18:58.967]                   {
[13:18:58.967]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:58.967]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:58.967]                       tmpdir = path, fileext = ".rds")
[13:18:58.967]                     save_rds(obj, file)
[13:18:58.967]                   }
[13:18:58.967]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:58.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.967]                   {
[13:18:58.967]                     inherits <- base::inherits
[13:18:58.967]                     invokeRestart <- base::invokeRestart
[13:18:58.967]                     is.null <- base::is.null
[13:18:58.967]                     muffled <- FALSE
[13:18:58.967]                     if (inherits(cond, "message")) {
[13:18:58.967]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:58.967]                       if (muffled) 
[13:18:58.967]                         invokeRestart("muffleMessage")
[13:18:58.967]                     }
[13:18:58.967]                     else if (inherits(cond, "warning")) {
[13:18:58.967]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:58.967]                       if (muffled) 
[13:18:58.967]                         invokeRestart("muffleWarning")
[13:18:58.967]                     }
[13:18:58.967]                     else if (inherits(cond, "condition")) {
[13:18:58.967]                       if (!is.null(pattern)) {
[13:18:58.967]                         computeRestarts <- base::computeRestarts
[13:18:58.967]                         grepl <- base::grepl
[13:18:58.967]                         restarts <- computeRestarts(cond)
[13:18:58.967]                         for (restart in restarts) {
[13:18:58.967]                           name <- restart$name
[13:18:58.967]                           if (is.null(name)) 
[13:18:58.967]                             next
[13:18:58.967]                           if (!grepl(pattern, name)) 
[13:18:58.967]                             next
[13:18:58.967]                           invokeRestart(restart)
[13:18:58.967]                           muffled <- TRUE
[13:18:58.967]                           break
[13:18:58.967]                         }
[13:18:58.967]                       }
[13:18:58.967]                     }
[13:18:58.967]                     invisible(muffled)
[13:18:58.967]                   }
[13:18:58.967]                   muffleCondition(cond)
[13:18:58.967]                 })
[13:18:58.967]             }))
[13:18:58.967]             future::FutureResult(value = ...future.value$value, 
[13:18:58.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.967]                   ...future.rng), globalenv = if (FALSE) 
[13:18:58.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:58.967]                     ...future.globalenv.names))
[13:18:58.967]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:58.967]         }, condition = base::local({
[13:18:58.967]             c <- base::c
[13:18:58.967]             inherits <- base::inherits
[13:18:58.967]             invokeRestart <- base::invokeRestart
[13:18:58.967]             length <- base::length
[13:18:58.967]             list <- base::list
[13:18:58.967]             seq.int <- base::seq.int
[13:18:58.967]             signalCondition <- base::signalCondition
[13:18:58.967]             sys.calls <- base::sys.calls
[13:18:58.967]             `[[` <- base::`[[`
[13:18:58.967]             `+` <- base::`+`
[13:18:58.967]             `<<-` <- base::`<<-`
[13:18:58.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:58.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:58.967]                   3L)]
[13:18:58.967]             }
[13:18:58.967]             function(cond) {
[13:18:58.967]                 is_error <- inherits(cond, "error")
[13:18:58.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:58.967]                   NULL)
[13:18:58.967]                 if (is_error) {
[13:18:58.967]                   sessionInformation <- function() {
[13:18:58.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:58.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:58.967]                       search = base::search(), system = base::Sys.info())
[13:18:58.967]                   }
[13:18:58.967]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:58.967]                     cond$call), session = sessionInformation(), 
[13:18:58.967]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:58.967]                   signalCondition(cond)
[13:18:58.967]                 }
[13:18:58.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:58.967]                 "immediateCondition"))) {
[13:18:58.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:58.967]                   ...future.conditions[[length(...future.conditions) + 
[13:18:58.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:58.967]                   if (TRUE && !signal) {
[13:18:58.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.967]                     {
[13:18:58.967]                       inherits <- base::inherits
[13:18:58.967]                       invokeRestart <- base::invokeRestart
[13:18:58.967]                       is.null <- base::is.null
[13:18:58.967]                       muffled <- FALSE
[13:18:58.967]                       if (inherits(cond, "message")) {
[13:18:58.967]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.967]                         if (muffled) 
[13:18:58.967]                           invokeRestart("muffleMessage")
[13:18:58.967]                       }
[13:18:58.967]                       else if (inherits(cond, "warning")) {
[13:18:58.967]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.967]                         if (muffled) 
[13:18:58.967]                           invokeRestart("muffleWarning")
[13:18:58.967]                       }
[13:18:58.967]                       else if (inherits(cond, "condition")) {
[13:18:58.967]                         if (!is.null(pattern)) {
[13:18:58.967]                           computeRestarts <- base::computeRestarts
[13:18:58.967]                           grepl <- base::grepl
[13:18:58.967]                           restarts <- computeRestarts(cond)
[13:18:58.967]                           for (restart in restarts) {
[13:18:58.967]                             name <- restart$name
[13:18:58.967]                             if (is.null(name)) 
[13:18:58.967]                               next
[13:18:58.967]                             if (!grepl(pattern, name)) 
[13:18:58.967]                               next
[13:18:58.967]                             invokeRestart(restart)
[13:18:58.967]                             muffled <- TRUE
[13:18:58.967]                             break
[13:18:58.967]                           }
[13:18:58.967]                         }
[13:18:58.967]                       }
[13:18:58.967]                       invisible(muffled)
[13:18:58.967]                     }
[13:18:58.967]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.967]                   }
[13:18:58.967]                 }
[13:18:58.967]                 else {
[13:18:58.967]                   if (TRUE) {
[13:18:58.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:58.967]                     {
[13:18:58.967]                       inherits <- base::inherits
[13:18:58.967]                       invokeRestart <- base::invokeRestart
[13:18:58.967]                       is.null <- base::is.null
[13:18:58.967]                       muffled <- FALSE
[13:18:58.967]                       if (inherits(cond, "message")) {
[13:18:58.967]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:58.967]                         if (muffled) 
[13:18:58.967]                           invokeRestart("muffleMessage")
[13:18:58.967]                       }
[13:18:58.967]                       else if (inherits(cond, "warning")) {
[13:18:58.967]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:58.967]                         if (muffled) 
[13:18:58.967]                           invokeRestart("muffleWarning")
[13:18:58.967]                       }
[13:18:58.967]                       else if (inherits(cond, "condition")) {
[13:18:58.967]                         if (!is.null(pattern)) {
[13:18:58.967]                           computeRestarts <- base::computeRestarts
[13:18:58.967]                           grepl <- base::grepl
[13:18:58.967]                           restarts <- computeRestarts(cond)
[13:18:58.967]                           for (restart in restarts) {
[13:18:58.967]                             name <- restart$name
[13:18:58.967]                             if (is.null(name)) 
[13:18:58.967]                               next
[13:18:58.967]                             if (!grepl(pattern, name)) 
[13:18:58.967]                               next
[13:18:58.967]                             invokeRestart(restart)
[13:18:58.967]                             muffled <- TRUE
[13:18:58.967]                             break
[13:18:58.967]                           }
[13:18:58.967]                         }
[13:18:58.967]                       }
[13:18:58.967]                       invisible(muffled)
[13:18:58.967]                     }
[13:18:58.967]                     muffleCondition(cond, pattern = "^muffle")
[13:18:58.967]                   }
[13:18:58.967]                 }
[13:18:58.967]             }
[13:18:58.967]         }))
[13:18:58.967]     }, error = function(ex) {
[13:18:58.967]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:58.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:58.967]                 ...future.rng), started = ...future.startTime, 
[13:18:58.967]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:58.967]             version = "1.8"), class = "FutureResult")
[13:18:58.967]     }, finally = {
[13:18:58.967]         if (!identical(...future.workdir, getwd())) 
[13:18:58.967]             setwd(...future.workdir)
[13:18:58.967]         {
[13:18:58.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:58.967]                 ...future.oldOptions$nwarnings <- NULL
[13:18:58.967]             }
[13:18:58.967]             base::options(...future.oldOptions)
[13:18:58.967]             if (.Platform$OS.type == "windows") {
[13:18:58.967]                 old_names <- names(...future.oldEnvVars)
[13:18:58.967]                 envs <- base::Sys.getenv()
[13:18:58.967]                 names <- names(envs)
[13:18:58.967]                 common <- intersect(names, old_names)
[13:18:58.967]                 added <- setdiff(names, old_names)
[13:18:58.967]                 removed <- setdiff(old_names, names)
[13:18:58.967]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:58.967]                   envs[common]]
[13:18:58.967]                 NAMES <- toupper(changed)
[13:18:58.967]                 args <- list()
[13:18:58.967]                 for (kk in seq_along(NAMES)) {
[13:18:58.967]                   name <- changed[[kk]]
[13:18:58.967]                   NAME <- NAMES[[kk]]
[13:18:58.967]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.967]                     next
[13:18:58.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.967]                 }
[13:18:58.967]                 NAMES <- toupper(added)
[13:18:58.967]                 for (kk in seq_along(NAMES)) {
[13:18:58.967]                   name <- added[[kk]]
[13:18:58.967]                   NAME <- NAMES[[kk]]
[13:18:58.967]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.967]                     next
[13:18:58.967]                   args[[name]] <- ""
[13:18:58.967]                 }
[13:18:58.967]                 NAMES <- toupper(removed)
[13:18:58.967]                 for (kk in seq_along(NAMES)) {
[13:18:58.967]                   name <- removed[[kk]]
[13:18:58.967]                   NAME <- NAMES[[kk]]
[13:18:58.967]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:58.967]                     next
[13:18:58.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:58.967]                 }
[13:18:58.967]                 if (length(args) > 0) 
[13:18:58.967]                   base::do.call(base::Sys.setenv, args = args)
[13:18:58.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:58.967]             }
[13:18:58.967]             else {
[13:18:58.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:58.967]             }
[13:18:58.967]             {
[13:18:58.967]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:58.967]                   0L) {
[13:18:58.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:58.967]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:58.967]                   base::options(opts)
[13:18:58.967]                 }
[13:18:58.967]                 {
[13:18:58.967]                   {
[13:18:58.967]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:58.967]                     NULL
[13:18:58.967]                   }
[13:18:58.967]                   options(future.plan = NULL)
[13:18:58.967]                   if (is.na(NA_character_)) 
[13:18:58.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:58.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:58.967]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:58.967]                     envir = parent.frame()) 
[13:18:58.967]                   {
[13:18:58.967]                     default_workers <- missing(workers)
[13:18:58.967]                     if (is.function(workers)) 
[13:18:58.967]                       workers <- workers()
[13:18:58.967]                     workers <- structure(as.integer(workers), 
[13:18:58.967]                       class = class(workers))
[13:18:58.967]                     stop_if_not(is.finite(workers), workers >= 
[13:18:58.967]                       1L)
[13:18:58.967]                     if ((workers == 1L && !inherits(workers, 
[13:18:58.967]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:58.967]                       if (default_workers) 
[13:18:58.967]                         supportsMulticore(warn = TRUE)
[13:18:58.967]                       return(sequential(..., envir = envir))
[13:18:58.967]                     }
[13:18:58.967]                     oopts <- options(mc.cores = workers)
[13:18:58.967]                     on.exit(options(oopts))
[13:18:58.967]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:58.967]                       envir = envir)
[13:18:58.967]                     if (!future$lazy) 
[13:18:58.967]                       future <- run(future)
[13:18:58.967]                     invisible(future)
[13:18:58.967]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:58.967]                 }
[13:18:58.967]             }
[13:18:58.967]         }
[13:18:58.967]     })
[13:18:58.967]     if (TRUE) {
[13:18:58.967]         base::sink(type = "output", split = FALSE)
[13:18:58.967]         if (TRUE) {
[13:18:58.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:58.967]         }
[13:18:58.967]         else {
[13:18:58.967]             ...future.result["stdout"] <- base::list(NULL)
[13:18:58.967]         }
[13:18:58.967]         base::close(...future.stdout)
[13:18:58.967]         ...future.stdout <- NULL
[13:18:58.967]     }
[13:18:58.967]     ...future.result$conditions <- ...future.conditions
[13:18:58.967]     ...future.result$finished <- base::Sys.time()
[13:18:58.967]     ...future.result
[13:18:58.967] }
[13:18:58.970] assign_globals() ...
[13:18:58.971] List of 11
[13:18:58.971]  $ ...future.FUN            :function (x, ...)  
[13:18:58.971]  $ x_FUN                    :function (x)  
[13:18:58.971]  $ times                    : int 4
[13:18:58.971]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:58.971]  $ stop_if_not              :function (...)  
[13:18:58.971]  $ dim                      : int [1:2] 2 2
[13:18:58.971]  $ valid_types              : chr [1:2] "logical" "integer"
[13:18:58.971]  $ future.call.arguments    : list()
[13:18:58.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:58.971]  $ ...future.elements_ii    :List of 5
[13:18:58.971]   ..$ : int 6
[13:18:58.971]   ..$ : int 7
[13:18:58.971]   ..$ : int 8
[13:18:58.971]   ..$ : int 9
[13:18:58.971]   ..$ : int 10
[13:18:58.971]  $ ...future.seeds_ii       : NULL
[13:18:58.971]  $ ...future.globals.maxSize: NULL
[13:18:58.971]  - attr(*, "resolved")= logi FALSE
[13:18:58.971]  - attr(*, "total_size")= num 97232
[13:18:58.971]  - attr(*, "where")=List of 11
[13:18:58.971]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:58.971]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:58.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:58.971]  - attr(*, "already-done")= logi TRUE
[13:18:58.989] - copied ‘...future.FUN’ to environment
[13:18:58.989] - reassign environment for ‘x_FUN’
[13:18:58.989] - copied ‘x_FUN’ to environment
[13:18:58.989] - copied ‘times’ to environment
[13:18:58.989] - copied ‘stopf’ to environment
[13:18:58.990] - copied ‘stop_if_not’ to environment
[13:18:58.990] - copied ‘dim’ to environment
[13:18:58.990] - copied ‘valid_types’ to environment
[13:18:58.990] - copied ‘future.call.arguments’ to environment
[13:18:58.990] - copied ‘...future.elements_ii’ to environment
[13:18:58.990] - copied ‘...future.seeds_ii’ to environment
[13:18:58.990] - copied ‘...future.globals.maxSize’ to environment
[13:18:58.990] assign_globals() ... done
[13:18:58.990] requestCore(): workers = 2
[13:18:58.993] MulticoreFuture started
[13:18:58.993] - Launch lazy future ... done
[13:18:58.993] run() for ‘MulticoreFuture’ ... done
[13:18:58.994] Created future:
[13:18:58.994] plan(): Setting new future strategy stack:
[13:18:58.994] List of future strategies:
[13:18:58.994] 1. sequential:
[13:18:58.994]    - args: function (..., envir = parent.frame())
[13:18:58.994]    - tweaked: FALSE
[13:18:58.994]    - call: NULL
[13:18:58.995] plan(): nbrOfWorkers() = 1
[13:18:58.998] plan(): Setting new future strategy stack:
[13:18:58.998] List of future strategies:
[13:18:58.998] 1. multicore:
[13:18:58.998]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:58.998]    - tweaked: FALSE
[13:18:58.998]    - call: plan(strategy)
[13:18:59.004] plan(): nbrOfWorkers() = 2
[13:18:58.994] MulticoreFuture:
[13:18:58.994] Label: ‘future_vapply-2’
[13:18:58.994] Expression:
[13:18:58.994] {
[13:18:58.994]     do.call(function(...) {
[13:18:58.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:58.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:58.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:58.994]             on.exit(options(oopts), add = TRUE)
[13:18:58.994]         }
[13:18:58.994]         {
[13:18:58.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:58.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:58.994]                 ...future.FUN(...future.X_jj, ...)
[13:18:58.994]             })
[13:18:58.994]         }
[13:18:58.994]     }, args = future.call.arguments)
[13:18:58.994] }
[13:18:58.994] Lazy evaluation: FALSE
[13:18:58.994] Asynchronous evaluation: TRUE
[13:18:58.994] Local evaluation: TRUE
[13:18:58.994] Environment: R_GlobalEnv
[13:18:58.994] Capture standard output: TRUE
[13:18:58.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:58.994] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:58.994] Packages: 1 packages (‘future.apply’)
[13:18:58.994] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:58.994] Resolved: TRUE
[13:18:58.994] Value: <not collected>
[13:18:58.994] Conditions captured: <none>
[13:18:58.994] Early signaling: FALSE
[13:18:58.994] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:58.994] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.005] Chunk #2 of 2 ... DONE
[13:18:59.005] Launching 2 futures (chunks) ... DONE
[13:18:59.005] Resolving 2 futures (chunks) ...
[13:18:59.006] resolve() on list ...
[13:18:59.006]  recursive: 0
[13:18:59.006]  length: 2
[13:18:59.006] 
[13:18:59.006] Future #1
[13:18:59.007] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.008] - nx: 2
[13:18:59.008] - relay: TRUE
[13:18:59.008] - stdout: TRUE
[13:18:59.008] - signal: TRUE
[13:18:59.008] - resignal: FALSE
[13:18:59.008] - force: TRUE
[13:18:59.008] - relayed: [n=2] FALSE, FALSE
[13:18:59.009] - queued futures: [n=2] FALSE, FALSE
[13:18:59.009]  - until=1
[13:18:59.009]  - relaying element #1
[13:18:59.009] - relayed: [n=2] TRUE, FALSE
[13:18:59.010] - queued futures: [n=2] TRUE, FALSE
[13:18:59.010] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.010]  length: 1 (resolved future 1)
[13:18:59.010] Future #2
[13:18:59.011] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.011] - nx: 2
[13:18:59.011] - relay: TRUE
[13:18:59.012] - stdout: TRUE
[13:18:59.012] - signal: TRUE
[13:18:59.012] - resignal: FALSE
[13:18:59.012] - force: TRUE
[13:18:59.012] - relayed: [n=2] TRUE, FALSE
[13:18:59.012] - queued futures: [n=2] TRUE, FALSE
[13:18:59.012]  - until=2
[13:18:59.012]  - relaying element #2
[13:18:59.013] - relayed: [n=2] TRUE, TRUE
[13:18:59.013] - queued futures: [n=2] TRUE, TRUE
[13:18:59.013] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.013]  length: 0 (resolved future 2)
[13:18:59.013] Relaying remaining futures
[13:18:59.013] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.013] - nx: 2
[13:18:59.014] - relay: TRUE
[13:18:59.014] - stdout: TRUE
[13:18:59.014] - signal: TRUE
[13:18:59.014] - resignal: FALSE
[13:18:59.014] - force: TRUE
[13:18:59.014] - relayed: [n=2] TRUE, TRUE
[13:18:59.014] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.014] - relayed: [n=2] TRUE, TRUE
[13:18:59.015] - queued futures: [n=2] TRUE, TRUE
[13:18:59.015] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.015] resolve() on list ... DONE
[13:18:59.015]  - Number of value chunks collected: 2
[13:18:59.015] Resolving 2 futures (chunks) ... DONE
[13:18:59.015] Reducing values from 2 chunks ...
[13:18:59.015]  - Number of values collected after concatenation: 10
[13:18:59.015]  - Number of values expected: 10
[13:18:59.016] Reducing values from 2 chunks ... DONE
[13:18:59.016] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:18:59.017] future_lapply() ...
[13:18:59.024] Number of chunks: 2
[13:18:59.024] getGlobalsAndPackagesXApply() ...
[13:18:59.024]  - future.globals: TRUE
[13:18:59.024] getGlobalsAndPackages() ...
[13:18:59.024] Searching for globals...
[13:18:59.032] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:18:59.032] Searching for globals ... DONE
[13:18:59.032] Resolving globals: FALSE
[13:18:59.033] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:18:59.034] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:59.034] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.034] - packages: [1] ‘future.apply’
[13:18:59.034] getGlobalsAndPackages() ... DONE
[13:18:59.034]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.034]  - needed namespaces: [n=1] ‘future.apply’
[13:18:59.034] Finding globals ... DONE
[13:18:59.034]  - use_args: TRUE
[13:18:59.035]  - Getting '...' globals ...
[13:18:59.035] resolve() on list ...
[13:18:59.035]  recursive: 0
[13:18:59.035]  length: 1
[13:18:59.035]  elements: ‘...’
[13:18:59.035]  length: 0 (resolved future 1)
[13:18:59.035] resolve() on list ... DONE
[13:18:59.036]    - '...' content: [n=0] 
[13:18:59.036] List of 1
[13:18:59.036]  $ ...: list()
[13:18:59.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.036]  - attr(*, "where")=List of 1
[13:18:59.036]   ..$ ...:<environment: 0x555f7b540a10> 
[13:18:59.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.036]  - attr(*, "resolved")= logi TRUE
[13:18:59.036]  - attr(*, "total_size")= num NA
[13:18:59.038]  - Getting '...' globals ... DONE
[13:18:59.038] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:59.039] List of 8
[13:18:59.039]  $ ...future.FUN:function (x, ...)  
[13:18:59.039]  $ x_FUN        :function (x)  
[13:18:59.039]  $ times        : int 4
[13:18:59.039]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.039]  $ stop_if_not  :function (...)  
[13:18:59.039]  $ dim          : int [1:2] 2 2
[13:18:59.039]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:59.039]  $ ...          : list()
[13:18:59.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.039]  - attr(*, "where")=List of 8
[13:18:59.039]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:59.039]   ..$ ...          :<environment: 0x555f7b540a10> 
[13:18:59.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.039]  - attr(*, "resolved")= logi FALSE
[13:18:59.039]  - attr(*, "total_size")= num 97304
[13:18:59.044] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:59.044] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.044] Number of futures (= number of chunks): 2
[13:18:59.045] Launching 2 futures (chunks) ...
[13:18:59.045] Chunk #1 of 2 ...
[13:18:59.045]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.045] getGlobalsAndPackages() ...
[13:18:59.045] Searching for globals...
[13:18:59.045] 
[13:18:59.045] Searching for globals ... DONE
[13:18:59.046] - globals: [0] <none>
[13:18:59.046] getGlobalsAndPackages() ... DONE
[13:18:59.046]    + additional globals found: [n=0] 
[13:18:59.046]    + additional namespaces needed: [n=0] 
[13:18:59.046]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.046]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:59.046]  - seeds: <none>
[13:18:59.046] getGlobalsAndPackages() ...
[13:18:59.046] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.046] Resolving globals: FALSE
[13:18:59.047] Tweak future expression to call with '...' arguments ...
[13:18:59.047] {
[13:18:59.047]     do.call(function(...) {
[13:18:59.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.047]             on.exit(options(oopts), add = TRUE)
[13:18:59.047]         }
[13:18:59.047]         {
[13:18:59.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.047]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.047]             })
[13:18:59.047]         }
[13:18:59.047]     }, args = future.call.arguments)
[13:18:59.047] }
[13:18:59.047] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.049] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.049] - packages: [1] ‘future.apply’
[13:18:59.050] getGlobalsAndPackages() ... DONE
[13:18:59.050] run() for ‘Future’ ...
[13:18:59.050] - state: ‘created’
[13:18:59.050] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.054] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.055]   - Field: ‘label’
[13:18:59.055]   - Field: ‘local’
[13:18:59.055]   - Field: ‘owner’
[13:18:59.055]   - Field: ‘envir’
[13:18:59.055]   - Field: ‘workers’
[13:18:59.055]   - Field: ‘packages’
[13:18:59.055]   - Field: ‘gc’
[13:18:59.055]   - Field: ‘job’
[13:18:59.056]   - Field: ‘conditions’
[13:18:59.056]   - Field: ‘expr’
[13:18:59.056]   - Field: ‘uuid’
[13:18:59.056]   - Field: ‘seed’
[13:18:59.056]   - Field: ‘version’
[13:18:59.056]   - Field: ‘result’
[13:18:59.056]   - Field: ‘asynchronous’
[13:18:59.056]   - Field: ‘calls’
[13:18:59.056]   - Field: ‘globals’
[13:18:59.057]   - Field: ‘stdout’
[13:18:59.057]   - Field: ‘earlySignal’
[13:18:59.057]   - Field: ‘lazy’
[13:18:59.057]   - Field: ‘state’
[13:18:59.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.057] - Launch lazy future ...
[13:18:59.057] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:59.058] Packages needed by future strategies (n = 0): <none>
[13:18:59.058] {
[13:18:59.058]     {
[13:18:59.058]         {
[13:18:59.058]             ...future.startTime <- base::Sys.time()
[13:18:59.058]             {
[13:18:59.058]                 {
[13:18:59.058]                   {
[13:18:59.058]                     {
[13:18:59.058]                       {
[13:18:59.058]                         base::local({
[13:18:59.058]                           has_future <- base::requireNamespace("future", 
[13:18:59.058]                             quietly = TRUE)
[13:18:59.058]                           if (has_future) {
[13:18:59.058]                             ns <- base::getNamespace("future")
[13:18:59.058]                             version <- ns[[".package"]][["version"]]
[13:18:59.058]                             if (is.null(version)) 
[13:18:59.058]                               version <- utils::packageVersion("future")
[13:18:59.058]                           }
[13:18:59.058]                           else {
[13:18:59.058]                             version <- NULL
[13:18:59.058]                           }
[13:18:59.058]                           if (!has_future || version < "1.8.0") {
[13:18:59.058]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.058]                               "", base::R.version$version.string), 
[13:18:59.058]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.058]                                 base::R.version$platform, 8 * 
[13:18:59.058]                                   base::.Machine$sizeof.pointer), 
[13:18:59.058]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.058]                                 "release", "version")], collapse = " "), 
[13:18:59.058]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.058]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.058]                               info)
[13:18:59.058]                             info <- base::paste(info, collapse = "; ")
[13:18:59.058]                             if (!has_future) {
[13:18:59.058]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.058]                                 info)
[13:18:59.058]                             }
[13:18:59.058]                             else {
[13:18:59.058]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.058]                                 info, version)
[13:18:59.058]                             }
[13:18:59.058]                             base::stop(msg)
[13:18:59.058]                           }
[13:18:59.058]                         })
[13:18:59.058]                       }
[13:18:59.058]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.058]                       base::options(mc.cores = 1L)
[13:18:59.058]                     }
[13:18:59.058]                     base::local({
[13:18:59.058]                       for (pkg in "future.apply") {
[13:18:59.058]                         base::loadNamespace(pkg)
[13:18:59.058]                         base::library(pkg, character.only = TRUE)
[13:18:59.058]                       }
[13:18:59.058]                     })
[13:18:59.058]                   }
[13:18:59.058]                   options(future.plan = NULL)
[13:18:59.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.058]                 }
[13:18:59.058]                 ...future.workdir <- getwd()
[13:18:59.058]             }
[13:18:59.058]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.058]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.058]         }
[13:18:59.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.058]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:59.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.058]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.058]             base::names(...future.oldOptions))
[13:18:59.058]     }
[13:18:59.058]     if (FALSE) {
[13:18:59.058]     }
[13:18:59.058]     else {
[13:18:59.058]         if (TRUE) {
[13:18:59.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.058]                 open = "w")
[13:18:59.058]         }
[13:18:59.058]         else {
[13:18:59.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.058]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.058]         }
[13:18:59.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.058]             base::sink(type = "output", split = FALSE)
[13:18:59.058]             base::close(...future.stdout)
[13:18:59.058]         }, add = TRUE)
[13:18:59.058]     }
[13:18:59.058]     ...future.frame <- base::sys.nframe()
[13:18:59.058]     ...future.conditions <- base::list()
[13:18:59.058]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.058]     if (FALSE) {
[13:18:59.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.058]     }
[13:18:59.058]     ...future.result <- base::tryCatch({
[13:18:59.058]         base::withCallingHandlers({
[13:18:59.058]             ...future.value <- base::withVisible(base::local({
[13:18:59.058]                 withCallingHandlers({
[13:18:59.058]                   {
[13:18:59.058]                     do.call(function(...) {
[13:18:59.058]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.058]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.058]                         ...future.globals.maxSize)) {
[13:18:59.058]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.058]                         on.exit(options(oopts), add = TRUE)
[13:18:59.058]                       }
[13:18:59.058]                       {
[13:18:59.058]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.058]                           FUN = function(jj) {
[13:18:59.058]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.058]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.058]                           })
[13:18:59.058]                       }
[13:18:59.058]                     }, args = future.call.arguments)
[13:18:59.058]                   }
[13:18:59.058]                 }, immediateCondition = function(cond) {
[13:18:59.058]                   save_rds <- function (object, pathname, ...) 
[13:18:59.058]                   {
[13:18:59.058]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.058]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.058]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.058]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.058]                         fi_tmp[["mtime"]])
[13:18:59.058]                     }
[13:18:59.058]                     tryCatch({
[13:18:59.058]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.058]                     }, error = function(ex) {
[13:18:59.058]                       msg <- conditionMessage(ex)
[13:18:59.058]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.058]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.058]                         fi_tmp[["mtime"]], msg)
[13:18:59.058]                       ex$message <- msg
[13:18:59.058]                       stop(ex)
[13:18:59.058]                     })
[13:18:59.058]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.058]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.058]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.058]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.058]                       fi <- file.info(pathname)
[13:18:59.058]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.058]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.058]                         fi[["size"]], fi[["mtime"]])
[13:18:59.058]                       stop(msg)
[13:18:59.058]                     }
[13:18:59.058]                     invisible(pathname)
[13:18:59.058]                   }
[13:18:59.058]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.058]                     rootPath = tempdir()) 
[13:18:59.058]                   {
[13:18:59.058]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.058]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.058]                       tmpdir = path, fileext = ".rds")
[13:18:59.058]                     save_rds(obj, file)
[13:18:59.058]                   }
[13:18:59.058]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.058]                   {
[13:18:59.058]                     inherits <- base::inherits
[13:18:59.058]                     invokeRestart <- base::invokeRestart
[13:18:59.058]                     is.null <- base::is.null
[13:18:59.058]                     muffled <- FALSE
[13:18:59.058]                     if (inherits(cond, "message")) {
[13:18:59.058]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.058]                       if (muffled) 
[13:18:59.058]                         invokeRestart("muffleMessage")
[13:18:59.058]                     }
[13:18:59.058]                     else if (inherits(cond, "warning")) {
[13:18:59.058]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.058]                       if (muffled) 
[13:18:59.058]                         invokeRestart("muffleWarning")
[13:18:59.058]                     }
[13:18:59.058]                     else if (inherits(cond, "condition")) {
[13:18:59.058]                       if (!is.null(pattern)) {
[13:18:59.058]                         computeRestarts <- base::computeRestarts
[13:18:59.058]                         grepl <- base::grepl
[13:18:59.058]                         restarts <- computeRestarts(cond)
[13:18:59.058]                         for (restart in restarts) {
[13:18:59.058]                           name <- restart$name
[13:18:59.058]                           if (is.null(name)) 
[13:18:59.058]                             next
[13:18:59.058]                           if (!grepl(pattern, name)) 
[13:18:59.058]                             next
[13:18:59.058]                           invokeRestart(restart)
[13:18:59.058]                           muffled <- TRUE
[13:18:59.058]                           break
[13:18:59.058]                         }
[13:18:59.058]                       }
[13:18:59.058]                     }
[13:18:59.058]                     invisible(muffled)
[13:18:59.058]                   }
[13:18:59.058]                   muffleCondition(cond)
[13:18:59.058]                 })
[13:18:59.058]             }))
[13:18:59.058]             future::FutureResult(value = ...future.value$value, 
[13:18:59.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.058]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.058]                     ...future.globalenv.names))
[13:18:59.058]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.058]         }, condition = base::local({
[13:18:59.058]             c <- base::c
[13:18:59.058]             inherits <- base::inherits
[13:18:59.058]             invokeRestart <- base::invokeRestart
[13:18:59.058]             length <- base::length
[13:18:59.058]             list <- base::list
[13:18:59.058]             seq.int <- base::seq.int
[13:18:59.058]             signalCondition <- base::signalCondition
[13:18:59.058]             sys.calls <- base::sys.calls
[13:18:59.058]             `[[` <- base::`[[`
[13:18:59.058]             `+` <- base::`+`
[13:18:59.058]             `<<-` <- base::`<<-`
[13:18:59.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.058]                   3L)]
[13:18:59.058]             }
[13:18:59.058]             function(cond) {
[13:18:59.058]                 is_error <- inherits(cond, "error")
[13:18:59.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.058]                   NULL)
[13:18:59.058]                 if (is_error) {
[13:18:59.058]                   sessionInformation <- function() {
[13:18:59.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.058]                       search = base::search(), system = base::Sys.info())
[13:18:59.058]                   }
[13:18:59.058]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.058]                     cond$call), session = sessionInformation(), 
[13:18:59.058]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.058]                   signalCondition(cond)
[13:18:59.058]                 }
[13:18:59.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.058]                 "immediateCondition"))) {
[13:18:59.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.058]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.058]                   if (TRUE && !signal) {
[13:18:59.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.058]                     {
[13:18:59.058]                       inherits <- base::inherits
[13:18:59.058]                       invokeRestart <- base::invokeRestart
[13:18:59.058]                       is.null <- base::is.null
[13:18:59.058]                       muffled <- FALSE
[13:18:59.058]                       if (inherits(cond, "message")) {
[13:18:59.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.058]                         if (muffled) 
[13:18:59.058]                           invokeRestart("muffleMessage")
[13:18:59.058]                       }
[13:18:59.058]                       else if (inherits(cond, "warning")) {
[13:18:59.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.058]                         if (muffled) 
[13:18:59.058]                           invokeRestart("muffleWarning")
[13:18:59.058]                       }
[13:18:59.058]                       else if (inherits(cond, "condition")) {
[13:18:59.058]                         if (!is.null(pattern)) {
[13:18:59.058]                           computeRestarts <- base::computeRestarts
[13:18:59.058]                           grepl <- base::grepl
[13:18:59.058]                           restarts <- computeRestarts(cond)
[13:18:59.058]                           for (restart in restarts) {
[13:18:59.058]                             name <- restart$name
[13:18:59.058]                             if (is.null(name)) 
[13:18:59.058]                               next
[13:18:59.058]                             if (!grepl(pattern, name)) 
[13:18:59.058]                               next
[13:18:59.058]                             invokeRestart(restart)
[13:18:59.058]                             muffled <- TRUE
[13:18:59.058]                             break
[13:18:59.058]                           }
[13:18:59.058]                         }
[13:18:59.058]                       }
[13:18:59.058]                       invisible(muffled)
[13:18:59.058]                     }
[13:18:59.058]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.058]                   }
[13:18:59.058]                 }
[13:18:59.058]                 else {
[13:18:59.058]                   if (TRUE) {
[13:18:59.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.058]                     {
[13:18:59.058]                       inherits <- base::inherits
[13:18:59.058]                       invokeRestart <- base::invokeRestart
[13:18:59.058]                       is.null <- base::is.null
[13:18:59.058]                       muffled <- FALSE
[13:18:59.058]                       if (inherits(cond, "message")) {
[13:18:59.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.058]                         if (muffled) 
[13:18:59.058]                           invokeRestart("muffleMessage")
[13:18:59.058]                       }
[13:18:59.058]                       else if (inherits(cond, "warning")) {
[13:18:59.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.058]                         if (muffled) 
[13:18:59.058]                           invokeRestart("muffleWarning")
[13:18:59.058]                       }
[13:18:59.058]                       else if (inherits(cond, "condition")) {
[13:18:59.058]                         if (!is.null(pattern)) {
[13:18:59.058]                           computeRestarts <- base::computeRestarts
[13:18:59.058]                           grepl <- base::grepl
[13:18:59.058]                           restarts <- computeRestarts(cond)
[13:18:59.058]                           for (restart in restarts) {
[13:18:59.058]                             name <- restart$name
[13:18:59.058]                             if (is.null(name)) 
[13:18:59.058]                               next
[13:18:59.058]                             if (!grepl(pattern, name)) 
[13:18:59.058]                               next
[13:18:59.058]                             invokeRestart(restart)
[13:18:59.058]                             muffled <- TRUE
[13:18:59.058]                             break
[13:18:59.058]                           }
[13:18:59.058]                         }
[13:18:59.058]                       }
[13:18:59.058]                       invisible(muffled)
[13:18:59.058]                     }
[13:18:59.058]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.058]                   }
[13:18:59.058]                 }
[13:18:59.058]             }
[13:18:59.058]         }))
[13:18:59.058]     }, error = function(ex) {
[13:18:59.058]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.058]                 ...future.rng), started = ...future.startTime, 
[13:18:59.058]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.058]             version = "1.8"), class = "FutureResult")
[13:18:59.058]     }, finally = {
[13:18:59.058]         if (!identical(...future.workdir, getwd())) 
[13:18:59.058]             setwd(...future.workdir)
[13:18:59.058]         {
[13:18:59.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.058]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.058]             }
[13:18:59.058]             base::options(...future.oldOptions)
[13:18:59.058]             if (.Platform$OS.type == "windows") {
[13:18:59.058]                 old_names <- names(...future.oldEnvVars)
[13:18:59.058]                 envs <- base::Sys.getenv()
[13:18:59.058]                 names <- names(envs)
[13:18:59.058]                 common <- intersect(names, old_names)
[13:18:59.058]                 added <- setdiff(names, old_names)
[13:18:59.058]                 removed <- setdiff(old_names, names)
[13:18:59.058]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.058]                   envs[common]]
[13:18:59.058]                 NAMES <- toupper(changed)
[13:18:59.058]                 args <- list()
[13:18:59.058]                 for (kk in seq_along(NAMES)) {
[13:18:59.058]                   name <- changed[[kk]]
[13:18:59.058]                   NAME <- NAMES[[kk]]
[13:18:59.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.058]                     next
[13:18:59.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.058]                 }
[13:18:59.058]                 NAMES <- toupper(added)
[13:18:59.058]                 for (kk in seq_along(NAMES)) {
[13:18:59.058]                   name <- added[[kk]]
[13:18:59.058]                   NAME <- NAMES[[kk]]
[13:18:59.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.058]                     next
[13:18:59.058]                   args[[name]] <- ""
[13:18:59.058]                 }
[13:18:59.058]                 NAMES <- toupper(removed)
[13:18:59.058]                 for (kk in seq_along(NAMES)) {
[13:18:59.058]                   name <- removed[[kk]]
[13:18:59.058]                   NAME <- NAMES[[kk]]
[13:18:59.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.058]                     next
[13:18:59.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.058]                 }
[13:18:59.058]                 if (length(args) > 0) 
[13:18:59.058]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.058]             }
[13:18:59.058]             else {
[13:18:59.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.058]             }
[13:18:59.058]             {
[13:18:59.058]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.058]                   0L) {
[13:18:59.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.058]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.058]                   base::options(opts)
[13:18:59.058]                 }
[13:18:59.058]                 {
[13:18:59.058]                   {
[13:18:59.058]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.058]                     NULL
[13:18:59.058]                   }
[13:18:59.058]                   options(future.plan = NULL)
[13:18:59.058]                   if (is.na(NA_character_)) 
[13:18:59.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.058]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.058]                     envir = parent.frame()) 
[13:18:59.058]                   {
[13:18:59.058]                     default_workers <- missing(workers)
[13:18:59.058]                     if (is.function(workers)) 
[13:18:59.058]                       workers <- workers()
[13:18:59.058]                     workers <- structure(as.integer(workers), 
[13:18:59.058]                       class = class(workers))
[13:18:59.058]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.058]                       1L)
[13:18:59.058]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.058]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.058]                       if (default_workers) 
[13:18:59.058]                         supportsMulticore(warn = TRUE)
[13:18:59.058]                       return(sequential(..., envir = envir))
[13:18:59.058]                     }
[13:18:59.058]                     oopts <- options(mc.cores = workers)
[13:18:59.058]                     on.exit(options(oopts))
[13:18:59.058]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.058]                       envir = envir)
[13:18:59.058]                     if (!future$lazy) 
[13:18:59.058]                       future <- run(future)
[13:18:59.058]                     invisible(future)
[13:18:59.058]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.058]                 }
[13:18:59.058]             }
[13:18:59.058]         }
[13:18:59.058]     })
[13:18:59.058]     if (TRUE) {
[13:18:59.058]         base::sink(type = "output", split = FALSE)
[13:18:59.058]         if (TRUE) {
[13:18:59.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.058]         }
[13:18:59.058]         else {
[13:18:59.058]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.058]         }
[13:18:59.058]         base::close(...future.stdout)
[13:18:59.058]         ...future.stdout <- NULL
[13:18:59.058]     }
[13:18:59.058]     ...future.result$conditions <- ...future.conditions
[13:18:59.058]     ...future.result$finished <- base::Sys.time()
[13:18:59.058]     ...future.result
[13:18:59.058] }
[13:18:59.061] assign_globals() ...
[13:18:59.061] List of 11
[13:18:59.061]  $ ...future.FUN            :function (x, ...)  
[13:18:59.061]  $ x_FUN                    :function (x)  
[13:18:59.061]  $ times                    : int 4
[13:18:59.061]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.061]  $ stop_if_not              :function (...)  
[13:18:59.061]  $ dim                      : int [1:2] 2 2
[13:18:59.061]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.061]  $ future.call.arguments    : list()
[13:18:59.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.061]  $ ...future.elements_ii    :List of 5
[13:18:59.061]   ..$ : int 1
[13:18:59.061]   ..$ : int 2
[13:18:59.061]   ..$ : int 3
[13:18:59.061]   ..$ : int 4
[13:18:59.061]   ..$ : int 5
[13:18:59.061]  $ ...future.seeds_ii       : NULL
[13:18:59.061]  $ ...future.globals.maxSize: NULL
[13:18:59.061]  - attr(*, "resolved")= logi FALSE
[13:18:59.061]  - attr(*, "total_size")= num 97304
[13:18:59.061]  - attr(*, "where")=List of 11
[13:18:59.061]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.061]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.061]  - attr(*, "already-done")= logi TRUE
[13:18:59.070] - copied ‘...future.FUN’ to environment
[13:18:59.070] - reassign environment for ‘x_FUN’
[13:18:59.070] - copied ‘x_FUN’ to environment
[13:18:59.070] - copied ‘times’ to environment
[13:18:59.070] - copied ‘stopf’ to environment
[13:18:59.070] - copied ‘stop_if_not’ to environment
[13:18:59.070] - copied ‘dim’ to environment
[13:18:59.071] - copied ‘valid_types’ to environment
[13:18:59.071] - copied ‘future.call.arguments’ to environment
[13:18:59.071] - copied ‘...future.elements_ii’ to environment
[13:18:59.071] - copied ‘...future.seeds_ii’ to environment
[13:18:59.071] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.071] assign_globals() ... done
[13:18:59.071] requestCore(): workers = 2
[13:18:59.073] MulticoreFuture started
[13:18:59.074] - Launch lazy future ... done
[13:18:59.074] run() for ‘MulticoreFuture’ ... done
[13:18:59.074] Created future:
[13:18:59.075] plan(): Setting new future strategy stack:
[13:18:59.075] List of future strategies:
[13:18:59.075] 1. sequential:
[13:18:59.075]    - args: function (..., envir = parent.frame())
[13:18:59.075]    - tweaked: FALSE
[13:18:59.075]    - call: NULL
[13:18:59.076] plan(): nbrOfWorkers() = 1
[13:18:59.078] plan(): Setting new future strategy stack:
[13:18:59.078] List of future strategies:
[13:18:59.078] 1. multicore:
[13:18:59.078]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.078]    - tweaked: FALSE
[13:18:59.078]    - call: plan(strategy)
[13:18:59.075] MulticoreFuture:
[13:18:59.075] Label: ‘future_vapply-1’
[13:18:59.075] Expression:
[13:18:59.075] {
[13:18:59.075]     do.call(function(...) {
[13:18:59.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.075]             on.exit(options(oopts), add = TRUE)
[13:18:59.075]         }
[13:18:59.075]         {
[13:18:59.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.075]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.075]             })
[13:18:59.075]         }
[13:18:59.075]     }, args = future.call.arguments)
[13:18:59.075] }
[13:18:59.075] Lazy evaluation: FALSE
[13:18:59.075] Asynchronous evaluation: TRUE
[13:18:59.075] Local evaluation: TRUE
[13:18:59.075] Environment: R_GlobalEnv
[13:18:59.075] Capture standard output: TRUE
[13:18:59.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.075] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.075] Packages: 1 packages (‘future.apply’)
[13:18:59.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.075] Resolved: FALSE
[13:18:59.075] Value: <not collected>
[13:18:59.075] Conditions captured: <none>
[13:18:59.075] Early signaling: FALSE
[13:18:59.075] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.075] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.088] Chunk #1 of 2 ... DONE
[13:18:59.088] Chunk #2 of 2 ...
[13:18:59.088]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.088] getGlobalsAndPackages() ...
[13:18:59.090] plan(): nbrOfWorkers() = 2
[13:18:59.088] Searching for globals...
[13:18:59.092] 
[13:18:59.092] Searching for globals ... DONE
[13:18:59.092] - globals: [0] <none>
[13:18:59.093] getGlobalsAndPackages() ... DONE
[13:18:59.093]    + additional globals found: [n=0] 
[13:18:59.093]    + additional namespaces needed: [n=0] 
[13:18:59.093]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.094]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:59.094]  - seeds: <none>
[13:18:59.094] getGlobalsAndPackages() ...
[13:18:59.094] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.095] Resolving globals: FALSE
[13:18:59.095] Tweak future expression to call with '...' arguments ...
[13:18:59.095] {
[13:18:59.095]     do.call(function(...) {
[13:18:59.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.095]             on.exit(options(oopts), add = TRUE)
[13:18:59.095]         }
[13:18:59.095]         {
[13:18:59.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.095]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.095]             })
[13:18:59.095]         }
[13:18:59.095]     }, args = future.call.arguments)
[13:18:59.095] }
[13:18:59.096] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.097] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.098] - packages: [1] ‘future.apply’
[13:18:59.098] getGlobalsAndPackages() ... DONE
[13:18:59.099] run() for ‘Future’ ...
[13:18:59.099] - state: ‘created’
[13:18:59.099] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.105] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.105] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.105]   - Field: ‘label’
[13:18:59.105]   - Field: ‘local’
[13:18:59.106]   - Field: ‘owner’
[13:18:59.106]   - Field: ‘envir’
[13:18:59.106]   - Field: ‘workers’
[13:18:59.106]   - Field: ‘packages’
[13:18:59.106]   - Field: ‘gc’
[13:18:59.107]   - Field: ‘job’
[13:18:59.107]   - Field: ‘conditions’
[13:18:59.107]   - Field: ‘expr’
[13:18:59.107]   - Field: ‘uuid’
[13:18:59.107]   - Field: ‘seed’
[13:18:59.107]   - Field: ‘version’
[13:18:59.107]   - Field: ‘result’
[13:18:59.108]   - Field: ‘asynchronous’
[13:18:59.108]   - Field: ‘calls’
[13:18:59.108]   - Field: ‘globals’
[13:18:59.108]   - Field: ‘stdout’
[13:18:59.108]   - Field: ‘earlySignal’
[13:18:59.109]   - Field: ‘lazy’
[13:18:59.109]   - Field: ‘state’
[13:18:59.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.109] - Launch lazy future ...
[13:18:59.109] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:59.110] Packages needed by future strategies (n = 0): <none>
[13:18:59.111] {
[13:18:59.111]     {
[13:18:59.111]         {
[13:18:59.111]             ...future.startTime <- base::Sys.time()
[13:18:59.111]             {
[13:18:59.111]                 {
[13:18:59.111]                   {
[13:18:59.111]                     {
[13:18:59.111]                       {
[13:18:59.111]                         base::local({
[13:18:59.111]                           has_future <- base::requireNamespace("future", 
[13:18:59.111]                             quietly = TRUE)
[13:18:59.111]                           if (has_future) {
[13:18:59.111]                             ns <- base::getNamespace("future")
[13:18:59.111]                             version <- ns[[".package"]][["version"]]
[13:18:59.111]                             if (is.null(version)) 
[13:18:59.111]                               version <- utils::packageVersion("future")
[13:18:59.111]                           }
[13:18:59.111]                           else {
[13:18:59.111]                             version <- NULL
[13:18:59.111]                           }
[13:18:59.111]                           if (!has_future || version < "1.8.0") {
[13:18:59.111]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.111]                               "", base::R.version$version.string), 
[13:18:59.111]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.111]                                 base::R.version$platform, 8 * 
[13:18:59.111]                                   base::.Machine$sizeof.pointer), 
[13:18:59.111]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.111]                                 "release", "version")], collapse = " "), 
[13:18:59.111]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.111]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.111]                               info)
[13:18:59.111]                             info <- base::paste(info, collapse = "; ")
[13:18:59.111]                             if (!has_future) {
[13:18:59.111]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.111]                                 info)
[13:18:59.111]                             }
[13:18:59.111]                             else {
[13:18:59.111]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.111]                                 info, version)
[13:18:59.111]                             }
[13:18:59.111]                             base::stop(msg)
[13:18:59.111]                           }
[13:18:59.111]                         })
[13:18:59.111]                       }
[13:18:59.111]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.111]                       base::options(mc.cores = 1L)
[13:18:59.111]                     }
[13:18:59.111]                     base::local({
[13:18:59.111]                       for (pkg in "future.apply") {
[13:18:59.111]                         base::loadNamespace(pkg)
[13:18:59.111]                         base::library(pkg, character.only = TRUE)
[13:18:59.111]                       }
[13:18:59.111]                     })
[13:18:59.111]                   }
[13:18:59.111]                   options(future.plan = NULL)
[13:18:59.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.111]                 }
[13:18:59.111]                 ...future.workdir <- getwd()
[13:18:59.111]             }
[13:18:59.111]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.111]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.111]         }
[13:18:59.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.111]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:59.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.111]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.111]             base::names(...future.oldOptions))
[13:18:59.111]     }
[13:18:59.111]     if (FALSE) {
[13:18:59.111]     }
[13:18:59.111]     else {
[13:18:59.111]         if (TRUE) {
[13:18:59.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.111]                 open = "w")
[13:18:59.111]         }
[13:18:59.111]         else {
[13:18:59.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.111]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.111]         }
[13:18:59.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.111]             base::sink(type = "output", split = FALSE)
[13:18:59.111]             base::close(...future.stdout)
[13:18:59.111]         }, add = TRUE)
[13:18:59.111]     }
[13:18:59.111]     ...future.frame <- base::sys.nframe()
[13:18:59.111]     ...future.conditions <- base::list()
[13:18:59.111]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.111]     if (FALSE) {
[13:18:59.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.111]     }
[13:18:59.111]     ...future.result <- base::tryCatch({
[13:18:59.111]         base::withCallingHandlers({
[13:18:59.111]             ...future.value <- base::withVisible(base::local({
[13:18:59.111]                 withCallingHandlers({
[13:18:59.111]                   {
[13:18:59.111]                     do.call(function(...) {
[13:18:59.111]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.111]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.111]                         ...future.globals.maxSize)) {
[13:18:59.111]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.111]                         on.exit(options(oopts), add = TRUE)
[13:18:59.111]                       }
[13:18:59.111]                       {
[13:18:59.111]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.111]                           FUN = function(jj) {
[13:18:59.111]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.111]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.111]                           })
[13:18:59.111]                       }
[13:18:59.111]                     }, args = future.call.arguments)
[13:18:59.111]                   }
[13:18:59.111]                 }, immediateCondition = function(cond) {
[13:18:59.111]                   save_rds <- function (object, pathname, ...) 
[13:18:59.111]                   {
[13:18:59.111]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.111]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.111]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.111]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.111]                         fi_tmp[["mtime"]])
[13:18:59.111]                     }
[13:18:59.111]                     tryCatch({
[13:18:59.111]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.111]                     }, error = function(ex) {
[13:18:59.111]                       msg <- conditionMessage(ex)
[13:18:59.111]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.111]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.111]                         fi_tmp[["mtime"]], msg)
[13:18:59.111]                       ex$message <- msg
[13:18:59.111]                       stop(ex)
[13:18:59.111]                     })
[13:18:59.111]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.111]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.111]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.111]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.111]                       fi <- file.info(pathname)
[13:18:59.111]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.111]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.111]                         fi[["size"]], fi[["mtime"]])
[13:18:59.111]                       stop(msg)
[13:18:59.111]                     }
[13:18:59.111]                     invisible(pathname)
[13:18:59.111]                   }
[13:18:59.111]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.111]                     rootPath = tempdir()) 
[13:18:59.111]                   {
[13:18:59.111]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.111]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.111]                       tmpdir = path, fileext = ".rds")
[13:18:59.111]                     save_rds(obj, file)
[13:18:59.111]                   }
[13:18:59.111]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.111]                   {
[13:18:59.111]                     inherits <- base::inherits
[13:18:59.111]                     invokeRestart <- base::invokeRestart
[13:18:59.111]                     is.null <- base::is.null
[13:18:59.111]                     muffled <- FALSE
[13:18:59.111]                     if (inherits(cond, "message")) {
[13:18:59.111]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.111]                       if (muffled) 
[13:18:59.111]                         invokeRestart("muffleMessage")
[13:18:59.111]                     }
[13:18:59.111]                     else if (inherits(cond, "warning")) {
[13:18:59.111]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.111]                       if (muffled) 
[13:18:59.111]                         invokeRestart("muffleWarning")
[13:18:59.111]                     }
[13:18:59.111]                     else if (inherits(cond, "condition")) {
[13:18:59.111]                       if (!is.null(pattern)) {
[13:18:59.111]                         computeRestarts <- base::computeRestarts
[13:18:59.111]                         grepl <- base::grepl
[13:18:59.111]                         restarts <- computeRestarts(cond)
[13:18:59.111]                         for (restart in restarts) {
[13:18:59.111]                           name <- restart$name
[13:18:59.111]                           if (is.null(name)) 
[13:18:59.111]                             next
[13:18:59.111]                           if (!grepl(pattern, name)) 
[13:18:59.111]                             next
[13:18:59.111]                           invokeRestart(restart)
[13:18:59.111]                           muffled <- TRUE
[13:18:59.111]                           break
[13:18:59.111]                         }
[13:18:59.111]                       }
[13:18:59.111]                     }
[13:18:59.111]                     invisible(muffled)
[13:18:59.111]                   }
[13:18:59.111]                   muffleCondition(cond)
[13:18:59.111]                 })
[13:18:59.111]             }))
[13:18:59.111]             future::FutureResult(value = ...future.value$value, 
[13:18:59.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.111]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.111]                     ...future.globalenv.names))
[13:18:59.111]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.111]         }, condition = base::local({
[13:18:59.111]             c <- base::c
[13:18:59.111]             inherits <- base::inherits
[13:18:59.111]             invokeRestart <- base::invokeRestart
[13:18:59.111]             length <- base::length
[13:18:59.111]             list <- base::list
[13:18:59.111]             seq.int <- base::seq.int
[13:18:59.111]             signalCondition <- base::signalCondition
[13:18:59.111]             sys.calls <- base::sys.calls
[13:18:59.111]             `[[` <- base::`[[`
[13:18:59.111]             `+` <- base::`+`
[13:18:59.111]             `<<-` <- base::`<<-`
[13:18:59.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.111]                   3L)]
[13:18:59.111]             }
[13:18:59.111]             function(cond) {
[13:18:59.111]                 is_error <- inherits(cond, "error")
[13:18:59.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.111]                   NULL)
[13:18:59.111]                 if (is_error) {
[13:18:59.111]                   sessionInformation <- function() {
[13:18:59.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.111]                       search = base::search(), system = base::Sys.info())
[13:18:59.111]                   }
[13:18:59.111]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.111]                     cond$call), session = sessionInformation(), 
[13:18:59.111]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.111]                   signalCondition(cond)
[13:18:59.111]                 }
[13:18:59.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.111]                 "immediateCondition"))) {
[13:18:59.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.111]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.111]                   if (TRUE && !signal) {
[13:18:59.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.111]                     {
[13:18:59.111]                       inherits <- base::inherits
[13:18:59.111]                       invokeRestart <- base::invokeRestart
[13:18:59.111]                       is.null <- base::is.null
[13:18:59.111]                       muffled <- FALSE
[13:18:59.111]                       if (inherits(cond, "message")) {
[13:18:59.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.111]                         if (muffled) 
[13:18:59.111]                           invokeRestart("muffleMessage")
[13:18:59.111]                       }
[13:18:59.111]                       else if (inherits(cond, "warning")) {
[13:18:59.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.111]                         if (muffled) 
[13:18:59.111]                           invokeRestart("muffleWarning")
[13:18:59.111]                       }
[13:18:59.111]                       else if (inherits(cond, "condition")) {
[13:18:59.111]                         if (!is.null(pattern)) {
[13:18:59.111]                           computeRestarts <- base::computeRestarts
[13:18:59.111]                           grepl <- base::grepl
[13:18:59.111]                           restarts <- computeRestarts(cond)
[13:18:59.111]                           for (restart in restarts) {
[13:18:59.111]                             name <- restart$name
[13:18:59.111]                             if (is.null(name)) 
[13:18:59.111]                               next
[13:18:59.111]                             if (!grepl(pattern, name)) 
[13:18:59.111]                               next
[13:18:59.111]                             invokeRestart(restart)
[13:18:59.111]                             muffled <- TRUE
[13:18:59.111]                             break
[13:18:59.111]                           }
[13:18:59.111]                         }
[13:18:59.111]                       }
[13:18:59.111]                       invisible(muffled)
[13:18:59.111]                     }
[13:18:59.111]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.111]                   }
[13:18:59.111]                 }
[13:18:59.111]                 else {
[13:18:59.111]                   if (TRUE) {
[13:18:59.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.111]                     {
[13:18:59.111]                       inherits <- base::inherits
[13:18:59.111]                       invokeRestart <- base::invokeRestart
[13:18:59.111]                       is.null <- base::is.null
[13:18:59.111]                       muffled <- FALSE
[13:18:59.111]                       if (inherits(cond, "message")) {
[13:18:59.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.111]                         if (muffled) 
[13:18:59.111]                           invokeRestart("muffleMessage")
[13:18:59.111]                       }
[13:18:59.111]                       else if (inherits(cond, "warning")) {
[13:18:59.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.111]                         if (muffled) 
[13:18:59.111]                           invokeRestart("muffleWarning")
[13:18:59.111]                       }
[13:18:59.111]                       else if (inherits(cond, "condition")) {
[13:18:59.111]                         if (!is.null(pattern)) {
[13:18:59.111]                           computeRestarts <- base::computeRestarts
[13:18:59.111]                           grepl <- base::grepl
[13:18:59.111]                           restarts <- computeRestarts(cond)
[13:18:59.111]                           for (restart in restarts) {
[13:18:59.111]                             name <- restart$name
[13:18:59.111]                             if (is.null(name)) 
[13:18:59.111]                               next
[13:18:59.111]                             if (!grepl(pattern, name)) 
[13:18:59.111]                               next
[13:18:59.111]                             invokeRestart(restart)
[13:18:59.111]                             muffled <- TRUE
[13:18:59.111]                             break
[13:18:59.111]                           }
[13:18:59.111]                         }
[13:18:59.111]                       }
[13:18:59.111]                       invisible(muffled)
[13:18:59.111]                     }
[13:18:59.111]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.111]                   }
[13:18:59.111]                 }
[13:18:59.111]             }
[13:18:59.111]         }))
[13:18:59.111]     }, error = function(ex) {
[13:18:59.111]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.111]                 ...future.rng), started = ...future.startTime, 
[13:18:59.111]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.111]             version = "1.8"), class = "FutureResult")
[13:18:59.111]     }, finally = {
[13:18:59.111]         if (!identical(...future.workdir, getwd())) 
[13:18:59.111]             setwd(...future.workdir)
[13:18:59.111]         {
[13:18:59.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.111]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.111]             }
[13:18:59.111]             base::options(...future.oldOptions)
[13:18:59.111]             if (.Platform$OS.type == "windows") {
[13:18:59.111]                 old_names <- names(...future.oldEnvVars)
[13:18:59.111]                 envs <- base::Sys.getenv()
[13:18:59.111]                 names <- names(envs)
[13:18:59.111]                 common <- intersect(names, old_names)
[13:18:59.111]                 added <- setdiff(names, old_names)
[13:18:59.111]                 removed <- setdiff(old_names, names)
[13:18:59.111]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.111]                   envs[common]]
[13:18:59.111]                 NAMES <- toupper(changed)
[13:18:59.111]                 args <- list()
[13:18:59.111]                 for (kk in seq_along(NAMES)) {
[13:18:59.111]                   name <- changed[[kk]]
[13:18:59.111]                   NAME <- NAMES[[kk]]
[13:18:59.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.111]                     next
[13:18:59.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.111]                 }
[13:18:59.111]                 NAMES <- toupper(added)
[13:18:59.111]                 for (kk in seq_along(NAMES)) {
[13:18:59.111]                   name <- added[[kk]]
[13:18:59.111]                   NAME <- NAMES[[kk]]
[13:18:59.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.111]                     next
[13:18:59.111]                   args[[name]] <- ""
[13:18:59.111]                 }
[13:18:59.111]                 NAMES <- toupper(removed)
[13:18:59.111]                 for (kk in seq_along(NAMES)) {
[13:18:59.111]                   name <- removed[[kk]]
[13:18:59.111]                   NAME <- NAMES[[kk]]
[13:18:59.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.111]                     next
[13:18:59.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.111]                 }
[13:18:59.111]                 if (length(args) > 0) 
[13:18:59.111]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.111]             }
[13:18:59.111]             else {
[13:18:59.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.111]             }
[13:18:59.111]             {
[13:18:59.111]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.111]                   0L) {
[13:18:59.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.111]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.111]                   base::options(opts)
[13:18:59.111]                 }
[13:18:59.111]                 {
[13:18:59.111]                   {
[13:18:59.111]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.111]                     NULL
[13:18:59.111]                   }
[13:18:59.111]                   options(future.plan = NULL)
[13:18:59.111]                   if (is.na(NA_character_)) 
[13:18:59.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.111]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.111]                     envir = parent.frame()) 
[13:18:59.111]                   {
[13:18:59.111]                     default_workers <- missing(workers)
[13:18:59.111]                     if (is.function(workers)) 
[13:18:59.111]                       workers <- workers()
[13:18:59.111]                     workers <- structure(as.integer(workers), 
[13:18:59.111]                       class = class(workers))
[13:18:59.111]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.111]                       1L)
[13:18:59.111]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.111]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.111]                       if (default_workers) 
[13:18:59.111]                         supportsMulticore(warn = TRUE)
[13:18:59.111]                       return(sequential(..., envir = envir))
[13:18:59.111]                     }
[13:18:59.111]                     oopts <- options(mc.cores = workers)
[13:18:59.111]                     on.exit(options(oopts))
[13:18:59.111]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.111]                       envir = envir)
[13:18:59.111]                     if (!future$lazy) 
[13:18:59.111]                       future <- run(future)
[13:18:59.111]                     invisible(future)
[13:18:59.111]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.111]                 }
[13:18:59.111]             }
[13:18:59.111]         }
[13:18:59.111]     })
[13:18:59.111]     if (TRUE) {
[13:18:59.111]         base::sink(type = "output", split = FALSE)
[13:18:59.111]         if (TRUE) {
[13:18:59.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.111]         }
[13:18:59.111]         else {
[13:18:59.111]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.111]         }
[13:18:59.111]         base::close(...future.stdout)
[13:18:59.111]         ...future.stdout <- NULL
[13:18:59.111]     }
[13:18:59.111]     ...future.result$conditions <- ...future.conditions
[13:18:59.111]     ...future.result$finished <- base::Sys.time()
[13:18:59.111]     ...future.result
[13:18:59.111] }
[13:18:59.113] assign_globals() ...
[13:18:59.114] List of 11
[13:18:59.114]  $ ...future.FUN            :function (x, ...)  
[13:18:59.114]  $ x_FUN                    :function (x)  
[13:18:59.114]  $ times                    : int 4
[13:18:59.114]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.114]  $ stop_if_not              :function (...)  
[13:18:59.114]  $ dim                      : int [1:2] 2 2
[13:18:59.114]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.114]  $ future.call.arguments    : list()
[13:18:59.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.114]  $ ...future.elements_ii    :List of 5
[13:18:59.114]   ..$ : int 6
[13:18:59.114]   ..$ : int 7
[13:18:59.114]   ..$ : int 8
[13:18:59.114]   ..$ : int 9
[13:18:59.114]   ..$ : int 10
[13:18:59.114]  $ ...future.seeds_ii       : NULL
[13:18:59.114]  $ ...future.globals.maxSize: NULL
[13:18:59.114]  - attr(*, "resolved")= logi FALSE
[13:18:59.114]  - attr(*, "total_size")= num 97304
[13:18:59.114]  - attr(*, "where")=List of 11
[13:18:59.114]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.114]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.114]  - attr(*, "already-done")= logi TRUE
[13:18:59.124] - copied ‘...future.FUN’ to environment
[13:18:59.125] - reassign environment for ‘x_FUN’
[13:18:59.125] - copied ‘x_FUN’ to environment
[13:18:59.125] - copied ‘times’ to environment
[13:18:59.125] - copied ‘stopf’ to environment
[13:18:59.125] - copied ‘stop_if_not’ to environment
[13:18:59.125] - copied ‘dim’ to environment
[13:18:59.125] - copied ‘valid_types’ to environment
[13:18:59.125] - copied ‘future.call.arguments’ to environment
[13:18:59.125] - copied ‘...future.elements_ii’ to environment
[13:18:59.125] - copied ‘...future.seeds_ii’ to environment
[13:18:59.126] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.126] assign_globals() ... done
[13:18:59.128] requestCore(): workers = 2
[13:18:59.130] MulticoreFuture started
[13:18:59.131] - Launch lazy future ... done
[13:18:59.132] run() for ‘MulticoreFuture’ ... done
[13:18:59.132] Created future:
[13:18:59.132] plan(): Setting new future strategy stack:
[13:18:59.133] List of future strategies:
[13:18:59.133] 1. sequential:
[13:18:59.133]    - args: function (..., envir = parent.frame())
[13:18:59.133]    - tweaked: FALSE
[13:18:59.133]    - call: NULL
[13:18:59.134] plan(): nbrOfWorkers() = 1
[13:18:59.137] plan(): Setting new future strategy stack:
[13:18:59.137] List of future strategies:
[13:18:59.137] 1. multicore:
[13:18:59.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.137]    - tweaked: FALSE
[13:18:59.137]    - call: plan(strategy)
[13:18:59.144] plan(): nbrOfWorkers() = 2
[13:18:59.132] MulticoreFuture:
[13:18:59.132] Label: ‘future_vapply-2’
[13:18:59.132] Expression:
[13:18:59.132] {
[13:18:59.132]     do.call(function(...) {
[13:18:59.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.132]             on.exit(options(oopts), add = TRUE)
[13:18:59.132]         }
[13:18:59.132]         {
[13:18:59.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.132]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.132]             })
[13:18:59.132]         }
[13:18:59.132]     }, args = future.call.arguments)
[13:18:59.132] }
[13:18:59.132] Lazy evaluation: FALSE
[13:18:59.132] Asynchronous evaluation: TRUE
[13:18:59.132] Local evaluation: TRUE
[13:18:59.132] Environment: R_GlobalEnv
[13:18:59.132] Capture standard output: TRUE
[13:18:59.132] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.132] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.132] Packages: 1 packages (‘future.apply’)
[13:18:59.132] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.132] Resolved: TRUE
[13:18:59.132] Value: <not collected>
[13:18:59.132] Conditions captured: <none>
[13:18:59.132] Early signaling: FALSE
[13:18:59.132] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.132] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.145] Chunk #2 of 2 ... DONE
[13:18:59.145] Launching 2 futures (chunks) ... DONE
[13:18:59.145] Resolving 2 futures (chunks) ...
[13:18:59.146] resolve() on list ...
[13:18:59.146]  recursive: 0
[13:18:59.146]  length: 2
[13:18:59.146] 
[13:18:59.147] Future #1
[13:18:59.148] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.148] - nx: 2
[13:18:59.148] - relay: TRUE
[13:18:59.148] - stdout: TRUE
[13:18:59.149] - signal: TRUE
[13:18:59.149] - resignal: FALSE
[13:18:59.149] - force: TRUE
[13:18:59.149] - relayed: [n=2] FALSE, FALSE
[13:18:59.150] - queued futures: [n=2] FALSE, FALSE
[13:18:59.150]  - until=1
[13:18:59.150]  - relaying element #1
[13:18:59.151] - relayed: [n=2] TRUE, FALSE
[13:18:59.151] - queued futures: [n=2] TRUE, FALSE
[13:18:59.151] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.151]  length: 1 (resolved future 1)
[13:18:59.152] Future #2
[13:18:59.153] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.153] - nx: 2
[13:18:59.153] - relay: TRUE
[13:18:59.153] - stdout: TRUE
[13:18:59.154] - signal: TRUE
[13:18:59.154] - resignal: FALSE
[13:18:59.154] - force: TRUE
[13:18:59.154] - relayed: [n=2] TRUE, FALSE
[13:18:59.154] - queued futures: [n=2] TRUE, FALSE
[13:18:59.154]  - until=2
[13:18:59.155]  - relaying element #2
[13:18:59.155] - relayed: [n=2] TRUE, TRUE
[13:18:59.155] - queued futures: [n=2] TRUE, TRUE
[13:18:59.156] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.156]  length: 0 (resolved future 2)
[13:18:59.156] Relaying remaining futures
[13:18:59.156] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.156] - nx: 2
[13:18:59.156] - relay: TRUE
[13:18:59.156] - stdout: TRUE
[13:18:59.156] - signal: TRUE
[13:18:59.157] - resignal: FALSE
[13:18:59.157] - force: TRUE
[13:18:59.157] - relayed: [n=2] TRUE, TRUE
[13:18:59.157] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.157] - relayed: [n=2] TRUE, TRUE
[13:18:59.157] - queued futures: [n=2] TRUE, TRUE
[13:18:59.157] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.157] resolve() on list ... DONE
[13:18:59.158]  - Number of value chunks collected: 2
[13:18:59.158] Resolving 2 futures (chunks) ... DONE
[13:18:59.158] Reducing values from 2 chunks ...
[13:18:59.158]  - Number of values collected after concatenation: 10
[13:18:59.158]  - Number of values expected: 10
[13:18:59.158] Reducing values from 2 chunks ... DONE
[13:18:59.159] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:18:59.161] future_lapply() ...
[13:18:59.167] Number of chunks: 2
[13:18:59.168] getGlobalsAndPackagesXApply() ...
[13:18:59.168]  - future.globals: TRUE
[13:18:59.168] getGlobalsAndPackages() ...
[13:18:59.168] Searching for globals...
[13:18:59.172] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:18:59.173] Searching for globals ... DONE
[13:18:59.173] Resolving globals: FALSE
[13:18:59.176] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:18:59.176] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:59.177] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.177] - packages: [1] ‘future.apply’
[13:18:59.177] getGlobalsAndPackages() ... DONE
[13:18:59.177]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.177]  - needed namespaces: [n=1] ‘future.apply’
[13:18:59.177] Finding globals ... DONE
[13:18:59.177]  - use_args: TRUE
[13:18:59.177]  - Getting '...' globals ...
[13:18:59.178] resolve() on list ...
[13:18:59.178]  recursive: 0
[13:18:59.178]  length: 1
[13:18:59.178]  elements: ‘...’
[13:18:59.178]  length: 0 (resolved future 1)
[13:18:59.178] resolve() on list ... DONE
[13:18:59.179]    - '...' content: [n=0] 
[13:18:59.179] List of 1
[13:18:59.179]  $ ...: list()
[13:18:59.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.179]  - attr(*, "where")=List of 1
[13:18:59.179]   ..$ ...:<environment: 0x555f79282d88> 
[13:18:59.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.179]  - attr(*, "resolved")= logi TRUE
[13:18:59.179]  - attr(*, "total_size")= num NA
[13:18:59.182]  - Getting '...' globals ... DONE
[13:18:59.182] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:59.182] List of 8
[13:18:59.182]  $ ...future.FUN:function (x, ...)  
[13:18:59.182]  $ x_FUN        :function (x)  
[13:18:59.182]  $ times        : int 4
[13:18:59.182]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.182]  $ stop_if_not  :function (...)  
[13:18:59.182]  $ dim          : int [1:2] 2 2
[13:18:59.182]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:59.182]  $ ...          : list()
[13:18:59.182]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.182]  - attr(*, "where")=List of 8
[13:18:59.182]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:59.182]   ..$ ...          :<environment: 0x555f79282d88> 
[13:18:59.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.182]  - attr(*, "resolved")= logi FALSE
[13:18:59.182]  - attr(*, "total_size")= num 105552
[13:18:59.188] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:59.188] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.188] Number of futures (= number of chunks): 2
[13:18:59.188] Launching 2 futures (chunks) ...
[13:18:59.188] Chunk #1 of 2 ...
[13:18:59.188]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.188] getGlobalsAndPackages() ...
[13:18:59.189] Searching for globals...
[13:18:59.189] 
[13:18:59.189] Searching for globals ... DONE
[13:18:59.189] - globals: [0] <none>
[13:18:59.189] getGlobalsAndPackages() ... DONE
[13:18:59.189]    + additional globals found: [n=0] 
[13:18:59.189]    + additional namespaces needed: [n=0] 
[13:18:59.189]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.190]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:59.190]  - seeds: <none>
[13:18:59.190] getGlobalsAndPackages() ...
[13:18:59.190] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.190] Resolving globals: FALSE
[13:18:59.190] Tweak future expression to call with '...' arguments ...
[13:18:59.190] {
[13:18:59.190]     do.call(function(...) {
[13:18:59.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.190]             on.exit(options(oopts), add = TRUE)
[13:18:59.190]         }
[13:18:59.190]         {
[13:18:59.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.190]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.190]             })
[13:18:59.190]         }
[13:18:59.190]     }, args = future.call.arguments)
[13:18:59.190] }
[13:18:59.191] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.191] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.191] - packages: [1] ‘future.apply’
[13:18:59.191] getGlobalsAndPackages() ... DONE
[13:18:59.192] run() for ‘Future’ ...
[13:18:59.192] - state: ‘created’
[13:18:59.192] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.196] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.196]   - Field: ‘label’
[13:18:59.196]   - Field: ‘local’
[13:18:59.196]   - Field: ‘owner’
[13:18:59.196]   - Field: ‘envir’
[13:18:59.196]   - Field: ‘workers’
[13:18:59.196]   - Field: ‘packages’
[13:18:59.196]   - Field: ‘gc’
[13:18:59.197]   - Field: ‘job’
[13:18:59.197]   - Field: ‘conditions’
[13:18:59.197]   - Field: ‘expr’
[13:18:59.197]   - Field: ‘uuid’
[13:18:59.197]   - Field: ‘seed’
[13:18:59.197]   - Field: ‘version’
[13:18:59.197]   - Field: ‘result’
[13:18:59.197]   - Field: ‘asynchronous’
[13:18:59.197]   - Field: ‘calls’
[13:18:59.197]   - Field: ‘globals’
[13:18:59.199]   - Field: ‘stdout’
[13:18:59.200]   - Field: ‘earlySignal’
[13:18:59.200]   - Field: ‘lazy’
[13:18:59.200]   - Field: ‘state’
[13:18:59.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.200] - Launch lazy future ...
[13:18:59.200] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:59.200] Packages needed by future strategies (n = 0): <none>
[13:18:59.201] {
[13:18:59.201]     {
[13:18:59.201]         {
[13:18:59.201]             ...future.startTime <- base::Sys.time()
[13:18:59.201]             {
[13:18:59.201]                 {
[13:18:59.201]                   {
[13:18:59.201]                     {
[13:18:59.201]                       {
[13:18:59.201]                         base::local({
[13:18:59.201]                           has_future <- base::requireNamespace("future", 
[13:18:59.201]                             quietly = TRUE)
[13:18:59.201]                           if (has_future) {
[13:18:59.201]                             ns <- base::getNamespace("future")
[13:18:59.201]                             version <- ns[[".package"]][["version"]]
[13:18:59.201]                             if (is.null(version)) 
[13:18:59.201]                               version <- utils::packageVersion("future")
[13:18:59.201]                           }
[13:18:59.201]                           else {
[13:18:59.201]                             version <- NULL
[13:18:59.201]                           }
[13:18:59.201]                           if (!has_future || version < "1.8.0") {
[13:18:59.201]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.201]                               "", base::R.version$version.string), 
[13:18:59.201]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.201]                                 base::R.version$platform, 8 * 
[13:18:59.201]                                   base::.Machine$sizeof.pointer), 
[13:18:59.201]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.201]                                 "release", "version")], collapse = " "), 
[13:18:59.201]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.201]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.201]                               info)
[13:18:59.201]                             info <- base::paste(info, collapse = "; ")
[13:18:59.201]                             if (!has_future) {
[13:18:59.201]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.201]                                 info)
[13:18:59.201]                             }
[13:18:59.201]                             else {
[13:18:59.201]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.201]                                 info, version)
[13:18:59.201]                             }
[13:18:59.201]                             base::stop(msg)
[13:18:59.201]                           }
[13:18:59.201]                         })
[13:18:59.201]                       }
[13:18:59.201]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.201]                       base::options(mc.cores = 1L)
[13:18:59.201]                     }
[13:18:59.201]                     base::local({
[13:18:59.201]                       for (pkg in "future.apply") {
[13:18:59.201]                         base::loadNamespace(pkg)
[13:18:59.201]                         base::library(pkg, character.only = TRUE)
[13:18:59.201]                       }
[13:18:59.201]                     })
[13:18:59.201]                   }
[13:18:59.201]                   options(future.plan = NULL)
[13:18:59.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.201]                 }
[13:18:59.201]                 ...future.workdir <- getwd()
[13:18:59.201]             }
[13:18:59.201]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.201]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.201]         }
[13:18:59.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.201]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:59.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.201]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.201]             base::names(...future.oldOptions))
[13:18:59.201]     }
[13:18:59.201]     if (FALSE) {
[13:18:59.201]     }
[13:18:59.201]     else {
[13:18:59.201]         if (TRUE) {
[13:18:59.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.201]                 open = "w")
[13:18:59.201]         }
[13:18:59.201]         else {
[13:18:59.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.201]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.201]         }
[13:18:59.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.201]             base::sink(type = "output", split = FALSE)
[13:18:59.201]             base::close(...future.stdout)
[13:18:59.201]         }, add = TRUE)
[13:18:59.201]     }
[13:18:59.201]     ...future.frame <- base::sys.nframe()
[13:18:59.201]     ...future.conditions <- base::list()
[13:18:59.201]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.201]     if (FALSE) {
[13:18:59.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.201]     }
[13:18:59.201]     ...future.result <- base::tryCatch({
[13:18:59.201]         base::withCallingHandlers({
[13:18:59.201]             ...future.value <- base::withVisible(base::local({
[13:18:59.201]                 withCallingHandlers({
[13:18:59.201]                   {
[13:18:59.201]                     do.call(function(...) {
[13:18:59.201]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.201]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.201]                         ...future.globals.maxSize)) {
[13:18:59.201]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.201]                         on.exit(options(oopts), add = TRUE)
[13:18:59.201]                       }
[13:18:59.201]                       {
[13:18:59.201]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.201]                           FUN = function(jj) {
[13:18:59.201]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.201]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.201]                           })
[13:18:59.201]                       }
[13:18:59.201]                     }, args = future.call.arguments)
[13:18:59.201]                   }
[13:18:59.201]                 }, immediateCondition = function(cond) {
[13:18:59.201]                   save_rds <- function (object, pathname, ...) 
[13:18:59.201]                   {
[13:18:59.201]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.201]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.201]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.201]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.201]                         fi_tmp[["mtime"]])
[13:18:59.201]                     }
[13:18:59.201]                     tryCatch({
[13:18:59.201]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.201]                     }, error = function(ex) {
[13:18:59.201]                       msg <- conditionMessage(ex)
[13:18:59.201]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.201]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.201]                         fi_tmp[["mtime"]], msg)
[13:18:59.201]                       ex$message <- msg
[13:18:59.201]                       stop(ex)
[13:18:59.201]                     })
[13:18:59.201]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.201]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.201]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.201]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.201]                       fi <- file.info(pathname)
[13:18:59.201]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.201]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.201]                         fi[["size"]], fi[["mtime"]])
[13:18:59.201]                       stop(msg)
[13:18:59.201]                     }
[13:18:59.201]                     invisible(pathname)
[13:18:59.201]                   }
[13:18:59.201]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.201]                     rootPath = tempdir()) 
[13:18:59.201]                   {
[13:18:59.201]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.201]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.201]                       tmpdir = path, fileext = ".rds")
[13:18:59.201]                     save_rds(obj, file)
[13:18:59.201]                   }
[13:18:59.201]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.201]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.201]                   {
[13:18:59.201]                     inherits <- base::inherits
[13:18:59.201]                     invokeRestart <- base::invokeRestart
[13:18:59.201]                     is.null <- base::is.null
[13:18:59.201]                     muffled <- FALSE
[13:18:59.201]                     if (inherits(cond, "message")) {
[13:18:59.201]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.201]                       if (muffled) 
[13:18:59.201]                         invokeRestart("muffleMessage")
[13:18:59.201]                     }
[13:18:59.201]                     else if (inherits(cond, "warning")) {
[13:18:59.201]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.201]                       if (muffled) 
[13:18:59.201]                         invokeRestart("muffleWarning")
[13:18:59.201]                     }
[13:18:59.201]                     else if (inherits(cond, "condition")) {
[13:18:59.201]                       if (!is.null(pattern)) {
[13:18:59.201]                         computeRestarts <- base::computeRestarts
[13:18:59.201]                         grepl <- base::grepl
[13:18:59.201]                         restarts <- computeRestarts(cond)
[13:18:59.201]                         for (restart in restarts) {
[13:18:59.201]                           name <- restart$name
[13:18:59.201]                           if (is.null(name)) 
[13:18:59.201]                             next
[13:18:59.201]                           if (!grepl(pattern, name)) 
[13:18:59.201]                             next
[13:18:59.201]                           invokeRestart(restart)
[13:18:59.201]                           muffled <- TRUE
[13:18:59.201]                           break
[13:18:59.201]                         }
[13:18:59.201]                       }
[13:18:59.201]                     }
[13:18:59.201]                     invisible(muffled)
[13:18:59.201]                   }
[13:18:59.201]                   muffleCondition(cond)
[13:18:59.201]                 })
[13:18:59.201]             }))
[13:18:59.201]             future::FutureResult(value = ...future.value$value, 
[13:18:59.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.201]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.201]                     ...future.globalenv.names))
[13:18:59.201]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.201]         }, condition = base::local({
[13:18:59.201]             c <- base::c
[13:18:59.201]             inherits <- base::inherits
[13:18:59.201]             invokeRestart <- base::invokeRestart
[13:18:59.201]             length <- base::length
[13:18:59.201]             list <- base::list
[13:18:59.201]             seq.int <- base::seq.int
[13:18:59.201]             signalCondition <- base::signalCondition
[13:18:59.201]             sys.calls <- base::sys.calls
[13:18:59.201]             `[[` <- base::`[[`
[13:18:59.201]             `+` <- base::`+`
[13:18:59.201]             `<<-` <- base::`<<-`
[13:18:59.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.201]                   3L)]
[13:18:59.201]             }
[13:18:59.201]             function(cond) {
[13:18:59.201]                 is_error <- inherits(cond, "error")
[13:18:59.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.201]                   NULL)
[13:18:59.201]                 if (is_error) {
[13:18:59.201]                   sessionInformation <- function() {
[13:18:59.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.201]                       search = base::search(), system = base::Sys.info())
[13:18:59.201]                   }
[13:18:59.201]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.201]                     cond$call), session = sessionInformation(), 
[13:18:59.201]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.201]                   signalCondition(cond)
[13:18:59.201]                 }
[13:18:59.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.201]                 "immediateCondition"))) {
[13:18:59.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.201]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.201]                   if (TRUE && !signal) {
[13:18:59.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.201]                     {
[13:18:59.201]                       inherits <- base::inherits
[13:18:59.201]                       invokeRestart <- base::invokeRestart
[13:18:59.201]                       is.null <- base::is.null
[13:18:59.201]                       muffled <- FALSE
[13:18:59.201]                       if (inherits(cond, "message")) {
[13:18:59.201]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.201]                         if (muffled) 
[13:18:59.201]                           invokeRestart("muffleMessage")
[13:18:59.201]                       }
[13:18:59.201]                       else if (inherits(cond, "warning")) {
[13:18:59.201]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.201]                         if (muffled) 
[13:18:59.201]                           invokeRestart("muffleWarning")
[13:18:59.201]                       }
[13:18:59.201]                       else if (inherits(cond, "condition")) {
[13:18:59.201]                         if (!is.null(pattern)) {
[13:18:59.201]                           computeRestarts <- base::computeRestarts
[13:18:59.201]                           grepl <- base::grepl
[13:18:59.201]                           restarts <- computeRestarts(cond)
[13:18:59.201]                           for (restart in restarts) {
[13:18:59.201]                             name <- restart$name
[13:18:59.201]                             if (is.null(name)) 
[13:18:59.201]                               next
[13:18:59.201]                             if (!grepl(pattern, name)) 
[13:18:59.201]                               next
[13:18:59.201]                             invokeRestart(restart)
[13:18:59.201]                             muffled <- TRUE
[13:18:59.201]                             break
[13:18:59.201]                           }
[13:18:59.201]                         }
[13:18:59.201]                       }
[13:18:59.201]                       invisible(muffled)
[13:18:59.201]                     }
[13:18:59.201]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.201]                   }
[13:18:59.201]                 }
[13:18:59.201]                 else {
[13:18:59.201]                   if (TRUE) {
[13:18:59.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.201]                     {
[13:18:59.201]                       inherits <- base::inherits
[13:18:59.201]                       invokeRestart <- base::invokeRestart
[13:18:59.201]                       is.null <- base::is.null
[13:18:59.201]                       muffled <- FALSE
[13:18:59.201]                       if (inherits(cond, "message")) {
[13:18:59.201]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.201]                         if (muffled) 
[13:18:59.201]                           invokeRestart("muffleMessage")
[13:18:59.201]                       }
[13:18:59.201]                       else if (inherits(cond, "warning")) {
[13:18:59.201]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.201]                         if (muffled) 
[13:18:59.201]                           invokeRestart("muffleWarning")
[13:18:59.201]                       }
[13:18:59.201]                       else if (inherits(cond, "condition")) {
[13:18:59.201]                         if (!is.null(pattern)) {
[13:18:59.201]                           computeRestarts <- base::computeRestarts
[13:18:59.201]                           grepl <- base::grepl
[13:18:59.201]                           restarts <- computeRestarts(cond)
[13:18:59.201]                           for (restart in restarts) {
[13:18:59.201]                             name <- restart$name
[13:18:59.201]                             if (is.null(name)) 
[13:18:59.201]                               next
[13:18:59.201]                             if (!grepl(pattern, name)) 
[13:18:59.201]                               next
[13:18:59.201]                             invokeRestart(restart)
[13:18:59.201]                             muffled <- TRUE
[13:18:59.201]                             break
[13:18:59.201]                           }
[13:18:59.201]                         }
[13:18:59.201]                       }
[13:18:59.201]                       invisible(muffled)
[13:18:59.201]                     }
[13:18:59.201]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.201]                   }
[13:18:59.201]                 }
[13:18:59.201]             }
[13:18:59.201]         }))
[13:18:59.201]     }, error = function(ex) {
[13:18:59.201]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.201]                 ...future.rng), started = ...future.startTime, 
[13:18:59.201]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.201]             version = "1.8"), class = "FutureResult")
[13:18:59.201]     }, finally = {
[13:18:59.201]         if (!identical(...future.workdir, getwd())) 
[13:18:59.201]             setwd(...future.workdir)
[13:18:59.201]         {
[13:18:59.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.201]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.201]             }
[13:18:59.201]             base::options(...future.oldOptions)
[13:18:59.201]             if (.Platform$OS.type == "windows") {
[13:18:59.201]                 old_names <- names(...future.oldEnvVars)
[13:18:59.201]                 envs <- base::Sys.getenv()
[13:18:59.201]                 names <- names(envs)
[13:18:59.201]                 common <- intersect(names, old_names)
[13:18:59.201]                 added <- setdiff(names, old_names)
[13:18:59.201]                 removed <- setdiff(old_names, names)
[13:18:59.201]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.201]                   envs[common]]
[13:18:59.201]                 NAMES <- toupper(changed)
[13:18:59.201]                 args <- list()
[13:18:59.201]                 for (kk in seq_along(NAMES)) {
[13:18:59.201]                   name <- changed[[kk]]
[13:18:59.201]                   NAME <- NAMES[[kk]]
[13:18:59.201]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.201]                     next
[13:18:59.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.201]                 }
[13:18:59.201]                 NAMES <- toupper(added)
[13:18:59.201]                 for (kk in seq_along(NAMES)) {
[13:18:59.201]                   name <- added[[kk]]
[13:18:59.201]                   NAME <- NAMES[[kk]]
[13:18:59.201]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.201]                     next
[13:18:59.201]                   args[[name]] <- ""
[13:18:59.201]                 }
[13:18:59.201]                 NAMES <- toupper(removed)
[13:18:59.201]                 for (kk in seq_along(NAMES)) {
[13:18:59.201]                   name <- removed[[kk]]
[13:18:59.201]                   NAME <- NAMES[[kk]]
[13:18:59.201]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.201]                     next
[13:18:59.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.201]                 }
[13:18:59.201]                 if (length(args) > 0) 
[13:18:59.201]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.201]             }
[13:18:59.201]             else {
[13:18:59.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.201]             }
[13:18:59.201]             {
[13:18:59.201]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.201]                   0L) {
[13:18:59.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.201]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.201]                   base::options(opts)
[13:18:59.201]                 }
[13:18:59.201]                 {
[13:18:59.201]                   {
[13:18:59.201]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.201]                     NULL
[13:18:59.201]                   }
[13:18:59.201]                   options(future.plan = NULL)
[13:18:59.201]                   if (is.na(NA_character_)) 
[13:18:59.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.201]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.201]                     envir = parent.frame()) 
[13:18:59.201]                   {
[13:18:59.201]                     default_workers <- missing(workers)
[13:18:59.201]                     if (is.function(workers)) 
[13:18:59.201]                       workers <- workers()
[13:18:59.201]                     workers <- structure(as.integer(workers), 
[13:18:59.201]                       class = class(workers))
[13:18:59.201]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.201]                       1L)
[13:18:59.201]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.201]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.201]                       if (default_workers) 
[13:18:59.201]                         supportsMulticore(warn = TRUE)
[13:18:59.201]                       return(sequential(..., envir = envir))
[13:18:59.201]                     }
[13:18:59.201]                     oopts <- options(mc.cores = workers)
[13:18:59.201]                     on.exit(options(oopts))
[13:18:59.201]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.201]                       envir = envir)
[13:18:59.201]                     if (!future$lazy) 
[13:18:59.201]                       future <- run(future)
[13:18:59.201]                     invisible(future)
[13:18:59.201]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.201]                 }
[13:18:59.201]             }
[13:18:59.201]         }
[13:18:59.201]     })
[13:18:59.201]     if (TRUE) {
[13:18:59.201]         base::sink(type = "output", split = FALSE)
[13:18:59.201]         if (TRUE) {
[13:18:59.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.201]         }
[13:18:59.201]         else {
[13:18:59.201]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.201]         }
[13:18:59.201]         base::close(...future.stdout)
[13:18:59.201]         ...future.stdout <- NULL
[13:18:59.201]     }
[13:18:59.201]     ...future.result$conditions <- ...future.conditions
[13:18:59.201]     ...future.result$finished <- base::Sys.time()
[13:18:59.201]     ...future.result
[13:18:59.201] }
[13:18:59.204] assign_globals() ...
[13:18:59.204] List of 11
[13:18:59.204]  $ ...future.FUN            :function (x, ...)  
[13:18:59.204]  $ x_FUN                    :function (x)  
[13:18:59.204]  $ times                    : int 4
[13:18:59.204]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.204]  $ stop_if_not              :function (...)  
[13:18:59.204]  $ dim                      : int [1:2] 2 2
[13:18:59.204]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.204]  $ future.call.arguments    : list()
[13:18:59.204]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.204]  $ ...future.elements_ii    :List of 5
[13:18:59.204]   ..$ : int 1
[13:18:59.204]   ..$ : int 2
[13:18:59.204]   ..$ : int 3
[13:18:59.204]   ..$ : int 4
[13:18:59.204]   ..$ : int 5
[13:18:59.204]  $ ...future.seeds_ii       : NULL
[13:18:59.204]  $ ...future.globals.maxSize: NULL
[13:18:59.204]  - attr(*, "resolved")= logi FALSE
[13:18:59.204]  - attr(*, "total_size")= num 105552
[13:18:59.204]  - attr(*, "where")=List of 11
[13:18:59.204]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.204]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.204]  - attr(*, "already-done")= logi TRUE
[13:18:59.213] - copied ‘...future.FUN’ to environment
[13:18:59.213] - reassign environment for ‘x_FUN’
[13:18:59.213] - copied ‘x_FUN’ to environment
[13:18:59.214] - copied ‘times’ to environment
[13:18:59.214] - copied ‘stopf’ to environment
[13:18:59.214] - copied ‘stop_if_not’ to environment
[13:18:59.214] - copied ‘dim’ to environment
[13:18:59.214] - copied ‘valid_types’ to environment
[13:18:59.214] - copied ‘future.call.arguments’ to environment
[13:18:59.214] - copied ‘...future.elements_ii’ to environment
[13:18:59.214] - copied ‘...future.seeds_ii’ to environment
[13:18:59.214] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.214] assign_globals() ... done
[13:18:59.215] requestCore(): workers = 2
[13:18:59.217] MulticoreFuture started
[13:18:59.217] - Launch lazy future ... done
[13:18:59.217] run() for ‘MulticoreFuture’ ... done
[13:18:59.218] Created future:
[13:18:59.218] plan(): Setting new future strategy stack:
[13:18:59.219] List of future strategies:
[13:18:59.219] 1. sequential:
[13:18:59.219]    - args: function (..., envir = parent.frame())
[13:18:59.219]    - tweaked: FALSE
[13:18:59.219]    - call: NULL
[13:18:59.219] plan(): nbrOfWorkers() = 1
[13:18:59.222] plan(): Setting new future strategy stack:
[13:18:59.222] List of future strategies:
[13:18:59.222] 1. multicore:
[13:18:59.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.222]    - tweaked: FALSE
[13:18:59.222]    - call: plan(strategy)
[13:18:59.227] plan(): nbrOfWorkers() = 2
[13:18:59.218] MulticoreFuture:
[13:18:59.218] Label: ‘future_vapply-1’
[13:18:59.218] Expression:
[13:18:59.218] {
[13:18:59.218]     do.call(function(...) {
[13:18:59.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.218]             on.exit(options(oopts), add = TRUE)
[13:18:59.218]         }
[13:18:59.218]         {
[13:18:59.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.218]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.218]             })
[13:18:59.218]         }
[13:18:59.218]     }, args = future.call.arguments)
[13:18:59.218] }
[13:18:59.218] Lazy evaluation: FALSE
[13:18:59.218] Asynchronous evaluation: TRUE
[13:18:59.218] Local evaluation: TRUE
[13:18:59.218] Environment: R_GlobalEnv
[13:18:59.218] Capture standard output: TRUE
[13:18:59.218] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.218] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.218] Packages: 1 packages (‘future.apply’)
[13:18:59.218] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.218] Resolved: TRUE
[13:18:59.218] Value: <not collected>
[13:18:59.218] Conditions captured: <none>
[13:18:59.218] Early signaling: FALSE
[13:18:59.218] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.218] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.228] Chunk #1 of 2 ... DONE
[13:18:59.229] Chunk #2 of 2 ...
[13:18:59.229]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.229] getGlobalsAndPackages() ...
[13:18:59.229] Searching for globals...
[13:18:59.230] 
[13:18:59.230] Searching for globals ... DONE
[13:18:59.230] - globals: [0] <none>
[13:18:59.230] getGlobalsAndPackages() ... DONE
[13:18:59.230]    + additional globals found: [n=0] 
[13:18:59.230]    + additional namespaces needed: [n=0] 
[13:18:59.230]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.231]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:18:59.231]  - seeds: <none>
[13:18:59.231] getGlobalsAndPackages() ...
[13:18:59.231] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.231] Resolving globals: FALSE
[13:18:59.232] Tweak future expression to call with '...' arguments ...
[13:18:59.232] {
[13:18:59.232]     do.call(function(...) {
[13:18:59.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.232]             on.exit(options(oopts), add = TRUE)
[13:18:59.232]         }
[13:18:59.232]         {
[13:18:59.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.232]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.232]             })
[13:18:59.232]         }
[13:18:59.232]     }, args = future.call.arguments)
[13:18:59.232] }
[13:18:59.232] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.233] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.234] - packages: [1] ‘future.apply’
[13:18:59.234] getGlobalsAndPackages() ... DONE
[13:18:59.234] run() for ‘Future’ ...
[13:18:59.234] - state: ‘created’
[13:18:59.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.244] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.244]   - Field: ‘label’
[13:18:59.245]   - Field: ‘local’
[13:18:59.245]   - Field: ‘owner’
[13:18:59.245]   - Field: ‘envir’
[13:18:59.245]   - Field: ‘workers’
[13:18:59.246]   - Field: ‘packages’
[13:18:59.246]   - Field: ‘gc’
[13:18:59.246]   - Field: ‘job’
[13:18:59.246]   - Field: ‘conditions’
[13:18:59.246]   - Field: ‘expr’
[13:18:59.247]   - Field: ‘uuid’
[13:18:59.247]   - Field: ‘seed’
[13:18:59.247]   - Field: ‘version’
[13:18:59.247]   - Field: ‘result’
[13:18:59.248]   - Field: ‘asynchronous’
[13:18:59.248]   - Field: ‘calls’
[13:18:59.248]   - Field: ‘globals’
[13:18:59.248]   - Field: ‘stdout’
[13:18:59.249]   - Field: ‘earlySignal’
[13:18:59.249]   - Field: ‘lazy’
[13:18:59.249]   - Field: ‘state’
[13:18:59.249] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.249] - Launch lazy future ...
[13:18:59.250] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:59.250] Packages needed by future strategies (n = 0): <none>
[13:18:59.251] {
[13:18:59.251]     {
[13:18:59.251]         {
[13:18:59.251]             ...future.startTime <- base::Sys.time()
[13:18:59.251]             {
[13:18:59.251]                 {
[13:18:59.251]                   {
[13:18:59.251]                     {
[13:18:59.251]                       {
[13:18:59.251]                         base::local({
[13:18:59.251]                           has_future <- base::requireNamespace("future", 
[13:18:59.251]                             quietly = TRUE)
[13:18:59.251]                           if (has_future) {
[13:18:59.251]                             ns <- base::getNamespace("future")
[13:18:59.251]                             version <- ns[[".package"]][["version"]]
[13:18:59.251]                             if (is.null(version)) 
[13:18:59.251]                               version <- utils::packageVersion("future")
[13:18:59.251]                           }
[13:18:59.251]                           else {
[13:18:59.251]                             version <- NULL
[13:18:59.251]                           }
[13:18:59.251]                           if (!has_future || version < "1.8.0") {
[13:18:59.251]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.251]                               "", base::R.version$version.string), 
[13:18:59.251]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.251]                                 base::R.version$platform, 8 * 
[13:18:59.251]                                   base::.Machine$sizeof.pointer), 
[13:18:59.251]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.251]                                 "release", "version")], collapse = " "), 
[13:18:59.251]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.251]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.251]                               info)
[13:18:59.251]                             info <- base::paste(info, collapse = "; ")
[13:18:59.251]                             if (!has_future) {
[13:18:59.251]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.251]                                 info)
[13:18:59.251]                             }
[13:18:59.251]                             else {
[13:18:59.251]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.251]                                 info, version)
[13:18:59.251]                             }
[13:18:59.251]                             base::stop(msg)
[13:18:59.251]                           }
[13:18:59.251]                         })
[13:18:59.251]                       }
[13:18:59.251]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.251]                       base::options(mc.cores = 1L)
[13:18:59.251]                     }
[13:18:59.251]                     base::local({
[13:18:59.251]                       for (pkg in "future.apply") {
[13:18:59.251]                         base::loadNamespace(pkg)
[13:18:59.251]                         base::library(pkg, character.only = TRUE)
[13:18:59.251]                       }
[13:18:59.251]                     })
[13:18:59.251]                   }
[13:18:59.251]                   options(future.plan = NULL)
[13:18:59.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.251]                 }
[13:18:59.251]                 ...future.workdir <- getwd()
[13:18:59.251]             }
[13:18:59.251]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.251]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.251]         }
[13:18:59.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.251]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:18:59.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.251]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.251]             base::names(...future.oldOptions))
[13:18:59.251]     }
[13:18:59.251]     if (FALSE) {
[13:18:59.251]     }
[13:18:59.251]     else {
[13:18:59.251]         if (TRUE) {
[13:18:59.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.251]                 open = "w")
[13:18:59.251]         }
[13:18:59.251]         else {
[13:18:59.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.251]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.251]         }
[13:18:59.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.251]             base::sink(type = "output", split = FALSE)
[13:18:59.251]             base::close(...future.stdout)
[13:18:59.251]         }, add = TRUE)
[13:18:59.251]     }
[13:18:59.251]     ...future.frame <- base::sys.nframe()
[13:18:59.251]     ...future.conditions <- base::list()
[13:18:59.251]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.251]     if (FALSE) {
[13:18:59.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.251]     }
[13:18:59.251]     ...future.result <- base::tryCatch({
[13:18:59.251]         base::withCallingHandlers({
[13:18:59.251]             ...future.value <- base::withVisible(base::local({
[13:18:59.251]                 withCallingHandlers({
[13:18:59.251]                   {
[13:18:59.251]                     do.call(function(...) {
[13:18:59.251]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.251]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.251]                         ...future.globals.maxSize)) {
[13:18:59.251]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.251]                         on.exit(options(oopts), add = TRUE)
[13:18:59.251]                       }
[13:18:59.251]                       {
[13:18:59.251]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.251]                           FUN = function(jj) {
[13:18:59.251]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.251]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.251]                           })
[13:18:59.251]                       }
[13:18:59.251]                     }, args = future.call.arguments)
[13:18:59.251]                   }
[13:18:59.251]                 }, immediateCondition = function(cond) {
[13:18:59.251]                   save_rds <- function (object, pathname, ...) 
[13:18:59.251]                   {
[13:18:59.251]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.251]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.251]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.251]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.251]                         fi_tmp[["mtime"]])
[13:18:59.251]                     }
[13:18:59.251]                     tryCatch({
[13:18:59.251]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.251]                     }, error = function(ex) {
[13:18:59.251]                       msg <- conditionMessage(ex)
[13:18:59.251]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.251]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.251]                         fi_tmp[["mtime"]], msg)
[13:18:59.251]                       ex$message <- msg
[13:18:59.251]                       stop(ex)
[13:18:59.251]                     })
[13:18:59.251]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.251]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.251]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.251]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.251]                       fi <- file.info(pathname)
[13:18:59.251]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.251]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.251]                         fi[["size"]], fi[["mtime"]])
[13:18:59.251]                       stop(msg)
[13:18:59.251]                     }
[13:18:59.251]                     invisible(pathname)
[13:18:59.251]                   }
[13:18:59.251]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.251]                     rootPath = tempdir()) 
[13:18:59.251]                   {
[13:18:59.251]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.251]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.251]                       tmpdir = path, fileext = ".rds")
[13:18:59.251]                     save_rds(obj, file)
[13:18:59.251]                   }
[13:18:59.251]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.251]                   {
[13:18:59.251]                     inherits <- base::inherits
[13:18:59.251]                     invokeRestart <- base::invokeRestart
[13:18:59.251]                     is.null <- base::is.null
[13:18:59.251]                     muffled <- FALSE
[13:18:59.251]                     if (inherits(cond, "message")) {
[13:18:59.251]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.251]                       if (muffled) 
[13:18:59.251]                         invokeRestart("muffleMessage")
[13:18:59.251]                     }
[13:18:59.251]                     else if (inherits(cond, "warning")) {
[13:18:59.251]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.251]                       if (muffled) 
[13:18:59.251]                         invokeRestart("muffleWarning")
[13:18:59.251]                     }
[13:18:59.251]                     else if (inherits(cond, "condition")) {
[13:18:59.251]                       if (!is.null(pattern)) {
[13:18:59.251]                         computeRestarts <- base::computeRestarts
[13:18:59.251]                         grepl <- base::grepl
[13:18:59.251]                         restarts <- computeRestarts(cond)
[13:18:59.251]                         for (restart in restarts) {
[13:18:59.251]                           name <- restart$name
[13:18:59.251]                           if (is.null(name)) 
[13:18:59.251]                             next
[13:18:59.251]                           if (!grepl(pattern, name)) 
[13:18:59.251]                             next
[13:18:59.251]                           invokeRestart(restart)
[13:18:59.251]                           muffled <- TRUE
[13:18:59.251]                           break
[13:18:59.251]                         }
[13:18:59.251]                       }
[13:18:59.251]                     }
[13:18:59.251]                     invisible(muffled)
[13:18:59.251]                   }
[13:18:59.251]                   muffleCondition(cond)
[13:18:59.251]                 })
[13:18:59.251]             }))
[13:18:59.251]             future::FutureResult(value = ...future.value$value, 
[13:18:59.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.251]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.251]                     ...future.globalenv.names))
[13:18:59.251]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.251]         }, condition = base::local({
[13:18:59.251]             c <- base::c
[13:18:59.251]             inherits <- base::inherits
[13:18:59.251]             invokeRestart <- base::invokeRestart
[13:18:59.251]             length <- base::length
[13:18:59.251]             list <- base::list
[13:18:59.251]             seq.int <- base::seq.int
[13:18:59.251]             signalCondition <- base::signalCondition
[13:18:59.251]             sys.calls <- base::sys.calls
[13:18:59.251]             `[[` <- base::`[[`
[13:18:59.251]             `+` <- base::`+`
[13:18:59.251]             `<<-` <- base::`<<-`
[13:18:59.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.251]                   3L)]
[13:18:59.251]             }
[13:18:59.251]             function(cond) {
[13:18:59.251]                 is_error <- inherits(cond, "error")
[13:18:59.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.251]                   NULL)
[13:18:59.251]                 if (is_error) {
[13:18:59.251]                   sessionInformation <- function() {
[13:18:59.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.251]                       search = base::search(), system = base::Sys.info())
[13:18:59.251]                   }
[13:18:59.251]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.251]                     cond$call), session = sessionInformation(), 
[13:18:59.251]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.251]                   signalCondition(cond)
[13:18:59.251]                 }
[13:18:59.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.251]                 "immediateCondition"))) {
[13:18:59.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.251]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.251]                   if (TRUE && !signal) {
[13:18:59.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.251]                     {
[13:18:59.251]                       inherits <- base::inherits
[13:18:59.251]                       invokeRestart <- base::invokeRestart
[13:18:59.251]                       is.null <- base::is.null
[13:18:59.251]                       muffled <- FALSE
[13:18:59.251]                       if (inherits(cond, "message")) {
[13:18:59.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.251]                         if (muffled) 
[13:18:59.251]                           invokeRestart("muffleMessage")
[13:18:59.251]                       }
[13:18:59.251]                       else if (inherits(cond, "warning")) {
[13:18:59.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.251]                         if (muffled) 
[13:18:59.251]                           invokeRestart("muffleWarning")
[13:18:59.251]                       }
[13:18:59.251]                       else if (inherits(cond, "condition")) {
[13:18:59.251]                         if (!is.null(pattern)) {
[13:18:59.251]                           computeRestarts <- base::computeRestarts
[13:18:59.251]                           grepl <- base::grepl
[13:18:59.251]                           restarts <- computeRestarts(cond)
[13:18:59.251]                           for (restart in restarts) {
[13:18:59.251]                             name <- restart$name
[13:18:59.251]                             if (is.null(name)) 
[13:18:59.251]                               next
[13:18:59.251]                             if (!grepl(pattern, name)) 
[13:18:59.251]                               next
[13:18:59.251]                             invokeRestart(restart)
[13:18:59.251]                             muffled <- TRUE
[13:18:59.251]                             break
[13:18:59.251]                           }
[13:18:59.251]                         }
[13:18:59.251]                       }
[13:18:59.251]                       invisible(muffled)
[13:18:59.251]                     }
[13:18:59.251]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.251]                   }
[13:18:59.251]                 }
[13:18:59.251]                 else {
[13:18:59.251]                   if (TRUE) {
[13:18:59.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.251]                     {
[13:18:59.251]                       inherits <- base::inherits
[13:18:59.251]                       invokeRestart <- base::invokeRestart
[13:18:59.251]                       is.null <- base::is.null
[13:18:59.251]                       muffled <- FALSE
[13:18:59.251]                       if (inherits(cond, "message")) {
[13:18:59.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.251]                         if (muffled) 
[13:18:59.251]                           invokeRestart("muffleMessage")
[13:18:59.251]                       }
[13:18:59.251]                       else if (inherits(cond, "warning")) {
[13:18:59.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.251]                         if (muffled) 
[13:18:59.251]                           invokeRestart("muffleWarning")
[13:18:59.251]                       }
[13:18:59.251]                       else if (inherits(cond, "condition")) {
[13:18:59.251]                         if (!is.null(pattern)) {
[13:18:59.251]                           computeRestarts <- base::computeRestarts
[13:18:59.251]                           grepl <- base::grepl
[13:18:59.251]                           restarts <- computeRestarts(cond)
[13:18:59.251]                           for (restart in restarts) {
[13:18:59.251]                             name <- restart$name
[13:18:59.251]                             if (is.null(name)) 
[13:18:59.251]                               next
[13:18:59.251]                             if (!grepl(pattern, name)) 
[13:18:59.251]                               next
[13:18:59.251]                             invokeRestart(restart)
[13:18:59.251]                             muffled <- TRUE
[13:18:59.251]                             break
[13:18:59.251]                           }
[13:18:59.251]                         }
[13:18:59.251]                       }
[13:18:59.251]                       invisible(muffled)
[13:18:59.251]                     }
[13:18:59.251]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.251]                   }
[13:18:59.251]                 }
[13:18:59.251]             }
[13:18:59.251]         }))
[13:18:59.251]     }, error = function(ex) {
[13:18:59.251]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.251]                 ...future.rng), started = ...future.startTime, 
[13:18:59.251]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.251]             version = "1.8"), class = "FutureResult")
[13:18:59.251]     }, finally = {
[13:18:59.251]         if (!identical(...future.workdir, getwd())) 
[13:18:59.251]             setwd(...future.workdir)
[13:18:59.251]         {
[13:18:59.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.251]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.251]             }
[13:18:59.251]             base::options(...future.oldOptions)
[13:18:59.251]             if (.Platform$OS.type == "windows") {
[13:18:59.251]                 old_names <- names(...future.oldEnvVars)
[13:18:59.251]                 envs <- base::Sys.getenv()
[13:18:59.251]                 names <- names(envs)
[13:18:59.251]                 common <- intersect(names, old_names)
[13:18:59.251]                 added <- setdiff(names, old_names)
[13:18:59.251]                 removed <- setdiff(old_names, names)
[13:18:59.251]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.251]                   envs[common]]
[13:18:59.251]                 NAMES <- toupper(changed)
[13:18:59.251]                 args <- list()
[13:18:59.251]                 for (kk in seq_along(NAMES)) {
[13:18:59.251]                   name <- changed[[kk]]
[13:18:59.251]                   NAME <- NAMES[[kk]]
[13:18:59.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.251]                     next
[13:18:59.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.251]                 }
[13:18:59.251]                 NAMES <- toupper(added)
[13:18:59.251]                 for (kk in seq_along(NAMES)) {
[13:18:59.251]                   name <- added[[kk]]
[13:18:59.251]                   NAME <- NAMES[[kk]]
[13:18:59.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.251]                     next
[13:18:59.251]                   args[[name]] <- ""
[13:18:59.251]                 }
[13:18:59.251]                 NAMES <- toupper(removed)
[13:18:59.251]                 for (kk in seq_along(NAMES)) {
[13:18:59.251]                   name <- removed[[kk]]
[13:18:59.251]                   NAME <- NAMES[[kk]]
[13:18:59.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.251]                     next
[13:18:59.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.251]                 }
[13:18:59.251]                 if (length(args) > 0) 
[13:18:59.251]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.251]             }
[13:18:59.251]             else {
[13:18:59.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.251]             }
[13:18:59.251]             {
[13:18:59.251]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.251]                   0L) {
[13:18:59.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.251]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.251]                   base::options(opts)
[13:18:59.251]                 }
[13:18:59.251]                 {
[13:18:59.251]                   {
[13:18:59.251]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.251]                     NULL
[13:18:59.251]                   }
[13:18:59.251]                   options(future.plan = NULL)
[13:18:59.251]                   if (is.na(NA_character_)) 
[13:18:59.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.251]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.251]                     envir = parent.frame()) 
[13:18:59.251]                   {
[13:18:59.251]                     default_workers <- missing(workers)
[13:18:59.251]                     if (is.function(workers)) 
[13:18:59.251]                       workers <- workers()
[13:18:59.251]                     workers <- structure(as.integer(workers), 
[13:18:59.251]                       class = class(workers))
[13:18:59.251]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.251]                       1L)
[13:18:59.251]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.251]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.251]                       if (default_workers) 
[13:18:59.251]                         supportsMulticore(warn = TRUE)
[13:18:59.251]                       return(sequential(..., envir = envir))
[13:18:59.251]                     }
[13:18:59.251]                     oopts <- options(mc.cores = workers)
[13:18:59.251]                     on.exit(options(oopts))
[13:18:59.251]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.251]                       envir = envir)
[13:18:59.251]                     if (!future$lazy) 
[13:18:59.251]                       future <- run(future)
[13:18:59.251]                     invisible(future)
[13:18:59.251]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.251]                 }
[13:18:59.251]             }
[13:18:59.251]         }
[13:18:59.251]     })
[13:18:59.251]     if (TRUE) {
[13:18:59.251]         base::sink(type = "output", split = FALSE)
[13:18:59.251]         if (TRUE) {
[13:18:59.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.251]         }
[13:18:59.251]         else {
[13:18:59.251]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.251]         }
[13:18:59.251]         base::close(...future.stdout)
[13:18:59.251]         ...future.stdout <- NULL
[13:18:59.251]     }
[13:18:59.251]     ...future.result$conditions <- ...future.conditions
[13:18:59.251]     ...future.result$finished <- base::Sys.time()
[13:18:59.251]     ...future.result
[13:18:59.251] }
[13:18:59.254] assign_globals() ...
[13:18:59.255] List of 11
[13:18:59.255]  $ ...future.FUN            :function (x, ...)  
[13:18:59.255]  $ x_FUN                    :function (x)  
[13:18:59.255]  $ times                    : int 4
[13:18:59.255]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.255]  $ stop_if_not              :function (...)  
[13:18:59.255]  $ dim                      : int [1:2] 2 2
[13:18:59.255]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.255]  $ future.call.arguments    : list()
[13:18:59.255]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.255]  $ ...future.elements_ii    :List of 5
[13:18:59.255]   ..$ : int 6
[13:18:59.255]   ..$ : int 7
[13:18:59.255]   ..$ : int 8
[13:18:59.255]   ..$ : int 9
[13:18:59.255]   ..$ : int 10
[13:18:59.255]  $ ...future.seeds_ii       : NULL
[13:18:59.255]  $ ...future.globals.maxSize: NULL
[13:18:59.255]  - attr(*, "resolved")= logi FALSE
[13:18:59.255]  - attr(*, "total_size")= num 105552
[13:18:59.255]  - attr(*, "where")=List of 11
[13:18:59.255]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.255]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.255]  - attr(*, "already-done")= logi TRUE
[13:18:59.267] - copied ‘...future.FUN’ to environment
[13:18:59.267] - reassign environment for ‘x_FUN’
[13:18:59.267] - copied ‘x_FUN’ to environment
[13:18:59.267] - copied ‘times’ to environment
[13:18:59.267] - copied ‘stopf’ to environment
[13:18:59.268] - copied ‘stop_if_not’ to environment
[13:18:59.268] - copied ‘dim’ to environment
[13:18:59.268] - copied ‘valid_types’ to environment
[13:18:59.268] - copied ‘future.call.arguments’ to environment
[13:18:59.268] - copied ‘...future.elements_ii’ to environment
[13:18:59.268] - copied ‘...future.seeds_ii’ to environment
[13:18:59.268] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.268] assign_globals() ... done
[13:18:59.268] requestCore(): workers = 2
[13:18:59.271] MulticoreFuture started
[13:18:59.271] - Launch lazy future ... done
[13:18:59.271] run() for ‘MulticoreFuture’ ... done
[13:18:59.272] Created future:
[13:18:59.272] plan(): Setting new future strategy stack:
[13:18:59.272] List of future strategies:
[13:18:59.272] 1. sequential:
[13:18:59.272]    - args: function (..., envir = parent.frame())
[13:18:59.272]    - tweaked: FALSE
[13:18:59.272]    - call: NULL
[13:18:59.273] plan(): nbrOfWorkers() = 1
[13:18:59.276] plan(): Setting new future strategy stack:
[13:18:59.276] List of future strategies:
[13:18:59.276] 1. multicore:
[13:18:59.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.276]    - tweaked: FALSE
[13:18:59.276]    - call: plan(strategy)
[13:18:59.281] plan(): nbrOfWorkers() = 2
[13:18:59.272] MulticoreFuture:
[13:18:59.272] Label: ‘future_vapply-2’
[13:18:59.272] Expression:
[13:18:59.272] {
[13:18:59.272]     do.call(function(...) {
[13:18:59.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.272]             on.exit(options(oopts), add = TRUE)
[13:18:59.272]         }
[13:18:59.272]         {
[13:18:59.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.272]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.272]             })
[13:18:59.272]         }
[13:18:59.272]     }, args = future.call.arguments)
[13:18:59.272] }
[13:18:59.272] Lazy evaluation: FALSE
[13:18:59.272] Asynchronous evaluation: TRUE
[13:18:59.272] Local evaluation: TRUE
[13:18:59.272] Environment: R_GlobalEnv
[13:18:59.272] Capture standard output: TRUE
[13:18:59.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.272] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.272] Packages: 1 packages (‘future.apply’)
[13:18:59.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.272] Resolved: TRUE
[13:18:59.272] Value: <not collected>
[13:18:59.272] Conditions captured: <none>
[13:18:59.272] Early signaling: FALSE
[13:18:59.272] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.272] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.282] Chunk #2 of 2 ... DONE
[13:18:59.282] Launching 2 futures (chunks) ... DONE
[13:18:59.282] Resolving 2 futures (chunks) ...
[13:18:59.283] resolve() on list ...
[13:18:59.283]  recursive: 0
[13:18:59.283]  length: 2
[13:18:59.283] 
[13:18:59.283] Future #1
[13:18:59.284] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.284] - nx: 2
[13:18:59.285] - relay: TRUE
[13:18:59.288] - stdout: TRUE
[13:18:59.289] - signal: TRUE
[13:18:59.289] - resignal: FALSE
[13:18:59.289] - force: TRUE
[13:18:59.290] - relayed: [n=2] FALSE, FALSE
[13:18:59.290] - queued futures: [n=2] FALSE, FALSE
[13:18:59.290]  - until=1
[13:18:59.291]  - relaying element #1
[13:18:59.291] - relayed: [n=2] TRUE, FALSE
[13:18:59.292] - queued futures: [n=2] TRUE, FALSE
[13:18:59.292] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.292]  length: 1 (resolved future 1)
[13:18:59.293] Future #2
[13:18:59.294] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.294] - nx: 2
[13:18:59.294] - relay: TRUE
[13:18:59.295] - stdout: TRUE
[13:18:59.295] - signal: TRUE
[13:18:59.295] - resignal: FALSE
[13:18:59.295] - force: TRUE
[13:18:59.295] - relayed: [n=2] TRUE, FALSE
[13:18:59.295] - queued futures: [n=2] TRUE, FALSE
[13:18:59.296]  - until=2
[13:18:59.296]  - relaying element #2
[13:18:59.296] - relayed: [n=2] TRUE, TRUE
[13:18:59.296] - queued futures: [n=2] TRUE, TRUE
[13:18:59.296] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.297]  length: 0 (resolved future 2)
[13:18:59.297] Relaying remaining futures
[13:18:59.297] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.297] - nx: 2
[13:18:59.297] - relay: TRUE
[13:18:59.297] - stdout: TRUE
[13:18:59.297] - signal: TRUE
[13:18:59.298] - resignal: FALSE
[13:18:59.298] - force: TRUE
[13:18:59.298] - relayed: [n=2] TRUE, TRUE
[13:18:59.298] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.298] - relayed: [n=2] TRUE, TRUE
[13:18:59.298] - queued futures: [n=2] TRUE, TRUE
[13:18:59.298] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.299] resolve() on list ... DONE
[13:18:59.299]  - Number of value chunks collected: 2
[13:18:59.299] Resolving 2 futures (chunks) ... DONE
[13:18:59.299] Reducing values from 2 chunks ...
[13:18:59.299]  - Number of values collected after concatenation: 10
[13:18:59.299]  - Number of values expected: 10
[13:18:59.299] Reducing values from 2 chunks ... DONE
[13:18:59.300] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:18:59.303] future_lapply() ...
[13:18:59.309] Number of chunks: 2
[13:18:59.309] getGlobalsAndPackagesXApply() ...
[13:18:59.309]  - future.globals: TRUE
[13:18:59.309] getGlobalsAndPackages() ...
[13:18:59.309] Searching for globals...
[13:18:59.313] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:18:59.313] Searching for globals ... DONE
[13:18:59.313] Resolving globals: FALSE
[13:18:59.314] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:18:59.314] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:59.315] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.315] - packages: [2] ‘stats’, ‘future.apply’
[13:18:59.315] getGlobalsAndPackages() ... DONE
[13:18:59.315]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.315]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:18:59.315] Finding globals ... DONE
[13:18:59.315]  - use_args: TRUE
[13:18:59.315]  - Getting '...' globals ...
[13:18:59.316] resolve() on list ...
[13:18:59.316]  recursive: 0
[13:18:59.316]  length: 1
[13:18:59.316]  elements: ‘...’
[13:18:59.316]  length: 0 (resolved future 1)
[13:18:59.316] resolve() on list ... DONE
[13:18:59.316]    - '...' content: [n=0] 
[13:18:59.316] List of 1
[13:18:59.316]  $ ...: list()
[13:18:59.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.316]  - attr(*, "where")=List of 1
[13:18:59.316]   ..$ ...:<environment: 0x555f79ef8c18> 
[13:18:59.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.316]  - attr(*, "resolved")= logi TRUE
[13:18:59.316]  - attr(*, "total_size")= num NA
[13:18:59.321]  - Getting '...' globals ... DONE
[13:18:59.321] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:59.322] List of 8
[13:18:59.322]  $ ...future.FUN:function (x, ...)  
[13:18:59.322]  $ x_FUN        :function (x, ...)  
[13:18:59.322]  $ times        : int 5
[13:18:59.322]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.322]  $ stop_if_not  :function (...)  
[13:18:59.322]  $ dim          : NULL
[13:18:59.322]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:59.322]  $ ...          : list()
[13:18:59.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.322]  - attr(*, "where")=List of 8
[13:18:59.322]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:59.322]   ..$ ...          :<environment: 0x555f79ef8c18> 
[13:18:59.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.322]  - attr(*, "resolved")= logi FALSE
[13:18:59.322]  - attr(*, "total_size")= num 95528
[13:18:59.327] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:18:59.327] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.327] Number of futures (= number of chunks): 2
[13:18:59.328] Launching 2 futures (chunks) ...
[13:18:59.328] Chunk #1 of 2 ...
[13:18:59.328]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.328] getGlobalsAndPackages() ...
[13:18:59.328] Searching for globals...
[13:18:59.328] 
[13:18:59.328] Searching for globals ... DONE
[13:18:59.328] - globals: [0] <none>
[13:18:59.329] getGlobalsAndPackages() ... DONE
[13:18:59.329]    + additional globals found: [n=0] 
[13:18:59.329]    + additional namespaces needed: [n=0] 
[13:18:59.329]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.329]  - seeds: <none>
[13:18:59.329] getGlobalsAndPackages() ...
[13:18:59.329] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.329] Resolving globals: FALSE
[13:18:59.329] Tweak future expression to call with '...' arguments ...
[13:18:59.329] {
[13:18:59.329]     do.call(function(...) {
[13:18:59.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.329]             on.exit(options(oopts), add = TRUE)
[13:18:59.329]         }
[13:18:59.329]         {
[13:18:59.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.329]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.329]             })
[13:18:59.329]         }
[13:18:59.329]     }, args = future.call.arguments)
[13:18:59.329] }
[13:18:59.330] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.330] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.330] - packages: [2] ‘stats’, ‘future.apply’
[13:18:59.330] getGlobalsAndPackages() ... DONE
[13:18:59.331] run() for ‘Future’ ...
[13:18:59.331] - state: ‘created’
[13:18:59.331] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.335] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.335] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.335]   - Field: ‘label’
[13:18:59.335]   - Field: ‘local’
[13:18:59.335]   - Field: ‘owner’
[13:18:59.335]   - Field: ‘envir’
[13:18:59.335]   - Field: ‘workers’
[13:18:59.335]   - Field: ‘packages’
[13:18:59.336]   - Field: ‘gc’
[13:18:59.336]   - Field: ‘job’
[13:18:59.336]   - Field: ‘conditions’
[13:18:59.336]   - Field: ‘expr’
[13:18:59.336]   - Field: ‘uuid’
[13:18:59.336]   - Field: ‘seed’
[13:18:59.336]   - Field: ‘version’
[13:18:59.336]   - Field: ‘result’
[13:18:59.336]   - Field: ‘asynchronous’
[13:18:59.336]   - Field: ‘calls’
[13:18:59.337]   - Field: ‘globals’
[13:18:59.337]   - Field: ‘stdout’
[13:18:59.337]   - Field: ‘earlySignal’
[13:18:59.337]   - Field: ‘lazy’
[13:18:59.337]   - Field: ‘state’
[13:18:59.337] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.337] - Launch lazy future ...
[13:18:59.337] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:18:59.338] Packages needed by future strategies (n = 0): <none>
[13:18:59.338] {
[13:18:59.338]     {
[13:18:59.338]         {
[13:18:59.338]             ...future.startTime <- base::Sys.time()
[13:18:59.338]             {
[13:18:59.338]                 {
[13:18:59.338]                   {
[13:18:59.338]                     {
[13:18:59.338]                       {
[13:18:59.338]                         base::local({
[13:18:59.338]                           has_future <- base::requireNamespace("future", 
[13:18:59.338]                             quietly = TRUE)
[13:18:59.338]                           if (has_future) {
[13:18:59.338]                             ns <- base::getNamespace("future")
[13:18:59.338]                             version <- ns[[".package"]][["version"]]
[13:18:59.338]                             if (is.null(version)) 
[13:18:59.338]                               version <- utils::packageVersion("future")
[13:18:59.338]                           }
[13:18:59.338]                           else {
[13:18:59.338]                             version <- NULL
[13:18:59.338]                           }
[13:18:59.338]                           if (!has_future || version < "1.8.0") {
[13:18:59.338]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.338]                               "", base::R.version$version.string), 
[13:18:59.338]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.338]                                 base::R.version$platform, 8 * 
[13:18:59.338]                                   base::.Machine$sizeof.pointer), 
[13:18:59.338]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.338]                                 "release", "version")], collapse = " "), 
[13:18:59.338]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.338]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.338]                               info)
[13:18:59.338]                             info <- base::paste(info, collapse = "; ")
[13:18:59.338]                             if (!has_future) {
[13:18:59.338]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.338]                                 info)
[13:18:59.338]                             }
[13:18:59.338]                             else {
[13:18:59.338]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.338]                                 info, version)
[13:18:59.338]                             }
[13:18:59.338]                             base::stop(msg)
[13:18:59.338]                           }
[13:18:59.338]                         })
[13:18:59.338]                       }
[13:18:59.338]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.338]                       base::options(mc.cores = 1L)
[13:18:59.338]                     }
[13:18:59.338]                     base::local({
[13:18:59.338]                       for (pkg in c("stats", "future.apply")) {
[13:18:59.338]                         base::loadNamespace(pkg)
[13:18:59.338]                         base::library(pkg, character.only = TRUE)
[13:18:59.338]                       }
[13:18:59.338]                     })
[13:18:59.338]                   }
[13:18:59.338]                   options(future.plan = NULL)
[13:18:59.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.338]                 }
[13:18:59.338]                 ...future.workdir <- getwd()
[13:18:59.338]             }
[13:18:59.338]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.338]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.338]         }
[13:18:59.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:18:59.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.338]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.338]             base::names(...future.oldOptions))
[13:18:59.338]     }
[13:18:59.338]     if (FALSE) {
[13:18:59.338]     }
[13:18:59.338]     else {
[13:18:59.338]         if (TRUE) {
[13:18:59.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.338]                 open = "w")
[13:18:59.338]         }
[13:18:59.338]         else {
[13:18:59.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.338]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.338]         }
[13:18:59.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.338]             base::sink(type = "output", split = FALSE)
[13:18:59.338]             base::close(...future.stdout)
[13:18:59.338]         }, add = TRUE)
[13:18:59.338]     }
[13:18:59.338]     ...future.frame <- base::sys.nframe()
[13:18:59.338]     ...future.conditions <- base::list()
[13:18:59.338]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.338]     if (FALSE) {
[13:18:59.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.338]     }
[13:18:59.338]     ...future.result <- base::tryCatch({
[13:18:59.338]         base::withCallingHandlers({
[13:18:59.338]             ...future.value <- base::withVisible(base::local({
[13:18:59.338]                 withCallingHandlers({
[13:18:59.338]                   {
[13:18:59.338]                     do.call(function(...) {
[13:18:59.338]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.338]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.338]                         ...future.globals.maxSize)) {
[13:18:59.338]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.338]                         on.exit(options(oopts), add = TRUE)
[13:18:59.338]                       }
[13:18:59.338]                       {
[13:18:59.338]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.338]                           FUN = function(jj) {
[13:18:59.338]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.338]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.338]                           })
[13:18:59.338]                       }
[13:18:59.338]                     }, args = future.call.arguments)
[13:18:59.338]                   }
[13:18:59.338]                 }, immediateCondition = function(cond) {
[13:18:59.338]                   save_rds <- function (object, pathname, ...) 
[13:18:59.338]                   {
[13:18:59.338]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.338]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.338]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.338]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.338]                         fi_tmp[["mtime"]])
[13:18:59.338]                     }
[13:18:59.338]                     tryCatch({
[13:18:59.338]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.338]                     }, error = function(ex) {
[13:18:59.338]                       msg <- conditionMessage(ex)
[13:18:59.338]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.338]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.338]                         fi_tmp[["mtime"]], msg)
[13:18:59.338]                       ex$message <- msg
[13:18:59.338]                       stop(ex)
[13:18:59.338]                     })
[13:18:59.338]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.338]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.338]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.338]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.338]                       fi <- file.info(pathname)
[13:18:59.338]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.338]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.338]                         fi[["size"]], fi[["mtime"]])
[13:18:59.338]                       stop(msg)
[13:18:59.338]                     }
[13:18:59.338]                     invisible(pathname)
[13:18:59.338]                   }
[13:18:59.338]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.338]                     rootPath = tempdir()) 
[13:18:59.338]                   {
[13:18:59.338]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.338]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.338]                       tmpdir = path, fileext = ".rds")
[13:18:59.338]                     save_rds(obj, file)
[13:18:59.338]                   }
[13:18:59.338]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.338]                   {
[13:18:59.338]                     inherits <- base::inherits
[13:18:59.338]                     invokeRestart <- base::invokeRestart
[13:18:59.338]                     is.null <- base::is.null
[13:18:59.338]                     muffled <- FALSE
[13:18:59.338]                     if (inherits(cond, "message")) {
[13:18:59.338]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.338]                       if (muffled) 
[13:18:59.338]                         invokeRestart("muffleMessage")
[13:18:59.338]                     }
[13:18:59.338]                     else if (inherits(cond, "warning")) {
[13:18:59.338]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.338]                       if (muffled) 
[13:18:59.338]                         invokeRestart("muffleWarning")
[13:18:59.338]                     }
[13:18:59.338]                     else if (inherits(cond, "condition")) {
[13:18:59.338]                       if (!is.null(pattern)) {
[13:18:59.338]                         computeRestarts <- base::computeRestarts
[13:18:59.338]                         grepl <- base::grepl
[13:18:59.338]                         restarts <- computeRestarts(cond)
[13:18:59.338]                         for (restart in restarts) {
[13:18:59.338]                           name <- restart$name
[13:18:59.338]                           if (is.null(name)) 
[13:18:59.338]                             next
[13:18:59.338]                           if (!grepl(pattern, name)) 
[13:18:59.338]                             next
[13:18:59.338]                           invokeRestart(restart)
[13:18:59.338]                           muffled <- TRUE
[13:18:59.338]                           break
[13:18:59.338]                         }
[13:18:59.338]                       }
[13:18:59.338]                     }
[13:18:59.338]                     invisible(muffled)
[13:18:59.338]                   }
[13:18:59.338]                   muffleCondition(cond)
[13:18:59.338]                 })
[13:18:59.338]             }))
[13:18:59.338]             future::FutureResult(value = ...future.value$value, 
[13:18:59.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.338]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.338]                     ...future.globalenv.names))
[13:18:59.338]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.338]         }, condition = base::local({
[13:18:59.338]             c <- base::c
[13:18:59.338]             inherits <- base::inherits
[13:18:59.338]             invokeRestart <- base::invokeRestart
[13:18:59.338]             length <- base::length
[13:18:59.338]             list <- base::list
[13:18:59.338]             seq.int <- base::seq.int
[13:18:59.338]             signalCondition <- base::signalCondition
[13:18:59.338]             sys.calls <- base::sys.calls
[13:18:59.338]             `[[` <- base::`[[`
[13:18:59.338]             `+` <- base::`+`
[13:18:59.338]             `<<-` <- base::`<<-`
[13:18:59.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.338]                   3L)]
[13:18:59.338]             }
[13:18:59.338]             function(cond) {
[13:18:59.338]                 is_error <- inherits(cond, "error")
[13:18:59.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.338]                   NULL)
[13:18:59.338]                 if (is_error) {
[13:18:59.338]                   sessionInformation <- function() {
[13:18:59.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.338]                       search = base::search(), system = base::Sys.info())
[13:18:59.338]                   }
[13:18:59.338]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.338]                     cond$call), session = sessionInformation(), 
[13:18:59.338]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.338]                   signalCondition(cond)
[13:18:59.338]                 }
[13:18:59.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.338]                 "immediateCondition"))) {
[13:18:59.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.338]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.338]                   if (TRUE && !signal) {
[13:18:59.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.338]                     {
[13:18:59.338]                       inherits <- base::inherits
[13:18:59.338]                       invokeRestart <- base::invokeRestart
[13:18:59.338]                       is.null <- base::is.null
[13:18:59.338]                       muffled <- FALSE
[13:18:59.338]                       if (inherits(cond, "message")) {
[13:18:59.338]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.338]                         if (muffled) 
[13:18:59.338]                           invokeRestart("muffleMessage")
[13:18:59.338]                       }
[13:18:59.338]                       else if (inherits(cond, "warning")) {
[13:18:59.338]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.338]                         if (muffled) 
[13:18:59.338]                           invokeRestart("muffleWarning")
[13:18:59.338]                       }
[13:18:59.338]                       else if (inherits(cond, "condition")) {
[13:18:59.338]                         if (!is.null(pattern)) {
[13:18:59.338]                           computeRestarts <- base::computeRestarts
[13:18:59.338]                           grepl <- base::grepl
[13:18:59.338]                           restarts <- computeRestarts(cond)
[13:18:59.338]                           for (restart in restarts) {
[13:18:59.338]                             name <- restart$name
[13:18:59.338]                             if (is.null(name)) 
[13:18:59.338]                               next
[13:18:59.338]                             if (!grepl(pattern, name)) 
[13:18:59.338]                               next
[13:18:59.338]                             invokeRestart(restart)
[13:18:59.338]                             muffled <- TRUE
[13:18:59.338]                             break
[13:18:59.338]                           }
[13:18:59.338]                         }
[13:18:59.338]                       }
[13:18:59.338]                       invisible(muffled)
[13:18:59.338]                     }
[13:18:59.338]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.338]                   }
[13:18:59.338]                 }
[13:18:59.338]                 else {
[13:18:59.338]                   if (TRUE) {
[13:18:59.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.338]                     {
[13:18:59.338]                       inherits <- base::inherits
[13:18:59.338]                       invokeRestart <- base::invokeRestart
[13:18:59.338]                       is.null <- base::is.null
[13:18:59.338]                       muffled <- FALSE
[13:18:59.338]                       if (inherits(cond, "message")) {
[13:18:59.338]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.338]                         if (muffled) 
[13:18:59.338]                           invokeRestart("muffleMessage")
[13:18:59.338]                       }
[13:18:59.338]                       else if (inherits(cond, "warning")) {
[13:18:59.338]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.338]                         if (muffled) 
[13:18:59.338]                           invokeRestart("muffleWarning")
[13:18:59.338]                       }
[13:18:59.338]                       else if (inherits(cond, "condition")) {
[13:18:59.338]                         if (!is.null(pattern)) {
[13:18:59.338]                           computeRestarts <- base::computeRestarts
[13:18:59.338]                           grepl <- base::grepl
[13:18:59.338]                           restarts <- computeRestarts(cond)
[13:18:59.338]                           for (restart in restarts) {
[13:18:59.338]                             name <- restart$name
[13:18:59.338]                             if (is.null(name)) 
[13:18:59.338]                               next
[13:18:59.338]                             if (!grepl(pattern, name)) 
[13:18:59.338]                               next
[13:18:59.338]                             invokeRestart(restart)
[13:18:59.338]                             muffled <- TRUE
[13:18:59.338]                             break
[13:18:59.338]                           }
[13:18:59.338]                         }
[13:18:59.338]                       }
[13:18:59.338]                       invisible(muffled)
[13:18:59.338]                     }
[13:18:59.338]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.338]                   }
[13:18:59.338]                 }
[13:18:59.338]             }
[13:18:59.338]         }))
[13:18:59.338]     }, error = function(ex) {
[13:18:59.338]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.338]                 ...future.rng), started = ...future.startTime, 
[13:18:59.338]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.338]             version = "1.8"), class = "FutureResult")
[13:18:59.338]     }, finally = {
[13:18:59.338]         if (!identical(...future.workdir, getwd())) 
[13:18:59.338]             setwd(...future.workdir)
[13:18:59.338]         {
[13:18:59.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.338]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.338]             }
[13:18:59.338]             base::options(...future.oldOptions)
[13:18:59.338]             if (.Platform$OS.type == "windows") {
[13:18:59.338]                 old_names <- names(...future.oldEnvVars)
[13:18:59.338]                 envs <- base::Sys.getenv()
[13:18:59.338]                 names <- names(envs)
[13:18:59.338]                 common <- intersect(names, old_names)
[13:18:59.338]                 added <- setdiff(names, old_names)
[13:18:59.338]                 removed <- setdiff(old_names, names)
[13:18:59.338]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.338]                   envs[common]]
[13:18:59.338]                 NAMES <- toupper(changed)
[13:18:59.338]                 args <- list()
[13:18:59.338]                 for (kk in seq_along(NAMES)) {
[13:18:59.338]                   name <- changed[[kk]]
[13:18:59.338]                   NAME <- NAMES[[kk]]
[13:18:59.338]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.338]                     next
[13:18:59.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.338]                 }
[13:18:59.338]                 NAMES <- toupper(added)
[13:18:59.338]                 for (kk in seq_along(NAMES)) {
[13:18:59.338]                   name <- added[[kk]]
[13:18:59.338]                   NAME <- NAMES[[kk]]
[13:18:59.338]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.338]                     next
[13:18:59.338]                   args[[name]] <- ""
[13:18:59.338]                 }
[13:18:59.338]                 NAMES <- toupper(removed)
[13:18:59.338]                 for (kk in seq_along(NAMES)) {
[13:18:59.338]                   name <- removed[[kk]]
[13:18:59.338]                   NAME <- NAMES[[kk]]
[13:18:59.338]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.338]                     next
[13:18:59.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.338]                 }
[13:18:59.338]                 if (length(args) > 0) 
[13:18:59.338]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.338]             }
[13:18:59.338]             else {
[13:18:59.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.338]             }
[13:18:59.338]             {
[13:18:59.338]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.338]                   0L) {
[13:18:59.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.338]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.338]                   base::options(opts)
[13:18:59.338]                 }
[13:18:59.338]                 {
[13:18:59.338]                   {
[13:18:59.338]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.338]                     NULL
[13:18:59.338]                   }
[13:18:59.338]                   options(future.plan = NULL)
[13:18:59.338]                   if (is.na(NA_character_)) 
[13:18:59.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.338]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.338]                     envir = parent.frame()) 
[13:18:59.338]                   {
[13:18:59.338]                     default_workers <- missing(workers)
[13:18:59.338]                     if (is.function(workers)) 
[13:18:59.338]                       workers <- workers()
[13:18:59.338]                     workers <- structure(as.integer(workers), 
[13:18:59.338]                       class = class(workers))
[13:18:59.338]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.338]                       1L)
[13:18:59.338]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.338]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.338]                       if (default_workers) 
[13:18:59.338]                         supportsMulticore(warn = TRUE)
[13:18:59.338]                       return(sequential(..., envir = envir))
[13:18:59.338]                     }
[13:18:59.338]                     oopts <- options(mc.cores = workers)
[13:18:59.338]                     on.exit(options(oopts))
[13:18:59.338]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.338]                       envir = envir)
[13:18:59.338]                     if (!future$lazy) 
[13:18:59.338]                       future <- run(future)
[13:18:59.338]                     invisible(future)
[13:18:59.338]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.338]                 }
[13:18:59.338]             }
[13:18:59.338]         }
[13:18:59.338]     })
[13:18:59.338]     if (TRUE) {
[13:18:59.338]         base::sink(type = "output", split = FALSE)
[13:18:59.338]         if (TRUE) {
[13:18:59.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.338]         }
[13:18:59.338]         else {
[13:18:59.338]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.338]         }
[13:18:59.338]         base::close(...future.stdout)
[13:18:59.338]         ...future.stdout <- NULL
[13:18:59.338]     }
[13:18:59.338]     ...future.result$conditions <- ...future.conditions
[13:18:59.338]     ...future.result$finished <- base::Sys.time()
[13:18:59.338]     ...future.result
[13:18:59.338] }
[13:18:59.341] assign_globals() ...
[13:18:59.341] List of 11
[13:18:59.341]  $ ...future.FUN            :function (x, ...)  
[13:18:59.341]  $ x_FUN                    :function (x, ...)  
[13:18:59.341]  $ times                    : int 5
[13:18:59.341]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.341]  $ stop_if_not              :function (...)  
[13:18:59.341]  $ dim                      : NULL
[13:18:59.341]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.341]  $ future.call.arguments    : list()
[13:18:59.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.341]  $ ...future.elements_ii    :List of 1
[13:18:59.341]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:18:59.341]  $ ...future.seeds_ii       : NULL
[13:18:59.341]  $ ...future.globals.maxSize: NULL
[13:18:59.341]  - attr(*, "where")=List of 11
[13:18:59.341]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.341]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.341]  - attr(*, "resolved")= logi FALSE
[13:18:59.341]  - attr(*, "total_size")= num 95528
[13:18:59.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.341]  - attr(*, "already-done")= logi TRUE
[13:18:59.351] - copied ‘...future.FUN’ to environment
[13:18:59.351] - copied ‘x_FUN’ to environment
[13:18:59.351] - copied ‘times’ to environment
[13:18:59.351] - copied ‘stopf’ to environment
[13:18:59.352] - copied ‘stop_if_not’ to environment
[13:18:59.352] - copied ‘dim’ to environment
[13:18:59.352] - copied ‘valid_types’ to environment
[13:18:59.352] - copied ‘future.call.arguments’ to environment
[13:18:59.352] - copied ‘...future.elements_ii’ to environment
[13:18:59.352] - copied ‘...future.seeds_ii’ to environment
[13:18:59.352] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.352] assign_globals() ... done
[13:18:59.352] requestCore(): workers = 2
[13:18:59.355] MulticoreFuture started
[13:18:59.355] - Launch lazy future ... done
[13:18:59.355] run() for ‘MulticoreFuture’ ... done
[13:18:59.356] Created future:
[13:18:59.356] plan(): Setting new future strategy stack:
[13:18:59.356] List of future strategies:
[13:18:59.356] 1. sequential:
[13:18:59.356]    - args: function (..., envir = parent.frame())
[13:18:59.356]    - tweaked: FALSE
[13:18:59.356]    - call: NULL
[13:18:59.357] plan(): nbrOfWorkers() = 1
[13:18:59.360] plan(): Setting new future strategy stack:
[13:18:59.360] List of future strategies:
[13:18:59.360] 1. multicore:
[13:18:59.360]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.360]    - tweaked: FALSE
[13:18:59.360]    - call: plan(strategy)
[13:18:59.365] plan(): nbrOfWorkers() = 2
[13:18:59.356] MulticoreFuture:
[13:18:59.356] Label: ‘future_vapply-1’
[13:18:59.356] Expression:
[13:18:59.356] {
[13:18:59.356]     do.call(function(...) {
[13:18:59.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.356]             on.exit(options(oopts), add = TRUE)
[13:18:59.356]         }
[13:18:59.356]         {
[13:18:59.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.356]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.356]             })
[13:18:59.356]         }
[13:18:59.356]     }, args = future.call.arguments)
[13:18:59.356] }
[13:18:59.356] Lazy evaluation: FALSE
[13:18:59.356] Asynchronous evaluation: TRUE
[13:18:59.356] Local evaluation: TRUE
[13:18:59.356] Environment: R_GlobalEnv
[13:18:59.356] Capture standard output: TRUE
[13:18:59.356] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.356] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.356] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:18:59.356] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.356] Resolved: TRUE
[13:18:59.356] Value: <not collected>
[13:18:59.356] Conditions captured: <none>
[13:18:59.356] Early signaling: FALSE
[13:18:59.356] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.356] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.366] Chunk #1 of 2 ... DONE
[13:18:59.367] Chunk #2 of 2 ...
[13:18:59.367]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.367] getGlobalsAndPackages() ...
[13:18:59.367] Searching for globals...
[13:18:59.368] 
[13:18:59.368] Searching for globals ... DONE
[13:18:59.368] - globals: [0] <none>
[13:18:59.368] getGlobalsAndPackages() ... DONE
[13:18:59.368]    + additional globals found: [n=0] 
[13:18:59.368]    + additional namespaces needed: [n=0] 
[13:18:59.368]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.369]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:18:59.369]  - seeds: <none>
[13:18:59.369] getGlobalsAndPackages() ...
[13:18:59.369] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.369] Resolving globals: FALSE
[13:18:59.369] Tweak future expression to call with '...' arguments ...
[13:18:59.370] {
[13:18:59.370]     do.call(function(...) {
[13:18:59.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.370]             on.exit(options(oopts), add = TRUE)
[13:18:59.370]         }
[13:18:59.370]         {
[13:18:59.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.370]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.370]             })
[13:18:59.370]         }
[13:18:59.370]     }, args = future.call.arguments)
[13:18:59.370] }
[13:18:59.370] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.371] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.371] - packages: [2] ‘stats’, ‘future.apply’
[13:18:59.371] getGlobalsAndPackages() ... DONE
[13:18:59.372] run() for ‘Future’ ...
[13:18:59.372] - state: ‘created’
[13:18:59.372] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.377] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.377]   - Field: ‘label’
[13:18:59.377]   - Field: ‘local’
[13:18:59.377]   - Field: ‘owner’
[13:18:59.378]   - Field: ‘envir’
[13:18:59.378]   - Field: ‘workers’
[13:18:59.378]   - Field: ‘packages’
[13:18:59.378]   - Field: ‘gc’
[13:18:59.378]   - Field: ‘job’
[13:18:59.378]   - Field: ‘conditions’
[13:18:59.379]   - Field: ‘expr’
[13:18:59.379]   - Field: ‘uuid’
[13:18:59.379]   - Field: ‘seed’
[13:18:59.379]   - Field: ‘version’
[13:18:59.379]   - Field: ‘result’
[13:18:59.379]   - Field: ‘asynchronous’
[13:18:59.379]   - Field: ‘calls’
[13:18:59.380]   - Field: ‘globals’
[13:18:59.380]   - Field: ‘stdout’
[13:18:59.380]   - Field: ‘earlySignal’
[13:18:59.380]   - Field: ‘lazy’
[13:18:59.380]   - Field: ‘state’
[13:18:59.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.381] - Launch lazy future ...
[13:18:59.381] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:18:59.381] Packages needed by future strategies (n = 0): <none>
[13:18:59.385] {
[13:18:59.385]     {
[13:18:59.385]         {
[13:18:59.385]             ...future.startTime <- base::Sys.time()
[13:18:59.385]             {
[13:18:59.385]                 {
[13:18:59.385]                   {
[13:18:59.385]                     {
[13:18:59.385]                       {
[13:18:59.385]                         base::local({
[13:18:59.385]                           has_future <- base::requireNamespace("future", 
[13:18:59.385]                             quietly = TRUE)
[13:18:59.385]                           if (has_future) {
[13:18:59.385]                             ns <- base::getNamespace("future")
[13:18:59.385]                             version <- ns[[".package"]][["version"]]
[13:18:59.385]                             if (is.null(version)) 
[13:18:59.385]                               version <- utils::packageVersion("future")
[13:18:59.385]                           }
[13:18:59.385]                           else {
[13:18:59.385]                             version <- NULL
[13:18:59.385]                           }
[13:18:59.385]                           if (!has_future || version < "1.8.0") {
[13:18:59.385]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.385]                               "", base::R.version$version.string), 
[13:18:59.385]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.385]                                 base::R.version$platform, 8 * 
[13:18:59.385]                                   base::.Machine$sizeof.pointer), 
[13:18:59.385]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.385]                                 "release", "version")], collapse = " "), 
[13:18:59.385]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.385]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.385]                               info)
[13:18:59.385]                             info <- base::paste(info, collapse = "; ")
[13:18:59.385]                             if (!has_future) {
[13:18:59.385]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.385]                                 info)
[13:18:59.385]                             }
[13:18:59.385]                             else {
[13:18:59.385]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.385]                                 info, version)
[13:18:59.385]                             }
[13:18:59.385]                             base::stop(msg)
[13:18:59.385]                           }
[13:18:59.385]                         })
[13:18:59.385]                       }
[13:18:59.385]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.385]                       base::options(mc.cores = 1L)
[13:18:59.385]                     }
[13:18:59.385]                     base::local({
[13:18:59.385]                       for (pkg in c("stats", "future.apply")) {
[13:18:59.385]                         base::loadNamespace(pkg)
[13:18:59.385]                         base::library(pkg, character.only = TRUE)
[13:18:59.385]                       }
[13:18:59.385]                     })
[13:18:59.385]                   }
[13:18:59.385]                   options(future.plan = NULL)
[13:18:59.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.385]                 }
[13:18:59.385]                 ...future.workdir <- getwd()
[13:18:59.385]             }
[13:18:59.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.385]         }
[13:18:59.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.385]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:18:59.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.385]             base::names(...future.oldOptions))
[13:18:59.385]     }
[13:18:59.385]     if (FALSE) {
[13:18:59.385]     }
[13:18:59.385]     else {
[13:18:59.385]         if (TRUE) {
[13:18:59.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.385]                 open = "w")
[13:18:59.385]         }
[13:18:59.385]         else {
[13:18:59.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.385]         }
[13:18:59.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.385]             base::sink(type = "output", split = FALSE)
[13:18:59.385]             base::close(...future.stdout)
[13:18:59.385]         }, add = TRUE)
[13:18:59.385]     }
[13:18:59.385]     ...future.frame <- base::sys.nframe()
[13:18:59.385]     ...future.conditions <- base::list()
[13:18:59.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.385]     if (FALSE) {
[13:18:59.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.385]     }
[13:18:59.385]     ...future.result <- base::tryCatch({
[13:18:59.385]         base::withCallingHandlers({
[13:18:59.385]             ...future.value <- base::withVisible(base::local({
[13:18:59.385]                 withCallingHandlers({
[13:18:59.385]                   {
[13:18:59.385]                     do.call(function(...) {
[13:18:59.385]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.385]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.385]                         ...future.globals.maxSize)) {
[13:18:59.385]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.385]                         on.exit(options(oopts), add = TRUE)
[13:18:59.385]                       }
[13:18:59.385]                       {
[13:18:59.385]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.385]                           FUN = function(jj) {
[13:18:59.385]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.385]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.385]                           })
[13:18:59.385]                       }
[13:18:59.385]                     }, args = future.call.arguments)
[13:18:59.385]                   }
[13:18:59.385]                 }, immediateCondition = function(cond) {
[13:18:59.385]                   save_rds <- function (object, pathname, ...) 
[13:18:59.385]                   {
[13:18:59.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.385]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.385]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.385]                         fi_tmp[["mtime"]])
[13:18:59.385]                     }
[13:18:59.385]                     tryCatch({
[13:18:59.385]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.385]                     }, error = function(ex) {
[13:18:59.385]                       msg <- conditionMessage(ex)
[13:18:59.385]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.385]                         fi_tmp[["mtime"]], msg)
[13:18:59.385]                       ex$message <- msg
[13:18:59.385]                       stop(ex)
[13:18:59.385]                     })
[13:18:59.385]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.385]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.385]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.385]                       fi <- file.info(pathname)
[13:18:59.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.385]                         fi[["size"]], fi[["mtime"]])
[13:18:59.385]                       stop(msg)
[13:18:59.385]                     }
[13:18:59.385]                     invisible(pathname)
[13:18:59.385]                   }
[13:18:59.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.385]                     rootPath = tempdir()) 
[13:18:59.385]                   {
[13:18:59.385]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.385]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.385]                       tmpdir = path, fileext = ".rds")
[13:18:59.385]                     save_rds(obj, file)
[13:18:59.385]                   }
[13:18:59.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.385]                   {
[13:18:59.385]                     inherits <- base::inherits
[13:18:59.385]                     invokeRestart <- base::invokeRestart
[13:18:59.385]                     is.null <- base::is.null
[13:18:59.385]                     muffled <- FALSE
[13:18:59.385]                     if (inherits(cond, "message")) {
[13:18:59.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.385]                       if (muffled) 
[13:18:59.385]                         invokeRestart("muffleMessage")
[13:18:59.385]                     }
[13:18:59.385]                     else if (inherits(cond, "warning")) {
[13:18:59.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.385]                       if (muffled) 
[13:18:59.385]                         invokeRestart("muffleWarning")
[13:18:59.385]                     }
[13:18:59.385]                     else if (inherits(cond, "condition")) {
[13:18:59.385]                       if (!is.null(pattern)) {
[13:18:59.385]                         computeRestarts <- base::computeRestarts
[13:18:59.385]                         grepl <- base::grepl
[13:18:59.385]                         restarts <- computeRestarts(cond)
[13:18:59.385]                         for (restart in restarts) {
[13:18:59.385]                           name <- restart$name
[13:18:59.385]                           if (is.null(name)) 
[13:18:59.385]                             next
[13:18:59.385]                           if (!grepl(pattern, name)) 
[13:18:59.385]                             next
[13:18:59.385]                           invokeRestart(restart)
[13:18:59.385]                           muffled <- TRUE
[13:18:59.385]                           break
[13:18:59.385]                         }
[13:18:59.385]                       }
[13:18:59.385]                     }
[13:18:59.385]                     invisible(muffled)
[13:18:59.385]                   }
[13:18:59.385]                   muffleCondition(cond)
[13:18:59.385]                 })
[13:18:59.385]             }))
[13:18:59.385]             future::FutureResult(value = ...future.value$value, 
[13:18:59.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.385]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.385]                     ...future.globalenv.names))
[13:18:59.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.385]         }, condition = base::local({
[13:18:59.385]             c <- base::c
[13:18:59.385]             inherits <- base::inherits
[13:18:59.385]             invokeRestart <- base::invokeRestart
[13:18:59.385]             length <- base::length
[13:18:59.385]             list <- base::list
[13:18:59.385]             seq.int <- base::seq.int
[13:18:59.385]             signalCondition <- base::signalCondition
[13:18:59.385]             sys.calls <- base::sys.calls
[13:18:59.385]             `[[` <- base::`[[`
[13:18:59.385]             `+` <- base::`+`
[13:18:59.385]             `<<-` <- base::`<<-`
[13:18:59.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.385]                   3L)]
[13:18:59.385]             }
[13:18:59.385]             function(cond) {
[13:18:59.385]                 is_error <- inherits(cond, "error")
[13:18:59.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.385]                   NULL)
[13:18:59.385]                 if (is_error) {
[13:18:59.385]                   sessionInformation <- function() {
[13:18:59.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.385]                       search = base::search(), system = base::Sys.info())
[13:18:59.385]                   }
[13:18:59.385]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.385]                     cond$call), session = sessionInformation(), 
[13:18:59.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.385]                   signalCondition(cond)
[13:18:59.385]                 }
[13:18:59.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.385]                 "immediateCondition"))) {
[13:18:59.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.385]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.385]                   if (TRUE && !signal) {
[13:18:59.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.385]                     {
[13:18:59.385]                       inherits <- base::inherits
[13:18:59.385]                       invokeRestart <- base::invokeRestart
[13:18:59.385]                       is.null <- base::is.null
[13:18:59.385]                       muffled <- FALSE
[13:18:59.385]                       if (inherits(cond, "message")) {
[13:18:59.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.385]                         if (muffled) 
[13:18:59.385]                           invokeRestart("muffleMessage")
[13:18:59.385]                       }
[13:18:59.385]                       else if (inherits(cond, "warning")) {
[13:18:59.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.385]                         if (muffled) 
[13:18:59.385]                           invokeRestart("muffleWarning")
[13:18:59.385]                       }
[13:18:59.385]                       else if (inherits(cond, "condition")) {
[13:18:59.385]                         if (!is.null(pattern)) {
[13:18:59.385]                           computeRestarts <- base::computeRestarts
[13:18:59.385]                           grepl <- base::grepl
[13:18:59.385]                           restarts <- computeRestarts(cond)
[13:18:59.385]                           for (restart in restarts) {
[13:18:59.385]                             name <- restart$name
[13:18:59.385]                             if (is.null(name)) 
[13:18:59.385]                               next
[13:18:59.385]                             if (!grepl(pattern, name)) 
[13:18:59.385]                               next
[13:18:59.385]                             invokeRestart(restart)
[13:18:59.385]                             muffled <- TRUE
[13:18:59.385]                             break
[13:18:59.385]                           }
[13:18:59.385]                         }
[13:18:59.385]                       }
[13:18:59.385]                       invisible(muffled)
[13:18:59.385]                     }
[13:18:59.385]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.385]                   }
[13:18:59.385]                 }
[13:18:59.385]                 else {
[13:18:59.385]                   if (TRUE) {
[13:18:59.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.385]                     {
[13:18:59.385]                       inherits <- base::inherits
[13:18:59.385]                       invokeRestart <- base::invokeRestart
[13:18:59.385]                       is.null <- base::is.null
[13:18:59.385]                       muffled <- FALSE
[13:18:59.385]                       if (inherits(cond, "message")) {
[13:18:59.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.385]                         if (muffled) 
[13:18:59.385]                           invokeRestart("muffleMessage")
[13:18:59.385]                       }
[13:18:59.385]                       else if (inherits(cond, "warning")) {
[13:18:59.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.385]                         if (muffled) 
[13:18:59.385]                           invokeRestart("muffleWarning")
[13:18:59.385]                       }
[13:18:59.385]                       else if (inherits(cond, "condition")) {
[13:18:59.385]                         if (!is.null(pattern)) {
[13:18:59.385]                           computeRestarts <- base::computeRestarts
[13:18:59.385]                           grepl <- base::grepl
[13:18:59.385]                           restarts <- computeRestarts(cond)
[13:18:59.385]                           for (restart in restarts) {
[13:18:59.385]                             name <- restart$name
[13:18:59.385]                             if (is.null(name)) 
[13:18:59.385]                               next
[13:18:59.385]                             if (!grepl(pattern, name)) 
[13:18:59.385]                               next
[13:18:59.385]                             invokeRestart(restart)
[13:18:59.385]                             muffled <- TRUE
[13:18:59.385]                             break
[13:18:59.385]                           }
[13:18:59.385]                         }
[13:18:59.385]                       }
[13:18:59.385]                       invisible(muffled)
[13:18:59.385]                     }
[13:18:59.385]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.385]                   }
[13:18:59.385]                 }
[13:18:59.385]             }
[13:18:59.385]         }))
[13:18:59.385]     }, error = function(ex) {
[13:18:59.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.385]                 ...future.rng), started = ...future.startTime, 
[13:18:59.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.385]             version = "1.8"), class = "FutureResult")
[13:18:59.385]     }, finally = {
[13:18:59.385]         if (!identical(...future.workdir, getwd())) 
[13:18:59.385]             setwd(...future.workdir)
[13:18:59.385]         {
[13:18:59.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.385]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.385]             }
[13:18:59.385]             base::options(...future.oldOptions)
[13:18:59.385]             if (.Platform$OS.type == "windows") {
[13:18:59.385]                 old_names <- names(...future.oldEnvVars)
[13:18:59.385]                 envs <- base::Sys.getenv()
[13:18:59.385]                 names <- names(envs)
[13:18:59.385]                 common <- intersect(names, old_names)
[13:18:59.385]                 added <- setdiff(names, old_names)
[13:18:59.385]                 removed <- setdiff(old_names, names)
[13:18:59.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.385]                   envs[common]]
[13:18:59.385]                 NAMES <- toupper(changed)
[13:18:59.385]                 args <- list()
[13:18:59.385]                 for (kk in seq_along(NAMES)) {
[13:18:59.385]                   name <- changed[[kk]]
[13:18:59.385]                   NAME <- NAMES[[kk]]
[13:18:59.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.385]                     next
[13:18:59.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.385]                 }
[13:18:59.385]                 NAMES <- toupper(added)
[13:18:59.385]                 for (kk in seq_along(NAMES)) {
[13:18:59.385]                   name <- added[[kk]]
[13:18:59.385]                   NAME <- NAMES[[kk]]
[13:18:59.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.385]                     next
[13:18:59.385]                   args[[name]] <- ""
[13:18:59.385]                 }
[13:18:59.385]                 NAMES <- toupper(removed)
[13:18:59.385]                 for (kk in seq_along(NAMES)) {
[13:18:59.385]                   name <- removed[[kk]]
[13:18:59.385]                   NAME <- NAMES[[kk]]
[13:18:59.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.385]                     next
[13:18:59.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.385]                 }
[13:18:59.385]                 if (length(args) > 0) 
[13:18:59.385]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.385]             }
[13:18:59.385]             else {
[13:18:59.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.385]             }
[13:18:59.385]             {
[13:18:59.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.385]                   0L) {
[13:18:59.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.385]                   base::options(opts)
[13:18:59.385]                 }
[13:18:59.385]                 {
[13:18:59.385]                   {
[13:18:59.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.385]                     NULL
[13:18:59.385]                   }
[13:18:59.385]                   options(future.plan = NULL)
[13:18:59.385]                   if (is.na(NA_character_)) 
[13:18:59.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.385]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.385]                     envir = parent.frame()) 
[13:18:59.385]                   {
[13:18:59.385]                     default_workers <- missing(workers)
[13:18:59.385]                     if (is.function(workers)) 
[13:18:59.385]                       workers <- workers()
[13:18:59.385]                     workers <- structure(as.integer(workers), 
[13:18:59.385]                       class = class(workers))
[13:18:59.385]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.385]                       1L)
[13:18:59.385]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.385]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.385]                       if (default_workers) 
[13:18:59.385]                         supportsMulticore(warn = TRUE)
[13:18:59.385]                       return(sequential(..., envir = envir))
[13:18:59.385]                     }
[13:18:59.385]                     oopts <- options(mc.cores = workers)
[13:18:59.385]                     on.exit(options(oopts))
[13:18:59.385]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.385]                       envir = envir)
[13:18:59.385]                     if (!future$lazy) 
[13:18:59.385]                       future <- run(future)
[13:18:59.385]                     invisible(future)
[13:18:59.385]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.385]                 }
[13:18:59.385]             }
[13:18:59.385]         }
[13:18:59.385]     })
[13:18:59.385]     if (TRUE) {
[13:18:59.385]         base::sink(type = "output", split = FALSE)
[13:18:59.385]         if (TRUE) {
[13:18:59.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.385]         }
[13:18:59.385]         else {
[13:18:59.385]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.385]         }
[13:18:59.385]         base::close(...future.stdout)
[13:18:59.385]         ...future.stdout <- NULL
[13:18:59.385]     }
[13:18:59.385]     ...future.result$conditions <- ...future.conditions
[13:18:59.385]     ...future.result$finished <- base::Sys.time()
[13:18:59.385]     ...future.result
[13:18:59.385] }
[13:18:59.389] assign_globals() ...
[13:18:59.389] List of 11
[13:18:59.389]  $ ...future.FUN            :function (x, ...)  
[13:18:59.389]  $ x_FUN                    :function (x, ...)  
[13:18:59.389]  $ times                    : int 5
[13:18:59.389]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.389]  $ stop_if_not              :function (...)  
[13:18:59.389]  $ dim                      : NULL
[13:18:59.389]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.389]  $ future.call.arguments    : list()
[13:18:59.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.389]  $ ...future.elements_ii    :List of 2
[13:18:59.389]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:18:59.389]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:18:59.389]  $ ...future.seeds_ii       : NULL
[13:18:59.389]  $ ...future.globals.maxSize: NULL
[13:18:59.389]  - attr(*, "resolved")= logi FALSE
[13:18:59.389]  - attr(*, "total_size")= num 95528
[13:18:59.389]  - attr(*, "where")=List of 11
[13:18:59.389]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.389]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.389]  - attr(*, "already-done")= logi TRUE
[13:18:59.403] - copied ‘...future.FUN’ to environment
[13:18:59.403] - copied ‘x_FUN’ to environment
[13:18:59.403] - copied ‘times’ to environment
[13:18:59.403] - copied ‘stopf’ to environment
[13:18:59.403] - copied ‘stop_if_not’ to environment
[13:18:59.403] - copied ‘dim’ to environment
[13:18:59.403] - copied ‘valid_types’ to environment
[13:18:59.403] - copied ‘future.call.arguments’ to environment
[13:18:59.403] - copied ‘...future.elements_ii’ to environment
[13:18:59.404] - copied ‘...future.seeds_ii’ to environment
[13:18:59.404] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.404] assign_globals() ... done
[13:18:59.404] requestCore(): workers = 2
[13:18:59.406] MulticoreFuture started
[13:18:59.407] - Launch lazy future ... done
[13:18:59.407] run() for ‘MulticoreFuture’ ... done
[13:18:59.407] Created future:
[13:18:59.408] plan(): Setting new future strategy stack:
[13:18:59.408] List of future strategies:
[13:18:59.408] 1. sequential:
[13:18:59.408]    - args: function (..., envir = parent.frame())
[13:18:59.408]    - tweaked: FALSE
[13:18:59.408]    - call: NULL
[13:18:59.409] plan(): nbrOfWorkers() = 1
[13:18:59.412] plan(): Setting new future strategy stack:
[13:18:59.412] List of future strategies:
[13:18:59.412] 1. multicore:
[13:18:59.412]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.412]    - tweaked: FALSE
[13:18:59.412]    - call: plan(strategy)
[13:18:59.417] plan(): nbrOfWorkers() = 2
[13:18:59.407] MulticoreFuture:
[13:18:59.407] Label: ‘future_vapply-2’
[13:18:59.407] Expression:
[13:18:59.407] {
[13:18:59.407]     do.call(function(...) {
[13:18:59.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.407]             on.exit(options(oopts), add = TRUE)
[13:18:59.407]         }
[13:18:59.407]         {
[13:18:59.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.407]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.407]             })
[13:18:59.407]         }
[13:18:59.407]     }, args = future.call.arguments)
[13:18:59.407] }
[13:18:59.407] Lazy evaluation: FALSE
[13:18:59.407] Asynchronous evaluation: TRUE
[13:18:59.407] Local evaluation: TRUE
[13:18:59.407] Environment: R_GlobalEnv
[13:18:59.407] Capture standard output: TRUE
[13:18:59.407] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.407] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.407] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:18:59.407] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.407] Resolved: TRUE
[13:18:59.407] Value: <not collected>
[13:18:59.407] Conditions captured: <none>
[13:18:59.407] Early signaling: FALSE
[13:18:59.407] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.407] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.418] Chunk #2 of 2 ... DONE
[13:18:59.418] Launching 2 futures (chunks) ... DONE
[13:18:59.418] Resolving 2 futures (chunks) ...
[13:18:59.418] resolve() on list ...
[13:18:59.418]  recursive: 0
[13:18:59.419]  length: 2
[13:18:59.419] 
[13:18:59.419] Future #1
[13:18:59.420] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.420] - nx: 2
[13:18:59.420] - relay: TRUE
[13:18:59.420] - stdout: TRUE
[13:18:59.420] - signal: TRUE
[13:18:59.421] - resignal: FALSE
[13:18:59.421] - force: TRUE
[13:18:59.421] - relayed: [n=2] FALSE, FALSE
[13:18:59.421] - queued futures: [n=2] FALSE, FALSE
[13:18:59.421]  - until=1
[13:18:59.421]  - relaying element #1
[13:18:59.422] - relayed: [n=2] TRUE, FALSE
[13:18:59.422] - queued futures: [n=2] TRUE, FALSE
[13:18:59.422] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.422]  length: 1 (resolved future 1)
[13:18:59.423] Future #2
[13:18:59.423] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.424] - nx: 2
[13:18:59.424] - relay: TRUE
[13:18:59.424] - stdout: TRUE
[13:18:59.424] - signal: TRUE
[13:18:59.424] - resignal: FALSE
[13:18:59.424] - force: TRUE
[13:18:59.424] - relayed: [n=2] TRUE, FALSE
[13:18:59.425] - queued futures: [n=2] TRUE, FALSE
[13:18:59.425]  - until=2
[13:18:59.425]  - relaying element #2
[13:18:59.425] - relayed: [n=2] TRUE, TRUE
[13:18:59.425] - queued futures: [n=2] TRUE, TRUE
[13:18:59.425] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.426]  length: 0 (resolved future 2)
[13:18:59.426] Relaying remaining futures
[13:18:59.426] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.426] - nx: 2
[13:18:59.426] - relay: TRUE
[13:18:59.426] - stdout: TRUE
[13:18:59.426] - signal: TRUE
[13:18:59.426] - resignal: FALSE
[13:18:59.427] - force: TRUE
[13:18:59.427] - relayed: [n=2] TRUE, TRUE
[13:18:59.427] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.427] - relayed: [n=2] TRUE, TRUE
[13:18:59.427] - queued futures: [n=2] TRUE, TRUE
[13:18:59.427] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.430] resolve() on list ... DONE
[13:18:59.430]  - Number of value chunks collected: 2
[13:18:59.431] Resolving 2 futures (chunks) ... DONE
[13:18:59.431] Reducing values from 2 chunks ...
[13:18:59.431]  - Number of values collected after concatenation: 3
[13:18:59.431]  - Number of values expected: 3
[13:18:59.431] Reducing values from 2 chunks ... DONE
[13:18:59.431] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:18:59.434] future_lapply() ...
[13:18:59.444] Number of chunks: 2
[13:18:59.444] getGlobalsAndPackagesXApply() ...
[13:18:59.444]  - future.globals: TRUE
[13:18:59.444] getGlobalsAndPackages() ...
[13:18:59.445] Searching for globals...
[13:18:59.450] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:18:59.450] Searching for globals ... DONE
[13:18:59.450] Resolving globals: FALSE
[13:18:59.451] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:18:59.451] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:18:59.451] - globals: [1] ‘FUN’
[13:18:59.451] - packages: [1] ‘stats’
[13:18:59.451] getGlobalsAndPackages() ... DONE
[13:18:59.451]  - globals found/used: [n=1] ‘FUN’
[13:18:59.452]  - needed namespaces: [n=1] ‘stats’
[13:18:59.452] Finding globals ... DONE
[13:18:59.452]  - use_args: TRUE
[13:18:59.452]  - Getting '...' globals ...
[13:18:59.452] resolve() on list ...
[13:18:59.452]  recursive: 0
[13:18:59.452]  length: 1
[13:18:59.452]  elements: ‘...’
[13:18:59.453]  length: 0 (resolved future 1)
[13:18:59.453] resolve() on list ... DONE
[13:18:59.453]    - '...' content: [n=0] 
[13:18:59.453] List of 1
[13:18:59.453]  $ ...: list()
[13:18:59.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.453]  - attr(*, "where")=List of 1
[13:18:59.453]   ..$ ...:<environment: 0x555f7a953c70> 
[13:18:59.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.453]  - attr(*, "resolved")= logi TRUE
[13:18:59.453]  - attr(*, "total_size")= num NA
[13:18:59.458]  - Getting '...' globals ... DONE
[13:18:59.458] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:18:59.458] List of 2
[13:18:59.458]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:18:59.458]  $ ...          : list()
[13:18:59.458]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.458]  - attr(*, "where")=List of 2
[13:18:59.458]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.458]   ..$ ...          :<environment: 0x555f7a953c70> 
[13:18:59.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.458]  - attr(*, "resolved")= logi FALSE
[13:18:59.458]  - attr(*, "total_size")= num 46960
[13:18:59.461] Packages to be attached in all futures: [n=1] ‘stats’
[13:18:59.461] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.461] Number of futures (= number of chunks): 2
[13:18:59.461] Launching 2 futures (chunks) ...
[13:18:59.462] Chunk #1 of 2 ...
[13:18:59.462]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.462] getGlobalsAndPackages() ...
[13:18:59.462] Searching for globals...
[13:18:59.462] 
[13:18:59.462] Searching for globals ... DONE
[13:18:59.462] - globals: [0] <none>
[13:18:59.462] getGlobalsAndPackages() ... DONE
[13:18:59.462]    + additional globals found: [n=0] 
[13:18:59.463]    + additional namespaces needed: [n=0] 
[13:18:59.463]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.463]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[13:18:59.463]  - seeds: <none>
[13:18:59.463] getGlobalsAndPackages() ...
[13:18:59.463] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.463] Resolving globals: FALSE
[13:18:59.463] Tweak future expression to call with '...' arguments ...
[13:18:59.463] {
[13:18:59.463]     do.call(function(...) {
[13:18:59.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.463]             on.exit(options(oopts), add = TRUE)
[13:18:59.463]         }
[13:18:59.463]         {
[13:18:59.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.463]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.463]             })
[13:18:59.463]         }
[13:18:59.463]     }, args = future.call.arguments)
[13:18:59.463] }
[13:18:59.464] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.464] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.464] - packages: [1] ‘stats’
[13:18:59.464] getGlobalsAndPackages() ... DONE
[13:18:59.465] run() for ‘Future’ ...
[13:18:59.465] - state: ‘created’
[13:18:59.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.468] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.469]   - Field: ‘label’
[13:18:59.469]   - Field: ‘local’
[13:18:59.469]   - Field: ‘owner’
[13:18:59.469]   - Field: ‘envir’
[13:18:59.469]   - Field: ‘workers’
[13:18:59.469]   - Field: ‘packages’
[13:18:59.469]   - Field: ‘gc’
[13:18:59.469]   - Field: ‘job’
[13:18:59.470]   - Field: ‘conditions’
[13:18:59.470]   - Field: ‘expr’
[13:18:59.470]   - Field: ‘uuid’
[13:18:59.470]   - Field: ‘seed’
[13:18:59.470]   - Field: ‘version’
[13:18:59.470]   - Field: ‘result’
[13:18:59.470]   - Field: ‘asynchronous’
[13:18:59.470]   - Field: ‘calls’
[13:18:59.470]   - Field: ‘globals’
[13:18:59.470]   - Field: ‘stdout’
[13:18:59.470]   - Field: ‘earlySignal’
[13:18:59.471]   - Field: ‘lazy’
[13:18:59.471]   - Field: ‘state’
[13:18:59.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.471] - Launch lazy future ...
[13:18:59.471] Packages needed by the future expression (n = 1): ‘stats’
[13:18:59.471] Packages needed by future strategies (n = 0): <none>
[13:18:59.472] {
[13:18:59.472]     {
[13:18:59.472]         {
[13:18:59.472]             ...future.startTime <- base::Sys.time()
[13:18:59.472]             {
[13:18:59.472]                 {
[13:18:59.472]                   {
[13:18:59.472]                     {
[13:18:59.472]                       {
[13:18:59.472]                         base::local({
[13:18:59.472]                           has_future <- base::requireNamespace("future", 
[13:18:59.472]                             quietly = TRUE)
[13:18:59.472]                           if (has_future) {
[13:18:59.472]                             ns <- base::getNamespace("future")
[13:18:59.472]                             version <- ns[[".package"]][["version"]]
[13:18:59.472]                             if (is.null(version)) 
[13:18:59.472]                               version <- utils::packageVersion("future")
[13:18:59.472]                           }
[13:18:59.472]                           else {
[13:18:59.472]                             version <- NULL
[13:18:59.472]                           }
[13:18:59.472]                           if (!has_future || version < "1.8.0") {
[13:18:59.472]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.472]                               "", base::R.version$version.string), 
[13:18:59.472]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.472]                                 base::R.version$platform, 8 * 
[13:18:59.472]                                   base::.Machine$sizeof.pointer), 
[13:18:59.472]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.472]                                 "release", "version")], collapse = " "), 
[13:18:59.472]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.472]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.472]                               info)
[13:18:59.472]                             info <- base::paste(info, collapse = "; ")
[13:18:59.472]                             if (!has_future) {
[13:18:59.472]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.472]                                 info)
[13:18:59.472]                             }
[13:18:59.472]                             else {
[13:18:59.472]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.472]                                 info, version)
[13:18:59.472]                             }
[13:18:59.472]                             base::stop(msg)
[13:18:59.472]                           }
[13:18:59.472]                         })
[13:18:59.472]                       }
[13:18:59.472]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.472]                       base::options(mc.cores = 1L)
[13:18:59.472]                     }
[13:18:59.472]                     base::local({
[13:18:59.472]                       for (pkg in "stats") {
[13:18:59.472]                         base::loadNamespace(pkg)
[13:18:59.472]                         base::library(pkg, character.only = TRUE)
[13:18:59.472]                       }
[13:18:59.472]                     })
[13:18:59.472]                   }
[13:18:59.472]                   options(future.plan = NULL)
[13:18:59.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.472]                 }
[13:18:59.472]                 ...future.workdir <- getwd()
[13:18:59.472]             }
[13:18:59.472]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.472]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.472]         }
[13:18:59.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.472]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[13:18:59.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.472]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.472]             base::names(...future.oldOptions))
[13:18:59.472]     }
[13:18:59.472]     if (FALSE) {
[13:18:59.472]     }
[13:18:59.472]     else {
[13:18:59.472]         if (TRUE) {
[13:18:59.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.472]                 open = "w")
[13:18:59.472]         }
[13:18:59.472]         else {
[13:18:59.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.472]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.472]         }
[13:18:59.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.472]             base::sink(type = "output", split = FALSE)
[13:18:59.472]             base::close(...future.stdout)
[13:18:59.472]         }, add = TRUE)
[13:18:59.472]     }
[13:18:59.472]     ...future.frame <- base::sys.nframe()
[13:18:59.472]     ...future.conditions <- base::list()
[13:18:59.472]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.472]     if (FALSE) {
[13:18:59.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.472]     }
[13:18:59.472]     ...future.result <- base::tryCatch({
[13:18:59.472]         base::withCallingHandlers({
[13:18:59.472]             ...future.value <- base::withVisible(base::local({
[13:18:59.472]                 withCallingHandlers({
[13:18:59.472]                   {
[13:18:59.472]                     do.call(function(...) {
[13:18:59.472]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.472]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.472]                         ...future.globals.maxSize)) {
[13:18:59.472]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.472]                         on.exit(options(oopts), add = TRUE)
[13:18:59.472]                       }
[13:18:59.472]                       {
[13:18:59.472]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.472]                           FUN = function(jj) {
[13:18:59.472]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.472]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.472]                           })
[13:18:59.472]                       }
[13:18:59.472]                     }, args = future.call.arguments)
[13:18:59.472]                   }
[13:18:59.472]                 }, immediateCondition = function(cond) {
[13:18:59.472]                   save_rds <- function (object, pathname, ...) 
[13:18:59.472]                   {
[13:18:59.472]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.472]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.472]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.472]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.472]                         fi_tmp[["mtime"]])
[13:18:59.472]                     }
[13:18:59.472]                     tryCatch({
[13:18:59.472]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.472]                     }, error = function(ex) {
[13:18:59.472]                       msg <- conditionMessage(ex)
[13:18:59.472]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.472]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.472]                         fi_tmp[["mtime"]], msg)
[13:18:59.472]                       ex$message <- msg
[13:18:59.472]                       stop(ex)
[13:18:59.472]                     })
[13:18:59.472]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.472]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.472]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.472]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.472]                       fi <- file.info(pathname)
[13:18:59.472]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.472]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.472]                         fi[["size"]], fi[["mtime"]])
[13:18:59.472]                       stop(msg)
[13:18:59.472]                     }
[13:18:59.472]                     invisible(pathname)
[13:18:59.472]                   }
[13:18:59.472]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.472]                     rootPath = tempdir()) 
[13:18:59.472]                   {
[13:18:59.472]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.472]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.472]                       tmpdir = path, fileext = ".rds")
[13:18:59.472]                     save_rds(obj, file)
[13:18:59.472]                   }
[13:18:59.472]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.472]                   {
[13:18:59.472]                     inherits <- base::inherits
[13:18:59.472]                     invokeRestart <- base::invokeRestart
[13:18:59.472]                     is.null <- base::is.null
[13:18:59.472]                     muffled <- FALSE
[13:18:59.472]                     if (inherits(cond, "message")) {
[13:18:59.472]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.472]                       if (muffled) 
[13:18:59.472]                         invokeRestart("muffleMessage")
[13:18:59.472]                     }
[13:18:59.472]                     else if (inherits(cond, "warning")) {
[13:18:59.472]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.472]                       if (muffled) 
[13:18:59.472]                         invokeRestart("muffleWarning")
[13:18:59.472]                     }
[13:18:59.472]                     else if (inherits(cond, "condition")) {
[13:18:59.472]                       if (!is.null(pattern)) {
[13:18:59.472]                         computeRestarts <- base::computeRestarts
[13:18:59.472]                         grepl <- base::grepl
[13:18:59.472]                         restarts <- computeRestarts(cond)
[13:18:59.472]                         for (restart in restarts) {
[13:18:59.472]                           name <- restart$name
[13:18:59.472]                           if (is.null(name)) 
[13:18:59.472]                             next
[13:18:59.472]                           if (!grepl(pattern, name)) 
[13:18:59.472]                             next
[13:18:59.472]                           invokeRestart(restart)
[13:18:59.472]                           muffled <- TRUE
[13:18:59.472]                           break
[13:18:59.472]                         }
[13:18:59.472]                       }
[13:18:59.472]                     }
[13:18:59.472]                     invisible(muffled)
[13:18:59.472]                   }
[13:18:59.472]                   muffleCondition(cond)
[13:18:59.472]                 })
[13:18:59.472]             }))
[13:18:59.472]             future::FutureResult(value = ...future.value$value, 
[13:18:59.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.472]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.472]                     ...future.globalenv.names))
[13:18:59.472]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.472]         }, condition = base::local({
[13:18:59.472]             c <- base::c
[13:18:59.472]             inherits <- base::inherits
[13:18:59.472]             invokeRestart <- base::invokeRestart
[13:18:59.472]             length <- base::length
[13:18:59.472]             list <- base::list
[13:18:59.472]             seq.int <- base::seq.int
[13:18:59.472]             signalCondition <- base::signalCondition
[13:18:59.472]             sys.calls <- base::sys.calls
[13:18:59.472]             `[[` <- base::`[[`
[13:18:59.472]             `+` <- base::`+`
[13:18:59.472]             `<<-` <- base::`<<-`
[13:18:59.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.472]                   3L)]
[13:18:59.472]             }
[13:18:59.472]             function(cond) {
[13:18:59.472]                 is_error <- inherits(cond, "error")
[13:18:59.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.472]                   NULL)
[13:18:59.472]                 if (is_error) {
[13:18:59.472]                   sessionInformation <- function() {
[13:18:59.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.472]                       search = base::search(), system = base::Sys.info())
[13:18:59.472]                   }
[13:18:59.472]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.472]                     cond$call), session = sessionInformation(), 
[13:18:59.472]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.472]                   signalCondition(cond)
[13:18:59.472]                 }
[13:18:59.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.472]                 "immediateCondition"))) {
[13:18:59.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.472]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.472]                   if (TRUE && !signal) {
[13:18:59.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.472]                     {
[13:18:59.472]                       inherits <- base::inherits
[13:18:59.472]                       invokeRestart <- base::invokeRestart
[13:18:59.472]                       is.null <- base::is.null
[13:18:59.472]                       muffled <- FALSE
[13:18:59.472]                       if (inherits(cond, "message")) {
[13:18:59.472]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.472]                         if (muffled) 
[13:18:59.472]                           invokeRestart("muffleMessage")
[13:18:59.472]                       }
[13:18:59.472]                       else if (inherits(cond, "warning")) {
[13:18:59.472]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.472]                         if (muffled) 
[13:18:59.472]                           invokeRestart("muffleWarning")
[13:18:59.472]                       }
[13:18:59.472]                       else if (inherits(cond, "condition")) {
[13:18:59.472]                         if (!is.null(pattern)) {
[13:18:59.472]                           computeRestarts <- base::computeRestarts
[13:18:59.472]                           grepl <- base::grepl
[13:18:59.472]                           restarts <- computeRestarts(cond)
[13:18:59.472]                           for (restart in restarts) {
[13:18:59.472]                             name <- restart$name
[13:18:59.472]                             if (is.null(name)) 
[13:18:59.472]                               next
[13:18:59.472]                             if (!grepl(pattern, name)) 
[13:18:59.472]                               next
[13:18:59.472]                             invokeRestart(restart)
[13:18:59.472]                             muffled <- TRUE
[13:18:59.472]                             break
[13:18:59.472]                           }
[13:18:59.472]                         }
[13:18:59.472]                       }
[13:18:59.472]                       invisible(muffled)
[13:18:59.472]                     }
[13:18:59.472]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.472]                   }
[13:18:59.472]                 }
[13:18:59.472]                 else {
[13:18:59.472]                   if (TRUE) {
[13:18:59.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.472]                     {
[13:18:59.472]                       inherits <- base::inherits
[13:18:59.472]                       invokeRestart <- base::invokeRestart
[13:18:59.472]                       is.null <- base::is.null
[13:18:59.472]                       muffled <- FALSE
[13:18:59.472]                       if (inherits(cond, "message")) {
[13:18:59.472]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.472]                         if (muffled) 
[13:18:59.472]                           invokeRestart("muffleMessage")
[13:18:59.472]                       }
[13:18:59.472]                       else if (inherits(cond, "warning")) {
[13:18:59.472]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.472]                         if (muffled) 
[13:18:59.472]                           invokeRestart("muffleWarning")
[13:18:59.472]                       }
[13:18:59.472]                       else if (inherits(cond, "condition")) {
[13:18:59.472]                         if (!is.null(pattern)) {
[13:18:59.472]                           computeRestarts <- base::computeRestarts
[13:18:59.472]                           grepl <- base::grepl
[13:18:59.472]                           restarts <- computeRestarts(cond)
[13:18:59.472]                           for (restart in restarts) {
[13:18:59.472]                             name <- restart$name
[13:18:59.472]                             if (is.null(name)) 
[13:18:59.472]                               next
[13:18:59.472]                             if (!grepl(pattern, name)) 
[13:18:59.472]                               next
[13:18:59.472]                             invokeRestart(restart)
[13:18:59.472]                             muffled <- TRUE
[13:18:59.472]                             break
[13:18:59.472]                           }
[13:18:59.472]                         }
[13:18:59.472]                       }
[13:18:59.472]                       invisible(muffled)
[13:18:59.472]                     }
[13:18:59.472]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.472]                   }
[13:18:59.472]                 }
[13:18:59.472]             }
[13:18:59.472]         }))
[13:18:59.472]     }, error = function(ex) {
[13:18:59.472]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.472]                 ...future.rng), started = ...future.startTime, 
[13:18:59.472]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.472]             version = "1.8"), class = "FutureResult")
[13:18:59.472]     }, finally = {
[13:18:59.472]         if (!identical(...future.workdir, getwd())) 
[13:18:59.472]             setwd(...future.workdir)
[13:18:59.472]         {
[13:18:59.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.472]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.472]             }
[13:18:59.472]             base::options(...future.oldOptions)
[13:18:59.472]             if (.Platform$OS.type == "windows") {
[13:18:59.472]                 old_names <- names(...future.oldEnvVars)
[13:18:59.472]                 envs <- base::Sys.getenv()
[13:18:59.472]                 names <- names(envs)
[13:18:59.472]                 common <- intersect(names, old_names)
[13:18:59.472]                 added <- setdiff(names, old_names)
[13:18:59.472]                 removed <- setdiff(old_names, names)
[13:18:59.472]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.472]                   envs[common]]
[13:18:59.472]                 NAMES <- toupper(changed)
[13:18:59.472]                 args <- list()
[13:18:59.472]                 for (kk in seq_along(NAMES)) {
[13:18:59.472]                   name <- changed[[kk]]
[13:18:59.472]                   NAME <- NAMES[[kk]]
[13:18:59.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.472]                     next
[13:18:59.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.472]                 }
[13:18:59.472]                 NAMES <- toupper(added)
[13:18:59.472]                 for (kk in seq_along(NAMES)) {
[13:18:59.472]                   name <- added[[kk]]
[13:18:59.472]                   NAME <- NAMES[[kk]]
[13:18:59.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.472]                     next
[13:18:59.472]                   args[[name]] <- ""
[13:18:59.472]                 }
[13:18:59.472]                 NAMES <- toupper(removed)
[13:18:59.472]                 for (kk in seq_along(NAMES)) {
[13:18:59.472]                   name <- removed[[kk]]
[13:18:59.472]                   NAME <- NAMES[[kk]]
[13:18:59.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.472]                     next
[13:18:59.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.472]                 }
[13:18:59.472]                 if (length(args) > 0) 
[13:18:59.472]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.472]             }
[13:18:59.472]             else {
[13:18:59.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.472]             }
[13:18:59.472]             {
[13:18:59.472]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.472]                   0L) {
[13:18:59.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.472]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.472]                   base::options(opts)
[13:18:59.472]                 }
[13:18:59.472]                 {
[13:18:59.472]                   {
[13:18:59.472]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.472]                     NULL
[13:18:59.472]                   }
[13:18:59.472]                   options(future.plan = NULL)
[13:18:59.472]                   if (is.na(NA_character_)) 
[13:18:59.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.472]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.472]                     envir = parent.frame()) 
[13:18:59.472]                   {
[13:18:59.472]                     default_workers <- missing(workers)
[13:18:59.472]                     if (is.function(workers)) 
[13:18:59.472]                       workers <- workers()
[13:18:59.472]                     workers <- structure(as.integer(workers), 
[13:18:59.472]                       class = class(workers))
[13:18:59.472]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.472]                       1L)
[13:18:59.472]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.472]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.472]                       if (default_workers) 
[13:18:59.472]                         supportsMulticore(warn = TRUE)
[13:18:59.472]                       return(sequential(..., envir = envir))
[13:18:59.472]                     }
[13:18:59.472]                     oopts <- options(mc.cores = workers)
[13:18:59.472]                     on.exit(options(oopts))
[13:18:59.472]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.472]                       envir = envir)
[13:18:59.472]                     if (!future$lazy) 
[13:18:59.472]                       future <- run(future)
[13:18:59.472]                     invisible(future)
[13:18:59.472]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.472]                 }
[13:18:59.472]             }
[13:18:59.472]         }
[13:18:59.472]     })
[13:18:59.472]     if (TRUE) {
[13:18:59.472]         base::sink(type = "output", split = FALSE)
[13:18:59.472]         if (TRUE) {
[13:18:59.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.472]         }
[13:18:59.472]         else {
[13:18:59.472]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.472]         }
[13:18:59.472]         base::close(...future.stdout)
[13:18:59.472]         ...future.stdout <- NULL
[13:18:59.472]     }
[13:18:59.472]     ...future.result$conditions <- ...future.conditions
[13:18:59.472]     ...future.result$finished <- base::Sys.time()
[13:18:59.472]     ...future.result
[13:18:59.472] }
[13:18:59.474] assign_globals() ...
[13:18:59.475] List of 5
[13:18:59.475]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:18:59.475]  $ future.call.arguments    : list()
[13:18:59.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.475]  $ ...future.elements_ii    :List of 4
[13:18:59.475]   ..$ : int [1:3] 1 2 3
[13:18:59.475]   ..$ : int [1:4] 1 2 3 4
[13:18:59.475]   ..$ : int [1:5] 1 2 3 4 5
[13:18:59.475]   ..$ : int [1:6] 1 2 3 4 5 6
[13:18:59.475]  $ ...future.seeds_ii       : NULL
[13:18:59.475]  $ ...future.globals.maxSize: NULL
[13:18:59.475]  - attr(*, "resolved")= logi FALSE
[13:18:59.475]  - attr(*, "total_size")= num 46960
[13:18:59.475]  - attr(*, "where")=List of 5
[13:18:59.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.475]  - attr(*, "already-done")= logi TRUE
[13:18:59.483] - copied ‘...future.FUN’ to environment
[13:18:59.483] - copied ‘future.call.arguments’ to environment
[13:18:59.483] - copied ‘...future.elements_ii’ to environment
[13:18:59.483] - copied ‘...future.seeds_ii’ to environment
[13:18:59.483] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.483] assign_globals() ... done
[13:18:59.483] requestCore(): workers = 2
[13:18:59.486] MulticoreFuture started
[13:18:59.487] - Launch lazy future ... done
[13:18:59.487] run() for ‘MulticoreFuture’ ... done
[13:18:59.488] Created future:
[13:18:59.488] plan(): Setting new future strategy stack:
[13:18:59.488] List of future strategies:
[13:18:59.488] 1. sequential:
[13:18:59.488]    - args: function (..., envir = parent.frame())
[13:18:59.488]    - tweaked: FALSE
[13:18:59.488]    - call: NULL
[13:18:59.490] plan(): nbrOfWorkers() = 1
[13:18:59.492] plan(): Setting new future strategy stack:
[13:18:59.493] List of future strategies:
[13:18:59.493] 1. multicore:
[13:18:59.493]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.493]    - tweaked: FALSE
[13:18:59.493]    - call: plan(strategy)
[13:18:59.498] plan(): nbrOfWorkers() = 2
[13:18:59.488] MulticoreFuture:
[13:18:59.488] Label: ‘future_sapply-1’
[13:18:59.488] Expression:
[13:18:59.488] {
[13:18:59.488]     do.call(function(...) {
[13:18:59.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.488]             on.exit(options(oopts), add = TRUE)
[13:18:59.488]         }
[13:18:59.488]         {
[13:18:59.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.488]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.488]             })
[13:18:59.488]         }
[13:18:59.488]     }, args = future.call.arguments)
[13:18:59.488] }
[13:18:59.488] Lazy evaluation: FALSE
[13:18:59.488] Asynchronous evaluation: TRUE
[13:18:59.488] Local evaluation: TRUE
[13:18:59.488] Environment: R_GlobalEnv
[13:18:59.488] Capture standard output: TRUE
[13:18:59.488] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.488] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:18:59.488] Packages: 1 packages (‘stats’)
[13:18:59.488] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.488] Resolved: TRUE
[13:18:59.488] Value: <not collected>
[13:18:59.488] Conditions captured: <none>
[13:18:59.488] Early signaling: FALSE
[13:18:59.488] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.488] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.499] Chunk #1 of 2 ... DONE
[13:18:59.500] Chunk #2 of 2 ...
[13:18:59.500]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.500] getGlobalsAndPackages() ...
[13:18:59.500] Searching for globals...
[13:18:59.501] 
[13:18:59.501] Searching for globals ... DONE
[13:18:59.501] - globals: [0] <none>
[13:18:59.501] getGlobalsAndPackages() ... DONE
[13:18:59.501]    + additional globals found: [n=0] 
[13:18:59.501]    + additional namespaces needed: [n=0] 
[13:18:59.502]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:18:59.502]  - seeds: <none>
[13:18:59.502] getGlobalsAndPackages() ...
[13:18:59.502] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.503] Resolving globals: FALSE
[13:18:59.503] Tweak future expression to call with '...' arguments ...
[13:18:59.503] {
[13:18:59.503]     do.call(function(...) {
[13:18:59.503]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.503]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.503]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.503]             on.exit(options(oopts), add = TRUE)
[13:18:59.503]         }
[13:18:59.503]         {
[13:18:59.503]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.503]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.503]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.503]             })
[13:18:59.503]         }
[13:18:59.503]     }, args = future.call.arguments)
[13:18:59.503] }
[13:18:59.504] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.505] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.505] - packages: [1] ‘stats’
[13:18:59.505] getGlobalsAndPackages() ... DONE
[13:18:59.506] run() for ‘Future’ ...
[13:18:59.506] - state: ‘created’
[13:18:59.506] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.511] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.511]   - Field: ‘label’
[13:18:59.511]   - Field: ‘local’
[13:18:59.511]   - Field: ‘owner’
[13:18:59.512]   - Field: ‘envir’
[13:18:59.512]   - Field: ‘workers’
[13:18:59.512]   - Field: ‘packages’
[13:18:59.512]   - Field: ‘gc’
[13:18:59.512]   - Field: ‘job’
[13:18:59.512]   - Field: ‘conditions’
[13:18:59.512]   - Field: ‘expr’
[13:18:59.513]   - Field: ‘uuid’
[13:18:59.513]   - Field: ‘seed’
[13:18:59.513]   - Field: ‘version’
[13:18:59.513]   - Field: ‘result’
[13:18:59.513]   - Field: ‘asynchronous’
[13:18:59.513]   - Field: ‘calls’
[13:18:59.513]   - Field: ‘globals’
[13:18:59.514]   - Field: ‘stdout’
[13:18:59.514]   - Field: ‘earlySignal’
[13:18:59.514]   - Field: ‘lazy’
[13:18:59.514]   - Field: ‘state’
[13:18:59.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.514] - Launch lazy future ...
[13:18:59.515] Packages needed by the future expression (n = 1): ‘stats’
[13:18:59.515] Packages needed by future strategies (n = 0): <none>
[13:18:59.516] {
[13:18:59.516]     {
[13:18:59.516]         {
[13:18:59.516]             ...future.startTime <- base::Sys.time()
[13:18:59.516]             {
[13:18:59.516]                 {
[13:18:59.516]                   {
[13:18:59.516]                     {
[13:18:59.516]                       {
[13:18:59.516]                         base::local({
[13:18:59.516]                           has_future <- base::requireNamespace("future", 
[13:18:59.516]                             quietly = TRUE)
[13:18:59.516]                           if (has_future) {
[13:18:59.516]                             ns <- base::getNamespace("future")
[13:18:59.516]                             version <- ns[[".package"]][["version"]]
[13:18:59.516]                             if (is.null(version)) 
[13:18:59.516]                               version <- utils::packageVersion("future")
[13:18:59.516]                           }
[13:18:59.516]                           else {
[13:18:59.516]                             version <- NULL
[13:18:59.516]                           }
[13:18:59.516]                           if (!has_future || version < "1.8.0") {
[13:18:59.516]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.516]                               "", base::R.version$version.string), 
[13:18:59.516]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.516]                                 base::R.version$platform, 8 * 
[13:18:59.516]                                   base::.Machine$sizeof.pointer), 
[13:18:59.516]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.516]                                 "release", "version")], collapse = " "), 
[13:18:59.516]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.516]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.516]                               info)
[13:18:59.516]                             info <- base::paste(info, collapse = "; ")
[13:18:59.516]                             if (!has_future) {
[13:18:59.516]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.516]                                 info)
[13:18:59.516]                             }
[13:18:59.516]                             else {
[13:18:59.516]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.516]                                 info, version)
[13:18:59.516]                             }
[13:18:59.516]                             base::stop(msg)
[13:18:59.516]                           }
[13:18:59.516]                         })
[13:18:59.516]                       }
[13:18:59.516]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.516]                       base::options(mc.cores = 1L)
[13:18:59.516]                     }
[13:18:59.516]                     base::local({
[13:18:59.516]                       for (pkg in "stats") {
[13:18:59.516]                         base::loadNamespace(pkg)
[13:18:59.516]                         base::library(pkg, character.only = TRUE)
[13:18:59.516]                       }
[13:18:59.516]                     })
[13:18:59.516]                   }
[13:18:59.516]                   options(future.plan = NULL)
[13:18:59.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.516]                 }
[13:18:59.516]                 ...future.workdir <- getwd()
[13:18:59.516]             }
[13:18:59.516]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.516]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.516]         }
[13:18:59.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.516]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:18:59.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.516]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.516]             base::names(...future.oldOptions))
[13:18:59.516]     }
[13:18:59.516]     if (FALSE) {
[13:18:59.516]     }
[13:18:59.516]     else {
[13:18:59.516]         if (TRUE) {
[13:18:59.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.516]                 open = "w")
[13:18:59.516]         }
[13:18:59.516]         else {
[13:18:59.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.516]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.516]         }
[13:18:59.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.516]             base::sink(type = "output", split = FALSE)
[13:18:59.516]             base::close(...future.stdout)
[13:18:59.516]         }, add = TRUE)
[13:18:59.516]     }
[13:18:59.516]     ...future.frame <- base::sys.nframe()
[13:18:59.516]     ...future.conditions <- base::list()
[13:18:59.516]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.516]     if (FALSE) {
[13:18:59.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.516]     }
[13:18:59.516]     ...future.result <- base::tryCatch({
[13:18:59.516]         base::withCallingHandlers({
[13:18:59.516]             ...future.value <- base::withVisible(base::local({
[13:18:59.516]                 withCallingHandlers({
[13:18:59.516]                   {
[13:18:59.516]                     do.call(function(...) {
[13:18:59.516]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.516]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.516]                         ...future.globals.maxSize)) {
[13:18:59.516]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.516]                         on.exit(options(oopts), add = TRUE)
[13:18:59.516]                       }
[13:18:59.516]                       {
[13:18:59.516]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.516]                           FUN = function(jj) {
[13:18:59.516]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.516]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.516]                           })
[13:18:59.516]                       }
[13:18:59.516]                     }, args = future.call.arguments)
[13:18:59.516]                   }
[13:18:59.516]                 }, immediateCondition = function(cond) {
[13:18:59.516]                   save_rds <- function (object, pathname, ...) 
[13:18:59.516]                   {
[13:18:59.516]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.516]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.516]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.516]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.516]                         fi_tmp[["mtime"]])
[13:18:59.516]                     }
[13:18:59.516]                     tryCatch({
[13:18:59.516]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.516]                     }, error = function(ex) {
[13:18:59.516]                       msg <- conditionMessage(ex)
[13:18:59.516]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.516]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.516]                         fi_tmp[["mtime"]], msg)
[13:18:59.516]                       ex$message <- msg
[13:18:59.516]                       stop(ex)
[13:18:59.516]                     })
[13:18:59.516]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.516]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.516]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.516]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.516]                       fi <- file.info(pathname)
[13:18:59.516]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.516]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.516]                         fi[["size"]], fi[["mtime"]])
[13:18:59.516]                       stop(msg)
[13:18:59.516]                     }
[13:18:59.516]                     invisible(pathname)
[13:18:59.516]                   }
[13:18:59.516]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.516]                     rootPath = tempdir()) 
[13:18:59.516]                   {
[13:18:59.516]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.516]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.516]                       tmpdir = path, fileext = ".rds")
[13:18:59.516]                     save_rds(obj, file)
[13:18:59.516]                   }
[13:18:59.516]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.516]                   {
[13:18:59.516]                     inherits <- base::inherits
[13:18:59.516]                     invokeRestart <- base::invokeRestart
[13:18:59.516]                     is.null <- base::is.null
[13:18:59.516]                     muffled <- FALSE
[13:18:59.516]                     if (inherits(cond, "message")) {
[13:18:59.516]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.516]                       if (muffled) 
[13:18:59.516]                         invokeRestart("muffleMessage")
[13:18:59.516]                     }
[13:18:59.516]                     else if (inherits(cond, "warning")) {
[13:18:59.516]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.516]                       if (muffled) 
[13:18:59.516]                         invokeRestart("muffleWarning")
[13:18:59.516]                     }
[13:18:59.516]                     else if (inherits(cond, "condition")) {
[13:18:59.516]                       if (!is.null(pattern)) {
[13:18:59.516]                         computeRestarts <- base::computeRestarts
[13:18:59.516]                         grepl <- base::grepl
[13:18:59.516]                         restarts <- computeRestarts(cond)
[13:18:59.516]                         for (restart in restarts) {
[13:18:59.516]                           name <- restart$name
[13:18:59.516]                           if (is.null(name)) 
[13:18:59.516]                             next
[13:18:59.516]                           if (!grepl(pattern, name)) 
[13:18:59.516]                             next
[13:18:59.516]                           invokeRestart(restart)
[13:18:59.516]                           muffled <- TRUE
[13:18:59.516]                           break
[13:18:59.516]                         }
[13:18:59.516]                       }
[13:18:59.516]                     }
[13:18:59.516]                     invisible(muffled)
[13:18:59.516]                   }
[13:18:59.516]                   muffleCondition(cond)
[13:18:59.516]                 })
[13:18:59.516]             }))
[13:18:59.516]             future::FutureResult(value = ...future.value$value, 
[13:18:59.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.516]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.516]                     ...future.globalenv.names))
[13:18:59.516]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.516]         }, condition = base::local({
[13:18:59.516]             c <- base::c
[13:18:59.516]             inherits <- base::inherits
[13:18:59.516]             invokeRestart <- base::invokeRestart
[13:18:59.516]             length <- base::length
[13:18:59.516]             list <- base::list
[13:18:59.516]             seq.int <- base::seq.int
[13:18:59.516]             signalCondition <- base::signalCondition
[13:18:59.516]             sys.calls <- base::sys.calls
[13:18:59.516]             `[[` <- base::`[[`
[13:18:59.516]             `+` <- base::`+`
[13:18:59.516]             `<<-` <- base::`<<-`
[13:18:59.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.516]                   3L)]
[13:18:59.516]             }
[13:18:59.516]             function(cond) {
[13:18:59.516]                 is_error <- inherits(cond, "error")
[13:18:59.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.516]                   NULL)
[13:18:59.516]                 if (is_error) {
[13:18:59.516]                   sessionInformation <- function() {
[13:18:59.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.516]                       search = base::search(), system = base::Sys.info())
[13:18:59.516]                   }
[13:18:59.516]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.516]                     cond$call), session = sessionInformation(), 
[13:18:59.516]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.516]                   signalCondition(cond)
[13:18:59.516]                 }
[13:18:59.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.516]                 "immediateCondition"))) {
[13:18:59.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.516]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.516]                   if (TRUE && !signal) {
[13:18:59.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.516]                     {
[13:18:59.516]                       inherits <- base::inherits
[13:18:59.516]                       invokeRestart <- base::invokeRestart
[13:18:59.516]                       is.null <- base::is.null
[13:18:59.516]                       muffled <- FALSE
[13:18:59.516]                       if (inherits(cond, "message")) {
[13:18:59.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.516]                         if (muffled) 
[13:18:59.516]                           invokeRestart("muffleMessage")
[13:18:59.516]                       }
[13:18:59.516]                       else if (inherits(cond, "warning")) {
[13:18:59.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.516]                         if (muffled) 
[13:18:59.516]                           invokeRestart("muffleWarning")
[13:18:59.516]                       }
[13:18:59.516]                       else if (inherits(cond, "condition")) {
[13:18:59.516]                         if (!is.null(pattern)) {
[13:18:59.516]                           computeRestarts <- base::computeRestarts
[13:18:59.516]                           grepl <- base::grepl
[13:18:59.516]                           restarts <- computeRestarts(cond)
[13:18:59.516]                           for (restart in restarts) {
[13:18:59.516]                             name <- restart$name
[13:18:59.516]                             if (is.null(name)) 
[13:18:59.516]                               next
[13:18:59.516]                             if (!grepl(pattern, name)) 
[13:18:59.516]                               next
[13:18:59.516]                             invokeRestart(restart)
[13:18:59.516]                             muffled <- TRUE
[13:18:59.516]                             break
[13:18:59.516]                           }
[13:18:59.516]                         }
[13:18:59.516]                       }
[13:18:59.516]                       invisible(muffled)
[13:18:59.516]                     }
[13:18:59.516]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.516]                   }
[13:18:59.516]                 }
[13:18:59.516]                 else {
[13:18:59.516]                   if (TRUE) {
[13:18:59.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.516]                     {
[13:18:59.516]                       inherits <- base::inherits
[13:18:59.516]                       invokeRestart <- base::invokeRestart
[13:18:59.516]                       is.null <- base::is.null
[13:18:59.516]                       muffled <- FALSE
[13:18:59.516]                       if (inherits(cond, "message")) {
[13:18:59.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.516]                         if (muffled) 
[13:18:59.516]                           invokeRestart("muffleMessage")
[13:18:59.516]                       }
[13:18:59.516]                       else if (inherits(cond, "warning")) {
[13:18:59.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.516]                         if (muffled) 
[13:18:59.516]                           invokeRestart("muffleWarning")
[13:18:59.516]                       }
[13:18:59.516]                       else if (inherits(cond, "condition")) {
[13:18:59.516]                         if (!is.null(pattern)) {
[13:18:59.516]                           computeRestarts <- base::computeRestarts
[13:18:59.516]                           grepl <- base::grepl
[13:18:59.516]                           restarts <- computeRestarts(cond)
[13:18:59.516]                           for (restart in restarts) {
[13:18:59.516]                             name <- restart$name
[13:18:59.516]                             if (is.null(name)) 
[13:18:59.516]                               next
[13:18:59.516]                             if (!grepl(pattern, name)) 
[13:18:59.516]                               next
[13:18:59.516]                             invokeRestart(restart)
[13:18:59.516]                             muffled <- TRUE
[13:18:59.516]                             break
[13:18:59.516]                           }
[13:18:59.516]                         }
[13:18:59.516]                       }
[13:18:59.516]                       invisible(muffled)
[13:18:59.516]                     }
[13:18:59.516]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.516]                   }
[13:18:59.516]                 }
[13:18:59.516]             }
[13:18:59.516]         }))
[13:18:59.516]     }, error = function(ex) {
[13:18:59.516]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.516]                 ...future.rng), started = ...future.startTime, 
[13:18:59.516]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.516]             version = "1.8"), class = "FutureResult")
[13:18:59.516]     }, finally = {
[13:18:59.516]         if (!identical(...future.workdir, getwd())) 
[13:18:59.516]             setwd(...future.workdir)
[13:18:59.516]         {
[13:18:59.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.516]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.516]             }
[13:18:59.516]             base::options(...future.oldOptions)
[13:18:59.516]             if (.Platform$OS.type == "windows") {
[13:18:59.516]                 old_names <- names(...future.oldEnvVars)
[13:18:59.516]                 envs <- base::Sys.getenv()
[13:18:59.516]                 names <- names(envs)
[13:18:59.516]                 common <- intersect(names, old_names)
[13:18:59.516]                 added <- setdiff(names, old_names)
[13:18:59.516]                 removed <- setdiff(old_names, names)
[13:18:59.516]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.516]                   envs[common]]
[13:18:59.516]                 NAMES <- toupper(changed)
[13:18:59.516]                 args <- list()
[13:18:59.516]                 for (kk in seq_along(NAMES)) {
[13:18:59.516]                   name <- changed[[kk]]
[13:18:59.516]                   NAME <- NAMES[[kk]]
[13:18:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.516]                     next
[13:18:59.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.516]                 }
[13:18:59.516]                 NAMES <- toupper(added)
[13:18:59.516]                 for (kk in seq_along(NAMES)) {
[13:18:59.516]                   name <- added[[kk]]
[13:18:59.516]                   NAME <- NAMES[[kk]]
[13:18:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.516]                     next
[13:18:59.516]                   args[[name]] <- ""
[13:18:59.516]                 }
[13:18:59.516]                 NAMES <- toupper(removed)
[13:18:59.516]                 for (kk in seq_along(NAMES)) {
[13:18:59.516]                   name <- removed[[kk]]
[13:18:59.516]                   NAME <- NAMES[[kk]]
[13:18:59.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.516]                     next
[13:18:59.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.516]                 }
[13:18:59.516]                 if (length(args) > 0) 
[13:18:59.516]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.516]             }
[13:18:59.516]             else {
[13:18:59.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.516]             }
[13:18:59.516]             {
[13:18:59.516]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.516]                   0L) {
[13:18:59.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.516]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.516]                   base::options(opts)
[13:18:59.516]                 }
[13:18:59.516]                 {
[13:18:59.516]                   {
[13:18:59.516]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.516]                     NULL
[13:18:59.516]                   }
[13:18:59.516]                   options(future.plan = NULL)
[13:18:59.516]                   if (is.na(NA_character_)) 
[13:18:59.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.516]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.516]                     envir = parent.frame()) 
[13:18:59.516]                   {
[13:18:59.516]                     default_workers <- missing(workers)
[13:18:59.516]                     if (is.function(workers)) 
[13:18:59.516]                       workers <- workers()
[13:18:59.516]                     workers <- structure(as.integer(workers), 
[13:18:59.516]                       class = class(workers))
[13:18:59.516]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.516]                       1L)
[13:18:59.516]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.516]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.516]                       if (default_workers) 
[13:18:59.516]                         supportsMulticore(warn = TRUE)
[13:18:59.516]                       return(sequential(..., envir = envir))
[13:18:59.516]                     }
[13:18:59.516]                     oopts <- options(mc.cores = workers)
[13:18:59.516]                     on.exit(options(oopts))
[13:18:59.516]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.516]                       envir = envir)
[13:18:59.516]                     if (!future$lazy) 
[13:18:59.516]                       future <- run(future)
[13:18:59.516]                     invisible(future)
[13:18:59.516]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.516]                 }
[13:18:59.516]             }
[13:18:59.516]         }
[13:18:59.516]     })
[13:18:59.516]     if (TRUE) {
[13:18:59.516]         base::sink(type = "output", split = FALSE)
[13:18:59.516]         if (TRUE) {
[13:18:59.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.516]         }
[13:18:59.516]         else {
[13:18:59.516]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.516]         }
[13:18:59.516]         base::close(...future.stdout)
[13:18:59.516]         ...future.stdout <- NULL
[13:18:59.516]     }
[13:18:59.516]     ...future.result$conditions <- ...future.conditions
[13:18:59.516]     ...future.result$finished <- base::Sys.time()
[13:18:59.516]     ...future.result
[13:18:59.516] }
[13:18:59.519] assign_globals() ...
[13:18:59.520] List of 5
[13:18:59.520]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:18:59.520]  $ future.call.arguments    : list()
[13:18:59.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.520]  $ ...future.elements_ii    :List of 3
[13:18:59.520]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:18:59.520]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:18:59.520]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:18:59.520]  $ ...future.seeds_ii       : NULL
[13:18:59.520]  $ ...future.globals.maxSize: NULL
[13:18:59.520]  - attr(*, "resolved")= logi FALSE
[13:18:59.520]  - attr(*, "total_size")= num 46960
[13:18:59.520]  - attr(*, "where")=List of 5
[13:18:59.520]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.520]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.520]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.520]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.520]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.520]  - attr(*, "already-done")= logi TRUE
[13:18:59.530] - copied ‘...future.FUN’ to environment
[13:18:59.530] - copied ‘future.call.arguments’ to environment
[13:18:59.530] - copied ‘...future.elements_ii’ to environment
[13:18:59.531] - copied ‘...future.seeds_ii’ to environment
[13:18:59.531] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.531] assign_globals() ... done
[13:18:59.531] requestCore(): workers = 2
[13:18:59.534] MulticoreFuture started
[13:18:59.535] - Launch lazy future ... done
[13:18:59.535] run() for ‘MulticoreFuture’ ... done
[13:18:59.536] Created future:
[13:18:59.536] plan(): Setting new future strategy stack:
[13:18:59.536] List of future strategies:
[13:18:59.536] 1. sequential:
[13:18:59.536]    - args: function (..., envir = parent.frame())
[13:18:59.536]    - tweaked: FALSE
[13:18:59.536]    - call: NULL
[13:18:59.538] plan(): nbrOfWorkers() = 1
[13:18:59.540] plan(): Setting new future strategy stack:
[13:18:59.541] List of future strategies:
[13:18:59.541] 1. multicore:
[13:18:59.541]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.541]    - tweaked: FALSE
[13:18:59.541]    - call: plan(strategy)
[13:18:59.548] plan(): nbrOfWorkers() = 2
[13:18:59.536] MulticoreFuture:
[13:18:59.536] Label: ‘future_sapply-2’
[13:18:59.536] Expression:
[13:18:59.536] {
[13:18:59.536]     do.call(function(...) {
[13:18:59.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.536]             on.exit(options(oopts), add = TRUE)
[13:18:59.536]         }
[13:18:59.536]         {
[13:18:59.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.536]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.536]             })
[13:18:59.536]         }
[13:18:59.536]     }, args = future.call.arguments)
[13:18:59.536] }
[13:18:59.536] Lazy evaluation: FALSE
[13:18:59.536] Asynchronous evaluation: TRUE
[13:18:59.536] Local evaluation: TRUE
[13:18:59.536] Environment: R_GlobalEnv
[13:18:59.536] Capture standard output: TRUE
[13:18:59.536] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.536] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:18:59.536] Packages: 1 packages (‘stats’)
[13:18:59.536] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.536] Resolved: TRUE
[13:18:59.536] Value: <not collected>
[13:18:59.536] Conditions captured: <none>
[13:18:59.536] Early signaling: FALSE
[13:18:59.536] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.536] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.549] Chunk #2 of 2 ... DONE
[13:18:59.549] Launching 2 futures (chunks) ... DONE
[13:18:59.550] Resolving 2 futures (chunks) ...
[13:18:59.550] resolve() on list ...
[13:18:59.550]  recursive: 0
[13:18:59.550]  length: 2
[13:18:59.550] 
[13:18:59.551] Future #1
[13:18:59.552] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.552] - nx: 2
[13:18:59.552] - relay: TRUE
[13:18:59.553] - stdout: TRUE
[13:18:59.553] - signal: TRUE
[13:18:59.553] - resignal: FALSE
[13:18:59.553] - force: TRUE
[13:18:59.553] - relayed: [n=2] FALSE, FALSE
[13:18:59.553] - queued futures: [n=2] FALSE, FALSE
[13:18:59.554]  - until=1
[13:18:59.554]  - relaying element #1
[13:18:59.554] - relayed: [n=2] TRUE, FALSE
[13:18:59.554] - queued futures: [n=2] TRUE, FALSE
[13:18:59.554] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.555]  length: 1 (resolved future 1)
[13:18:59.555] Future #2
[13:18:59.557] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.557] - nx: 2
[13:18:59.557] - relay: TRUE
[13:18:59.557] - stdout: TRUE
[13:18:59.557] - signal: TRUE
[13:18:59.557] - resignal: FALSE
[13:18:59.558] - force: TRUE
[13:18:59.558] - relayed: [n=2] TRUE, FALSE
[13:18:59.558] - queued futures: [n=2] TRUE, FALSE
[13:18:59.558]  - until=2
[13:18:59.558]  - relaying element #2
[13:18:59.559] - relayed: [n=2] TRUE, TRUE
[13:18:59.559] - queued futures: [n=2] TRUE, TRUE
[13:18:59.559] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.559]  length: 0 (resolved future 2)
[13:18:59.559] Relaying remaining futures
[13:18:59.560] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.560] - nx: 2
[13:18:59.560] - relay: TRUE
[13:18:59.560] - stdout: TRUE
[13:18:59.560] - signal: TRUE
[13:18:59.560] - resignal: FALSE
[13:18:59.560] - force: TRUE
[13:18:59.561] - relayed: [n=2] TRUE, TRUE
[13:18:59.561] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.561] - relayed: [n=2] TRUE, TRUE
[13:18:59.561] - queued futures: [n=2] TRUE, TRUE
[13:18:59.561] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.561] resolve() on list ... DONE
[13:18:59.562]  - Number of value chunks collected: 2
[13:18:59.562] Resolving 2 futures (chunks) ... DONE
[13:18:59.562] Reducing values from 2 chunks ...
[13:18:59.562]  - Number of values collected after concatenation: 7
[13:18:59.562]  - Number of values expected: 7
[13:18:59.562] Reducing values from 2 chunks ... DONE
[13:18:59.563] future_lapply() ... DONE
[13:18:59.563] future_lapply() ...
[13:18:59.570] Number of chunks: 2
[13:18:59.570] getGlobalsAndPackagesXApply() ...
[13:18:59.570]  - future.globals: TRUE
[13:18:59.570] getGlobalsAndPackages() ...
[13:18:59.570] Searching for globals...
[13:18:59.582] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:18:59.582] Searching for globals ... DONE
[13:18:59.582] Resolving globals: FALSE
[13:18:59.584] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:18:59.584] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:18:59.584] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.584] - packages: [2] ‘stats’, ‘future.apply’
[13:18:59.584] getGlobalsAndPackages() ... DONE
[13:18:59.585]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.585]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:18:59.585] Finding globals ... DONE
[13:18:59.585]  - use_args: TRUE
[13:18:59.585]  - Getting '...' globals ...
[13:18:59.585] resolve() on list ...
[13:18:59.585]  recursive: 0
[13:18:59.586]  length: 1
[13:18:59.586]  elements: ‘...’
[13:18:59.586]  length: 0 (resolved future 1)
[13:18:59.586] resolve() on list ... DONE
[13:18:59.586]    - '...' content: [n=0] 
[13:18:59.586] List of 1
[13:18:59.586]  $ ...: list()
[13:18:59.586]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.586]  - attr(*, "where")=List of 1
[13:18:59.586]   ..$ ...:<environment: 0x555f795059b8> 
[13:18:59.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.586]  - attr(*, "resolved")= logi TRUE
[13:18:59.586]  - attr(*, "total_size")= num NA
[13:18:59.589]  - Getting '...' globals ... DONE
[13:18:59.589] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:59.589] List of 8
[13:18:59.589]  $ ...future.FUN:function (x, ...)  
[13:18:59.589]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:18:59.589]  $ times        : int 5
[13:18:59.589]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.589]  $ stop_if_not  :function (...)  
[13:18:59.589]  $ dim          : NULL
[13:18:59.589]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:59.589]  $ ...          : list()
[13:18:59.589]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.589]  - attr(*, "where")=List of 8
[13:18:59.589]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:59.589]   ..$ ...          :<environment: 0x555f795059b8> 
[13:18:59.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.589]  - attr(*, "resolved")= logi FALSE
[13:18:59.589]  - attr(*, "total_size")= num 141240
[13:18:59.597] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:18:59.597] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.597] Number of futures (= number of chunks): 2
[13:18:59.597] Launching 2 futures (chunks) ...
[13:18:59.597] Chunk #1 of 2 ...
[13:18:59.597]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.598] getGlobalsAndPackages() ...
[13:18:59.598] Searching for globals...
[13:18:59.598] 
[13:18:59.598] Searching for globals ... DONE
[13:18:59.598] - globals: [0] <none>
[13:18:59.598] getGlobalsAndPackages() ... DONE
[13:18:59.598]    + additional globals found: [n=0] 
[13:18:59.598]    + additional namespaces needed: [n=0] 
[13:18:59.599]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.599]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[13:18:59.599]  - seeds: <none>
[13:18:59.599] getGlobalsAndPackages() ...
[13:18:59.599] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.599] Resolving globals: FALSE
[13:18:59.599] Tweak future expression to call with '...' arguments ...
[13:18:59.599] {
[13:18:59.599]     do.call(function(...) {
[13:18:59.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.599]             on.exit(options(oopts), add = TRUE)
[13:18:59.599]         }
[13:18:59.599]         {
[13:18:59.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.599]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.599]             })
[13:18:59.599]         }
[13:18:59.599]     }, args = future.call.arguments)
[13:18:59.599] }
[13:18:59.600] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.600] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.600] - packages: [2] ‘stats’, ‘future.apply’
[13:18:59.600] getGlobalsAndPackages() ... DONE
[13:18:59.601] run() for ‘Future’ ...
[13:18:59.601] - state: ‘created’
[13:18:59.601] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.605] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.605]   - Field: ‘label’
[13:18:59.605]   - Field: ‘local’
[13:18:59.605]   - Field: ‘owner’
[13:18:59.605]   - Field: ‘envir’
[13:18:59.605]   - Field: ‘workers’
[13:18:59.605]   - Field: ‘packages’
[13:18:59.606]   - Field: ‘gc’
[13:18:59.606]   - Field: ‘job’
[13:18:59.606]   - Field: ‘conditions’
[13:18:59.606]   - Field: ‘expr’
[13:18:59.606]   - Field: ‘uuid’
[13:18:59.606]   - Field: ‘seed’
[13:18:59.606]   - Field: ‘version’
[13:18:59.606]   - Field: ‘result’
[13:18:59.606]   - Field: ‘asynchronous’
[13:18:59.606]   - Field: ‘calls’
[13:18:59.607]   - Field: ‘globals’
[13:18:59.607]   - Field: ‘stdout’
[13:18:59.607]   - Field: ‘earlySignal’
[13:18:59.607]   - Field: ‘lazy’
[13:18:59.607]   - Field: ‘state’
[13:18:59.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.607] - Launch lazy future ...
[13:18:59.607] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:18:59.607] Packages needed by future strategies (n = 0): <none>
[13:18:59.608] {
[13:18:59.608]     {
[13:18:59.608]         {
[13:18:59.608]             ...future.startTime <- base::Sys.time()
[13:18:59.608]             {
[13:18:59.608]                 {
[13:18:59.608]                   {
[13:18:59.608]                     {
[13:18:59.608]                       {
[13:18:59.608]                         base::local({
[13:18:59.608]                           has_future <- base::requireNamespace("future", 
[13:18:59.608]                             quietly = TRUE)
[13:18:59.608]                           if (has_future) {
[13:18:59.608]                             ns <- base::getNamespace("future")
[13:18:59.608]                             version <- ns[[".package"]][["version"]]
[13:18:59.608]                             if (is.null(version)) 
[13:18:59.608]                               version <- utils::packageVersion("future")
[13:18:59.608]                           }
[13:18:59.608]                           else {
[13:18:59.608]                             version <- NULL
[13:18:59.608]                           }
[13:18:59.608]                           if (!has_future || version < "1.8.0") {
[13:18:59.608]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.608]                               "", base::R.version$version.string), 
[13:18:59.608]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.608]                                 base::R.version$platform, 8 * 
[13:18:59.608]                                   base::.Machine$sizeof.pointer), 
[13:18:59.608]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.608]                                 "release", "version")], collapse = " "), 
[13:18:59.608]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.608]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.608]                               info)
[13:18:59.608]                             info <- base::paste(info, collapse = "; ")
[13:18:59.608]                             if (!has_future) {
[13:18:59.608]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.608]                                 info)
[13:18:59.608]                             }
[13:18:59.608]                             else {
[13:18:59.608]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.608]                                 info, version)
[13:18:59.608]                             }
[13:18:59.608]                             base::stop(msg)
[13:18:59.608]                           }
[13:18:59.608]                         })
[13:18:59.608]                       }
[13:18:59.608]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.608]                       base::options(mc.cores = 1L)
[13:18:59.608]                     }
[13:18:59.608]                     base::local({
[13:18:59.608]                       for (pkg in c("stats", "future.apply")) {
[13:18:59.608]                         base::loadNamespace(pkg)
[13:18:59.608]                         base::library(pkg, character.only = TRUE)
[13:18:59.608]                       }
[13:18:59.608]                     })
[13:18:59.608]                   }
[13:18:59.608]                   options(future.plan = NULL)
[13:18:59.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.608]                 }
[13:18:59.608]                 ...future.workdir <- getwd()
[13:18:59.608]             }
[13:18:59.608]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.608]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.608]         }
[13:18:59.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.608]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[13:18:59.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.608]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.608]             base::names(...future.oldOptions))
[13:18:59.608]     }
[13:18:59.608]     if (FALSE) {
[13:18:59.608]     }
[13:18:59.608]     else {
[13:18:59.608]         if (TRUE) {
[13:18:59.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.608]                 open = "w")
[13:18:59.608]         }
[13:18:59.608]         else {
[13:18:59.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.608]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.608]         }
[13:18:59.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.608]             base::sink(type = "output", split = FALSE)
[13:18:59.608]             base::close(...future.stdout)
[13:18:59.608]         }, add = TRUE)
[13:18:59.608]     }
[13:18:59.608]     ...future.frame <- base::sys.nframe()
[13:18:59.608]     ...future.conditions <- base::list()
[13:18:59.608]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.608]     if (FALSE) {
[13:18:59.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.608]     }
[13:18:59.608]     ...future.result <- base::tryCatch({
[13:18:59.608]         base::withCallingHandlers({
[13:18:59.608]             ...future.value <- base::withVisible(base::local({
[13:18:59.608]                 withCallingHandlers({
[13:18:59.608]                   {
[13:18:59.608]                     do.call(function(...) {
[13:18:59.608]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.608]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.608]                         ...future.globals.maxSize)) {
[13:18:59.608]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.608]                         on.exit(options(oopts), add = TRUE)
[13:18:59.608]                       }
[13:18:59.608]                       {
[13:18:59.608]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.608]                           FUN = function(jj) {
[13:18:59.608]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.608]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.608]                           })
[13:18:59.608]                       }
[13:18:59.608]                     }, args = future.call.arguments)
[13:18:59.608]                   }
[13:18:59.608]                 }, immediateCondition = function(cond) {
[13:18:59.608]                   save_rds <- function (object, pathname, ...) 
[13:18:59.608]                   {
[13:18:59.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.608]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.608]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.608]                         fi_tmp[["mtime"]])
[13:18:59.608]                     }
[13:18:59.608]                     tryCatch({
[13:18:59.608]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.608]                     }, error = function(ex) {
[13:18:59.608]                       msg <- conditionMessage(ex)
[13:18:59.608]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.608]                         fi_tmp[["mtime"]], msg)
[13:18:59.608]                       ex$message <- msg
[13:18:59.608]                       stop(ex)
[13:18:59.608]                     })
[13:18:59.608]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.608]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.608]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.608]                       fi <- file.info(pathname)
[13:18:59.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.608]                         fi[["size"]], fi[["mtime"]])
[13:18:59.608]                       stop(msg)
[13:18:59.608]                     }
[13:18:59.608]                     invisible(pathname)
[13:18:59.608]                   }
[13:18:59.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.608]                     rootPath = tempdir()) 
[13:18:59.608]                   {
[13:18:59.608]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.608]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.608]                       tmpdir = path, fileext = ".rds")
[13:18:59.608]                     save_rds(obj, file)
[13:18:59.608]                   }
[13:18:59.608]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.608]                   {
[13:18:59.608]                     inherits <- base::inherits
[13:18:59.608]                     invokeRestart <- base::invokeRestart
[13:18:59.608]                     is.null <- base::is.null
[13:18:59.608]                     muffled <- FALSE
[13:18:59.608]                     if (inherits(cond, "message")) {
[13:18:59.608]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.608]                       if (muffled) 
[13:18:59.608]                         invokeRestart("muffleMessage")
[13:18:59.608]                     }
[13:18:59.608]                     else if (inherits(cond, "warning")) {
[13:18:59.608]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.608]                       if (muffled) 
[13:18:59.608]                         invokeRestart("muffleWarning")
[13:18:59.608]                     }
[13:18:59.608]                     else if (inherits(cond, "condition")) {
[13:18:59.608]                       if (!is.null(pattern)) {
[13:18:59.608]                         computeRestarts <- base::computeRestarts
[13:18:59.608]                         grepl <- base::grepl
[13:18:59.608]                         restarts <- computeRestarts(cond)
[13:18:59.608]                         for (restart in restarts) {
[13:18:59.608]                           name <- restart$name
[13:18:59.608]                           if (is.null(name)) 
[13:18:59.608]                             next
[13:18:59.608]                           if (!grepl(pattern, name)) 
[13:18:59.608]                             next
[13:18:59.608]                           invokeRestart(restart)
[13:18:59.608]                           muffled <- TRUE
[13:18:59.608]                           break
[13:18:59.608]                         }
[13:18:59.608]                       }
[13:18:59.608]                     }
[13:18:59.608]                     invisible(muffled)
[13:18:59.608]                   }
[13:18:59.608]                   muffleCondition(cond)
[13:18:59.608]                 })
[13:18:59.608]             }))
[13:18:59.608]             future::FutureResult(value = ...future.value$value, 
[13:18:59.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.608]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.608]                     ...future.globalenv.names))
[13:18:59.608]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.608]         }, condition = base::local({
[13:18:59.608]             c <- base::c
[13:18:59.608]             inherits <- base::inherits
[13:18:59.608]             invokeRestart <- base::invokeRestart
[13:18:59.608]             length <- base::length
[13:18:59.608]             list <- base::list
[13:18:59.608]             seq.int <- base::seq.int
[13:18:59.608]             signalCondition <- base::signalCondition
[13:18:59.608]             sys.calls <- base::sys.calls
[13:18:59.608]             `[[` <- base::`[[`
[13:18:59.608]             `+` <- base::`+`
[13:18:59.608]             `<<-` <- base::`<<-`
[13:18:59.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.608]                   3L)]
[13:18:59.608]             }
[13:18:59.608]             function(cond) {
[13:18:59.608]                 is_error <- inherits(cond, "error")
[13:18:59.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.608]                   NULL)
[13:18:59.608]                 if (is_error) {
[13:18:59.608]                   sessionInformation <- function() {
[13:18:59.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.608]                       search = base::search(), system = base::Sys.info())
[13:18:59.608]                   }
[13:18:59.608]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.608]                     cond$call), session = sessionInformation(), 
[13:18:59.608]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.608]                   signalCondition(cond)
[13:18:59.608]                 }
[13:18:59.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.608]                 "immediateCondition"))) {
[13:18:59.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.608]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.608]                   if (TRUE && !signal) {
[13:18:59.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.608]                     {
[13:18:59.608]                       inherits <- base::inherits
[13:18:59.608]                       invokeRestart <- base::invokeRestart
[13:18:59.608]                       is.null <- base::is.null
[13:18:59.608]                       muffled <- FALSE
[13:18:59.608]                       if (inherits(cond, "message")) {
[13:18:59.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.608]                         if (muffled) 
[13:18:59.608]                           invokeRestart("muffleMessage")
[13:18:59.608]                       }
[13:18:59.608]                       else if (inherits(cond, "warning")) {
[13:18:59.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.608]                         if (muffled) 
[13:18:59.608]                           invokeRestart("muffleWarning")
[13:18:59.608]                       }
[13:18:59.608]                       else if (inherits(cond, "condition")) {
[13:18:59.608]                         if (!is.null(pattern)) {
[13:18:59.608]                           computeRestarts <- base::computeRestarts
[13:18:59.608]                           grepl <- base::grepl
[13:18:59.608]                           restarts <- computeRestarts(cond)
[13:18:59.608]                           for (restart in restarts) {
[13:18:59.608]                             name <- restart$name
[13:18:59.608]                             if (is.null(name)) 
[13:18:59.608]                               next
[13:18:59.608]                             if (!grepl(pattern, name)) 
[13:18:59.608]                               next
[13:18:59.608]                             invokeRestart(restart)
[13:18:59.608]                             muffled <- TRUE
[13:18:59.608]                             break
[13:18:59.608]                           }
[13:18:59.608]                         }
[13:18:59.608]                       }
[13:18:59.608]                       invisible(muffled)
[13:18:59.608]                     }
[13:18:59.608]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.608]                   }
[13:18:59.608]                 }
[13:18:59.608]                 else {
[13:18:59.608]                   if (TRUE) {
[13:18:59.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.608]                     {
[13:18:59.608]                       inherits <- base::inherits
[13:18:59.608]                       invokeRestart <- base::invokeRestart
[13:18:59.608]                       is.null <- base::is.null
[13:18:59.608]                       muffled <- FALSE
[13:18:59.608]                       if (inherits(cond, "message")) {
[13:18:59.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.608]                         if (muffled) 
[13:18:59.608]                           invokeRestart("muffleMessage")
[13:18:59.608]                       }
[13:18:59.608]                       else if (inherits(cond, "warning")) {
[13:18:59.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.608]                         if (muffled) 
[13:18:59.608]                           invokeRestart("muffleWarning")
[13:18:59.608]                       }
[13:18:59.608]                       else if (inherits(cond, "condition")) {
[13:18:59.608]                         if (!is.null(pattern)) {
[13:18:59.608]                           computeRestarts <- base::computeRestarts
[13:18:59.608]                           grepl <- base::grepl
[13:18:59.608]                           restarts <- computeRestarts(cond)
[13:18:59.608]                           for (restart in restarts) {
[13:18:59.608]                             name <- restart$name
[13:18:59.608]                             if (is.null(name)) 
[13:18:59.608]                               next
[13:18:59.608]                             if (!grepl(pattern, name)) 
[13:18:59.608]                               next
[13:18:59.608]                             invokeRestart(restart)
[13:18:59.608]                             muffled <- TRUE
[13:18:59.608]                             break
[13:18:59.608]                           }
[13:18:59.608]                         }
[13:18:59.608]                       }
[13:18:59.608]                       invisible(muffled)
[13:18:59.608]                     }
[13:18:59.608]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.608]                   }
[13:18:59.608]                 }
[13:18:59.608]             }
[13:18:59.608]         }))
[13:18:59.608]     }, error = function(ex) {
[13:18:59.608]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.608]                 ...future.rng), started = ...future.startTime, 
[13:18:59.608]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.608]             version = "1.8"), class = "FutureResult")
[13:18:59.608]     }, finally = {
[13:18:59.608]         if (!identical(...future.workdir, getwd())) 
[13:18:59.608]             setwd(...future.workdir)
[13:18:59.608]         {
[13:18:59.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.608]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.608]             }
[13:18:59.608]             base::options(...future.oldOptions)
[13:18:59.608]             if (.Platform$OS.type == "windows") {
[13:18:59.608]                 old_names <- names(...future.oldEnvVars)
[13:18:59.608]                 envs <- base::Sys.getenv()
[13:18:59.608]                 names <- names(envs)
[13:18:59.608]                 common <- intersect(names, old_names)
[13:18:59.608]                 added <- setdiff(names, old_names)
[13:18:59.608]                 removed <- setdiff(old_names, names)
[13:18:59.608]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.608]                   envs[common]]
[13:18:59.608]                 NAMES <- toupper(changed)
[13:18:59.608]                 args <- list()
[13:18:59.608]                 for (kk in seq_along(NAMES)) {
[13:18:59.608]                   name <- changed[[kk]]
[13:18:59.608]                   NAME <- NAMES[[kk]]
[13:18:59.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.608]                     next
[13:18:59.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.608]                 }
[13:18:59.608]                 NAMES <- toupper(added)
[13:18:59.608]                 for (kk in seq_along(NAMES)) {
[13:18:59.608]                   name <- added[[kk]]
[13:18:59.608]                   NAME <- NAMES[[kk]]
[13:18:59.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.608]                     next
[13:18:59.608]                   args[[name]] <- ""
[13:18:59.608]                 }
[13:18:59.608]                 NAMES <- toupper(removed)
[13:18:59.608]                 for (kk in seq_along(NAMES)) {
[13:18:59.608]                   name <- removed[[kk]]
[13:18:59.608]                   NAME <- NAMES[[kk]]
[13:18:59.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.608]                     next
[13:18:59.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.608]                 }
[13:18:59.608]                 if (length(args) > 0) 
[13:18:59.608]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.608]             }
[13:18:59.608]             else {
[13:18:59.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.608]             }
[13:18:59.608]             {
[13:18:59.608]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.608]                   0L) {
[13:18:59.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.608]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.608]                   base::options(opts)
[13:18:59.608]                 }
[13:18:59.608]                 {
[13:18:59.608]                   {
[13:18:59.608]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.608]                     NULL
[13:18:59.608]                   }
[13:18:59.608]                   options(future.plan = NULL)
[13:18:59.608]                   if (is.na(NA_character_)) 
[13:18:59.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.608]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.608]                     envir = parent.frame()) 
[13:18:59.608]                   {
[13:18:59.608]                     default_workers <- missing(workers)
[13:18:59.608]                     if (is.function(workers)) 
[13:18:59.608]                       workers <- workers()
[13:18:59.608]                     workers <- structure(as.integer(workers), 
[13:18:59.608]                       class = class(workers))
[13:18:59.608]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.608]                       1L)
[13:18:59.608]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.608]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.608]                       if (default_workers) 
[13:18:59.608]                         supportsMulticore(warn = TRUE)
[13:18:59.608]                       return(sequential(..., envir = envir))
[13:18:59.608]                     }
[13:18:59.608]                     oopts <- options(mc.cores = workers)
[13:18:59.608]                     on.exit(options(oopts))
[13:18:59.608]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.608]                       envir = envir)
[13:18:59.608]                     if (!future$lazy) 
[13:18:59.608]                       future <- run(future)
[13:18:59.608]                     invisible(future)
[13:18:59.608]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.608]                 }
[13:18:59.608]             }
[13:18:59.608]         }
[13:18:59.608]     })
[13:18:59.608]     if (TRUE) {
[13:18:59.608]         base::sink(type = "output", split = FALSE)
[13:18:59.608]         if (TRUE) {
[13:18:59.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.608]         }
[13:18:59.608]         else {
[13:18:59.608]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.608]         }
[13:18:59.608]         base::close(...future.stdout)
[13:18:59.608]         ...future.stdout <- NULL
[13:18:59.608]     }
[13:18:59.608]     ...future.result$conditions <- ...future.conditions
[13:18:59.608]     ...future.result$finished <- base::Sys.time()
[13:18:59.608]     ...future.result
[13:18:59.608] }
[13:18:59.611] assign_globals() ...
[13:18:59.611] List of 11
[13:18:59.611]  $ ...future.FUN            :function (x, ...)  
[13:18:59.611]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:18:59.611]  $ times                    : int 5
[13:18:59.611]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.611]  $ stop_if_not              :function (...)  
[13:18:59.611]  $ dim                      : NULL
[13:18:59.611]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.611]  $ future.call.arguments    : list()
[13:18:59.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.611]  $ ...future.elements_ii    :List of 4
[13:18:59.611]   ..$ : int [1:3] 1 2 3
[13:18:59.611]   ..$ : int [1:4] 1 2 3 4
[13:18:59.611]   ..$ : int [1:5] 1 2 3 4 5
[13:18:59.611]   ..$ : int [1:6] 1 2 3 4 5 6
[13:18:59.611]  $ ...future.seeds_ii       : NULL
[13:18:59.611]  $ ...future.globals.maxSize: NULL
[13:18:59.611]  - attr(*, "resolved")= logi FALSE
[13:18:59.611]  - attr(*, "total_size")= num 141240
[13:18:59.611]  - attr(*, "where")=List of 11
[13:18:59.611]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.611]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.611]  - attr(*, "already-done")= logi TRUE
[13:18:59.621] - copied ‘...future.FUN’ to environment
[13:18:59.622] - copied ‘x_FUN’ to environment
[13:18:59.622] - copied ‘times’ to environment
[13:18:59.622] - copied ‘stopf’ to environment
[13:18:59.622] - copied ‘stop_if_not’ to environment
[13:18:59.622] - copied ‘dim’ to environment
[13:18:59.622] - copied ‘valid_types’ to environment
[13:18:59.622] - copied ‘future.call.arguments’ to environment
[13:18:59.622] - copied ‘...future.elements_ii’ to environment
[13:18:59.622] - copied ‘...future.seeds_ii’ to environment
[13:18:59.622] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.623] assign_globals() ... done
[13:18:59.623] requestCore(): workers = 2
[13:18:59.625] MulticoreFuture started
[13:18:59.626] - Launch lazy future ... done
[13:18:59.626] run() for ‘MulticoreFuture’ ... done
[13:18:59.627] Created future:
[13:18:59.628] plan(): Setting new future strategy stack:
[13:18:59.628] List of future strategies:
[13:18:59.628] 1. sequential:
[13:18:59.628]    - args: function (..., envir = parent.frame())
[13:18:59.628]    - tweaked: FALSE
[13:18:59.628]    - call: NULL
[13:18:59.630] plan(): nbrOfWorkers() = 1
[13:18:59.632] plan(): Setting new future strategy stack:
[13:18:59.633] List of future strategies:
[13:18:59.633] 1. multicore:
[13:18:59.633]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.633]    - tweaked: FALSE
[13:18:59.633]    - call: plan(strategy)
[13:18:59.638] plan(): nbrOfWorkers() = 2
[13:18:59.627] MulticoreFuture:
[13:18:59.627] Label: ‘future_vapply-1’
[13:18:59.627] Expression:
[13:18:59.627] {
[13:18:59.627]     do.call(function(...) {
[13:18:59.627]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.627]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.627]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.627]             on.exit(options(oopts), add = TRUE)
[13:18:59.627]         }
[13:18:59.627]         {
[13:18:59.627]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.627]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.627]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.627]             })
[13:18:59.627]         }
[13:18:59.627]     }, args = future.call.arguments)
[13:18:59.627] }
[13:18:59.627] Lazy evaluation: FALSE
[13:18:59.627] Asynchronous evaluation: TRUE
[13:18:59.627] Local evaluation: TRUE
[13:18:59.627] Environment: R_GlobalEnv
[13:18:59.627] Capture standard output: TRUE
[13:18:59.627] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.627] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.627] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:18:59.627] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.627] Resolved: TRUE
[13:18:59.627] Value: <not collected>
[13:18:59.627] Conditions captured: <none>
[13:18:59.627] Early signaling: FALSE
[13:18:59.627] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.627] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.639] Chunk #1 of 2 ... DONE
[13:18:59.639] Chunk #2 of 2 ...
[13:18:59.640]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.640] getGlobalsAndPackages() ...
[13:18:59.640] Searching for globals...
[13:18:59.640] 
[13:18:59.641] Searching for globals ... DONE
[13:18:59.641] - globals: [0] <none>
[13:18:59.641] getGlobalsAndPackages() ... DONE
[13:18:59.641]    + additional globals found: [n=0] 
[13:18:59.641]    + additional namespaces needed: [n=0] 
[13:18:59.641]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.641]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:18:59.642]  - seeds: <none>
[13:18:59.642] getGlobalsAndPackages() ...
[13:18:59.642] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.642] Resolving globals: FALSE
[13:18:59.643] Tweak future expression to call with '...' arguments ...
[13:18:59.643] {
[13:18:59.643]     do.call(function(...) {
[13:18:59.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.643]             on.exit(options(oopts), add = TRUE)
[13:18:59.643]         }
[13:18:59.643]         {
[13:18:59.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.643]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.643]             })
[13:18:59.643]         }
[13:18:59.643]     }, args = future.call.arguments)
[13:18:59.643] }
[13:18:59.643] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.645] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.645] - packages: [2] ‘stats’, ‘future.apply’
[13:18:59.645] getGlobalsAndPackages() ... DONE
[13:18:59.646] run() for ‘Future’ ...
[13:18:59.646] - state: ‘created’
[13:18:59.646] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.651]   - Field: ‘label’
[13:18:59.651]   - Field: ‘local’
[13:18:59.651]   - Field: ‘owner’
[13:18:59.651]   - Field: ‘envir’
[13:18:59.652]   - Field: ‘workers’
[13:18:59.652]   - Field: ‘packages’
[13:18:59.652]   - Field: ‘gc’
[13:18:59.652]   - Field: ‘job’
[13:18:59.652]   - Field: ‘conditions’
[13:18:59.652]   - Field: ‘expr’
[13:18:59.652]   - Field: ‘uuid’
[13:18:59.653]   - Field: ‘seed’
[13:18:59.653]   - Field: ‘version’
[13:18:59.653]   - Field: ‘result’
[13:18:59.653]   - Field: ‘asynchronous’
[13:18:59.653]   - Field: ‘calls’
[13:18:59.653]   - Field: ‘globals’
[13:18:59.653]   - Field: ‘stdout’
[13:18:59.653]   - Field: ‘earlySignal’
[13:18:59.654]   - Field: ‘lazy’
[13:18:59.654]   - Field: ‘state’
[13:18:59.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.654] - Launch lazy future ...
[13:18:59.654] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:18:59.655] Packages needed by future strategies (n = 0): <none>
[13:18:59.655] {
[13:18:59.655]     {
[13:18:59.655]         {
[13:18:59.655]             ...future.startTime <- base::Sys.time()
[13:18:59.655]             {
[13:18:59.655]                 {
[13:18:59.655]                   {
[13:18:59.655]                     {
[13:18:59.655]                       {
[13:18:59.655]                         base::local({
[13:18:59.655]                           has_future <- base::requireNamespace("future", 
[13:18:59.655]                             quietly = TRUE)
[13:18:59.655]                           if (has_future) {
[13:18:59.655]                             ns <- base::getNamespace("future")
[13:18:59.655]                             version <- ns[[".package"]][["version"]]
[13:18:59.655]                             if (is.null(version)) 
[13:18:59.655]                               version <- utils::packageVersion("future")
[13:18:59.655]                           }
[13:18:59.655]                           else {
[13:18:59.655]                             version <- NULL
[13:18:59.655]                           }
[13:18:59.655]                           if (!has_future || version < "1.8.0") {
[13:18:59.655]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.655]                               "", base::R.version$version.string), 
[13:18:59.655]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.655]                                 base::R.version$platform, 8 * 
[13:18:59.655]                                   base::.Machine$sizeof.pointer), 
[13:18:59.655]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.655]                                 "release", "version")], collapse = " "), 
[13:18:59.655]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.655]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.655]                               info)
[13:18:59.655]                             info <- base::paste(info, collapse = "; ")
[13:18:59.655]                             if (!has_future) {
[13:18:59.655]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.655]                                 info)
[13:18:59.655]                             }
[13:18:59.655]                             else {
[13:18:59.655]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.655]                                 info, version)
[13:18:59.655]                             }
[13:18:59.655]                             base::stop(msg)
[13:18:59.655]                           }
[13:18:59.655]                         })
[13:18:59.655]                       }
[13:18:59.655]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.655]                       base::options(mc.cores = 1L)
[13:18:59.655]                     }
[13:18:59.655]                     base::local({
[13:18:59.655]                       for (pkg in c("stats", "future.apply")) {
[13:18:59.655]                         base::loadNamespace(pkg)
[13:18:59.655]                         base::library(pkg, character.only = TRUE)
[13:18:59.655]                       }
[13:18:59.655]                     })
[13:18:59.655]                   }
[13:18:59.655]                   options(future.plan = NULL)
[13:18:59.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.655]                 }
[13:18:59.655]                 ...future.workdir <- getwd()
[13:18:59.655]             }
[13:18:59.655]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.655]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.655]         }
[13:18:59.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.655]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:18:59.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.655]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.655]             base::names(...future.oldOptions))
[13:18:59.655]     }
[13:18:59.655]     if (FALSE) {
[13:18:59.655]     }
[13:18:59.655]     else {
[13:18:59.655]         if (TRUE) {
[13:18:59.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.655]                 open = "w")
[13:18:59.655]         }
[13:18:59.655]         else {
[13:18:59.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.655]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.655]         }
[13:18:59.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.655]             base::sink(type = "output", split = FALSE)
[13:18:59.655]             base::close(...future.stdout)
[13:18:59.655]         }, add = TRUE)
[13:18:59.655]     }
[13:18:59.655]     ...future.frame <- base::sys.nframe()
[13:18:59.655]     ...future.conditions <- base::list()
[13:18:59.655]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.655]     if (FALSE) {
[13:18:59.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.655]     }
[13:18:59.655]     ...future.result <- base::tryCatch({
[13:18:59.655]         base::withCallingHandlers({
[13:18:59.655]             ...future.value <- base::withVisible(base::local({
[13:18:59.655]                 withCallingHandlers({
[13:18:59.655]                   {
[13:18:59.655]                     do.call(function(...) {
[13:18:59.655]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.655]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.655]                         ...future.globals.maxSize)) {
[13:18:59.655]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.655]                         on.exit(options(oopts), add = TRUE)
[13:18:59.655]                       }
[13:18:59.655]                       {
[13:18:59.655]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.655]                           FUN = function(jj) {
[13:18:59.655]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.655]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.655]                           })
[13:18:59.655]                       }
[13:18:59.655]                     }, args = future.call.arguments)
[13:18:59.655]                   }
[13:18:59.655]                 }, immediateCondition = function(cond) {
[13:18:59.655]                   save_rds <- function (object, pathname, ...) 
[13:18:59.655]                   {
[13:18:59.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.655]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.655]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.655]                         fi_tmp[["mtime"]])
[13:18:59.655]                     }
[13:18:59.655]                     tryCatch({
[13:18:59.655]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.655]                     }, error = function(ex) {
[13:18:59.655]                       msg <- conditionMessage(ex)
[13:18:59.655]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.655]                         fi_tmp[["mtime"]], msg)
[13:18:59.655]                       ex$message <- msg
[13:18:59.655]                       stop(ex)
[13:18:59.655]                     })
[13:18:59.655]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.655]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.655]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.655]                       fi <- file.info(pathname)
[13:18:59.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.655]                         fi[["size"]], fi[["mtime"]])
[13:18:59.655]                       stop(msg)
[13:18:59.655]                     }
[13:18:59.655]                     invisible(pathname)
[13:18:59.655]                   }
[13:18:59.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.655]                     rootPath = tempdir()) 
[13:18:59.655]                   {
[13:18:59.655]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.655]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.655]                       tmpdir = path, fileext = ".rds")
[13:18:59.655]                     save_rds(obj, file)
[13:18:59.655]                   }
[13:18:59.655]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.655]                   {
[13:18:59.655]                     inherits <- base::inherits
[13:18:59.655]                     invokeRestart <- base::invokeRestart
[13:18:59.655]                     is.null <- base::is.null
[13:18:59.655]                     muffled <- FALSE
[13:18:59.655]                     if (inherits(cond, "message")) {
[13:18:59.655]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.655]                       if (muffled) 
[13:18:59.655]                         invokeRestart("muffleMessage")
[13:18:59.655]                     }
[13:18:59.655]                     else if (inherits(cond, "warning")) {
[13:18:59.655]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.655]                       if (muffled) 
[13:18:59.655]                         invokeRestart("muffleWarning")
[13:18:59.655]                     }
[13:18:59.655]                     else if (inherits(cond, "condition")) {
[13:18:59.655]                       if (!is.null(pattern)) {
[13:18:59.655]                         computeRestarts <- base::computeRestarts
[13:18:59.655]                         grepl <- base::grepl
[13:18:59.655]                         restarts <- computeRestarts(cond)
[13:18:59.655]                         for (restart in restarts) {
[13:18:59.655]                           name <- restart$name
[13:18:59.655]                           if (is.null(name)) 
[13:18:59.655]                             next
[13:18:59.655]                           if (!grepl(pattern, name)) 
[13:18:59.655]                             next
[13:18:59.655]                           invokeRestart(restart)
[13:18:59.655]                           muffled <- TRUE
[13:18:59.655]                           break
[13:18:59.655]                         }
[13:18:59.655]                       }
[13:18:59.655]                     }
[13:18:59.655]                     invisible(muffled)
[13:18:59.655]                   }
[13:18:59.655]                   muffleCondition(cond)
[13:18:59.655]                 })
[13:18:59.655]             }))
[13:18:59.655]             future::FutureResult(value = ...future.value$value, 
[13:18:59.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.655]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.655]                     ...future.globalenv.names))
[13:18:59.655]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.655]         }, condition = base::local({
[13:18:59.655]             c <- base::c
[13:18:59.655]             inherits <- base::inherits
[13:18:59.655]             invokeRestart <- base::invokeRestart
[13:18:59.655]             length <- base::length
[13:18:59.655]             list <- base::list
[13:18:59.655]             seq.int <- base::seq.int
[13:18:59.655]             signalCondition <- base::signalCondition
[13:18:59.655]             sys.calls <- base::sys.calls
[13:18:59.655]             `[[` <- base::`[[`
[13:18:59.655]             `+` <- base::`+`
[13:18:59.655]             `<<-` <- base::`<<-`
[13:18:59.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.655]                   3L)]
[13:18:59.655]             }
[13:18:59.655]             function(cond) {
[13:18:59.655]                 is_error <- inherits(cond, "error")
[13:18:59.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.655]                   NULL)
[13:18:59.655]                 if (is_error) {
[13:18:59.655]                   sessionInformation <- function() {
[13:18:59.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.655]                       search = base::search(), system = base::Sys.info())
[13:18:59.655]                   }
[13:18:59.655]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.655]                     cond$call), session = sessionInformation(), 
[13:18:59.655]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.655]                   signalCondition(cond)
[13:18:59.655]                 }
[13:18:59.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.655]                 "immediateCondition"))) {
[13:18:59.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.655]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.655]                   if (TRUE && !signal) {
[13:18:59.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.655]                     {
[13:18:59.655]                       inherits <- base::inherits
[13:18:59.655]                       invokeRestart <- base::invokeRestart
[13:18:59.655]                       is.null <- base::is.null
[13:18:59.655]                       muffled <- FALSE
[13:18:59.655]                       if (inherits(cond, "message")) {
[13:18:59.655]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.655]                         if (muffled) 
[13:18:59.655]                           invokeRestart("muffleMessage")
[13:18:59.655]                       }
[13:18:59.655]                       else if (inherits(cond, "warning")) {
[13:18:59.655]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.655]                         if (muffled) 
[13:18:59.655]                           invokeRestart("muffleWarning")
[13:18:59.655]                       }
[13:18:59.655]                       else if (inherits(cond, "condition")) {
[13:18:59.655]                         if (!is.null(pattern)) {
[13:18:59.655]                           computeRestarts <- base::computeRestarts
[13:18:59.655]                           grepl <- base::grepl
[13:18:59.655]                           restarts <- computeRestarts(cond)
[13:18:59.655]                           for (restart in restarts) {
[13:18:59.655]                             name <- restart$name
[13:18:59.655]                             if (is.null(name)) 
[13:18:59.655]                               next
[13:18:59.655]                             if (!grepl(pattern, name)) 
[13:18:59.655]                               next
[13:18:59.655]                             invokeRestart(restart)
[13:18:59.655]                             muffled <- TRUE
[13:18:59.655]                             break
[13:18:59.655]                           }
[13:18:59.655]                         }
[13:18:59.655]                       }
[13:18:59.655]                       invisible(muffled)
[13:18:59.655]                     }
[13:18:59.655]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.655]                   }
[13:18:59.655]                 }
[13:18:59.655]                 else {
[13:18:59.655]                   if (TRUE) {
[13:18:59.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.655]                     {
[13:18:59.655]                       inherits <- base::inherits
[13:18:59.655]                       invokeRestart <- base::invokeRestart
[13:18:59.655]                       is.null <- base::is.null
[13:18:59.655]                       muffled <- FALSE
[13:18:59.655]                       if (inherits(cond, "message")) {
[13:18:59.655]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.655]                         if (muffled) 
[13:18:59.655]                           invokeRestart("muffleMessage")
[13:18:59.655]                       }
[13:18:59.655]                       else if (inherits(cond, "warning")) {
[13:18:59.655]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.655]                         if (muffled) 
[13:18:59.655]                           invokeRestart("muffleWarning")
[13:18:59.655]                       }
[13:18:59.655]                       else if (inherits(cond, "condition")) {
[13:18:59.655]                         if (!is.null(pattern)) {
[13:18:59.655]                           computeRestarts <- base::computeRestarts
[13:18:59.655]                           grepl <- base::grepl
[13:18:59.655]                           restarts <- computeRestarts(cond)
[13:18:59.655]                           for (restart in restarts) {
[13:18:59.655]                             name <- restart$name
[13:18:59.655]                             if (is.null(name)) 
[13:18:59.655]                               next
[13:18:59.655]                             if (!grepl(pattern, name)) 
[13:18:59.655]                               next
[13:18:59.655]                             invokeRestart(restart)
[13:18:59.655]                             muffled <- TRUE
[13:18:59.655]                             break
[13:18:59.655]                           }
[13:18:59.655]                         }
[13:18:59.655]                       }
[13:18:59.655]                       invisible(muffled)
[13:18:59.655]                     }
[13:18:59.655]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.655]                   }
[13:18:59.655]                 }
[13:18:59.655]             }
[13:18:59.655]         }))
[13:18:59.655]     }, error = function(ex) {
[13:18:59.655]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.655]                 ...future.rng), started = ...future.startTime, 
[13:18:59.655]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.655]             version = "1.8"), class = "FutureResult")
[13:18:59.655]     }, finally = {
[13:18:59.655]         if (!identical(...future.workdir, getwd())) 
[13:18:59.655]             setwd(...future.workdir)
[13:18:59.655]         {
[13:18:59.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.655]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.655]             }
[13:18:59.655]             base::options(...future.oldOptions)
[13:18:59.655]             if (.Platform$OS.type == "windows") {
[13:18:59.655]                 old_names <- names(...future.oldEnvVars)
[13:18:59.655]                 envs <- base::Sys.getenv()
[13:18:59.655]                 names <- names(envs)
[13:18:59.655]                 common <- intersect(names, old_names)
[13:18:59.655]                 added <- setdiff(names, old_names)
[13:18:59.655]                 removed <- setdiff(old_names, names)
[13:18:59.655]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.655]                   envs[common]]
[13:18:59.655]                 NAMES <- toupper(changed)
[13:18:59.655]                 args <- list()
[13:18:59.655]                 for (kk in seq_along(NAMES)) {
[13:18:59.655]                   name <- changed[[kk]]
[13:18:59.655]                   NAME <- NAMES[[kk]]
[13:18:59.655]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.655]                     next
[13:18:59.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.655]                 }
[13:18:59.655]                 NAMES <- toupper(added)
[13:18:59.655]                 for (kk in seq_along(NAMES)) {
[13:18:59.655]                   name <- added[[kk]]
[13:18:59.655]                   NAME <- NAMES[[kk]]
[13:18:59.655]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.655]                     next
[13:18:59.655]                   args[[name]] <- ""
[13:18:59.655]                 }
[13:18:59.655]                 NAMES <- toupper(removed)
[13:18:59.655]                 for (kk in seq_along(NAMES)) {
[13:18:59.655]                   name <- removed[[kk]]
[13:18:59.655]                   NAME <- NAMES[[kk]]
[13:18:59.655]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.655]                     next
[13:18:59.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.655]                 }
[13:18:59.655]                 if (length(args) > 0) 
[13:18:59.655]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.655]             }
[13:18:59.655]             else {
[13:18:59.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.655]             }
[13:18:59.655]             {
[13:18:59.655]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.655]                   0L) {
[13:18:59.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.655]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.655]                   base::options(opts)
[13:18:59.655]                 }
[13:18:59.655]                 {
[13:18:59.655]                   {
[13:18:59.655]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.655]                     NULL
[13:18:59.655]                   }
[13:18:59.655]                   options(future.plan = NULL)
[13:18:59.655]                   if (is.na(NA_character_)) 
[13:18:59.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.655]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.655]                     envir = parent.frame()) 
[13:18:59.655]                   {
[13:18:59.655]                     default_workers <- missing(workers)
[13:18:59.655]                     if (is.function(workers)) 
[13:18:59.655]                       workers <- workers()
[13:18:59.655]                     workers <- structure(as.integer(workers), 
[13:18:59.655]                       class = class(workers))
[13:18:59.655]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.655]                       1L)
[13:18:59.655]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.655]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.655]                       if (default_workers) 
[13:18:59.655]                         supportsMulticore(warn = TRUE)
[13:18:59.655]                       return(sequential(..., envir = envir))
[13:18:59.655]                     }
[13:18:59.655]                     oopts <- options(mc.cores = workers)
[13:18:59.655]                     on.exit(options(oopts))
[13:18:59.655]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.655]                       envir = envir)
[13:18:59.655]                     if (!future$lazy) 
[13:18:59.655]                       future <- run(future)
[13:18:59.655]                     invisible(future)
[13:18:59.655]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.655]                 }
[13:18:59.655]             }
[13:18:59.655]         }
[13:18:59.655]     })
[13:18:59.655]     if (TRUE) {
[13:18:59.655]         base::sink(type = "output", split = FALSE)
[13:18:59.655]         if (TRUE) {
[13:18:59.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.655]         }
[13:18:59.655]         else {
[13:18:59.655]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.655]         }
[13:18:59.655]         base::close(...future.stdout)
[13:18:59.655]         ...future.stdout <- NULL
[13:18:59.655]     }
[13:18:59.655]     ...future.result$conditions <- ...future.conditions
[13:18:59.655]     ...future.result$finished <- base::Sys.time()
[13:18:59.655]     ...future.result
[13:18:59.655] }
[13:18:59.659] assign_globals() ...
[13:18:59.659] List of 11
[13:18:59.659]  $ ...future.FUN            :function (x, ...)  
[13:18:59.659]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:18:59.659]  $ times                    : int 5
[13:18:59.659]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.659]  $ stop_if_not              :function (...)  
[13:18:59.659]  $ dim                      : NULL
[13:18:59.659]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.659]  $ future.call.arguments    : list()
[13:18:59.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.659]  $ ...future.elements_ii    :List of 3
[13:18:59.659]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:18:59.659]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:18:59.659]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:18:59.659]  $ ...future.seeds_ii       : NULL
[13:18:59.659]  $ ...future.globals.maxSize: NULL
[13:18:59.659]  - attr(*, "resolved")= logi FALSE
[13:18:59.659]  - attr(*, "total_size")= num 141240
[13:18:59.659]  - attr(*, "where")=List of 11
[13:18:59.659]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.659]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.659]  - attr(*, "already-done")= logi TRUE
[13:18:59.674] - copied ‘...future.FUN’ to environment
[13:18:59.674] - copied ‘x_FUN’ to environment
[13:18:59.674] - copied ‘times’ to environment
[13:18:59.674] - copied ‘stopf’ to environment
[13:18:59.674] - copied ‘stop_if_not’ to environment
[13:18:59.674] - copied ‘dim’ to environment
[13:18:59.674] - copied ‘valid_types’ to environment
[13:18:59.674] - copied ‘future.call.arguments’ to environment
[13:18:59.674] - copied ‘...future.elements_ii’ to environment
[13:18:59.675] - copied ‘...future.seeds_ii’ to environment
[13:18:59.675] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.675] assign_globals() ... done
[13:18:59.675] requestCore(): workers = 2
[13:18:59.677] MulticoreFuture started
[13:18:59.678] - Launch lazy future ... done
[13:18:59.678] run() for ‘MulticoreFuture’ ... done
[13:18:59.678] Created future:
[13:18:59.679] plan(): Setting new future strategy stack:
[13:18:59.679] List of future strategies:
[13:18:59.679] 1. sequential:
[13:18:59.679]    - args: function (..., envir = parent.frame())
[13:18:59.679]    - tweaked: FALSE
[13:18:59.679]    - call: NULL
[13:18:59.680] plan(): nbrOfWorkers() = 1
[13:18:59.683] plan(): Setting new future strategy stack:
[13:18:59.683] List of future strategies:
[13:18:59.683] 1. multicore:
[13:18:59.683]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.683]    - tweaked: FALSE
[13:18:59.683]    - call: plan(strategy)
[13:18:59.688] plan(): nbrOfWorkers() = 2
[13:18:59.678] MulticoreFuture:
[13:18:59.678] Label: ‘future_vapply-2’
[13:18:59.678] Expression:
[13:18:59.678] {
[13:18:59.678]     do.call(function(...) {
[13:18:59.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.678]             on.exit(options(oopts), add = TRUE)
[13:18:59.678]         }
[13:18:59.678]         {
[13:18:59.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.678]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.678]             })
[13:18:59.678]         }
[13:18:59.678]     }, args = future.call.arguments)
[13:18:59.678] }
[13:18:59.678] Lazy evaluation: FALSE
[13:18:59.678] Asynchronous evaluation: TRUE
[13:18:59.678] Local evaluation: TRUE
[13:18:59.678] Environment: R_GlobalEnv
[13:18:59.678] Capture standard output: TRUE
[13:18:59.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.678] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.678] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:18:59.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.678] Resolved: TRUE
[13:18:59.678] Value: <not collected>
[13:18:59.678] Conditions captured: <none>
[13:18:59.678] Early signaling: FALSE
[13:18:59.678] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.678] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.689] Chunk #2 of 2 ... DONE
[13:18:59.689] Launching 2 futures (chunks) ... DONE
[13:18:59.690] Resolving 2 futures (chunks) ...
[13:18:59.690] resolve() on list ...
[13:18:59.690]  recursive: 0
[13:18:59.690]  length: 2
[13:18:59.690] 
[13:18:59.690] Future #1
[13:18:59.691] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.692] - nx: 2
[13:18:59.692] - relay: TRUE
[13:18:59.692] - stdout: TRUE
[13:18:59.692] - signal: TRUE
[13:18:59.692] - resignal: FALSE
[13:18:59.692] - force: TRUE
[13:18:59.692] - relayed: [n=2] FALSE, FALSE
[13:18:59.693] - queued futures: [n=2] FALSE, FALSE
[13:18:59.693]  - until=1
[13:18:59.693]  - relaying element #1
[13:18:59.693] - relayed: [n=2] TRUE, FALSE
[13:18:59.693] - queued futures: [n=2] TRUE, FALSE
[13:18:59.694] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.694]  length: 1 (resolved future 1)
[13:18:59.694] Future #2
[13:18:59.695] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.695] - nx: 2
[13:18:59.695] - relay: TRUE
[13:18:59.696] - stdout: TRUE
[13:18:59.696] - signal: TRUE
[13:18:59.696] - resignal: FALSE
[13:18:59.696] - force: TRUE
[13:18:59.696] - relayed: [n=2] TRUE, FALSE
[13:18:59.697] - queued futures: [n=2] TRUE, FALSE
[13:18:59.697]  - until=2
[13:18:59.697]  - relaying element #2
[13:18:59.697] - relayed: [n=2] TRUE, TRUE
[13:18:59.697] - queued futures: [n=2] TRUE, TRUE
[13:18:59.698] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.698]  length: 0 (resolved future 2)
[13:18:59.698] Relaying remaining futures
[13:18:59.698] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.698] - nx: 2
[13:18:59.698] - relay: TRUE
[13:18:59.698] - stdout: TRUE
[13:18:59.698] - signal: TRUE
[13:18:59.699] - resignal: FALSE
[13:18:59.699] - force: TRUE
[13:18:59.699] - relayed: [n=2] TRUE, TRUE
[13:18:59.699] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.699] - relayed: [n=2] TRUE, TRUE
[13:18:59.699] - queued futures: [n=2] TRUE, TRUE
[13:18:59.699] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.699] resolve() on list ... DONE
[13:18:59.700]  - Number of value chunks collected: 2
[13:18:59.700] Resolving 2 futures (chunks) ... DONE
[13:18:59.700] Reducing values from 2 chunks ...
[13:18:59.700]  - Number of values collected after concatenation: 7
[13:18:59.700]  - Number of values expected: 7
[13:18:59.700] Reducing values from 2 chunks ... DONE
[13:18:59.700] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:18:59.703] future_lapply() ...
[13:18:59.710] Number of chunks: 2
[13:18:59.711] getGlobalsAndPackagesXApply() ...
[13:18:59.711]  - future.globals: TRUE
[13:18:59.711] getGlobalsAndPackages() ...
[13:18:59.711] Searching for globals...
[13:18:59.713] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:18:59.713] Searching for globals ... DONE
[13:18:59.713] Resolving globals: FALSE
[13:18:59.714] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:18:59.714] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:18:59.715] - globals: [1] ‘FUN’
[13:18:59.715] 
[13:18:59.715] getGlobalsAndPackages() ... DONE
[13:18:59.715]  - globals found/used: [n=1] ‘FUN’
[13:18:59.715]  - needed namespaces: [n=0] 
[13:18:59.715] Finding globals ... DONE
[13:18:59.715]  - use_args: TRUE
[13:18:59.716]  - Getting '...' globals ...
[13:18:59.716] resolve() on list ...
[13:18:59.716]  recursive: 0
[13:18:59.716]  length: 1
[13:18:59.716]  elements: ‘...’
[13:18:59.716]  length: 0 (resolved future 1)
[13:18:59.717] resolve() on list ... DONE
[13:18:59.717]    - '...' content: [n=1] ‘y’
[13:18:59.717] List of 1
[13:18:59.717]  $ ...:List of 1
[13:18:59.717]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.717]  - attr(*, "where")=List of 1
[13:18:59.717]   ..$ ...:<environment: 0x555f7b7fdc80> 
[13:18:59.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.717]  - attr(*, "resolved")= logi TRUE
[13:18:59.717]  - attr(*, "total_size")= num NA
[13:18:59.720]  - Getting '...' globals ... DONE
[13:18:59.720] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:18:59.720] List of 2
[13:18:59.720]  $ ...future.FUN:function (x, y)  
[13:18:59.720]  $ ...          :List of 1
[13:18:59.720]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.720]  - attr(*, "where")=List of 2
[13:18:59.720]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.720]   ..$ ...          :<environment: 0x555f7b7fdc80> 
[13:18:59.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.720]  - attr(*, "resolved")= logi FALSE
[13:18:59.720]  - attr(*, "total_size")= num 4264
[13:18:59.724] Packages to be attached in all futures: [n=0] 
[13:18:59.724] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.724] Number of futures (= number of chunks): 2
[13:18:59.724] Launching 2 futures (chunks) ...
[13:18:59.724] Chunk #1 of 2 ...
[13:18:59.724]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.724] getGlobalsAndPackages() ...
[13:18:59.724] Searching for globals...
[13:18:59.725] 
[13:18:59.725] Searching for globals ... DONE
[13:18:59.725] - globals: [0] <none>
[13:18:59.725] getGlobalsAndPackages() ... DONE
[13:18:59.725]    + additional globals found: [n=0] 
[13:18:59.725]    + additional namespaces needed: [n=0] 
[13:18:59.725]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.725]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:18:59.726]  - seeds: <none>
[13:18:59.726] getGlobalsAndPackages() ...
[13:18:59.726] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.726] Resolving globals: FALSE
[13:18:59.726] Tweak future expression to call with '...' arguments ...
[13:18:59.726] {
[13:18:59.726]     do.call(function(...) {
[13:18:59.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.726]             on.exit(options(oopts), add = TRUE)
[13:18:59.726]         }
[13:18:59.726]         {
[13:18:59.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.726]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.726]             })
[13:18:59.726]         }
[13:18:59.726]     }, args = future.call.arguments)
[13:18:59.726] }
[13:18:59.726] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.727] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.727] 
[13:18:59.727] getGlobalsAndPackages() ... DONE
[13:18:59.727] run() for ‘Future’ ...
[13:18:59.727] - state: ‘created’
[13:18:59.728] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.735] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.735] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.736]   - Field: ‘label’
[13:18:59.736]   - Field: ‘local’
[13:18:59.736]   - Field: ‘owner’
[13:18:59.736]   - Field: ‘envir’
[13:18:59.736]   - Field: ‘workers’
[13:18:59.736]   - Field: ‘packages’
[13:18:59.736]   - Field: ‘gc’
[13:18:59.736]   - Field: ‘job’
[13:18:59.736]   - Field: ‘conditions’
[13:18:59.736]   - Field: ‘expr’
[13:18:59.737]   - Field: ‘uuid’
[13:18:59.737]   - Field: ‘seed’
[13:18:59.737]   - Field: ‘version’
[13:18:59.737]   - Field: ‘result’
[13:18:59.737]   - Field: ‘asynchronous’
[13:18:59.737]   - Field: ‘calls’
[13:18:59.737]   - Field: ‘globals’
[13:18:59.737]   - Field: ‘stdout’
[13:18:59.737]   - Field: ‘earlySignal’
[13:18:59.738]   - Field: ‘lazy’
[13:18:59.738]   - Field: ‘state’
[13:18:59.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.738] - Launch lazy future ...
[13:18:59.738] Packages needed by the future expression (n = 0): <none>
[13:18:59.738] Packages needed by future strategies (n = 0): <none>
[13:18:59.739] {
[13:18:59.739]     {
[13:18:59.739]         {
[13:18:59.739]             ...future.startTime <- base::Sys.time()
[13:18:59.739]             {
[13:18:59.739]                 {
[13:18:59.739]                   {
[13:18:59.739]                     {
[13:18:59.739]                       base::local({
[13:18:59.739]                         has_future <- base::requireNamespace("future", 
[13:18:59.739]                           quietly = TRUE)
[13:18:59.739]                         if (has_future) {
[13:18:59.739]                           ns <- base::getNamespace("future")
[13:18:59.739]                           version <- ns[[".package"]][["version"]]
[13:18:59.739]                           if (is.null(version)) 
[13:18:59.739]                             version <- utils::packageVersion("future")
[13:18:59.739]                         }
[13:18:59.739]                         else {
[13:18:59.739]                           version <- NULL
[13:18:59.739]                         }
[13:18:59.739]                         if (!has_future || version < "1.8.0") {
[13:18:59.739]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.739]                             "", base::R.version$version.string), 
[13:18:59.739]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:59.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:59.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.739]                               "release", "version")], collapse = " "), 
[13:18:59.739]                             hostname = base::Sys.info()[["nodename"]])
[13:18:59.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.739]                             info)
[13:18:59.739]                           info <- base::paste(info, collapse = "; ")
[13:18:59.739]                           if (!has_future) {
[13:18:59.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.739]                               info)
[13:18:59.739]                           }
[13:18:59.739]                           else {
[13:18:59.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.739]                               info, version)
[13:18:59.739]                           }
[13:18:59.739]                           base::stop(msg)
[13:18:59.739]                         }
[13:18:59.739]                       })
[13:18:59.739]                     }
[13:18:59.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.739]                     base::options(mc.cores = 1L)
[13:18:59.739]                   }
[13:18:59.739]                   options(future.plan = NULL)
[13:18:59.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.739]                 }
[13:18:59.739]                 ...future.workdir <- getwd()
[13:18:59.739]             }
[13:18:59.739]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.739]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.739]         }
[13:18:59.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.739]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:18:59.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.739]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.739]             base::names(...future.oldOptions))
[13:18:59.739]     }
[13:18:59.739]     if (FALSE) {
[13:18:59.739]     }
[13:18:59.739]     else {
[13:18:59.739]         if (TRUE) {
[13:18:59.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.739]                 open = "w")
[13:18:59.739]         }
[13:18:59.739]         else {
[13:18:59.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.739]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.739]         }
[13:18:59.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.739]             base::sink(type = "output", split = FALSE)
[13:18:59.739]             base::close(...future.stdout)
[13:18:59.739]         }, add = TRUE)
[13:18:59.739]     }
[13:18:59.739]     ...future.frame <- base::sys.nframe()
[13:18:59.739]     ...future.conditions <- base::list()
[13:18:59.739]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.739]     if (FALSE) {
[13:18:59.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.739]     }
[13:18:59.739]     ...future.result <- base::tryCatch({
[13:18:59.739]         base::withCallingHandlers({
[13:18:59.739]             ...future.value <- base::withVisible(base::local({
[13:18:59.739]                 withCallingHandlers({
[13:18:59.739]                   {
[13:18:59.739]                     do.call(function(...) {
[13:18:59.739]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.739]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.739]                         ...future.globals.maxSize)) {
[13:18:59.739]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.739]                         on.exit(options(oopts), add = TRUE)
[13:18:59.739]                       }
[13:18:59.739]                       {
[13:18:59.739]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.739]                           FUN = function(jj) {
[13:18:59.739]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.739]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.739]                           })
[13:18:59.739]                       }
[13:18:59.739]                     }, args = future.call.arguments)
[13:18:59.739]                   }
[13:18:59.739]                 }, immediateCondition = function(cond) {
[13:18:59.739]                   save_rds <- function (object, pathname, ...) 
[13:18:59.739]                   {
[13:18:59.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.739]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.739]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.739]                         fi_tmp[["mtime"]])
[13:18:59.739]                     }
[13:18:59.739]                     tryCatch({
[13:18:59.739]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.739]                     }, error = function(ex) {
[13:18:59.739]                       msg <- conditionMessage(ex)
[13:18:59.739]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.739]                         fi_tmp[["mtime"]], msg)
[13:18:59.739]                       ex$message <- msg
[13:18:59.739]                       stop(ex)
[13:18:59.739]                     })
[13:18:59.739]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.739]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.739]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.739]                       fi <- file.info(pathname)
[13:18:59.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.739]                         fi[["size"]], fi[["mtime"]])
[13:18:59.739]                       stop(msg)
[13:18:59.739]                     }
[13:18:59.739]                     invisible(pathname)
[13:18:59.739]                   }
[13:18:59.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.739]                     rootPath = tempdir()) 
[13:18:59.739]                   {
[13:18:59.739]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.739]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.739]                       tmpdir = path, fileext = ".rds")
[13:18:59.739]                     save_rds(obj, file)
[13:18:59.739]                   }
[13:18:59.739]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.739]                   {
[13:18:59.739]                     inherits <- base::inherits
[13:18:59.739]                     invokeRestart <- base::invokeRestart
[13:18:59.739]                     is.null <- base::is.null
[13:18:59.739]                     muffled <- FALSE
[13:18:59.739]                     if (inherits(cond, "message")) {
[13:18:59.739]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.739]                       if (muffled) 
[13:18:59.739]                         invokeRestart("muffleMessage")
[13:18:59.739]                     }
[13:18:59.739]                     else if (inherits(cond, "warning")) {
[13:18:59.739]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.739]                       if (muffled) 
[13:18:59.739]                         invokeRestart("muffleWarning")
[13:18:59.739]                     }
[13:18:59.739]                     else if (inherits(cond, "condition")) {
[13:18:59.739]                       if (!is.null(pattern)) {
[13:18:59.739]                         computeRestarts <- base::computeRestarts
[13:18:59.739]                         grepl <- base::grepl
[13:18:59.739]                         restarts <- computeRestarts(cond)
[13:18:59.739]                         for (restart in restarts) {
[13:18:59.739]                           name <- restart$name
[13:18:59.739]                           if (is.null(name)) 
[13:18:59.739]                             next
[13:18:59.739]                           if (!grepl(pattern, name)) 
[13:18:59.739]                             next
[13:18:59.739]                           invokeRestart(restart)
[13:18:59.739]                           muffled <- TRUE
[13:18:59.739]                           break
[13:18:59.739]                         }
[13:18:59.739]                       }
[13:18:59.739]                     }
[13:18:59.739]                     invisible(muffled)
[13:18:59.739]                   }
[13:18:59.739]                   muffleCondition(cond)
[13:18:59.739]                 })
[13:18:59.739]             }))
[13:18:59.739]             future::FutureResult(value = ...future.value$value, 
[13:18:59.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.739]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.739]                     ...future.globalenv.names))
[13:18:59.739]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.739]         }, condition = base::local({
[13:18:59.739]             c <- base::c
[13:18:59.739]             inherits <- base::inherits
[13:18:59.739]             invokeRestart <- base::invokeRestart
[13:18:59.739]             length <- base::length
[13:18:59.739]             list <- base::list
[13:18:59.739]             seq.int <- base::seq.int
[13:18:59.739]             signalCondition <- base::signalCondition
[13:18:59.739]             sys.calls <- base::sys.calls
[13:18:59.739]             `[[` <- base::`[[`
[13:18:59.739]             `+` <- base::`+`
[13:18:59.739]             `<<-` <- base::`<<-`
[13:18:59.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.739]                   3L)]
[13:18:59.739]             }
[13:18:59.739]             function(cond) {
[13:18:59.739]                 is_error <- inherits(cond, "error")
[13:18:59.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.739]                   NULL)
[13:18:59.739]                 if (is_error) {
[13:18:59.739]                   sessionInformation <- function() {
[13:18:59.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.739]                       search = base::search(), system = base::Sys.info())
[13:18:59.739]                   }
[13:18:59.739]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.739]                     cond$call), session = sessionInformation(), 
[13:18:59.739]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.739]                   signalCondition(cond)
[13:18:59.739]                 }
[13:18:59.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.739]                 "immediateCondition"))) {
[13:18:59.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.739]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.739]                   if (TRUE && !signal) {
[13:18:59.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.739]                     {
[13:18:59.739]                       inherits <- base::inherits
[13:18:59.739]                       invokeRestart <- base::invokeRestart
[13:18:59.739]                       is.null <- base::is.null
[13:18:59.739]                       muffled <- FALSE
[13:18:59.739]                       if (inherits(cond, "message")) {
[13:18:59.739]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.739]                         if (muffled) 
[13:18:59.739]                           invokeRestart("muffleMessage")
[13:18:59.739]                       }
[13:18:59.739]                       else if (inherits(cond, "warning")) {
[13:18:59.739]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.739]                         if (muffled) 
[13:18:59.739]                           invokeRestart("muffleWarning")
[13:18:59.739]                       }
[13:18:59.739]                       else if (inherits(cond, "condition")) {
[13:18:59.739]                         if (!is.null(pattern)) {
[13:18:59.739]                           computeRestarts <- base::computeRestarts
[13:18:59.739]                           grepl <- base::grepl
[13:18:59.739]                           restarts <- computeRestarts(cond)
[13:18:59.739]                           for (restart in restarts) {
[13:18:59.739]                             name <- restart$name
[13:18:59.739]                             if (is.null(name)) 
[13:18:59.739]                               next
[13:18:59.739]                             if (!grepl(pattern, name)) 
[13:18:59.739]                               next
[13:18:59.739]                             invokeRestart(restart)
[13:18:59.739]                             muffled <- TRUE
[13:18:59.739]                             break
[13:18:59.739]                           }
[13:18:59.739]                         }
[13:18:59.739]                       }
[13:18:59.739]                       invisible(muffled)
[13:18:59.739]                     }
[13:18:59.739]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.739]                   }
[13:18:59.739]                 }
[13:18:59.739]                 else {
[13:18:59.739]                   if (TRUE) {
[13:18:59.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.739]                     {
[13:18:59.739]                       inherits <- base::inherits
[13:18:59.739]                       invokeRestart <- base::invokeRestart
[13:18:59.739]                       is.null <- base::is.null
[13:18:59.739]                       muffled <- FALSE
[13:18:59.739]                       if (inherits(cond, "message")) {
[13:18:59.739]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.739]                         if (muffled) 
[13:18:59.739]                           invokeRestart("muffleMessage")
[13:18:59.739]                       }
[13:18:59.739]                       else if (inherits(cond, "warning")) {
[13:18:59.739]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.739]                         if (muffled) 
[13:18:59.739]                           invokeRestart("muffleWarning")
[13:18:59.739]                       }
[13:18:59.739]                       else if (inherits(cond, "condition")) {
[13:18:59.739]                         if (!is.null(pattern)) {
[13:18:59.739]                           computeRestarts <- base::computeRestarts
[13:18:59.739]                           grepl <- base::grepl
[13:18:59.739]                           restarts <- computeRestarts(cond)
[13:18:59.739]                           for (restart in restarts) {
[13:18:59.739]                             name <- restart$name
[13:18:59.739]                             if (is.null(name)) 
[13:18:59.739]                               next
[13:18:59.739]                             if (!grepl(pattern, name)) 
[13:18:59.739]                               next
[13:18:59.739]                             invokeRestart(restart)
[13:18:59.739]                             muffled <- TRUE
[13:18:59.739]                             break
[13:18:59.739]                           }
[13:18:59.739]                         }
[13:18:59.739]                       }
[13:18:59.739]                       invisible(muffled)
[13:18:59.739]                     }
[13:18:59.739]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.739]                   }
[13:18:59.739]                 }
[13:18:59.739]             }
[13:18:59.739]         }))
[13:18:59.739]     }, error = function(ex) {
[13:18:59.739]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.739]                 ...future.rng), started = ...future.startTime, 
[13:18:59.739]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.739]             version = "1.8"), class = "FutureResult")
[13:18:59.739]     }, finally = {
[13:18:59.739]         if (!identical(...future.workdir, getwd())) 
[13:18:59.739]             setwd(...future.workdir)
[13:18:59.739]         {
[13:18:59.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.739]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.739]             }
[13:18:59.739]             base::options(...future.oldOptions)
[13:18:59.739]             if (.Platform$OS.type == "windows") {
[13:18:59.739]                 old_names <- names(...future.oldEnvVars)
[13:18:59.739]                 envs <- base::Sys.getenv()
[13:18:59.739]                 names <- names(envs)
[13:18:59.739]                 common <- intersect(names, old_names)
[13:18:59.739]                 added <- setdiff(names, old_names)
[13:18:59.739]                 removed <- setdiff(old_names, names)
[13:18:59.739]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.739]                   envs[common]]
[13:18:59.739]                 NAMES <- toupper(changed)
[13:18:59.739]                 args <- list()
[13:18:59.739]                 for (kk in seq_along(NAMES)) {
[13:18:59.739]                   name <- changed[[kk]]
[13:18:59.739]                   NAME <- NAMES[[kk]]
[13:18:59.739]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.739]                     next
[13:18:59.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.739]                 }
[13:18:59.739]                 NAMES <- toupper(added)
[13:18:59.739]                 for (kk in seq_along(NAMES)) {
[13:18:59.739]                   name <- added[[kk]]
[13:18:59.739]                   NAME <- NAMES[[kk]]
[13:18:59.739]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.739]                     next
[13:18:59.739]                   args[[name]] <- ""
[13:18:59.739]                 }
[13:18:59.739]                 NAMES <- toupper(removed)
[13:18:59.739]                 for (kk in seq_along(NAMES)) {
[13:18:59.739]                   name <- removed[[kk]]
[13:18:59.739]                   NAME <- NAMES[[kk]]
[13:18:59.739]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.739]                     next
[13:18:59.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.739]                 }
[13:18:59.739]                 if (length(args) > 0) 
[13:18:59.739]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.739]             }
[13:18:59.739]             else {
[13:18:59.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.739]             }
[13:18:59.739]             {
[13:18:59.739]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.739]                   0L) {
[13:18:59.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.739]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.739]                   base::options(opts)
[13:18:59.739]                 }
[13:18:59.739]                 {
[13:18:59.739]                   {
[13:18:59.739]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.739]                     NULL
[13:18:59.739]                   }
[13:18:59.739]                   options(future.plan = NULL)
[13:18:59.739]                   if (is.na(NA_character_)) 
[13:18:59.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.739]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.739]                     envir = parent.frame()) 
[13:18:59.739]                   {
[13:18:59.739]                     default_workers <- missing(workers)
[13:18:59.739]                     if (is.function(workers)) 
[13:18:59.739]                       workers <- workers()
[13:18:59.739]                     workers <- structure(as.integer(workers), 
[13:18:59.739]                       class = class(workers))
[13:18:59.739]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.739]                       1L)
[13:18:59.739]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.739]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.739]                       if (default_workers) 
[13:18:59.739]                         supportsMulticore(warn = TRUE)
[13:18:59.739]                       return(sequential(..., envir = envir))
[13:18:59.739]                     }
[13:18:59.739]                     oopts <- options(mc.cores = workers)
[13:18:59.739]                     on.exit(options(oopts))
[13:18:59.739]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.739]                       envir = envir)
[13:18:59.739]                     if (!future$lazy) 
[13:18:59.739]                       future <- run(future)
[13:18:59.739]                     invisible(future)
[13:18:59.739]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.739]                 }
[13:18:59.739]             }
[13:18:59.739]         }
[13:18:59.739]     })
[13:18:59.739]     if (TRUE) {
[13:18:59.739]         base::sink(type = "output", split = FALSE)
[13:18:59.739]         if (TRUE) {
[13:18:59.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.739]         }
[13:18:59.739]         else {
[13:18:59.739]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.739]         }
[13:18:59.739]         base::close(...future.stdout)
[13:18:59.739]         ...future.stdout <- NULL
[13:18:59.739]     }
[13:18:59.739]     ...future.result$conditions <- ...future.conditions
[13:18:59.739]     ...future.result$finished <- base::Sys.time()
[13:18:59.739]     ...future.result
[13:18:59.739] }
[13:18:59.742] assign_globals() ...
[13:18:59.742] List of 5
[13:18:59.742]  $ ...future.FUN            :function (x, y)  
[13:18:59.742]  $ future.call.arguments    :List of 1
[13:18:59.742]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.742]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.742]  $ ...future.elements_ii    :List of 2
[13:18:59.742]   ..$ A: num 50
[13:18:59.742]   ..$ B: num 60
[13:18:59.742]  $ ...future.seeds_ii       : NULL
[13:18:59.742]  $ ...future.globals.maxSize: NULL
[13:18:59.742]  - attr(*, "resolved")= logi FALSE
[13:18:59.742]  - attr(*, "total_size")= num 4264
[13:18:59.742]  - attr(*, "where")=List of 5
[13:18:59.742]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.742]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.742]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.742]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.742]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.742]  - attr(*, "already-done")= logi TRUE
[13:18:59.748] - reassign environment for ‘...future.FUN’
[13:18:59.748] - copied ‘...future.FUN’ to environment
[13:18:59.748] - copied ‘future.call.arguments’ to environment
[13:18:59.748] - copied ‘...future.elements_ii’ to environment
[13:18:59.748] - copied ‘...future.seeds_ii’ to environment
[13:18:59.748] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.748] assign_globals() ... done
[13:18:59.749] requestCore(): workers = 2
[13:18:59.751] MulticoreFuture started
[13:18:59.751] - Launch lazy future ... done
[13:18:59.752] run() for ‘MulticoreFuture’ ... done
[13:18:59.752] Created future:
[13:18:59.752] plan(): Setting new future strategy stack:
[13:18:59.752] List of future strategies:
[13:18:59.752] 1. sequential:
[13:18:59.752]    - args: function (..., envir = parent.frame())
[13:18:59.752]    - tweaked: FALSE
[13:18:59.752]    - call: NULL
[13:18:59.753] plan(): nbrOfWorkers() = 1
[13:18:59.755] plan(): Setting new future strategy stack:
[13:18:59.756] List of future strategies:
[13:18:59.756] 1. multicore:
[13:18:59.756]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.756]    - tweaked: FALSE
[13:18:59.756]    - call: plan(strategy)
[13:18:59.761] plan(): nbrOfWorkers() = 2
[13:18:59.752] MulticoreFuture:
[13:18:59.752] Label: ‘future_sapply-1’
[13:18:59.752] Expression:
[13:18:59.752] {
[13:18:59.752]     do.call(function(...) {
[13:18:59.752]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.752]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.752]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.752]             on.exit(options(oopts), add = TRUE)
[13:18:59.752]         }
[13:18:59.752]         {
[13:18:59.752]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.752]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.752]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.752]             })
[13:18:59.752]         }
[13:18:59.752]     }, args = future.call.arguments)
[13:18:59.752] }
[13:18:59.752] Lazy evaluation: FALSE
[13:18:59.752] Asynchronous evaluation: TRUE
[13:18:59.752] Local evaluation: TRUE
[13:18:59.752] Environment: R_GlobalEnv
[13:18:59.752] Capture standard output: TRUE
[13:18:59.752] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.752] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:18:59.752] Packages: <none>
[13:18:59.752] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.752] Resolved: TRUE
[13:18:59.752] Value: <not collected>
[13:18:59.752] Conditions captured: <none>
[13:18:59.752] Early signaling: FALSE
[13:18:59.752] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.752] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.762] Chunk #1 of 2 ... DONE
[13:18:59.762] Chunk #2 of 2 ...
[13:18:59.762]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.762] getGlobalsAndPackages() ...
[13:18:59.763] Searching for globals...
[13:18:59.763] 
[13:18:59.763] Searching for globals ... DONE
[13:18:59.763] - globals: [0] <none>
[13:18:59.763] getGlobalsAndPackages() ... DONE
[13:18:59.764]    + additional globals found: [n=0] 
[13:18:59.764]    + additional namespaces needed: [n=0] 
[13:18:59.764]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.764]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:18:59.764]  - seeds: <none>
[13:18:59.764] getGlobalsAndPackages() ...
[13:18:59.764] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.765] Resolving globals: FALSE
[13:18:59.765] Tweak future expression to call with '...' arguments ...
[13:18:59.765] {
[13:18:59.765]     do.call(function(...) {
[13:18:59.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.765]             on.exit(options(oopts), add = TRUE)
[13:18:59.765]         }
[13:18:59.765]         {
[13:18:59.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.765]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.765]             })
[13:18:59.765]         }
[13:18:59.765]     }, args = future.call.arguments)
[13:18:59.765] }
[13:18:59.766] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.766] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.766] 
[13:18:59.766] getGlobalsAndPackages() ... DONE
[13:18:59.767] run() for ‘Future’ ...
[13:18:59.767] - state: ‘created’
[13:18:59.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.772] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.773]   - Field: ‘label’
[13:18:59.773]   - Field: ‘local’
[13:18:59.773]   - Field: ‘owner’
[13:18:59.773]   - Field: ‘envir’
[13:18:59.773]   - Field: ‘workers’
[13:18:59.773]   - Field: ‘packages’
[13:18:59.774]   - Field: ‘gc’
[13:18:59.774]   - Field: ‘job’
[13:18:59.774]   - Field: ‘conditions’
[13:18:59.774]   - Field: ‘expr’
[13:18:59.774]   - Field: ‘uuid’
[13:18:59.774]   - Field: ‘seed’
[13:18:59.775]   - Field: ‘version’
[13:18:59.775]   - Field: ‘result’
[13:18:59.775]   - Field: ‘asynchronous’
[13:18:59.775]   - Field: ‘calls’
[13:18:59.775]   - Field: ‘globals’
[13:18:59.775]   - Field: ‘stdout’
[13:18:59.776]   - Field: ‘earlySignal’
[13:18:59.776]   - Field: ‘lazy’
[13:18:59.779]   - Field: ‘state’
[13:18:59.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.780] - Launch lazy future ...
[13:18:59.781] Packages needed by the future expression (n = 0): <none>
[13:18:59.781] Packages needed by future strategies (n = 0): <none>
[13:18:59.782] {
[13:18:59.782]     {
[13:18:59.782]         {
[13:18:59.782]             ...future.startTime <- base::Sys.time()
[13:18:59.782]             {
[13:18:59.782]                 {
[13:18:59.782]                   {
[13:18:59.782]                     {
[13:18:59.782]                       base::local({
[13:18:59.782]                         has_future <- base::requireNamespace("future", 
[13:18:59.782]                           quietly = TRUE)
[13:18:59.782]                         if (has_future) {
[13:18:59.782]                           ns <- base::getNamespace("future")
[13:18:59.782]                           version <- ns[[".package"]][["version"]]
[13:18:59.782]                           if (is.null(version)) 
[13:18:59.782]                             version <- utils::packageVersion("future")
[13:18:59.782]                         }
[13:18:59.782]                         else {
[13:18:59.782]                           version <- NULL
[13:18:59.782]                         }
[13:18:59.782]                         if (!has_future || version < "1.8.0") {
[13:18:59.782]                           info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.782]                             "", base::R.version$version.string), 
[13:18:59.782]                             platform = base::sprintf("%s (%s-bit)", 
[13:18:59.782]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:18:59.782]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.782]                               "release", "version")], collapse = " "), 
[13:18:59.782]                             hostname = base::Sys.info()[["nodename"]])
[13:18:59.782]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.782]                             info)
[13:18:59.782]                           info <- base::paste(info, collapse = "; ")
[13:18:59.782]                           if (!has_future) {
[13:18:59.782]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.782]                               info)
[13:18:59.782]                           }
[13:18:59.782]                           else {
[13:18:59.782]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.782]                               info, version)
[13:18:59.782]                           }
[13:18:59.782]                           base::stop(msg)
[13:18:59.782]                         }
[13:18:59.782]                       })
[13:18:59.782]                     }
[13:18:59.782]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.782]                     base::options(mc.cores = 1L)
[13:18:59.782]                   }
[13:18:59.782]                   options(future.plan = NULL)
[13:18:59.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.782]                 }
[13:18:59.782]                 ...future.workdir <- getwd()
[13:18:59.782]             }
[13:18:59.782]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.782]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.782]         }
[13:18:59.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.782]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:18:59.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.782]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.782]             base::names(...future.oldOptions))
[13:18:59.782]     }
[13:18:59.782]     if (FALSE) {
[13:18:59.782]     }
[13:18:59.782]     else {
[13:18:59.782]         if (TRUE) {
[13:18:59.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.782]                 open = "w")
[13:18:59.782]         }
[13:18:59.782]         else {
[13:18:59.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.782]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.782]         }
[13:18:59.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.782]             base::sink(type = "output", split = FALSE)
[13:18:59.782]             base::close(...future.stdout)
[13:18:59.782]         }, add = TRUE)
[13:18:59.782]     }
[13:18:59.782]     ...future.frame <- base::sys.nframe()
[13:18:59.782]     ...future.conditions <- base::list()
[13:18:59.782]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.782]     if (FALSE) {
[13:18:59.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.782]     }
[13:18:59.782]     ...future.result <- base::tryCatch({
[13:18:59.782]         base::withCallingHandlers({
[13:18:59.782]             ...future.value <- base::withVisible(base::local({
[13:18:59.782]                 withCallingHandlers({
[13:18:59.782]                   {
[13:18:59.782]                     do.call(function(...) {
[13:18:59.782]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.782]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.782]                         ...future.globals.maxSize)) {
[13:18:59.782]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.782]                         on.exit(options(oopts), add = TRUE)
[13:18:59.782]                       }
[13:18:59.782]                       {
[13:18:59.782]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.782]                           FUN = function(jj) {
[13:18:59.782]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.782]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.782]                           })
[13:18:59.782]                       }
[13:18:59.782]                     }, args = future.call.arguments)
[13:18:59.782]                   }
[13:18:59.782]                 }, immediateCondition = function(cond) {
[13:18:59.782]                   save_rds <- function (object, pathname, ...) 
[13:18:59.782]                   {
[13:18:59.782]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.782]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.782]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.782]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.782]                         fi_tmp[["mtime"]])
[13:18:59.782]                     }
[13:18:59.782]                     tryCatch({
[13:18:59.782]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.782]                     }, error = function(ex) {
[13:18:59.782]                       msg <- conditionMessage(ex)
[13:18:59.782]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.782]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.782]                         fi_tmp[["mtime"]], msg)
[13:18:59.782]                       ex$message <- msg
[13:18:59.782]                       stop(ex)
[13:18:59.782]                     })
[13:18:59.782]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.782]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.782]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.782]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.782]                       fi <- file.info(pathname)
[13:18:59.782]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.782]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.782]                         fi[["size"]], fi[["mtime"]])
[13:18:59.782]                       stop(msg)
[13:18:59.782]                     }
[13:18:59.782]                     invisible(pathname)
[13:18:59.782]                   }
[13:18:59.782]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.782]                     rootPath = tempdir()) 
[13:18:59.782]                   {
[13:18:59.782]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.782]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.782]                       tmpdir = path, fileext = ".rds")
[13:18:59.782]                     save_rds(obj, file)
[13:18:59.782]                   }
[13:18:59.782]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.782]                   {
[13:18:59.782]                     inherits <- base::inherits
[13:18:59.782]                     invokeRestart <- base::invokeRestart
[13:18:59.782]                     is.null <- base::is.null
[13:18:59.782]                     muffled <- FALSE
[13:18:59.782]                     if (inherits(cond, "message")) {
[13:18:59.782]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.782]                       if (muffled) 
[13:18:59.782]                         invokeRestart("muffleMessage")
[13:18:59.782]                     }
[13:18:59.782]                     else if (inherits(cond, "warning")) {
[13:18:59.782]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.782]                       if (muffled) 
[13:18:59.782]                         invokeRestart("muffleWarning")
[13:18:59.782]                     }
[13:18:59.782]                     else if (inherits(cond, "condition")) {
[13:18:59.782]                       if (!is.null(pattern)) {
[13:18:59.782]                         computeRestarts <- base::computeRestarts
[13:18:59.782]                         grepl <- base::grepl
[13:18:59.782]                         restarts <- computeRestarts(cond)
[13:18:59.782]                         for (restart in restarts) {
[13:18:59.782]                           name <- restart$name
[13:18:59.782]                           if (is.null(name)) 
[13:18:59.782]                             next
[13:18:59.782]                           if (!grepl(pattern, name)) 
[13:18:59.782]                             next
[13:18:59.782]                           invokeRestart(restart)
[13:18:59.782]                           muffled <- TRUE
[13:18:59.782]                           break
[13:18:59.782]                         }
[13:18:59.782]                       }
[13:18:59.782]                     }
[13:18:59.782]                     invisible(muffled)
[13:18:59.782]                   }
[13:18:59.782]                   muffleCondition(cond)
[13:18:59.782]                 })
[13:18:59.782]             }))
[13:18:59.782]             future::FutureResult(value = ...future.value$value, 
[13:18:59.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.782]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.782]                     ...future.globalenv.names))
[13:18:59.782]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.782]         }, condition = base::local({
[13:18:59.782]             c <- base::c
[13:18:59.782]             inherits <- base::inherits
[13:18:59.782]             invokeRestart <- base::invokeRestart
[13:18:59.782]             length <- base::length
[13:18:59.782]             list <- base::list
[13:18:59.782]             seq.int <- base::seq.int
[13:18:59.782]             signalCondition <- base::signalCondition
[13:18:59.782]             sys.calls <- base::sys.calls
[13:18:59.782]             `[[` <- base::`[[`
[13:18:59.782]             `+` <- base::`+`
[13:18:59.782]             `<<-` <- base::`<<-`
[13:18:59.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.782]                   3L)]
[13:18:59.782]             }
[13:18:59.782]             function(cond) {
[13:18:59.782]                 is_error <- inherits(cond, "error")
[13:18:59.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.782]                   NULL)
[13:18:59.782]                 if (is_error) {
[13:18:59.782]                   sessionInformation <- function() {
[13:18:59.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.782]                       search = base::search(), system = base::Sys.info())
[13:18:59.782]                   }
[13:18:59.782]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.782]                     cond$call), session = sessionInformation(), 
[13:18:59.782]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.782]                   signalCondition(cond)
[13:18:59.782]                 }
[13:18:59.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.782]                 "immediateCondition"))) {
[13:18:59.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.782]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.782]                   if (TRUE && !signal) {
[13:18:59.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.782]                     {
[13:18:59.782]                       inherits <- base::inherits
[13:18:59.782]                       invokeRestart <- base::invokeRestart
[13:18:59.782]                       is.null <- base::is.null
[13:18:59.782]                       muffled <- FALSE
[13:18:59.782]                       if (inherits(cond, "message")) {
[13:18:59.782]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.782]                         if (muffled) 
[13:18:59.782]                           invokeRestart("muffleMessage")
[13:18:59.782]                       }
[13:18:59.782]                       else if (inherits(cond, "warning")) {
[13:18:59.782]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.782]                         if (muffled) 
[13:18:59.782]                           invokeRestart("muffleWarning")
[13:18:59.782]                       }
[13:18:59.782]                       else if (inherits(cond, "condition")) {
[13:18:59.782]                         if (!is.null(pattern)) {
[13:18:59.782]                           computeRestarts <- base::computeRestarts
[13:18:59.782]                           grepl <- base::grepl
[13:18:59.782]                           restarts <- computeRestarts(cond)
[13:18:59.782]                           for (restart in restarts) {
[13:18:59.782]                             name <- restart$name
[13:18:59.782]                             if (is.null(name)) 
[13:18:59.782]                               next
[13:18:59.782]                             if (!grepl(pattern, name)) 
[13:18:59.782]                               next
[13:18:59.782]                             invokeRestart(restart)
[13:18:59.782]                             muffled <- TRUE
[13:18:59.782]                             break
[13:18:59.782]                           }
[13:18:59.782]                         }
[13:18:59.782]                       }
[13:18:59.782]                       invisible(muffled)
[13:18:59.782]                     }
[13:18:59.782]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.782]                   }
[13:18:59.782]                 }
[13:18:59.782]                 else {
[13:18:59.782]                   if (TRUE) {
[13:18:59.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.782]                     {
[13:18:59.782]                       inherits <- base::inherits
[13:18:59.782]                       invokeRestart <- base::invokeRestart
[13:18:59.782]                       is.null <- base::is.null
[13:18:59.782]                       muffled <- FALSE
[13:18:59.782]                       if (inherits(cond, "message")) {
[13:18:59.782]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.782]                         if (muffled) 
[13:18:59.782]                           invokeRestart("muffleMessage")
[13:18:59.782]                       }
[13:18:59.782]                       else if (inherits(cond, "warning")) {
[13:18:59.782]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.782]                         if (muffled) 
[13:18:59.782]                           invokeRestart("muffleWarning")
[13:18:59.782]                       }
[13:18:59.782]                       else if (inherits(cond, "condition")) {
[13:18:59.782]                         if (!is.null(pattern)) {
[13:18:59.782]                           computeRestarts <- base::computeRestarts
[13:18:59.782]                           grepl <- base::grepl
[13:18:59.782]                           restarts <- computeRestarts(cond)
[13:18:59.782]                           for (restart in restarts) {
[13:18:59.782]                             name <- restart$name
[13:18:59.782]                             if (is.null(name)) 
[13:18:59.782]                               next
[13:18:59.782]                             if (!grepl(pattern, name)) 
[13:18:59.782]                               next
[13:18:59.782]                             invokeRestart(restart)
[13:18:59.782]                             muffled <- TRUE
[13:18:59.782]                             break
[13:18:59.782]                           }
[13:18:59.782]                         }
[13:18:59.782]                       }
[13:18:59.782]                       invisible(muffled)
[13:18:59.782]                     }
[13:18:59.782]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.782]                   }
[13:18:59.782]                 }
[13:18:59.782]             }
[13:18:59.782]         }))
[13:18:59.782]     }, error = function(ex) {
[13:18:59.782]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.782]                 ...future.rng), started = ...future.startTime, 
[13:18:59.782]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.782]             version = "1.8"), class = "FutureResult")
[13:18:59.782]     }, finally = {
[13:18:59.782]         if (!identical(...future.workdir, getwd())) 
[13:18:59.782]             setwd(...future.workdir)
[13:18:59.782]         {
[13:18:59.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.782]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.782]             }
[13:18:59.782]             base::options(...future.oldOptions)
[13:18:59.782]             if (.Platform$OS.type == "windows") {
[13:18:59.782]                 old_names <- names(...future.oldEnvVars)
[13:18:59.782]                 envs <- base::Sys.getenv()
[13:18:59.782]                 names <- names(envs)
[13:18:59.782]                 common <- intersect(names, old_names)
[13:18:59.782]                 added <- setdiff(names, old_names)
[13:18:59.782]                 removed <- setdiff(old_names, names)
[13:18:59.782]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.782]                   envs[common]]
[13:18:59.782]                 NAMES <- toupper(changed)
[13:18:59.782]                 args <- list()
[13:18:59.782]                 for (kk in seq_along(NAMES)) {
[13:18:59.782]                   name <- changed[[kk]]
[13:18:59.782]                   NAME <- NAMES[[kk]]
[13:18:59.782]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.782]                     next
[13:18:59.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.782]                 }
[13:18:59.782]                 NAMES <- toupper(added)
[13:18:59.782]                 for (kk in seq_along(NAMES)) {
[13:18:59.782]                   name <- added[[kk]]
[13:18:59.782]                   NAME <- NAMES[[kk]]
[13:18:59.782]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.782]                     next
[13:18:59.782]                   args[[name]] <- ""
[13:18:59.782]                 }
[13:18:59.782]                 NAMES <- toupper(removed)
[13:18:59.782]                 for (kk in seq_along(NAMES)) {
[13:18:59.782]                   name <- removed[[kk]]
[13:18:59.782]                   NAME <- NAMES[[kk]]
[13:18:59.782]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.782]                     next
[13:18:59.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.782]                 }
[13:18:59.782]                 if (length(args) > 0) 
[13:18:59.782]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.782]             }
[13:18:59.782]             else {
[13:18:59.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.782]             }
[13:18:59.782]             {
[13:18:59.782]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.782]                   0L) {
[13:18:59.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.782]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.782]                   base::options(opts)
[13:18:59.782]                 }
[13:18:59.782]                 {
[13:18:59.782]                   {
[13:18:59.782]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.782]                     NULL
[13:18:59.782]                   }
[13:18:59.782]                   options(future.plan = NULL)
[13:18:59.782]                   if (is.na(NA_character_)) 
[13:18:59.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.782]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.782]                     envir = parent.frame()) 
[13:18:59.782]                   {
[13:18:59.782]                     default_workers <- missing(workers)
[13:18:59.782]                     if (is.function(workers)) 
[13:18:59.782]                       workers <- workers()
[13:18:59.782]                     workers <- structure(as.integer(workers), 
[13:18:59.782]                       class = class(workers))
[13:18:59.782]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.782]                       1L)
[13:18:59.782]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.782]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.782]                       if (default_workers) 
[13:18:59.782]                         supportsMulticore(warn = TRUE)
[13:18:59.782]                       return(sequential(..., envir = envir))
[13:18:59.782]                     }
[13:18:59.782]                     oopts <- options(mc.cores = workers)
[13:18:59.782]                     on.exit(options(oopts))
[13:18:59.782]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.782]                       envir = envir)
[13:18:59.782]                     if (!future$lazy) 
[13:18:59.782]                       future <- run(future)
[13:18:59.782]                     invisible(future)
[13:18:59.782]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.782]                 }
[13:18:59.782]             }
[13:18:59.782]         }
[13:18:59.782]     })
[13:18:59.782]     if (TRUE) {
[13:18:59.782]         base::sink(type = "output", split = FALSE)
[13:18:59.782]         if (TRUE) {
[13:18:59.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.782]         }
[13:18:59.782]         else {
[13:18:59.782]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.782]         }
[13:18:59.782]         base::close(...future.stdout)
[13:18:59.782]         ...future.stdout <- NULL
[13:18:59.782]     }
[13:18:59.782]     ...future.result$conditions <- ...future.conditions
[13:18:59.782]     ...future.result$finished <- base::Sys.time()
[13:18:59.782]     ...future.result
[13:18:59.782] }
[13:18:59.785] assign_globals() ...
[13:18:59.785] List of 5
[13:18:59.785]  $ ...future.FUN            :function (x, y)  
[13:18:59.785]  $ future.call.arguments    :List of 1
[13:18:59.785]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.785]  $ ...future.elements_ii    :List of 2
[13:18:59.785]   ..$ C: num 70
[13:18:59.785]   ..$ D: num 80
[13:18:59.785]  $ ...future.seeds_ii       : NULL
[13:18:59.785]  $ ...future.globals.maxSize: NULL
[13:18:59.785]  - attr(*, "resolved")= logi FALSE
[13:18:59.785]  - attr(*, "total_size")= num 4264
[13:18:59.785]  - attr(*, "where")=List of 5
[13:18:59.785]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.785]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.785]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.785]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.785]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.785]  - attr(*, "already-done")= logi TRUE
[13:18:59.795] - reassign environment for ‘...future.FUN’
[13:18:59.796] - copied ‘...future.FUN’ to environment
[13:18:59.796] - copied ‘future.call.arguments’ to environment
[13:18:59.796] - copied ‘...future.elements_ii’ to environment
[13:18:59.796] - copied ‘...future.seeds_ii’ to environment
[13:18:59.796] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.796] assign_globals() ... done
[13:18:59.796] requestCore(): workers = 2
[13:18:59.799] MulticoreFuture started
[13:18:59.799] - Launch lazy future ... done
[13:18:59.799] run() for ‘MulticoreFuture’ ... done
[13:18:59.800] Created future:
[13:18:59.800] plan(): Setting new future strategy stack:
[13:18:59.800] List of future strategies:
[13:18:59.800] 1. sequential:
[13:18:59.800]    - args: function (..., envir = parent.frame())
[13:18:59.800]    - tweaked: FALSE
[13:18:59.800]    - call: NULL
[13:18:59.802] plan(): nbrOfWorkers() = 1
[13:18:59.804] plan(): Setting new future strategy stack:
[13:18:59.804] List of future strategies:
[13:18:59.804] 1. multicore:
[13:18:59.804]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.804]    - tweaked: FALSE
[13:18:59.804]    - call: plan(strategy)
[13:18:59.810] plan(): nbrOfWorkers() = 2
[13:18:59.800] MulticoreFuture:
[13:18:59.800] Label: ‘future_sapply-2’
[13:18:59.800] Expression:
[13:18:59.800] {
[13:18:59.800]     do.call(function(...) {
[13:18:59.800]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.800]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.800]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.800]             on.exit(options(oopts), add = TRUE)
[13:18:59.800]         }
[13:18:59.800]         {
[13:18:59.800]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.800]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.800]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.800]             })
[13:18:59.800]         }
[13:18:59.800]     }, args = future.call.arguments)
[13:18:59.800] }
[13:18:59.800] Lazy evaluation: FALSE
[13:18:59.800] Asynchronous evaluation: TRUE
[13:18:59.800] Local evaluation: TRUE
[13:18:59.800] Environment: R_GlobalEnv
[13:18:59.800] Capture standard output: TRUE
[13:18:59.800] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.800] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:18:59.800] Packages: <none>
[13:18:59.800] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.800] Resolved: TRUE
[13:18:59.800] Value: <not collected>
[13:18:59.800] Conditions captured: <none>
[13:18:59.800] Early signaling: FALSE
[13:18:59.800] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.800] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.811] Chunk #2 of 2 ... DONE
[13:18:59.811] Launching 2 futures (chunks) ... DONE
[13:18:59.811] Resolving 2 futures (chunks) ...
[13:18:59.812] resolve() on list ...
[13:18:59.812]  recursive: 0
[13:18:59.812]  length: 2
[13:18:59.812] 
[13:18:59.812] Future #1
[13:18:59.814] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.814] - nx: 2
[13:18:59.814] - relay: TRUE
[13:18:59.814] - stdout: TRUE
[13:18:59.814] - signal: TRUE
[13:18:59.814] - resignal: FALSE
[13:18:59.814] - force: TRUE
[13:18:59.815] - relayed: [n=2] FALSE, FALSE
[13:18:59.815] - queued futures: [n=2] FALSE, FALSE
[13:18:59.815]  - until=1
[13:18:59.815]  - relaying element #1
[13:18:59.815] - relayed: [n=2] TRUE, FALSE
[13:18:59.816] - queued futures: [n=2] TRUE, FALSE
[13:18:59.816] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.816]  length: 1 (resolved future 1)
[13:18:59.816] Future #2
[13:18:59.817] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.817] - nx: 2
[13:18:59.817] - relay: TRUE
[13:18:59.818] - stdout: TRUE
[13:18:59.818] - signal: TRUE
[13:18:59.818] - resignal: FALSE
[13:18:59.818] - force: TRUE
[13:18:59.818] - relayed: [n=2] TRUE, FALSE
[13:18:59.819] - queued futures: [n=2] TRUE, FALSE
[13:18:59.819]  - until=2
[13:18:59.819]  - relaying element #2
[13:18:59.819] - relayed: [n=2] TRUE, TRUE
[13:18:59.819] - queued futures: [n=2] TRUE, TRUE
[13:18:59.820] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.820]  length: 0 (resolved future 2)
[13:18:59.820] Relaying remaining futures
[13:18:59.820] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.820] - nx: 2
[13:18:59.820] - relay: TRUE
[13:18:59.820] - stdout: TRUE
[13:18:59.820] - signal: TRUE
[13:18:59.821] - resignal: FALSE
[13:18:59.821] - force: TRUE
[13:18:59.821] - relayed: [n=2] TRUE, TRUE
[13:18:59.821] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.821] - relayed: [n=2] TRUE, TRUE
[13:18:59.821] - queued futures: [n=2] TRUE, TRUE
[13:18:59.821] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.821] resolve() on list ... DONE
[13:18:59.822]  - Number of value chunks collected: 2
[13:18:59.822] Resolving 2 futures (chunks) ... DONE
[13:18:59.822] Reducing values from 2 chunks ...
[13:18:59.822]  - Number of values collected after concatenation: 4
[13:18:59.822]  - Number of values expected: 4
[13:18:59.822] Reducing values from 2 chunks ... DONE
[13:18:59.822] future_lapply() ... DONE
[13:18:59.823] future_lapply() ...
[13:18:59.833] Number of chunks: 2
[13:18:59.833] getGlobalsAndPackagesXApply() ...
[13:18:59.833]  - future.globals: TRUE
[13:18:59.833] getGlobalsAndPackages() ...
[13:18:59.833] Searching for globals...
[13:18:59.839] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:18:59.839] Searching for globals ... DONE
[13:18:59.839] Resolving globals: FALSE
[13:18:59.840] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:18:59.840] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:59.840] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.841] - packages: [1] ‘future.apply’
[13:18:59.841] getGlobalsAndPackages() ... DONE
[13:18:59.841]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.841]  - needed namespaces: [n=1] ‘future.apply’
[13:18:59.841] Finding globals ... DONE
[13:18:59.841]  - use_args: TRUE
[13:18:59.841]  - Getting '...' globals ...
[13:18:59.842] resolve() on list ...
[13:18:59.842]  recursive: 0
[13:18:59.842]  length: 1
[13:18:59.842]  elements: ‘...’
[13:18:59.842]  length: 0 (resolved future 1)
[13:18:59.842] resolve() on list ... DONE
[13:18:59.842]    - '...' content: [n=1] ‘y’
[13:18:59.842] List of 1
[13:18:59.842]  $ ...:List of 1
[13:18:59.842]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.842]  - attr(*, "where")=List of 1
[13:18:59.842]   ..$ ...:<environment: 0x555f7b57e598> 
[13:18:59.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.842]  - attr(*, "resolved")= logi TRUE
[13:18:59.842]  - attr(*, "total_size")= num NA
[13:18:59.846]  - Getting '...' globals ... DONE
[13:18:59.846] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:59.846] List of 8
[13:18:59.846]  $ ...future.FUN:function (x, ...)  
[13:18:59.846]  $ x_FUN        :function (x, y)  
[13:18:59.846]  $ times        : int 15
[13:18:59.846]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.846]  $ stop_if_not  :function (...)  
[13:18:59.846]  $ dim          : int [1:2] 3 5
[13:18:59.846]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:18:59.846]  $ ...          :List of 1
[13:18:59.846]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.846]  - attr(*, "where")=List of 8
[13:18:59.846]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:59.846]   ..$ ...          :<environment: 0x555f7b57e598> 
[13:18:59.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.846]  - attr(*, "resolved")= logi FALSE
[13:18:59.846]  - attr(*, "total_size")= num 98600
[13:18:59.854] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:59.854] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.854] Number of futures (= number of chunks): 2
[13:18:59.854] Launching 2 futures (chunks) ...
[13:18:59.855] Chunk #1 of 2 ...
[13:18:59.855]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.855] getGlobalsAndPackages() ...
[13:18:59.855] Searching for globals...
[13:18:59.855] 
[13:18:59.855] Searching for globals ... DONE
[13:18:59.855] - globals: [0] <none>
[13:18:59.855] getGlobalsAndPackages() ... DONE
[13:18:59.856]    + additional globals found: [n=0] 
[13:18:59.856]    + additional namespaces needed: [n=0] 
[13:18:59.856]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.856]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:18:59.856]  - seeds: <none>
[13:18:59.856] getGlobalsAndPackages() ...
[13:18:59.856] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.856] Resolving globals: FALSE
[13:18:59.856] Tweak future expression to call with '...' arguments ...
[13:18:59.857] {
[13:18:59.857]     do.call(function(...) {
[13:18:59.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.857]             on.exit(options(oopts), add = TRUE)
[13:18:59.857]         }
[13:18:59.857]         {
[13:18:59.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.857]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.857]             })
[13:18:59.857]         }
[13:18:59.857]     }, args = future.call.arguments)
[13:18:59.857] }
[13:18:59.857] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.857] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.858] - packages: [1] ‘future.apply’
[13:18:59.858] getGlobalsAndPackages() ... DONE
[13:18:59.858] run() for ‘Future’ ...
[13:18:59.858] - state: ‘created’
[13:18:59.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.862] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.862]   - Field: ‘label’
[13:18:59.862]   - Field: ‘local’
[13:18:59.862]   - Field: ‘owner’
[13:18:59.863]   - Field: ‘envir’
[13:18:59.863]   - Field: ‘workers’
[13:18:59.863]   - Field: ‘packages’
[13:18:59.863]   - Field: ‘gc’
[13:18:59.863]   - Field: ‘job’
[13:18:59.863]   - Field: ‘conditions’
[13:18:59.863]   - Field: ‘expr’
[13:18:59.863]   - Field: ‘uuid’
[13:18:59.863]   - Field: ‘seed’
[13:18:59.863]   - Field: ‘version’
[13:18:59.863]   - Field: ‘result’
[13:18:59.864]   - Field: ‘asynchronous’
[13:18:59.864]   - Field: ‘calls’
[13:18:59.864]   - Field: ‘globals’
[13:18:59.864]   - Field: ‘stdout’
[13:18:59.864]   - Field: ‘earlySignal’
[13:18:59.864]   - Field: ‘lazy’
[13:18:59.864]   - Field: ‘state’
[13:18:59.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.864] - Launch lazy future ...
[13:18:59.865] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:59.865] Packages needed by future strategies (n = 0): <none>
[13:18:59.865] {
[13:18:59.865]     {
[13:18:59.865]         {
[13:18:59.865]             ...future.startTime <- base::Sys.time()
[13:18:59.865]             {
[13:18:59.865]                 {
[13:18:59.865]                   {
[13:18:59.865]                     {
[13:18:59.865]                       {
[13:18:59.865]                         base::local({
[13:18:59.865]                           has_future <- base::requireNamespace("future", 
[13:18:59.865]                             quietly = TRUE)
[13:18:59.865]                           if (has_future) {
[13:18:59.865]                             ns <- base::getNamespace("future")
[13:18:59.865]                             version <- ns[[".package"]][["version"]]
[13:18:59.865]                             if (is.null(version)) 
[13:18:59.865]                               version <- utils::packageVersion("future")
[13:18:59.865]                           }
[13:18:59.865]                           else {
[13:18:59.865]                             version <- NULL
[13:18:59.865]                           }
[13:18:59.865]                           if (!has_future || version < "1.8.0") {
[13:18:59.865]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.865]                               "", base::R.version$version.string), 
[13:18:59.865]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.865]                                 base::R.version$platform, 8 * 
[13:18:59.865]                                   base::.Machine$sizeof.pointer), 
[13:18:59.865]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.865]                                 "release", "version")], collapse = " "), 
[13:18:59.865]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.865]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.865]                               info)
[13:18:59.865]                             info <- base::paste(info, collapse = "; ")
[13:18:59.865]                             if (!has_future) {
[13:18:59.865]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.865]                                 info)
[13:18:59.865]                             }
[13:18:59.865]                             else {
[13:18:59.865]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.865]                                 info, version)
[13:18:59.865]                             }
[13:18:59.865]                             base::stop(msg)
[13:18:59.865]                           }
[13:18:59.865]                         })
[13:18:59.865]                       }
[13:18:59.865]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.865]                       base::options(mc.cores = 1L)
[13:18:59.865]                     }
[13:18:59.865]                     base::local({
[13:18:59.865]                       for (pkg in "future.apply") {
[13:18:59.865]                         base::loadNamespace(pkg)
[13:18:59.865]                         base::library(pkg, character.only = TRUE)
[13:18:59.865]                       }
[13:18:59.865]                     })
[13:18:59.865]                   }
[13:18:59.865]                   options(future.plan = NULL)
[13:18:59.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.865]                 }
[13:18:59.865]                 ...future.workdir <- getwd()
[13:18:59.865]             }
[13:18:59.865]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.865]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.865]         }
[13:18:59.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.865]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:18:59.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.865]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.865]             base::names(...future.oldOptions))
[13:18:59.865]     }
[13:18:59.865]     if (FALSE) {
[13:18:59.865]     }
[13:18:59.865]     else {
[13:18:59.865]         if (TRUE) {
[13:18:59.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.865]                 open = "w")
[13:18:59.865]         }
[13:18:59.865]         else {
[13:18:59.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.865]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.865]         }
[13:18:59.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.865]             base::sink(type = "output", split = FALSE)
[13:18:59.865]             base::close(...future.stdout)
[13:18:59.865]         }, add = TRUE)
[13:18:59.865]     }
[13:18:59.865]     ...future.frame <- base::sys.nframe()
[13:18:59.865]     ...future.conditions <- base::list()
[13:18:59.865]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.865]     if (FALSE) {
[13:18:59.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.865]     }
[13:18:59.865]     ...future.result <- base::tryCatch({
[13:18:59.865]         base::withCallingHandlers({
[13:18:59.865]             ...future.value <- base::withVisible(base::local({
[13:18:59.865]                 withCallingHandlers({
[13:18:59.865]                   {
[13:18:59.865]                     do.call(function(...) {
[13:18:59.865]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.865]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.865]                         ...future.globals.maxSize)) {
[13:18:59.865]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.865]                         on.exit(options(oopts), add = TRUE)
[13:18:59.865]                       }
[13:18:59.865]                       {
[13:18:59.865]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.865]                           FUN = function(jj) {
[13:18:59.865]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.865]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.865]                           })
[13:18:59.865]                       }
[13:18:59.865]                     }, args = future.call.arguments)
[13:18:59.865]                   }
[13:18:59.865]                 }, immediateCondition = function(cond) {
[13:18:59.865]                   save_rds <- function (object, pathname, ...) 
[13:18:59.865]                   {
[13:18:59.865]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.865]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.865]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.865]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.865]                         fi_tmp[["mtime"]])
[13:18:59.865]                     }
[13:18:59.865]                     tryCatch({
[13:18:59.865]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.865]                     }, error = function(ex) {
[13:18:59.865]                       msg <- conditionMessage(ex)
[13:18:59.865]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.865]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.865]                         fi_tmp[["mtime"]], msg)
[13:18:59.865]                       ex$message <- msg
[13:18:59.865]                       stop(ex)
[13:18:59.865]                     })
[13:18:59.865]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.865]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.865]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.865]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.865]                       fi <- file.info(pathname)
[13:18:59.865]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.865]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.865]                         fi[["size"]], fi[["mtime"]])
[13:18:59.865]                       stop(msg)
[13:18:59.865]                     }
[13:18:59.865]                     invisible(pathname)
[13:18:59.865]                   }
[13:18:59.865]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.865]                     rootPath = tempdir()) 
[13:18:59.865]                   {
[13:18:59.865]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.865]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.865]                       tmpdir = path, fileext = ".rds")
[13:18:59.865]                     save_rds(obj, file)
[13:18:59.865]                   }
[13:18:59.865]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.865]                   {
[13:18:59.865]                     inherits <- base::inherits
[13:18:59.865]                     invokeRestart <- base::invokeRestart
[13:18:59.865]                     is.null <- base::is.null
[13:18:59.865]                     muffled <- FALSE
[13:18:59.865]                     if (inherits(cond, "message")) {
[13:18:59.865]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.865]                       if (muffled) 
[13:18:59.865]                         invokeRestart("muffleMessage")
[13:18:59.865]                     }
[13:18:59.865]                     else if (inherits(cond, "warning")) {
[13:18:59.865]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.865]                       if (muffled) 
[13:18:59.865]                         invokeRestart("muffleWarning")
[13:18:59.865]                     }
[13:18:59.865]                     else if (inherits(cond, "condition")) {
[13:18:59.865]                       if (!is.null(pattern)) {
[13:18:59.865]                         computeRestarts <- base::computeRestarts
[13:18:59.865]                         grepl <- base::grepl
[13:18:59.865]                         restarts <- computeRestarts(cond)
[13:18:59.865]                         for (restart in restarts) {
[13:18:59.865]                           name <- restart$name
[13:18:59.865]                           if (is.null(name)) 
[13:18:59.865]                             next
[13:18:59.865]                           if (!grepl(pattern, name)) 
[13:18:59.865]                             next
[13:18:59.865]                           invokeRestart(restart)
[13:18:59.865]                           muffled <- TRUE
[13:18:59.865]                           break
[13:18:59.865]                         }
[13:18:59.865]                       }
[13:18:59.865]                     }
[13:18:59.865]                     invisible(muffled)
[13:18:59.865]                   }
[13:18:59.865]                   muffleCondition(cond)
[13:18:59.865]                 })
[13:18:59.865]             }))
[13:18:59.865]             future::FutureResult(value = ...future.value$value, 
[13:18:59.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.865]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.865]                     ...future.globalenv.names))
[13:18:59.865]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.865]         }, condition = base::local({
[13:18:59.865]             c <- base::c
[13:18:59.865]             inherits <- base::inherits
[13:18:59.865]             invokeRestart <- base::invokeRestart
[13:18:59.865]             length <- base::length
[13:18:59.865]             list <- base::list
[13:18:59.865]             seq.int <- base::seq.int
[13:18:59.865]             signalCondition <- base::signalCondition
[13:18:59.865]             sys.calls <- base::sys.calls
[13:18:59.865]             `[[` <- base::`[[`
[13:18:59.865]             `+` <- base::`+`
[13:18:59.865]             `<<-` <- base::`<<-`
[13:18:59.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.865]                   3L)]
[13:18:59.865]             }
[13:18:59.865]             function(cond) {
[13:18:59.865]                 is_error <- inherits(cond, "error")
[13:18:59.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.865]                   NULL)
[13:18:59.865]                 if (is_error) {
[13:18:59.865]                   sessionInformation <- function() {
[13:18:59.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.865]                       search = base::search(), system = base::Sys.info())
[13:18:59.865]                   }
[13:18:59.865]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.865]                     cond$call), session = sessionInformation(), 
[13:18:59.865]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.865]                   signalCondition(cond)
[13:18:59.865]                 }
[13:18:59.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.865]                 "immediateCondition"))) {
[13:18:59.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.865]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.865]                   if (TRUE && !signal) {
[13:18:59.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.865]                     {
[13:18:59.865]                       inherits <- base::inherits
[13:18:59.865]                       invokeRestart <- base::invokeRestart
[13:18:59.865]                       is.null <- base::is.null
[13:18:59.865]                       muffled <- FALSE
[13:18:59.865]                       if (inherits(cond, "message")) {
[13:18:59.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.865]                         if (muffled) 
[13:18:59.865]                           invokeRestart("muffleMessage")
[13:18:59.865]                       }
[13:18:59.865]                       else if (inherits(cond, "warning")) {
[13:18:59.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.865]                         if (muffled) 
[13:18:59.865]                           invokeRestart("muffleWarning")
[13:18:59.865]                       }
[13:18:59.865]                       else if (inherits(cond, "condition")) {
[13:18:59.865]                         if (!is.null(pattern)) {
[13:18:59.865]                           computeRestarts <- base::computeRestarts
[13:18:59.865]                           grepl <- base::grepl
[13:18:59.865]                           restarts <- computeRestarts(cond)
[13:18:59.865]                           for (restart in restarts) {
[13:18:59.865]                             name <- restart$name
[13:18:59.865]                             if (is.null(name)) 
[13:18:59.865]                               next
[13:18:59.865]                             if (!grepl(pattern, name)) 
[13:18:59.865]                               next
[13:18:59.865]                             invokeRestart(restart)
[13:18:59.865]                             muffled <- TRUE
[13:18:59.865]                             break
[13:18:59.865]                           }
[13:18:59.865]                         }
[13:18:59.865]                       }
[13:18:59.865]                       invisible(muffled)
[13:18:59.865]                     }
[13:18:59.865]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.865]                   }
[13:18:59.865]                 }
[13:18:59.865]                 else {
[13:18:59.865]                   if (TRUE) {
[13:18:59.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.865]                     {
[13:18:59.865]                       inherits <- base::inherits
[13:18:59.865]                       invokeRestart <- base::invokeRestart
[13:18:59.865]                       is.null <- base::is.null
[13:18:59.865]                       muffled <- FALSE
[13:18:59.865]                       if (inherits(cond, "message")) {
[13:18:59.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.865]                         if (muffled) 
[13:18:59.865]                           invokeRestart("muffleMessage")
[13:18:59.865]                       }
[13:18:59.865]                       else if (inherits(cond, "warning")) {
[13:18:59.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.865]                         if (muffled) 
[13:18:59.865]                           invokeRestart("muffleWarning")
[13:18:59.865]                       }
[13:18:59.865]                       else if (inherits(cond, "condition")) {
[13:18:59.865]                         if (!is.null(pattern)) {
[13:18:59.865]                           computeRestarts <- base::computeRestarts
[13:18:59.865]                           grepl <- base::grepl
[13:18:59.865]                           restarts <- computeRestarts(cond)
[13:18:59.865]                           for (restart in restarts) {
[13:18:59.865]                             name <- restart$name
[13:18:59.865]                             if (is.null(name)) 
[13:18:59.865]                               next
[13:18:59.865]                             if (!grepl(pattern, name)) 
[13:18:59.865]                               next
[13:18:59.865]                             invokeRestart(restart)
[13:18:59.865]                             muffled <- TRUE
[13:18:59.865]                             break
[13:18:59.865]                           }
[13:18:59.865]                         }
[13:18:59.865]                       }
[13:18:59.865]                       invisible(muffled)
[13:18:59.865]                     }
[13:18:59.865]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.865]                   }
[13:18:59.865]                 }
[13:18:59.865]             }
[13:18:59.865]         }))
[13:18:59.865]     }, error = function(ex) {
[13:18:59.865]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.865]                 ...future.rng), started = ...future.startTime, 
[13:18:59.865]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.865]             version = "1.8"), class = "FutureResult")
[13:18:59.865]     }, finally = {
[13:18:59.865]         if (!identical(...future.workdir, getwd())) 
[13:18:59.865]             setwd(...future.workdir)
[13:18:59.865]         {
[13:18:59.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.865]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.865]             }
[13:18:59.865]             base::options(...future.oldOptions)
[13:18:59.865]             if (.Platform$OS.type == "windows") {
[13:18:59.865]                 old_names <- names(...future.oldEnvVars)
[13:18:59.865]                 envs <- base::Sys.getenv()
[13:18:59.865]                 names <- names(envs)
[13:18:59.865]                 common <- intersect(names, old_names)
[13:18:59.865]                 added <- setdiff(names, old_names)
[13:18:59.865]                 removed <- setdiff(old_names, names)
[13:18:59.865]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.865]                   envs[common]]
[13:18:59.865]                 NAMES <- toupper(changed)
[13:18:59.865]                 args <- list()
[13:18:59.865]                 for (kk in seq_along(NAMES)) {
[13:18:59.865]                   name <- changed[[kk]]
[13:18:59.865]                   NAME <- NAMES[[kk]]
[13:18:59.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.865]                     next
[13:18:59.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.865]                 }
[13:18:59.865]                 NAMES <- toupper(added)
[13:18:59.865]                 for (kk in seq_along(NAMES)) {
[13:18:59.865]                   name <- added[[kk]]
[13:18:59.865]                   NAME <- NAMES[[kk]]
[13:18:59.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.865]                     next
[13:18:59.865]                   args[[name]] <- ""
[13:18:59.865]                 }
[13:18:59.865]                 NAMES <- toupper(removed)
[13:18:59.865]                 for (kk in seq_along(NAMES)) {
[13:18:59.865]                   name <- removed[[kk]]
[13:18:59.865]                   NAME <- NAMES[[kk]]
[13:18:59.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.865]                     next
[13:18:59.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.865]                 }
[13:18:59.865]                 if (length(args) > 0) 
[13:18:59.865]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.865]             }
[13:18:59.865]             else {
[13:18:59.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.865]             }
[13:18:59.865]             {
[13:18:59.865]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.865]                   0L) {
[13:18:59.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.865]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.865]                   base::options(opts)
[13:18:59.865]                 }
[13:18:59.865]                 {
[13:18:59.865]                   {
[13:18:59.865]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.865]                     NULL
[13:18:59.865]                   }
[13:18:59.865]                   options(future.plan = NULL)
[13:18:59.865]                   if (is.na(NA_character_)) 
[13:18:59.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.865]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.865]                     envir = parent.frame()) 
[13:18:59.865]                   {
[13:18:59.865]                     default_workers <- missing(workers)
[13:18:59.865]                     if (is.function(workers)) 
[13:18:59.865]                       workers <- workers()
[13:18:59.865]                     workers <- structure(as.integer(workers), 
[13:18:59.865]                       class = class(workers))
[13:18:59.865]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.865]                       1L)
[13:18:59.865]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.865]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.865]                       if (default_workers) 
[13:18:59.865]                         supportsMulticore(warn = TRUE)
[13:18:59.865]                       return(sequential(..., envir = envir))
[13:18:59.865]                     }
[13:18:59.865]                     oopts <- options(mc.cores = workers)
[13:18:59.865]                     on.exit(options(oopts))
[13:18:59.865]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.865]                       envir = envir)
[13:18:59.865]                     if (!future$lazy) 
[13:18:59.865]                       future <- run(future)
[13:18:59.865]                     invisible(future)
[13:18:59.865]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.865]                 }
[13:18:59.865]             }
[13:18:59.865]         }
[13:18:59.865]     })
[13:18:59.865]     if (TRUE) {
[13:18:59.865]         base::sink(type = "output", split = FALSE)
[13:18:59.865]         if (TRUE) {
[13:18:59.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.865]         }
[13:18:59.865]         else {
[13:18:59.865]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.865]         }
[13:18:59.865]         base::close(...future.stdout)
[13:18:59.865]         ...future.stdout <- NULL
[13:18:59.865]     }
[13:18:59.865]     ...future.result$conditions <- ...future.conditions
[13:18:59.865]     ...future.result$finished <- base::Sys.time()
[13:18:59.865]     ...future.result
[13:18:59.865] }
[13:18:59.868] assign_globals() ...
[13:18:59.868] List of 11
[13:18:59.868]  $ ...future.FUN            :function (x, ...)  
[13:18:59.868]  $ x_FUN                    :function (x, y)  
[13:18:59.868]  $ times                    : int 15
[13:18:59.868]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.868]  $ stop_if_not              :function (...)  
[13:18:59.868]  $ dim                      : int [1:2] 3 5
[13:18:59.868]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.868]  $ future.call.arguments    :List of 1
[13:18:59.868]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.868]  $ ...future.elements_ii    :List of 2
[13:18:59.868]   ..$ A: num 50
[13:18:59.868]   ..$ B: num 60
[13:18:59.868]  $ ...future.seeds_ii       : NULL
[13:18:59.868]  $ ...future.globals.maxSize: NULL
[13:18:59.868]  - attr(*, "resolved")= logi FALSE
[13:18:59.868]  - attr(*, "total_size")= num 98600
[13:18:59.868]  - attr(*, "where")=List of 11
[13:18:59.868]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.868]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.868]  - attr(*, "already-done")= logi TRUE
[13:18:59.878] - copied ‘...future.FUN’ to environment
[13:18:59.878] - reassign environment for ‘x_FUN’
[13:18:59.878] - copied ‘x_FUN’ to environment
[13:18:59.879] - copied ‘times’ to environment
[13:18:59.879] - copied ‘stopf’ to environment
[13:18:59.879] - copied ‘stop_if_not’ to environment
[13:18:59.879] - copied ‘dim’ to environment
[13:18:59.879] - copied ‘valid_types’ to environment
[13:18:59.879] - copied ‘future.call.arguments’ to environment
[13:18:59.879] - copied ‘...future.elements_ii’ to environment
[13:18:59.879] - copied ‘...future.seeds_ii’ to environment
[13:18:59.879] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.880] assign_globals() ... done
[13:18:59.880] requestCore(): workers = 2
[13:18:59.882] MulticoreFuture started
[13:18:59.883] - Launch lazy future ... done
[13:18:59.883] run() for ‘MulticoreFuture’ ... done
[13:18:59.884] Created future:
[13:18:59.884] plan(): Setting new future strategy stack:
[13:18:59.884] List of future strategies:
[13:18:59.884] 1. sequential:
[13:18:59.884]    - args: function (..., envir = parent.frame())
[13:18:59.884]    - tweaked: FALSE
[13:18:59.884]    - call: NULL
[13:18:59.886] plan(): nbrOfWorkers() = 1
[13:18:59.889] plan(): Setting new future strategy stack:
[13:18:59.889] List of future strategies:
[13:18:59.889] 1. multicore:
[13:18:59.889]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.889]    - tweaked: FALSE
[13:18:59.889]    - call: plan(strategy)
[13:18:59.896] plan(): nbrOfWorkers() = 2
[13:18:59.884] MulticoreFuture:
[13:18:59.884] Label: ‘future_vapply-1’
[13:18:59.884] Expression:
[13:18:59.884] {
[13:18:59.884]     do.call(function(...) {
[13:18:59.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.884]             on.exit(options(oopts), add = TRUE)
[13:18:59.884]         }
[13:18:59.884]         {
[13:18:59.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.884]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.884]             })
[13:18:59.884]         }
[13:18:59.884]     }, args = future.call.arguments)
[13:18:59.884] }
[13:18:59.884] Lazy evaluation: FALSE
[13:18:59.884] Asynchronous evaluation: TRUE
[13:18:59.884] Local evaluation: TRUE
[13:18:59.884] Environment: R_GlobalEnv
[13:18:59.884] Capture standard output: TRUE
[13:18:59.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.884] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.884] Packages: 1 packages (‘future.apply’)
[13:18:59.884] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.884] Resolved: TRUE
[13:18:59.884] Value: <not collected>
[13:18:59.884] Conditions captured: <none>
[13:18:59.884] Early signaling: FALSE
[13:18:59.884] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.884] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.897] Chunk #1 of 2 ... DONE
[13:18:59.897] Chunk #2 of 2 ...
[13:18:59.897]  - Finding globals in 'X' for chunk #2 ...
[13:18:59.898] getGlobalsAndPackages() ...
[13:18:59.898] Searching for globals...
[13:18:59.898] 
[13:18:59.899] Searching for globals ... DONE
[13:18:59.899] - globals: [0] <none>
[13:18:59.899] getGlobalsAndPackages() ... DONE
[13:18:59.899]    + additional globals found: [n=0] 
[13:18:59.899]    + additional namespaces needed: [n=0] 
[13:18:59.899]  - Finding globals in 'X' for chunk #2 ... DONE
[13:18:59.900]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:18:59.900]  - seeds: <none>
[13:18:59.900] getGlobalsAndPackages() ...
[13:18:59.900] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.901] Resolving globals: FALSE
[13:18:59.901] Tweak future expression to call with '...' arguments ...
[13:18:59.901] {
[13:18:59.901]     do.call(function(...) {
[13:18:59.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.901]             on.exit(options(oopts), add = TRUE)
[13:18:59.901]         }
[13:18:59.901]         {
[13:18:59.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.901]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.901]             })
[13:18:59.901]         }
[13:18:59.901]     }, args = future.call.arguments)
[13:18:59.901] }
[13:18:59.902] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.902] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.903] - packages: [1] ‘future.apply’
[13:18:59.903] getGlobalsAndPackages() ... DONE
[13:18:59.904] run() for ‘Future’ ...
[13:18:59.904] - state: ‘created’
[13:18:59.904] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.909] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.909] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.909]   - Field: ‘label’
[13:18:59.909]   - Field: ‘local’
[13:18:59.909]   - Field: ‘owner’
[13:18:59.910]   - Field: ‘envir’
[13:18:59.910]   - Field: ‘workers’
[13:18:59.910]   - Field: ‘packages’
[13:18:59.910]   - Field: ‘gc’
[13:18:59.910]   - Field: ‘job’
[13:18:59.910]   - Field: ‘conditions’
[13:18:59.911]   - Field: ‘expr’
[13:18:59.911]   - Field: ‘uuid’
[13:18:59.911]   - Field: ‘seed’
[13:18:59.911]   - Field: ‘version’
[13:18:59.911]   - Field: ‘result’
[13:18:59.911]   - Field: ‘asynchronous’
[13:18:59.911]   - Field: ‘calls’
[13:18:59.911]   - Field: ‘globals’
[13:18:59.912]   - Field: ‘stdout’
[13:18:59.912]   - Field: ‘earlySignal’
[13:18:59.912]   - Field: ‘lazy’
[13:18:59.912]   - Field: ‘state’
[13:18:59.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:18:59.912] - Launch lazy future ...
[13:18:59.913] Packages needed by the future expression (n = 1): ‘future.apply’
[13:18:59.913] Packages needed by future strategies (n = 0): <none>
[13:18:59.913] {
[13:18:59.913]     {
[13:18:59.913]         {
[13:18:59.913]             ...future.startTime <- base::Sys.time()
[13:18:59.913]             {
[13:18:59.913]                 {
[13:18:59.913]                   {
[13:18:59.913]                     {
[13:18:59.913]                       {
[13:18:59.913]                         base::local({
[13:18:59.913]                           has_future <- base::requireNamespace("future", 
[13:18:59.913]                             quietly = TRUE)
[13:18:59.913]                           if (has_future) {
[13:18:59.913]                             ns <- base::getNamespace("future")
[13:18:59.913]                             version <- ns[[".package"]][["version"]]
[13:18:59.913]                             if (is.null(version)) 
[13:18:59.913]                               version <- utils::packageVersion("future")
[13:18:59.913]                           }
[13:18:59.913]                           else {
[13:18:59.913]                             version <- NULL
[13:18:59.913]                           }
[13:18:59.913]                           if (!has_future || version < "1.8.0") {
[13:18:59.913]                             info <- base::c(r_version = base::gsub("R version ", 
[13:18:59.913]                               "", base::R.version$version.string), 
[13:18:59.913]                               platform = base::sprintf("%s (%s-bit)", 
[13:18:59.913]                                 base::R.version$platform, 8 * 
[13:18:59.913]                                   base::.Machine$sizeof.pointer), 
[13:18:59.913]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:18:59.913]                                 "release", "version")], collapse = " "), 
[13:18:59.913]                               hostname = base::Sys.info()[["nodename"]])
[13:18:59.913]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:18:59.913]                               info)
[13:18:59.913]                             info <- base::paste(info, collapse = "; ")
[13:18:59.913]                             if (!has_future) {
[13:18:59.913]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:18:59.913]                                 info)
[13:18:59.913]                             }
[13:18:59.913]                             else {
[13:18:59.913]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:18:59.913]                                 info, version)
[13:18:59.913]                             }
[13:18:59.913]                             base::stop(msg)
[13:18:59.913]                           }
[13:18:59.913]                         })
[13:18:59.913]                       }
[13:18:59.913]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:18:59.913]                       base::options(mc.cores = 1L)
[13:18:59.913]                     }
[13:18:59.913]                     base::local({
[13:18:59.913]                       for (pkg in "future.apply") {
[13:18:59.913]                         base::loadNamespace(pkg)
[13:18:59.913]                         base::library(pkg, character.only = TRUE)
[13:18:59.913]                       }
[13:18:59.913]                     })
[13:18:59.913]                   }
[13:18:59.913]                   options(future.plan = NULL)
[13:18:59.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:18:59.913]                 }
[13:18:59.913]                 ...future.workdir <- getwd()
[13:18:59.913]             }
[13:18:59.913]             ...future.oldOptions <- base::as.list(base::.Options)
[13:18:59.913]             ...future.oldEnvVars <- base::Sys.getenv()
[13:18:59.913]         }
[13:18:59.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:18:59.913]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:18:59.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:18:59.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:18:59.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:18:59.913]             future.stdout.windows.reencode = NULL, width = 80L)
[13:18:59.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:18:59.913]             base::names(...future.oldOptions))
[13:18:59.913]     }
[13:18:59.913]     if (FALSE) {
[13:18:59.913]     }
[13:18:59.913]     else {
[13:18:59.913]         if (TRUE) {
[13:18:59.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:18:59.913]                 open = "w")
[13:18:59.913]         }
[13:18:59.913]         else {
[13:18:59.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:18:59.913]                 windows = "NUL", "/dev/null"), open = "w")
[13:18:59.913]         }
[13:18:59.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:18:59.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:18:59.913]             base::sink(type = "output", split = FALSE)
[13:18:59.913]             base::close(...future.stdout)
[13:18:59.913]         }, add = TRUE)
[13:18:59.913]     }
[13:18:59.913]     ...future.frame <- base::sys.nframe()
[13:18:59.913]     ...future.conditions <- base::list()
[13:18:59.913]     ...future.rng <- base::globalenv()$.Random.seed
[13:18:59.913]     if (FALSE) {
[13:18:59.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:18:59.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:18:59.913]     }
[13:18:59.913]     ...future.result <- base::tryCatch({
[13:18:59.913]         base::withCallingHandlers({
[13:18:59.913]             ...future.value <- base::withVisible(base::local({
[13:18:59.913]                 withCallingHandlers({
[13:18:59.913]                   {
[13:18:59.913]                     do.call(function(...) {
[13:18:59.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.913]                       if (!identical(...future.globals.maxSize.org, 
[13:18:59.913]                         ...future.globals.maxSize)) {
[13:18:59.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.913]                         on.exit(options(oopts), add = TRUE)
[13:18:59.913]                       }
[13:18:59.913]                       {
[13:18:59.913]                         lapply(seq_along(...future.elements_ii), 
[13:18:59.913]                           FUN = function(jj) {
[13:18:59.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.913]                             ...future.FUN(...future.X_jj, ...)
[13:18:59.913]                           })
[13:18:59.913]                       }
[13:18:59.913]                     }, args = future.call.arguments)
[13:18:59.913]                   }
[13:18:59.913]                 }, immediateCondition = function(cond) {
[13:18:59.913]                   save_rds <- function (object, pathname, ...) 
[13:18:59.913]                   {
[13:18:59.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:18:59.913]                     if (file_test("-f", pathname_tmp)) {
[13:18:59.913]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:18:59.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.913]                         fi_tmp[["mtime"]])
[13:18:59.913]                     }
[13:18:59.913]                     tryCatch({
[13:18:59.913]                       saveRDS(object, file = pathname_tmp, ...)
[13:18:59.913]                     }, error = function(ex) {
[13:18:59.913]                       msg <- conditionMessage(ex)
[13:18:59.913]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:18:59.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.913]                         fi_tmp[["mtime"]], msg)
[13:18:59.913]                       ex$message <- msg
[13:18:59.913]                       stop(ex)
[13:18:59.913]                     })
[13:18:59.913]                     stopifnot(file_test("-f", pathname_tmp))
[13:18:59.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:18:59.913]                     if (!res || file_test("-f", pathname_tmp)) {
[13:18:59.913]                       fi_tmp <- file.info(pathname_tmp)
[13:18:59.913]                       fi <- file.info(pathname)
[13:18:59.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:18:59.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:18:59.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:18:59.913]                         fi[["size"]], fi[["mtime"]])
[13:18:59.913]                       stop(msg)
[13:18:59.913]                     }
[13:18:59.913]                     invisible(pathname)
[13:18:59.913]                   }
[13:18:59.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:18:59.913]                     rootPath = tempdir()) 
[13:18:59.913]                   {
[13:18:59.913]                     obj <- list(time = Sys.time(), condition = cond)
[13:18:59.913]                     file <- tempfile(pattern = class(cond)[1], 
[13:18:59.913]                       tmpdir = path, fileext = ".rds")
[13:18:59.913]                     save_rds(obj, file)
[13:18:59.913]                   }
[13:18:59.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:18:59.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.913]                   {
[13:18:59.913]                     inherits <- base::inherits
[13:18:59.913]                     invokeRestart <- base::invokeRestart
[13:18:59.913]                     is.null <- base::is.null
[13:18:59.913]                     muffled <- FALSE
[13:18:59.913]                     if (inherits(cond, "message")) {
[13:18:59.913]                       muffled <- grepl(pattern, "muffleMessage")
[13:18:59.913]                       if (muffled) 
[13:18:59.913]                         invokeRestart("muffleMessage")
[13:18:59.913]                     }
[13:18:59.913]                     else if (inherits(cond, "warning")) {
[13:18:59.913]                       muffled <- grepl(pattern, "muffleWarning")
[13:18:59.913]                       if (muffled) 
[13:18:59.913]                         invokeRestart("muffleWarning")
[13:18:59.913]                     }
[13:18:59.913]                     else if (inherits(cond, "condition")) {
[13:18:59.913]                       if (!is.null(pattern)) {
[13:18:59.913]                         computeRestarts <- base::computeRestarts
[13:18:59.913]                         grepl <- base::grepl
[13:18:59.913]                         restarts <- computeRestarts(cond)
[13:18:59.913]                         for (restart in restarts) {
[13:18:59.913]                           name <- restart$name
[13:18:59.913]                           if (is.null(name)) 
[13:18:59.913]                             next
[13:18:59.913]                           if (!grepl(pattern, name)) 
[13:18:59.913]                             next
[13:18:59.913]                           invokeRestart(restart)
[13:18:59.913]                           muffled <- TRUE
[13:18:59.913]                           break
[13:18:59.913]                         }
[13:18:59.913]                       }
[13:18:59.913]                     }
[13:18:59.913]                     invisible(muffled)
[13:18:59.913]                   }
[13:18:59.913]                   muffleCondition(cond)
[13:18:59.913]                 })
[13:18:59.913]             }))
[13:18:59.913]             future::FutureResult(value = ...future.value$value, 
[13:18:59.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.913]                   ...future.rng), globalenv = if (FALSE) 
[13:18:59.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:18:59.913]                     ...future.globalenv.names))
[13:18:59.913]                 else NULL, started = ...future.startTime, version = "1.8")
[13:18:59.913]         }, condition = base::local({
[13:18:59.913]             c <- base::c
[13:18:59.913]             inherits <- base::inherits
[13:18:59.913]             invokeRestart <- base::invokeRestart
[13:18:59.913]             length <- base::length
[13:18:59.913]             list <- base::list
[13:18:59.913]             seq.int <- base::seq.int
[13:18:59.913]             signalCondition <- base::signalCondition
[13:18:59.913]             sys.calls <- base::sys.calls
[13:18:59.913]             `[[` <- base::`[[`
[13:18:59.913]             `+` <- base::`+`
[13:18:59.913]             `<<-` <- base::`<<-`
[13:18:59.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:18:59.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:18:59.913]                   3L)]
[13:18:59.913]             }
[13:18:59.913]             function(cond) {
[13:18:59.913]                 is_error <- inherits(cond, "error")
[13:18:59.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:18:59.913]                   NULL)
[13:18:59.913]                 if (is_error) {
[13:18:59.913]                   sessionInformation <- function() {
[13:18:59.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:18:59.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:18:59.913]                       search = base::search(), system = base::Sys.info())
[13:18:59.913]                   }
[13:18:59.913]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:18:59.913]                     cond$call), session = sessionInformation(), 
[13:18:59.913]                     timestamp = base::Sys.time(), signaled = 0L)
[13:18:59.913]                   signalCondition(cond)
[13:18:59.913]                 }
[13:18:59.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:18:59.913]                 "immediateCondition"))) {
[13:18:59.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:18:59.913]                   ...future.conditions[[length(...future.conditions) + 
[13:18:59.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:18:59.913]                   if (TRUE && !signal) {
[13:18:59.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.913]                     {
[13:18:59.913]                       inherits <- base::inherits
[13:18:59.913]                       invokeRestart <- base::invokeRestart
[13:18:59.913]                       is.null <- base::is.null
[13:18:59.913]                       muffled <- FALSE
[13:18:59.913]                       if (inherits(cond, "message")) {
[13:18:59.913]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.913]                         if (muffled) 
[13:18:59.913]                           invokeRestart("muffleMessage")
[13:18:59.913]                       }
[13:18:59.913]                       else if (inherits(cond, "warning")) {
[13:18:59.913]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.913]                         if (muffled) 
[13:18:59.913]                           invokeRestart("muffleWarning")
[13:18:59.913]                       }
[13:18:59.913]                       else if (inherits(cond, "condition")) {
[13:18:59.913]                         if (!is.null(pattern)) {
[13:18:59.913]                           computeRestarts <- base::computeRestarts
[13:18:59.913]                           grepl <- base::grepl
[13:18:59.913]                           restarts <- computeRestarts(cond)
[13:18:59.913]                           for (restart in restarts) {
[13:18:59.913]                             name <- restart$name
[13:18:59.913]                             if (is.null(name)) 
[13:18:59.913]                               next
[13:18:59.913]                             if (!grepl(pattern, name)) 
[13:18:59.913]                               next
[13:18:59.913]                             invokeRestart(restart)
[13:18:59.913]                             muffled <- TRUE
[13:18:59.913]                             break
[13:18:59.913]                           }
[13:18:59.913]                         }
[13:18:59.913]                       }
[13:18:59.913]                       invisible(muffled)
[13:18:59.913]                     }
[13:18:59.913]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.913]                   }
[13:18:59.913]                 }
[13:18:59.913]                 else {
[13:18:59.913]                   if (TRUE) {
[13:18:59.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:18:59.913]                     {
[13:18:59.913]                       inherits <- base::inherits
[13:18:59.913]                       invokeRestart <- base::invokeRestart
[13:18:59.913]                       is.null <- base::is.null
[13:18:59.913]                       muffled <- FALSE
[13:18:59.913]                       if (inherits(cond, "message")) {
[13:18:59.913]                         muffled <- grepl(pattern, "muffleMessage")
[13:18:59.913]                         if (muffled) 
[13:18:59.913]                           invokeRestart("muffleMessage")
[13:18:59.913]                       }
[13:18:59.913]                       else if (inherits(cond, "warning")) {
[13:18:59.913]                         muffled <- grepl(pattern, "muffleWarning")
[13:18:59.913]                         if (muffled) 
[13:18:59.913]                           invokeRestart("muffleWarning")
[13:18:59.913]                       }
[13:18:59.913]                       else if (inherits(cond, "condition")) {
[13:18:59.913]                         if (!is.null(pattern)) {
[13:18:59.913]                           computeRestarts <- base::computeRestarts
[13:18:59.913]                           grepl <- base::grepl
[13:18:59.913]                           restarts <- computeRestarts(cond)
[13:18:59.913]                           for (restart in restarts) {
[13:18:59.913]                             name <- restart$name
[13:18:59.913]                             if (is.null(name)) 
[13:18:59.913]                               next
[13:18:59.913]                             if (!grepl(pattern, name)) 
[13:18:59.913]                               next
[13:18:59.913]                             invokeRestart(restart)
[13:18:59.913]                             muffled <- TRUE
[13:18:59.913]                             break
[13:18:59.913]                           }
[13:18:59.913]                         }
[13:18:59.913]                       }
[13:18:59.913]                       invisible(muffled)
[13:18:59.913]                     }
[13:18:59.913]                     muffleCondition(cond, pattern = "^muffle")
[13:18:59.913]                   }
[13:18:59.913]                 }
[13:18:59.913]             }
[13:18:59.913]         }))
[13:18:59.913]     }, error = function(ex) {
[13:18:59.913]         base::structure(base::list(value = NULL, visible = NULL, 
[13:18:59.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:18:59.913]                 ...future.rng), started = ...future.startTime, 
[13:18:59.913]             finished = Sys.time(), session_uuid = NA_character_, 
[13:18:59.913]             version = "1.8"), class = "FutureResult")
[13:18:59.913]     }, finally = {
[13:18:59.913]         if (!identical(...future.workdir, getwd())) 
[13:18:59.913]             setwd(...future.workdir)
[13:18:59.913]         {
[13:18:59.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:18:59.913]                 ...future.oldOptions$nwarnings <- NULL
[13:18:59.913]             }
[13:18:59.913]             base::options(...future.oldOptions)
[13:18:59.913]             if (.Platform$OS.type == "windows") {
[13:18:59.913]                 old_names <- names(...future.oldEnvVars)
[13:18:59.913]                 envs <- base::Sys.getenv()
[13:18:59.913]                 names <- names(envs)
[13:18:59.913]                 common <- intersect(names, old_names)
[13:18:59.913]                 added <- setdiff(names, old_names)
[13:18:59.913]                 removed <- setdiff(old_names, names)
[13:18:59.913]                 changed <- common[...future.oldEnvVars[common] != 
[13:18:59.913]                   envs[common]]
[13:18:59.913]                 NAMES <- toupper(changed)
[13:18:59.913]                 args <- list()
[13:18:59.913]                 for (kk in seq_along(NAMES)) {
[13:18:59.913]                   name <- changed[[kk]]
[13:18:59.913]                   NAME <- NAMES[[kk]]
[13:18:59.913]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.913]                     next
[13:18:59.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.913]                 }
[13:18:59.913]                 NAMES <- toupper(added)
[13:18:59.913]                 for (kk in seq_along(NAMES)) {
[13:18:59.913]                   name <- added[[kk]]
[13:18:59.913]                   NAME <- NAMES[[kk]]
[13:18:59.913]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.913]                     next
[13:18:59.913]                   args[[name]] <- ""
[13:18:59.913]                 }
[13:18:59.913]                 NAMES <- toupper(removed)
[13:18:59.913]                 for (kk in seq_along(NAMES)) {
[13:18:59.913]                   name <- removed[[kk]]
[13:18:59.913]                   NAME <- NAMES[[kk]]
[13:18:59.913]                   if (name != NAME && is.element(NAME, old_names)) 
[13:18:59.913]                     next
[13:18:59.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:18:59.913]                 }
[13:18:59.913]                 if (length(args) > 0) 
[13:18:59.913]                   base::do.call(base::Sys.setenv, args = args)
[13:18:59.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:18:59.913]             }
[13:18:59.913]             else {
[13:18:59.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:18:59.913]             }
[13:18:59.913]             {
[13:18:59.913]                 if (base::length(...future.futureOptionsAdded) > 
[13:18:59.913]                   0L) {
[13:18:59.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:18:59.913]                   base::names(opts) <- ...future.futureOptionsAdded
[13:18:59.913]                   base::options(opts)
[13:18:59.913]                 }
[13:18:59.913]                 {
[13:18:59.913]                   {
[13:18:59.913]                     base::options(mc.cores = ...future.mc.cores.old)
[13:18:59.913]                     NULL
[13:18:59.913]                   }
[13:18:59.913]                   options(future.plan = NULL)
[13:18:59.913]                   if (is.na(NA_character_)) 
[13:18:59.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:18:59.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:18:59.913]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:18:59.913]                     envir = parent.frame()) 
[13:18:59.913]                   {
[13:18:59.913]                     default_workers <- missing(workers)
[13:18:59.913]                     if (is.function(workers)) 
[13:18:59.913]                       workers <- workers()
[13:18:59.913]                     workers <- structure(as.integer(workers), 
[13:18:59.913]                       class = class(workers))
[13:18:59.913]                     stop_if_not(is.finite(workers), workers >= 
[13:18:59.913]                       1L)
[13:18:59.913]                     if ((workers == 1L && !inherits(workers, 
[13:18:59.913]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:18:59.913]                       if (default_workers) 
[13:18:59.913]                         supportsMulticore(warn = TRUE)
[13:18:59.913]                       return(sequential(..., envir = envir))
[13:18:59.913]                     }
[13:18:59.913]                     oopts <- options(mc.cores = workers)
[13:18:59.913]                     on.exit(options(oopts))
[13:18:59.913]                     future <- MulticoreFuture(..., workers = workers, 
[13:18:59.913]                       envir = envir)
[13:18:59.913]                     if (!future$lazy) 
[13:18:59.913]                       future <- run(future)
[13:18:59.913]                     invisible(future)
[13:18:59.913]                   }), .cleanup = FALSE, .init = FALSE)
[13:18:59.913]                 }
[13:18:59.913]             }
[13:18:59.913]         }
[13:18:59.913]     })
[13:18:59.913]     if (TRUE) {
[13:18:59.913]         base::sink(type = "output", split = FALSE)
[13:18:59.913]         if (TRUE) {
[13:18:59.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:18:59.913]         }
[13:18:59.913]         else {
[13:18:59.913]             ...future.result["stdout"] <- base::list(NULL)
[13:18:59.913]         }
[13:18:59.913]         base::close(...future.stdout)
[13:18:59.913]         ...future.stdout <- NULL
[13:18:59.913]     }
[13:18:59.913]     ...future.result$conditions <- ...future.conditions
[13:18:59.913]     ...future.result$finished <- base::Sys.time()
[13:18:59.913]     ...future.result
[13:18:59.913] }
[13:18:59.917] assign_globals() ...
[13:18:59.917] List of 11
[13:18:59.917]  $ ...future.FUN            :function (x, ...)  
[13:18:59.917]  $ x_FUN                    :function (x, y)  
[13:18:59.917]  $ times                    : int 15
[13:18:59.917]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.917]  $ stop_if_not              :function (...)  
[13:18:59.917]  $ dim                      : int [1:2] 3 5
[13:18:59.917]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:18:59.917]  $ future.call.arguments    :List of 1
[13:18:59.917]   ..$ y: num [1:5] 2 4 6 8 10
[13:18:59.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.917]  $ ...future.elements_ii    :List of 2
[13:18:59.917]   ..$ C: num 70
[13:18:59.917]   ..$ D: num 80
[13:18:59.917]  $ ...future.seeds_ii       : NULL
[13:18:59.917]  $ ...future.globals.maxSize: NULL
[13:18:59.917]  - attr(*, "resolved")= logi FALSE
[13:18:59.917]  - attr(*, "total_size")= num 98600
[13:18:59.917]  - attr(*, "where")=List of 11
[13:18:59.917]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ times                    :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:18:59.917]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:18:59.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.917]  - attr(*, "already-done")= logi TRUE
[13:18:59.931] - copied ‘...future.FUN’ to environment
[13:18:59.931] - reassign environment for ‘x_FUN’
[13:18:59.932] - copied ‘x_FUN’ to environment
[13:18:59.932] - copied ‘times’ to environment
[13:18:59.932] - copied ‘stopf’ to environment
[13:18:59.932] - copied ‘stop_if_not’ to environment
[13:18:59.932] - copied ‘dim’ to environment
[13:18:59.932] - copied ‘valid_types’ to environment
[13:18:59.932] - copied ‘future.call.arguments’ to environment
[13:18:59.932] - copied ‘...future.elements_ii’ to environment
[13:18:59.933] - copied ‘...future.seeds_ii’ to environment
[13:18:59.933] - copied ‘...future.globals.maxSize’ to environment
[13:18:59.933] assign_globals() ... done
[13:18:59.933] requestCore(): workers = 2
[13:18:59.935] MulticoreFuture started
[13:18:59.936] - Launch lazy future ... done
[13:18:59.937] run() for ‘MulticoreFuture’ ... done
[13:18:59.937] Created future:
[13:18:59.937] plan(): Setting new future strategy stack:
[13:18:59.938] List of future strategies:
[13:18:59.938] 1. sequential:
[13:18:59.938]    - args: function (..., envir = parent.frame())
[13:18:59.938]    - tweaked: FALSE
[13:18:59.938]    - call: NULL
[13:18:59.939] plan(): nbrOfWorkers() = 1
[13:18:59.941] plan(): Setting new future strategy stack:
[13:18:59.942] List of future strategies:
[13:18:59.942] 1. multicore:
[13:18:59.942]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:18:59.942]    - tweaked: FALSE
[13:18:59.942]    - call: plan(strategy)
[13:18:59.947] plan(): nbrOfWorkers() = 2
[13:18:59.938] MulticoreFuture:
[13:18:59.938] Label: ‘future_vapply-2’
[13:18:59.938] Expression:
[13:18:59.938] {
[13:18:59.938]     do.call(function(...) {
[13:18:59.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.938]             on.exit(options(oopts), add = TRUE)
[13:18:59.938]         }
[13:18:59.938]         {
[13:18:59.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.938]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.938]             })
[13:18:59.938]         }
[13:18:59.938]     }, args = future.call.arguments)
[13:18:59.938] }
[13:18:59.938] Lazy evaluation: FALSE
[13:18:59.938] Asynchronous evaluation: TRUE
[13:18:59.938] Local evaluation: TRUE
[13:18:59.938] Environment: R_GlobalEnv
[13:18:59.938] Capture standard output: TRUE
[13:18:59.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:18:59.938] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:18:59.938] Packages: 1 packages (‘future.apply’)
[13:18:59.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:18:59.938] Resolved: TRUE
[13:18:59.938] Value: <not collected>
[13:18:59.938] Conditions captured: <none>
[13:18:59.938] Early signaling: FALSE
[13:18:59.938] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:18:59.938] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.949] Chunk #2 of 2 ... DONE
[13:18:59.949] Launching 2 futures (chunks) ... DONE
[13:18:59.949] Resolving 2 futures (chunks) ...
[13:18:59.949] resolve() on list ...
[13:18:59.949]  recursive: 0
[13:18:59.949]  length: 2
[13:18:59.950] 
[13:18:59.950] Future #1
[13:18:59.951] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:18:59.951] - nx: 2
[13:18:59.951] - relay: TRUE
[13:18:59.952] - stdout: TRUE
[13:18:59.952] - signal: TRUE
[13:18:59.952] - resignal: FALSE
[13:18:59.952] - force: TRUE
[13:18:59.952] - relayed: [n=2] FALSE, FALSE
[13:18:59.952] - queued futures: [n=2] FALSE, FALSE
[13:18:59.953]  - until=1
[13:18:59.953]  - relaying element #1
[13:18:59.953] - relayed: [n=2] TRUE, FALSE
[13:18:59.953] - queued futures: [n=2] TRUE, FALSE
[13:18:59.954] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:18:59.954]  length: 1 (resolved future 1)
[13:18:59.954] Future #2
[13:18:59.955] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:18:59.955] - nx: 2
[13:18:59.955] - relay: TRUE
[13:18:59.955] - stdout: TRUE
[13:18:59.956] - signal: TRUE
[13:18:59.956] - resignal: FALSE
[13:18:59.956] - force: TRUE
[13:18:59.956] - relayed: [n=2] TRUE, FALSE
[13:18:59.956] - queued futures: [n=2] TRUE, FALSE
[13:18:59.956]  - until=2
[13:18:59.956]  - relaying element #2
[13:18:59.957] - relayed: [n=2] TRUE, TRUE
[13:18:59.957] - queued futures: [n=2] TRUE, TRUE
[13:18:59.957] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:18:59.957]  length: 0 (resolved future 2)
[13:18:59.957] Relaying remaining futures
[13:18:59.957] signalConditionsASAP(NULL, pos=0) ...
[13:18:59.957] - nx: 2
[13:18:59.957] - relay: TRUE
[13:18:59.958] - stdout: TRUE
[13:18:59.958] - signal: TRUE
[13:18:59.958] - resignal: FALSE
[13:18:59.958] - force: TRUE
[13:18:59.958] - relayed: [n=2] TRUE, TRUE
[13:18:59.958] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:18:59.958] - relayed: [n=2] TRUE, TRUE
[13:18:59.958] - queued futures: [n=2] TRUE, TRUE
[13:18:59.958] signalConditionsASAP(NULL, pos=0) ... done
[13:18:59.959] resolve() on list ... DONE
[13:18:59.959]  - Number of value chunks collected: 2
[13:18:59.959] Resolving 2 futures (chunks) ... DONE
[13:18:59.959] Reducing values from 2 chunks ...
[13:18:59.959]  - Number of values collected after concatenation: 4
[13:18:59.959]  - Number of values expected: 4
[13:18:59.959] Reducing values from 2 chunks ... DONE
[13:18:59.959] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:18:59.962] future_lapply() ...
[13:18:59.971] Number of chunks: 2
[13:18:59.971] getGlobalsAndPackagesXApply() ...
[13:18:59.971]  - future.globals: TRUE
[13:18:59.971] getGlobalsAndPackages() ...
[13:18:59.971] Searching for globals...
[13:18:59.976] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:18:59.976] Searching for globals ... DONE
[13:18:59.976] Resolving globals: FALSE
[13:18:59.977] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:18:59.978] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:18:59.978] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.978] - packages: [1] ‘future.apply’
[13:18:59.978] getGlobalsAndPackages() ... DONE
[13:18:59.978]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:18:59.978]  - needed namespaces: [n=1] ‘future.apply’
[13:18:59.979] Finding globals ... DONE
[13:18:59.979]  - use_args: TRUE
[13:18:59.979]  - Getting '...' globals ...
[13:18:59.979] resolve() on list ...
[13:18:59.979]  recursive: 0
[13:18:59.979]  length: 1
[13:18:59.979]  elements: ‘...’
[13:18:59.979]  length: 0 (resolved future 1)
[13:18:59.980] resolve() on list ... DONE
[13:18:59.980]    - '...' content: [n=0] 
[13:18:59.980] List of 1
[13:18:59.980]  $ ...: list()
[13:18:59.980]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.980]  - attr(*, "where")=List of 1
[13:18:59.980]   ..$ ...:<environment: 0x555f7b4b9ba8> 
[13:18:59.980]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.980]  - attr(*, "resolved")= logi TRUE
[13:18:59.980]  - attr(*, "total_size")= num NA
[13:18:59.982]  - Getting '...' globals ... DONE
[13:18:59.983] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:18:59.983] List of 8
[13:18:59.983]  $ ...future.FUN:function (x, ...)  
[13:18:59.983]  $ x_FUN        :function (x)  
[13:18:59.983]  $ times        : int 1
[13:18:59.983]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:18:59.983]  $ stop_if_not  :function (...)  
[13:18:59.983]  $ dim          : NULL
[13:18:59.983]  $ valid_types  : chr "logical"
[13:18:59.983]  $ ...          : list()
[13:18:59.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:18:59.983]  - attr(*, "where")=List of 8
[13:18:59.983]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ times        :<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ dim          :<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:18:59.983]   ..$ ...          :<environment: 0x555f7b4b9ba8> 
[13:18:59.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:18:59.983]  - attr(*, "resolved")= logi FALSE
[13:18:59.983]  - attr(*, "total_size")= num 94200
[13:18:59.988] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:18:59.988] getGlobalsAndPackagesXApply() ... DONE
[13:18:59.990] Number of futures (= number of chunks): 2
[13:18:59.991] Launching 2 futures (chunks) ...
[13:18:59.991] Chunk #1 of 2 ...
[13:18:59.991]  - Finding globals in 'X' for chunk #1 ...
[13:18:59.991] getGlobalsAndPackages() ...
[13:18:59.991] Searching for globals...
[13:18:59.991] 
[13:18:59.992] Searching for globals ... DONE
[13:18:59.992] - globals: [0] <none>
[13:18:59.992] getGlobalsAndPackages() ... DONE
[13:18:59.992]    + additional globals found: [n=0] 
[13:18:59.992]    + additional namespaces needed: [n=0] 
[13:18:59.992]  - Finding globals in 'X' for chunk #1 ... DONE
[13:18:59.992]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[13:18:59.992]  - seeds: <none>
[13:18:59.992] getGlobalsAndPackages() ...
[13:18:59.993] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.993] Resolving globals: FALSE
[13:18:59.993] Tweak future expression to call with '...' arguments ...
[13:18:59.993] {
[13:18:59.993]     do.call(function(...) {
[13:18:59.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:18:59.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:18:59.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:18:59.993]             on.exit(options(oopts), add = TRUE)
[13:18:59.993]         }
[13:18:59.993]         {
[13:18:59.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:18:59.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:18:59.993]                 ...future.FUN(...future.X_jj, ...)
[13:18:59.993]             })
[13:18:59.993]         }
[13:18:59.993]     }, args = future.call.arguments)
[13:18:59.993] }
[13:18:59.993] Tweak future expression to call with '...' arguments ... DONE
[13:18:59.994] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:18:59.994] - packages: [1] ‘future.apply’
[13:18:59.994] getGlobalsAndPackages() ... DONE
[13:18:59.994] run() for ‘Future’ ...
[13:18:59.995] - state: ‘created’
[13:18:59.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:18:59.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:18:59.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:18:59.999]   - Field: ‘label’
[13:18:59.999]   - Field: ‘local’
[13:18:59.999]   - Field: ‘owner’
[13:18:59.999]   - Field: ‘envir’
[13:18:59.999]   - Field: ‘workers’
[13:18:59.999]   - Field: ‘packages’
[13:19:00.000]   - Field: ‘gc’
[13:19:00.000]   - Field: ‘job’
[13:19:00.000]   - Field: ‘conditions’
[13:19:00.000]   - Field: ‘expr’
[13:19:00.000]   - Field: ‘uuid’
[13:19:00.000]   - Field: ‘seed’
[13:19:00.000]   - Field: ‘version’
[13:19:00.000]   - Field: ‘result’
[13:19:00.000]   - Field: ‘asynchronous’
[13:19:00.001]   - Field: ‘calls’
[13:19:00.001]   - Field: ‘globals’
[13:19:00.001]   - Field: ‘stdout’
[13:19:00.001]   - Field: ‘earlySignal’
[13:19:00.001]   - Field: ‘lazy’
[13:19:00.001]   - Field: ‘state’
[13:19:00.001] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:00.001] - Launch lazy future ...
[13:19:00.002] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:00.002] Packages needed by future strategies (n = 0): <none>
[13:19:00.002] {
[13:19:00.002]     {
[13:19:00.002]         {
[13:19:00.002]             ...future.startTime <- base::Sys.time()
[13:19:00.002]             {
[13:19:00.002]                 {
[13:19:00.002]                   {
[13:19:00.002]                     {
[13:19:00.002]                       {
[13:19:00.002]                         base::local({
[13:19:00.002]                           has_future <- base::requireNamespace("future", 
[13:19:00.002]                             quietly = TRUE)
[13:19:00.002]                           if (has_future) {
[13:19:00.002]                             ns <- base::getNamespace("future")
[13:19:00.002]                             version <- ns[[".package"]][["version"]]
[13:19:00.002]                             if (is.null(version)) 
[13:19:00.002]                               version <- utils::packageVersion("future")
[13:19:00.002]                           }
[13:19:00.002]                           else {
[13:19:00.002]                             version <- NULL
[13:19:00.002]                           }
[13:19:00.002]                           if (!has_future || version < "1.8.0") {
[13:19:00.002]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.002]                               "", base::R.version$version.string), 
[13:19:00.002]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:00.002]                                 base::R.version$platform, 8 * 
[13:19:00.002]                                   base::.Machine$sizeof.pointer), 
[13:19:00.002]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.002]                                 "release", "version")], collapse = " "), 
[13:19:00.002]                               hostname = base::Sys.info()[["nodename"]])
[13:19:00.002]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.002]                               info)
[13:19:00.002]                             info <- base::paste(info, collapse = "; ")
[13:19:00.002]                             if (!has_future) {
[13:19:00.002]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.002]                                 info)
[13:19:00.002]                             }
[13:19:00.002]                             else {
[13:19:00.002]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.002]                                 info, version)
[13:19:00.002]                             }
[13:19:00.002]                             base::stop(msg)
[13:19:00.002]                           }
[13:19:00.002]                         })
[13:19:00.002]                       }
[13:19:00.002]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.002]                       base::options(mc.cores = 1L)
[13:19:00.002]                     }
[13:19:00.002]                     base::local({
[13:19:00.002]                       for (pkg in "future.apply") {
[13:19:00.002]                         base::loadNamespace(pkg)
[13:19:00.002]                         base::library(pkg, character.only = TRUE)
[13:19:00.002]                       }
[13:19:00.002]                     })
[13:19:00.002]                   }
[13:19:00.002]                   options(future.plan = NULL)
[13:19:00.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.002]                 }
[13:19:00.002]                 ...future.workdir <- getwd()
[13:19:00.002]             }
[13:19:00.002]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.002]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.002]         }
[13:19:00.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.002]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[13:19:00.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.002]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.002]             base::names(...future.oldOptions))
[13:19:00.002]     }
[13:19:00.002]     if (FALSE) {
[13:19:00.002]     }
[13:19:00.002]     else {
[13:19:00.002]         if (TRUE) {
[13:19:00.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.002]                 open = "w")
[13:19:00.002]         }
[13:19:00.002]         else {
[13:19:00.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.002]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.002]         }
[13:19:00.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.002]             base::sink(type = "output", split = FALSE)
[13:19:00.002]             base::close(...future.stdout)
[13:19:00.002]         }, add = TRUE)
[13:19:00.002]     }
[13:19:00.002]     ...future.frame <- base::sys.nframe()
[13:19:00.002]     ...future.conditions <- base::list()
[13:19:00.002]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.002]     if (FALSE) {
[13:19:00.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.002]     }
[13:19:00.002]     ...future.result <- base::tryCatch({
[13:19:00.002]         base::withCallingHandlers({
[13:19:00.002]             ...future.value <- base::withVisible(base::local({
[13:19:00.002]                 withCallingHandlers({
[13:19:00.002]                   {
[13:19:00.002]                     do.call(function(...) {
[13:19:00.002]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.002]                       if (!identical(...future.globals.maxSize.org, 
[13:19:00.002]                         ...future.globals.maxSize)) {
[13:19:00.002]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.002]                         on.exit(options(oopts), add = TRUE)
[13:19:00.002]                       }
[13:19:00.002]                       {
[13:19:00.002]                         lapply(seq_along(...future.elements_ii), 
[13:19:00.002]                           FUN = function(jj) {
[13:19:00.002]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.002]                             ...future.FUN(...future.X_jj, ...)
[13:19:00.002]                           })
[13:19:00.002]                       }
[13:19:00.002]                     }, args = future.call.arguments)
[13:19:00.002]                   }
[13:19:00.002]                 }, immediateCondition = function(cond) {
[13:19:00.002]                   save_rds <- function (object, pathname, ...) 
[13:19:00.002]                   {
[13:19:00.002]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:00.002]                     if (file_test("-f", pathname_tmp)) {
[13:19:00.002]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.002]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:00.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.002]                         fi_tmp[["mtime"]])
[13:19:00.002]                     }
[13:19:00.002]                     tryCatch({
[13:19:00.002]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:00.002]                     }, error = function(ex) {
[13:19:00.002]                       msg <- conditionMessage(ex)
[13:19:00.002]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.002]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:00.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.002]                         fi_tmp[["mtime"]], msg)
[13:19:00.002]                       ex$message <- msg
[13:19:00.002]                       stop(ex)
[13:19:00.002]                     })
[13:19:00.002]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:00.002]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:00.002]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:00.002]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.002]                       fi <- file.info(pathname)
[13:19:00.002]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:00.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.002]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:00.002]                         fi[["size"]], fi[["mtime"]])
[13:19:00.002]                       stop(msg)
[13:19:00.002]                     }
[13:19:00.002]                     invisible(pathname)
[13:19:00.002]                   }
[13:19:00.002]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:00.002]                     rootPath = tempdir()) 
[13:19:00.002]                   {
[13:19:00.002]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:00.002]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:00.002]                       tmpdir = path, fileext = ".rds")
[13:19:00.002]                     save_rds(obj, file)
[13:19:00.002]                   }
[13:19:00.002]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:19:00.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.002]                   {
[13:19:00.002]                     inherits <- base::inherits
[13:19:00.002]                     invokeRestart <- base::invokeRestart
[13:19:00.002]                     is.null <- base::is.null
[13:19:00.002]                     muffled <- FALSE
[13:19:00.002]                     if (inherits(cond, "message")) {
[13:19:00.002]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.002]                       if (muffled) 
[13:19:00.002]                         invokeRestart("muffleMessage")
[13:19:00.002]                     }
[13:19:00.002]                     else if (inherits(cond, "warning")) {
[13:19:00.002]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.002]                       if (muffled) 
[13:19:00.002]                         invokeRestart("muffleWarning")
[13:19:00.002]                     }
[13:19:00.002]                     else if (inherits(cond, "condition")) {
[13:19:00.002]                       if (!is.null(pattern)) {
[13:19:00.002]                         computeRestarts <- base::computeRestarts
[13:19:00.002]                         grepl <- base::grepl
[13:19:00.002]                         restarts <- computeRestarts(cond)
[13:19:00.002]                         for (restart in restarts) {
[13:19:00.002]                           name <- restart$name
[13:19:00.002]                           if (is.null(name)) 
[13:19:00.002]                             next
[13:19:00.002]                           if (!grepl(pattern, name)) 
[13:19:00.002]                             next
[13:19:00.002]                           invokeRestart(restart)
[13:19:00.002]                           muffled <- TRUE
[13:19:00.002]                           break
[13:19:00.002]                         }
[13:19:00.002]                       }
[13:19:00.002]                     }
[13:19:00.002]                     invisible(muffled)
[13:19:00.002]                   }
[13:19:00.002]                   muffleCondition(cond)
[13:19:00.002]                 })
[13:19:00.002]             }))
[13:19:00.002]             future::FutureResult(value = ...future.value$value, 
[13:19:00.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.002]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.002]                     ...future.globalenv.names))
[13:19:00.002]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.002]         }, condition = base::local({
[13:19:00.002]             c <- base::c
[13:19:00.002]             inherits <- base::inherits
[13:19:00.002]             invokeRestart <- base::invokeRestart
[13:19:00.002]             length <- base::length
[13:19:00.002]             list <- base::list
[13:19:00.002]             seq.int <- base::seq.int
[13:19:00.002]             signalCondition <- base::signalCondition
[13:19:00.002]             sys.calls <- base::sys.calls
[13:19:00.002]             `[[` <- base::`[[`
[13:19:00.002]             `+` <- base::`+`
[13:19:00.002]             `<<-` <- base::`<<-`
[13:19:00.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.002]                   3L)]
[13:19:00.002]             }
[13:19:00.002]             function(cond) {
[13:19:00.002]                 is_error <- inherits(cond, "error")
[13:19:00.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.002]                   NULL)
[13:19:00.002]                 if (is_error) {
[13:19:00.002]                   sessionInformation <- function() {
[13:19:00.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.002]                       search = base::search(), system = base::Sys.info())
[13:19:00.002]                   }
[13:19:00.002]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.002]                     cond$call), session = sessionInformation(), 
[13:19:00.002]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.002]                   signalCondition(cond)
[13:19:00.002]                 }
[13:19:00.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.002]                 "immediateCondition"))) {
[13:19:00.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.002]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.002]                   if (TRUE && !signal) {
[13:19:00.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.002]                     {
[13:19:00.002]                       inherits <- base::inherits
[13:19:00.002]                       invokeRestart <- base::invokeRestart
[13:19:00.002]                       is.null <- base::is.null
[13:19:00.002]                       muffled <- FALSE
[13:19:00.002]                       if (inherits(cond, "message")) {
[13:19:00.002]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.002]                         if (muffled) 
[13:19:00.002]                           invokeRestart("muffleMessage")
[13:19:00.002]                       }
[13:19:00.002]                       else if (inherits(cond, "warning")) {
[13:19:00.002]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.002]                         if (muffled) 
[13:19:00.002]                           invokeRestart("muffleWarning")
[13:19:00.002]                       }
[13:19:00.002]                       else if (inherits(cond, "condition")) {
[13:19:00.002]                         if (!is.null(pattern)) {
[13:19:00.002]                           computeRestarts <- base::computeRestarts
[13:19:00.002]                           grepl <- base::grepl
[13:19:00.002]                           restarts <- computeRestarts(cond)
[13:19:00.002]                           for (restart in restarts) {
[13:19:00.002]                             name <- restart$name
[13:19:00.002]                             if (is.null(name)) 
[13:19:00.002]                               next
[13:19:00.002]                             if (!grepl(pattern, name)) 
[13:19:00.002]                               next
[13:19:00.002]                             invokeRestart(restart)
[13:19:00.002]                             muffled <- TRUE
[13:19:00.002]                             break
[13:19:00.002]                           }
[13:19:00.002]                         }
[13:19:00.002]                       }
[13:19:00.002]                       invisible(muffled)
[13:19:00.002]                     }
[13:19:00.002]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.002]                   }
[13:19:00.002]                 }
[13:19:00.002]                 else {
[13:19:00.002]                   if (TRUE) {
[13:19:00.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.002]                     {
[13:19:00.002]                       inherits <- base::inherits
[13:19:00.002]                       invokeRestart <- base::invokeRestart
[13:19:00.002]                       is.null <- base::is.null
[13:19:00.002]                       muffled <- FALSE
[13:19:00.002]                       if (inherits(cond, "message")) {
[13:19:00.002]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.002]                         if (muffled) 
[13:19:00.002]                           invokeRestart("muffleMessage")
[13:19:00.002]                       }
[13:19:00.002]                       else if (inherits(cond, "warning")) {
[13:19:00.002]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.002]                         if (muffled) 
[13:19:00.002]                           invokeRestart("muffleWarning")
[13:19:00.002]                       }
[13:19:00.002]                       else if (inherits(cond, "condition")) {
[13:19:00.002]                         if (!is.null(pattern)) {
[13:19:00.002]                           computeRestarts <- base::computeRestarts
[13:19:00.002]                           grepl <- base::grepl
[13:19:00.002]                           restarts <- computeRestarts(cond)
[13:19:00.002]                           for (restart in restarts) {
[13:19:00.002]                             name <- restart$name
[13:19:00.002]                             if (is.null(name)) 
[13:19:00.002]                               next
[13:19:00.002]                             if (!grepl(pattern, name)) 
[13:19:00.002]                               next
[13:19:00.002]                             invokeRestart(restart)
[13:19:00.002]                             muffled <- TRUE
[13:19:00.002]                             break
[13:19:00.002]                           }
[13:19:00.002]                         }
[13:19:00.002]                       }
[13:19:00.002]                       invisible(muffled)
[13:19:00.002]                     }
[13:19:00.002]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.002]                   }
[13:19:00.002]                 }
[13:19:00.002]             }
[13:19:00.002]         }))
[13:19:00.002]     }, error = function(ex) {
[13:19:00.002]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.002]                 ...future.rng), started = ...future.startTime, 
[13:19:00.002]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.002]             version = "1.8"), class = "FutureResult")
[13:19:00.002]     }, finally = {
[13:19:00.002]         if (!identical(...future.workdir, getwd())) 
[13:19:00.002]             setwd(...future.workdir)
[13:19:00.002]         {
[13:19:00.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.002]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.002]             }
[13:19:00.002]             base::options(...future.oldOptions)
[13:19:00.002]             if (.Platform$OS.type == "windows") {
[13:19:00.002]                 old_names <- names(...future.oldEnvVars)
[13:19:00.002]                 envs <- base::Sys.getenv()
[13:19:00.002]                 names <- names(envs)
[13:19:00.002]                 common <- intersect(names, old_names)
[13:19:00.002]                 added <- setdiff(names, old_names)
[13:19:00.002]                 removed <- setdiff(old_names, names)
[13:19:00.002]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.002]                   envs[common]]
[13:19:00.002]                 NAMES <- toupper(changed)
[13:19:00.002]                 args <- list()
[13:19:00.002]                 for (kk in seq_along(NAMES)) {
[13:19:00.002]                   name <- changed[[kk]]
[13:19:00.002]                   NAME <- NAMES[[kk]]
[13:19:00.002]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.002]                     next
[13:19:00.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.002]                 }
[13:19:00.002]                 NAMES <- toupper(added)
[13:19:00.002]                 for (kk in seq_along(NAMES)) {
[13:19:00.002]                   name <- added[[kk]]
[13:19:00.002]                   NAME <- NAMES[[kk]]
[13:19:00.002]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.002]                     next
[13:19:00.002]                   args[[name]] <- ""
[13:19:00.002]                 }
[13:19:00.002]                 NAMES <- toupper(removed)
[13:19:00.002]                 for (kk in seq_along(NAMES)) {
[13:19:00.002]                   name <- removed[[kk]]
[13:19:00.002]                   NAME <- NAMES[[kk]]
[13:19:00.002]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.002]                     next
[13:19:00.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.002]                 }
[13:19:00.002]                 if (length(args) > 0) 
[13:19:00.002]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.002]             }
[13:19:00.002]             else {
[13:19:00.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.002]             }
[13:19:00.002]             {
[13:19:00.002]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.002]                   0L) {
[13:19:00.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.002]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.002]                   base::options(opts)
[13:19:00.002]                 }
[13:19:00.002]                 {
[13:19:00.002]                   {
[13:19:00.002]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.002]                     NULL
[13:19:00.002]                   }
[13:19:00.002]                   options(future.plan = NULL)
[13:19:00.002]                   if (is.na(NA_character_)) 
[13:19:00.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.002]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:00.002]                     envir = parent.frame()) 
[13:19:00.002]                   {
[13:19:00.002]                     default_workers <- missing(workers)
[13:19:00.002]                     if (is.function(workers)) 
[13:19:00.002]                       workers <- workers()
[13:19:00.002]                     workers <- structure(as.integer(workers), 
[13:19:00.002]                       class = class(workers))
[13:19:00.002]                     stop_if_not(is.finite(workers), workers >= 
[13:19:00.002]                       1L)
[13:19:00.002]                     if ((workers == 1L && !inherits(workers, 
[13:19:00.002]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:00.002]                       if (default_workers) 
[13:19:00.002]                         supportsMulticore(warn = TRUE)
[13:19:00.002]                       return(sequential(..., envir = envir))
[13:19:00.002]                     }
[13:19:00.002]                     oopts <- options(mc.cores = workers)
[13:19:00.002]                     on.exit(options(oopts))
[13:19:00.002]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:00.002]                       envir = envir)
[13:19:00.002]                     if (!future$lazy) 
[13:19:00.002]                       future <- run(future)
[13:19:00.002]                     invisible(future)
[13:19:00.002]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.002]                 }
[13:19:00.002]             }
[13:19:00.002]         }
[13:19:00.002]     })
[13:19:00.002]     if (TRUE) {
[13:19:00.002]         base::sink(type = "output", split = FALSE)
[13:19:00.002]         if (TRUE) {
[13:19:00.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.002]         }
[13:19:00.002]         else {
[13:19:00.002]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.002]         }
[13:19:00.002]         base::close(...future.stdout)
[13:19:00.002]         ...future.stdout <- NULL
[13:19:00.002]     }
[13:19:00.002]     ...future.result$conditions <- ...future.conditions
[13:19:00.002]     ...future.result$finished <- base::Sys.time()
[13:19:00.002]     ...future.result
[13:19:00.002] }
[13:19:00.005] assign_globals() ...
[13:19:00.005] List of 11
[13:19:00.005]  $ ...future.FUN            :function (x, ...)  
[13:19:00.005]  $ x_FUN                    :function (x)  
[13:19:00.005]  $ times                    : int 1
[13:19:00.005]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.005]  $ stop_if_not              :function (...)  
[13:19:00.005]  $ dim                      : NULL
[13:19:00.005]  $ valid_types              : chr "logical"
[13:19:00.005]  $ future.call.arguments    : list()
[13:19:00.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.005]  $ ...future.elements_ii    :List of 6
[13:19:00.005]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[13:19:00.005]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[13:19:00.005]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[13:19:00.005]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[13:19:00.005]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[13:19:00.005]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[13:19:00.005]  $ ...future.seeds_ii       : NULL
[13:19:00.005]  $ ...future.globals.maxSize: NULL
[13:19:00.005]  - attr(*, "resolved")= logi FALSE
[13:19:00.005]  - attr(*, "total_size")= num 94200
[13:19:00.005]  - attr(*, "where")=List of 11
[13:19:00.005]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ times                    :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:00.005]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:00.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.005]  - attr(*, "already-done")= logi TRUE
[13:19:00.018] - copied ‘...future.FUN’ to environment
[13:19:00.018] - copied ‘x_FUN’ to environment
[13:19:00.018] - copied ‘times’ to environment
[13:19:00.019] - copied ‘stopf’ to environment
[13:19:00.019] - copied ‘stop_if_not’ to environment
[13:19:00.019] - copied ‘dim’ to environment
[13:19:00.019] - copied ‘valid_types’ to environment
[13:19:00.019] - copied ‘future.call.arguments’ to environment
[13:19:00.019] - copied ‘...future.elements_ii’ to environment
[13:19:00.019] - copied ‘...future.seeds_ii’ to environment
[13:19:00.019] - copied ‘...future.globals.maxSize’ to environment
[13:19:00.020] assign_globals() ... done
[13:19:00.020] requestCore(): workers = 2
[13:19:00.022] MulticoreFuture started
[13:19:00.023] - Launch lazy future ... done
[13:19:00.023] run() for ‘MulticoreFuture’ ... done
[13:19:00.024] Created future:
[13:19:00.024] plan(): Setting new future strategy stack:
[13:19:00.025] List of future strategies:
[13:19:00.025] 1. sequential:
[13:19:00.025]    - args: function (..., envir = parent.frame())
[13:19:00.025]    - tweaked: FALSE
[13:19:00.025]    - call: NULL
[13:19:00.026] plan(): nbrOfWorkers() = 1
[13:19:00.029] plan(): Setting new future strategy stack:
[13:19:00.029] List of future strategies:
[13:19:00.029] 1. multicore:
[13:19:00.029]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:00.029]    - tweaked: FALSE
[13:19:00.029]    - call: plan(strategy)
[13:19:00.036] plan(): nbrOfWorkers() = 2
[13:19:00.025] MulticoreFuture:
[13:19:00.025] Label: ‘future_vapply-1’
[13:19:00.025] Expression:
[13:19:00.025] {
[13:19:00.025]     do.call(function(...) {
[13:19:00.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.025]             on.exit(options(oopts), add = TRUE)
[13:19:00.025]         }
[13:19:00.025]         {
[13:19:00.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.025]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.025]             })
[13:19:00.025]         }
[13:19:00.025]     }, args = future.call.arguments)
[13:19:00.025] }
[13:19:00.025] Lazy evaluation: FALSE
[13:19:00.025] Asynchronous evaluation: TRUE
[13:19:00.025] Local evaluation: TRUE
[13:19:00.025] Environment: R_GlobalEnv
[13:19:00.025] Capture standard output: TRUE
[13:19:00.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:00.025] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:00.025] Packages: 1 packages (‘future.apply’)
[13:19:00.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:00.025] Resolved: TRUE
[13:19:00.025] Value: <not collected>
[13:19:00.025] Conditions captured: <none>
[13:19:00.025] Early signaling: FALSE
[13:19:00.025] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:00.025] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.038] Chunk #1 of 2 ... DONE
[13:19:00.038] Chunk #2 of 2 ...
[13:19:00.038]  - Finding globals in 'X' for chunk #2 ...
[13:19:00.038] getGlobalsAndPackages() ...
[13:19:00.039] Searching for globals...
[13:19:00.039] 
[13:19:00.039] Searching for globals ... DONE
[13:19:00.039] - globals: [0] <none>
[13:19:00.040] getGlobalsAndPackages() ... DONE
[13:19:00.040]    + additional globals found: [n=0] 
[13:19:00.040]    + additional namespaces needed: [n=0] 
[13:19:00.040]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:00.040]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:00.041]  - seeds: <none>
[13:19:00.041] getGlobalsAndPackages() ...
[13:19:00.041] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.041] Resolving globals: FALSE
[13:19:00.042] Tweak future expression to call with '...' arguments ...
[13:19:00.042] {
[13:19:00.042]     do.call(function(...) {
[13:19:00.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.042]             on.exit(options(oopts), add = TRUE)
[13:19:00.042]         }
[13:19:00.042]         {
[13:19:00.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.042]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.042]             })
[13:19:00.042]         }
[13:19:00.042]     }, args = future.call.arguments)
[13:19:00.042] }
[13:19:00.042] Tweak future expression to call with '...' arguments ... DONE
[13:19:00.043] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.043] - packages: [1] ‘future.apply’
[13:19:00.044] getGlobalsAndPackages() ... DONE
[13:19:00.044] run() for ‘Future’ ...
[13:19:00.045] - state: ‘created’
[13:19:00.045] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:00.049] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:00.050]   - Field: ‘label’
[13:19:00.050]   - Field: ‘local’
[13:19:00.050]   - Field: ‘owner’
[13:19:00.050]   - Field: ‘envir’
[13:19:00.050]   - Field: ‘workers’
[13:19:00.051]   - Field: ‘packages’
[13:19:00.051]   - Field: ‘gc’
[13:19:00.051]   - Field: ‘job’
[13:19:00.051]   - Field: ‘conditions’
[13:19:00.051]   - Field: ‘expr’
[13:19:00.051]   - Field: ‘uuid’
[13:19:00.051]   - Field: ‘seed’
[13:19:00.052]   - Field: ‘version’
[13:19:00.052]   - Field: ‘result’
[13:19:00.052]   - Field: ‘asynchronous’
[13:19:00.052]   - Field: ‘calls’
[13:19:00.052]   - Field: ‘globals’
[13:19:00.052]   - Field: ‘stdout’
[13:19:00.052]   - Field: ‘earlySignal’
[13:19:00.053]   - Field: ‘lazy’
[13:19:00.053]   - Field: ‘state’
[13:19:00.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:00.053] - Launch lazy future ...
[13:19:00.053] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:00.053] Packages needed by future strategies (n = 0): <none>
[13:19:00.054] {
[13:19:00.054]     {
[13:19:00.054]         {
[13:19:00.054]             ...future.startTime <- base::Sys.time()
[13:19:00.054]             {
[13:19:00.054]                 {
[13:19:00.054]                   {
[13:19:00.054]                     {
[13:19:00.054]                       {
[13:19:00.054]                         base::local({
[13:19:00.054]                           has_future <- base::requireNamespace("future", 
[13:19:00.054]                             quietly = TRUE)
[13:19:00.054]                           if (has_future) {
[13:19:00.054]                             ns <- base::getNamespace("future")
[13:19:00.054]                             version <- ns[[".package"]][["version"]]
[13:19:00.054]                             if (is.null(version)) 
[13:19:00.054]                               version <- utils::packageVersion("future")
[13:19:00.054]                           }
[13:19:00.054]                           else {
[13:19:00.054]                             version <- NULL
[13:19:00.054]                           }
[13:19:00.054]                           if (!has_future || version < "1.8.0") {
[13:19:00.054]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.054]                               "", base::R.version$version.string), 
[13:19:00.054]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:00.054]                                 base::R.version$platform, 8 * 
[13:19:00.054]                                   base::.Machine$sizeof.pointer), 
[13:19:00.054]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.054]                                 "release", "version")], collapse = " "), 
[13:19:00.054]                               hostname = base::Sys.info()[["nodename"]])
[13:19:00.054]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.054]                               info)
[13:19:00.054]                             info <- base::paste(info, collapse = "; ")
[13:19:00.054]                             if (!has_future) {
[13:19:00.054]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.054]                                 info)
[13:19:00.054]                             }
[13:19:00.054]                             else {
[13:19:00.054]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.054]                                 info, version)
[13:19:00.054]                             }
[13:19:00.054]                             base::stop(msg)
[13:19:00.054]                           }
[13:19:00.054]                         })
[13:19:00.054]                       }
[13:19:00.054]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.054]                       base::options(mc.cores = 1L)
[13:19:00.054]                     }
[13:19:00.054]                     base::local({
[13:19:00.054]                       for (pkg in "future.apply") {
[13:19:00.054]                         base::loadNamespace(pkg)
[13:19:00.054]                         base::library(pkg, character.only = TRUE)
[13:19:00.054]                       }
[13:19:00.054]                     })
[13:19:00.054]                   }
[13:19:00.054]                   options(future.plan = NULL)
[13:19:00.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.054]                 }
[13:19:00.054]                 ...future.workdir <- getwd()
[13:19:00.054]             }
[13:19:00.054]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.054]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.054]         }
[13:19:00.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.054]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:00.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.054]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.054]             base::names(...future.oldOptions))
[13:19:00.054]     }
[13:19:00.054]     if (FALSE) {
[13:19:00.054]     }
[13:19:00.054]     else {
[13:19:00.054]         if (TRUE) {
[13:19:00.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.054]                 open = "w")
[13:19:00.054]         }
[13:19:00.054]         else {
[13:19:00.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.054]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.054]         }
[13:19:00.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.054]             base::sink(type = "output", split = FALSE)
[13:19:00.054]             base::close(...future.stdout)
[13:19:00.054]         }, add = TRUE)
[13:19:00.054]     }
[13:19:00.054]     ...future.frame <- base::sys.nframe()
[13:19:00.054]     ...future.conditions <- base::list()
[13:19:00.054]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.054]     if (FALSE) {
[13:19:00.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.054]     }
[13:19:00.054]     ...future.result <- base::tryCatch({
[13:19:00.054]         base::withCallingHandlers({
[13:19:00.054]             ...future.value <- base::withVisible(base::local({
[13:19:00.054]                 withCallingHandlers({
[13:19:00.054]                   {
[13:19:00.054]                     do.call(function(...) {
[13:19:00.054]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.054]                       if (!identical(...future.globals.maxSize.org, 
[13:19:00.054]                         ...future.globals.maxSize)) {
[13:19:00.054]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.054]                         on.exit(options(oopts), add = TRUE)
[13:19:00.054]                       }
[13:19:00.054]                       {
[13:19:00.054]                         lapply(seq_along(...future.elements_ii), 
[13:19:00.054]                           FUN = function(jj) {
[13:19:00.054]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.054]                             ...future.FUN(...future.X_jj, ...)
[13:19:00.054]                           })
[13:19:00.054]                       }
[13:19:00.054]                     }, args = future.call.arguments)
[13:19:00.054]                   }
[13:19:00.054]                 }, immediateCondition = function(cond) {
[13:19:00.054]                   save_rds <- function (object, pathname, ...) 
[13:19:00.054]                   {
[13:19:00.054]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:00.054]                     if (file_test("-f", pathname_tmp)) {
[13:19:00.054]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.054]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:00.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.054]                         fi_tmp[["mtime"]])
[13:19:00.054]                     }
[13:19:00.054]                     tryCatch({
[13:19:00.054]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:00.054]                     }, error = function(ex) {
[13:19:00.054]                       msg <- conditionMessage(ex)
[13:19:00.054]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.054]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:00.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.054]                         fi_tmp[["mtime"]], msg)
[13:19:00.054]                       ex$message <- msg
[13:19:00.054]                       stop(ex)
[13:19:00.054]                     })
[13:19:00.054]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:00.054]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:00.054]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:00.054]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.054]                       fi <- file.info(pathname)
[13:19:00.054]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:00.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.054]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:00.054]                         fi[["size"]], fi[["mtime"]])
[13:19:00.054]                       stop(msg)
[13:19:00.054]                     }
[13:19:00.054]                     invisible(pathname)
[13:19:00.054]                   }
[13:19:00.054]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:00.054]                     rootPath = tempdir()) 
[13:19:00.054]                   {
[13:19:00.054]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:00.054]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:00.054]                       tmpdir = path, fileext = ".rds")
[13:19:00.054]                     save_rds(obj, file)
[13:19:00.054]                   }
[13:19:00.054]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:19:00.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.054]                   {
[13:19:00.054]                     inherits <- base::inherits
[13:19:00.054]                     invokeRestart <- base::invokeRestart
[13:19:00.054]                     is.null <- base::is.null
[13:19:00.054]                     muffled <- FALSE
[13:19:00.054]                     if (inherits(cond, "message")) {
[13:19:00.054]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.054]                       if (muffled) 
[13:19:00.054]                         invokeRestart("muffleMessage")
[13:19:00.054]                     }
[13:19:00.054]                     else if (inherits(cond, "warning")) {
[13:19:00.054]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.054]                       if (muffled) 
[13:19:00.054]                         invokeRestart("muffleWarning")
[13:19:00.054]                     }
[13:19:00.054]                     else if (inherits(cond, "condition")) {
[13:19:00.054]                       if (!is.null(pattern)) {
[13:19:00.054]                         computeRestarts <- base::computeRestarts
[13:19:00.054]                         grepl <- base::grepl
[13:19:00.054]                         restarts <- computeRestarts(cond)
[13:19:00.054]                         for (restart in restarts) {
[13:19:00.054]                           name <- restart$name
[13:19:00.054]                           if (is.null(name)) 
[13:19:00.054]                             next
[13:19:00.054]                           if (!grepl(pattern, name)) 
[13:19:00.054]                             next
[13:19:00.054]                           invokeRestart(restart)
[13:19:00.054]                           muffled <- TRUE
[13:19:00.054]                           break
[13:19:00.054]                         }
[13:19:00.054]                       }
[13:19:00.054]                     }
[13:19:00.054]                     invisible(muffled)
[13:19:00.054]                   }
[13:19:00.054]                   muffleCondition(cond)
[13:19:00.054]                 })
[13:19:00.054]             }))
[13:19:00.054]             future::FutureResult(value = ...future.value$value, 
[13:19:00.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.054]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.054]                     ...future.globalenv.names))
[13:19:00.054]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.054]         }, condition = base::local({
[13:19:00.054]             c <- base::c
[13:19:00.054]             inherits <- base::inherits
[13:19:00.054]             invokeRestart <- base::invokeRestart
[13:19:00.054]             length <- base::length
[13:19:00.054]             list <- base::list
[13:19:00.054]             seq.int <- base::seq.int
[13:19:00.054]             signalCondition <- base::signalCondition
[13:19:00.054]             sys.calls <- base::sys.calls
[13:19:00.054]             `[[` <- base::`[[`
[13:19:00.054]             `+` <- base::`+`
[13:19:00.054]             `<<-` <- base::`<<-`
[13:19:00.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.054]                   3L)]
[13:19:00.054]             }
[13:19:00.054]             function(cond) {
[13:19:00.054]                 is_error <- inherits(cond, "error")
[13:19:00.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.054]                   NULL)
[13:19:00.054]                 if (is_error) {
[13:19:00.054]                   sessionInformation <- function() {
[13:19:00.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.054]                       search = base::search(), system = base::Sys.info())
[13:19:00.054]                   }
[13:19:00.054]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.054]                     cond$call), session = sessionInformation(), 
[13:19:00.054]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.054]                   signalCondition(cond)
[13:19:00.054]                 }
[13:19:00.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.054]                 "immediateCondition"))) {
[13:19:00.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.054]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.054]                   if (TRUE && !signal) {
[13:19:00.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.054]                     {
[13:19:00.054]                       inherits <- base::inherits
[13:19:00.054]                       invokeRestart <- base::invokeRestart
[13:19:00.054]                       is.null <- base::is.null
[13:19:00.054]                       muffled <- FALSE
[13:19:00.054]                       if (inherits(cond, "message")) {
[13:19:00.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.054]                         if (muffled) 
[13:19:00.054]                           invokeRestart("muffleMessage")
[13:19:00.054]                       }
[13:19:00.054]                       else if (inherits(cond, "warning")) {
[13:19:00.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.054]                         if (muffled) 
[13:19:00.054]                           invokeRestart("muffleWarning")
[13:19:00.054]                       }
[13:19:00.054]                       else if (inherits(cond, "condition")) {
[13:19:00.054]                         if (!is.null(pattern)) {
[13:19:00.054]                           computeRestarts <- base::computeRestarts
[13:19:00.054]                           grepl <- base::grepl
[13:19:00.054]                           restarts <- computeRestarts(cond)
[13:19:00.054]                           for (restart in restarts) {
[13:19:00.054]                             name <- restart$name
[13:19:00.054]                             if (is.null(name)) 
[13:19:00.054]                               next
[13:19:00.054]                             if (!grepl(pattern, name)) 
[13:19:00.054]                               next
[13:19:00.054]                             invokeRestart(restart)
[13:19:00.054]                             muffled <- TRUE
[13:19:00.054]                             break
[13:19:00.054]                           }
[13:19:00.054]                         }
[13:19:00.054]                       }
[13:19:00.054]                       invisible(muffled)
[13:19:00.054]                     }
[13:19:00.054]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.054]                   }
[13:19:00.054]                 }
[13:19:00.054]                 else {
[13:19:00.054]                   if (TRUE) {
[13:19:00.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.054]                     {
[13:19:00.054]                       inherits <- base::inherits
[13:19:00.054]                       invokeRestart <- base::invokeRestart
[13:19:00.054]                       is.null <- base::is.null
[13:19:00.054]                       muffled <- FALSE
[13:19:00.054]                       if (inherits(cond, "message")) {
[13:19:00.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.054]                         if (muffled) 
[13:19:00.054]                           invokeRestart("muffleMessage")
[13:19:00.054]                       }
[13:19:00.054]                       else if (inherits(cond, "warning")) {
[13:19:00.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.054]                         if (muffled) 
[13:19:00.054]                           invokeRestart("muffleWarning")
[13:19:00.054]                       }
[13:19:00.054]                       else if (inherits(cond, "condition")) {
[13:19:00.054]                         if (!is.null(pattern)) {
[13:19:00.054]                           computeRestarts <- base::computeRestarts
[13:19:00.054]                           grepl <- base::grepl
[13:19:00.054]                           restarts <- computeRestarts(cond)
[13:19:00.054]                           for (restart in restarts) {
[13:19:00.054]                             name <- restart$name
[13:19:00.054]                             if (is.null(name)) 
[13:19:00.054]                               next
[13:19:00.054]                             if (!grepl(pattern, name)) 
[13:19:00.054]                               next
[13:19:00.054]                             invokeRestart(restart)
[13:19:00.054]                             muffled <- TRUE
[13:19:00.054]                             break
[13:19:00.054]                           }
[13:19:00.054]                         }
[13:19:00.054]                       }
[13:19:00.054]                       invisible(muffled)
[13:19:00.054]                     }
[13:19:00.054]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.054]                   }
[13:19:00.054]                 }
[13:19:00.054]             }
[13:19:00.054]         }))
[13:19:00.054]     }, error = function(ex) {
[13:19:00.054]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.054]                 ...future.rng), started = ...future.startTime, 
[13:19:00.054]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.054]             version = "1.8"), class = "FutureResult")
[13:19:00.054]     }, finally = {
[13:19:00.054]         if (!identical(...future.workdir, getwd())) 
[13:19:00.054]             setwd(...future.workdir)
[13:19:00.054]         {
[13:19:00.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.054]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.054]             }
[13:19:00.054]             base::options(...future.oldOptions)
[13:19:00.054]             if (.Platform$OS.type == "windows") {
[13:19:00.054]                 old_names <- names(...future.oldEnvVars)
[13:19:00.054]                 envs <- base::Sys.getenv()
[13:19:00.054]                 names <- names(envs)
[13:19:00.054]                 common <- intersect(names, old_names)
[13:19:00.054]                 added <- setdiff(names, old_names)
[13:19:00.054]                 removed <- setdiff(old_names, names)
[13:19:00.054]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.054]                   envs[common]]
[13:19:00.054]                 NAMES <- toupper(changed)
[13:19:00.054]                 args <- list()
[13:19:00.054]                 for (kk in seq_along(NAMES)) {
[13:19:00.054]                   name <- changed[[kk]]
[13:19:00.054]                   NAME <- NAMES[[kk]]
[13:19:00.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.054]                     next
[13:19:00.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.054]                 }
[13:19:00.054]                 NAMES <- toupper(added)
[13:19:00.054]                 for (kk in seq_along(NAMES)) {
[13:19:00.054]                   name <- added[[kk]]
[13:19:00.054]                   NAME <- NAMES[[kk]]
[13:19:00.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.054]                     next
[13:19:00.054]                   args[[name]] <- ""
[13:19:00.054]                 }
[13:19:00.054]                 NAMES <- toupper(removed)
[13:19:00.054]                 for (kk in seq_along(NAMES)) {
[13:19:00.054]                   name <- removed[[kk]]
[13:19:00.054]                   NAME <- NAMES[[kk]]
[13:19:00.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.054]                     next
[13:19:00.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.054]                 }
[13:19:00.054]                 if (length(args) > 0) 
[13:19:00.054]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.054]             }
[13:19:00.054]             else {
[13:19:00.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.054]             }
[13:19:00.054]             {
[13:19:00.054]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.054]                   0L) {
[13:19:00.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.054]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.054]                   base::options(opts)
[13:19:00.054]                 }
[13:19:00.054]                 {
[13:19:00.054]                   {
[13:19:00.054]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.054]                     NULL
[13:19:00.054]                   }
[13:19:00.054]                   options(future.plan = NULL)
[13:19:00.054]                   if (is.na(NA_character_)) 
[13:19:00.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.054]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:00.054]                     envir = parent.frame()) 
[13:19:00.054]                   {
[13:19:00.054]                     default_workers <- missing(workers)
[13:19:00.054]                     if (is.function(workers)) 
[13:19:00.054]                       workers <- workers()
[13:19:00.054]                     workers <- structure(as.integer(workers), 
[13:19:00.054]                       class = class(workers))
[13:19:00.054]                     stop_if_not(is.finite(workers), workers >= 
[13:19:00.054]                       1L)
[13:19:00.054]                     if ((workers == 1L && !inherits(workers, 
[13:19:00.054]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:00.054]                       if (default_workers) 
[13:19:00.054]                         supportsMulticore(warn = TRUE)
[13:19:00.054]                       return(sequential(..., envir = envir))
[13:19:00.054]                     }
[13:19:00.054]                     oopts <- options(mc.cores = workers)
[13:19:00.054]                     on.exit(options(oopts))
[13:19:00.054]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:00.054]                       envir = envir)
[13:19:00.054]                     if (!future$lazy) 
[13:19:00.054]                       future <- run(future)
[13:19:00.054]                     invisible(future)
[13:19:00.054]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.054]                 }
[13:19:00.054]             }
[13:19:00.054]         }
[13:19:00.054]     })
[13:19:00.054]     if (TRUE) {
[13:19:00.054]         base::sink(type = "output", split = FALSE)
[13:19:00.054]         if (TRUE) {
[13:19:00.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.054]         }
[13:19:00.054]         else {
[13:19:00.054]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.054]         }
[13:19:00.054]         base::close(...future.stdout)
[13:19:00.054]         ...future.stdout <- NULL
[13:19:00.054]     }
[13:19:00.054]     ...future.result$conditions <- ...future.conditions
[13:19:00.054]     ...future.result$finished <- base::Sys.time()
[13:19:00.054]     ...future.result
[13:19:00.054] }
[13:19:00.058] assign_globals() ...
[13:19:00.058] List of 11
[13:19:00.058]  $ ...future.FUN            :function (x, ...)  
[13:19:00.058]  $ x_FUN                    :function (x)  
[13:19:00.058]  $ times                    : int 1
[13:19:00.058]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.058]  $ stop_if_not              :function (...)  
[13:19:00.058]  $ dim                      : NULL
[13:19:00.058]  $ valid_types              : chr "logical"
[13:19:00.058]  $ future.call.arguments    : list()
[13:19:00.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.058]  $ ...future.elements_ii    :List of 5
[13:19:00.058]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[13:19:00.058]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[13:19:00.058]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[13:19:00.058]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[13:19:00.058]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[13:19:00.058]  $ ...future.seeds_ii       : NULL
[13:19:00.058]  $ ...future.globals.maxSize: NULL
[13:19:00.058]  - attr(*, "resolved")= logi FALSE
[13:19:00.058]  - attr(*, "total_size")= num 94200
[13:19:00.058]  - attr(*, "where")=List of 11
[13:19:00.058]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ times                    :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:00.058]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:00.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.058]  - attr(*, "already-done")= logi TRUE
[13:19:00.072] - copied ‘...future.FUN’ to environment
[13:19:00.072] - copied ‘x_FUN’ to environment
[13:19:00.073] - copied ‘times’ to environment
[13:19:00.073] - copied ‘stopf’ to environment
[13:19:00.073] - copied ‘stop_if_not’ to environment
[13:19:00.073] - copied ‘dim’ to environment
[13:19:00.073] - copied ‘valid_types’ to environment
[13:19:00.073] - copied ‘future.call.arguments’ to environment
[13:19:00.073] - copied ‘...future.elements_ii’ to environment
[13:19:00.073] - copied ‘...future.seeds_ii’ to environment
[13:19:00.074] - copied ‘...future.globals.maxSize’ to environment
[13:19:00.074] assign_globals() ... done
[13:19:00.074] requestCore(): workers = 2
[13:19:00.076] MulticoreFuture started
[13:19:00.077] - Launch lazy future ... done
[13:19:00.077] run() for ‘MulticoreFuture’ ... done
[13:19:00.077] Created future:
[13:19:00.078] plan(): Setting new future strategy stack:
[13:19:00.078] List of future strategies:
[13:19:00.078] 1. sequential:
[13:19:00.078]    - args: function (..., envir = parent.frame())
[13:19:00.078]    - tweaked: FALSE
[13:19:00.078]    - call: NULL
[13:19:00.079] plan(): nbrOfWorkers() = 1
[13:19:00.081] plan(): Setting new future strategy stack:
[13:19:00.081] List of future strategies:
[13:19:00.081] 1. multicore:
[13:19:00.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:00.081]    - tweaked: FALSE
[13:19:00.081]    - call: plan(strategy)
[13:19:00.088] plan(): nbrOfWorkers() = 2
[13:19:00.078] MulticoreFuture:
[13:19:00.078] Label: ‘future_vapply-2’
[13:19:00.078] Expression:
[13:19:00.078] {
[13:19:00.078]     do.call(function(...) {
[13:19:00.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.078]             on.exit(options(oopts), add = TRUE)
[13:19:00.078]         }
[13:19:00.078]         {
[13:19:00.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.078]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.078]             })
[13:19:00.078]         }
[13:19:00.078]     }, args = future.call.arguments)
[13:19:00.078] }
[13:19:00.078] Lazy evaluation: FALSE
[13:19:00.078] Asynchronous evaluation: TRUE
[13:19:00.078] Local evaluation: TRUE
[13:19:00.078] Environment: R_GlobalEnv
[13:19:00.078] Capture standard output: TRUE
[13:19:00.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:00.078] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:00.078] Packages: 1 packages (‘future.apply’)
[13:19:00.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:00.078] Resolved: TRUE
[13:19:00.078] Value: <not collected>
[13:19:00.078] Conditions captured: <none>
[13:19:00.078] Early signaling: FALSE
[13:19:00.078] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:00.078] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.089] Chunk #2 of 2 ... DONE
[13:19:00.089] Launching 2 futures (chunks) ... DONE
[13:19:00.090] Resolving 2 futures (chunks) ...
[13:19:00.090] resolve() on list ...
[13:19:00.090]  recursive: 0
[13:19:00.090]  length: 2
[13:19:00.090] 
[13:19:00.091] Future #1
[13:19:00.092] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:00.092] - nx: 2
[13:19:00.092] - relay: TRUE
[13:19:00.092] - stdout: TRUE
[13:19:00.092] - signal: TRUE
[13:19:00.092] - resignal: FALSE
[13:19:00.093] - force: TRUE
[13:19:00.093] - relayed: [n=2] FALSE, FALSE
[13:19:00.093] - queued futures: [n=2] FALSE, FALSE
[13:19:00.093]  - until=1
[13:19:00.093]  - relaying element #1
[13:19:00.094] - relayed: [n=2] TRUE, FALSE
[13:19:00.094] - queued futures: [n=2] TRUE, FALSE
[13:19:00.094] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:00.094]  length: 1 (resolved future 1)
[13:19:00.095] Future #2
[13:19:00.095] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:00.096] - nx: 2
[13:19:00.096] - relay: TRUE
[13:19:00.096] - stdout: TRUE
[13:19:00.096] - signal: TRUE
[13:19:00.096] - resignal: FALSE
[13:19:00.096] - force: TRUE
[13:19:00.096] - relayed: [n=2] TRUE, FALSE
[13:19:00.096] - queued futures: [n=2] TRUE, FALSE
[13:19:00.097]  - until=2
[13:19:00.097]  - relaying element #2
[13:19:00.097] - relayed: [n=2] TRUE, TRUE
[13:19:00.097] - queued futures: [n=2] TRUE, TRUE
[13:19:00.097] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:00.097]  length: 0 (resolved future 2)
[13:19:00.097] Relaying remaining futures
[13:19:00.098] signalConditionsASAP(NULL, pos=0) ...
[13:19:00.098] - nx: 2
[13:19:00.098] - relay: TRUE
[13:19:00.098] - stdout: TRUE
[13:19:00.098] - signal: TRUE
[13:19:00.098] - resignal: FALSE
[13:19:00.098] - force: TRUE
[13:19:00.098] - relayed: [n=2] TRUE, TRUE
[13:19:00.098] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:00.099] - relayed: [n=2] TRUE, TRUE
[13:19:00.099] - queued futures: [n=2] TRUE, TRUE
[13:19:00.099] signalConditionsASAP(NULL, pos=0) ... done
[13:19:00.099] resolve() on list ... DONE
[13:19:00.099]  - Number of value chunks collected: 2
[13:19:00.099] Resolving 2 futures (chunks) ... DONE
[13:19:00.100] Reducing values from 2 chunks ...
[13:19:00.100]  - Number of values collected after concatenation: 11
[13:19:00.100]  - Number of values expected: 11
[13:19:00.100] Reducing values from 2 chunks ... DONE
[13:19:00.100] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:19:00.101] future_lapply() ...
[13:19:00.111] Number of chunks: 2
[13:19:00.111] getGlobalsAndPackagesXApply() ...
[13:19:00.111]  - future.globals: TRUE
[13:19:00.111] getGlobalsAndPackages() ...
[13:19:00.112] Searching for globals...
[13:19:00.116] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:00.116] Searching for globals ... DONE
[13:19:00.116] Resolving globals: FALSE
[13:19:00.117] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:19:00.118] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:00.118] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:00.118] - packages: [1] ‘future.apply’
[13:19:00.118] getGlobalsAndPackages() ... DONE
[13:19:00.118]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:00.118]  - needed namespaces: [n=1] ‘future.apply’
[13:19:00.119] Finding globals ... DONE
[13:19:00.119]  - use_args: TRUE
[13:19:00.119]  - Getting '...' globals ...
[13:19:00.119] resolve() on list ...
[13:19:00.119]  recursive: 0
[13:19:00.119]  length: 1
[13:19:00.119]  elements: ‘...’
[13:19:00.119]  length: 0 (resolved future 1)
[13:19:00.120] resolve() on list ... DONE
[13:19:00.120]    - '...' content: [n=0] 
[13:19:00.120] List of 1
[13:19:00.120]  $ ...: list()
[13:19:00.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.120]  - attr(*, "where")=List of 1
[13:19:00.120]   ..$ ...:<environment: 0x555f7b4d4ac0> 
[13:19:00.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.120]  - attr(*, "resolved")= logi TRUE
[13:19:00.120]  - attr(*, "total_size")= num NA
[13:19:00.122]  - Getting '...' globals ... DONE
[13:19:00.123] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:00.123] List of 8
[13:19:00.123]  $ ...future.FUN:function (x, ...)  
[13:19:00.123]  $ x_FUN        :function (x)  
[13:19:00.123]  $ times        : int 1
[13:19:00.123]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.123]  $ stop_if_not  :function (...)  
[13:19:00.123]  $ dim          : NULL
[13:19:00.123]  $ valid_types  : chr [1:2] "logical" "integer"
[13:19:00.123]  $ ...          : list()
[13:19:00.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.123]  - attr(*, "where")=List of 8
[13:19:00.123]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:00.123]   ..$ ...          :<environment: 0x555f7b4d4ac0> 
[13:19:00.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.123]  - attr(*, "resolved")= logi FALSE
[13:19:00.123]  - attr(*, "total_size")= num 94264
[13:19:00.131] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:00.131] getGlobalsAndPackagesXApply() ... DONE
[13:19:00.131] Number of futures (= number of chunks): 2
[13:19:00.131] Launching 2 futures (chunks) ...
[13:19:00.131] Chunk #1 of 2 ...
[13:19:00.131]  - Finding globals in 'X' for chunk #1 ...
[13:19:00.132] getGlobalsAndPackages() ...
[13:19:00.132] Searching for globals...
[13:19:00.132] 
[13:19:00.132] Searching for globals ... DONE
[13:19:00.132] - globals: [0] <none>
[13:19:00.132] getGlobalsAndPackages() ... DONE
[13:19:00.132]    + additional globals found: [n=0] 
[13:19:00.132]    + additional namespaces needed: [n=0] 
[13:19:00.133]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:00.133]  - seeds: <none>
[13:19:00.133] getGlobalsAndPackages() ...
[13:19:00.133] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.133] Resolving globals: FALSE
[13:19:00.133] Tweak future expression to call with '...' arguments ...
[13:19:00.133] {
[13:19:00.133]     do.call(function(...) {
[13:19:00.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.133]             on.exit(options(oopts), add = TRUE)
[13:19:00.133]         }
[13:19:00.133]         {
[13:19:00.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.133]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.133]             })
[13:19:00.133]         }
[13:19:00.133]     }, args = future.call.arguments)
[13:19:00.133] }
[13:19:00.134] Tweak future expression to call with '...' arguments ... DONE
[13:19:00.134] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.134] - packages: [1] ‘future.apply’
[13:19:00.135] getGlobalsAndPackages() ... DONE
[13:19:00.135] run() for ‘Future’ ...
[13:19:00.135] - state: ‘created’
[13:19:00.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:00.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:00.140]   - Field: ‘label’
[13:19:00.140]   - Field: ‘local’
[13:19:00.140]   - Field: ‘owner’
[13:19:00.140]   - Field: ‘envir’
[13:19:00.140]   - Field: ‘workers’
[13:19:00.140]   - Field: ‘packages’
[13:19:00.140]   - Field: ‘gc’
[13:19:00.140]   - Field: ‘job’
[13:19:00.140]   - Field: ‘conditions’
[13:19:00.141]   - Field: ‘expr’
[13:19:00.141]   - Field: ‘uuid’
[13:19:00.141]   - Field: ‘seed’
[13:19:00.141]   - Field: ‘version’
[13:19:00.141]   - Field: ‘result’
[13:19:00.141]   - Field: ‘asynchronous’
[13:19:00.141]   - Field: ‘calls’
[13:19:00.141]   - Field: ‘globals’
[13:19:00.141]   - Field: ‘stdout’
[13:19:00.141]   - Field: ‘earlySignal’
[13:19:00.142]   - Field: ‘lazy’
[13:19:00.142]   - Field: ‘state’
[13:19:00.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:00.142] - Launch lazy future ...
[13:19:00.142] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:00.142] Packages needed by future strategies (n = 0): <none>
[13:19:00.143] {
[13:19:00.143]     {
[13:19:00.143]         {
[13:19:00.143]             ...future.startTime <- base::Sys.time()
[13:19:00.143]             {
[13:19:00.143]                 {
[13:19:00.143]                   {
[13:19:00.143]                     {
[13:19:00.143]                       {
[13:19:00.143]                         base::local({
[13:19:00.143]                           has_future <- base::requireNamespace("future", 
[13:19:00.143]                             quietly = TRUE)
[13:19:00.143]                           if (has_future) {
[13:19:00.143]                             ns <- base::getNamespace("future")
[13:19:00.143]                             version <- ns[[".package"]][["version"]]
[13:19:00.143]                             if (is.null(version)) 
[13:19:00.143]                               version <- utils::packageVersion("future")
[13:19:00.143]                           }
[13:19:00.143]                           else {
[13:19:00.143]                             version <- NULL
[13:19:00.143]                           }
[13:19:00.143]                           if (!has_future || version < "1.8.0") {
[13:19:00.143]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.143]                               "", base::R.version$version.string), 
[13:19:00.143]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:00.143]                                 base::R.version$platform, 8 * 
[13:19:00.143]                                   base::.Machine$sizeof.pointer), 
[13:19:00.143]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.143]                                 "release", "version")], collapse = " "), 
[13:19:00.143]                               hostname = base::Sys.info()[["nodename"]])
[13:19:00.143]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.143]                               info)
[13:19:00.143]                             info <- base::paste(info, collapse = "; ")
[13:19:00.143]                             if (!has_future) {
[13:19:00.143]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.143]                                 info)
[13:19:00.143]                             }
[13:19:00.143]                             else {
[13:19:00.143]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.143]                                 info, version)
[13:19:00.143]                             }
[13:19:00.143]                             base::stop(msg)
[13:19:00.143]                           }
[13:19:00.143]                         })
[13:19:00.143]                       }
[13:19:00.143]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.143]                       base::options(mc.cores = 1L)
[13:19:00.143]                     }
[13:19:00.143]                     base::local({
[13:19:00.143]                       for (pkg in "future.apply") {
[13:19:00.143]                         base::loadNamespace(pkg)
[13:19:00.143]                         base::library(pkg, character.only = TRUE)
[13:19:00.143]                       }
[13:19:00.143]                     })
[13:19:00.143]                   }
[13:19:00.143]                   options(future.plan = NULL)
[13:19:00.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.143]                 }
[13:19:00.143]                 ...future.workdir <- getwd()
[13:19:00.143]             }
[13:19:00.143]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.143]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.143]         }
[13:19:00.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.143]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:00.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.143]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.143]             base::names(...future.oldOptions))
[13:19:00.143]     }
[13:19:00.143]     if (FALSE) {
[13:19:00.143]     }
[13:19:00.143]     else {
[13:19:00.143]         if (TRUE) {
[13:19:00.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.143]                 open = "w")
[13:19:00.143]         }
[13:19:00.143]         else {
[13:19:00.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.143]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.143]         }
[13:19:00.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.143]             base::sink(type = "output", split = FALSE)
[13:19:00.143]             base::close(...future.stdout)
[13:19:00.143]         }, add = TRUE)
[13:19:00.143]     }
[13:19:00.143]     ...future.frame <- base::sys.nframe()
[13:19:00.143]     ...future.conditions <- base::list()
[13:19:00.143]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.143]     if (FALSE) {
[13:19:00.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.143]     }
[13:19:00.143]     ...future.result <- base::tryCatch({
[13:19:00.143]         base::withCallingHandlers({
[13:19:00.143]             ...future.value <- base::withVisible(base::local({
[13:19:00.143]                 withCallingHandlers({
[13:19:00.143]                   {
[13:19:00.143]                     do.call(function(...) {
[13:19:00.143]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.143]                       if (!identical(...future.globals.maxSize.org, 
[13:19:00.143]                         ...future.globals.maxSize)) {
[13:19:00.143]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.143]                         on.exit(options(oopts), add = TRUE)
[13:19:00.143]                       }
[13:19:00.143]                       {
[13:19:00.143]                         lapply(seq_along(...future.elements_ii), 
[13:19:00.143]                           FUN = function(jj) {
[13:19:00.143]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.143]                             ...future.FUN(...future.X_jj, ...)
[13:19:00.143]                           })
[13:19:00.143]                       }
[13:19:00.143]                     }, args = future.call.arguments)
[13:19:00.143]                   }
[13:19:00.143]                 }, immediateCondition = function(cond) {
[13:19:00.143]                   save_rds <- function (object, pathname, ...) 
[13:19:00.143]                   {
[13:19:00.143]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:00.143]                     if (file_test("-f", pathname_tmp)) {
[13:19:00.143]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.143]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:00.143]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.143]                         fi_tmp[["mtime"]])
[13:19:00.143]                     }
[13:19:00.143]                     tryCatch({
[13:19:00.143]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:00.143]                     }, error = function(ex) {
[13:19:00.143]                       msg <- conditionMessage(ex)
[13:19:00.143]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.143]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:00.143]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.143]                         fi_tmp[["mtime"]], msg)
[13:19:00.143]                       ex$message <- msg
[13:19:00.143]                       stop(ex)
[13:19:00.143]                     })
[13:19:00.143]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:00.143]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:00.143]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:00.143]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.143]                       fi <- file.info(pathname)
[13:19:00.143]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:00.143]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.143]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:00.143]                         fi[["size"]], fi[["mtime"]])
[13:19:00.143]                       stop(msg)
[13:19:00.143]                     }
[13:19:00.143]                     invisible(pathname)
[13:19:00.143]                   }
[13:19:00.143]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:00.143]                     rootPath = tempdir()) 
[13:19:00.143]                   {
[13:19:00.143]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:00.143]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:00.143]                       tmpdir = path, fileext = ".rds")
[13:19:00.143]                     save_rds(obj, file)
[13:19:00.143]                   }
[13:19:00.143]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:19:00.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.143]                   {
[13:19:00.143]                     inherits <- base::inherits
[13:19:00.143]                     invokeRestart <- base::invokeRestart
[13:19:00.143]                     is.null <- base::is.null
[13:19:00.143]                     muffled <- FALSE
[13:19:00.143]                     if (inherits(cond, "message")) {
[13:19:00.143]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.143]                       if (muffled) 
[13:19:00.143]                         invokeRestart("muffleMessage")
[13:19:00.143]                     }
[13:19:00.143]                     else if (inherits(cond, "warning")) {
[13:19:00.143]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.143]                       if (muffled) 
[13:19:00.143]                         invokeRestart("muffleWarning")
[13:19:00.143]                     }
[13:19:00.143]                     else if (inherits(cond, "condition")) {
[13:19:00.143]                       if (!is.null(pattern)) {
[13:19:00.143]                         computeRestarts <- base::computeRestarts
[13:19:00.143]                         grepl <- base::grepl
[13:19:00.143]                         restarts <- computeRestarts(cond)
[13:19:00.143]                         for (restart in restarts) {
[13:19:00.143]                           name <- restart$name
[13:19:00.143]                           if (is.null(name)) 
[13:19:00.143]                             next
[13:19:00.143]                           if (!grepl(pattern, name)) 
[13:19:00.143]                             next
[13:19:00.143]                           invokeRestart(restart)
[13:19:00.143]                           muffled <- TRUE
[13:19:00.143]                           break
[13:19:00.143]                         }
[13:19:00.143]                       }
[13:19:00.143]                     }
[13:19:00.143]                     invisible(muffled)
[13:19:00.143]                   }
[13:19:00.143]                   muffleCondition(cond)
[13:19:00.143]                 })
[13:19:00.143]             }))
[13:19:00.143]             future::FutureResult(value = ...future.value$value, 
[13:19:00.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.143]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.143]                     ...future.globalenv.names))
[13:19:00.143]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.143]         }, condition = base::local({
[13:19:00.143]             c <- base::c
[13:19:00.143]             inherits <- base::inherits
[13:19:00.143]             invokeRestart <- base::invokeRestart
[13:19:00.143]             length <- base::length
[13:19:00.143]             list <- base::list
[13:19:00.143]             seq.int <- base::seq.int
[13:19:00.143]             signalCondition <- base::signalCondition
[13:19:00.143]             sys.calls <- base::sys.calls
[13:19:00.143]             `[[` <- base::`[[`
[13:19:00.143]             `+` <- base::`+`
[13:19:00.143]             `<<-` <- base::`<<-`
[13:19:00.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.143]                   3L)]
[13:19:00.143]             }
[13:19:00.143]             function(cond) {
[13:19:00.143]                 is_error <- inherits(cond, "error")
[13:19:00.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.143]                   NULL)
[13:19:00.143]                 if (is_error) {
[13:19:00.143]                   sessionInformation <- function() {
[13:19:00.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.143]                       search = base::search(), system = base::Sys.info())
[13:19:00.143]                   }
[13:19:00.143]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.143]                     cond$call), session = sessionInformation(), 
[13:19:00.143]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.143]                   signalCondition(cond)
[13:19:00.143]                 }
[13:19:00.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.143]                 "immediateCondition"))) {
[13:19:00.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.143]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.143]                   if (TRUE && !signal) {
[13:19:00.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.143]                     {
[13:19:00.143]                       inherits <- base::inherits
[13:19:00.143]                       invokeRestart <- base::invokeRestart
[13:19:00.143]                       is.null <- base::is.null
[13:19:00.143]                       muffled <- FALSE
[13:19:00.143]                       if (inherits(cond, "message")) {
[13:19:00.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.143]                         if (muffled) 
[13:19:00.143]                           invokeRestart("muffleMessage")
[13:19:00.143]                       }
[13:19:00.143]                       else if (inherits(cond, "warning")) {
[13:19:00.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.143]                         if (muffled) 
[13:19:00.143]                           invokeRestart("muffleWarning")
[13:19:00.143]                       }
[13:19:00.143]                       else if (inherits(cond, "condition")) {
[13:19:00.143]                         if (!is.null(pattern)) {
[13:19:00.143]                           computeRestarts <- base::computeRestarts
[13:19:00.143]                           grepl <- base::grepl
[13:19:00.143]                           restarts <- computeRestarts(cond)
[13:19:00.143]                           for (restart in restarts) {
[13:19:00.143]                             name <- restart$name
[13:19:00.143]                             if (is.null(name)) 
[13:19:00.143]                               next
[13:19:00.143]                             if (!grepl(pattern, name)) 
[13:19:00.143]                               next
[13:19:00.143]                             invokeRestart(restart)
[13:19:00.143]                             muffled <- TRUE
[13:19:00.143]                             break
[13:19:00.143]                           }
[13:19:00.143]                         }
[13:19:00.143]                       }
[13:19:00.143]                       invisible(muffled)
[13:19:00.143]                     }
[13:19:00.143]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.143]                   }
[13:19:00.143]                 }
[13:19:00.143]                 else {
[13:19:00.143]                   if (TRUE) {
[13:19:00.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.143]                     {
[13:19:00.143]                       inherits <- base::inherits
[13:19:00.143]                       invokeRestart <- base::invokeRestart
[13:19:00.143]                       is.null <- base::is.null
[13:19:00.143]                       muffled <- FALSE
[13:19:00.143]                       if (inherits(cond, "message")) {
[13:19:00.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.143]                         if (muffled) 
[13:19:00.143]                           invokeRestart("muffleMessage")
[13:19:00.143]                       }
[13:19:00.143]                       else if (inherits(cond, "warning")) {
[13:19:00.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.143]                         if (muffled) 
[13:19:00.143]                           invokeRestart("muffleWarning")
[13:19:00.143]                       }
[13:19:00.143]                       else if (inherits(cond, "condition")) {
[13:19:00.143]                         if (!is.null(pattern)) {
[13:19:00.143]                           computeRestarts <- base::computeRestarts
[13:19:00.143]                           grepl <- base::grepl
[13:19:00.143]                           restarts <- computeRestarts(cond)
[13:19:00.143]                           for (restart in restarts) {
[13:19:00.143]                             name <- restart$name
[13:19:00.143]                             if (is.null(name)) 
[13:19:00.143]                               next
[13:19:00.143]                             if (!grepl(pattern, name)) 
[13:19:00.143]                               next
[13:19:00.143]                             invokeRestart(restart)
[13:19:00.143]                             muffled <- TRUE
[13:19:00.143]                             break
[13:19:00.143]                           }
[13:19:00.143]                         }
[13:19:00.143]                       }
[13:19:00.143]                       invisible(muffled)
[13:19:00.143]                     }
[13:19:00.143]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.143]                   }
[13:19:00.143]                 }
[13:19:00.143]             }
[13:19:00.143]         }))
[13:19:00.143]     }, error = function(ex) {
[13:19:00.143]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.143]                 ...future.rng), started = ...future.startTime, 
[13:19:00.143]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.143]             version = "1.8"), class = "FutureResult")
[13:19:00.143]     }, finally = {
[13:19:00.143]         if (!identical(...future.workdir, getwd())) 
[13:19:00.143]             setwd(...future.workdir)
[13:19:00.143]         {
[13:19:00.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.143]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.143]             }
[13:19:00.143]             base::options(...future.oldOptions)
[13:19:00.143]             if (.Platform$OS.type == "windows") {
[13:19:00.143]                 old_names <- names(...future.oldEnvVars)
[13:19:00.143]                 envs <- base::Sys.getenv()
[13:19:00.143]                 names <- names(envs)
[13:19:00.143]                 common <- intersect(names, old_names)
[13:19:00.143]                 added <- setdiff(names, old_names)
[13:19:00.143]                 removed <- setdiff(old_names, names)
[13:19:00.143]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.143]                   envs[common]]
[13:19:00.143]                 NAMES <- toupper(changed)
[13:19:00.143]                 args <- list()
[13:19:00.143]                 for (kk in seq_along(NAMES)) {
[13:19:00.143]                   name <- changed[[kk]]
[13:19:00.143]                   NAME <- NAMES[[kk]]
[13:19:00.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.143]                     next
[13:19:00.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.143]                 }
[13:19:00.143]                 NAMES <- toupper(added)
[13:19:00.143]                 for (kk in seq_along(NAMES)) {
[13:19:00.143]                   name <- added[[kk]]
[13:19:00.143]                   NAME <- NAMES[[kk]]
[13:19:00.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.143]                     next
[13:19:00.143]                   args[[name]] <- ""
[13:19:00.143]                 }
[13:19:00.143]                 NAMES <- toupper(removed)
[13:19:00.143]                 for (kk in seq_along(NAMES)) {
[13:19:00.143]                   name <- removed[[kk]]
[13:19:00.143]                   NAME <- NAMES[[kk]]
[13:19:00.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.143]                     next
[13:19:00.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.143]                 }
[13:19:00.143]                 if (length(args) > 0) 
[13:19:00.143]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.143]             }
[13:19:00.143]             else {
[13:19:00.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.143]             }
[13:19:00.143]             {
[13:19:00.143]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.143]                   0L) {
[13:19:00.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.143]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.143]                   base::options(opts)
[13:19:00.143]                 }
[13:19:00.143]                 {
[13:19:00.143]                   {
[13:19:00.143]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.143]                     NULL
[13:19:00.143]                   }
[13:19:00.143]                   options(future.plan = NULL)
[13:19:00.143]                   if (is.na(NA_character_)) 
[13:19:00.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.143]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:00.143]                     envir = parent.frame()) 
[13:19:00.143]                   {
[13:19:00.143]                     default_workers <- missing(workers)
[13:19:00.143]                     if (is.function(workers)) 
[13:19:00.143]                       workers <- workers()
[13:19:00.143]                     workers <- structure(as.integer(workers), 
[13:19:00.143]                       class = class(workers))
[13:19:00.143]                     stop_if_not(is.finite(workers), workers >= 
[13:19:00.143]                       1L)
[13:19:00.143]                     if ((workers == 1L && !inherits(workers, 
[13:19:00.143]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:00.143]                       if (default_workers) 
[13:19:00.143]                         supportsMulticore(warn = TRUE)
[13:19:00.143]                       return(sequential(..., envir = envir))
[13:19:00.143]                     }
[13:19:00.143]                     oopts <- options(mc.cores = workers)
[13:19:00.143]                     on.exit(options(oopts))
[13:19:00.143]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:00.143]                       envir = envir)
[13:19:00.143]                     if (!future$lazy) 
[13:19:00.143]                       future <- run(future)
[13:19:00.143]                     invisible(future)
[13:19:00.143]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.143]                 }
[13:19:00.143]             }
[13:19:00.143]         }
[13:19:00.143]     })
[13:19:00.143]     if (TRUE) {
[13:19:00.143]         base::sink(type = "output", split = FALSE)
[13:19:00.143]         if (TRUE) {
[13:19:00.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.143]         }
[13:19:00.143]         else {
[13:19:00.143]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.143]         }
[13:19:00.143]         base::close(...future.stdout)
[13:19:00.143]         ...future.stdout <- NULL
[13:19:00.143]     }
[13:19:00.143]     ...future.result$conditions <- ...future.conditions
[13:19:00.143]     ...future.result$finished <- base::Sys.time()
[13:19:00.143]     ...future.result
[13:19:00.143] }
[13:19:00.146] assign_globals() ...
[13:19:00.146] List of 11
[13:19:00.146]  $ ...future.FUN            :function (x, ...)  
[13:19:00.146]  $ x_FUN                    :function (x)  
[13:19:00.146]  $ times                    : int 1
[13:19:00.146]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.146]  $ stop_if_not              :function (...)  
[13:19:00.146]  $ dim                      : NULL
[13:19:00.146]  $ valid_types              : chr [1:2] "logical" "integer"
[13:19:00.146]  $ future.call.arguments    : list()
[13:19:00.146]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.146]  $ ...future.elements_ii    :List of 1
[13:19:00.146]   ..$ a: num 1
[13:19:00.146]  $ ...future.seeds_ii       : NULL
[13:19:00.146]  $ ...future.globals.maxSize: NULL
[13:19:00.146]  - attr(*, "where")=List of 11
[13:19:00.146]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ times                    :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:00.146]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:00.146]  - attr(*, "resolved")= logi FALSE
[13:19:00.146]  - attr(*, "total_size")= num 94264
[13:19:00.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.146]  - attr(*, "already-done")= logi TRUE
[13:19:00.156] - copied ‘...future.FUN’ to environment
[13:19:00.156] - copied ‘x_FUN’ to environment
[13:19:00.156] - copied ‘times’ to environment
[13:19:00.156] - copied ‘stopf’ to environment
[13:19:00.157] - copied ‘stop_if_not’ to environment
[13:19:00.157] - copied ‘dim’ to environment
[13:19:00.157] - copied ‘valid_types’ to environment
[13:19:00.157] - copied ‘future.call.arguments’ to environment
[13:19:00.157] - copied ‘...future.elements_ii’ to environment
[13:19:00.157] - copied ‘...future.seeds_ii’ to environment
[13:19:00.157] - copied ‘...future.globals.maxSize’ to environment
[13:19:00.157] assign_globals() ... done
[13:19:00.158] requestCore(): workers = 2
[13:19:00.160] MulticoreFuture started
[13:19:00.161] - Launch lazy future ... done
[13:19:00.161] run() for ‘MulticoreFuture’ ... done
[13:19:00.162] Created future:
[13:19:00.162] plan(): Setting new future strategy stack:
[13:19:00.162] List of future strategies:
[13:19:00.162] 1. sequential:
[13:19:00.162]    - args: function (..., envir = parent.frame())
[13:19:00.162]    - tweaked: FALSE
[13:19:00.162]    - call: NULL
[13:19:00.164] plan(): nbrOfWorkers() = 1
[13:19:00.167] plan(): Setting new future strategy stack:
[13:19:00.167] List of future strategies:
[13:19:00.167] 1. multicore:
[13:19:00.167]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:00.167]    - tweaked: FALSE
[13:19:00.167]    - call: plan(strategy)
[13:19:00.174] plan(): nbrOfWorkers() = 2
[13:19:00.162] MulticoreFuture:
[13:19:00.162] Label: ‘future_vapply-1’
[13:19:00.162] Expression:
[13:19:00.162] {
[13:19:00.162]     do.call(function(...) {
[13:19:00.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.162]             on.exit(options(oopts), add = TRUE)
[13:19:00.162]         }
[13:19:00.162]         {
[13:19:00.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.162]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.162]             })
[13:19:00.162]         }
[13:19:00.162]     }, args = future.call.arguments)
[13:19:00.162] }
[13:19:00.162] Lazy evaluation: FALSE
[13:19:00.162] Asynchronous evaluation: TRUE
[13:19:00.162] Local evaluation: TRUE
[13:19:00.162] Environment: R_GlobalEnv
[13:19:00.162] Capture standard output: TRUE
[13:19:00.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:00.162] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:00.162] Packages: 1 packages (‘future.apply’)
[13:19:00.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:00.162] Resolved: TRUE
[13:19:00.162] Value: <not collected>
[13:19:00.162] Conditions captured: <none>
[13:19:00.162] Early signaling: FALSE
[13:19:00.162] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:00.162] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.176] Chunk #1 of 2 ... DONE
[13:19:00.176] Chunk #2 of 2 ...
[13:19:00.176]  - Finding globals in 'X' for chunk #2 ...
[13:19:00.176] getGlobalsAndPackages() ...
[13:19:00.177] Searching for globals...
[13:19:00.177] 
[13:19:00.177] Searching for globals ... DONE
[13:19:00.177] - globals: [0] <none>
[13:19:00.178] getGlobalsAndPackages() ... DONE
[13:19:00.178]    + additional globals found: [n=0] 
[13:19:00.178]    + additional namespaces needed: [n=0] 
[13:19:00.178]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:00.178]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:00.179]  - seeds: <none>
[13:19:00.179] getGlobalsAndPackages() ...
[13:19:00.179] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.180] Resolving globals: FALSE
[13:19:00.180] Tweak future expression to call with '...' arguments ...
[13:19:00.180] {
[13:19:00.180]     do.call(function(...) {
[13:19:00.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.180]             on.exit(options(oopts), add = TRUE)
[13:19:00.180]         }
[13:19:00.180]         {
[13:19:00.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.180]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.180]             })
[13:19:00.180]         }
[13:19:00.180]     }, args = future.call.arguments)
[13:19:00.180] }
[13:19:00.181] Tweak future expression to call with '...' arguments ... DONE
[13:19:00.182] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.182] - packages: [1] ‘future.apply’
[13:19:00.182] getGlobalsAndPackages() ... DONE
[13:19:00.182] run() for ‘Future’ ...
[13:19:00.183] - state: ‘created’
[13:19:00.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:00.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:00.188]   - Field: ‘label’
[13:19:00.189]   - Field: ‘local’
[13:19:00.189]   - Field: ‘owner’
[13:19:00.189]   - Field: ‘envir’
[13:19:00.189]   - Field: ‘workers’
[13:19:00.189]   - Field: ‘packages’
[13:19:00.189]   - Field: ‘gc’
[13:19:00.189]   - Field: ‘job’
[13:19:00.190]   - Field: ‘conditions’
[13:19:00.190]   - Field: ‘expr’
[13:19:00.190]   - Field: ‘uuid’
[13:19:00.190]   - Field: ‘seed’
[13:19:00.190]   - Field: ‘version’
[13:19:00.190]   - Field: ‘result’
[13:19:00.190]   - Field: ‘asynchronous’
[13:19:00.191]   - Field: ‘calls’
[13:19:00.191]   - Field: ‘globals’
[13:19:00.191]   - Field: ‘stdout’
[13:19:00.191]   - Field: ‘earlySignal’
[13:19:00.191]   - Field: ‘lazy’
[13:19:00.191]   - Field: ‘state’
[13:19:00.191] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:00.192] - Launch lazy future ...
[13:19:00.192] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:00.192] Packages needed by future strategies (n = 0): <none>
[13:19:00.193] {
[13:19:00.193]     {
[13:19:00.193]         {
[13:19:00.193]             ...future.startTime <- base::Sys.time()
[13:19:00.193]             {
[13:19:00.193]                 {
[13:19:00.193]                   {
[13:19:00.193]                     {
[13:19:00.193]                       {
[13:19:00.193]                         base::local({
[13:19:00.193]                           has_future <- base::requireNamespace("future", 
[13:19:00.193]                             quietly = TRUE)
[13:19:00.193]                           if (has_future) {
[13:19:00.193]                             ns <- base::getNamespace("future")
[13:19:00.193]                             version <- ns[[".package"]][["version"]]
[13:19:00.193]                             if (is.null(version)) 
[13:19:00.193]                               version <- utils::packageVersion("future")
[13:19:00.193]                           }
[13:19:00.193]                           else {
[13:19:00.193]                             version <- NULL
[13:19:00.193]                           }
[13:19:00.193]                           if (!has_future || version < "1.8.0") {
[13:19:00.193]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.193]                               "", base::R.version$version.string), 
[13:19:00.193]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:00.193]                                 base::R.version$platform, 8 * 
[13:19:00.193]                                   base::.Machine$sizeof.pointer), 
[13:19:00.193]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.193]                                 "release", "version")], collapse = " "), 
[13:19:00.193]                               hostname = base::Sys.info()[["nodename"]])
[13:19:00.193]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.193]                               info)
[13:19:00.193]                             info <- base::paste(info, collapse = "; ")
[13:19:00.193]                             if (!has_future) {
[13:19:00.193]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.193]                                 info)
[13:19:00.193]                             }
[13:19:00.193]                             else {
[13:19:00.193]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.193]                                 info, version)
[13:19:00.193]                             }
[13:19:00.193]                             base::stop(msg)
[13:19:00.193]                           }
[13:19:00.193]                         })
[13:19:00.193]                       }
[13:19:00.193]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.193]                       base::options(mc.cores = 1L)
[13:19:00.193]                     }
[13:19:00.193]                     base::local({
[13:19:00.193]                       for (pkg in "future.apply") {
[13:19:00.193]                         base::loadNamespace(pkg)
[13:19:00.193]                         base::library(pkg, character.only = TRUE)
[13:19:00.193]                       }
[13:19:00.193]                     })
[13:19:00.193]                   }
[13:19:00.193]                   options(future.plan = NULL)
[13:19:00.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.193]                 }
[13:19:00.193]                 ...future.workdir <- getwd()
[13:19:00.193]             }
[13:19:00.193]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.193]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.193]         }
[13:19:00.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.193]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:00.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.193]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.193]             base::names(...future.oldOptions))
[13:19:00.193]     }
[13:19:00.193]     if (FALSE) {
[13:19:00.193]     }
[13:19:00.193]     else {
[13:19:00.193]         if (TRUE) {
[13:19:00.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.193]                 open = "w")
[13:19:00.193]         }
[13:19:00.193]         else {
[13:19:00.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.193]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.193]         }
[13:19:00.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.193]             base::sink(type = "output", split = FALSE)
[13:19:00.193]             base::close(...future.stdout)
[13:19:00.193]         }, add = TRUE)
[13:19:00.193]     }
[13:19:00.193]     ...future.frame <- base::sys.nframe()
[13:19:00.193]     ...future.conditions <- base::list()
[13:19:00.193]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.193]     if (FALSE) {
[13:19:00.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.193]     }
[13:19:00.193]     ...future.result <- base::tryCatch({
[13:19:00.193]         base::withCallingHandlers({
[13:19:00.193]             ...future.value <- base::withVisible(base::local({
[13:19:00.193]                 withCallingHandlers({
[13:19:00.193]                   {
[13:19:00.193]                     do.call(function(...) {
[13:19:00.193]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.193]                       if (!identical(...future.globals.maxSize.org, 
[13:19:00.193]                         ...future.globals.maxSize)) {
[13:19:00.193]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.193]                         on.exit(options(oopts), add = TRUE)
[13:19:00.193]                       }
[13:19:00.193]                       {
[13:19:00.193]                         lapply(seq_along(...future.elements_ii), 
[13:19:00.193]                           FUN = function(jj) {
[13:19:00.193]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.193]                             ...future.FUN(...future.X_jj, ...)
[13:19:00.193]                           })
[13:19:00.193]                       }
[13:19:00.193]                     }, args = future.call.arguments)
[13:19:00.193]                   }
[13:19:00.193]                 }, immediateCondition = function(cond) {
[13:19:00.193]                   save_rds <- function (object, pathname, ...) 
[13:19:00.193]                   {
[13:19:00.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:00.193]                     if (file_test("-f", pathname_tmp)) {
[13:19:00.193]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:00.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.193]                         fi_tmp[["mtime"]])
[13:19:00.193]                     }
[13:19:00.193]                     tryCatch({
[13:19:00.193]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:00.193]                     }, error = function(ex) {
[13:19:00.193]                       msg <- conditionMessage(ex)
[13:19:00.193]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:00.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.193]                         fi_tmp[["mtime"]], msg)
[13:19:00.193]                       ex$message <- msg
[13:19:00.193]                       stop(ex)
[13:19:00.193]                     })
[13:19:00.193]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:00.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:00.193]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:00.193]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.193]                       fi <- file.info(pathname)
[13:19:00.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:00.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:00.193]                         fi[["size"]], fi[["mtime"]])
[13:19:00.193]                       stop(msg)
[13:19:00.193]                     }
[13:19:00.193]                     invisible(pathname)
[13:19:00.193]                   }
[13:19:00.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:00.193]                     rootPath = tempdir()) 
[13:19:00.193]                   {
[13:19:00.193]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:00.193]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:00.193]                       tmpdir = path, fileext = ".rds")
[13:19:00.193]                     save_rds(obj, file)
[13:19:00.193]                   }
[13:19:00.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:19:00.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.193]                   {
[13:19:00.193]                     inherits <- base::inherits
[13:19:00.193]                     invokeRestart <- base::invokeRestart
[13:19:00.193]                     is.null <- base::is.null
[13:19:00.193]                     muffled <- FALSE
[13:19:00.193]                     if (inherits(cond, "message")) {
[13:19:00.193]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.193]                       if (muffled) 
[13:19:00.193]                         invokeRestart("muffleMessage")
[13:19:00.193]                     }
[13:19:00.193]                     else if (inherits(cond, "warning")) {
[13:19:00.193]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.193]                       if (muffled) 
[13:19:00.193]                         invokeRestart("muffleWarning")
[13:19:00.193]                     }
[13:19:00.193]                     else if (inherits(cond, "condition")) {
[13:19:00.193]                       if (!is.null(pattern)) {
[13:19:00.193]                         computeRestarts <- base::computeRestarts
[13:19:00.193]                         grepl <- base::grepl
[13:19:00.193]                         restarts <- computeRestarts(cond)
[13:19:00.193]                         for (restart in restarts) {
[13:19:00.193]                           name <- restart$name
[13:19:00.193]                           if (is.null(name)) 
[13:19:00.193]                             next
[13:19:00.193]                           if (!grepl(pattern, name)) 
[13:19:00.193]                             next
[13:19:00.193]                           invokeRestart(restart)
[13:19:00.193]                           muffled <- TRUE
[13:19:00.193]                           break
[13:19:00.193]                         }
[13:19:00.193]                       }
[13:19:00.193]                     }
[13:19:00.193]                     invisible(muffled)
[13:19:00.193]                   }
[13:19:00.193]                   muffleCondition(cond)
[13:19:00.193]                 })
[13:19:00.193]             }))
[13:19:00.193]             future::FutureResult(value = ...future.value$value, 
[13:19:00.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.193]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.193]                     ...future.globalenv.names))
[13:19:00.193]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.193]         }, condition = base::local({
[13:19:00.193]             c <- base::c
[13:19:00.193]             inherits <- base::inherits
[13:19:00.193]             invokeRestart <- base::invokeRestart
[13:19:00.193]             length <- base::length
[13:19:00.193]             list <- base::list
[13:19:00.193]             seq.int <- base::seq.int
[13:19:00.193]             signalCondition <- base::signalCondition
[13:19:00.193]             sys.calls <- base::sys.calls
[13:19:00.193]             `[[` <- base::`[[`
[13:19:00.193]             `+` <- base::`+`
[13:19:00.193]             `<<-` <- base::`<<-`
[13:19:00.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.193]                   3L)]
[13:19:00.193]             }
[13:19:00.193]             function(cond) {
[13:19:00.193]                 is_error <- inherits(cond, "error")
[13:19:00.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.193]                   NULL)
[13:19:00.193]                 if (is_error) {
[13:19:00.193]                   sessionInformation <- function() {
[13:19:00.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.193]                       search = base::search(), system = base::Sys.info())
[13:19:00.193]                   }
[13:19:00.193]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.193]                     cond$call), session = sessionInformation(), 
[13:19:00.193]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.193]                   signalCondition(cond)
[13:19:00.193]                 }
[13:19:00.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.193]                 "immediateCondition"))) {
[13:19:00.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.193]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.193]                   if (TRUE && !signal) {
[13:19:00.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.193]                     {
[13:19:00.193]                       inherits <- base::inherits
[13:19:00.193]                       invokeRestart <- base::invokeRestart
[13:19:00.193]                       is.null <- base::is.null
[13:19:00.193]                       muffled <- FALSE
[13:19:00.193]                       if (inherits(cond, "message")) {
[13:19:00.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.193]                         if (muffled) 
[13:19:00.193]                           invokeRestart("muffleMessage")
[13:19:00.193]                       }
[13:19:00.193]                       else if (inherits(cond, "warning")) {
[13:19:00.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.193]                         if (muffled) 
[13:19:00.193]                           invokeRestart("muffleWarning")
[13:19:00.193]                       }
[13:19:00.193]                       else if (inherits(cond, "condition")) {
[13:19:00.193]                         if (!is.null(pattern)) {
[13:19:00.193]                           computeRestarts <- base::computeRestarts
[13:19:00.193]                           grepl <- base::grepl
[13:19:00.193]                           restarts <- computeRestarts(cond)
[13:19:00.193]                           for (restart in restarts) {
[13:19:00.193]                             name <- restart$name
[13:19:00.193]                             if (is.null(name)) 
[13:19:00.193]                               next
[13:19:00.193]                             if (!grepl(pattern, name)) 
[13:19:00.193]                               next
[13:19:00.193]                             invokeRestart(restart)
[13:19:00.193]                             muffled <- TRUE
[13:19:00.193]                             break
[13:19:00.193]                           }
[13:19:00.193]                         }
[13:19:00.193]                       }
[13:19:00.193]                       invisible(muffled)
[13:19:00.193]                     }
[13:19:00.193]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.193]                   }
[13:19:00.193]                 }
[13:19:00.193]                 else {
[13:19:00.193]                   if (TRUE) {
[13:19:00.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.193]                     {
[13:19:00.193]                       inherits <- base::inherits
[13:19:00.193]                       invokeRestart <- base::invokeRestart
[13:19:00.193]                       is.null <- base::is.null
[13:19:00.193]                       muffled <- FALSE
[13:19:00.193]                       if (inherits(cond, "message")) {
[13:19:00.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.193]                         if (muffled) 
[13:19:00.193]                           invokeRestart("muffleMessage")
[13:19:00.193]                       }
[13:19:00.193]                       else if (inherits(cond, "warning")) {
[13:19:00.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.193]                         if (muffled) 
[13:19:00.193]                           invokeRestart("muffleWarning")
[13:19:00.193]                       }
[13:19:00.193]                       else if (inherits(cond, "condition")) {
[13:19:00.193]                         if (!is.null(pattern)) {
[13:19:00.193]                           computeRestarts <- base::computeRestarts
[13:19:00.193]                           grepl <- base::grepl
[13:19:00.193]                           restarts <- computeRestarts(cond)
[13:19:00.193]                           for (restart in restarts) {
[13:19:00.193]                             name <- restart$name
[13:19:00.193]                             if (is.null(name)) 
[13:19:00.193]                               next
[13:19:00.193]                             if (!grepl(pattern, name)) 
[13:19:00.193]                               next
[13:19:00.193]                             invokeRestart(restart)
[13:19:00.193]                             muffled <- TRUE
[13:19:00.193]                             break
[13:19:00.193]                           }
[13:19:00.193]                         }
[13:19:00.193]                       }
[13:19:00.193]                       invisible(muffled)
[13:19:00.193]                     }
[13:19:00.193]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.193]                   }
[13:19:00.193]                 }
[13:19:00.193]             }
[13:19:00.193]         }))
[13:19:00.193]     }, error = function(ex) {
[13:19:00.193]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.193]                 ...future.rng), started = ...future.startTime, 
[13:19:00.193]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.193]             version = "1.8"), class = "FutureResult")
[13:19:00.193]     }, finally = {
[13:19:00.193]         if (!identical(...future.workdir, getwd())) 
[13:19:00.193]             setwd(...future.workdir)
[13:19:00.193]         {
[13:19:00.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.193]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.193]             }
[13:19:00.193]             base::options(...future.oldOptions)
[13:19:00.193]             if (.Platform$OS.type == "windows") {
[13:19:00.193]                 old_names <- names(...future.oldEnvVars)
[13:19:00.193]                 envs <- base::Sys.getenv()
[13:19:00.193]                 names <- names(envs)
[13:19:00.193]                 common <- intersect(names, old_names)
[13:19:00.193]                 added <- setdiff(names, old_names)
[13:19:00.193]                 removed <- setdiff(old_names, names)
[13:19:00.193]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.193]                   envs[common]]
[13:19:00.193]                 NAMES <- toupper(changed)
[13:19:00.193]                 args <- list()
[13:19:00.193]                 for (kk in seq_along(NAMES)) {
[13:19:00.193]                   name <- changed[[kk]]
[13:19:00.193]                   NAME <- NAMES[[kk]]
[13:19:00.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.193]                     next
[13:19:00.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.193]                 }
[13:19:00.193]                 NAMES <- toupper(added)
[13:19:00.193]                 for (kk in seq_along(NAMES)) {
[13:19:00.193]                   name <- added[[kk]]
[13:19:00.193]                   NAME <- NAMES[[kk]]
[13:19:00.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.193]                     next
[13:19:00.193]                   args[[name]] <- ""
[13:19:00.193]                 }
[13:19:00.193]                 NAMES <- toupper(removed)
[13:19:00.193]                 for (kk in seq_along(NAMES)) {
[13:19:00.193]                   name <- removed[[kk]]
[13:19:00.193]                   NAME <- NAMES[[kk]]
[13:19:00.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.193]                     next
[13:19:00.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.193]                 }
[13:19:00.193]                 if (length(args) > 0) 
[13:19:00.193]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.193]             }
[13:19:00.193]             else {
[13:19:00.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.193]             }
[13:19:00.193]             {
[13:19:00.193]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.193]                   0L) {
[13:19:00.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.193]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.193]                   base::options(opts)
[13:19:00.193]                 }
[13:19:00.193]                 {
[13:19:00.193]                   {
[13:19:00.193]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.193]                     NULL
[13:19:00.193]                   }
[13:19:00.193]                   options(future.plan = NULL)
[13:19:00.193]                   if (is.na(NA_character_)) 
[13:19:00.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.193]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:00.193]                     envir = parent.frame()) 
[13:19:00.193]                   {
[13:19:00.193]                     default_workers <- missing(workers)
[13:19:00.193]                     if (is.function(workers)) 
[13:19:00.193]                       workers <- workers()
[13:19:00.193]                     workers <- structure(as.integer(workers), 
[13:19:00.193]                       class = class(workers))
[13:19:00.193]                     stop_if_not(is.finite(workers), workers >= 
[13:19:00.193]                       1L)
[13:19:00.193]                     if ((workers == 1L && !inherits(workers, 
[13:19:00.193]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:00.193]                       if (default_workers) 
[13:19:00.193]                         supportsMulticore(warn = TRUE)
[13:19:00.193]                       return(sequential(..., envir = envir))
[13:19:00.193]                     }
[13:19:00.193]                     oopts <- options(mc.cores = workers)
[13:19:00.193]                     on.exit(options(oopts))
[13:19:00.193]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:00.193]                       envir = envir)
[13:19:00.193]                     if (!future$lazy) 
[13:19:00.193]                       future <- run(future)
[13:19:00.193]                     invisible(future)
[13:19:00.193]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.193]                 }
[13:19:00.193]             }
[13:19:00.193]         }
[13:19:00.193]     })
[13:19:00.193]     if (TRUE) {
[13:19:00.193]         base::sink(type = "output", split = FALSE)
[13:19:00.193]         if (TRUE) {
[13:19:00.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.193]         }
[13:19:00.193]         else {
[13:19:00.193]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.193]         }
[13:19:00.193]         base::close(...future.stdout)
[13:19:00.193]         ...future.stdout <- NULL
[13:19:00.193]     }
[13:19:00.193]     ...future.result$conditions <- ...future.conditions
[13:19:00.193]     ...future.result$finished <- base::Sys.time()
[13:19:00.193]     ...future.result
[13:19:00.193] }
[13:19:00.196] assign_globals() ...
[13:19:00.197] List of 11
[13:19:00.197]  $ ...future.FUN            :function (x, ...)  
[13:19:00.197]  $ x_FUN                    :function (x)  
[13:19:00.197]  $ times                    : int 1
[13:19:00.197]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.197]  $ stop_if_not              :function (...)  
[13:19:00.197]  $ dim                      : NULL
[13:19:00.197]  $ valid_types              : chr [1:2] "logical" "integer"
[13:19:00.197]  $ future.call.arguments    : list()
[13:19:00.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.197]  $ ...future.elements_ii    :List of 2
[13:19:00.197]   ..$ b: num 2
[13:19:00.197]   ..$ c: num 3
[13:19:00.197]  $ ...future.seeds_ii       : NULL
[13:19:00.197]  $ ...future.globals.maxSize: NULL
[13:19:00.197]  - attr(*, "resolved")= logi FALSE
[13:19:00.197]  - attr(*, "total_size")= num 94264
[13:19:00.197]  - attr(*, "where")=List of 11
[13:19:00.197]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ times                    :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:00.197]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:00.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.197]  - attr(*, "already-done")= logi TRUE
[13:19:00.211] - copied ‘...future.FUN’ to environment
[13:19:00.211] - copied ‘x_FUN’ to environment
[13:19:00.211] - copied ‘times’ to environment
[13:19:00.211] - copied ‘stopf’ to environment
[13:19:00.211] - copied ‘stop_if_not’ to environment
[13:19:00.211] - copied ‘dim’ to environment
[13:19:00.212] - copied ‘valid_types’ to environment
[13:19:00.212] - copied ‘future.call.arguments’ to environment
[13:19:00.212] - copied ‘...future.elements_ii’ to environment
[13:19:00.212] - copied ‘...future.seeds_ii’ to environment
[13:19:00.212] - copied ‘...future.globals.maxSize’ to environment
[13:19:00.212] assign_globals() ... done
[13:19:00.212] requestCore(): workers = 2
[13:19:00.215] MulticoreFuture started
[13:19:00.216] - Launch lazy future ... done
[13:19:00.216] run() for ‘MulticoreFuture’ ... done
[13:19:00.217] Created future:
[13:19:00.217] plan(): Setting new future strategy stack:
[13:19:00.217] List of future strategies:
[13:19:00.217] 1. sequential:
[13:19:00.217]    - args: function (..., envir = parent.frame())
[13:19:00.217]    - tweaked: FALSE
[13:19:00.217]    - call: NULL
[13:19:00.219] plan(): nbrOfWorkers() = 1
[13:19:00.221] plan(): Setting new future strategy stack:
[13:19:00.222] List of future strategies:
[13:19:00.222] 1. multicore:
[13:19:00.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:00.222]    - tweaked: FALSE
[13:19:00.222]    - call: plan(strategy)
[13:19:00.228] plan(): nbrOfWorkers() = 2
[13:19:00.217] MulticoreFuture:
[13:19:00.217] Label: ‘future_vapply-2’
[13:19:00.217] Expression:
[13:19:00.217] {
[13:19:00.217]     do.call(function(...) {
[13:19:00.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.217]             on.exit(options(oopts), add = TRUE)
[13:19:00.217]         }
[13:19:00.217]         {
[13:19:00.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.217]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.217]             })
[13:19:00.217]         }
[13:19:00.217]     }, args = future.call.arguments)
[13:19:00.217] }
[13:19:00.217] Lazy evaluation: FALSE
[13:19:00.217] Asynchronous evaluation: TRUE
[13:19:00.217] Local evaluation: TRUE
[13:19:00.217] Environment: R_GlobalEnv
[13:19:00.217] Capture standard output: TRUE
[13:19:00.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:00.217] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:00.217] Packages: 1 packages (‘future.apply’)
[13:19:00.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:00.217] Resolved: TRUE
[13:19:00.217] Value: <not collected>
[13:19:00.217] Conditions captured: <none>
[13:19:00.217] Early signaling: FALSE
[13:19:00.217] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:00.217] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.229] Chunk #2 of 2 ... DONE
[13:19:00.229] Launching 2 futures (chunks) ... DONE
[13:19:00.229] Resolving 2 futures (chunks) ...
[13:19:00.229] resolve() on list ...
[13:19:00.230]  recursive: 0
[13:19:00.230]  length: 2
[13:19:00.230] 
[13:19:00.230] Future #1
[13:19:00.231] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:00.231] - nx: 2
[13:19:00.231] - relay: TRUE
[13:19:00.232] - stdout: TRUE
[13:19:00.232] - signal: TRUE
[13:19:00.232] - resignal: FALSE
[13:19:00.232] - force: TRUE
[13:19:00.232] - relayed: [n=2] FALSE, FALSE
[13:19:00.233] - queued futures: [n=2] FALSE, FALSE
[13:19:00.233]  - until=1
[13:19:00.233]  - relaying element #1
[13:19:00.234] - relayed: [n=2] TRUE, FALSE
[13:19:00.234] - queued futures: [n=2] TRUE, FALSE
[13:19:00.234] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:00.234]  length: 1 (resolved future 1)
[13:19:00.234] Future #2
[13:19:00.235] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:00.236] - nx: 2
[13:19:00.236] - relay: TRUE
[13:19:00.236] - stdout: TRUE
[13:19:00.236] - signal: TRUE
[13:19:00.236] - resignal: FALSE
[13:19:00.237] - force: TRUE
[13:19:00.237] - relayed: [n=2] TRUE, FALSE
[13:19:00.237] - queued futures: [n=2] TRUE, FALSE
[13:19:00.237]  - until=2
[13:19:00.237]  - relaying element #2
[13:19:00.238] - relayed: [n=2] TRUE, TRUE
[13:19:00.238] - queued futures: [n=2] TRUE, TRUE
[13:19:00.238] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:19:00.238]  length: 0 (resolved future 2)
[13:19:00.238] Relaying remaining futures
[13:19:00.238] signalConditionsASAP(NULL, pos=0) ...
[13:19:00.239] - nx: 2
[13:19:00.239] - relay: TRUE
[13:19:00.239] - stdout: TRUE
[13:19:00.239] - signal: TRUE
[13:19:00.239] - resignal: FALSE
[13:19:00.239] - force: TRUE
[13:19:00.239] - relayed: [n=2] TRUE, TRUE
[13:19:00.239] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:00.239] - relayed: [n=2] TRUE, TRUE
[13:19:00.240] - queued futures: [n=2] TRUE, TRUE
[13:19:00.240] signalConditionsASAP(NULL, pos=0) ... done
[13:19:00.240] resolve() on list ... DONE
[13:19:00.240]  - Number of value chunks collected: 2
[13:19:00.240] Resolving 2 futures (chunks) ... DONE
[13:19:00.240] Reducing values from 2 chunks ...
[13:19:00.240]  - Number of values collected after concatenation: 3
[13:19:00.240]  - Number of values expected: 3
[13:19:00.241] Reducing values from 2 chunks ... DONE
[13:19:00.241] future_lapply() ... DONE
- exceptions ...
[13:19:00.241] future_lapply() ...
[13:19:00.248] Number of chunks: 2
[13:19:00.248] getGlobalsAndPackagesXApply() ...
[13:19:00.248]  - future.globals: TRUE
[13:19:00.248] getGlobalsAndPackages() ...
[13:19:00.248] Searching for globals...
[13:19:00.255] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:00.256] Searching for globals ... DONE
[13:19:00.256] Resolving globals: FALSE
[13:19:00.257] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:19:00.257] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:00.258] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:00.258] - packages: [1] ‘future.apply’
[13:19:00.258] getGlobalsAndPackages() ... DONE
[13:19:00.258]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:00.258]  - needed namespaces: [n=1] ‘future.apply’
[13:19:00.258] Finding globals ... DONE
[13:19:00.258]  - use_args: TRUE
[13:19:00.259]  - Getting '...' globals ...
[13:19:00.259] resolve() on list ...
[13:19:00.259]  recursive: 0
[13:19:00.259]  length: 1
[13:19:00.259]  elements: ‘...’
[13:19:00.259]  length: 0 (resolved future 1)
[13:19:00.260] resolve() on list ... DONE
[13:19:00.260]    - '...' content: [n=0] 
[13:19:00.260] List of 1
[13:19:00.260]  $ ...: list()
[13:19:00.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.260]  - attr(*, "where")=List of 1
[13:19:00.260]   ..$ ...:<environment: 0x555f7afc8390> 
[13:19:00.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.260]  - attr(*, "resolved")= logi TRUE
[13:19:00.260]  - attr(*, "total_size")= num NA
[13:19:00.263]  - Getting '...' globals ... DONE
[13:19:00.263] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:00.263] List of 8
[13:19:00.263]  $ ...future.FUN:function (x, ...)  
[13:19:00.263]  $ x_FUN        :function (x)  
[13:19:00.263]  $ times        : int 2
[13:19:00.263]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.263]  $ stop_if_not  :function (...)  
[13:19:00.263]  $ dim          : NULL
[13:19:00.263]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:00.263]  $ ...          : list()
[13:19:00.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.263]  - attr(*, "where")=List of 8
[13:19:00.263]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:00.263]   ..$ ...          :<environment: 0x555f7afc8390> 
[13:19:00.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.263]  - attr(*, "resolved")= logi FALSE
[13:19:00.263]  - attr(*, "total_size")= num 95128
[13:19:00.269] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:00.269] getGlobalsAndPackagesXApply() ... DONE
[13:19:00.269] Number of futures (= number of chunks): 2
[13:19:00.269] Launching 2 futures (chunks) ...
[13:19:00.269] Chunk #1 of 2 ...
[13:19:00.269]  - Finding globals in 'X' for chunk #1 ...
[13:19:00.269] getGlobalsAndPackages() ...
[13:19:00.269] Searching for globals...
[13:19:00.270] 
[13:19:00.270] Searching for globals ... DONE
[13:19:00.270] - globals: [0] <none>
[13:19:00.270] getGlobalsAndPackages() ... DONE
[13:19:00.270]    + additional globals found: [n=0] 
[13:19:00.272]    + additional namespaces needed: [n=0] 
[13:19:00.273]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:00.273]  - seeds: <none>
[13:19:00.273] getGlobalsAndPackages() ...
[13:19:00.273] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.273] Resolving globals: FALSE
[13:19:00.273] Tweak future expression to call with '...' arguments ...
[13:19:00.273] {
[13:19:00.273]     do.call(function(...) {
[13:19:00.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.273]             on.exit(options(oopts), add = TRUE)
[13:19:00.273]         }
[13:19:00.273]         {
[13:19:00.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.273]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.273]             })
[13:19:00.273]         }
[13:19:00.273]     }, args = future.call.arguments)
[13:19:00.273] }
[13:19:00.274] Tweak future expression to call with '...' arguments ... DONE
[13:19:00.274] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.274] - packages: [1] ‘future.apply’
[13:19:00.275] getGlobalsAndPackages() ... DONE
[13:19:00.275] run() for ‘Future’ ...
[13:19:00.275] - state: ‘created’
[13:19:00.275] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:00.280] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:00.280]   - Field: ‘label’
[13:19:00.280]   - Field: ‘local’
[13:19:00.280]   - Field: ‘owner’
[13:19:00.280]   - Field: ‘envir’
[13:19:00.280]   - Field: ‘workers’
[13:19:00.281]   - Field: ‘packages’
[13:19:00.281]   - Field: ‘gc’
[13:19:00.281]   - Field: ‘job’
[13:19:00.281]   - Field: ‘conditions’
[13:19:00.281]   - Field: ‘expr’
[13:19:00.281]   - Field: ‘uuid’
[13:19:00.281]   - Field: ‘seed’
[13:19:00.281]   - Field: ‘version’
[13:19:00.282]   - Field: ‘result’
[13:19:00.282]   - Field: ‘asynchronous’
[13:19:00.282]   - Field: ‘calls’
[13:19:00.282]   - Field: ‘globals’
[13:19:00.282]   - Field: ‘stdout’
[13:19:00.282]   - Field: ‘earlySignal’
[13:19:00.282]   - Field: ‘lazy’
[13:19:00.282]   - Field: ‘state’
[13:19:00.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:00.283] - Launch lazy future ...
[13:19:00.283] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:00.283] Packages needed by future strategies (n = 0): <none>
[13:19:00.284] {
[13:19:00.284]     {
[13:19:00.284]         {
[13:19:00.284]             ...future.startTime <- base::Sys.time()
[13:19:00.284]             {
[13:19:00.284]                 {
[13:19:00.284]                   {
[13:19:00.284]                     {
[13:19:00.284]                       {
[13:19:00.284]                         base::local({
[13:19:00.284]                           has_future <- base::requireNamespace("future", 
[13:19:00.284]                             quietly = TRUE)
[13:19:00.284]                           if (has_future) {
[13:19:00.284]                             ns <- base::getNamespace("future")
[13:19:00.284]                             version <- ns[[".package"]][["version"]]
[13:19:00.284]                             if (is.null(version)) 
[13:19:00.284]                               version <- utils::packageVersion("future")
[13:19:00.284]                           }
[13:19:00.284]                           else {
[13:19:00.284]                             version <- NULL
[13:19:00.284]                           }
[13:19:00.284]                           if (!has_future || version < "1.8.0") {
[13:19:00.284]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.284]                               "", base::R.version$version.string), 
[13:19:00.284]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:00.284]                                 base::R.version$platform, 8 * 
[13:19:00.284]                                   base::.Machine$sizeof.pointer), 
[13:19:00.284]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.284]                                 "release", "version")], collapse = " "), 
[13:19:00.284]                               hostname = base::Sys.info()[["nodename"]])
[13:19:00.284]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.284]                               info)
[13:19:00.284]                             info <- base::paste(info, collapse = "; ")
[13:19:00.284]                             if (!has_future) {
[13:19:00.284]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.284]                                 info)
[13:19:00.284]                             }
[13:19:00.284]                             else {
[13:19:00.284]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.284]                                 info, version)
[13:19:00.284]                             }
[13:19:00.284]                             base::stop(msg)
[13:19:00.284]                           }
[13:19:00.284]                         })
[13:19:00.284]                       }
[13:19:00.284]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.284]                       base::options(mc.cores = 1L)
[13:19:00.284]                     }
[13:19:00.284]                     base::local({
[13:19:00.284]                       for (pkg in "future.apply") {
[13:19:00.284]                         base::loadNamespace(pkg)
[13:19:00.284]                         base::library(pkg, character.only = TRUE)
[13:19:00.284]                       }
[13:19:00.284]                     })
[13:19:00.284]                   }
[13:19:00.284]                   options(future.plan = NULL)
[13:19:00.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.284]                 }
[13:19:00.284]                 ...future.workdir <- getwd()
[13:19:00.284]             }
[13:19:00.284]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.284]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.284]         }
[13:19:00.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:00.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.284]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.284]             base::names(...future.oldOptions))
[13:19:00.284]     }
[13:19:00.284]     if (FALSE) {
[13:19:00.284]     }
[13:19:00.284]     else {
[13:19:00.284]         if (TRUE) {
[13:19:00.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.284]                 open = "w")
[13:19:00.284]         }
[13:19:00.284]         else {
[13:19:00.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.284]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.284]         }
[13:19:00.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.284]             base::sink(type = "output", split = FALSE)
[13:19:00.284]             base::close(...future.stdout)
[13:19:00.284]         }, add = TRUE)
[13:19:00.284]     }
[13:19:00.284]     ...future.frame <- base::sys.nframe()
[13:19:00.284]     ...future.conditions <- base::list()
[13:19:00.284]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.284]     if (FALSE) {
[13:19:00.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.284]     }
[13:19:00.284]     ...future.result <- base::tryCatch({
[13:19:00.284]         base::withCallingHandlers({
[13:19:00.284]             ...future.value <- base::withVisible(base::local({
[13:19:00.284]                 withCallingHandlers({
[13:19:00.284]                   {
[13:19:00.284]                     do.call(function(...) {
[13:19:00.284]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.284]                       if (!identical(...future.globals.maxSize.org, 
[13:19:00.284]                         ...future.globals.maxSize)) {
[13:19:00.284]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.284]                         on.exit(options(oopts), add = TRUE)
[13:19:00.284]                       }
[13:19:00.284]                       {
[13:19:00.284]                         lapply(seq_along(...future.elements_ii), 
[13:19:00.284]                           FUN = function(jj) {
[13:19:00.284]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.284]                             ...future.FUN(...future.X_jj, ...)
[13:19:00.284]                           })
[13:19:00.284]                       }
[13:19:00.284]                     }, args = future.call.arguments)
[13:19:00.284]                   }
[13:19:00.284]                 }, immediateCondition = function(cond) {
[13:19:00.284]                   save_rds <- function (object, pathname, ...) 
[13:19:00.284]                   {
[13:19:00.284]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:00.284]                     if (file_test("-f", pathname_tmp)) {
[13:19:00.284]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.284]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:00.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.284]                         fi_tmp[["mtime"]])
[13:19:00.284]                     }
[13:19:00.284]                     tryCatch({
[13:19:00.284]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:00.284]                     }, error = function(ex) {
[13:19:00.284]                       msg <- conditionMessage(ex)
[13:19:00.284]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.284]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:00.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.284]                         fi_tmp[["mtime"]], msg)
[13:19:00.284]                       ex$message <- msg
[13:19:00.284]                       stop(ex)
[13:19:00.284]                     })
[13:19:00.284]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:00.284]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:00.284]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:00.284]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.284]                       fi <- file.info(pathname)
[13:19:00.284]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:00.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.284]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:00.284]                         fi[["size"]], fi[["mtime"]])
[13:19:00.284]                       stop(msg)
[13:19:00.284]                     }
[13:19:00.284]                     invisible(pathname)
[13:19:00.284]                   }
[13:19:00.284]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:00.284]                     rootPath = tempdir()) 
[13:19:00.284]                   {
[13:19:00.284]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:00.284]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:00.284]                       tmpdir = path, fileext = ".rds")
[13:19:00.284]                     save_rds(obj, file)
[13:19:00.284]                   }
[13:19:00.284]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:19:00.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.284]                   {
[13:19:00.284]                     inherits <- base::inherits
[13:19:00.284]                     invokeRestart <- base::invokeRestart
[13:19:00.284]                     is.null <- base::is.null
[13:19:00.284]                     muffled <- FALSE
[13:19:00.284]                     if (inherits(cond, "message")) {
[13:19:00.284]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.284]                       if (muffled) 
[13:19:00.284]                         invokeRestart("muffleMessage")
[13:19:00.284]                     }
[13:19:00.284]                     else if (inherits(cond, "warning")) {
[13:19:00.284]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.284]                       if (muffled) 
[13:19:00.284]                         invokeRestart("muffleWarning")
[13:19:00.284]                     }
[13:19:00.284]                     else if (inherits(cond, "condition")) {
[13:19:00.284]                       if (!is.null(pattern)) {
[13:19:00.284]                         computeRestarts <- base::computeRestarts
[13:19:00.284]                         grepl <- base::grepl
[13:19:00.284]                         restarts <- computeRestarts(cond)
[13:19:00.284]                         for (restart in restarts) {
[13:19:00.284]                           name <- restart$name
[13:19:00.284]                           if (is.null(name)) 
[13:19:00.284]                             next
[13:19:00.284]                           if (!grepl(pattern, name)) 
[13:19:00.284]                             next
[13:19:00.284]                           invokeRestart(restart)
[13:19:00.284]                           muffled <- TRUE
[13:19:00.284]                           break
[13:19:00.284]                         }
[13:19:00.284]                       }
[13:19:00.284]                     }
[13:19:00.284]                     invisible(muffled)
[13:19:00.284]                   }
[13:19:00.284]                   muffleCondition(cond)
[13:19:00.284]                 })
[13:19:00.284]             }))
[13:19:00.284]             future::FutureResult(value = ...future.value$value, 
[13:19:00.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.284]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.284]                     ...future.globalenv.names))
[13:19:00.284]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.284]         }, condition = base::local({
[13:19:00.284]             c <- base::c
[13:19:00.284]             inherits <- base::inherits
[13:19:00.284]             invokeRestart <- base::invokeRestart
[13:19:00.284]             length <- base::length
[13:19:00.284]             list <- base::list
[13:19:00.284]             seq.int <- base::seq.int
[13:19:00.284]             signalCondition <- base::signalCondition
[13:19:00.284]             sys.calls <- base::sys.calls
[13:19:00.284]             `[[` <- base::`[[`
[13:19:00.284]             `+` <- base::`+`
[13:19:00.284]             `<<-` <- base::`<<-`
[13:19:00.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.284]                   3L)]
[13:19:00.284]             }
[13:19:00.284]             function(cond) {
[13:19:00.284]                 is_error <- inherits(cond, "error")
[13:19:00.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.284]                   NULL)
[13:19:00.284]                 if (is_error) {
[13:19:00.284]                   sessionInformation <- function() {
[13:19:00.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.284]                       search = base::search(), system = base::Sys.info())
[13:19:00.284]                   }
[13:19:00.284]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.284]                     cond$call), session = sessionInformation(), 
[13:19:00.284]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.284]                   signalCondition(cond)
[13:19:00.284]                 }
[13:19:00.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.284]                 "immediateCondition"))) {
[13:19:00.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.284]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.284]                   if (TRUE && !signal) {
[13:19:00.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.284]                     {
[13:19:00.284]                       inherits <- base::inherits
[13:19:00.284]                       invokeRestart <- base::invokeRestart
[13:19:00.284]                       is.null <- base::is.null
[13:19:00.284]                       muffled <- FALSE
[13:19:00.284]                       if (inherits(cond, "message")) {
[13:19:00.284]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.284]                         if (muffled) 
[13:19:00.284]                           invokeRestart("muffleMessage")
[13:19:00.284]                       }
[13:19:00.284]                       else if (inherits(cond, "warning")) {
[13:19:00.284]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.284]                         if (muffled) 
[13:19:00.284]                           invokeRestart("muffleWarning")
[13:19:00.284]                       }
[13:19:00.284]                       else if (inherits(cond, "condition")) {
[13:19:00.284]                         if (!is.null(pattern)) {
[13:19:00.284]                           computeRestarts <- base::computeRestarts
[13:19:00.284]                           grepl <- base::grepl
[13:19:00.284]                           restarts <- computeRestarts(cond)
[13:19:00.284]                           for (restart in restarts) {
[13:19:00.284]                             name <- restart$name
[13:19:00.284]                             if (is.null(name)) 
[13:19:00.284]                               next
[13:19:00.284]                             if (!grepl(pattern, name)) 
[13:19:00.284]                               next
[13:19:00.284]                             invokeRestart(restart)
[13:19:00.284]                             muffled <- TRUE
[13:19:00.284]                             break
[13:19:00.284]                           }
[13:19:00.284]                         }
[13:19:00.284]                       }
[13:19:00.284]                       invisible(muffled)
[13:19:00.284]                     }
[13:19:00.284]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.284]                   }
[13:19:00.284]                 }
[13:19:00.284]                 else {
[13:19:00.284]                   if (TRUE) {
[13:19:00.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.284]                     {
[13:19:00.284]                       inherits <- base::inherits
[13:19:00.284]                       invokeRestart <- base::invokeRestart
[13:19:00.284]                       is.null <- base::is.null
[13:19:00.284]                       muffled <- FALSE
[13:19:00.284]                       if (inherits(cond, "message")) {
[13:19:00.284]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.284]                         if (muffled) 
[13:19:00.284]                           invokeRestart("muffleMessage")
[13:19:00.284]                       }
[13:19:00.284]                       else if (inherits(cond, "warning")) {
[13:19:00.284]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.284]                         if (muffled) 
[13:19:00.284]                           invokeRestart("muffleWarning")
[13:19:00.284]                       }
[13:19:00.284]                       else if (inherits(cond, "condition")) {
[13:19:00.284]                         if (!is.null(pattern)) {
[13:19:00.284]                           computeRestarts <- base::computeRestarts
[13:19:00.284]                           grepl <- base::grepl
[13:19:00.284]                           restarts <- computeRestarts(cond)
[13:19:00.284]                           for (restart in restarts) {
[13:19:00.284]                             name <- restart$name
[13:19:00.284]                             if (is.null(name)) 
[13:19:00.284]                               next
[13:19:00.284]                             if (!grepl(pattern, name)) 
[13:19:00.284]                               next
[13:19:00.284]                             invokeRestart(restart)
[13:19:00.284]                             muffled <- TRUE
[13:19:00.284]                             break
[13:19:00.284]                           }
[13:19:00.284]                         }
[13:19:00.284]                       }
[13:19:00.284]                       invisible(muffled)
[13:19:00.284]                     }
[13:19:00.284]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.284]                   }
[13:19:00.284]                 }
[13:19:00.284]             }
[13:19:00.284]         }))
[13:19:00.284]     }, error = function(ex) {
[13:19:00.284]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.284]                 ...future.rng), started = ...future.startTime, 
[13:19:00.284]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.284]             version = "1.8"), class = "FutureResult")
[13:19:00.284]     }, finally = {
[13:19:00.284]         if (!identical(...future.workdir, getwd())) 
[13:19:00.284]             setwd(...future.workdir)
[13:19:00.284]         {
[13:19:00.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.284]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.284]             }
[13:19:00.284]             base::options(...future.oldOptions)
[13:19:00.284]             if (.Platform$OS.type == "windows") {
[13:19:00.284]                 old_names <- names(...future.oldEnvVars)
[13:19:00.284]                 envs <- base::Sys.getenv()
[13:19:00.284]                 names <- names(envs)
[13:19:00.284]                 common <- intersect(names, old_names)
[13:19:00.284]                 added <- setdiff(names, old_names)
[13:19:00.284]                 removed <- setdiff(old_names, names)
[13:19:00.284]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.284]                   envs[common]]
[13:19:00.284]                 NAMES <- toupper(changed)
[13:19:00.284]                 args <- list()
[13:19:00.284]                 for (kk in seq_along(NAMES)) {
[13:19:00.284]                   name <- changed[[kk]]
[13:19:00.284]                   NAME <- NAMES[[kk]]
[13:19:00.284]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.284]                     next
[13:19:00.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.284]                 }
[13:19:00.284]                 NAMES <- toupper(added)
[13:19:00.284]                 for (kk in seq_along(NAMES)) {
[13:19:00.284]                   name <- added[[kk]]
[13:19:00.284]                   NAME <- NAMES[[kk]]
[13:19:00.284]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.284]                     next
[13:19:00.284]                   args[[name]] <- ""
[13:19:00.284]                 }
[13:19:00.284]                 NAMES <- toupper(removed)
[13:19:00.284]                 for (kk in seq_along(NAMES)) {
[13:19:00.284]                   name <- removed[[kk]]
[13:19:00.284]                   NAME <- NAMES[[kk]]
[13:19:00.284]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.284]                     next
[13:19:00.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.284]                 }
[13:19:00.284]                 if (length(args) > 0) 
[13:19:00.284]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.284]             }
[13:19:00.284]             else {
[13:19:00.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.284]             }
[13:19:00.284]             {
[13:19:00.284]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.284]                   0L) {
[13:19:00.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.284]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.284]                   base::options(opts)
[13:19:00.284]                 }
[13:19:00.284]                 {
[13:19:00.284]                   {
[13:19:00.284]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.284]                     NULL
[13:19:00.284]                   }
[13:19:00.284]                   options(future.plan = NULL)
[13:19:00.284]                   if (is.na(NA_character_)) 
[13:19:00.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.284]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:00.284]                     envir = parent.frame()) 
[13:19:00.284]                   {
[13:19:00.284]                     default_workers <- missing(workers)
[13:19:00.284]                     if (is.function(workers)) 
[13:19:00.284]                       workers <- workers()
[13:19:00.284]                     workers <- structure(as.integer(workers), 
[13:19:00.284]                       class = class(workers))
[13:19:00.284]                     stop_if_not(is.finite(workers), workers >= 
[13:19:00.284]                       1L)
[13:19:00.284]                     if ((workers == 1L && !inherits(workers, 
[13:19:00.284]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:00.284]                       if (default_workers) 
[13:19:00.284]                         supportsMulticore(warn = TRUE)
[13:19:00.284]                       return(sequential(..., envir = envir))
[13:19:00.284]                     }
[13:19:00.284]                     oopts <- options(mc.cores = workers)
[13:19:00.284]                     on.exit(options(oopts))
[13:19:00.284]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:00.284]                       envir = envir)
[13:19:00.284]                     if (!future$lazy) 
[13:19:00.284]                       future <- run(future)
[13:19:00.284]                     invisible(future)
[13:19:00.284]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.284]                 }
[13:19:00.284]             }
[13:19:00.284]         }
[13:19:00.284]     })
[13:19:00.284]     if (TRUE) {
[13:19:00.284]         base::sink(type = "output", split = FALSE)
[13:19:00.284]         if (TRUE) {
[13:19:00.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.284]         }
[13:19:00.284]         else {
[13:19:00.284]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.284]         }
[13:19:00.284]         base::close(...future.stdout)
[13:19:00.284]         ...future.stdout <- NULL
[13:19:00.284]     }
[13:19:00.284]     ...future.result$conditions <- ...future.conditions
[13:19:00.284]     ...future.result$finished <- base::Sys.time()
[13:19:00.284]     ...future.result
[13:19:00.284] }
[13:19:00.287] assign_globals() ...
[13:19:00.287] List of 11
[13:19:00.287]  $ ...future.FUN            :function (x, ...)  
[13:19:00.287]  $ x_FUN                    :function (x)  
[13:19:00.287]  $ times                    : int 2
[13:19:00.287]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.287]  $ stop_if_not              :function (...)  
[13:19:00.287]  $ dim                      : NULL
[13:19:00.287]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:19:00.287]  $ future.call.arguments    : list()
[13:19:00.287]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.287]  $ ...future.elements_ii    :List of 1
[13:19:00.287]   ..$ : int 1
[13:19:00.287]  $ ...future.seeds_ii       : NULL
[13:19:00.287]  $ ...future.globals.maxSize: NULL
[13:19:00.287]  - attr(*, "where")=List of 11
[13:19:00.287]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ times                    :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:00.287]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:00.287]  - attr(*, "resolved")= logi FALSE
[13:19:00.287]  - attr(*, "total_size")= num 95128
[13:19:00.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.287]  - attr(*, "already-done")= logi TRUE
[13:19:00.294] - copied ‘...future.FUN’ to environment
[13:19:00.295] - copied ‘x_FUN’ to environment
[13:19:00.295] - copied ‘times’ to environment
[13:19:00.295] - copied ‘stopf’ to environment
[13:19:00.295] - copied ‘stop_if_not’ to environment
[13:19:00.295] - copied ‘dim’ to environment
[13:19:00.295] - copied ‘valid_types’ to environment
[13:19:00.295] - copied ‘future.call.arguments’ to environment
[13:19:00.295] - copied ‘...future.elements_ii’ to environment
[13:19:00.295] - copied ‘...future.seeds_ii’ to environment
[13:19:00.296] - copied ‘...future.globals.maxSize’ to environment
[13:19:00.296] assign_globals() ... done
[13:19:00.296] requestCore(): workers = 2
[13:19:00.298] MulticoreFuture started
[13:19:00.298] - Launch lazy future ... done
[13:19:00.299] run() for ‘MulticoreFuture’ ... done
[13:19:00.299] Created future:
[13:19:00.299] plan(): Setting new future strategy stack:
[13:19:00.300] List of future strategies:
[13:19:00.300] 1. sequential:
[13:19:00.300]    - args: function (..., envir = parent.frame())
[13:19:00.300]    - tweaked: FALSE
[13:19:00.300]    - call: NULL
[13:19:00.305] plan(): nbrOfWorkers() = 1
[13:19:00.307] plan(): Setting new future strategy stack:
[13:19:00.308] List of future strategies:
[13:19:00.308] 1. multicore:
[13:19:00.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:00.308]    - tweaked: FALSE
[13:19:00.308]    - call: plan(strategy)
[13:19:00.315] plan(): nbrOfWorkers() = 2
[13:19:00.299] MulticoreFuture:
[13:19:00.299] Label: ‘future_vapply-1’
[13:19:00.299] Expression:
[13:19:00.299] {
[13:19:00.299]     do.call(function(...) {
[13:19:00.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.299]             on.exit(options(oopts), add = TRUE)
[13:19:00.299]         }
[13:19:00.299]         {
[13:19:00.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.299]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.299]             })
[13:19:00.299]         }
[13:19:00.299]     }, args = future.call.arguments)
[13:19:00.299] }
[13:19:00.299] Lazy evaluation: FALSE
[13:19:00.299] Asynchronous evaluation: TRUE
[13:19:00.299] Local evaluation: TRUE
[13:19:00.299] Environment: R_GlobalEnv
[13:19:00.299] Capture standard output: TRUE
[13:19:00.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:00.299] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:00.299] Packages: 1 packages (‘future.apply’)
[13:19:00.299] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:00.299] Resolved: FALSE
[13:19:00.299] Value: <not collected>
[13:19:00.299] Conditions captured: <none>
[13:19:00.299] Early signaling: FALSE
[13:19:00.299] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:00.299] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.318] Chunk #1 of 2 ... DONE
[13:19:00.318] Chunk #2 of 2 ...
[13:19:00.319]  - Finding globals in 'X' for chunk #2 ...
[13:19:00.319] getGlobalsAndPackages() ...
[13:19:00.319] Searching for globals...
[13:19:00.320] 
[13:19:00.320] Searching for globals ... DONE
[13:19:00.320] - globals: [0] <none>
[13:19:00.320] getGlobalsAndPackages() ... DONE
[13:19:00.320]    + additional globals found: [n=0] 
[13:19:00.321]    + additional namespaces needed: [n=0] 
[13:19:00.321]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:00.321]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:00.321]  - seeds: <none>
[13:19:00.321] getGlobalsAndPackages() ...
[13:19:00.322] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.322] Resolving globals: FALSE
[13:19:00.322] Tweak future expression to call with '...' arguments ...
[13:19:00.322] {
[13:19:00.322]     do.call(function(...) {
[13:19:00.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.322]             on.exit(options(oopts), add = TRUE)
[13:19:00.322]         }
[13:19:00.322]         {
[13:19:00.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.322]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.322]             })
[13:19:00.322]         }
[13:19:00.322]     }, args = future.call.arguments)
[13:19:00.322] }
[13:19:00.323] Tweak future expression to call with '...' arguments ... DONE
[13:19:00.324] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:00.324] - packages: [1] ‘future.apply’
[13:19:00.324] getGlobalsAndPackages() ... DONE
[13:19:00.325] run() for ‘Future’ ...
[13:19:00.325] - state: ‘created’
[13:19:00.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:00.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:00.330]   - Field: ‘label’
[13:19:00.330]   - Field: ‘local’
[13:19:00.330]   - Field: ‘owner’
[13:19:00.331]   - Field: ‘envir’
[13:19:00.331]   - Field: ‘workers’
[13:19:00.331]   - Field: ‘packages’
[13:19:00.331]   - Field: ‘gc’
[13:19:00.331]   - Field: ‘job’
[13:19:00.331]   - Field: ‘conditions’
[13:19:00.332]   - Field: ‘expr’
[13:19:00.332]   - Field: ‘uuid’
[13:19:00.332]   - Field: ‘seed’
[13:19:00.332]   - Field: ‘version’
[13:19:00.332]   - Field: ‘result’
[13:19:00.333]   - Field: ‘asynchronous’
[13:19:00.333]   - Field: ‘calls’
[13:19:00.333]   - Field: ‘globals’
[13:19:00.333]   - Field: ‘stdout’
[13:19:00.333]   - Field: ‘earlySignal’
[13:19:00.333]   - Field: ‘lazy’
[13:19:00.334]   - Field: ‘state’
[13:19:00.334] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:00.334] - Launch lazy future ...
[13:19:00.334] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:00.335] Packages needed by future strategies (n = 0): <none>
[13:19:00.335] {
[13:19:00.335]     {
[13:19:00.335]         {
[13:19:00.335]             ...future.startTime <- base::Sys.time()
[13:19:00.335]             {
[13:19:00.335]                 {
[13:19:00.335]                   {
[13:19:00.335]                     {
[13:19:00.335]                       {
[13:19:00.335]                         base::local({
[13:19:00.335]                           has_future <- base::requireNamespace("future", 
[13:19:00.335]                             quietly = TRUE)
[13:19:00.335]                           if (has_future) {
[13:19:00.335]                             ns <- base::getNamespace("future")
[13:19:00.335]                             version <- ns[[".package"]][["version"]]
[13:19:00.335]                             if (is.null(version)) 
[13:19:00.335]                               version <- utils::packageVersion("future")
[13:19:00.335]                           }
[13:19:00.335]                           else {
[13:19:00.335]                             version <- NULL
[13:19:00.335]                           }
[13:19:00.335]                           if (!has_future || version < "1.8.0") {
[13:19:00.335]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.335]                               "", base::R.version$version.string), 
[13:19:00.335]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:00.335]                                 base::R.version$platform, 8 * 
[13:19:00.335]                                   base::.Machine$sizeof.pointer), 
[13:19:00.335]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.335]                                 "release", "version")], collapse = " "), 
[13:19:00.335]                               hostname = base::Sys.info()[["nodename"]])
[13:19:00.335]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.335]                               info)
[13:19:00.335]                             info <- base::paste(info, collapse = "; ")
[13:19:00.335]                             if (!has_future) {
[13:19:00.335]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.335]                                 info)
[13:19:00.335]                             }
[13:19:00.335]                             else {
[13:19:00.335]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.335]                                 info, version)
[13:19:00.335]                             }
[13:19:00.335]                             base::stop(msg)
[13:19:00.335]                           }
[13:19:00.335]                         })
[13:19:00.335]                       }
[13:19:00.335]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.335]                       base::options(mc.cores = 1L)
[13:19:00.335]                     }
[13:19:00.335]                     base::local({
[13:19:00.335]                       for (pkg in "future.apply") {
[13:19:00.335]                         base::loadNamespace(pkg)
[13:19:00.335]                         base::library(pkg, character.only = TRUE)
[13:19:00.335]                       }
[13:19:00.335]                     })
[13:19:00.335]                   }
[13:19:00.335]                   options(future.plan = NULL)
[13:19:00.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.335]                 }
[13:19:00.335]                 ...future.workdir <- getwd()
[13:19:00.335]             }
[13:19:00.335]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.335]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.335]         }
[13:19:00.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.335]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:00.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.335]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.335]             base::names(...future.oldOptions))
[13:19:00.335]     }
[13:19:00.335]     if (FALSE) {
[13:19:00.335]     }
[13:19:00.335]     else {
[13:19:00.335]         if (TRUE) {
[13:19:00.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.335]                 open = "w")
[13:19:00.335]         }
[13:19:00.335]         else {
[13:19:00.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.335]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.335]         }
[13:19:00.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.335]             base::sink(type = "output", split = FALSE)
[13:19:00.335]             base::close(...future.stdout)
[13:19:00.335]         }, add = TRUE)
[13:19:00.335]     }
[13:19:00.335]     ...future.frame <- base::sys.nframe()
[13:19:00.335]     ...future.conditions <- base::list()
[13:19:00.335]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.335]     if (FALSE) {
[13:19:00.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.335]     }
[13:19:00.335]     ...future.result <- base::tryCatch({
[13:19:00.335]         base::withCallingHandlers({
[13:19:00.335]             ...future.value <- base::withVisible(base::local({
[13:19:00.335]                 withCallingHandlers({
[13:19:00.335]                   {
[13:19:00.335]                     do.call(function(...) {
[13:19:00.335]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.335]                       if (!identical(...future.globals.maxSize.org, 
[13:19:00.335]                         ...future.globals.maxSize)) {
[13:19:00.335]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.335]                         on.exit(options(oopts), add = TRUE)
[13:19:00.335]                       }
[13:19:00.335]                       {
[13:19:00.335]                         lapply(seq_along(...future.elements_ii), 
[13:19:00.335]                           FUN = function(jj) {
[13:19:00.335]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.335]                             ...future.FUN(...future.X_jj, ...)
[13:19:00.335]                           })
[13:19:00.335]                       }
[13:19:00.335]                     }, args = future.call.arguments)
[13:19:00.335]                   }
[13:19:00.335]                 }, immediateCondition = function(cond) {
[13:19:00.335]                   save_rds <- function (object, pathname, ...) 
[13:19:00.335]                   {
[13:19:00.335]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:00.335]                     if (file_test("-f", pathname_tmp)) {
[13:19:00.335]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.335]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:00.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.335]                         fi_tmp[["mtime"]])
[13:19:00.335]                     }
[13:19:00.335]                     tryCatch({
[13:19:00.335]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:00.335]                     }, error = function(ex) {
[13:19:00.335]                       msg <- conditionMessage(ex)
[13:19:00.335]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.335]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:00.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.335]                         fi_tmp[["mtime"]], msg)
[13:19:00.335]                       ex$message <- msg
[13:19:00.335]                       stop(ex)
[13:19:00.335]                     })
[13:19:00.335]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:00.335]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:00.335]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:00.335]                       fi_tmp <- file.info(pathname_tmp)
[13:19:00.335]                       fi <- file.info(pathname)
[13:19:00.335]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:00.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:00.335]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:00.335]                         fi[["size"]], fi[["mtime"]])
[13:19:00.335]                       stop(msg)
[13:19:00.335]                     }
[13:19:00.335]                     invisible(pathname)
[13:19:00.335]                   }
[13:19:00.335]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:00.335]                     rootPath = tempdir()) 
[13:19:00.335]                   {
[13:19:00.335]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:00.335]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:00.335]                       tmpdir = path, fileext = ".rds")
[13:19:00.335]                     save_rds(obj, file)
[13:19:00.335]                   }
[13:19:00.335]                   saveImmediateCondition(cond, path = "/tmp/RtmpnoxQVa/.future/immediateConditions")
[13:19:00.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.335]                   {
[13:19:00.335]                     inherits <- base::inherits
[13:19:00.335]                     invokeRestart <- base::invokeRestart
[13:19:00.335]                     is.null <- base::is.null
[13:19:00.335]                     muffled <- FALSE
[13:19:00.335]                     if (inherits(cond, "message")) {
[13:19:00.335]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.335]                       if (muffled) 
[13:19:00.335]                         invokeRestart("muffleMessage")
[13:19:00.335]                     }
[13:19:00.335]                     else if (inherits(cond, "warning")) {
[13:19:00.335]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.335]                       if (muffled) 
[13:19:00.335]                         invokeRestart("muffleWarning")
[13:19:00.335]                     }
[13:19:00.335]                     else if (inherits(cond, "condition")) {
[13:19:00.335]                       if (!is.null(pattern)) {
[13:19:00.335]                         computeRestarts <- base::computeRestarts
[13:19:00.335]                         grepl <- base::grepl
[13:19:00.335]                         restarts <- computeRestarts(cond)
[13:19:00.335]                         for (restart in restarts) {
[13:19:00.335]                           name <- restart$name
[13:19:00.335]                           if (is.null(name)) 
[13:19:00.335]                             next
[13:19:00.335]                           if (!grepl(pattern, name)) 
[13:19:00.335]                             next
[13:19:00.335]                           invokeRestart(restart)
[13:19:00.335]                           muffled <- TRUE
[13:19:00.335]                           break
[13:19:00.335]                         }
[13:19:00.335]                       }
[13:19:00.335]                     }
[13:19:00.335]                     invisible(muffled)
[13:19:00.335]                   }
[13:19:00.335]                   muffleCondition(cond)
[13:19:00.335]                 })
[13:19:00.335]             }))
[13:19:00.335]             future::FutureResult(value = ...future.value$value, 
[13:19:00.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.335]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.335]                     ...future.globalenv.names))
[13:19:00.335]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.335]         }, condition = base::local({
[13:19:00.335]             c <- base::c
[13:19:00.335]             inherits <- base::inherits
[13:19:00.335]             invokeRestart <- base::invokeRestart
[13:19:00.335]             length <- base::length
[13:19:00.335]             list <- base::list
[13:19:00.335]             seq.int <- base::seq.int
[13:19:00.335]             signalCondition <- base::signalCondition
[13:19:00.335]             sys.calls <- base::sys.calls
[13:19:00.335]             `[[` <- base::`[[`
[13:19:00.335]             `+` <- base::`+`
[13:19:00.335]             `<<-` <- base::`<<-`
[13:19:00.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.335]                   3L)]
[13:19:00.335]             }
[13:19:00.335]             function(cond) {
[13:19:00.335]                 is_error <- inherits(cond, "error")
[13:19:00.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.335]                   NULL)
[13:19:00.335]                 if (is_error) {
[13:19:00.335]                   sessionInformation <- function() {
[13:19:00.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.335]                       search = base::search(), system = base::Sys.info())
[13:19:00.335]                   }
[13:19:00.335]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.335]                     cond$call), session = sessionInformation(), 
[13:19:00.335]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.335]                   signalCondition(cond)
[13:19:00.335]                 }
[13:19:00.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.335]                 "immediateCondition"))) {
[13:19:00.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.335]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.335]                   if (TRUE && !signal) {
[13:19:00.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.335]                     {
[13:19:00.335]                       inherits <- base::inherits
[13:19:00.335]                       invokeRestart <- base::invokeRestart
[13:19:00.335]                       is.null <- base::is.null
[13:19:00.335]                       muffled <- FALSE
[13:19:00.335]                       if (inherits(cond, "message")) {
[13:19:00.335]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.335]                         if (muffled) 
[13:19:00.335]                           invokeRestart("muffleMessage")
[13:19:00.335]                       }
[13:19:00.335]                       else if (inherits(cond, "warning")) {
[13:19:00.335]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.335]                         if (muffled) 
[13:19:00.335]                           invokeRestart("muffleWarning")
[13:19:00.335]                       }
[13:19:00.335]                       else if (inherits(cond, "condition")) {
[13:19:00.335]                         if (!is.null(pattern)) {
[13:19:00.335]                           computeRestarts <- base::computeRestarts
[13:19:00.335]                           grepl <- base::grepl
[13:19:00.335]                           restarts <- computeRestarts(cond)
[13:19:00.335]                           for (restart in restarts) {
[13:19:00.335]                             name <- restart$name
[13:19:00.335]                             if (is.null(name)) 
[13:19:00.335]                               next
[13:19:00.335]                             if (!grepl(pattern, name)) 
[13:19:00.335]                               next
[13:19:00.335]                             invokeRestart(restart)
[13:19:00.335]                             muffled <- TRUE
[13:19:00.335]                             break
[13:19:00.335]                           }
[13:19:00.335]                         }
[13:19:00.335]                       }
[13:19:00.335]                       invisible(muffled)
[13:19:00.335]                     }
[13:19:00.335]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.335]                   }
[13:19:00.335]                 }
[13:19:00.335]                 else {
[13:19:00.335]                   if (TRUE) {
[13:19:00.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.335]                     {
[13:19:00.335]                       inherits <- base::inherits
[13:19:00.335]                       invokeRestart <- base::invokeRestart
[13:19:00.335]                       is.null <- base::is.null
[13:19:00.335]                       muffled <- FALSE
[13:19:00.335]                       if (inherits(cond, "message")) {
[13:19:00.335]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.335]                         if (muffled) 
[13:19:00.335]                           invokeRestart("muffleMessage")
[13:19:00.335]                       }
[13:19:00.335]                       else if (inherits(cond, "warning")) {
[13:19:00.335]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.335]                         if (muffled) 
[13:19:00.335]                           invokeRestart("muffleWarning")
[13:19:00.335]                       }
[13:19:00.335]                       else if (inherits(cond, "condition")) {
[13:19:00.335]                         if (!is.null(pattern)) {
[13:19:00.335]                           computeRestarts <- base::computeRestarts
[13:19:00.335]                           grepl <- base::grepl
[13:19:00.335]                           restarts <- computeRestarts(cond)
[13:19:00.335]                           for (restart in restarts) {
[13:19:00.335]                             name <- restart$name
[13:19:00.335]                             if (is.null(name)) 
[13:19:00.335]                               next
[13:19:00.335]                             if (!grepl(pattern, name)) 
[13:19:00.335]                               next
[13:19:00.335]                             invokeRestart(restart)
[13:19:00.335]                             muffled <- TRUE
[13:19:00.335]                             break
[13:19:00.335]                           }
[13:19:00.335]                         }
[13:19:00.335]                       }
[13:19:00.335]                       invisible(muffled)
[13:19:00.335]                     }
[13:19:00.335]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.335]                   }
[13:19:00.335]                 }
[13:19:00.335]             }
[13:19:00.335]         }))
[13:19:00.335]     }, error = function(ex) {
[13:19:00.335]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.335]                 ...future.rng), started = ...future.startTime, 
[13:19:00.335]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.335]             version = "1.8"), class = "FutureResult")
[13:19:00.335]     }, finally = {
[13:19:00.335]         if (!identical(...future.workdir, getwd())) 
[13:19:00.335]             setwd(...future.workdir)
[13:19:00.335]         {
[13:19:00.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.335]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.335]             }
[13:19:00.335]             base::options(...future.oldOptions)
[13:19:00.335]             if (.Platform$OS.type == "windows") {
[13:19:00.335]                 old_names <- names(...future.oldEnvVars)
[13:19:00.335]                 envs <- base::Sys.getenv()
[13:19:00.335]                 names <- names(envs)
[13:19:00.335]                 common <- intersect(names, old_names)
[13:19:00.335]                 added <- setdiff(names, old_names)
[13:19:00.335]                 removed <- setdiff(old_names, names)
[13:19:00.335]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.335]                   envs[common]]
[13:19:00.335]                 NAMES <- toupper(changed)
[13:19:00.335]                 args <- list()
[13:19:00.335]                 for (kk in seq_along(NAMES)) {
[13:19:00.335]                   name <- changed[[kk]]
[13:19:00.335]                   NAME <- NAMES[[kk]]
[13:19:00.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.335]                     next
[13:19:00.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.335]                 }
[13:19:00.335]                 NAMES <- toupper(added)
[13:19:00.335]                 for (kk in seq_along(NAMES)) {
[13:19:00.335]                   name <- added[[kk]]
[13:19:00.335]                   NAME <- NAMES[[kk]]
[13:19:00.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.335]                     next
[13:19:00.335]                   args[[name]] <- ""
[13:19:00.335]                 }
[13:19:00.335]                 NAMES <- toupper(removed)
[13:19:00.335]                 for (kk in seq_along(NAMES)) {
[13:19:00.335]                   name <- removed[[kk]]
[13:19:00.335]                   NAME <- NAMES[[kk]]
[13:19:00.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.335]                     next
[13:19:00.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.335]                 }
[13:19:00.335]                 if (length(args) > 0) 
[13:19:00.335]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.335]             }
[13:19:00.335]             else {
[13:19:00.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.335]             }
[13:19:00.335]             {
[13:19:00.335]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.335]                   0L) {
[13:19:00.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.335]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.335]                   base::options(opts)
[13:19:00.335]                 }
[13:19:00.335]                 {
[13:19:00.335]                   {
[13:19:00.335]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.335]                     NULL
[13:19:00.335]                   }
[13:19:00.335]                   options(future.plan = NULL)
[13:19:00.335]                   if (is.na(NA_character_)) 
[13:19:00.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.335]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:00.335]                     envir = parent.frame()) 
[13:19:00.335]                   {
[13:19:00.335]                     default_workers <- missing(workers)
[13:19:00.335]                     if (is.function(workers)) 
[13:19:00.335]                       workers <- workers()
[13:19:00.335]                     workers <- structure(as.integer(workers), 
[13:19:00.335]                       class = class(workers))
[13:19:00.335]                     stop_if_not(is.finite(workers), workers >= 
[13:19:00.335]                       1L)
[13:19:00.335]                     if ((workers == 1L && !inherits(workers, 
[13:19:00.335]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:00.335]                       if (default_workers) 
[13:19:00.335]                         supportsMulticore(warn = TRUE)
[13:19:00.335]                       return(sequential(..., envir = envir))
[13:19:00.335]                     }
[13:19:00.335]                     oopts <- options(mc.cores = workers)
[13:19:00.335]                     on.exit(options(oopts))
[13:19:00.335]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:00.335]                       envir = envir)
[13:19:00.335]                     if (!future$lazy) 
[13:19:00.335]                       future <- run(future)
[13:19:00.335]                     invisible(future)
[13:19:00.335]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.335]                 }
[13:19:00.335]             }
[13:19:00.335]         }
[13:19:00.335]     })
[13:19:00.335]     if (TRUE) {
[13:19:00.335]         base::sink(type = "output", split = FALSE)
[13:19:00.335]         if (TRUE) {
[13:19:00.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.335]         }
[13:19:00.335]         else {
[13:19:00.335]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.335]         }
[13:19:00.335]         base::close(...future.stdout)
[13:19:00.335]         ...future.stdout <- NULL
[13:19:00.335]     }
[13:19:00.335]     ...future.result$conditions <- ...future.conditions
[13:19:00.335]     ...future.result$finished <- base::Sys.time()
[13:19:00.335]     ...future.result
[13:19:00.335] }
[13:19:00.338] assign_globals() ...
[13:19:00.339] List of 11
[13:19:00.339]  $ ...future.FUN            :function (x, ...)  
[13:19:00.339]  $ x_FUN                    :function (x)  
[13:19:00.339]  $ times                    : int 2
[13:19:00.339]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:00.339]  $ stop_if_not              :function (...)  
[13:19:00.339]  $ dim                      : NULL
[13:19:00.339]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:19:00.339]  $ future.call.arguments    : list()
[13:19:00.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:00.339]  $ ...future.elements_ii    :List of 2
[13:19:00.339]   ..$ : int 2
[13:19:00.339]   ..$ : int 3
[13:19:00.339]  $ ...future.seeds_ii       : NULL
[13:19:00.339]  $ ...future.globals.maxSize: NULL
[13:19:00.339]  - attr(*, "resolved")= logi FALSE
[13:19:00.339]  - attr(*, "total_size")= num 95128
[13:19:00.339]  - attr(*, "where")=List of 11
[13:19:00.339]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ times                    :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:00.339]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:00.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:00.339]  - attr(*, "already-done")= logi TRUE
[13:19:00.350] - copied ‘...future.FUN’ to environment
[13:19:00.351] - copied ‘x_FUN’ to environment
[13:19:00.351] - copied ‘times’ to environment
[13:19:00.351] - copied ‘stopf’ to environment
[13:19:00.351] - copied ‘stop_if_not’ to environment
[13:19:00.351] - copied ‘dim’ to environment
[13:19:00.351] - copied ‘valid_types’ to environment
[13:19:00.351] - copied ‘future.call.arguments’ to environment
[13:19:00.351] - copied ‘...future.elements_ii’ to environment
[13:19:00.352] - copied ‘...future.seeds_ii’ to environment
[13:19:00.352] - copied ‘...future.globals.maxSize’ to environment
[13:19:00.352] assign_globals() ... done
[13:19:00.352] requestCore(): workers = 2
[13:19:00.355] MulticoreFuture started
[13:19:00.355] - Launch lazy future ... done
[13:19:00.356] run() for ‘MulticoreFuture’ ... done
[13:19:00.356] Created future:
[13:19:00.356] plan(): Setting new future strategy stack:
[13:19:00.357] List of future strategies:
[13:19:00.357] 1. sequential:
[13:19:00.357]    - args: function (..., envir = parent.frame())
[13:19:00.357]    - tweaked: FALSE
[13:19:00.357]    - call: NULL
[13:19:00.358] plan(): nbrOfWorkers() = 1
[13:19:00.361] plan(): Setting new future strategy stack:
[13:19:00.361] List of future strategies:
[13:19:00.361] 1. multicore:
[13:19:00.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:00.361]    - tweaked: FALSE
[13:19:00.361]    - call: plan(strategy)
[13:19:00.368] plan(): nbrOfWorkers() = 2
[13:19:00.357] MulticoreFuture:
[13:19:00.357] Label: ‘future_vapply-2’
[13:19:00.357] Expression:
[13:19:00.357] {
[13:19:00.357]     do.call(function(...) {
[13:19:00.357]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:00.357]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:00.357]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:00.357]             on.exit(options(oopts), add = TRUE)
[13:19:00.357]         }
[13:19:00.357]         {
[13:19:00.357]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:00.357]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:00.357]                 ...future.FUN(...future.X_jj, ...)
[13:19:00.357]             })
[13:19:00.357]         }
[13:19:00.357]     }, args = future.call.arguments)
[13:19:00.357] }
[13:19:00.357] Lazy evaluation: FALSE
[13:19:00.357] Asynchronous evaluation: TRUE
[13:19:00.357] Local evaluation: TRUE
[13:19:00.357] Environment: R_GlobalEnv
[13:19:00.357] Capture standard output: TRUE
[13:19:00.357] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:00.357] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:00.357] Packages: 1 packages (‘future.apply’)
[13:19:00.357] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:00.357] Resolved: FALSE
[13:19:00.357] Value: <not collected>
[13:19:00.357] Conditions captured: <none>
[13:19:00.357] Early signaling: FALSE
[13:19:00.357] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:00.357] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:00.371] Chunk #2 of 2 ... DONE
[13:19:00.372] Launching 2 futures (chunks) ... DONE
[13:19:00.372] Resolving 2 futures (chunks) ...
[13:19:00.372] resolve() on list ...
[13:19:00.372]  recursive: 0
[13:19:00.372]  length: 2
[13:19:00.373] 
[13:19:00.373] Future #1
[13:19:00.382] signalConditions() ...
[13:19:00.382]  - include = ‘immediateCondition’
[13:19:00.382]  - exclude = 
[13:19:00.382]  - resignal = FALSE
[13:19:00.382]  - Number of conditions: 1
[13:19:00.382] signalConditions() ... done
[13:19:00.383] signalConditions() ...
[13:19:00.383]  - include = ‘immediateCondition’
[13:19:00.383]  - exclude = 
[13:19:00.383]  - resignal = FALSE
[13:19:00.383]  - Number of conditions: 1
[13:19:00.383] signalConditions() ... done
[13:19:00.383] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:00.384] - nx: 2
[13:19:00.384] - relay: TRUE
[13:19:00.384] - stdout: TRUE
[13:19:00.384] - signal: TRUE
[13:19:00.384] - resignal: FALSE
[13:19:00.384] - force: TRUE
[13:19:00.384] - relayed: [n=2] FALSE, FALSE
[13:19:00.384] - queued futures: [n=2] FALSE, FALSE
[13:19:00.385]  - until=1
[13:19:00.385]  - relaying element #1
[13:19:00.385] signalConditions() ...
[13:19:00.385]  - include = ‘immediateCondition’
[13:19:00.385]  - exclude = 
[13:19:00.385]  - resignal = FALSE
[13:19:00.385]  - Number of conditions: 1
[13:19:00.386] signalConditions() ... done
[13:19:00.386] signalConditions() ...
[13:19:00.386]  - include = ‘immediateCondition’
[13:19:00.386]  - exclude = 
[13:19:00.386]  - resignal = FALSE
[13:19:00.386]  - Number of conditions: 1
[13:19:00.386] signalConditions() ... done
[13:19:00.387] signalConditions() ...
[13:19:00.387]  - include = ‘condition’
[13:19:00.387]  - exclude = ‘immediateCondition’
[13:19:00.387]  - resignal = TRUE
[13:19:00.387]  - Number of conditions: 1
[13:19:00.387]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:19:00.387] signalConditions() ... done
[13:19:00.387] - relayed: [n=2] FALSE, FALSE
[13:19:00.388] - queued futures: [n=2] TRUE, FALSE
[13:19:00.388] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:00.388] plan(): Setting new future strategy stack:
[13:19:00.388] List of future strategies:
[13:19:00.388] 1. sequential:
[13:19:00.388]    - args: function (..., envir = parent.frame())
[13:19:00.388]    - tweaked: FALSE
[13:19:00.388]    - call: plan(sequential)
[13:19:00.389] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:19:00.389] plan(): Setting new future strategy stack:
[13:19:00.389] List of future strategies:
[13:19:00.389] 1. multisession:
[13:19:00.389]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:00.389]    - tweaked: FALSE
[13:19:00.389]    - call: plan(strategy)
[13:19:00.390] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:19:00.390] multisession:
[13:19:00.390] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:00.390] - tweaked: FALSE
[13:19:00.390] - call: plan(strategy)
[13:19:00.402] getGlobalsAndPackages() ...
[13:19:00.402] Not searching for globals
[13:19:00.402] - globals: [0] <none>
[13:19:00.402] getGlobalsAndPackages() ... DONE
[13:19:00.403] [local output] makeClusterPSOCK() ...
[13:19:00.456] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:19:00.461] [local output] Base port: 11605
[13:19:00.461] [local output] Getting setup options for 2 cluster nodes ...
[13:19:00.462] [local output]  - Node 1 of 2 ...
[13:19:00.462] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:00.463] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnoxQVa/worker.rank=1.parallelly.parent=79321.135d973b593f1.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpnoxQVa/worker.rank=1.parallelly.parent=79321.135d973b593f1.pid")'’
[13:19:00.654] - Possible to infer worker's PID: TRUE
[13:19:00.654] [local output] Rscript port: 11605

[13:19:00.655] [local output]  - Node 2 of 2 ...
[13:19:00.655] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:00.656] [local output] Rscript port: 11605

[13:19:00.656] [local output] Getting setup options for 2 cluster nodes ... done
[13:19:00.656] [local output]  - Parallel setup requested for some PSOCK nodes
[13:19:00.657] [local output] Setting up PSOCK nodes in parallel
[13:19:00.657] List of 36
[13:19:00.657]  $ worker          : chr "localhost"
[13:19:00.657]   ..- attr(*, "localhost")= logi TRUE
[13:19:00.657]  $ master          : chr "localhost"
[13:19:00.657]  $ port            : int 11605
[13:19:00.657]  $ connectTimeout  : num 120
[13:19:00.657]  $ timeout         : num 2592000
[13:19:00.657]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:19:00.657]  $ homogeneous     : logi TRUE
[13:19:00.657]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:19:00.657]  $ rscript_envs    : NULL
[13:19:00.657]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:00.657]  $ rscript_startup : NULL
[13:19:00.657]  $ rscript_sh      : chr "sh"
[13:19:00.657]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:00.657]  $ methods         : logi TRUE
[13:19:00.657]  $ socketOptions   : chr "no-delay"
[13:19:00.657]  $ useXDR          : logi FALSE
[13:19:00.657]  $ outfile         : chr "/dev/null"
[13:19:00.657]  $ renice          : int NA
[13:19:00.657]  $ rshcmd          : NULL
[13:19:00.657]  $ user            : chr(0) 
[13:19:00.657]  $ revtunnel       : logi FALSE
[13:19:00.657]  $ rshlogfile      : NULL
[13:19:00.657]  $ rshopts         : chr(0) 
[13:19:00.657]  $ rank            : int 1
[13:19:00.657]  $ manual          : logi FALSE
[13:19:00.657]  $ dryrun          : logi FALSE
[13:19:00.657]  $ quiet           : logi FALSE
[13:19:00.657]  $ setup_strategy  : chr "parallel"
[13:19:00.657]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:00.657]  $ pidfile         : chr "/tmp/RtmpnoxQVa/worker.rank=1.parallelly.parent=79321.135d973b593f1.pid"
[13:19:00.657]  $ rshcmd_label    : NULL
[13:19:00.657]  $ rsh_call        : NULL
[13:19:00.657]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:00.657]  $ localMachine    : logi TRUE
[13:19:00.657]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:19:00.657]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:19:00.657]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:19:00.657]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:19:00.657]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:19:00.657]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:19:00.657]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:19:00.657]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:19:00.657]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:19:00.657]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:19:00.657]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:19:00.657]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:19:00.657]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:19:00.657]  $ arguments       :List of 28
[13:19:00.657]   ..$ worker          : chr "localhost"
[13:19:00.657]   ..$ master          : NULL
[13:19:00.657]   ..$ port            : int 11605
[13:19:00.657]   ..$ connectTimeout  : num 120
[13:19:00.657]   ..$ timeout         : num 2592000
[13:19:00.657]   ..$ rscript         : NULL
[13:19:00.657]   ..$ homogeneous     : NULL
[13:19:00.657]   ..$ rscript_args    : NULL
[13:19:00.657]   ..$ rscript_envs    : NULL
[13:19:00.657]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:00.657]   ..$ rscript_startup : NULL
[13:19:00.657]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:19:00.657]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:00.657]   ..$ methods         : logi TRUE
[13:19:00.657]   ..$ socketOptions   : chr "no-delay"
[13:19:00.657]   ..$ useXDR          : logi FALSE
[13:19:00.657]   ..$ outfile         : chr "/dev/null"
[13:19:00.657]   ..$ renice          : int NA
[13:19:00.657]   ..$ rshcmd          : NULL
[13:19:00.657]   ..$ user            : NULL
[13:19:00.657]   ..$ revtunnel       : logi NA
[13:19:00.657]   ..$ rshlogfile      : NULL
[13:19:00.657]   ..$ rshopts         : NULL
[13:19:00.657]   ..$ rank            : int 1
[13:19:00.657]   ..$ manual          : logi FALSE
[13:19:00.657]   ..$ dryrun          : logi FALSE
[13:19:00.657]   ..$ quiet           : logi FALSE
[13:19:00.657]   ..$ setup_strategy  : chr "parallel"
[13:19:00.657]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:19:00.675] [local output] System call to launch all workers:
[13:19:00.675] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnoxQVa/worker.rank=1.parallelly.parent=79321.135d973b593f1.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11605 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:19:00.676] [local output] Starting PSOCK main server
[13:19:00.677] [local output] Workers launched
[13:19:00.677] [local output] Waiting for workers to connect back
[13:19:00.678]  - [local output] 0 workers out of 2 ready
[13:19:00.920]  - [local output] 0 workers out of 2 ready
[13:19:00.920]  - [local output] 1 workers out of 2 ready
[13:19:00.930]  - [local output] 1 workers out of 2 ready
[13:19:00.931]  - [local output] 2 workers out of 2 ready
[13:19:00.931] [local output] Launching of workers completed
[13:19:00.931] [local output] Collecting session information from workers
[13:19:00.932] [local output]  - Worker #1 of 2
[13:19:00.932] [local output]  - Worker #2 of 2
[13:19:00.932] [local output] makeClusterPSOCK() ... done
[13:19:00.945] Packages needed by the future expression (n = 0): <none>
[13:19:00.945] Packages needed by future strategies (n = 0): <none>
[13:19:00.945] {
[13:19:00.945]     {
[13:19:00.945]         {
[13:19:00.945]             ...future.startTime <- base::Sys.time()
[13:19:00.945]             {
[13:19:00.945]                 {
[13:19:00.945]                   {
[13:19:00.945]                     {
[13:19:00.945]                       base::local({
[13:19:00.945]                         has_future <- base::requireNamespace("future", 
[13:19:00.945]                           quietly = TRUE)
[13:19:00.945]                         if (has_future) {
[13:19:00.945]                           ns <- base::getNamespace("future")
[13:19:00.945]                           version <- ns[[".package"]][["version"]]
[13:19:00.945]                           if (is.null(version)) 
[13:19:00.945]                             version <- utils::packageVersion("future")
[13:19:00.945]                         }
[13:19:00.945]                         else {
[13:19:00.945]                           version <- NULL
[13:19:00.945]                         }
[13:19:00.945]                         if (!has_future || version < "1.8.0") {
[13:19:00.945]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:00.945]                             "", base::R.version$version.string), 
[13:19:00.945]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:00.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:00.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:00.945]                               "release", "version")], collapse = " "), 
[13:19:00.945]                             hostname = base::Sys.info()[["nodename"]])
[13:19:00.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:00.945]                             info)
[13:19:00.945]                           info <- base::paste(info, collapse = "; ")
[13:19:00.945]                           if (!has_future) {
[13:19:00.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:00.945]                               info)
[13:19:00.945]                           }
[13:19:00.945]                           else {
[13:19:00.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:00.945]                               info, version)
[13:19:00.945]                           }
[13:19:00.945]                           base::stop(msg)
[13:19:00.945]                         }
[13:19:00.945]                       })
[13:19:00.945]                     }
[13:19:00.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:00.945]                     base::options(mc.cores = 1L)
[13:19:00.945]                   }
[13:19:00.945]                   options(future.plan = NULL)
[13:19:00.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:00.945]                 }
[13:19:00.945]                 ...future.workdir <- getwd()
[13:19:00.945]             }
[13:19:00.945]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:00.945]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:00.945]         }
[13:19:00.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:00.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:00.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:00.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:00.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:00.945]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:00.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:00.945]             base::names(...future.oldOptions))
[13:19:00.945]     }
[13:19:00.945]     if (FALSE) {
[13:19:00.945]     }
[13:19:00.945]     else {
[13:19:00.945]         if (TRUE) {
[13:19:00.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:00.945]                 open = "w")
[13:19:00.945]         }
[13:19:00.945]         else {
[13:19:00.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:00.945]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:00.945]         }
[13:19:00.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:00.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:00.945]             base::sink(type = "output", split = FALSE)
[13:19:00.945]             base::close(...future.stdout)
[13:19:00.945]         }, add = TRUE)
[13:19:00.945]     }
[13:19:00.945]     ...future.frame <- base::sys.nframe()
[13:19:00.945]     ...future.conditions <- base::list()
[13:19:00.945]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:00.945]     if (FALSE) {
[13:19:00.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:00.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:00.945]     }
[13:19:00.945]     ...future.result <- base::tryCatch({
[13:19:00.945]         base::withCallingHandlers({
[13:19:00.945]             ...future.value <- base::withVisible(base::local({
[13:19:00.945]                 ...future.makeSendCondition <- local({
[13:19:00.945]                   sendCondition <- NULL
[13:19:00.945]                   function(frame = 1L) {
[13:19:00.945]                     if (is.function(sendCondition)) 
[13:19:00.945]                       return(sendCondition)
[13:19:00.945]                     ns <- getNamespace("parallel")
[13:19:00.945]                     if (exists("sendData", mode = "function", 
[13:19:00.945]                       envir = ns)) {
[13:19:00.945]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:00.945]                         envir = ns)
[13:19:00.945]                       envir <- sys.frame(frame)
[13:19:00.945]                       master <- NULL
[13:19:00.945]                       while (!identical(envir, .GlobalEnv) && 
[13:19:00.945]                         !identical(envir, emptyenv())) {
[13:19:00.945]                         if (exists("master", mode = "list", envir = envir, 
[13:19:00.945]                           inherits = FALSE)) {
[13:19:00.945]                           master <- get("master", mode = "list", 
[13:19:00.945]                             envir = envir, inherits = FALSE)
[13:19:00.945]                           if (inherits(master, c("SOCKnode", 
[13:19:00.945]                             "SOCK0node"))) {
[13:19:00.945]                             sendCondition <<- function(cond) {
[13:19:00.945]                               data <- list(type = "VALUE", value = cond, 
[13:19:00.945]                                 success = TRUE)
[13:19:00.945]                               parallel_sendData(master, data)
[13:19:00.945]                             }
[13:19:00.945]                             return(sendCondition)
[13:19:00.945]                           }
[13:19:00.945]                         }
[13:19:00.945]                         frame <- frame + 1L
[13:19:00.945]                         envir <- sys.frame(frame)
[13:19:00.945]                       }
[13:19:00.945]                     }
[13:19:00.945]                     sendCondition <<- function(cond) NULL
[13:19:00.945]                   }
[13:19:00.945]                 })
[13:19:00.945]                 withCallingHandlers({
[13:19:00.945]                   NA
[13:19:00.945]                 }, immediateCondition = function(cond) {
[13:19:00.945]                   sendCondition <- ...future.makeSendCondition()
[13:19:00.945]                   sendCondition(cond)
[13:19:00.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.945]                   {
[13:19:00.945]                     inherits <- base::inherits
[13:19:00.945]                     invokeRestart <- base::invokeRestart
[13:19:00.945]                     is.null <- base::is.null
[13:19:00.945]                     muffled <- FALSE
[13:19:00.945]                     if (inherits(cond, "message")) {
[13:19:00.945]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:00.945]                       if (muffled) 
[13:19:00.945]                         invokeRestart("muffleMessage")
[13:19:00.945]                     }
[13:19:00.945]                     else if (inherits(cond, "warning")) {
[13:19:00.945]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:00.945]                       if (muffled) 
[13:19:00.945]                         invokeRestart("muffleWarning")
[13:19:00.945]                     }
[13:19:00.945]                     else if (inherits(cond, "condition")) {
[13:19:00.945]                       if (!is.null(pattern)) {
[13:19:00.945]                         computeRestarts <- base::computeRestarts
[13:19:00.945]                         grepl <- base::grepl
[13:19:00.945]                         restarts <- computeRestarts(cond)
[13:19:00.945]                         for (restart in restarts) {
[13:19:00.945]                           name <- restart$name
[13:19:00.945]                           if (is.null(name)) 
[13:19:00.945]                             next
[13:19:00.945]                           if (!grepl(pattern, name)) 
[13:19:00.945]                             next
[13:19:00.945]                           invokeRestart(restart)
[13:19:00.945]                           muffled <- TRUE
[13:19:00.945]                           break
[13:19:00.945]                         }
[13:19:00.945]                       }
[13:19:00.945]                     }
[13:19:00.945]                     invisible(muffled)
[13:19:00.945]                   }
[13:19:00.945]                   muffleCondition(cond)
[13:19:00.945]                 })
[13:19:00.945]             }))
[13:19:00.945]             future::FutureResult(value = ...future.value$value, 
[13:19:00.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.945]                   ...future.rng), globalenv = if (FALSE) 
[13:19:00.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:00.945]                     ...future.globalenv.names))
[13:19:00.945]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:00.945]         }, condition = base::local({
[13:19:00.945]             c <- base::c
[13:19:00.945]             inherits <- base::inherits
[13:19:00.945]             invokeRestart <- base::invokeRestart
[13:19:00.945]             length <- base::length
[13:19:00.945]             list <- base::list
[13:19:00.945]             seq.int <- base::seq.int
[13:19:00.945]             signalCondition <- base::signalCondition
[13:19:00.945]             sys.calls <- base::sys.calls
[13:19:00.945]             `[[` <- base::`[[`
[13:19:00.945]             `+` <- base::`+`
[13:19:00.945]             `<<-` <- base::`<<-`
[13:19:00.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:00.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:00.945]                   3L)]
[13:19:00.945]             }
[13:19:00.945]             function(cond) {
[13:19:00.945]                 is_error <- inherits(cond, "error")
[13:19:00.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:00.945]                   NULL)
[13:19:00.945]                 if (is_error) {
[13:19:00.945]                   sessionInformation <- function() {
[13:19:00.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:00.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:00.945]                       search = base::search(), system = base::Sys.info())
[13:19:00.945]                   }
[13:19:00.945]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:00.945]                     cond$call), session = sessionInformation(), 
[13:19:00.945]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:00.945]                   signalCondition(cond)
[13:19:00.945]                 }
[13:19:00.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:00.945]                 "immediateCondition"))) {
[13:19:00.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:00.945]                   ...future.conditions[[length(...future.conditions) + 
[13:19:00.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:00.945]                   if (TRUE && !signal) {
[13:19:00.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.945]                     {
[13:19:00.945]                       inherits <- base::inherits
[13:19:00.945]                       invokeRestart <- base::invokeRestart
[13:19:00.945]                       is.null <- base::is.null
[13:19:00.945]                       muffled <- FALSE
[13:19:00.945]                       if (inherits(cond, "message")) {
[13:19:00.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.945]                         if (muffled) 
[13:19:00.945]                           invokeRestart("muffleMessage")
[13:19:00.945]                       }
[13:19:00.945]                       else if (inherits(cond, "warning")) {
[13:19:00.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.945]                         if (muffled) 
[13:19:00.945]                           invokeRestart("muffleWarning")
[13:19:00.945]                       }
[13:19:00.945]                       else if (inherits(cond, "condition")) {
[13:19:00.945]                         if (!is.null(pattern)) {
[13:19:00.945]                           computeRestarts <- base::computeRestarts
[13:19:00.945]                           grepl <- base::grepl
[13:19:00.945]                           restarts <- computeRestarts(cond)
[13:19:00.945]                           for (restart in restarts) {
[13:19:00.945]                             name <- restart$name
[13:19:00.945]                             if (is.null(name)) 
[13:19:00.945]                               next
[13:19:00.945]                             if (!grepl(pattern, name)) 
[13:19:00.945]                               next
[13:19:00.945]                             invokeRestart(restart)
[13:19:00.945]                             muffled <- TRUE
[13:19:00.945]                             break
[13:19:00.945]                           }
[13:19:00.945]                         }
[13:19:00.945]                       }
[13:19:00.945]                       invisible(muffled)
[13:19:00.945]                     }
[13:19:00.945]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.945]                   }
[13:19:00.945]                 }
[13:19:00.945]                 else {
[13:19:00.945]                   if (TRUE) {
[13:19:00.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:00.945]                     {
[13:19:00.945]                       inherits <- base::inherits
[13:19:00.945]                       invokeRestart <- base::invokeRestart
[13:19:00.945]                       is.null <- base::is.null
[13:19:00.945]                       muffled <- FALSE
[13:19:00.945]                       if (inherits(cond, "message")) {
[13:19:00.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:00.945]                         if (muffled) 
[13:19:00.945]                           invokeRestart("muffleMessage")
[13:19:00.945]                       }
[13:19:00.945]                       else if (inherits(cond, "warning")) {
[13:19:00.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:00.945]                         if (muffled) 
[13:19:00.945]                           invokeRestart("muffleWarning")
[13:19:00.945]                       }
[13:19:00.945]                       else if (inherits(cond, "condition")) {
[13:19:00.945]                         if (!is.null(pattern)) {
[13:19:00.945]                           computeRestarts <- base::computeRestarts
[13:19:00.945]                           grepl <- base::grepl
[13:19:00.945]                           restarts <- computeRestarts(cond)
[13:19:00.945]                           for (restart in restarts) {
[13:19:00.945]                             name <- restart$name
[13:19:00.945]                             if (is.null(name)) 
[13:19:00.945]                               next
[13:19:00.945]                             if (!grepl(pattern, name)) 
[13:19:00.945]                               next
[13:19:00.945]                             invokeRestart(restart)
[13:19:00.945]                             muffled <- TRUE
[13:19:00.945]                             break
[13:19:00.945]                           }
[13:19:00.945]                         }
[13:19:00.945]                       }
[13:19:00.945]                       invisible(muffled)
[13:19:00.945]                     }
[13:19:00.945]                     muffleCondition(cond, pattern = "^muffle")
[13:19:00.945]                   }
[13:19:00.945]                 }
[13:19:00.945]             }
[13:19:00.945]         }))
[13:19:00.945]     }, error = function(ex) {
[13:19:00.945]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:00.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:00.945]                 ...future.rng), started = ...future.startTime, 
[13:19:00.945]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:00.945]             version = "1.8"), class = "FutureResult")
[13:19:00.945]     }, finally = {
[13:19:00.945]         if (!identical(...future.workdir, getwd())) 
[13:19:00.945]             setwd(...future.workdir)
[13:19:00.945]         {
[13:19:00.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:00.945]                 ...future.oldOptions$nwarnings <- NULL
[13:19:00.945]             }
[13:19:00.945]             base::options(...future.oldOptions)
[13:19:00.945]             if (.Platform$OS.type == "windows") {
[13:19:00.945]                 old_names <- names(...future.oldEnvVars)
[13:19:00.945]                 envs <- base::Sys.getenv()
[13:19:00.945]                 names <- names(envs)
[13:19:00.945]                 common <- intersect(names, old_names)
[13:19:00.945]                 added <- setdiff(names, old_names)
[13:19:00.945]                 removed <- setdiff(old_names, names)
[13:19:00.945]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:00.945]                   envs[common]]
[13:19:00.945]                 NAMES <- toupper(changed)
[13:19:00.945]                 args <- list()
[13:19:00.945]                 for (kk in seq_along(NAMES)) {
[13:19:00.945]                   name <- changed[[kk]]
[13:19:00.945]                   NAME <- NAMES[[kk]]
[13:19:00.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.945]                     next
[13:19:00.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.945]                 }
[13:19:00.945]                 NAMES <- toupper(added)
[13:19:00.945]                 for (kk in seq_along(NAMES)) {
[13:19:00.945]                   name <- added[[kk]]
[13:19:00.945]                   NAME <- NAMES[[kk]]
[13:19:00.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.945]                     next
[13:19:00.945]                   args[[name]] <- ""
[13:19:00.945]                 }
[13:19:00.945]                 NAMES <- toupper(removed)
[13:19:00.945]                 for (kk in seq_along(NAMES)) {
[13:19:00.945]                   name <- removed[[kk]]
[13:19:00.945]                   NAME <- NAMES[[kk]]
[13:19:00.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:00.945]                     next
[13:19:00.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:00.945]                 }
[13:19:00.945]                 if (length(args) > 0) 
[13:19:00.945]                   base::do.call(base::Sys.setenv, args = args)
[13:19:00.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:00.945]             }
[13:19:00.945]             else {
[13:19:00.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:00.945]             }
[13:19:00.945]             {
[13:19:00.945]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:00.945]                   0L) {
[13:19:00.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:00.945]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:00.945]                   base::options(opts)
[13:19:00.945]                 }
[13:19:00.945]                 {
[13:19:00.945]                   {
[13:19:00.945]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:00.945]                     NULL
[13:19:00.945]                   }
[13:19:00.945]                   options(future.plan = NULL)
[13:19:00.945]                   if (is.na(NA_character_)) 
[13:19:00.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:00.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:00.945]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:00.945]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:00.945]                     envir = parent.frame()) 
[13:19:00.945]                   {
[13:19:00.945]                     if (is.function(workers)) 
[13:19:00.945]                       workers <- workers()
[13:19:00.945]                     workers <- structure(as.integer(workers), 
[13:19:00.945]                       class = class(workers))
[13:19:00.945]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:00.945]                       workers >= 1)
[13:19:00.945]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:00.945]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:00.945]                     }
[13:19:00.945]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:00.945]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:00.945]                       envir = envir)
[13:19:00.945]                     if (!future$lazy) 
[13:19:00.945]                       future <- run(future)
[13:19:00.945]                     invisible(future)
[13:19:00.945]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:00.945]                 }
[13:19:00.945]             }
[13:19:00.945]         }
[13:19:00.945]     })
[13:19:00.945]     if (TRUE) {
[13:19:00.945]         base::sink(type = "output", split = FALSE)
[13:19:00.945]         if (TRUE) {
[13:19:00.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:00.945]         }
[13:19:00.945]         else {
[13:19:00.945]             ...future.result["stdout"] <- base::list(NULL)
[13:19:00.945]         }
[13:19:00.945]         base::close(...future.stdout)
[13:19:00.945]         ...future.stdout <- NULL
[13:19:00.945]     }
[13:19:00.945]     ...future.result$conditions <- ...future.conditions
[13:19:00.945]     ...future.result$finished <- base::Sys.time()
[13:19:00.945]     ...future.result
[13:19:00.945] }
[13:19:01.018] MultisessionFuture started
[13:19:01.018] result() for ClusterFuture ...
[13:19:01.019] receiveMessageFromWorker() for ClusterFuture ...
[13:19:01.019] - Validating connection of MultisessionFuture
[13:19:01.051] - received message: FutureResult
[13:19:01.051] - Received FutureResult
[13:19:01.051] - Erased future from FutureRegistry
[13:19:01.051] result() for ClusterFuture ...
[13:19:01.052] - result already collected: FutureResult
[13:19:01.052] result() for ClusterFuture ... done
[13:19:01.052] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:01.052] result() for ClusterFuture ... done
[13:19:01.052] result() for ClusterFuture ...
[13:19:01.052] - result already collected: FutureResult
[13:19:01.052] result() for ClusterFuture ... done
[13:19:01.052] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:19:01.056] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:19:01.059] future_lapply() ...
[13:19:01.065] Number of chunks: 2
[13:19:01.065] getGlobalsAndPackagesXApply() ...
[13:19:01.065]  - future.globals: TRUE
[13:19:01.065] getGlobalsAndPackages() ...
[13:19:01.065] Searching for globals...
[13:19:01.069] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:01.070] Searching for globals ... DONE
[13:19:01.070] Resolving globals: FALSE
[13:19:01.071] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:19:01.071] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:01.071] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:01.072] - packages: [1] ‘future.apply’
[13:19:01.072] getGlobalsAndPackages() ... DONE
[13:19:01.072]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:01.072]  - needed namespaces: [n=1] ‘future.apply’
[13:19:01.072] Finding globals ... DONE
[13:19:01.072]  - use_args: TRUE
[13:19:01.072]  - Getting '...' globals ...
[13:19:01.073] resolve() on list ...
[13:19:01.073]  recursive: 0
[13:19:01.073]  length: 1
[13:19:01.073]  elements: ‘...’
[13:19:01.073]  length: 0 (resolved future 1)
[13:19:01.073] resolve() on list ... DONE
[13:19:01.073]    - '...' content: [n=0] 
[13:19:01.074] List of 1
[13:19:01.074]  $ ...: list()
[13:19:01.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:01.074]  - attr(*, "where")=List of 1
[13:19:01.074]   ..$ ...:<environment: 0x555f7cc79ca8> 
[13:19:01.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:01.074]  - attr(*, "resolved")= logi TRUE
[13:19:01.074]  - attr(*, "total_size")= num NA
[13:19:01.077]  - Getting '...' globals ... DONE
[13:19:01.077] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:01.077] List of 8
[13:19:01.077]  $ ...future.FUN:function (x, ...)  
[13:19:01.077]  $ x_FUN        :function (x)  
[13:19:01.077]  $ times        : int 1
[13:19:01.077]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:01.077]  $ stop_if_not  :function (...)  
[13:19:01.077]  $ dim          : NULL
[13:19:01.077]  $ valid_types  : chr "character"
[13:19:01.077]  $ ...          : list()
[13:19:01.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:01.077]  - attr(*, "where")=List of 8
[13:19:01.077]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:01.077]   ..$ ...          :<environment: 0x555f7cc79ca8> 
[13:19:01.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:01.077]  - attr(*, "resolved")= logi FALSE
[13:19:01.077]  - attr(*, "total_size")= num 94208
[13:19:01.084] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:01.084] getGlobalsAndPackagesXApply() ... DONE
[13:19:01.084] Number of futures (= number of chunks): 2
[13:19:01.084] Launching 2 futures (chunks) ...
[13:19:01.085] Chunk #1 of 2 ...
[13:19:01.085]  - Finding globals in 'X' for chunk #1 ...
[13:19:01.085] getGlobalsAndPackages() ...
[13:19:01.085] Searching for globals...
[13:19:01.085] 
[13:19:01.085] Searching for globals ... DONE
[13:19:01.086] - globals: [0] <none>
[13:19:01.086] getGlobalsAndPackages() ... DONE
[13:19:01.086]    + additional globals found: [n=0] 
[13:19:01.086]    + additional namespaces needed: [n=0] 
[13:19:01.086]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:01.086]  - seeds: <none>
[13:19:01.086] getGlobalsAndPackages() ...
[13:19:01.086] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.086] Resolving globals: FALSE
[13:19:01.087] Tweak future expression to call with '...' arguments ...
[13:19:01.087] {
[13:19:01.087]     do.call(function(...) {
[13:19:01.087]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.087]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.087]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.087]             on.exit(options(oopts), add = TRUE)
[13:19:01.087]         }
[13:19:01.087]         {
[13:19:01.087]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.087]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.087]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.087]             })
[13:19:01.087]         }
[13:19:01.087]     }, args = future.call.arguments)
[13:19:01.087] }
[13:19:01.087] Tweak future expression to call with '...' arguments ... DONE
[13:19:01.088] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.088] - packages: [1] ‘future.apply’
[13:19:01.088] getGlobalsAndPackages() ... DONE
[13:19:01.088] run() for ‘Future’ ...
[13:19:01.088] - state: ‘created’
[13:19:01.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:01.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:01.105]   - Field: ‘node’
[13:19:01.105]   - Field: ‘label’
[13:19:01.105]   - Field: ‘local’
[13:19:01.105]   - Field: ‘owner’
[13:19:01.105]   - Field: ‘envir’
[13:19:01.105]   - Field: ‘workers’
[13:19:01.105]   - Field: ‘packages’
[13:19:01.106]   - Field: ‘gc’
[13:19:01.106]   - Field: ‘conditions’
[13:19:01.106]   - Field: ‘persistent’
[13:19:01.106]   - Field: ‘expr’
[13:19:01.106]   - Field: ‘uuid’
[13:19:01.106]   - Field: ‘seed’
[13:19:01.106]   - Field: ‘version’
[13:19:01.106]   - Field: ‘result’
[13:19:01.106]   - Field: ‘asynchronous’
[13:19:01.107]   - Field: ‘calls’
[13:19:01.107]   - Field: ‘globals’
[13:19:01.107]   - Field: ‘stdout’
[13:19:01.107]   - Field: ‘earlySignal’
[13:19:01.107]   - Field: ‘lazy’
[13:19:01.107]   - Field: ‘state’
[13:19:01.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:01.107] - Launch lazy future ...
[13:19:01.108] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:01.108] Packages needed by future strategies (n = 0): <none>
[13:19:01.108] {
[13:19:01.108]     {
[13:19:01.108]         {
[13:19:01.108]             ...future.startTime <- base::Sys.time()
[13:19:01.108]             {
[13:19:01.108]                 {
[13:19:01.108]                   {
[13:19:01.108]                     {
[13:19:01.108]                       {
[13:19:01.108]                         base::local({
[13:19:01.108]                           has_future <- base::requireNamespace("future", 
[13:19:01.108]                             quietly = TRUE)
[13:19:01.108]                           if (has_future) {
[13:19:01.108]                             ns <- base::getNamespace("future")
[13:19:01.108]                             version <- ns[[".package"]][["version"]]
[13:19:01.108]                             if (is.null(version)) 
[13:19:01.108]                               version <- utils::packageVersion("future")
[13:19:01.108]                           }
[13:19:01.108]                           else {
[13:19:01.108]                             version <- NULL
[13:19:01.108]                           }
[13:19:01.108]                           if (!has_future || version < "1.8.0") {
[13:19:01.108]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:01.108]                               "", base::R.version$version.string), 
[13:19:01.108]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:01.108]                                 base::R.version$platform, 8 * 
[13:19:01.108]                                   base::.Machine$sizeof.pointer), 
[13:19:01.108]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:01.108]                                 "release", "version")], collapse = " "), 
[13:19:01.108]                               hostname = base::Sys.info()[["nodename"]])
[13:19:01.108]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:01.108]                               info)
[13:19:01.108]                             info <- base::paste(info, collapse = "; ")
[13:19:01.108]                             if (!has_future) {
[13:19:01.108]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:01.108]                                 info)
[13:19:01.108]                             }
[13:19:01.108]                             else {
[13:19:01.108]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:01.108]                                 info, version)
[13:19:01.108]                             }
[13:19:01.108]                             base::stop(msg)
[13:19:01.108]                           }
[13:19:01.108]                         })
[13:19:01.108]                       }
[13:19:01.108]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:01.108]                       base::options(mc.cores = 1L)
[13:19:01.108]                     }
[13:19:01.108]                     base::local({
[13:19:01.108]                       for (pkg in "future.apply") {
[13:19:01.108]                         base::loadNamespace(pkg)
[13:19:01.108]                         base::library(pkg, character.only = TRUE)
[13:19:01.108]                       }
[13:19:01.108]                     })
[13:19:01.108]                   }
[13:19:01.108]                   options(future.plan = NULL)
[13:19:01.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:01.108]                 }
[13:19:01.108]                 ...future.workdir <- getwd()
[13:19:01.108]             }
[13:19:01.108]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:01.108]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:01.108]         }
[13:19:01.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:01.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:01.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:01.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:01.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:01.108]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:01.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:01.108]             base::names(...future.oldOptions))
[13:19:01.108]     }
[13:19:01.108]     if (FALSE) {
[13:19:01.108]     }
[13:19:01.108]     else {
[13:19:01.108]         if (TRUE) {
[13:19:01.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:01.108]                 open = "w")
[13:19:01.108]         }
[13:19:01.108]         else {
[13:19:01.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:01.108]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:01.108]         }
[13:19:01.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:01.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:01.108]             base::sink(type = "output", split = FALSE)
[13:19:01.108]             base::close(...future.stdout)
[13:19:01.108]         }, add = TRUE)
[13:19:01.108]     }
[13:19:01.108]     ...future.frame <- base::sys.nframe()
[13:19:01.108]     ...future.conditions <- base::list()
[13:19:01.108]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:01.108]     if (FALSE) {
[13:19:01.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:01.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:01.108]     }
[13:19:01.108]     ...future.result <- base::tryCatch({
[13:19:01.108]         base::withCallingHandlers({
[13:19:01.108]             ...future.value <- base::withVisible(base::local({
[13:19:01.108]                 ...future.makeSendCondition <- local({
[13:19:01.108]                   sendCondition <- NULL
[13:19:01.108]                   function(frame = 1L) {
[13:19:01.108]                     if (is.function(sendCondition)) 
[13:19:01.108]                       return(sendCondition)
[13:19:01.108]                     ns <- getNamespace("parallel")
[13:19:01.108]                     if (exists("sendData", mode = "function", 
[13:19:01.108]                       envir = ns)) {
[13:19:01.108]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:01.108]                         envir = ns)
[13:19:01.108]                       envir <- sys.frame(frame)
[13:19:01.108]                       master <- NULL
[13:19:01.108]                       while (!identical(envir, .GlobalEnv) && 
[13:19:01.108]                         !identical(envir, emptyenv())) {
[13:19:01.108]                         if (exists("master", mode = "list", envir = envir, 
[13:19:01.108]                           inherits = FALSE)) {
[13:19:01.108]                           master <- get("master", mode = "list", 
[13:19:01.108]                             envir = envir, inherits = FALSE)
[13:19:01.108]                           if (inherits(master, c("SOCKnode", 
[13:19:01.108]                             "SOCK0node"))) {
[13:19:01.108]                             sendCondition <<- function(cond) {
[13:19:01.108]                               data <- list(type = "VALUE", value = cond, 
[13:19:01.108]                                 success = TRUE)
[13:19:01.108]                               parallel_sendData(master, data)
[13:19:01.108]                             }
[13:19:01.108]                             return(sendCondition)
[13:19:01.108]                           }
[13:19:01.108]                         }
[13:19:01.108]                         frame <- frame + 1L
[13:19:01.108]                         envir <- sys.frame(frame)
[13:19:01.108]                       }
[13:19:01.108]                     }
[13:19:01.108]                     sendCondition <<- function(cond) NULL
[13:19:01.108]                   }
[13:19:01.108]                 })
[13:19:01.108]                 withCallingHandlers({
[13:19:01.108]                   {
[13:19:01.108]                     do.call(function(...) {
[13:19:01.108]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.108]                       if (!identical(...future.globals.maxSize.org, 
[13:19:01.108]                         ...future.globals.maxSize)) {
[13:19:01.108]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.108]                         on.exit(options(oopts), add = TRUE)
[13:19:01.108]                       }
[13:19:01.108]                       {
[13:19:01.108]                         lapply(seq_along(...future.elements_ii), 
[13:19:01.108]                           FUN = function(jj) {
[13:19:01.108]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.108]                             ...future.FUN(...future.X_jj, ...)
[13:19:01.108]                           })
[13:19:01.108]                       }
[13:19:01.108]                     }, args = future.call.arguments)
[13:19:01.108]                   }
[13:19:01.108]                 }, immediateCondition = function(cond) {
[13:19:01.108]                   sendCondition <- ...future.makeSendCondition()
[13:19:01.108]                   sendCondition(cond)
[13:19:01.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.108]                   {
[13:19:01.108]                     inherits <- base::inherits
[13:19:01.108]                     invokeRestart <- base::invokeRestart
[13:19:01.108]                     is.null <- base::is.null
[13:19:01.108]                     muffled <- FALSE
[13:19:01.108]                     if (inherits(cond, "message")) {
[13:19:01.108]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:01.108]                       if (muffled) 
[13:19:01.108]                         invokeRestart("muffleMessage")
[13:19:01.108]                     }
[13:19:01.108]                     else if (inherits(cond, "warning")) {
[13:19:01.108]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:01.108]                       if (muffled) 
[13:19:01.108]                         invokeRestart("muffleWarning")
[13:19:01.108]                     }
[13:19:01.108]                     else if (inherits(cond, "condition")) {
[13:19:01.108]                       if (!is.null(pattern)) {
[13:19:01.108]                         computeRestarts <- base::computeRestarts
[13:19:01.108]                         grepl <- base::grepl
[13:19:01.108]                         restarts <- computeRestarts(cond)
[13:19:01.108]                         for (restart in restarts) {
[13:19:01.108]                           name <- restart$name
[13:19:01.108]                           if (is.null(name)) 
[13:19:01.108]                             next
[13:19:01.108]                           if (!grepl(pattern, name)) 
[13:19:01.108]                             next
[13:19:01.108]                           invokeRestart(restart)
[13:19:01.108]                           muffled <- TRUE
[13:19:01.108]                           break
[13:19:01.108]                         }
[13:19:01.108]                       }
[13:19:01.108]                     }
[13:19:01.108]                     invisible(muffled)
[13:19:01.108]                   }
[13:19:01.108]                   muffleCondition(cond)
[13:19:01.108]                 })
[13:19:01.108]             }))
[13:19:01.108]             future::FutureResult(value = ...future.value$value, 
[13:19:01.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.108]                   ...future.rng), globalenv = if (FALSE) 
[13:19:01.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:01.108]                     ...future.globalenv.names))
[13:19:01.108]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:01.108]         }, condition = base::local({
[13:19:01.108]             c <- base::c
[13:19:01.108]             inherits <- base::inherits
[13:19:01.108]             invokeRestart <- base::invokeRestart
[13:19:01.108]             length <- base::length
[13:19:01.108]             list <- base::list
[13:19:01.108]             seq.int <- base::seq.int
[13:19:01.108]             signalCondition <- base::signalCondition
[13:19:01.108]             sys.calls <- base::sys.calls
[13:19:01.108]             `[[` <- base::`[[`
[13:19:01.108]             `+` <- base::`+`
[13:19:01.108]             `<<-` <- base::`<<-`
[13:19:01.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:01.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:01.108]                   3L)]
[13:19:01.108]             }
[13:19:01.108]             function(cond) {
[13:19:01.108]                 is_error <- inherits(cond, "error")
[13:19:01.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:01.108]                   NULL)
[13:19:01.108]                 if (is_error) {
[13:19:01.108]                   sessionInformation <- function() {
[13:19:01.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:01.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:01.108]                       search = base::search(), system = base::Sys.info())
[13:19:01.108]                   }
[13:19:01.108]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:01.108]                     cond$call), session = sessionInformation(), 
[13:19:01.108]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:01.108]                   signalCondition(cond)
[13:19:01.108]                 }
[13:19:01.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:01.108]                 "immediateCondition"))) {
[13:19:01.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:01.108]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:01.108]                   if (TRUE && !signal) {
[13:19:01.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.108]                     {
[13:19:01.108]                       inherits <- base::inherits
[13:19:01.108]                       invokeRestart <- base::invokeRestart
[13:19:01.108]                       is.null <- base::is.null
[13:19:01.108]                       muffled <- FALSE
[13:19:01.108]                       if (inherits(cond, "message")) {
[13:19:01.108]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.108]                         if (muffled) 
[13:19:01.108]                           invokeRestart("muffleMessage")
[13:19:01.108]                       }
[13:19:01.108]                       else if (inherits(cond, "warning")) {
[13:19:01.108]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.108]                         if (muffled) 
[13:19:01.108]                           invokeRestart("muffleWarning")
[13:19:01.108]                       }
[13:19:01.108]                       else if (inherits(cond, "condition")) {
[13:19:01.108]                         if (!is.null(pattern)) {
[13:19:01.108]                           computeRestarts <- base::computeRestarts
[13:19:01.108]                           grepl <- base::grepl
[13:19:01.108]                           restarts <- computeRestarts(cond)
[13:19:01.108]                           for (restart in restarts) {
[13:19:01.108]                             name <- restart$name
[13:19:01.108]                             if (is.null(name)) 
[13:19:01.108]                               next
[13:19:01.108]                             if (!grepl(pattern, name)) 
[13:19:01.108]                               next
[13:19:01.108]                             invokeRestart(restart)
[13:19:01.108]                             muffled <- TRUE
[13:19:01.108]                             break
[13:19:01.108]                           }
[13:19:01.108]                         }
[13:19:01.108]                       }
[13:19:01.108]                       invisible(muffled)
[13:19:01.108]                     }
[13:19:01.108]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.108]                   }
[13:19:01.108]                 }
[13:19:01.108]                 else {
[13:19:01.108]                   if (TRUE) {
[13:19:01.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.108]                     {
[13:19:01.108]                       inherits <- base::inherits
[13:19:01.108]                       invokeRestart <- base::invokeRestart
[13:19:01.108]                       is.null <- base::is.null
[13:19:01.108]                       muffled <- FALSE
[13:19:01.108]                       if (inherits(cond, "message")) {
[13:19:01.108]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.108]                         if (muffled) 
[13:19:01.108]                           invokeRestart("muffleMessage")
[13:19:01.108]                       }
[13:19:01.108]                       else if (inherits(cond, "warning")) {
[13:19:01.108]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.108]                         if (muffled) 
[13:19:01.108]                           invokeRestart("muffleWarning")
[13:19:01.108]                       }
[13:19:01.108]                       else if (inherits(cond, "condition")) {
[13:19:01.108]                         if (!is.null(pattern)) {
[13:19:01.108]                           computeRestarts <- base::computeRestarts
[13:19:01.108]                           grepl <- base::grepl
[13:19:01.108]                           restarts <- computeRestarts(cond)
[13:19:01.108]                           for (restart in restarts) {
[13:19:01.108]                             name <- restart$name
[13:19:01.108]                             if (is.null(name)) 
[13:19:01.108]                               next
[13:19:01.108]                             if (!grepl(pattern, name)) 
[13:19:01.108]                               next
[13:19:01.108]                             invokeRestart(restart)
[13:19:01.108]                             muffled <- TRUE
[13:19:01.108]                             break
[13:19:01.108]                           }
[13:19:01.108]                         }
[13:19:01.108]                       }
[13:19:01.108]                       invisible(muffled)
[13:19:01.108]                     }
[13:19:01.108]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.108]                   }
[13:19:01.108]                 }
[13:19:01.108]             }
[13:19:01.108]         }))
[13:19:01.108]     }, error = function(ex) {
[13:19:01.108]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:01.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.108]                 ...future.rng), started = ...future.startTime, 
[13:19:01.108]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:01.108]             version = "1.8"), class = "FutureResult")
[13:19:01.108]     }, finally = {
[13:19:01.108]         if (!identical(...future.workdir, getwd())) 
[13:19:01.108]             setwd(...future.workdir)
[13:19:01.108]         {
[13:19:01.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:01.108]                 ...future.oldOptions$nwarnings <- NULL
[13:19:01.108]             }
[13:19:01.108]             base::options(...future.oldOptions)
[13:19:01.108]             if (.Platform$OS.type == "windows") {
[13:19:01.108]                 old_names <- names(...future.oldEnvVars)
[13:19:01.108]                 envs <- base::Sys.getenv()
[13:19:01.108]                 names <- names(envs)
[13:19:01.108]                 common <- intersect(names, old_names)
[13:19:01.108]                 added <- setdiff(names, old_names)
[13:19:01.108]                 removed <- setdiff(old_names, names)
[13:19:01.108]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:01.108]                   envs[common]]
[13:19:01.108]                 NAMES <- toupper(changed)
[13:19:01.108]                 args <- list()
[13:19:01.108]                 for (kk in seq_along(NAMES)) {
[13:19:01.108]                   name <- changed[[kk]]
[13:19:01.108]                   NAME <- NAMES[[kk]]
[13:19:01.108]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.108]                     next
[13:19:01.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.108]                 }
[13:19:01.108]                 NAMES <- toupper(added)
[13:19:01.108]                 for (kk in seq_along(NAMES)) {
[13:19:01.108]                   name <- added[[kk]]
[13:19:01.108]                   NAME <- NAMES[[kk]]
[13:19:01.108]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.108]                     next
[13:19:01.108]                   args[[name]] <- ""
[13:19:01.108]                 }
[13:19:01.108]                 NAMES <- toupper(removed)
[13:19:01.108]                 for (kk in seq_along(NAMES)) {
[13:19:01.108]                   name <- removed[[kk]]
[13:19:01.108]                   NAME <- NAMES[[kk]]
[13:19:01.108]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.108]                     next
[13:19:01.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.108]                 }
[13:19:01.108]                 if (length(args) > 0) 
[13:19:01.108]                   base::do.call(base::Sys.setenv, args = args)
[13:19:01.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:01.108]             }
[13:19:01.108]             else {
[13:19:01.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:01.108]             }
[13:19:01.108]             {
[13:19:01.108]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:01.108]                   0L) {
[13:19:01.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:01.108]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:01.108]                   base::options(opts)
[13:19:01.108]                 }
[13:19:01.108]                 {
[13:19:01.108]                   {
[13:19:01.108]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:01.108]                     NULL
[13:19:01.108]                   }
[13:19:01.108]                   options(future.plan = NULL)
[13:19:01.108]                   if (is.na(NA_character_)) 
[13:19:01.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:01.108]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:01.108]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:01.108]                     envir = parent.frame()) 
[13:19:01.108]                   {
[13:19:01.108]                     if (is.function(workers)) 
[13:19:01.108]                       workers <- workers()
[13:19:01.108]                     workers <- structure(as.integer(workers), 
[13:19:01.108]                       class = class(workers))
[13:19:01.108]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:01.108]                       workers >= 1)
[13:19:01.108]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:01.108]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:01.108]                     }
[13:19:01.108]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:01.108]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:01.108]                       envir = envir)
[13:19:01.108]                     if (!future$lazy) 
[13:19:01.108]                       future <- run(future)
[13:19:01.108]                     invisible(future)
[13:19:01.108]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:01.108]                 }
[13:19:01.108]             }
[13:19:01.108]         }
[13:19:01.108]     })
[13:19:01.108]     if (TRUE) {
[13:19:01.108]         base::sink(type = "output", split = FALSE)
[13:19:01.108]         if (TRUE) {
[13:19:01.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:01.108]         }
[13:19:01.108]         else {
[13:19:01.108]             ...future.result["stdout"] <- base::list(NULL)
[13:19:01.108]         }
[13:19:01.108]         base::close(...future.stdout)
[13:19:01.108]         ...future.stdout <- NULL
[13:19:01.108]     }
[13:19:01.108]     ...future.result$conditions <- ...future.conditions
[13:19:01.108]     ...future.result$finished <- base::Sys.time()
[13:19:01.108]     ...future.result
[13:19:01.108] }
[13:19:01.112] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[13:19:01.112] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:01.153] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:01.153] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:19:01.154] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:19:01.154] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:01.154] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:01.155] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:01.197] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:01.197] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:01.241] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:01.241] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:01.242] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.242] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[13:19:01.242] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[13:19:01.243] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:01.243] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.243] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[13:19:01.244] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[13:19:01.244] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:01.244] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.244] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:01.245] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.245] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[13:19:01.246] MultisessionFuture started
[13:19:01.246] - Launch lazy future ... done
[13:19:01.246] run() for ‘MultisessionFuture’ ... done
[13:19:01.246] Created future:
[13:19:01.246] MultisessionFuture:
[13:19:01.246] Label: ‘future_vapply-1’
[13:19:01.246] Expression:
[13:19:01.246] {
[13:19:01.246]     do.call(function(...) {
[13:19:01.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.246]             on.exit(options(oopts), add = TRUE)
[13:19:01.246]         }
[13:19:01.246]         {
[13:19:01.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.246]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.246]             })
[13:19:01.246]         }
[13:19:01.246]     }, args = future.call.arguments)
[13:19:01.246] }
[13:19:01.246] Lazy evaluation: FALSE
[13:19:01.246] Asynchronous evaluation: TRUE
[13:19:01.246] Local evaluation: TRUE
[13:19:01.246] Environment: R_GlobalEnv
[13:19:01.246] Capture standard output: TRUE
[13:19:01.246] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:01.246] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:01.246] Packages: 1 packages (‘future.apply’)
[13:19:01.246] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:01.246] Resolved: FALSE
[13:19:01.246] Value: <not collected>
[13:19:01.246] Conditions captured: <none>
[13:19:01.246] Early signaling: FALSE
[13:19:01.246] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:01.246] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.259] Chunk #1 of 2 ... DONE
[13:19:01.259] Chunk #2 of 2 ...
[13:19:01.259]  - Finding globals in 'X' for chunk #2 ...
[13:19:01.259] getGlobalsAndPackages() ...
[13:19:01.259] Searching for globals...
[13:19:01.260] 
[13:19:01.260] Searching for globals ... DONE
[13:19:01.260] - globals: [0] <none>
[13:19:01.260] getGlobalsAndPackages() ... DONE
[13:19:01.260]    + additional globals found: [n=0] 
[13:19:01.260]    + additional namespaces needed: [n=0] 
[13:19:01.260]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:01.261]  - seeds: <none>
[13:19:01.261] getGlobalsAndPackages() ...
[13:19:01.261] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.261] Resolving globals: FALSE
[13:19:01.261] Tweak future expression to call with '...' arguments ...
[13:19:01.261] {
[13:19:01.261]     do.call(function(...) {
[13:19:01.261]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.261]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.261]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.261]             on.exit(options(oopts), add = TRUE)
[13:19:01.261]         }
[13:19:01.261]         {
[13:19:01.261]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.261]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.261]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.261]             })
[13:19:01.261]         }
[13:19:01.261]     }, args = future.call.arguments)
[13:19:01.261] }
[13:19:01.262] Tweak future expression to call with '...' arguments ... DONE
[13:19:01.262] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.262] - packages: [1] ‘future.apply’
[13:19:01.262] getGlobalsAndPackages() ... DONE
[13:19:01.263] run() for ‘Future’ ...
[13:19:01.263] - state: ‘created’
[13:19:01.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:01.279] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:01.279]   - Field: ‘node’
[13:19:01.279]   - Field: ‘label’
[13:19:01.279]   - Field: ‘local’
[13:19:01.280]   - Field: ‘owner’
[13:19:01.280]   - Field: ‘envir’
[13:19:01.280]   - Field: ‘workers’
[13:19:01.280]   - Field: ‘packages’
[13:19:01.280]   - Field: ‘gc’
[13:19:01.280]   - Field: ‘conditions’
[13:19:01.280]   - Field: ‘persistent’
[13:19:01.280]   - Field: ‘expr’
[13:19:01.280]   - Field: ‘uuid’
[13:19:01.281]   - Field: ‘seed’
[13:19:01.281]   - Field: ‘version’
[13:19:01.281]   - Field: ‘result’
[13:19:01.281]   - Field: ‘asynchronous’
[13:19:01.281]   - Field: ‘calls’
[13:19:01.281]   - Field: ‘globals’
[13:19:01.281]   - Field: ‘stdout’
[13:19:01.281]   - Field: ‘earlySignal’
[13:19:01.281]   - Field: ‘lazy’
[13:19:01.282]   - Field: ‘state’
[13:19:01.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:01.282] - Launch lazy future ...
[13:19:01.282] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:01.282] Packages needed by future strategies (n = 0): <none>
[13:19:01.283] {
[13:19:01.283]     {
[13:19:01.283]         {
[13:19:01.283]             ...future.startTime <- base::Sys.time()
[13:19:01.283]             {
[13:19:01.283]                 {
[13:19:01.283]                   {
[13:19:01.283]                     {
[13:19:01.283]                       {
[13:19:01.283]                         base::local({
[13:19:01.283]                           has_future <- base::requireNamespace("future", 
[13:19:01.283]                             quietly = TRUE)
[13:19:01.283]                           if (has_future) {
[13:19:01.283]                             ns <- base::getNamespace("future")
[13:19:01.283]                             version <- ns[[".package"]][["version"]]
[13:19:01.283]                             if (is.null(version)) 
[13:19:01.283]                               version <- utils::packageVersion("future")
[13:19:01.283]                           }
[13:19:01.283]                           else {
[13:19:01.283]                             version <- NULL
[13:19:01.283]                           }
[13:19:01.283]                           if (!has_future || version < "1.8.0") {
[13:19:01.283]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:01.283]                               "", base::R.version$version.string), 
[13:19:01.283]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:01.283]                                 base::R.version$platform, 8 * 
[13:19:01.283]                                   base::.Machine$sizeof.pointer), 
[13:19:01.283]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:01.283]                                 "release", "version")], collapse = " "), 
[13:19:01.283]                               hostname = base::Sys.info()[["nodename"]])
[13:19:01.283]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:01.283]                               info)
[13:19:01.283]                             info <- base::paste(info, collapse = "; ")
[13:19:01.283]                             if (!has_future) {
[13:19:01.283]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:01.283]                                 info)
[13:19:01.283]                             }
[13:19:01.283]                             else {
[13:19:01.283]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:01.283]                                 info, version)
[13:19:01.283]                             }
[13:19:01.283]                             base::stop(msg)
[13:19:01.283]                           }
[13:19:01.283]                         })
[13:19:01.283]                       }
[13:19:01.283]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:01.283]                       base::options(mc.cores = 1L)
[13:19:01.283]                     }
[13:19:01.283]                     base::local({
[13:19:01.283]                       for (pkg in "future.apply") {
[13:19:01.283]                         base::loadNamespace(pkg)
[13:19:01.283]                         base::library(pkg, character.only = TRUE)
[13:19:01.283]                       }
[13:19:01.283]                     })
[13:19:01.283]                   }
[13:19:01.283]                   options(future.plan = NULL)
[13:19:01.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:01.283]                 }
[13:19:01.283]                 ...future.workdir <- getwd()
[13:19:01.283]             }
[13:19:01.283]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:01.283]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:01.283]         }
[13:19:01.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:01.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:01.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:01.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:01.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:01.283]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:01.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:01.283]             base::names(...future.oldOptions))
[13:19:01.283]     }
[13:19:01.283]     if (FALSE) {
[13:19:01.283]     }
[13:19:01.283]     else {
[13:19:01.283]         if (TRUE) {
[13:19:01.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:01.283]                 open = "w")
[13:19:01.283]         }
[13:19:01.283]         else {
[13:19:01.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:01.283]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:01.283]         }
[13:19:01.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:01.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:01.283]             base::sink(type = "output", split = FALSE)
[13:19:01.283]             base::close(...future.stdout)
[13:19:01.283]         }, add = TRUE)
[13:19:01.283]     }
[13:19:01.283]     ...future.frame <- base::sys.nframe()
[13:19:01.283]     ...future.conditions <- base::list()
[13:19:01.283]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:01.283]     if (FALSE) {
[13:19:01.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:01.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:01.283]     }
[13:19:01.283]     ...future.result <- base::tryCatch({
[13:19:01.283]         base::withCallingHandlers({
[13:19:01.283]             ...future.value <- base::withVisible(base::local({
[13:19:01.283]                 ...future.makeSendCondition <- local({
[13:19:01.283]                   sendCondition <- NULL
[13:19:01.283]                   function(frame = 1L) {
[13:19:01.283]                     if (is.function(sendCondition)) 
[13:19:01.283]                       return(sendCondition)
[13:19:01.283]                     ns <- getNamespace("parallel")
[13:19:01.283]                     if (exists("sendData", mode = "function", 
[13:19:01.283]                       envir = ns)) {
[13:19:01.283]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:01.283]                         envir = ns)
[13:19:01.283]                       envir <- sys.frame(frame)
[13:19:01.283]                       master <- NULL
[13:19:01.283]                       while (!identical(envir, .GlobalEnv) && 
[13:19:01.283]                         !identical(envir, emptyenv())) {
[13:19:01.283]                         if (exists("master", mode = "list", envir = envir, 
[13:19:01.283]                           inherits = FALSE)) {
[13:19:01.283]                           master <- get("master", mode = "list", 
[13:19:01.283]                             envir = envir, inherits = FALSE)
[13:19:01.283]                           if (inherits(master, c("SOCKnode", 
[13:19:01.283]                             "SOCK0node"))) {
[13:19:01.283]                             sendCondition <<- function(cond) {
[13:19:01.283]                               data <- list(type = "VALUE", value = cond, 
[13:19:01.283]                                 success = TRUE)
[13:19:01.283]                               parallel_sendData(master, data)
[13:19:01.283]                             }
[13:19:01.283]                             return(sendCondition)
[13:19:01.283]                           }
[13:19:01.283]                         }
[13:19:01.283]                         frame <- frame + 1L
[13:19:01.283]                         envir <- sys.frame(frame)
[13:19:01.283]                       }
[13:19:01.283]                     }
[13:19:01.283]                     sendCondition <<- function(cond) NULL
[13:19:01.283]                   }
[13:19:01.283]                 })
[13:19:01.283]                 withCallingHandlers({
[13:19:01.283]                   {
[13:19:01.283]                     do.call(function(...) {
[13:19:01.283]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.283]                       if (!identical(...future.globals.maxSize.org, 
[13:19:01.283]                         ...future.globals.maxSize)) {
[13:19:01.283]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.283]                         on.exit(options(oopts), add = TRUE)
[13:19:01.283]                       }
[13:19:01.283]                       {
[13:19:01.283]                         lapply(seq_along(...future.elements_ii), 
[13:19:01.283]                           FUN = function(jj) {
[13:19:01.283]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.283]                             ...future.FUN(...future.X_jj, ...)
[13:19:01.283]                           })
[13:19:01.283]                       }
[13:19:01.283]                     }, args = future.call.arguments)
[13:19:01.283]                   }
[13:19:01.283]                 }, immediateCondition = function(cond) {
[13:19:01.283]                   sendCondition <- ...future.makeSendCondition()
[13:19:01.283]                   sendCondition(cond)
[13:19:01.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.283]                   {
[13:19:01.283]                     inherits <- base::inherits
[13:19:01.283]                     invokeRestart <- base::invokeRestart
[13:19:01.283]                     is.null <- base::is.null
[13:19:01.283]                     muffled <- FALSE
[13:19:01.283]                     if (inherits(cond, "message")) {
[13:19:01.283]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:01.283]                       if (muffled) 
[13:19:01.283]                         invokeRestart("muffleMessage")
[13:19:01.283]                     }
[13:19:01.283]                     else if (inherits(cond, "warning")) {
[13:19:01.283]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:01.283]                       if (muffled) 
[13:19:01.283]                         invokeRestart("muffleWarning")
[13:19:01.283]                     }
[13:19:01.283]                     else if (inherits(cond, "condition")) {
[13:19:01.283]                       if (!is.null(pattern)) {
[13:19:01.283]                         computeRestarts <- base::computeRestarts
[13:19:01.283]                         grepl <- base::grepl
[13:19:01.283]                         restarts <- computeRestarts(cond)
[13:19:01.283]                         for (restart in restarts) {
[13:19:01.283]                           name <- restart$name
[13:19:01.283]                           if (is.null(name)) 
[13:19:01.283]                             next
[13:19:01.283]                           if (!grepl(pattern, name)) 
[13:19:01.283]                             next
[13:19:01.283]                           invokeRestart(restart)
[13:19:01.283]                           muffled <- TRUE
[13:19:01.283]                           break
[13:19:01.283]                         }
[13:19:01.283]                       }
[13:19:01.283]                     }
[13:19:01.283]                     invisible(muffled)
[13:19:01.283]                   }
[13:19:01.283]                   muffleCondition(cond)
[13:19:01.283]                 })
[13:19:01.283]             }))
[13:19:01.283]             future::FutureResult(value = ...future.value$value, 
[13:19:01.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.283]                   ...future.rng), globalenv = if (FALSE) 
[13:19:01.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:01.283]                     ...future.globalenv.names))
[13:19:01.283]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:01.283]         }, condition = base::local({
[13:19:01.283]             c <- base::c
[13:19:01.283]             inherits <- base::inherits
[13:19:01.283]             invokeRestart <- base::invokeRestart
[13:19:01.283]             length <- base::length
[13:19:01.283]             list <- base::list
[13:19:01.283]             seq.int <- base::seq.int
[13:19:01.283]             signalCondition <- base::signalCondition
[13:19:01.283]             sys.calls <- base::sys.calls
[13:19:01.283]             `[[` <- base::`[[`
[13:19:01.283]             `+` <- base::`+`
[13:19:01.283]             `<<-` <- base::`<<-`
[13:19:01.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:01.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:01.283]                   3L)]
[13:19:01.283]             }
[13:19:01.283]             function(cond) {
[13:19:01.283]                 is_error <- inherits(cond, "error")
[13:19:01.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:01.283]                   NULL)
[13:19:01.283]                 if (is_error) {
[13:19:01.283]                   sessionInformation <- function() {
[13:19:01.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:01.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:01.283]                       search = base::search(), system = base::Sys.info())
[13:19:01.283]                   }
[13:19:01.283]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:01.283]                     cond$call), session = sessionInformation(), 
[13:19:01.283]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:01.283]                   signalCondition(cond)
[13:19:01.283]                 }
[13:19:01.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:01.283]                 "immediateCondition"))) {
[13:19:01.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:01.283]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:01.283]                   if (TRUE && !signal) {
[13:19:01.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.283]                     {
[13:19:01.283]                       inherits <- base::inherits
[13:19:01.283]                       invokeRestart <- base::invokeRestart
[13:19:01.283]                       is.null <- base::is.null
[13:19:01.283]                       muffled <- FALSE
[13:19:01.283]                       if (inherits(cond, "message")) {
[13:19:01.283]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.283]                         if (muffled) 
[13:19:01.283]                           invokeRestart("muffleMessage")
[13:19:01.283]                       }
[13:19:01.283]                       else if (inherits(cond, "warning")) {
[13:19:01.283]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.283]                         if (muffled) 
[13:19:01.283]                           invokeRestart("muffleWarning")
[13:19:01.283]                       }
[13:19:01.283]                       else if (inherits(cond, "condition")) {
[13:19:01.283]                         if (!is.null(pattern)) {
[13:19:01.283]                           computeRestarts <- base::computeRestarts
[13:19:01.283]                           grepl <- base::grepl
[13:19:01.283]                           restarts <- computeRestarts(cond)
[13:19:01.283]                           for (restart in restarts) {
[13:19:01.283]                             name <- restart$name
[13:19:01.283]                             if (is.null(name)) 
[13:19:01.283]                               next
[13:19:01.283]                             if (!grepl(pattern, name)) 
[13:19:01.283]                               next
[13:19:01.283]                             invokeRestart(restart)
[13:19:01.283]                             muffled <- TRUE
[13:19:01.283]                             break
[13:19:01.283]                           }
[13:19:01.283]                         }
[13:19:01.283]                       }
[13:19:01.283]                       invisible(muffled)
[13:19:01.283]                     }
[13:19:01.283]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.283]                   }
[13:19:01.283]                 }
[13:19:01.283]                 else {
[13:19:01.283]                   if (TRUE) {
[13:19:01.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.283]                     {
[13:19:01.283]                       inherits <- base::inherits
[13:19:01.283]                       invokeRestart <- base::invokeRestart
[13:19:01.283]                       is.null <- base::is.null
[13:19:01.283]                       muffled <- FALSE
[13:19:01.283]                       if (inherits(cond, "message")) {
[13:19:01.283]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.283]                         if (muffled) 
[13:19:01.283]                           invokeRestart("muffleMessage")
[13:19:01.283]                       }
[13:19:01.283]                       else if (inherits(cond, "warning")) {
[13:19:01.283]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.283]                         if (muffled) 
[13:19:01.283]                           invokeRestart("muffleWarning")
[13:19:01.283]                       }
[13:19:01.283]                       else if (inherits(cond, "condition")) {
[13:19:01.283]                         if (!is.null(pattern)) {
[13:19:01.283]                           computeRestarts <- base::computeRestarts
[13:19:01.283]                           grepl <- base::grepl
[13:19:01.283]                           restarts <- computeRestarts(cond)
[13:19:01.283]                           for (restart in restarts) {
[13:19:01.283]                             name <- restart$name
[13:19:01.283]                             if (is.null(name)) 
[13:19:01.283]                               next
[13:19:01.283]                             if (!grepl(pattern, name)) 
[13:19:01.283]                               next
[13:19:01.283]                             invokeRestart(restart)
[13:19:01.283]                             muffled <- TRUE
[13:19:01.283]                             break
[13:19:01.283]                           }
[13:19:01.283]                         }
[13:19:01.283]                       }
[13:19:01.283]                       invisible(muffled)
[13:19:01.283]                     }
[13:19:01.283]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.283]                   }
[13:19:01.283]                 }
[13:19:01.283]             }
[13:19:01.283]         }))
[13:19:01.283]     }, error = function(ex) {
[13:19:01.283]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:01.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.283]                 ...future.rng), started = ...future.startTime, 
[13:19:01.283]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:01.283]             version = "1.8"), class = "FutureResult")
[13:19:01.283]     }, finally = {
[13:19:01.283]         if (!identical(...future.workdir, getwd())) 
[13:19:01.283]             setwd(...future.workdir)
[13:19:01.283]         {
[13:19:01.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:01.283]                 ...future.oldOptions$nwarnings <- NULL
[13:19:01.283]             }
[13:19:01.283]             base::options(...future.oldOptions)
[13:19:01.283]             if (.Platform$OS.type == "windows") {
[13:19:01.283]                 old_names <- names(...future.oldEnvVars)
[13:19:01.283]                 envs <- base::Sys.getenv()
[13:19:01.283]                 names <- names(envs)
[13:19:01.283]                 common <- intersect(names, old_names)
[13:19:01.283]                 added <- setdiff(names, old_names)
[13:19:01.283]                 removed <- setdiff(old_names, names)
[13:19:01.283]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:01.283]                   envs[common]]
[13:19:01.283]                 NAMES <- toupper(changed)
[13:19:01.283]                 args <- list()
[13:19:01.283]                 for (kk in seq_along(NAMES)) {
[13:19:01.283]                   name <- changed[[kk]]
[13:19:01.283]                   NAME <- NAMES[[kk]]
[13:19:01.283]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.283]                     next
[13:19:01.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.283]                 }
[13:19:01.283]                 NAMES <- toupper(added)
[13:19:01.283]                 for (kk in seq_along(NAMES)) {
[13:19:01.283]                   name <- added[[kk]]
[13:19:01.283]                   NAME <- NAMES[[kk]]
[13:19:01.283]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.283]                     next
[13:19:01.283]                   args[[name]] <- ""
[13:19:01.283]                 }
[13:19:01.283]                 NAMES <- toupper(removed)
[13:19:01.283]                 for (kk in seq_along(NAMES)) {
[13:19:01.283]                   name <- removed[[kk]]
[13:19:01.283]                   NAME <- NAMES[[kk]]
[13:19:01.283]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.283]                     next
[13:19:01.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.283]                 }
[13:19:01.283]                 if (length(args) > 0) 
[13:19:01.283]                   base::do.call(base::Sys.setenv, args = args)
[13:19:01.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:01.283]             }
[13:19:01.283]             else {
[13:19:01.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:01.283]             }
[13:19:01.283]             {
[13:19:01.283]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:01.283]                   0L) {
[13:19:01.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:01.283]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:01.283]                   base::options(opts)
[13:19:01.283]                 }
[13:19:01.283]                 {
[13:19:01.283]                   {
[13:19:01.283]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:01.283]                     NULL
[13:19:01.283]                   }
[13:19:01.283]                   options(future.plan = NULL)
[13:19:01.283]                   if (is.na(NA_character_)) 
[13:19:01.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:01.283]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:01.283]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:01.283]                     envir = parent.frame()) 
[13:19:01.283]                   {
[13:19:01.283]                     if (is.function(workers)) 
[13:19:01.283]                       workers <- workers()
[13:19:01.283]                     workers <- structure(as.integer(workers), 
[13:19:01.283]                       class = class(workers))
[13:19:01.283]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:01.283]                       workers >= 1)
[13:19:01.283]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:01.283]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:01.283]                     }
[13:19:01.283]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:01.283]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:01.283]                       envir = envir)
[13:19:01.283]                     if (!future$lazy) 
[13:19:01.283]                       future <- run(future)
[13:19:01.283]                     invisible(future)
[13:19:01.283]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:01.283]                 }
[13:19:01.283]             }
[13:19:01.283]         }
[13:19:01.283]     })
[13:19:01.283]     if (TRUE) {
[13:19:01.283]         base::sink(type = "output", split = FALSE)
[13:19:01.283]         if (TRUE) {
[13:19:01.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:01.283]         }
[13:19:01.283]         else {
[13:19:01.283]             ...future.result["stdout"] <- base::list(NULL)
[13:19:01.283]         }
[13:19:01.283]         base::close(...future.stdout)
[13:19:01.283]         ...future.stdout <- NULL
[13:19:01.283]     }
[13:19:01.283]     ...future.result$conditions <- ...future.conditions
[13:19:01.283]     ...future.result$finished <- base::Sys.time()
[13:19:01.283]     ...future.result
[13:19:01.283] }
[13:19:01.356] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[13:19:01.356] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:01.361] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:01.361] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:19:01.362] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:19:01.362] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:01.362] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:01.362] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:01.405] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:01.405] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:01.449] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:01.449] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:01.450] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.450] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[13:19:01.450] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[13:19:01.450] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:01.451] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.451] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[13:19:01.451] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[13:19:01.452] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:01.452] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.452] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:01.452] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.452] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[13:19:01.453] MultisessionFuture started
[13:19:01.456] - Launch lazy future ... done
[13:19:01.456] run() for ‘MultisessionFuture’ ... done
[13:19:01.456] Created future:
[13:19:01.456] MultisessionFuture:
[13:19:01.456] Label: ‘future_vapply-2’
[13:19:01.456] Expression:
[13:19:01.456] {
[13:19:01.456]     do.call(function(...) {
[13:19:01.456]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.456]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.456]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.456]             on.exit(options(oopts), add = TRUE)
[13:19:01.456]         }
[13:19:01.456]         {
[13:19:01.456]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.456]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.456]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.456]             })
[13:19:01.456]         }
[13:19:01.456]     }, args = future.call.arguments)
[13:19:01.456] }
[13:19:01.456] Lazy evaluation: FALSE
[13:19:01.456] Asynchronous evaluation: TRUE
[13:19:01.456] Local evaluation: TRUE
[13:19:01.456] Environment: R_GlobalEnv
[13:19:01.456] Capture standard output: TRUE
[13:19:01.456] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:01.456] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:01.456] Packages: 1 packages (‘future.apply’)
[13:19:01.456] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:01.456] Resolved: FALSE
[13:19:01.456] Value: <not collected>
[13:19:01.456] Conditions captured: <none>
[13:19:01.456] Early signaling: FALSE
[13:19:01.456] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:01.456] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.468] Chunk #2 of 2 ... DONE
[13:19:01.468] Launching 2 futures (chunks) ... DONE
[13:19:01.468] Resolving 2 futures (chunks) ...
[13:19:01.468] resolve() on list ...
[13:19:01.468]  recursive: 0
[13:19:01.468]  length: 2
[13:19:01.468] 
[13:19:01.469] receiveMessageFromWorker() for ClusterFuture ...
[13:19:01.469] - Validating connection of MultisessionFuture
[13:19:01.469] - received message: FutureResult
[13:19:01.469] - Received FutureResult
[13:19:01.469] - Erased future from FutureRegistry
[13:19:01.470] result() for ClusterFuture ...
[13:19:01.470] - result already collected: FutureResult
[13:19:01.470] result() for ClusterFuture ... done
[13:19:01.470] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:01.470] Future #1
[13:19:01.470] result() for ClusterFuture ...
[13:19:01.470] - result already collected: FutureResult
[13:19:01.470] result() for ClusterFuture ... done
[13:19:01.470] result() for ClusterFuture ...
[13:19:01.470] - result already collected: FutureResult
[13:19:01.470] result() for ClusterFuture ... done
[13:19:01.470] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:01.471] - nx: 2
[13:19:01.471] - relay: TRUE
[13:19:01.471] - stdout: TRUE
[13:19:01.471] - signal: TRUE
[13:19:01.471] - resignal: FALSE
[13:19:01.471] - force: TRUE
[13:19:01.471] - relayed: [n=2] FALSE, FALSE
[13:19:01.471] - queued futures: [n=2] FALSE, FALSE
[13:19:01.471]  - until=1
[13:19:01.471]  - relaying element #1
[13:19:01.471] result() for ClusterFuture ...
[13:19:01.472] - result already collected: FutureResult
[13:19:01.472] result() for ClusterFuture ... done
[13:19:01.472] result() for ClusterFuture ...
[13:19:01.472] - result already collected: FutureResult
[13:19:01.472] result() for ClusterFuture ... done
[13:19:01.472] result() for ClusterFuture ...
[13:19:01.472] - result already collected: FutureResult
[13:19:01.472] result() for ClusterFuture ... done
[13:19:01.472] result() for ClusterFuture ...
[13:19:01.472] - result already collected: FutureResult
[13:19:01.472] result() for ClusterFuture ... done
[13:19:01.472] - relayed: [n=2] TRUE, FALSE
[13:19:01.473] - queued futures: [n=2] TRUE, FALSE
[13:19:01.473] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:01.473]  length: 1 (resolved future 1)
[13:19:01.538] receiveMessageFromWorker() for ClusterFuture ...
[13:19:01.538] - Validating connection of MultisessionFuture
[13:19:01.539] - received message: FutureResult
[13:19:01.539] - Received FutureResult
[13:19:01.539] - Erased future from FutureRegistry
[13:19:01.539] result() for ClusterFuture ...
[13:19:01.539] - result already collected: FutureResult
[13:19:01.539] result() for ClusterFuture ... done
[13:19:01.539] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:01.539] Future #2
[13:19:01.540] result() for ClusterFuture ...
[13:19:01.540] - result already collected: FutureResult
[13:19:01.540] result() for ClusterFuture ... done
[13:19:01.540] result() for ClusterFuture ...
[13:19:01.540] - result already collected: FutureResult
[13:19:01.540] result() for ClusterFuture ... done
[13:19:01.540] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:01.540] - nx: 2
[13:19:01.540] - relay: TRUE
[13:19:01.540] - stdout: TRUE
[13:19:01.540] - signal: TRUE
[13:19:01.541] - resignal: FALSE
[13:19:01.541] - force: TRUE
[13:19:01.541] - relayed: [n=2] TRUE, FALSE
[13:19:01.541] - queued futures: [n=2] TRUE, FALSE
[13:19:01.541]  - until=2
[13:19:01.541]  - relaying element #2
[13:19:01.541] result() for ClusterFuture ...
[13:19:01.541] - result already collected: FutureResult
[13:19:01.541] result() for ClusterFuture ... done
[13:19:01.541] result() for ClusterFuture ...
[13:19:01.542] - result already collected: FutureResult
[13:19:01.542] result() for ClusterFuture ... done
[13:19:01.542] result() for ClusterFuture ...
[13:19:01.542] - result already collected: FutureResult
[13:19:01.542] result() for ClusterFuture ... done
[13:19:01.542] result() for ClusterFuture ...
[13:19:01.542] - result already collected: FutureResult
[13:19:01.542] result() for ClusterFuture ... done
[13:19:01.542] - relayed: [n=2] TRUE, TRUE
[13:19:01.542] - queued futures: [n=2] TRUE, TRUE
[13:19:01.542] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:01.543]  length: 0 (resolved future 2)
[13:19:01.543] Relaying remaining futures
[13:19:01.543] signalConditionsASAP(NULL, pos=0) ...
[13:19:01.543] - nx: 2
[13:19:01.543] - relay: TRUE
[13:19:01.543] - stdout: TRUE
[13:19:01.543] - signal: TRUE
[13:19:01.543] - resignal: FALSE
[13:19:01.543] - force: TRUE
[13:19:01.543] - relayed: [n=2] TRUE, TRUE
[13:19:01.543] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:01.544] - relayed: [n=2] TRUE, TRUE
[13:19:01.544] - queued futures: [n=2] TRUE, TRUE
[13:19:01.544] signalConditionsASAP(NULL, pos=0) ... done
[13:19:01.544] resolve() on list ... DONE
[13:19:01.544] result() for ClusterFuture ...
[13:19:01.544] - result already collected: FutureResult
[13:19:01.544] result() for ClusterFuture ... done
[13:19:01.544] result() for ClusterFuture ...
[13:19:01.544] - result already collected: FutureResult
[13:19:01.544] result() for ClusterFuture ... done
[13:19:01.544] result() for ClusterFuture ...
[13:19:01.545] - result already collected: FutureResult
[13:19:01.545] result() for ClusterFuture ... done
[13:19:01.545] result() for ClusterFuture ...
[13:19:01.545] - result already collected: FutureResult
[13:19:01.545] result() for ClusterFuture ... done
[13:19:01.545]  - Number of value chunks collected: 2
[13:19:01.545] Resolving 2 futures (chunks) ... DONE
[13:19:01.545] Reducing values from 2 chunks ...
[13:19:01.545]  - Number of values collected after concatenation: 2
[13:19:01.545]  - Number of values expected: 2
[13:19:01.546] Reducing values from 2 chunks ... DONE
[13:19:01.546] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:19:01.547] future_lapply() ...
[13:19:01.552] Number of chunks: 2
[13:19:01.552] getGlobalsAndPackagesXApply() ...
[13:19:01.552]  - future.globals: TRUE
[13:19:01.552] getGlobalsAndPackages() ...
[13:19:01.552] Searching for globals...
[13:19:01.556] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:19:01.556] Searching for globals ... DONE
[13:19:01.556] Resolving globals: FALSE
[13:19:01.557] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:19:01.557] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:01.557] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:01.558] - packages: [1] ‘future.apply’
[13:19:01.558] getGlobalsAndPackages() ... DONE
[13:19:01.558]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:01.558]  - needed namespaces: [n=1] ‘future.apply’
[13:19:01.558] Finding globals ... DONE
[13:19:01.558]  - use_args: TRUE
[13:19:01.558]  - Getting '...' globals ...
[13:19:01.559] resolve() on list ...
[13:19:01.559]  recursive: 0
[13:19:01.559]  length: 1
[13:19:01.559]  elements: ‘...’
[13:19:01.559]  length: 0 (resolved future 1)
[13:19:01.559] resolve() on list ... DONE
[13:19:01.559]    - '...' content: [n=0] 
[13:19:01.559] List of 1
[13:19:01.559]  $ ...: list()
[13:19:01.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:01.559]  - attr(*, "where")=List of 1
[13:19:01.559]   ..$ ...:<environment: 0x555f79f58618> 
[13:19:01.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:01.559]  - attr(*, "resolved")= logi TRUE
[13:19:01.559]  - attr(*, "total_size")= num NA
[13:19:01.562]  - Getting '...' globals ... DONE
[13:19:01.562] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:01.562] List of 8
[13:19:01.562]  $ ...future.FUN:function (x, ...)  
[13:19:01.562]  $ x_FUN        :function (x)  
[13:19:01.562]  $ times        : int 0
[13:19:01.562]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:01.562]  $ stop_if_not  :function (...)  
[13:19:01.562]  $ dim          : NULL
[13:19:01.562]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:01.562]  $ ...          : list()
[13:19:01.562]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:01.562]  - attr(*, "where")=List of 8
[13:19:01.562]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:01.562]   ..$ ...          :<environment: 0x555f79f58618> 
[13:19:01.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:01.562]  - attr(*, "resolved")= logi FALSE
[13:19:01.562]  - attr(*, "total_size")= num 95472
[13:19:01.567] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:01.567] getGlobalsAndPackagesXApply() ... DONE
[13:19:01.567] Number of futures (= number of chunks): 2
[13:19:01.568] Launching 2 futures (chunks) ...
[13:19:01.568] Chunk #1 of 2 ...
[13:19:01.568]  - Finding globals in 'X' for chunk #1 ...
[13:19:01.568] getGlobalsAndPackages() ...
[13:19:01.568] Searching for globals...
[13:19:01.568] 
[13:19:01.568] Searching for globals ... DONE
[13:19:01.568] - globals: [0] <none>
[13:19:01.569] getGlobalsAndPackages() ... DONE
[13:19:01.569]    + additional globals found: [n=0] 
[13:19:01.569]    + additional namespaces needed: [n=0] 
[13:19:01.569]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:01.569]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:01.569]  - seeds: <none>
[13:19:01.569] getGlobalsAndPackages() ...
[13:19:01.569] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.569] Resolving globals: FALSE
[13:19:01.569] Tweak future expression to call with '...' arguments ...
[13:19:01.570] {
[13:19:01.570]     do.call(function(...) {
[13:19:01.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.570]             on.exit(options(oopts), add = TRUE)
[13:19:01.570]         }
[13:19:01.570]         {
[13:19:01.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.570]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.570]             })
[13:19:01.570]         }
[13:19:01.570]     }, args = future.call.arguments)
[13:19:01.570] }
[13:19:01.570] Tweak future expression to call with '...' arguments ... DONE
[13:19:01.570] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.570] - packages: [1] ‘future.apply’
[13:19:01.571] getGlobalsAndPackages() ... DONE
[13:19:01.571] run() for ‘Future’ ...
[13:19:01.571] - state: ‘created’
[13:19:01.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:01.587] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:01.587]   - Field: ‘node’
[13:19:01.587]   - Field: ‘label’
[13:19:01.588]   - Field: ‘local’
[13:19:01.588]   - Field: ‘owner’
[13:19:01.588]   - Field: ‘envir’
[13:19:01.588]   - Field: ‘workers’
[13:19:01.588]   - Field: ‘packages’
[13:19:01.588]   - Field: ‘gc’
[13:19:01.588]   - Field: ‘conditions’
[13:19:01.588]   - Field: ‘persistent’
[13:19:01.588]   - Field: ‘expr’
[13:19:01.588]   - Field: ‘uuid’
[13:19:01.588]   - Field: ‘seed’
[13:19:01.589]   - Field: ‘version’
[13:19:01.589]   - Field: ‘result’
[13:19:01.589]   - Field: ‘asynchronous’
[13:19:01.589]   - Field: ‘calls’
[13:19:01.589]   - Field: ‘globals’
[13:19:01.589]   - Field: ‘stdout’
[13:19:01.589]   - Field: ‘earlySignal’
[13:19:01.589]   - Field: ‘lazy’
[13:19:01.589]   - Field: ‘state’
[13:19:01.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:01.590] - Launch lazy future ...
[13:19:01.590] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:01.590] Packages needed by future strategies (n = 0): <none>
[13:19:01.590] {
[13:19:01.590]     {
[13:19:01.590]         {
[13:19:01.590]             ...future.startTime <- base::Sys.time()
[13:19:01.590]             {
[13:19:01.590]                 {
[13:19:01.590]                   {
[13:19:01.590]                     {
[13:19:01.590]                       {
[13:19:01.590]                         base::local({
[13:19:01.590]                           has_future <- base::requireNamespace("future", 
[13:19:01.590]                             quietly = TRUE)
[13:19:01.590]                           if (has_future) {
[13:19:01.590]                             ns <- base::getNamespace("future")
[13:19:01.590]                             version <- ns[[".package"]][["version"]]
[13:19:01.590]                             if (is.null(version)) 
[13:19:01.590]                               version <- utils::packageVersion("future")
[13:19:01.590]                           }
[13:19:01.590]                           else {
[13:19:01.590]                             version <- NULL
[13:19:01.590]                           }
[13:19:01.590]                           if (!has_future || version < "1.8.0") {
[13:19:01.590]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:01.590]                               "", base::R.version$version.string), 
[13:19:01.590]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:01.590]                                 base::R.version$platform, 8 * 
[13:19:01.590]                                   base::.Machine$sizeof.pointer), 
[13:19:01.590]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:01.590]                                 "release", "version")], collapse = " "), 
[13:19:01.590]                               hostname = base::Sys.info()[["nodename"]])
[13:19:01.590]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:01.590]                               info)
[13:19:01.590]                             info <- base::paste(info, collapse = "; ")
[13:19:01.590]                             if (!has_future) {
[13:19:01.590]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:01.590]                                 info)
[13:19:01.590]                             }
[13:19:01.590]                             else {
[13:19:01.590]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:01.590]                                 info, version)
[13:19:01.590]                             }
[13:19:01.590]                             base::stop(msg)
[13:19:01.590]                           }
[13:19:01.590]                         })
[13:19:01.590]                       }
[13:19:01.590]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:01.590]                       base::options(mc.cores = 1L)
[13:19:01.590]                     }
[13:19:01.590]                     base::local({
[13:19:01.590]                       for (pkg in "future.apply") {
[13:19:01.590]                         base::loadNamespace(pkg)
[13:19:01.590]                         base::library(pkg, character.only = TRUE)
[13:19:01.590]                       }
[13:19:01.590]                     })
[13:19:01.590]                   }
[13:19:01.590]                   options(future.plan = NULL)
[13:19:01.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:01.590]                 }
[13:19:01.590]                 ...future.workdir <- getwd()
[13:19:01.590]             }
[13:19:01.590]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:01.590]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:01.590]         }
[13:19:01.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:01.590]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:01.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:01.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:01.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:01.590]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:01.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:01.590]             base::names(...future.oldOptions))
[13:19:01.590]     }
[13:19:01.590]     if (FALSE) {
[13:19:01.590]     }
[13:19:01.590]     else {
[13:19:01.590]         if (TRUE) {
[13:19:01.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:01.590]                 open = "w")
[13:19:01.590]         }
[13:19:01.590]         else {
[13:19:01.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:01.590]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:01.590]         }
[13:19:01.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:01.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:01.590]             base::sink(type = "output", split = FALSE)
[13:19:01.590]             base::close(...future.stdout)
[13:19:01.590]         }, add = TRUE)
[13:19:01.590]     }
[13:19:01.590]     ...future.frame <- base::sys.nframe()
[13:19:01.590]     ...future.conditions <- base::list()
[13:19:01.590]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:01.590]     if (FALSE) {
[13:19:01.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:01.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:01.590]     }
[13:19:01.590]     ...future.result <- base::tryCatch({
[13:19:01.590]         base::withCallingHandlers({
[13:19:01.590]             ...future.value <- base::withVisible(base::local({
[13:19:01.590]                 ...future.makeSendCondition <- local({
[13:19:01.590]                   sendCondition <- NULL
[13:19:01.590]                   function(frame = 1L) {
[13:19:01.590]                     if (is.function(sendCondition)) 
[13:19:01.590]                       return(sendCondition)
[13:19:01.590]                     ns <- getNamespace("parallel")
[13:19:01.590]                     if (exists("sendData", mode = "function", 
[13:19:01.590]                       envir = ns)) {
[13:19:01.590]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:01.590]                         envir = ns)
[13:19:01.590]                       envir <- sys.frame(frame)
[13:19:01.590]                       master <- NULL
[13:19:01.590]                       while (!identical(envir, .GlobalEnv) && 
[13:19:01.590]                         !identical(envir, emptyenv())) {
[13:19:01.590]                         if (exists("master", mode = "list", envir = envir, 
[13:19:01.590]                           inherits = FALSE)) {
[13:19:01.590]                           master <- get("master", mode = "list", 
[13:19:01.590]                             envir = envir, inherits = FALSE)
[13:19:01.590]                           if (inherits(master, c("SOCKnode", 
[13:19:01.590]                             "SOCK0node"))) {
[13:19:01.590]                             sendCondition <<- function(cond) {
[13:19:01.590]                               data <- list(type = "VALUE", value = cond, 
[13:19:01.590]                                 success = TRUE)
[13:19:01.590]                               parallel_sendData(master, data)
[13:19:01.590]                             }
[13:19:01.590]                             return(sendCondition)
[13:19:01.590]                           }
[13:19:01.590]                         }
[13:19:01.590]                         frame <- frame + 1L
[13:19:01.590]                         envir <- sys.frame(frame)
[13:19:01.590]                       }
[13:19:01.590]                     }
[13:19:01.590]                     sendCondition <<- function(cond) NULL
[13:19:01.590]                   }
[13:19:01.590]                 })
[13:19:01.590]                 withCallingHandlers({
[13:19:01.590]                   {
[13:19:01.590]                     do.call(function(...) {
[13:19:01.590]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.590]                       if (!identical(...future.globals.maxSize.org, 
[13:19:01.590]                         ...future.globals.maxSize)) {
[13:19:01.590]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.590]                         on.exit(options(oopts), add = TRUE)
[13:19:01.590]                       }
[13:19:01.590]                       {
[13:19:01.590]                         lapply(seq_along(...future.elements_ii), 
[13:19:01.590]                           FUN = function(jj) {
[13:19:01.590]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.590]                             ...future.FUN(...future.X_jj, ...)
[13:19:01.590]                           })
[13:19:01.590]                       }
[13:19:01.590]                     }, args = future.call.arguments)
[13:19:01.590]                   }
[13:19:01.590]                 }, immediateCondition = function(cond) {
[13:19:01.590]                   sendCondition <- ...future.makeSendCondition()
[13:19:01.590]                   sendCondition(cond)
[13:19:01.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.590]                   {
[13:19:01.590]                     inherits <- base::inherits
[13:19:01.590]                     invokeRestart <- base::invokeRestart
[13:19:01.590]                     is.null <- base::is.null
[13:19:01.590]                     muffled <- FALSE
[13:19:01.590]                     if (inherits(cond, "message")) {
[13:19:01.590]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:01.590]                       if (muffled) 
[13:19:01.590]                         invokeRestart("muffleMessage")
[13:19:01.590]                     }
[13:19:01.590]                     else if (inherits(cond, "warning")) {
[13:19:01.590]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:01.590]                       if (muffled) 
[13:19:01.590]                         invokeRestart("muffleWarning")
[13:19:01.590]                     }
[13:19:01.590]                     else if (inherits(cond, "condition")) {
[13:19:01.590]                       if (!is.null(pattern)) {
[13:19:01.590]                         computeRestarts <- base::computeRestarts
[13:19:01.590]                         grepl <- base::grepl
[13:19:01.590]                         restarts <- computeRestarts(cond)
[13:19:01.590]                         for (restart in restarts) {
[13:19:01.590]                           name <- restart$name
[13:19:01.590]                           if (is.null(name)) 
[13:19:01.590]                             next
[13:19:01.590]                           if (!grepl(pattern, name)) 
[13:19:01.590]                             next
[13:19:01.590]                           invokeRestart(restart)
[13:19:01.590]                           muffled <- TRUE
[13:19:01.590]                           break
[13:19:01.590]                         }
[13:19:01.590]                       }
[13:19:01.590]                     }
[13:19:01.590]                     invisible(muffled)
[13:19:01.590]                   }
[13:19:01.590]                   muffleCondition(cond)
[13:19:01.590]                 })
[13:19:01.590]             }))
[13:19:01.590]             future::FutureResult(value = ...future.value$value, 
[13:19:01.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.590]                   ...future.rng), globalenv = if (FALSE) 
[13:19:01.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:01.590]                     ...future.globalenv.names))
[13:19:01.590]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:01.590]         }, condition = base::local({
[13:19:01.590]             c <- base::c
[13:19:01.590]             inherits <- base::inherits
[13:19:01.590]             invokeRestart <- base::invokeRestart
[13:19:01.590]             length <- base::length
[13:19:01.590]             list <- base::list
[13:19:01.590]             seq.int <- base::seq.int
[13:19:01.590]             signalCondition <- base::signalCondition
[13:19:01.590]             sys.calls <- base::sys.calls
[13:19:01.590]             `[[` <- base::`[[`
[13:19:01.590]             `+` <- base::`+`
[13:19:01.590]             `<<-` <- base::`<<-`
[13:19:01.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:01.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:01.590]                   3L)]
[13:19:01.590]             }
[13:19:01.590]             function(cond) {
[13:19:01.590]                 is_error <- inherits(cond, "error")
[13:19:01.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:01.590]                   NULL)
[13:19:01.590]                 if (is_error) {
[13:19:01.590]                   sessionInformation <- function() {
[13:19:01.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:01.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:01.590]                       search = base::search(), system = base::Sys.info())
[13:19:01.590]                   }
[13:19:01.590]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:01.590]                     cond$call), session = sessionInformation(), 
[13:19:01.590]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:01.590]                   signalCondition(cond)
[13:19:01.590]                 }
[13:19:01.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:01.590]                 "immediateCondition"))) {
[13:19:01.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:01.590]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:01.590]                   if (TRUE && !signal) {
[13:19:01.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.590]                     {
[13:19:01.590]                       inherits <- base::inherits
[13:19:01.590]                       invokeRestart <- base::invokeRestart
[13:19:01.590]                       is.null <- base::is.null
[13:19:01.590]                       muffled <- FALSE
[13:19:01.590]                       if (inherits(cond, "message")) {
[13:19:01.590]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.590]                         if (muffled) 
[13:19:01.590]                           invokeRestart("muffleMessage")
[13:19:01.590]                       }
[13:19:01.590]                       else if (inherits(cond, "warning")) {
[13:19:01.590]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.590]                         if (muffled) 
[13:19:01.590]                           invokeRestart("muffleWarning")
[13:19:01.590]                       }
[13:19:01.590]                       else if (inherits(cond, "condition")) {
[13:19:01.590]                         if (!is.null(pattern)) {
[13:19:01.590]                           computeRestarts <- base::computeRestarts
[13:19:01.590]                           grepl <- base::grepl
[13:19:01.590]                           restarts <- computeRestarts(cond)
[13:19:01.590]                           for (restart in restarts) {
[13:19:01.590]                             name <- restart$name
[13:19:01.590]                             if (is.null(name)) 
[13:19:01.590]                               next
[13:19:01.590]                             if (!grepl(pattern, name)) 
[13:19:01.590]                               next
[13:19:01.590]                             invokeRestart(restart)
[13:19:01.590]                             muffled <- TRUE
[13:19:01.590]                             break
[13:19:01.590]                           }
[13:19:01.590]                         }
[13:19:01.590]                       }
[13:19:01.590]                       invisible(muffled)
[13:19:01.590]                     }
[13:19:01.590]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.590]                   }
[13:19:01.590]                 }
[13:19:01.590]                 else {
[13:19:01.590]                   if (TRUE) {
[13:19:01.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.590]                     {
[13:19:01.590]                       inherits <- base::inherits
[13:19:01.590]                       invokeRestart <- base::invokeRestart
[13:19:01.590]                       is.null <- base::is.null
[13:19:01.590]                       muffled <- FALSE
[13:19:01.590]                       if (inherits(cond, "message")) {
[13:19:01.590]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.590]                         if (muffled) 
[13:19:01.590]                           invokeRestart("muffleMessage")
[13:19:01.590]                       }
[13:19:01.590]                       else if (inherits(cond, "warning")) {
[13:19:01.590]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.590]                         if (muffled) 
[13:19:01.590]                           invokeRestart("muffleWarning")
[13:19:01.590]                       }
[13:19:01.590]                       else if (inherits(cond, "condition")) {
[13:19:01.590]                         if (!is.null(pattern)) {
[13:19:01.590]                           computeRestarts <- base::computeRestarts
[13:19:01.590]                           grepl <- base::grepl
[13:19:01.590]                           restarts <- computeRestarts(cond)
[13:19:01.590]                           for (restart in restarts) {
[13:19:01.590]                             name <- restart$name
[13:19:01.590]                             if (is.null(name)) 
[13:19:01.590]                               next
[13:19:01.590]                             if (!grepl(pattern, name)) 
[13:19:01.590]                               next
[13:19:01.590]                             invokeRestart(restart)
[13:19:01.590]                             muffled <- TRUE
[13:19:01.590]                             break
[13:19:01.590]                           }
[13:19:01.590]                         }
[13:19:01.590]                       }
[13:19:01.590]                       invisible(muffled)
[13:19:01.590]                     }
[13:19:01.590]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.590]                   }
[13:19:01.590]                 }
[13:19:01.590]             }
[13:19:01.590]         }))
[13:19:01.590]     }, error = function(ex) {
[13:19:01.590]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:01.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.590]                 ...future.rng), started = ...future.startTime, 
[13:19:01.590]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:01.590]             version = "1.8"), class = "FutureResult")
[13:19:01.590]     }, finally = {
[13:19:01.590]         if (!identical(...future.workdir, getwd())) 
[13:19:01.590]             setwd(...future.workdir)
[13:19:01.590]         {
[13:19:01.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:01.590]                 ...future.oldOptions$nwarnings <- NULL
[13:19:01.590]             }
[13:19:01.590]             base::options(...future.oldOptions)
[13:19:01.590]             if (.Platform$OS.type == "windows") {
[13:19:01.590]                 old_names <- names(...future.oldEnvVars)
[13:19:01.590]                 envs <- base::Sys.getenv()
[13:19:01.590]                 names <- names(envs)
[13:19:01.590]                 common <- intersect(names, old_names)
[13:19:01.590]                 added <- setdiff(names, old_names)
[13:19:01.590]                 removed <- setdiff(old_names, names)
[13:19:01.590]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:01.590]                   envs[common]]
[13:19:01.590]                 NAMES <- toupper(changed)
[13:19:01.590]                 args <- list()
[13:19:01.590]                 for (kk in seq_along(NAMES)) {
[13:19:01.590]                   name <- changed[[kk]]
[13:19:01.590]                   NAME <- NAMES[[kk]]
[13:19:01.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.590]                     next
[13:19:01.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.590]                 }
[13:19:01.590]                 NAMES <- toupper(added)
[13:19:01.590]                 for (kk in seq_along(NAMES)) {
[13:19:01.590]                   name <- added[[kk]]
[13:19:01.590]                   NAME <- NAMES[[kk]]
[13:19:01.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.590]                     next
[13:19:01.590]                   args[[name]] <- ""
[13:19:01.590]                 }
[13:19:01.590]                 NAMES <- toupper(removed)
[13:19:01.590]                 for (kk in seq_along(NAMES)) {
[13:19:01.590]                   name <- removed[[kk]]
[13:19:01.590]                   NAME <- NAMES[[kk]]
[13:19:01.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.590]                     next
[13:19:01.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.590]                 }
[13:19:01.590]                 if (length(args) > 0) 
[13:19:01.590]                   base::do.call(base::Sys.setenv, args = args)
[13:19:01.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:01.590]             }
[13:19:01.590]             else {
[13:19:01.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:01.590]             }
[13:19:01.590]             {
[13:19:01.590]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:01.590]                   0L) {
[13:19:01.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:01.590]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:01.590]                   base::options(opts)
[13:19:01.590]                 }
[13:19:01.590]                 {
[13:19:01.590]                   {
[13:19:01.590]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:01.590]                     NULL
[13:19:01.590]                   }
[13:19:01.590]                   options(future.plan = NULL)
[13:19:01.590]                   if (is.na(NA_character_)) 
[13:19:01.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:01.590]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:01.590]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:01.590]                     envir = parent.frame()) 
[13:19:01.590]                   {
[13:19:01.590]                     if (is.function(workers)) 
[13:19:01.590]                       workers <- workers()
[13:19:01.590]                     workers <- structure(as.integer(workers), 
[13:19:01.590]                       class = class(workers))
[13:19:01.590]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:01.590]                       workers >= 1)
[13:19:01.590]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:01.590]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:01.590]                     }
[13:19:01.590]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:01.590]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:01.590]                       envir = envir)
[13:19:01.590]                     if (!future$lazy) 
[13:19:01.590]                       future <- run(future)
[13:19:01.590]                     invisible(future)
[13:19:01.590]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:01.590]                 }
[13:19:01.590]             }
[13:19:01.590]         }
[13:19:01.590]     })
[13:19:01.590]     if (TRUE) {
[13:19:01.590]         base::sink(type = "output", split = FALSE)
[13:19:01.590]         if (TRUE) {
[13:19:01.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:01.590]         }
[13:19:01.590]         else {
[13:19:01.590]             ...future.result["stdout"] <- base::list(NULL)
[13:19:01.590]         }
[13:19:01.590]         base::close(...future.stdout)
[13:19:01.590]         ...future.stdout <- NULL
[13:19:01.590]     }
[13:19:01.590]     ...future.result$conditions <- ...future.conditions
[13:19:01.590]     ...future.result$finished <- base::Sys.time()
[13:19:01.590]     ...future.result
[13:19:01.590] }
[13:19:01.593] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[13:19:01.594] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:01.637] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:01.637] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:19:01.638] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:19:01.638] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:01.638] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:01.638] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:01.681] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:01.681] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:01.725] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:01.725] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:01.725] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.726] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:01.726] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:01.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:01.727] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.727] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:01.727] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:01.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:01.728] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.728] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:01.728] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:01.728] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[13:19:01.729] MultisessionFuture started
[13:19:01.729] - Launch lazy future ... done
[13:19:01.729] run() for ‘MultisessionFuture’ ... done
[13:19:01.729] Created future:
[13:19:01.730] MultisessionFuture:
[13:19:01.730] Label: ‘future_vapply-1’
[13:19:01.730] Expression:
[13:19:01.730] {
[13:19:01.730]     do.call(function(...) {
[13:19:01.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.730]             on.exit(options(oopts), add = TRUE)
[13:19:01.730]         }
[13:19:01.730]         {
[13:19:01.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.730]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.730]             })
[13:19:01.730]         }
[13:19:01.730]     }, args = future.call.arguments)
[13:19:01.730] }
[13:19:01.730] Lazy evaluation: FALSE
[13:19:01.730] Asynchronous evaluation: TRUE
[13:19:01.730] Local evaluation: TRUE
[13:19:01.730] Environment: R_GlobalEnv
[13:19:01.730] Capture standard output: TRUE
[13:19:01.730] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:01.730] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:01.730] Packages: 1 packages (‘future.apply’)
[13:19:01.730] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:01.730] Resolved: FALSE
[13:19:01.730] Value: <not collected>
[13:19:01.730] Conditions captured: <none>
[13:19:01.730] Early signaling: FALSE
[13:19:01.730] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:01.730] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.741] Chunk #1 of 2 ... DONE
[13:19:01.741] Chunk #2 of 2 ...
[13:19:01.742]  - Finding globals in 'X' for chunk #2 ...
[13:19:01.742] getGlobalsAndPackages() ...
[13:19:01.742] Searching for globals...
[13:19:01.742] 
[13:19:01.742] Searching for globals ... DONE
[13:19:01.742] - globals: [0] <none>
[13:19:01.742] getGlobalsAndPackages() ... DONE
[13:19:01.742]    + additional globals found: [n=0] 
[13:19:01.743]    + additional namespaces needed: [n=0] 
[13:19:01.743]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:01.743]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:01.743]  - seeds: <none>
[13:19:01.743] getGlobalsAndPackages() ...
[13:19:01.743] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.743] Resolving globals: FALSE
[13:19:01.743] Tweak future expression to call with '...' arguments ...
[13:19:01.743] {
[13:19:01.743]     do.call(function(...) {
[13:19:01.743]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.743]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.743]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.743]             on.exit(options(oopts), add = TRUE)
[13:19:01.743]         }
[13:19:01.743]         {
[13:19:01.743]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.743]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.743]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.743]             })
[13:19:01.743]         }
[13:19:01.743]     }, args = future.call.arguments)
[13:19:01.743] }
[13:19:01.744] Tweak future expression to call with '...' arguments ... DONE
[13:19:01.744] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.744] - packages: [1] ‘future.apply’
[13:19:01.744] getGlobalsAndPackages() ... DONE
[13:19:01.745] run() for ‘Future’ ...
[13:19:01.745] - state: ‘created’
[13:19:01.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:01.760] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:01.760]   - Field: ‘node’
[13:19:01.760]   - Field: ‘label’
[13:19:01.760]   - Field: ‘local’
[13:19:01.760]   - Field: ‘owner’
[13:19:01.761]   - Field: ‘envir’
[13:19:01.761]   - Field: ‘workers’
[13:19:01.761]   - Field: ‘packages’
[13:19:01.761]   - Field: ‘gc’
[13:19:01.761]   - Field: ‘conditions’
[13:19:01.761]   - Field: ‘persistent’
[13:19:01.761]   - Field: ‘expr’
[13:19:01.761]   - Field: ‘uuid’
[13:19:01.761]   - Field: ‘seed’
[13:19:01.761]   - Field: ‘version’
[13:19:01.761]   - Field: ‘result’
[13:19:01.762]   - Field: ‘asynchronous’
[13:19:01.762]   - Field: ‘calls’
[13:19:01.762]   - Field: ‘globals’
[13:19:01.762]   - Field: ‘stdout’
[13:19:01.762]   - Field: ‘earlySignal’
[13:19:01.762]   - Field: ‘lazy’
[13:19:01.762]   - Field: ‘state’
[13:19:01.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:01.762] - Launch lazy future ...
[13:19:01.763] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:01.763] Packages needed by future strategies (n = 0): <none>
[13:19:01.763] {
[13:19:01.763]     {
[13:19:01.763]         {
[13:19:01.763]             ...future.startTime <- base::Sys.time()
[13:19:01.763]             {
[13:19:01.763]                 {
[13:19:01.763]                   {
[13:19:01.763]                     {
[13:19:01.763]                       {
[13:19:01.763]                         base::local({
[13:19:01.763]                           has_future <- base::requireNamespace("future", 
[13:19:01.763]                             quietly = TRUE)
[13:19:01.763]                           if (has_future) {
[13:19:01.763]                             ns <- base::getNamespace("future")
[13:19:01.763]                             version <- ns[[".package"]][["version"]]
[13:19:01.763]                             if (is.null(version)) 
[13:19:01.763]                               version <- utils::packageVersion("future")
[13:19:01.763]                           }
[13:19:01.763]                           else {
[13:19:01.763]                             version <- NULL
[13:19:01.763]                           }
[13:19:01.763]                           if (!has_future || version < "1.8.0") {
[13:19:01.763]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:01.763]                               "", base::R.version$version.string), 
[13:19:01.763]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:01.763]                                 base::R.version$platform, 8 * 
[13:19:01.763]                                   base::.Machine$sizeof.pointer), 
[13:19:01.763]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:01.763]                                 "release", "version")], collapse = " "), 
[13:19:01.763]                               hostname = base::Sys.info()[["nodename"]])
[13:19:01.763]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:01.763]                               info)
[13:19:01.763]                             info <- base::paste(info, collapse = "; ")
[13:19:01.763]                             if (!has_future) {
[13:19:01.763]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:01.763]                                 info)
[13:19:01.763]                             }
[13:19:01.763]                             else {
[13:19:01.763]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:01.763]                                 info, version)
[13:19:01.763]                             }
[13:19:01.763]                             base::stop(msg)
[13:19:01.763]                           }
[13:19:01.763]                         })
[13:19:01.763]                       }
[13:19:01.763]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:01.763]                       base::options(mc.cores = 1L)
[13:19:01.763]                     }
[13:19:01.763]                     base::local({
[13:19:01.763]                       for (pkg in "future.apply") {
[13:19:01.763]                         base::loadNamespace(pkg)
[13:19:01.763]                         base::library(pkg, character.only = TRUE)
[13:19:01.763]                       }
[13:19:01.763]                     })
[13:19:01.763]                   }
[13:19:01.763]                   options(future.plan = NULL)
[13:19:01.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:01.763]                 }
[13:19:01.763]                 ...future.workdir <- getwd()
[13:19:01.763]             }
[13:19:01.763]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:01.763]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:01.763]         }
[13:19:01.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:01.763]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:01.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:01.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:01.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:01.763]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:01.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:01.763]             base::names(...future.oldOptions))
[13:19:01.763]     }
[13:19:01.763]     if (FALSE) {
[13:19:01.763]     }
[13:19:01.763]     else {
[13:19:01.763]         if (TRUE) {
[13:19:01.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:01.763]                 open = "w")
[13:19:01.763]         }
[13:19:01.763]         else {
[13:19:01.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:01.763]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:01.763]         }
[13:19:01.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:01.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:01.763]             base::sink(type = "output", split = FALSE)
[13:19:01.763]             base::close(...future.stdout)
[13:19:01.763]         }, add = TRUE)
[13:19:01.763]     }
[13:19:01.763]     ...future.frame <- base::sys.nframe()
[13:19:01.763]     ...future.conditions <- base::list()
[13:19:01.763]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:01.763]     if (FALSE) {
[13:19:01.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:01.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:01.763]     }
[13:19:01.763]     ...future.result <- base::tryCatch({
[13:19:01.763]         base::withCallingHandlers({
[13:19:01.763]             ...future.value <- base::withVisible(base::local({
[13:19:01.763]                 ...future.makeSendCondition <- local({
[13:19:01.763]                   sendCondition <- NULL
[13:19:01.763]                   function(frame = 1L) {
[13:19:01.763]                     if (is.function(sendCondition)) 
[13:19:01.763]                       return(sendCondition)
[13:19:01.763]                     ns <- getNamespace("parallel")
[13:19:01.763]                     if (exists("sendData", mode = "function", 
[13:19:01.763]                       envir = ns)) {
[13:19:01.763]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:01.763]                         envir = ns)
[13:19:01.763]                       envir <- sys.frame(frame)
[13:19:01.763]                       master <- NULL
[13:19:01.763]                       while (!identical(envir, .GlobalEnv) && 
[13:19:01.763]                         !identical(envir, emptyenv())) {
[13:19:01.763]                         if (exists("master", mode = "list", envir = envir, 
[13:19:01.763]                           inherits = FALSE)) {
[13:19:01.763]                           master <- get("master", mode = "list", 
[13:19:01.763]                             envir = envir, inherits = FALSE)
[13:19:01.763]                           if (inherits(master, c("SOCKnode", 
[13:19:01.763]                             "SOCK0node"))) {
[13:19:01.763]                             sendCondition <<- function(cond) {
[13:19:01.763]                               data <- list(type = "VALUE", value = cond, 
[13:19:01.763]                                 success = TRUE)
[13:19:01.763]                               parallel_sendData(master, data)
[13:19:01.763]                             }
[13:19:01.763]                             return(sendCondition)
[13:19:01.763]                           }
[13:19:01.763]                         }
[13:19:01.763]                         frame <- frame + 1L
[13:19:01.763]                         envir <- sys.frame(frame)
[13:19:01.763]                       }
[13:19:01.763]                     }
[13:19:01.763]                     sendCondition <<- function(cond) NULL
[13:19:01.763]                   }
[13:19:01.763]                 })
[13:19:01.763]                 withCallingHandlers({
[13:19:01.763]                   {
[13:19:01.763]                     do.call(function(...) {
[13:19:01.763]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.763]                       if (!identical(...future.globals.maxSize.org, 
[13:19:01.763]                         ...future.globals.maxSize)) {
[13:19:01.763]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.763]                         on.exit(options(oopts), add = TRUE)
[13:19:01.763]                       }
[13:19:01.763]                       {
[13:19:01.763]                         lapply(seq_along(...future.elements_ii), 
[13:19:01.763]                           FUN = function(jj) {
[13:19:01.763]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.763]                             ...future.FUN(...future.X_jj, ...)
[13:19:01.763]                           })
[13:19:01.763]                       }
[13:19:01.763]                     }, args = future.call.arguments)
[13:19:01.763]                   }
[13:19:01.763]                 }, immediateCondition = function(cond) {
[13:19:01.763]                   sendCondition <- ...future.makeSendCondition()
[13:19:01.763]                   sendCondition(cond)
[13:19:01.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.763]                   {
[13:19:01.763]                     inherits <- base::inherits
[13:19:01.763]                     invokeRestart <- base::invokeRestart
[13:19:01.763]                     is.null <- base::is.null
[13:19:01.763]                     muffled <- FALSE
[13:19:01.763]                     if (inherits(cond, "message")) {
[13:19:01.763]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:01.763]                       if (muffled) 
[13:19:01.763]                         invokeRestart("muffleMessage")
[13:19:01.763]                     }
[13:19:01.763]                     else if (inherits(cond, "warning")) {
[13:19:01.763]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:01.763]                       if (muffled) 
[13:19:01.763]                         invokeRestart("muffleWarning")
[13:19:01.763]                     }
[13:19:01.763]                     else if (inherits(cond, "condition")) {
[13:19:01.763]                       if (!is.null(pattern)) {
[13:19:01.763]                         computeRestarts <- base::computeRestarts
[13:19:01.763]                         grepl <- base::grepl
[13:19:01.763]                         restarts <- computeRestarts(cond)
[13:19:01.763]                         for (restart in restarts) {
[13:19:01.763]                           name <- restart$name
[13:19:01.763]                           if (is.null(name)) 
[13:19:01.763]                             next
[13:19:01.763]                           if (!grepl(pattern, name)) 
[13:19:01.763]                             next
[13:19:01.763]                           invokeRestart(restart)
[13:19:01.763]                           muffled <- TRUE
[13:19:01.763]                           break
[13:19:01.763]                         }
[13:19:01.763]                       }
[13:19:01.763]                     }
[13:19:01.763]                     invisible(muffled)
[13:19:01.763]                   }
[13:19:01.763]                   muffleCondition(cond)
[13:19:01.763]                 })
[13:19:01.763]             }))
[13:19:01.763]             future::FutureResult(value = ...future.value$value, 
[13:19:01.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.763]                   ...future.rng), globalenv = if (FALSE) 
[13:19:01.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:01.763]                     ...future.globalenv.names))
[13:19:01.763]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:01.763]         }, condition = base::local({
[13:19:01.763]             c <- base::c
[13:19:01.763]             inherits <- base::inherits
[13:19:01.763]             invokeRestart <- base::invokeRestart
[13:19:01.763]             length <- base::length
[13:19:01.763]             list <- base::list
[13:19:01.763]             seq.int <- base::seq.int
[13:19:01.763]             signalCondition <- base::signalCondition
[13:19:01.763]             sys.calls <- base::sys.calls
[13:19:01.763]             `[[` <- base::`[[`
[13:19:01.763]             `+` <- base::`+`
[13:19:01.763]             `<<-` <- base::`<<-`
[13:19:01.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:01.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:01.763]                   3L)]
[13:19:01.763]             }
[13:19:01.763]             function(cond) {
[13:19:01.763]                 is_error <- inherits(cond, "error")
[13:19:01.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:01.763]                   NULL)
[13:19:01.763]                 if (is_error) {
[13:19:01.763]                   sessionInformation <- function() {
[13:19:01.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:01.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:01.763]                       search = base::search(), system = base::Sys.info())
[13:19:01.763]                   }
[13:19:01.763]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:01.763]                     cond$call), session = sessionInformation(), 
[13:19:01.763]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:01.763]                   signalCondition(cond)
[13:19:01.763]                 }
[13:19:01.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:01.763]                 "immediateCondition"))) {
[13:19:01.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:01.763]                   ...future.conditions[[length(...future.conditions) + 
[13:19:01.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:01.763]                   if (TRUE && !signal) {
[13:19:01.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.763]                     {
[13:19:01.763]                       inherits <- base::inherits
[13:19:01.763]                       invokeRestart <- base::invokeRestart
[13:19:01.763]                       is.null <- base::is.null
[13:19:01.763]                       muffled <- FALSE
[13:19:01.763]                       if (inherits(cond, "message")) {
[13:19:01.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.763]                         if (muffled) 
[13:19:01.763]                           invokeRestart("muffleMessage")
[13:19:01.763]                       }
[13:19:01.763]                       else if (inherits(cond, "warning")) {
[13:19:01.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.763]                         if (muffled) 
[13:19:01.763]                           invokeRestart("muffleWarning")
[13:19:01.763]                       }
[13:19:01.763]                       else if (inherits(cond, "condition")) {
[13:19:01.763]                         if (!is.null(pattern)) {
[13:19:01.763]                           computeRestarts <- base::computeRestarts
[13:19:01.763]                           grepl <- base::grepl
[13:19:01.763]                           restarts <- computeRestarts(cond)
[13:19:01.763]                           for (restart in restarts) {
[13:19:01.763]                             name <- restart$name
[13:19:01.763]                             if (is.null(name)) 
[13:19:01.763]                               next
[13:19:01.763]                             if (!grepl(pattern, name)) 
[13:19:01.763]                               next
[13:19:01.763]                             invokeRestart(restart)
[13:19:01.763]                             muffled <- TRUE
[13:19:01.763]                             break
[13:19:01.763]                           }
[13:19:01.763]                         }
[13:19:01.763]                       }
[13:19:01.763]                       invisible(muffled)
[13:19:01.763]                     }
[13:19:01.763]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.763]                   }
[13:19:01.763]                 }
[13:19:01.763]                 else {
[13:19:01.763]                   if (TRUE) {
[13:19:01.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:01.763]                     {
[13:19:01.763]                       inherits <- base::inherits
[13:19:01.763]                       invokeRestart <- base::invokeRestart
[13:19:01.763]                       is.null <- base::is.null
[13:19:01.763]                       muffled <- FALSE
[13:19:01.763]                       if (inherits(cond, "message")) {
[13:19:01.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:01.763]                         if (muffled) 
[13:19:01.763]                           invokeRestart("muffleMessage")
[13:19:01.763]                       }
[13:19:01.763]                       else if (inherits(cond, "warning")) {
[13:19:01.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:01.763]                         if (muffled) 
[13:19:01.763]                           invokeRestart("muffleWarning")
[13:19:01.763]                       }
[13:19:01.763]                       else if (inherits(cond, "condition")) {
[13:19:01.763]                         if (!is.null(pattern)) {
[13:19:01.763]                           computeRestarts <- base::computeRestarts
[13:19:01.763]                           grepl <- base::grepl
[13:19:01.763]                           restarts <- computeRestarts(cond)
[13:19:01.763]                           for (restart in restarts) {
[13:19:01.763]                             name <- restart$name
[13:19:01.763]                             if (is.null(name)) 
[13:19:01.763]                               next
[13:19:01.763]                             if (!grepl(pattern, name)) 
[13:19:01.763]                               next
[13:19:01.763]                             invokeRestart(restart)
[13:19:01.763]                             muffled <- TRUE
[13:19:01.763]                             break
[13:19:01.763]                           }
[13:19:01.763]                         }
[13:19:01.763]                       }
[13:19:01.763]                       invisible(muffled)
[13:19:01.763]                     }
[13:19:01.763]                     muffleCondition(cond, pattern = "^muffle")
[13:19:01.763]                   }
[13:19:01.763]                 }
[13:19:01.763]             }
[13:19:01.763]         }))
[13:19:01.763]     }, error = function(ex) {
[13:19:01.763]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:01.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:01.763]                 ...future.rng), started = ...future.startTime, 
[13:19:01.763]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:01.763]             version = "1.8"), class = "FutureResult")
[13:19:01.763]     }, finally = {
[13:19:01.763]         if (!identical(...future.workdir, getwd())) 
[13:19:01.763]             setwd(...future.workdir)
[13:19:01.763]         {
[13:19:01.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:01.763]                 ...future.oldOptions$nwarnings <- NULL
[13:19:01.763]             }
[13:19:01.763]             base::options(...future.oldOptions)
[13:19:01.763]             if (.Platform$OS.type == "windows") {
[13:19:01.763]                 old_names <- names(...future.oldEnvVars)
[13:19:01.763]                 envs <- base::Sys.getenv()
[13:19:01.763]                 names <- names(envs)
[13:19:01.763]                 common <- intersect(names, old_names)
[13:19:01.763]                 added <- setdiff(names, old_names)
[13:19:01.763]                 removed <- setdiff(old_names, names)
[13:19:01.763]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:01.763]                   envs[common]]
[13:19:01.763]                 NAMES <- toupper(changed)
[13:19:01.763]                 args <- list()
[13:19:01.763]                 for (kk in seq_along(NAMES)) {
[13:19:01.763]                   name <- changed[[kk]]
[13:19:01.763]                   NAME <- NAMES[[kk]]
[13:19:01.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.763]                     next
[13:19:01.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.763]                 }
[13:19:01.763]                 NAMES <- toupper(added)
[13:19:01.763]                 for (kk in seq_along(NAMES)) {
[13:19:01.763]                   name <- added[[kk]]
[13:19:01.763]                   NAME <- NAMES[[kk]]
[13:19:01.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.763]                     next
[13:19:01.763]                   args[[name]] <- ""
[13:19:01.763]                 }
[13:19:01.763]                 NAMES <- toupper(removed)
[13:19:01.763]                 for (kk in seq_along(NAMES)) {
[13:19:01.763]                   name <- removed[[kk]]
[13:19:01.763]                   NAME <- NAMES[[kk]]
[13:19:01.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:01.763]                     next
[13:19:01.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:01.763]                 }
[13:19:01.763]                 if (length(args) > 0) 
[13:19:01.763]                   base::do.call(base::Sys.setenv, args = args)
[13:19:01.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:01.763]             }
[13:19:01.763]             else {
[13:19:01.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:01.763]             }
[13:19:01.763]             {
[13:19:01.763]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:01.763]                   0L) {
[13:19:01.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:01.763]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:01.763]                   base::options(opts)
[13:19:01.763]                 }
[13:19:01.763]                 {
[13:19:01.763]                   {
[13:19:01.763]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:01.763]                     NULL
[13:19:01.763]                   }
[13:19:01.763]                   options(future.plan = NULL)
[13:19:01.763]                   if (is.na(NA_character_)) 
[13:19:01.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:01.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:01.763]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:01.763]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:01.763]                     envir = parent.frame()) 
[13:19:01.763]                   {
[13:19:01.763]                     if (is.function(workers)) 
[13:19:01.763]                       workers <- workers()
[13:19:01.763]                     workers <- structure(as.integer(workers), 
[13:19:01.763]                       class = class(workers))
[13:19:01.763]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:01.763]                       workers >= 1)
[13:19:01.763]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:01.763]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:01.763]                     }
[13:19:01.763]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:01.763]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:01.763]                       envir = envir)
[13:19:01.763]                     if (!future$lazy) 
[13:19:01.763]                       future <- run(future)
[13:19:01.763]                     invisible(future)
[13:19:01.763]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:01.763]                 }
[13:19:01.763]             }
[13:19:01.763]         }
[13:19:01.763]     })
[13:19:01.763]     if (TRUE) {
[13:19:01.763]         base::sink(type = "output", split = FALSE)
[13:19:01.763]         if (TRUE) {
[13:19:01.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:01.763]         }
[13:19:01.763]         else {
[13:19:01.763]             ...future.result["stdout"] <- base::list(NULL)
[13:19:01.763]         }
[13:19:01.763]         base::close(...future.stdout)
[13:19:01.763]         ...future.stdout <- NULL
[13:19:01.763]     }
[13:19:01.763]     ...future.result$conditions <- ...future.conditions
[13:19:01.763]     ...future.result$finished <- base::Sys.time()
[13:19:01.763]     ...future.result
[13:19:01.763] }
[13:19:01.766] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[13:19:01.766] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:01.813] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:01.813] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[13:19:01.814] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[13:19:01.814] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:01.814] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:01.814] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:01.857] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:01.857] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:01.901] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:01.901] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:01.901] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.902] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:01.902] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:01.902] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:01.903] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.903] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:01.903] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:01.903] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:01.904] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:01.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:01.904] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[13:19:01.905] MultisessionFuture started
[13:19:01.905] - Launch lazy future ... done
[13:19:01.905] run() for ‘MultisessionFuture’ ... done
[13:19:01.905] Created future:
[13:19:01.905] MultisessionFuture:
[13:19:01.905] Label: ‘future_vapply-2’
[13:19:01.905] Expression:
[13:19:01.905] {
[13:19:01.905]     do.call(function(...) {
[13:19:01.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.905]             on.exit(options(oopts), add = TRUE)
[13:19:01.905]         }
[13:19:01.905]         {
[13:19:01.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.905]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.905]             })
[13:19:01.905]         }
[13:19:01.905]     }, args = future.call.arguments)
[13:19:01.905] }
[13:19:01.905] Lazy evaluation: FALSE
[13:19:01.905] Asynchronous evaluation: TRUE
[13:19:01.905] Local evaluation: TRUE
[13:19:01.905] Environment: R_GlobalEnv
[13:19:01.905] Capture standard output: TRUE
[13:19:01.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:01.905] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:01.905] Packages: 1 packages (‘future.apply’)
[13:19:01.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:01.905] Resolved: FALSE
[13:19:01.905] Value: <not collected>
[13:19:01.905] Conditions captured: <none>
[13:19:01.905] Early signaling: FALSE
[13:19:01.905] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:01.905] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:01.917] Chunk #2 of 2 ... DONE
[13:19:01.917] Launching 2 futures (chunks) ... DONE
[13:19:01.917] Resolving 2 futures (chunks) ...
[13:19:01.917] resolve() on list ...
[13:19:01.917]  recursive: 0
[13:19:01.918]  length: 2
[13:19:01.918] 
[13:19:01.918] receiveMessageFromWorker() for ClusterFuture ...
[13:19:01.918] - Validating connection of MultisessionFuture
[13:19:01.918] - received message: FutureResult
[13:19:01.919] - Received FutureResult
[13:19:01.919] - Erased future from FutureRegistry
[13:19:01.919] result() for ClusterFuture ...
[13:19:01.919] - result already collected: FutureResult
[13:19:01.919] result() for ClusterFuture ... done
[13:19:01.919] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:01.919] Future #1
[13:19:01.919] result() for ClusterFuture ...
[13:19:01.919] - result already collected: FutureResult
[13:19:01.919] result() for ClusterFuture ... done
[13:19:01.919] result() for ClusterFuture ...
[13:19:01.920] - result already collected: FutureResult
[13:19:01.920] result() for ClusterFuture ... done
[13:19:01.920] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:01.920] - nx: 2
[13:19:01.920] - relay: TRUE
[13:19:01.920] - stdout: TRUE
[13:19:01.920] - signal: TRUE
[13:19:01.920] - resignal: FALSE
[13:19:01.920] - force: TRUE
[13:19:01.920] - relayed: [n=2] FALSE, FALSE
[13:19:01.920] - queued futures: [n=2] FALSE, FALSE
[13:19:01.920]  - until=1
[13:19:01.921]  - relaying element #1
[13:19:01.921] result() for ClusterFuture ...
[13:19:01.921] - result already collected: FutureResult
[13:19:01.921] result() for ClusterFuture ... done
[13:19:01.921] result() for ClusterFuture ...
[13:19:01.921] - result already collected: FutureResult
[13:19:01.921] result() for ClusterFuture ... done
[13:19:01.921] result() for ClusterFuture ...
[13:19:01.921] - result already collected: FutureResult
[13:19:01.921] result() for ClusterFuture ... done
[13:19:01.922] result() for ClusterFuture ...
[13:19:01.922] - result already collected: FutureResult
[13:19:01.922] result() for ClusterFuture ... done
[13:19:01.922] - relayed: [n=2] TRUE, FALSE
[13:19:01.922] - queued futures: [n=2] TRUE, FALSE
[13:19:01.922] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:01.922]  length: 1 (resolved future 1)
[13:19:01.964] receiveMessageFromWorker() for ClusterFuture ...
[13:19:01.964] - Validating connection of MultisessionFuture
[13:19:01.964] - received message: FutureResult
[13:19:01.964] - Received FutureResult
[13:19:01.965] - Erased future from FutureRegistry
[13:19:01.965] result() for ClusterFuture ...
[13:19:01.965] - result already collected: FutureResult
[13:19:01.965] result() for ClusterFuture ... done
[13:19:01.965] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:01.965] Future #2
[13:19:01.965] result() for ClusterFuture ...
[13:19:01.965] - result already collected: FutureResult
[13:19:01.965] result() for ClusterFuture ... done
[13:19:01.965] result() for ClusterFuture ...
[13:19:01.966] - result already collected: FutureResult
[13:19:01.966] result() for ClusterFuture ... done
[13:19:01.966] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:01.966] - nx: 2
[13:19:01.966] - relay: TRUE
[13:19:01.966] - stdout: TRUE
[13:19:01.966] - signal: TRUE
[13:19:01.966] - resignal: FALSE
[13:19:01.966] - force: TRUE
[13:19:01.966] - relayed: [n=2] TRUE, FALSE
[13:19:01.966] - queued futures: [n=2] TRUE, FALSE
[13:19:01.966]  - until=2
[13:19:01.967]  - relaying element #2
[13:19:01.967] result() for ClusterFuture ...
[13:19:01.967] - result already collected: FutureResult
[13:19:01.967] result() for ClusterFuture ... done
[13:19:01.967] result() for ClusterFuture ...
[13:19:01.967] - result already collected: FutureResult
[13:19:01.967] result() for ClusterFuture ... done
[13:19:01.967] result() for ClusterFuture ...
[13:19:01.967] - result already collected: FutureResult
[13:19:01.967] result() for ClusterFuture ... done
[13:19:01.968] result() for ClusterFuture ...
[13:19:01.968] - result already collected: FutureResult
[13:19:01.968] result() for ClusterFuture ... done
[13:19:01.968] - relayed: [n=2] TRUE, TRUE
[13:19:01.968] - queued futures: [n=2] TRUE, TRUE
[13:19:01.968] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:01.968]  length: 0 (resolved future 2)
[13:19:01.968] Relaying remaining futures
[13:19:01.968] signalConditionsASAP(NULL, pos=0) ...
[13:19:01.968] - nx: 2
[13:19:01.968] - relay: TRUE
[13:19:01.968] - stdout: TRUE
[13:19:01.969] - signal: TRUE
[13:19:01.969] - resignal: FALSE
[13:19:01.969] - force: TRUE
[13:19:01.969] - relayed: [n=2] TRUE, TRUE
[13:19:01.969] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:01.969] - relayed: [n=2] TRUE, TRUE
[13:19:01.969] - queued futures: [n=2] TRUE, TRUE
[13:19:01.969] signalConditionsASAP(NULL, pos=0) ... done
[13:19:01.969] resolve() on list ... DONE
[13:19:01.969] result() for ClusterFuture ...
[13:19:01.969] - result already collected: FutureResult
[13:19:01.970] result() for ClusterFuture ... done
[13:19:01.970] result() for ClusterFuture ...
[13:19:01.970] - result already collected: FutureResult
[13:19:01.970] result() for ClusterFuture ... done
[13:19:01.970] result() for ClusterFuture ...
[13:19:01.970] - result already collected: FutureResult
[13:19:01.970] result() for ClusterFuture ... done
[13:19:01.970] result() for ClusterFuture ...
[13:19:01.970] - result already collected: FutureResult
[13:19:01.970] result() for ClusterFuture ... done
[13:19:01.970]  - Number of value chunks collected: 2
[13:19:01.971] Resolving 2 futures (chunks) ... DONE
[13:19:01.971] Reducing values from 2 chunks ...
[13:19:01.971]  - Number of values collected after concatenation: 10
[13:19:01.971]  - Number of values expected: 10
[13:19:01.971] Reducing values from 2 chunks ... DONE
[13:19:01.971] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:19:01.972] future_lapply() ...
[13:19:01.979] Number of chunks: 2
[13:19:01.979] getGlobalsAndPackagesXApply() ...
[13:19:01.980]  - future.globals: TRUE
[13:19:01.980] getGlobalsAndPackages() ...
[13:19:01.980] Searching for globals...
[13:19:01.983] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:19:01.983] Searching for globals ... DONE
[13:19:01.983] Resolving globals: FALSE
[13:19:01.984] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:19:01.985] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:01.985] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:01.985] - packages: [1] ‘future.apply’
[13:19:01.985] getGlobalsAndPackages() ... DONE
[13:19:01.985]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:01.985]  - needed namespaces: [n=1] ‘future.apply’
[13:19:01.985] Finding globals ... DONE
[13:19:01.985]  - use_args: TRUE
[13:19:01.985]  - Getting '...' globals ...
[13:19:01.986] resolve() on list ...
[13:19:01.986]  recursive: 0
[13:19:01.986]  length: 1
[13:19:01.986]  elements: ‘...’
[13:19:01.986]  length: 0 (resolved future 1)
[13:19:01.986] resolve() on list ... DONE
[13:19:01.986]    - '...' content: [n=0] 
[13:19:01.986] List of 1
[13:19:01.986]  $ ...: list()
[13:19:01.986]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:01.986]  - attr(*, "where")=List of 1
[13:19:01.986]   ..$ ...:<environment: 0x555f7e29f2a8> 
[13:19:01.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:01.986]  - attr(*, "resolved")= logi TRUE
[13:19:01.986]  - attr(*, "total_size")= num NA
[13:19:01.989]  - Getting '...' globals ... DONE
[13:19:01.989] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:01.989] List of 8
[13:19:01.989]  $ ...future.FUN:function (x, ...)  
[13:19:01.989]  $ x_FUN        :function (x)  
[13:19:01.989]  $ times        : int 0
[13:19:01.989]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:01.989]  $ stop_if_not  :function (...)  
[13:19:01.989]  $ dim          : NULL
[13:19:01.989]  $ valid_types  : chr [1:2] "logical" "integer"
[13:19:01.989]  $ ...          : list()
[13:19:01.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:01.989]  - attr(*, "where")=List of 8
[13:19:01.989]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:01.989]   ..$ ...          :<environment: 0x555f7e29f2a8> 
[13:19:01.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:01.989]  - attr(*, "resolved")= logi FALSE
[13:19:01.989]  - attr(*, "total_size")= num 95400
[13:19:01.994] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:01.995] getGlobalsAndPackagesXApply() ... DONE
[13:19:01.995] Number of futures (= number of chunks): 2
[13:19:01.995] Launching 2 futures (chunks) ...
[13:19:01.995] Chunk #1 of 2 ...
[13:19:01.995]  - Finding globals in 'X' for chunk #1 ...
[13:19:01.995] getGlobalsAndPackages() ...
[13:19:01.995] Searching for globals...
[13:19:01.996] 
[13:19:01.996] Searching for globals ... DONE
[13:19:01.996] - globals: [0] <none>
[13:19:01.996] getGlobalsAndPackages() ... DONE
[13:19:01.996]    + additional globals found: [n=0] 
[13:19:01.996]    + additional namespaces needed: [n=0] 
[13:19:01.996]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:01.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:01.996]  - seeds: <none>
[13:19:01.996] getGlobalsAndPackages() ...
[13:19:01.996] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.997] Resolving globals: FALSE
[13:19:01.997] Tweak future expression to call with '...' arguments ...
[13:19:01.997] {
[13:19:01.997]     do.call(function(...) {
[13:19:01.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:01.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:01.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:01.997]             on.exit(options(oopts), add = TRUE)
[13:19:01.997]         }
[13:19:01.997]         {
[13:19:01.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:01.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:01.997]                 ...future.FUN(...future.X_jj, ...)
[13:19:01.997]             })
[13:19:01.997]         }
[13:19:01.997]     }, args = future.call.arguments)
[13:19:01.997] }
[13:19:01.997] Tweak future expression to call with '...' arguments ... DONE
[13:19:01.998] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:01.998] - packages: [1] ‘future.apply’
[13:19:01.998] getGlobalsAndPackages() ... DONE
[13:19:01.998] run() for ‘Future’ ...
[13:19:01.998] - state: ‘created’
[13:19:01.998] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:02.013] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:02.013]   - Field: ‘node’
[13:19:02.013]   - Field: ‘label’
[13:19:02.013]   - Field: ‘local’
[13:19:02.013]   - Field: ‘owner’
[13:19:02.013]   - Field: ‘envir’
[13:19:02.013]   - Field: ‘workers’
[13:19:02.013]   - Field: ‘packages’
[13:19:02.014]   - Field: ‘gc’
[13:19:02.014]   - Field: ‘conditions’
[13:19:02.014]   - Field: ‘persistent’
[13:19:02.014]   - Field: ‘expr’
[13:19:02.014]   - Field: ‘uuid’
[13:19:02.014]   - Field: ‘seed’
[13:19:02.014]   - Field: ‘version’
[13:19:02.014]   - Field: ‘result’
[13:19:02.014]   - Field: ‘asynchronous’
[13:19:02.014]   - Field: ‘calls’
[13:19:02.014]   - Field: ‘globals’
[13:19:02.015]   - Field: ‘stdout’
[13:19:02.015]   - Field: ‘earlySignal’
[13:19:02.015]   - Field: ‘lazy’
[13:19:02.015]   - Field: ‘state’
[13:19:02.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:02.015] - Launch lazy future ...
[13:19:02.015] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:02.015] Packages needed by future strategies (n = 0): <none>
[13:19:02.016] {
[13:19:02.016]     {
[13:19:02.016]         {
[13:19:02.016]             ...future.startTime <- base::Sys.time()
[13:19:02.016]             {
[13:19:02.016]                 {
[13:19:02.016]                   {
[13:19:02.016]                     {
[13:19:02.016]                       {
[13:19:02.016]                         base::local({
[13:19:02.016]                           has_future <- base::requireNamespace("future", 
[13:19:02.016]                             quietly = TRUE)
[13:19:02.016]                           if (has_future) {
[13:19:02.016]                             ns <- base::getNamespace("future")
[13:19:02.016]                             version <- ns[[".package"]][["version"]]
[13:19:02.016]                             if (is.null(version)) 
[13:19:02.016]                               version <- utils::packageVersion("future")
[13:19:02.016]                           }
[13:19:02.016]                           else {
[13:19:02.016]                             version <- NULL
[13:19:02.016]                           }
[13:19:02.016]                           if (!has_future || version < "1.8.0") {
[13:19:02.016]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:02.016]                               "", base::R.version$version.string), 
[13:19:02.016]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:02.016]                                 base::R.version$platform, 8 * 
[13:19:02.016]                                   base::.Machine$sizeof.pointer), 
[13:19:02.016]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:02.016]                                 "release", "version")], collapse = " "), 
[13:19:02.016]                               hostname = base::Sys.info()[["nodename"]])
[13:19:02.016]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:02.016]                               info)
[13:19:02.016]                             info <- base::paste(info, collapse = "; ")
[13:19:02.016]                             if (!has_future) {
[13:19:02.016]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:02.016]                                 info)
[13:19:02.016]                             }
[13:19:02.016]                             else {
[13:19:02.016]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:02.016]                                 info, version)
[13:19:02.016]                             }
[13:19:02.016]                             base::stop(msg)
[13:19:02.016]                           }
[13:19:02.016]                         })
[13:19:02.016]                       }
[13:19:02.016]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:02.016]                       base::options(mc.cores = 1L)
[13:19:02.016]                     }
[13:19:02.016]                     base::local({
[13:19:02.016]                       for (pkg in "future.apply") {
[13:19:02.016]                         base::loadNamespace(pkg)
[13:19:02.016]                         base::library(pkg, character.only = TRUE)
[13:19:02.016]                       }
[13:19:02.016]                     })
[13:19:02.016]                   }
[13:19:02.016]                   options(future.plan = NULL)
[13:19:02.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:02.016]                 }
[13:19:02.016]                 ...future.workdir <- getwd()
[13:19:02.016]             }
[13:19:02.016]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:02.016]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:02.016]         }
[13:19:02.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:02.016]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:02.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:02.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:02.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:02.016]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:02.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:02.016]             base::names(...future.oldOptions))
[13:19:02.016]     }
[13:19:02.016]     if (FALSE) {
[13:19:02.016]     }
[13:19:02.016]     else {
[13:19:02.016]         if (TRUE) {
[13:19:02.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:02.016]                 open = "w")
[13:19:02.016]         }
[13:19:02.016]         else {
[13:19:02.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:02.016]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:02.016]         }
[13:19:02.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:02.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:02.016]             base::sink(type = "output", split = FALSE)
[13:19:02.016]             base::close(...future.stdout)
[13:19:02.016]         }, add = TRUE)
[13:19:02.016]     }
[13:19:02.016]     ...future.frame <- base::sys.nframe()
[13:19:02.016]     ...future.conditions <- base::list()
[13:19:02.016]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:02.016]     if (FALSE) {
[13:19:02.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:02.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:02.016]     }
[13:19:02.016]     ...future.result <- base::tryCatch({
[13:19:02.016]         base::withCallingHandlers({
[13:19:02.016]             ...future.value <- base::withVisible(base::local({
[13:19:02.016]                 ...future.makeSendCondition <- local({
[13:19:02.016]                   sendCondition <- NULL
[13:19:02.016]                   function(frame = 1L) {
[13:19:02.016]                     if (is.function(sendCondition)) 
[13:19:02.016]                       return(sendCondition)
[13:19:02.016]                     ns <- getNamespace("parallel")
[13:19:02.016]                     if (exists("sendData", mode = "function", 
[13:19:02.016]                       envir = ns)) {
[13:19:02.016]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:02.016]                         envir = ns)
[13:19:02.016]                       envir <- sys.frame(frame)
[13:19:02.016]                       master <- NULL
[13:19:02.016]                       while (!identical(envir, .GlobalEnv) && 
[13:19:02.016]                         !identical(envir, emptyenv())) {
[13:19:02.016]                         if (exists("master", mode = "list", envir = envir, 
[13:19:02.016]                           inherits = FALSE)) {
[13:19:02.016]                           master <- get("master", mode = "list", 
[13:19:02.016]                             envir = envir, inherits = FALSE)
[13:19:02.016]                           if (inherits(master, c("SOCKnode", 
[13:19:02.016]                             "SOCK0node"))) {
[13:19:02.016]                             sendCondition <<- function(cond) {
[13:19:02.016]                               data <- list(type = "VALUE", value = cond, 
[13:19:02.016]                                 success = TRUE)
[13:19:02.016]                               parallel_sendData(master, data)
[13:19:02.016]                             }
[13:19:02.016]                             return(sendCondition)
[13:19:02.016]                           }
[13:19:02.016]                         }
[13:19:02.016]                         frame <- frame + 1L
[13:19:02.016]                         envir <- sys.frame(frame)
[13:19:02.016]                       }
[13:19:02.016]                     }
[13:19:02.016]                     sendCondition <<- function(cond) NULL
[13:19:02.016]                   }
[13:19:02.016]                 })
[13:19:02.016]                 withCallingHandlers({
[13:19:02.016]                   {
[13:19:02.016]                     do.call(function(...) {
[13:19:02.016]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.016]                       if (!identical(...future.globals.maxSize.org, 
[13:19:02.016]                         ...future.globals.maxSize)) {
[13:19:02.016]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.016]                         on.exit(options(oopts), add = TRUE)
[13:19:02.016]                       }
[13:19:02.016]                       {
[13:19:02.016]                         lapply(seq_along(...future.elements_ii), 
[13:19:02.016]                           FUN = function(jj) {
[13:19:02.016]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.016]                             ...future.FUN(...future.X_jj, ...)
[13:19:02.016]                           })
[13:19:02.016]                       }
[13:19:02.016]                     }, args = future.call.arguments)
[13:19:02.016]                   }
[13:19:02.016]                 }, immediateCondition = function(cond) {
[13:19:02.016]                   sendCondition <- ...future.makeSendCondition()
[13:19:02.016]                   sendCondition(cond)
[13:19:02.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.016]                   {
[13:19:02.016]                     inherits <- base::inherits
[13:19:02.016]                     invokeRestart <- base::invokeRestart
[13:19:02.016]                     is.null <- base::is.null
[13:19:02.016]                     muffled <- FALSE
[13:19:02.016]                     if (inherits(cond, "message")) {
[13:19:02.016]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:02.016]                       if (muffled) 
[13:19:02.016]                         invokeRestart("muffleMessage")
[13:19:02.016]                     }
[13:19:02.016]                     else if (inherits(cond, "warning")) {
[13:19:02.016]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:02.016]                       if (muffled) 
[13:19:02.016]                         invokeRestart("muffleWarning")
[13:19:02.016]                     }
[13:19:02.016]                     else if (inherits(cond, "condition")) {
[13:19:02.016]                       if (!is.null(pattern)) {
[13:19:02.016]                         computeRestarts <- base::computeRestarts
[13:19:02.016]                         grepl <- base::grepl
[13:19:02.016]                         restarts <- computeRestarts(cond)
[13:19:02.016]                         for (restart in restarts) {
[13:19:02.016]                           name <- restart$name
[13:19:02.016]                           if (is.null(name)) 
[13:19:02.016]                             next
[13:19:02.016]                           if (!grepl(pattern, name)) 
[13:19:02.016]                             next
[13:19:02.016]                           invokeRestart(restart)
[13:19:02.016]                           muffled <- TRUE
[13:19:02.016]                           break
[13:19:02.016]                         }
[13:19:02.016]                       }
[13:19:02.016]                     }
[13:19:02.016]                     invisible(muffled)
[13:19:02.016]                   }
[13:19:02.016]                   muffleCondition(cond)
[13:19:02.016]                 })
[13:19:02.016]             }))
[13:19:02.016]             future::FutureResult(value = ...future.value$value, 
[13:19:02.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.016]                   ...future.rng), globalenv = if (FALSE) 
[13:19:02.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:02.016]                     ...future.globalenv.names))
[13:19:02.016]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:02.016]         }, condition = base::local({
[13:19:02.016]             c <- base::c
[13:19:02.016]             inherits <- base::inherits
[13:19:02.016]             invokeRestart <- base::invokeRestart
[13:19:02.016]             length <- base::length
[13:19:02.016]             list <- base::list
[13:19:02.016]             seq.int <- base::seq.int
[13:19:02.016]             signalCondition <- base::signalCondition
[13:19:02.016]             sys.calls <- base::sys.calls
[13:19:02.016]             `[[` <- base::`[[`
[13:19:02.016]             `+` <- base::`+`
[13:19:02.016]             `<<-` <- base::`<<-`
[13:19:02.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:02.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:02.016]                   3L)]
[13:19:02.016]             }
[13:19:02.016]             function(cond) {
[13:19:02.016]                 is_error <- inherits(cond, "error")
[13:19:02.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:02.016]                   NULL)
[13:19:02.016]                 if (is_error) {
[13:19:02.016]                   sessionInformation <- function() {
[13:19:02.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:02.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:02.016]                       search = base::search(), system = base::Sys.info())
[13:19:02.016]                   }
[13:19:02.016]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:02.016]                     cond$call), session = sessionInformation(), 
[13:19:02.016]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:02.016]                   signalCondition(cond)
[13:19:02.016]                 }
[13:19:02.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:02.016]                 "immediateCondition"))) {
[13:19:02.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:02.016]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:02.016]                   if (TRUE && !signal) {
[13:19:02.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.016]                     {
[13:19:02.016]                       inherits <- base::inherits
[13:19:02.016]                       invokeRestart <- base::invokeRestart
[13:19:02.016]                       is.null <- base::is.null
[13:19:02.016]                       muffled <- FALSE
[13:19:02.016]                       if (inherits(cond, "message")) {
[13:19:02.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.016]                         if (muffled) 
[13:19:02.016]                           invokeRestart("muffleMessage")
[13:19:02.016]                       }
[13:19:02.016]                       else if (inherits(cond, "warning")) {
[13:19:02.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.016]                         if (muffled) 
[13:19:02.016]                           invokeRestart("muffleWarning")
[13:19:02.016]                       }
[13:19:02.016]                       else if (inherits(cond, "condition")) {
[13:19:02.016]                         if (!is.null(pattern)) {
[13:19:02.016]                           computeRestarts <- base::computeRestarts
[13:19:02.016]                           grepl <- base::grepl
[13:19:02.016]                           restarts <- computeRestarts(cond)
[13:19:02.016]                           for (restart in restarts) {
[13:19:02.016]                             name <- restart$name
[13:19:02.016]                             if (is.null(name)) 
[13:19:02.016]                               next
[13:19:02.016]                             if (!grepl(pattern, name)) 
[13:19:02.016]                               next
[13:19:02.016]                             invokeRestart(restart)
[13:19:02.016]                             muffled <- TRUE
[13:19:02.016]                             break
[13:19:02.016]                           }
[13:19:02.016]                         }
[13:19:02.016]                       }
[13:19:02.016]                       invisible(muffled)
[13:19:02.016]                     }
[13:19:02.016]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.016]                   }
[13:19:02.016]                 }
[13:19:02.016]                 else {
[13:19:02.016]                   if (TRUE) {
[13:19:02.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.016]                     {
[13:19:02.016]                       inherits <- base::inherits
[13:19:02.016]                       invokeRestart <- base::invokeRestart
[13:19:02.016]                       is.null <- base::is.null
[13:19:02.016]                       muffled <- FALSE
[13:19:02.016]                       if (inherits(cond, "message")) {
[13:19:02.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.016]                         if (muffled) 
[13:19:02.016]                           invokeRestart("muffleMessage")
[13:19:02.016]                       }
[13:19:02.016]                       else if (inherits(cond, "warning")) {
[13:19:02.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.016]                         if (muffled) 
[13:19:02.016]                           invokeRestart("muffleWarning")
[13:19:02.016]                       }
[13:19:02.016]                       else if (inherits(cond, "condition")) {
[13:19:02.016]                         if (!is.null(pattern)) {
[13:19:02.016]                           computeRestarts <- base::computeRestarts
[13:19:02.016]                           grepl <- base::grepl
[13:19:02.016]                           restarts <- computeRestarts(cond)
[13:19:02.016]                           for (restart in restarts) {
[13:19:02.016]                             name <- restart$name
[13:19:02.016]                             if (is.null(name)) 
[13:19:02.016]                               next
[13:19:02.016]                             if (!grepl(pattern, name)) 
[13:19:02.016]                               next
[13:19:02.016]                             invokeRestart(restart)
[13:19:02.016]                             muffled <- TRUE
[13:19:02.016]                             break
[13:19:02.016]                           }
[13:19:02.016]                         }
[13:19:02.016]                       }
[13:19:02.016]                       invisible(muffled)
[13:19:02.016]                     }
[13:19:02.016]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.016]                   }
[13:19:02.016]                 }
[13:19:02.016]             }
[13:19:02.016]         }))
[13:19:02.016]     }, error = function(ex) {
[13:19:02.016]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:02.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.016]                 ...future.rng), started = ...future.startTime, 
[13:19:02.016]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:02.016]             version = "1.8"), class = "FutureResult")
[13:19:02.016]     }, finally = {
[13:19:02.016]         if (!identical(...future.workdir, getwd())) 
[13:19:02.016]             setwd(...future.workdir)
[13:19:02.016]         {
[13:19:02.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:02.016]                 ...future.oldOptions$nwarnings <- NULL
[13:19:02.016]             }
[13:19:02.016]             base::options(...future.oldOptions)
[13:19:02.016]             if (.Platform$OS.type == "windows") {
[13:19:02.016]                 old_names <- names(...future.oldEnvVars)
[13:19:02.016]                 envs <- base::Sys.getenv()
[13:19:02.016]                 names <- names(envs)
[13:19:02.016]                 common <- intersect(names, old_names)
[13:19:02.016]                 added <- setdiff(names, old_names)
[13:19:02.016]                 removed <- setdiff(old_names, names)
[13:19:02.016]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:02.016]                   envs[common]]
[13:19:02.016]                 NAMES <- toupper(changed)
[13:19:02.016]                 args <- list()
[13:19:02.016]                 for (kk in seq_along(NAMES)) {
[13:19:02.016]                   name <- changed[[kk]]
[13:19:02.016]                   NAME <- NAMES[[kk]]
[13:19:02.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.016]                     next
[13:19:02.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.016]                 }
[13:19:02.016]                 NAMES <- toupper(added)
[13:19:02.016]                 for (kk in seq_along(NAMES)) {
[13:19:02.016]                   name <- added[[kk]]
[13:19:02.016]                   NAME <- NAMES[[kk]]
[13:19:02.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.016]                     next
[13:19:02.016]                   args[[name]] <- ""
[13:19:02.016]                 }
[13:19:02.016]                 NAMES <- toupper(removed)
[13:19:02.016]                 for (kk in seq_along(NAMES)) {
[13:19:02.016]                   name <- removed[[kk]]
[13:19:02.016]                   NAME <- NAMES[[kk]]
[13:19:02.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.016]                     next
[13:19:02.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.016]                 }
[13:19:02.016]                 if (length(args) > 0) 
[13:19:02.016]                   base::do.call(base::Sys.setenv, args = args)
[13:19:02.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:02.016]             }
[13:19:02.016]             else {
[13:19:02.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:02.016]             }
[13:19:02.016]             {
[13:19:02.016]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:02.016]                   0L) {
[13:19:02.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:02.016]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:02.016]                   base::options(opts)
[13:19:02.016]                 }
[13:19:02.016]                 {
[13:19:02.016]                   {
[13:19:02.016]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:02.016]                     NULL
[13:19:02.016]                   }
[13:19:02.016]                   options(future.plan = NULL)
[13:19:02.016]                   if (is.na(NA_character_)) 
[13:19:02.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:02.016]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:02.016]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:02.016]                     envir = parent.frame()) 
[13:19:02.016]                   {
[13:19:02.016]                     if (is.function(workers)) 
[13:19:02.016]                       workers <- workers()
[13:19:02.016]                     workers <- structure(as.integer(workers), 
[13:19:02.016]                       class = class(workers))
[13:19:02.016]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:02.016]                       workers >= 1)
[13:19:02.016]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:02.016]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:02.016]                     }
[13:19:02.016]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:02.016]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:02.016]                       envir = envir)
[13:19:02.016]                     if (!future$lazy) 
[13:19:02.016]                       future <- run(future)
[13:19:02.016]                     invisible(future)
[13:19:02.016]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:02.016]                 }
[13:19:02.016]             }
[13:19:02.016]         }
[13:19:02.016]     })
[13:19:02.016]     if (TRUE) {
[13:19:02.016]         base::sink(type = "output", split = FALSE)
[13:19:02.016]         if (TRUE) {
[13:19:02.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:02.016]         }
[13:19:02.016]         else {
[13:19:02.016]             ...future.result["stdout"] <- base::list(NULL)
[13:19:02.016]         }
[13:19:02.016]         base::close(...future.stdout)
[13:19:02.016]         ...future.stdout <- NULL
[13:19:02.016]     }
[13:19:02.016]     ...future.result$conditions <- ...future.conditions
[13:19:02.016]     ...future.result$finished <- base::Sys.time()
[13:19:02.016]     ...future.result
[13:19:02.016] }
[13:19:02.019] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[13:19:02.019] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:02.061] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:02.061] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:19:02.062] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:19:02.062] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:02.062] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:02.063] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:02.105] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:02.105] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:02.149] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:02.149] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:02.150] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.150] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:19:02.150] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:19:02.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:02.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.151] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:02.152] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:02.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:02.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:02.153] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.153] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[13:19:02.153] MultisessionFuture started
[13:19:02.154] - Launch lazy future ... done
[13:19:02.154] run() for ‘MultisessionFuture’ ... done
[13:19:02.154] Created future:
[13:19:02.154] MultisessionFuture:
[13:19:02.154] Label: ‘future_vapply-1’
[13:19:02.154] Expression:
[13:19:02.154] {
[13:19:02.154]     do.call(function(...) {
[13:19:02.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.154]             on.exit(options(oopts), add = TRUE)
[13:19:02.154]         }
[13:19:02.154]         {
[13:19:02.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.154]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.154]             })
[13:19:02.154]         }
[13:19:02.154]     }, args = future.call.arguments)
[13:19:02.154] }
[13:19:02.154] Lazy evaluation: FALSE
[13:19:02.154] Asynchronous evaluation: TRUE
[13:19:02.154] Local evaluation: TRUE
[13:19:02.154] Environment: R_GlobalEnv
[13:19:02.154] Capture standard output: TRUE
[13:19:02.154] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:02.154] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:02.154] Packages: 1 packages (‘future.apply’)
[13:19:02.154] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:02.154] Resolved: FALSE
[13:19:02.154] Value: <not collected>
[13:19:02.154] Conditions captured: <none>
[13:19:02.154] Early signaling: FALSE
[13:19:02.154] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:02.154] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.166] Chunk #1 of 2 ... DONE
[13:19:02.166] Chunk #2 of 2 ...
[13:19:02.166]  - Finding globals in 'X' for chunk #2 ...
[13:19:02.166] getGlobalsAndPackages() ...
[13:19:02.166] Searching for globals...
[13:19:02.167] 
[13:19:02.167] Searching for globals ... DONE
[13:19:02.167] - globals: [0] <none>
[13:19:02.167] getGlobalsAndPackages() ... DONE
[13:19:02.167]    + additional globals found: [n=0] 
[13:19:02.167]    + additional namespaces needed: [n=0] 
[13:19:02.167]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:02.167]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:02.167]  - seeds: <none>
[13:19:02.167] getGlobalsAndPackages() ...
[13:19:02.168] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.168] Resolving globals: FALSE
[13:19:02.168] Tweak future expression to call with '...' arguments ...
[13:19:02.168] {
[13:19:02.168]     do.call(function(...) {
[13:19:02.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.168]             on.exit(options(oopts), add = TRUE)
[13:19:02.168]         }
[13:19:02.168]         {
[13:19:02.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.168]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.168]             })
[13:19:02.168]         }
[13:19:02.168]     }, args = future.call.arguments)
[13:19:02.168] }
[13:19:02.168] Tweak future expression to call with '...' arguments ... DONE
[13:19:02.169] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.169] - packages: [1] ‘future.apply’
[13:19:02.169] getGlobalsAndPackages() ... DONE
[13:19:02.169] run() for ‘Future’ ...
[13:19:02.169] - state: ‘created’
[13:19:02.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:02.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.185] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:02.185]   - Field: ‘node’
[13:19:02.185]   - Field: ‘label’
[13:19:02.185]   - Field: ‘local’
[13:19:02.185]   - Field: ‘owner’
[13:19:02.186]   - Field: ‘envir’
[13:19:02.186]   - Field: ‘workers’
[13:19:02.186]   - Field: ‘packages’
[13:19:02.186]   - Field: ‘gc’
[13:19:02.186]   - Field: ‘conditions’
[13:19:02.186]   - Field: ‘persistent’
[13:19:02.186]   - Field: ‘expr’
[13:19:02.186]   - Field: ‘uuid’
[13:19:02.186]   - Field: ‘seed’
[13:19:02.186]   - Field: ‘version’
[13:19:02.186]   - Field: ‘result’
[13:19:02.187]   - Field: ‘asynchronous’
[13:19:02.187]   - Field: ‘calls’
[13:19:02.187]   - Field: ‘globals’
[13:19:02.187]   - Field: ‘stdout’
[13:19:02.187]   - Field: ‘earlySignal’
[13:19:02.187]   - Field: ‘lazy’
[13:19:02.187]   - Field: ‘state’
[13:19:02.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:02.187] - Launch lazy future ...
[13:19:02.188] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:02.188] Packages needed by future strategies (n = 0): <none>
[13:19:02.188] {
[13:19:02.188]     {
[13:19:02.188]         {
[13:19:02.188]             ...future.startTime <- base::Sys.time()
[13:19:02.188]             {
[13:19:02.188]                 {
[13:19:02.188]                   {
[13:19:02.188]                     {
[13:19:02.188]                       {
[13:19:02.188]                         base::local({
[13:19:02.188]                           has_future <- base::requireNamespace("future", 
[13:19:02.188]                             quietly = TRUE)
[13:19:02.188]                           if (has_future) {
[13:19:02.188]                             ns <- base::getNamespace("future")
[13:19:02.188]                             version <- ns[[".package"]][["version"]]
[13:19:02.188]                             if (is.null(version)) 
[13:19:02.188]                               version <- utils::packageVersion("future")
[13:19:02.188]                           }
[13:19:02.188]                           else {
[13:19:02.188]                             version <- NULL
[13:19:02.188]                           }
[13:19:02.188]                           if (!has_future || version < "1.8.0") {
[13:19:02.188]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:02.188]                               "", base::R.version$version.string), 
[13:19:02.188]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:02.188]                                 base::R.version$platform, 8 * 
[13:19:02.188]                                   base::.Machine$sizeof.pointer), 
[13:19:02.188]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:02.188]                                 "release", "version")], collapse = " "), 
[13:19:02.188]                               hostname = base::Sys.info()[["nodename"]])
[13:19:02.188]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:02.188]                               info)
[13:19:02.188]                             info <- base::paste(info, collapse = "; ")
[13:19:02.188]                             if (!has_future) {
[13:19:02.188]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:02.188]                                 info)
[13:19:02.188]                             }
[13:19:02.188]                             else {
[13:19:02.188]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:02.188]                                 info, version)
[13:19:02.188]                             }
[13:19:02.188]                             base::stop(msg)
[13:19:02.188]                           }
[13:19:02.188]                         })
[13:19:02.188]                       }
[13:19:02.188]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:02.188]                       base::options(mc.cores = 1L)
[13:19:02.188]                     }
[13:19:02.188]                     base::local({
[13:19:02.188]                       for (pkg in "future.apply") {
[13:19:02.188]                         base::loadNamespace(pkg)
[13:19:02.188]                         base::library(pkg, character.only = TRUE)
[13:19:02.188]                       }
[13:19:02.188]                     })
[13:19:02.188]                   }
[13:19:02.188]                   options(future.plan = NULL)
[13:19:02.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:02.188]                 }
[13:19:02.188]                 ...future.workdir <- getwd()
[13:19:02.188]             }
[13:19:02.188]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:02.188]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:02.188]         }
[13:19:02.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:02.188]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:02.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:02.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:02.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:02.188]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:02.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:02.188]             base::names(...future.oldOptions))
[13:19:02.188]     }
[13:19:02.188]     if (FALSE) {
[13:19:02.188]     }
[13:19:02.188]     else {
[13:19:02.188]         if (TRUE) {
[13:19:02.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:02.188]                 open = "w")
[13:19:02.188]         }
[13:19:02.188]         else {
[13:19:02.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:02.188]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:02.188]         }
[13:19:02.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:02.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:02.188]             base::sink(type = "output", split = FALSE)
[13:19:02.188]             base::close(...future.stdout)
[13:19:02.188]         }, add = TRUE)
[13:19:02.188]     }
[13:19:02.188]     ...future.frame <- base::sys.nframe()
[13:19:02.188]     ...future.conditions <- base::list()
[13:19:02.188]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:02.188]     if (FALSE) {
[13:19:02.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:02.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:02.188]     }
[13:19:02.188]     ...future.result <- base::tryCatch({
[13:19:02.188]         base::withCallingHandlers({
[13:19:02.188]             ...future.value <- base::withVisible(base::local({
[13:19:02.188]                 ...future.makeSendCondition <- local({
[13:19:02.188]                   sendCondition <- NULL
[13:19:02.188]                   function(frame = 1L) {
[13:19:02.188]                     if (is.function(sendCondition)) 
[13:19:02.188]                       return(sendCondition)
[13:19:02.188]                     ns <- getNamespace("parallel")
[13:19:02.188]                     if (exists("sendData", mode = "function", 
[13:19:02.188]                       envir = ns)) {
[13:19:02.188]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:02.188]                         envir = ns)
[13:19:02.188]                       envir <- sys.frame(frame)
[13:19:02.188]                       master <- NULL
[13:19:02.188]                       while (!identical(envir, .GlobalEnv) && 
[13:19:02.188]                         !identical(envir, emptyenv())) {
[13:19:02.188]                         if (exists("master", mode = "list", envir = envir, 
[13:19:02.188]                           inherits = FALSE)) {
[13:19:02.188]                           master <- get("master", mode = "list", 
[13:19:02.188]                             envir = envir, inherits = FALSE)
[13:19:02.188]                           if (inherits(master, c("SOCKnode", 
[13:19:02.188]                             "SOCK0node"))) {
[13:19:02.188]                             sendCondition <<- function(cond) {
[13:19:02.188]                               data <- list(type = "VALUE", value = cond, 
[13:19:02.188]                                 success = TRUE)
[13:19:02.188]                               parallel_sendData(master, data)
[13:19:02.188]                             }
[13:19:02.188]                             return(sendCondition)
[13:19:02.188]                           }
[13:19:02.188]                         }
[13:19:02.188]                         frame <- frame + 1L
[13:19:02.188]                         envir <- sys.frame(frame)
[13:19:02.188]                       }
[13:19:02.188]                     }
[13:19:02.188]                     sendCondition <<- function(cond) NULL
[13:19:02.188]                   }
[13:19:02.188]                 })
[13:19:02.188]                 withCallingHandlers({
[13:19:02.188]                   {
[13:19:02.188]                     do.call(function(...) {
[13:19:02.188]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.188]                       if (!identical(...future.globals.maxSize.org, 
[13:19:02.188]                         ...future.globals.maxSize)) {
[13:19:02.188]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.188]                         on.exit(options(oopts), add = TRUE)
[13:19:02.188]                       }
[13:19:02.188]                       {
[13:19:02.188]                         lapply(seq_along(...future.elements_ii), 
[13:19:02.188]                           FUN = function(jj) {
[13:19:02.188]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.188]                             ...future.FUN(...future.X_jj, ...)
[13:19:02.188]                           })
[13:19:02.188]                       }
[13:19:02.188]                     }, args = future.call.arguments)
[13:19:02.188]                   }
[13:19:02.188]                 }, immediateCondition = function(cond) {
[13:19:02.188]                   sendCondition <- ...future.makeSendCondition()
[13:19:02.188]                   sendCondition(cond)
[13:19:02.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.188]                   {
[13:19:02.188]                     inherits <- base::inherits
[13:19:02.188]                     invokeRestart <- base::invokeRestart
[13:19:02.188]                     is.null <- base::is.null
[13:19:02.188]                     muffled <- FALSE
[13:19:02.188]                     if (inherits(cond, "message")) {
[13:19:02.188]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:02.188]                       if (muffled) 
[13:19:02.188]                         invokeRestart("muffleMessage")
[13:19:02.188]                     }
[13:19:02.188]                     else if (inherits(cond, "warning")) {
[13:19:02.188]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:02.188]                       if (muffled) 
[13:19:02.188]                         invokeRestart("muffleWarning")
[13:19:02.188]                     }
[13:19:02.188]                     else if (inherits(cond, "condition")) {
[13:19:02.188]                       if (!is.null(pattern)) {
[13:19:02.188]                         computeRestarts <- base::computeRestarts
[13:19:02.188]                         grepl <- base::grepl
[13:19:02.188]                         restarts <- computeRestarts(cond)
[13:19:02.188]                         for (restart in restarts) {
[13:19:02.188]                           name <- restart$name
[13:19:02.188]                           if (is.null(name)) 
[13:19:02.188]                             next
[13:19:02.188]                           if (!grepl(pattern, name)) 
[13:19:02.188]                             next
[13:19:02.188]                           invokeRestart(restart)
[13:19:02.188]                           muffled <- TRUE
[13:19:02.188]                           break
[13:19:02.188]                         }
[13:19:02.188]                       }
[13:19:02.188]                     }
[13:19:02.188]                     invisible(muffled)
[13:19:02.188]                   }
[13:19:02.188]                   muffleCondition(cond)
[13:19:02.188]                 })
[13:19:02.188]             }))
[13:19:02.188]             future::FutureResult(value = ...future.value$value, 
[13:19:02.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.188]                   ...future.rng), globalenv = if (FALSE) 
[13:19:02.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:02.188]                     ...future.globalenv.names))
[13:19:02.188]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:02.188]         }, condition = base::local({
[13:19:02.188]             c <- base::c
[13:19:02.188]             inherits <- base::inherits
[13:19:02.188]             invokeRestart <- base::invokeRestart
[13:19:02.188]             length <- base::length
[13:19:02.188]             list <- base::list
[13:19:02.188]             seq.int <- base::seq.int
[13:19:02.188]             signalCondition <- base::signalCondition
[13:19:02.188]             sys.calls <- base::sys.calls
[13:19:02.188]             `[[` <- base::`[[`
[13:19:02.188]             `+` <- base::`+`
[13:19:02.188]             `<<-` <- base::`<<-`
[13:19:02.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:02.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:02.188]                   3L)]
[13:19:02.188]             }
[13:19:02.188]             function(cond) {
[13:19:02.188]                 is_error <- inherits(cond, "error")
[13:19:02.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:02.188]                   NULL)
[13:19:02.188]                 if (is_error) {
[13:19:02.188]                   sessionInformation <- function() {
[13:19:02.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:02.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:02.188]                       search = base::search(), system = base::Sys.info())
[13:19:02.188]                   }
[13:19:02.188]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:02.188]                     cond$call), session = sessionInformation(), 
[13:19:02.188]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:02.188]                   signalCondition(cond)
[13:19:02.188]                 }
[13:19:02.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:02.188]                 "immediateCondition"))) {
[13:19:02.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:02.188]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:02.188]                   if (TRUE && !signal) {
[13:19:02.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.188]                     {
[13:19:02.188]                       inherits <- base::inherits
[13:19:02.188]                       invokeRestart <- base::invokeRestart
[13:19:02.188]                       is.null <- base::is.null
[13:19:02.188]                       muffled <- FALSE
[13:19:02.188]                       if (inherits(cond, "message")) {
[13:19:02.188]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.188]                         if (muffled) 
[13:19:02.188]                           invokeRestart("muffleMessage")
[13:19:02.188]                       }
[13:19:02.188]                       else if (inherits(cond, "warning")) {
[13:19:02.188]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.188]                         if (muffled) 
[13:19:02.188]                           invokeRestart("muffleWarning")
[13:19:02.188]                       }
[13:19:02.188]                       else if (inherits(cond, "condition")) {
[13:19:02.188]                         if (!is.null(pattern)) {
[13:19:02.188]                           computeRestarts <- base::computeRestarts
[13:19:02.188]                           grepl <- base::grepl
[13:19:02.188]                           restarts <- computeRestarts(cond)
[13:19:02.188]                           for (restart in restarts) {
[13:19:02.188]                             name <- restart$name
[13:19:02.188]                             if (is.null(name)) 
[13:19:02.188]                               next
[13:19:02.188]                             if (!grepl(pattern, name)) 
[13:19:02.188]                               next
[13:19:02.188]                             invokeRestart(restart)
[13:19:02.188]                             muffled <- TRUE
[13:19:02.188]                             break
[13:19:02.188]                           }
[13:19:02.188]                         }
[13:19:02.188]                       }
[13:19:02.188]                       invisible(muffled)
[13:19:02.188]                     }
[13:19:02.188]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.188]                   }
[13:19:02.188]                 }
[13:19:02.188]                 else {
[13:19:02.188]                   if (TRUE) {
[13:19:02.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.188]                     {
[13:19:02.188]                       inherits <- base::inherits
[13:19:02.188]                       invokeRestart <- base::invokeRestart
[13:19:02.188]                       is.null <- base::is.null
[13:19:02.188]                       muffled <- FALSE
[13:19:02.188]                       if (inherits(cond, "message")) {
[13:19:02.188]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.188]                         if (muffled) 
[13:19:02.188]                           invokeRestart("muffleMessage")
[13:19:02.188]                       }
[13:19:02.188]                       else if (inherits(cond, "warning")) {
[13:19:02.188]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.188]                         if (muffled) 
[13:19:02.188]                           invokeRestart("muffleWarning")
[13:19:02.188]                       }
[13:19:02.188]                       else if (inherits(cond, "condition")) {
[13:19:02.188]                         if (!is.null(pattern)) {
[13:19:02.188]                           computeRestarts <- base::computeRestarts
[13:19:02.188]                           grepl <- base::grepl
[13:19:02.188]                           restarts <- computeRestarts(cond)
[13:19:02.188]                           for (restart in restarts) {
[13:19:02.188]                             name <- restart$name
[13:19:02.188]                             if (is.null(name)) 
[13:19:02.188]                               next
[13:19:02.188]                             if (!grepl(pattern, name)) 
[13:19:02.188]                               next
[13:19:02.188]                             invokeRestart(restart)
[13:19:02.188]                             muffled <- TRUE
[13:19:02.188]                             break
[13:19:02.188]                           }
[13:19:02.188]                         }
[13:19:02.188]                       }
[13:19:02.188]                       invisible(muffled)
[13:19:02.188]                     }
[13:19:02.188]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.188]                   }
[13:19:02.188]                 }
[13:19:02.188]             }
[13:19:02.188]         }))
[13:19:02.188]     }, error = function(ex) {
[13:19:02.188]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:02.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.188]                 ...future.rng), started = ...future.startTime, 
[13:19:02.188]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:02.188]             version = "1.8"), class = "FutureResult")
[13:19:02.188]     }, finally = {
[13:19:02.188]         if (!identical(...future.workdir, getwd())) 
[13:19:02.188]             setwd(...future.workdir)
[13:19:02.188]         {
[13:19:02.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:02.188]                 ...future.oldOptions$nwarnings <- NULL
[13:19:02.188]             }
[13:19:02.188]             base::options(...future.oldOptions)
[13:19:02.188]             if (.Platform$OS.type == "windows") {
[13:19:02.188]                 old_names <- names(...future.oldEnvVars)
[13:19:02.188]                 envs <- base::Sys.getenv()
[13:19:02.188]                 names <- names(envs)
[13:19:02.188]                 common <- intersect(names, old_names)
[13:19:02.188]                 added <- setdiff(names, old_names)
[13:19:02.188]                 removed <- setdiff(old_names, names)
[13:19:02.188]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:02.188]                   envs[common]]
[13:19:02.188]                 NAMES <- toupper(changed)
[13:19:02.188]                 args <- list()
[13:19:02.188]                 for (kk in seq_along(NAMES)) {
[13:19:02.188]                   name <- changed[[kk]]
[13:19:02.188]                   NAME <- NAMES[[kk]]
[13:19:02.188]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.188]                     next
[13:19:02.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.188]                 }
[13:19:02.188]                 NAMES <- toupper(added)
[13:19:02.188]                 for (kk in seq_along(NAMES)) {
[13:19:02.188]                   name <- added[[kk]]
[13:19:02.188]                   NAME <- NAMES[[kk]]
[13:19:02.188]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.188]                     next
[13:19:02.188]                   args[[name]] <- ""
[13:19:02.188]                 }
[13:19:02.188]                 NAMES <- toupper(removed)
[13:19:02.188]                 for (kk in seq_along(NAMES)) {
[13:19:02.188]                   name <- removed[[kk]]
[13:19:02.188]                   NAME <- NAMES[[kk]]
[13:19:02.188]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.188]                     next
[13:19:02.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.188]                 }
[13:19:02.188]                 if (length(args) > 0) 
[13:19:02.188]                   base::do.call(base::Sys.setenv, args = args)
[13:19:02.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:02.188]             }
[13:19:02.188]             else {
[13:19:02.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:02.188]             }
[13:19:02.188]             {
[13:19:02.188]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:02.188]                   0L) {
[13:19:02.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:02.188]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:02.188]                   base::options(opts)
[13:19:02.188]                 }
[13:19:02.188]                 {
[13:19:02.188]                   {
[13:19:02.188]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:02.188]                     NULL
[13:19:02.188]                   }
[13:19:02.188]                   options(future.plan = NULL)
[13:19:02.188]                   if (is.na(NA_character_)) 
[13:19:02.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:02.188]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:02.188]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:02.188]                     envir = parent.frame()) 
[13:19:02.188]                   {
[13:19:02.188]                     if (is.function(workers)) 
[13:19:02.188]                       workers <- workers()
[13:19:02.188]                     workers <- structure(as.integer(workers), 
[13:19:02.188]                       class = class(workers))
[13:19:02.188]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:02.188]                       workers >= 1)
[13:19:02.188]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:02.188]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:02.188]                     }
[13:19:02.188]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:02.188]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:02.188]                       envir = envir)
[13:19:02.188]                     if (!future$lazy) 
[13:19:02.188]                       future <- run(future)
[13:19:02.188]                     invisible(future)
[13:19:02.188]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:02.188]                 }
[13:19:02.188]             }
[13:19:02.188]         }
[13:19:02.188]     })
[13:19:02.188]     if (TRUE) {
[13:19:02.188]         base::sink(type = "output", split = FALSE)
[13:19:02.188]         if (TRUE) {
[13:19:02.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:02.188]         }
[13:19:02.188]         else {
[13:19:02.188]             ...future.result["stdout"] <- base::list(NULL)
[13:19:02.188]         }
[13:19:02.188]         base::close(...future.stdout)
[13:19:02.188]         ...future.stdout <- NULL
[13:19:02.188]     }
[13:19:02.188]     ...future.result$conditions <- ...future.conditions
[13:19:02.188]     ...future.result$finished <- base::Sys.time()
[13:19:02.188]     ...future.result
[13:19:02.188] }
[13:19:02.191] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[13:19:02.192] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:02.233] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:02.233] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[13:19:02.234] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[13:19:02.234] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:02.234] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:02.234] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:02.277] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:02.277] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:02.321] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:02.321] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:02.322] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.322] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:19:02.322] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:19:02.323] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:02.323] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.323] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:02.323] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:02.324] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:02.324] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.324] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:02.324] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.325] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[13:19:02.325] MultisessionFuture started
[13:19:02.325] - Launch lazy future ... done
[13:19:02.325] run() for ‘MultisessionFuture’ ... done
[13:19:02.326] Created future:
[13:19:02.326] MultisessionFuture:
[13:19:02.326] Label: ‘future_vapply-2’
[13:19:02.326] Expression:
[13:19:02.326] {
[13:19:02.326]     do.call(function(...) {
[13:19:02.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.326]             on.exit(options(oopts), add = TRUE)
[13:19:02.326]         }
[13:19:02.326]         {
[13:19:02.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.326]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.326]             })
[13:19:02.326]         }
[13:19:02.326]     }, args = future.call.arguments)
[13:19:02.326] }
[13:19:02.326] Lazy evaluation: FALSE
[13:19:02.326] Asynchronous evaluation: TRUE
[13:19:02.326] Local evaluation: TRUE
[13:19:02.326] Environment: R_GlobalEnv
[13:19:02.326] Capture standard output: TRUE
[13:19:02.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:02.326] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:02.326] Packages: 1 packages (‘future.apply’)
[13:19:02.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:02.326] Resolved: FALSE
[13:19:02.326] Value: <not collected>
[13:19:02.326] Conditions captured: <none>
[13:19:02.326] Early signaling: FALSE
[13:19:02.326] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:02.326] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.337] Chunk #2 of 2 ... DONE
[13:19:02.338] Launching 2 futures (chunks) ... DONE
[13:19:02.338] Resolving 2 futures (chunks) ...
[13:19:02.338] resolve() on list ...
[13:19:02.338]  recursive: 0
[13:19:02.338]  length: 2
[13:19:02.338] 
[13:19:02.339] receiveMessageFromWorker() for ClusterFuture ...
[13:19:02.339] - Validating connection of MultisessionFuture
[13:19:02.339] - received message: FutureResult
[13:19:02.339] - Received FutureResult
[13:19:02.339] - Erased future from FutureRegistry
[13:19:02.339] result() for ClusterFuture ...
[13:19:02.339] - result already collected: FutureResult
[13:19:02.339] result() for ClusterFuture ... done
[13:19:02.340] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:02.340] Future #1
[13:19:02.340] result() for ClusterFuture ...
[13:19:02.340] - result already collected: FutureResult
[13:19:02.340] result() for ClusterFuture ... done
[13:19:02.340] result() for ClusterFuture ...
[13:19:02.340] - result already collected: FutureResult
[13:19:02.340] result() for ClusterFuture ... done
[13:19:02.340] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:02.340] - nx: 2
[13:19:02.340] - relay: TRUE
[13:19:02.341] - stdout: TRUE
[13:19:02.341] - signal: TRUE
[13:19:02.341] - resignal: FALSE
[13:19:02.341] - force: TRUE
[13:19:02.341] - relayed: [n=2] FALSE, FALSE
[13:19:02.341] - queued futures: [n=2] FALSE, FALSE
[13:19:02.341]  - until=1
[13:19:02.341]  - relaying element #1
[13:19:02.341] result() for ClusterFuture ...
[13:19:02.341] - result already collected: FutureResult
[13:19:02.341] result() for ClusterFuture ... done
[13:19:02.342] result() for ClusterFuture ...
[13:19:02.342] - result already collected: FutureResult
[13:19:02.342] result() for ClusterFuture ... done
[13:19:02.342] result() for ClusterFuture ...
[13:19:02.342] - result already collected: FutureResult
[13:19:02.342] result() for ClusterFuture ... done
[13:19:02.342] result() for ClusterFuture ...
[13:19:02.342] - result already collected: FutureResult
[13:19:02.342] result() for ClusterFuture ... done
[13:19:02.342] - relayed: [n=2] TRUE, FALSE
[13:19:02.342] - queued futures: [n=2] TRUE, FALSE
[13:19:02.343] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:02.343]  length: 1 (resolved future 1)
[13:19:02.374] receiveMessageFromWorker() for ClusterFuture ...
[13:19:02.374] - Validating connection of MultisessionFuture
[13:19:02.374] - received message: FutureResult
[13:19:02.374] - Received FutureResult
[13:19:02.374] - Erased future from FutureRegistry
[13:19:02.375] result() for ClusterFuture ...
[13:19:02.375] - result already collected: FutureResult
[13:19:02.375] result() for ClusterFuture ... done
[13:19:02.375] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:02.375] Future #2
[13:19:02.375] result() for ClusterFuture ...
[13:19:02.375] - result already collected: FutureResult
[13:19:02.375] result() for ClusterFuture ... done
[13:19:02.375] result() for ClusterFuture ...
[13:19:02.375] - result already collected: FutureResult
[13:19:02.376] result() for ClusterFuture ... done
[13:19:02.376] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:02.376] - nx: 2
[13:19:02.376] - relay: TRUE
[13:19:02.376] - stdout: TRUE
[13:19:02.376] - signal: TRUE
[13:19:02.376] - resignal: FALSE
[13:19:02.376] - force: TRUE
[13:19:02.376] - relayed: [n=2] TRUE, FALSE
[13:19:02.376] - queued futures: [n=2] TRUE, FALSE
[13:19:02.376]  - until=2
[13:19:02.376]  - relaying element #2
[13:19:02.377] result() for ClusterFuture ...
[13:19:02.377] - result already collected: FutureResult
[13:19:02.377] result() for ClusterFuture ... done
[13:19:02.377] result() for ClusterFuture ...
[13:19:02.377] - result already collected: FutureResult
[13:19:02.377] result() for ClusterFuture ... done
[13:19:02.377] result() for ClusterFuture ...
[13:19:02.377] - result already collected: FutureResult
[13:19:02.377] result() for ClusterFuture ... done
[13:19:02.377] result() for ClusterFuture ...
[13:19:02.378] - result already collected: FutureResult
[13:19:02.378] result() for ClusterFuture ... done
[13:19:02.378] - relayed: [n=2] TRUE, TRUE
[13:19:02.378] - queued futures: [n=2] TRUE, TRUE
[13:19:02.378] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:02.378]  length: 0 (resolved future 2)
[13:19:02.378] Relaying remaining futures
[13:19:02.378] signalConditionsASAP(NULL, pos=0) ...
[13:19:02.378] - nx: 2
[13:19:02.378] - relay: TRUE
[13:19:02.378] - stdout: TRUE
[13:19:02.379] - signal: TRUE
[13:19:02.379] - resignal: FALSE
[13:19:02.379] - force: TRUE
[13:19:02.379] - relayed: [n=2] TRUE, TRUE
[13:19:02.379] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:02.379] - relayed: [n=2] TRUE, TRUE
[13:19:02.379] - queued futures: [n=2] TRUE, TRUE
[13:19:02.379] signalConditionsASAP(NULL, pos=0) ... done
[13:19:02.379] resolve() on list ... DONE
[13:19:02.379] result() for ClusterFuture ...
[13:19:02.379] - result already collected: FutureResult
[13:19:02.380] result() for ClusterFuture ... done
[13:19:02.380] result() for ClusterFuture ...
[13:19:02.380] - result already collected: FutureResult
[13:19:02.380] result() for ClusterFuture ... done
[13:19:02.380] result() for ClusterFuture ...
[13:19:02.380] - result already collected: FutureResult
[13:19:02.380] result() for ClusterFuture ... done
[13:19:02.380] result() for ClusterFuture ...
[13:19:02.380] - result already collected: FutureResult
[13:19:02.380] result() for ClusterFuture ... done
[13:19:02.381]  - Number of value chunks collected: 2
[13:19:02.381] Resolving 2 futures (chunks) ... DONE
[13:19:02.381] Reducing values from 2 chunks ...
[13:19:02.381]  - Number of values collected after concatenation: 10
[13:19:02.381]  - Number of values expected: 10
[13:19:02.381] Reducing values from 2 chunks ... DONE
[13:19:02.381] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:19:02.382] future_lapply() ...
[13:19:02.387] Number of chunks: 2
[13:19:02.388] getGlobalsAndPackagesXApply() ...
[13:19:02.388]  - future.globals: TRUE
[13:19:02.388] getGlobalsAndPackages() ...
[13:19:02.388] Searching for globals...
[13:19:02.391] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:02.391] Searching for globals ... DONE
[13:19:02.391] Resolving globals: FALSE
[13:19:02.392] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:19:02.392] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:02.393] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:02.393] - packages: [1] ‘future.apply’
[13:19:02.393] getGlobalsAndPackages() ... DONE
[13:19:02.393]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:02.393]  - needed namespaces: [n=1] ‘future.apply’
[13:19:02.393] Finding globals ... DONE
[13:19:02.393]  - use_args: TRUE
[13:19:02.393]  - Getting '...' globals ...
[13:19:02.394] resolve() on list ...
[13:19:02.394]  recursive: 0
[13:19:02.394]  length: 1
[13:19:02.394]  elements: ‘...’
[13:19:02.394]  length: 0 (resolved future 1)
[13:19:02.394] resolve() on list ... DONE
[13:19:02.394]    - '...' content: [n=0] 
[13:19:02.394] List of 1
[13:19:02.394]  $ ...: list()
[13:19:02.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:02.394]  - attr(*, "where")=List of 1
[13:19:02.394]   ..$ ...:<environment: 0x555f7d7dc9a8> 
[13:19:02.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:02.394]  - attr(*, "resolved")= logi TRUE
[13:19:02.394]  - attr(*, "total_size")= num NA
[13:19:02.397]  - Getting '...' globals ... DONE
[13:19:02.397] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:02.397] List of 8
[13:19:02.397]  $ ...future.FUN:function (x, ...)  
[13:19:02.397]  $ x_FUN        :function (x)  
[13:19:02.397]  $ times        : int 1
[13:19:02.397]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:02.397]  $ stop_if_not  :function (...)  
[13:19:02.397]  $ dim          : NULL
[13:19:02.397]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:02.397]  $ ...          : list()
[13:19:02.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:02.397]  - attr(*, "where")=List of 8
[13:19:02.397]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:02.397]   ..$ ...          :<environment: 0x555f7d7dc9a8> 
[13:19:02.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:02.397]  - attr(*, "resolved")= logi FALSE
[13:19:02.397]  - attr(*, "total_size")= num 94336
[13:19:02.402] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:02.403] getGlobalsAndPackagesXApply() ... DONE
[13:19:02.403] Number of futures (= number of chunks): 2
[13:19:02.403] Launching 2 futures (chunks) ...
[13:19:02.403] Chunk #1 of 2 ...
[13:19:02.403]  - Finding globals in 'X' for chunk #1 ...
[13:19:02.403] getGlobalsAndPackages() ...
[13:19:02.403] Searching for globals...
[13:19:02.405] 
[13:19:02.406] Searching for globals ... DONE
[13:19:02.406] - globals: [0] <none>
[13:19:02.406] getGlobalsAndPackages() ... DONE
[13:19:02.406]    + additional globals found: [n=0] 
[13:19:02.406]    + additional namespaces needed: [n=0] 
[13:19:02.406]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:02.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:02.406]  - seeds: <none>
[13:19:02.406] getGlobalsAndPackages() ...
[13:19:02.406] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.407] Resolving globals: FALSE
[13:19:02.407] Tweak future expression to call with '...' arguments ...
[13:19:02.407] {
[13:19:02.407]     do.call(function(...) {
[13:19:02.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.407]             on.exit(options(oopts), add = TRUE)
[13:19:02.407]         }
[13:19:02.407]         {
[13:19:02.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.407]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.407]             })
[13:19:02.407]         }
[13:19:02.407]     }, args = future.call.arguments)
[13:19:02.407] }
[13:19:02.407] Tweak future expression to call with '...' arguments ... DONE
[13:19:02.408] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.408] - packages: [1] ‘future.apply’
[13:19:02.408] getGlobalsAndPackages() ... DONE
[13:19:02.408] run() for ‘Future’ ...
[13:19:02.408] - state: ‘created’
[13:19:02.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:02.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:02.424]   - Field: ‘node’
[13:19:02.424]   - Field: ‘label’
[13:19:02.424]   - Field: ‘local’
[13:19:02.424]   - Field: ‘owner’
[13:19:02.424]   - Field: ‘envir’
[13:19:02.424]   - Field: ‘workers’
[13:19:02.424]   - Field: ‘packages’
[13:19:02.424]   - Field: ‘gc’
[13:19:02.424]   - Field: ‘conditions’
[13:19:02.425]   - Field: ‘persistent’
[13:19:02.425]   - Field: ‘expr’
[13:19:02.425]   - Field: ‘uuid’
[13:19:02.425]   - Field: ‘seed’
[13:19:02.425]   - Field: ‘version’
[13:19:02.425]   - Field: ‘result’
[13:19:02.425]   - Field: ‘asynchronous’
[13:19:02.425]   - Field: ‘calls’
[13:19:02.425]   - Field: ‘globals’
[13:19:02.425]   - Field: ‘stdout’
[13:19:02.425]   - Field: ‘earlySignal’
[13:19:02.426]   - Field: ‘lazy’
[13:19:02.426]   - Field: ‘state’
[13:19:02.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:02.426] - Launch lazy future ...
[13:19:02.426] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:02.426] Packages needed by future strategies (n = 0): <none>
[13:19:02.427] {
[13:19:02.427]     {
[13:19:02.427]         {
[13:19:02.427]             ...future.startTime <- base::Sys.time()
[13:19:02.427]             {
[13:19:02.427]                 {
[13:19:02.427]                   {
[13:19:02.427]                     {
[13:19:02.427]                       {
[13:19:02.427]                         base::local({
[13:19:02.427]                           has_future <- base::requireNamespace("future", 
[13:19:02.427]                             quietly = TRUE)
[13:19:02.427]                           if (has_future) {
[13:19:02.427]                             ns <- base::getNamespace("future")
[13:19:02.427]                             version <- ns[[".package"]][["version"]]
[13:19:02.427]                             if (is.null(version)) 
[13:19:02.427]                               version <- utils::packageVersion("future")
[13:19:02.427]                           }
[13:19:02.427]                           else {
[13:19:02.427]                             version <- NULL
[13:19:02.427]                           }
[13:19:02.427]                           if (!has_future || version < "1.8.0") {
[13:19:02.427]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:02.427]                               "", base::R.version$version.string), 
[13:19:02.427]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:02.427]                                 base::R.version$platform, 8 * 
[13:19:02.427]                                   base::.Machine$sizeof.pointer), 
[13:19:02.427]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:02.427]                                 "release", "version")], collapse = " "), 
[13:19:02.427]                               hostname = base::Sys.info()[["nodename"]])
[13:19:02.427]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:02.427]                               info)
[13:19:02.427]                             info <- base::paste(info, collapse = "; ")
[13:19:02.427]                             if (!has_future) {
[13:19:02.427]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:02.427]                                 info)
[13:19:02.427]                             }
[13:19:02.427]                             else {
[13:19:02.427]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:02.427]                                 info, version)
[13:19:02.427]                             }
[13:19:02.427]                             base::stop(msg)
[13:19:02.427]                           }
[13:19:02.427]                         })
[13:19:02.427]                       }
[13:19:02.427]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:02.427]                       base::options(mc.cores = 1L)
[13:19:02.427]                     }
[13:19:02.427]                     base::local({
[13:19:02.427]                       for (pkg in "future.apply") {
[13:19:02.427]                         base::loadNamespace(pkg)
[13:19:02.427]                         base::library(pkg, character.only = TRUE)
[13:19:02.427]                       }
[13:19:02.427]                     })
[13:19:02.427]                   }
[13:19:02.427]                   options(future.plan = NULL)
[13:19:02.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:02.427]                 }
[13:19:02.427]                 ...future.workdir <- getwd()
[13:19:02.427]             }
[13:19:02.427]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:02.427]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:02.427]         }
[13:19:02.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:02.427]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:02.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:02.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:02.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:02.427]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:02.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:02.427]             base::names(...future.oldOptions))
[13:19:02.427]     }
[13:19:02.427]     if (FALSE) {
[13:19:02.427]     }
[13:19:02.427]     else {
[13:19:02.427]         if (TRUE) {
[13:19:02.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:02.427]                 open = "w")
[13:19:02.427]         }
[13:19:02.427]         else {
[13:19:02.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:02.427]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:02.427]         }
[13:19:02.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:02.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:02.427]             base::sink(type = "output", split = FALSE)
[13:19:02.427]             base::close(...future.stdout)
[13:19:02.427]         }, add = TRUE)
[13:19:02.427]     }
[13:19:02.427]     ...future.frame <- base::sys.nframe()
[13:19:02.427]     ...future.conditions <- base::list()
[13:19:02.427]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:02.427]     if (FALSE) {
[13:19:02.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:02.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:02.427]     }
[13:19:02.427]     ...future.result <- base::tryCatch({
[13:19:02.427]         base::withCallingHandlers({
[13:19:02.427]             ...future.value <- base::withVisible(base::local({
[13:19:02.427]                 ...future.makeSendCondition <- local({
[13:19:02.427]                   sendCondition <- NULL
[13:19:02.427]                   function(frame = 1L) {
[13:19:02.427]                     if (is.function(sendCondition)) 
[13:19:02.427]                       return(sendCondition)
[13:19:02.427]                     ns <- getNamespace("parallel")
[13:19:02.427]                     if (exists("sendData", mode = "function", 
[13:19:02.427]                       envir = ns)) {
[13:19:02.427]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:02.427]                         envir = ns)
[13:19:02.427]                       envir <- sys.frame(frame)
[13:19:02.427]                       master <- NULL
[13:19:02.427]                       while (!identical(envir, .GlobalEnv) && 
[13:19:02.427]                         !identical(envir, emptyenv())) {
[13:19:02.427]                         if (exists("master", mode = "list", envir = envir, 
[13:19:02.427]                           inherits = FALSE)) {
[13:19:02.427]                           master <- get("master", mode = "list", 
[13:19:02.427]                             envir = envir, inherits = FALSE)
[13:19:02.427]                           if (inherits(master, c("SOCKnode", 
[13:19:02.427]                             "SOCK0node"))) {
[13:19:02.427]                             sendCondition <<- function(cond) {
[13:19:02.427]                               data <- list(type = "VALUE", value = cond, 
[13:19:02.427]                                 success = TRUE)
[13:19:02.427]                               parallel_sendData(master, data)
[13:19:02.427]                             }
[13:19:02.427]                             return(sendCondition)
[13:19:02.427]                           }
[13:19:02.427]                         }
[13:19:02.427]                         frame <- frame + 1L
[13:19:02.427]                         envir <- sys.frame(frame)
[13:19:02.427]                       }
[13:19:02.427]                     }
[13:19:02.427]                     sendCondition <<- function(cond) NULL
[13:19:02.427]                   }
[13:19:02.427]                 })
[13:19:02.427]                 withCallingHandlers({
[13:19:02.427]                   {
[13:19:02.427]                     do.call(function(...) {
[13:19:02.427]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.427]                       if (!identical(...future.globals.maxSize.org, 
[13:19:02.427]                         ...future.globals.maxSize)) {
[13:19:02.427]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.427]                         on.exit(options(oopts), add = TRUE)
[13:19:02.427]                       }
[13:19:02.427]                       {
[13:19:02.427]                         lapply(seq_along(...future.elements_ii), 
[13:19:02.427]                           FUN = function(jj) {
[13:19:02.427]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.427]                             ...future.FUN(...future.X_jj, ...)
[13:19:02.427]                           })
[13:19:02.427]                       }
[13:19:02.427]                     }, args = future.call.arguments)
[13:19:02.427]                   }
[13:19:02.427]                 }, immediateCondition = function(cond) {
[13:19:02.427]                   sendCondition <- ...future.makeSendCondition()
[13:19:02.427]                   sendCondition(cond)
[13:19:02.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.427]                   {
[13:19:02.427]                     inherits <- base::inherits
[13:19:02.427]                     invokeRestart <- base::invokeRestart
[13:19:02.427]                     is.null <- base::is.null
[13:19:02.427]                     muffled <- FALSE
[13:19:02.427]                     if (inherits(cond, "message")) {
[13:19:02.427]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:02.427]                       if (muffled) 
[13:19:02.427]                         invokeRestart("muffleMessage")
[13:19:02.427]                     }
[13:19:02.427]                     else if (inherits(cond, "warning")) {
[13:19:02.427]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:02.427]                       if (muffled) 
[13:19:02.427]                         invokeRestart("muffleWarning")
[13:19:02.427]                     }
[13:19:02.427]                     else if (inherits(cond, "condition")) {
[13:19:02.427]                       if (!is.null(pattern)) {
[13:19:02.427]                         computeRestarts <- base::computeRestarts
[13:19:02.427]                         grepl <- base::grepl
[13:19:02.427]                         restarts <- computeRestarts(cond)
[13:19:02.427]                         for (restart in restarts) {
[13:19:02.427]                           name <- restart$name
[13:19:02.427]                           if (is.null(name)) 
[13:19:02.427]                             next
[13:19:02.427]                           if (!grepl(pattern, name)) 
[13:19:02.427]                             next
[13:19:02.427]                           invokeRestart(restart)
[13:19:02.427]                           muffled <- TRUE
[13:19:02.427]                           break
[13:19:02.427]                         }
[13:19:02.427]                       }
[13:19:02.427]                     }
[13:19:02.427]                     invisible(muffled)
[13:19:02.427]                   }
[13:19:02.427]                   muffleCondition(cond)
[13:19:02.427]                 })
[13:19:02.427]             }))
[13:19:02.427]             future::FutureResult(value = ...future.value$value, 
[13:19:02.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.427]                   ...future.rng), globalenv = if (FALSE) 
[13:19:02.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:02.427]                     ...future.globalenv.names))
[13:19:02.427]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:02.427]         }, condition = base::local({
[13:19:02.427]             c <- base::c
[13:19:02.427]             inherits <- base::inherits
[13:19:02.427]             invokeRestart <- base::invokeRestart
[13:19:02.427]             length <- base::length
[13:19:02.427]             list <- base::list
[13:19:02.427]             seq.int <- base::seq.int
[13:19:02.427]             signalCondition <- base::signalCondition
[13:19:02.427]             sys.calls <- base::sys.calls
[13:19:02.427]             `[[` <- base::`[[`
[13:19:02.427]             `+` <- base::`+`
[13:19:02.427]             `<<-` <- base::`<<-`
[13:19:02.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:02.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:02.427]                   3L)]
[13:19:02.427]             }
[13:19:02.427]             function(cond) {
[13:19:02.427]                 is_error <- inherits(cond, "error")
[13:19:02.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:02.427]                   NULL)
[13:19:02.427]                 if (is_error) {
[13:19:02.427]                   sessionInformation <- function() {
[13:19:02.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:02.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:02.427]                       search = base::search(), system = base::Sys.info())
[13:19:02.427]                   }
[13:19:02.427]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:02.427]                     cond$call), session = sessionInformation(), 
[13:19:02.427]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:02.427]                   signalCondition(cond)
[13:19:02.427]                 }
[13:19:02.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:02.427]                 "immediateCondition"))) {
[13:19:02.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:02.427]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:02.427]                   if (TRUE && !signal) {
[13:19:02.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.427]                     {
[13:19:02.427]                       inherits <- base::inherits
[13:19:02.427]                       invokeRestart <- base::invokeRestart
[13:19:02.427]                       is.null <- base::is.null
[13:19:02.427]                       muffled <- FALSE
[13:19:02.427]                       if (inherits(cond, "message")) {
[13:19:02.427]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.427]                         if (muffled) 
[13:19:02.427]                           invokeRestart("muffleMessage")
[13:19:02.427]                       }
[13:19:02.427]                       else if (inherits(cond, "warning")) {
[13:19:02.427]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.427]                         if (muffled) 
[13:19:02.427]                           invokeRestart("muffleWarning")
[13:19:02.427]                       }
[13:19:02.427]                       else if (inherits(cond, "condition")) {
[13:19:02.427]                         if (!is.null(pattern)) {
[13:19:02.427]                           computeRestarts <- base::computeRestarts
[13:19:02.427]                           grepl <- base::grepl
[13:19:02.427]                           restarts <- computeRestarts(cond)
[13:19:02.427]                           for (restart in restarts) {
[13:19:02.427]                             name <- restart$name
[13:19:02.427]                             if (is.null(name)) 
[13:19:02.427]                               next
[13:19:02.427]                             if (!grepl(pattern, name)) 
[13:19:02.427]                               next
[13:19:02.427]                             invokeRestart(restart)
[13:19:02.427]                             muffled <- TRUE
[13:19:02.427]                             break
[13:19:02.427]                           }
[13:19:02.427]                         }
[13:19:02.427]                       }
[13:19:02.427]                       invisible(muffled)
[13:19:02.427]                     }
[13:19:02.427]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.427]                   }
[13:19:02.427]                 }
[13:19:02.427]                 else {
[13:19:02.427]                   if (TRUE) {
[13:19:02.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.427]                     {
[13:19:02.427]                       inherits <- base::inherits
[13:19:02.427]                       invokeRestart <- base::invokeRestart
[13:19:02.427]                       is.null <- base::is.null
[13:19:02.427]                       muffled <- FALSE
[13:19:02.427]                       if (inherits(cond, "message")) {
[13:19:02.427]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.427]                         if (muffled) 
[13:19:02.427]                           invokeRestart("muffleMessage")
[13:19:02.427]                       }
[13:19:02.427]                       else if (inherits(cond, "warning")) {
[13:19:02.427]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.427]                         if (muffled) 
[13:19:02.427]                           invokeRestart("muffleWarning")
[13:19:02.427]                       }
[13:19:02.427]                       else if (inherits(cond, "condition")) {
[13:19:02.427]                         if (!is.null(pattern)) {
[13:19:02.427]                           computeRestarts <- base::computeRestarts
[13:19:02.427]                           grepl <- base::grepl
[13:19:02.427]                           restarts <- computeRestarts(cond)
[13:19:02.427]                           for (restart in restarts) {
[13:19:02.427]                             name <- restart$name
[13:19:02.427]                             if (is.null(name)) 
[13:19:02.427]                               next
[13:19:02.427]                             if (!grepl(pattern, name)) 
[13:19:02.427]                               next
[13:19:02.427]                             invokeRestart(restart)
[13:19:02.427]                             muffled <- TRUE
[13:19:02.427]                             break
[13:19:02.427]                           }
[13:19:02.427]                         }
[13:19:02.427]                       }
[13:19:02.427]                       invisible(muffled)
[13:19:02.427]                     }
[13:19:02.427]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.427]                   }
[13:19:02.427]                 }
[13:19:02.427]             }
[13:19:02.427]         }))
[13:19:02.427]     }, error = function(ex) {
[13:19:02.427]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:02.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.427]                 ...future.rng), started = ...future.startTime, 
[13:19:02.427]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:02.427]             version = "1.8"), class = "FutureResult")
[13:19:02.427]     }, finally = {
[13:19:02.427]         if (!identical(...future.workdir, getwd())) 
[13:19:02.427]             setwd(...future.workdir)
[13:19:02.427]         {
[13:19:02.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:02.427]                 ...future.oldOptions$nwarnings <- NULL
[13:19:02.427]             }
[13:19:02.427]             base::options(...future.oldOptions)
[13:19:02.427]             if (.Platform$OS.type == "windows") {
[13:19:02.427]                 old_names <- names(...future.oldEnvVars)
[13:19:02.427]                 envs <- base::Sys.getenv()
[13:19:02.427]                 names <- names(envs)
[13:19:02.427]                 common <- intersect(names, old_names)
[13:19:02.427]                 added <- setdiff(names, old_names)
[13:19:02.427]                 removed <- setdiff(old_names, names)
[13:19:02.427]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:02.427]                   envs[common]]
[13:19:02.427]                 NAMES <- toupper(changed)
[13:19:02.427]                 args <- list()
[13:19:02.427]                 for (kk in seq_along(NAMES)) {
[13:19:02.427]                   name <- changed[[kk]]
[13:19:02.427]                   NAME <- NAMES[[kk]]
[13:19:02.427]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.427]                     next
[13:19:02.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.427]                 }
[13:19:02.427]                 NAMES <- toupper(added)
[13:19:02.427]                 for (kk in seq_along(NAMES)) {
[13:19:02.427]                   name <- added[[kk]]
[13:19:02.427]                   NAME <- NAMES[[kk]]
[13:19:02.427]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.427]                     next
[13:19:02.427]                   args[[name]] <- ""
[13:19:02.427]                 }
[13:19:02.427]                 NAMES <- toupper(removed)
[13:19:02.427]                 for (kk in seq_along(NAMES)) {
[13:19:02.427]                   name <- removed[[kk]]
[13:19:02.427]                   NAME <- NAMES[[kk]]
[13:19:02.427]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.427]                     next
[13:19:02.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.427]                 }
[13:19:02.427]                 if (length(args) > 0) 
[13:19:02.427]                   base::do.call(base::Sys.setenv, args = args)
[13:19:02.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:02.427]             }
[13:19:02.427]             else {
[13:19:02.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:02.427]             }
[13:19:02.427]             {
[13:19:02.427]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:02.427]                   0L) {
[13:19:02.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:02.427]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:02.427]                   base::options(opts)
[13:19:02.427]                 }
[13:19:02.427]                 {
[13:19:02.427]                   {
[13:19:02.427]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:02.427]                     NULL
[13:19:02.427]                   }
[13:19:02.427]                   options(future.plan = NULL)
[13:19:02.427]                   if (is.na(NA_character_)) 
[13:19:02.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:02.427]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:02.427]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:02.427]                     envir = parent.frame()) 
[13:19:02.427]                   {
[13:19:02.427]                     if (is.function(workers)) 
[13:19:02.427]                       workers <- workers()
[13:19:02.427]                     workers <- structure(as.integer(workers), 
[13:19:02.427]                       class = class(workers))
[13:19:02.427]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:02.427]                       workers >= 1)
[13:19:02.427]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:02.427]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:02.427]                     }
[13:19:02.427]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:02.427]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:02.427]                       envir = envir)
[13:19:02.427]                     if (!future$lazy) 
[13:19:02.427]                       future <- run(future)
[13:19:02.427]                     invisible(future)
[13:19:02.427]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:02.427]                 }
[13:19:02.427]             }
[13:19:02.427]         }
[13:19:02.427]     })
[13:19:02.427]     if (TRUE) {
[13:19:02.427]         base::sink(type = "output", split = FALSE)
[13:19:02.427]         if (TRUE) {
[13:19:02.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:02.427]         }
[13:19:02.427]         else {
[13:19:02.427]             ...future.result["stdout"] <- base::list(NULL)
[13:19:02.427]         }
[13:19:02.427]         base::close(...future.stdout)
[13:19:02.427]         ...future.stdout <- NULL
[13:19:02.427]     }
[13:19:02.427]     ...future.result$conditions <- ...future.conditions
[13:19:02.427]     ...future.result$finished <- base::Sys.time()
[13:19:02.427]     ...future.result
[13:19:02.427] }
[13:19:02.430] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[13:19:02.430] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:02.473] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:02.473] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:19:02.474] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:19:02.474] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:02.474] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:02.474] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:02.517] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:02.517] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:02.561] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:02.561] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:02.562] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.562] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:02.562] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:02.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:02.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.563] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:02.563] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:02.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:02.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:02.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.564] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[13:19:02.565] MultisessionFuture started
[13:19:02.565] - Launch lazy future ... done
[13:19:02.566] run() for ‘MultisessionFuture’ ... done
[13:19:02.566] Created future:
[13:19:02.566] MultisessionFuture:
[13:19:02.566] Label: ‘future_vapply-1’
[13:19:02.566] Expression:
[13:19:02.566] {
[13:19:02.566]     do.call(function(...) {
[13:19:02.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.566]             on.exit(options(oopts), add = TRUE)
[13:19:02.566]         }
[13:19:02.566]         {
[13:19:02.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.566]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.566]             })
[13:19:02.566]         }
[13:19:02.566]     }, args = future.call.arguments)
[13:19:02.566] }
[13:19:02.566] Lazy evaluation: FALSE
[13:19:02.566] Asynchronous evaluation: TRUE
[13:19:02.566] Local evaluation: TRUE
[13:19:02.566] Environment: R_GlobalEnv
[13:19:02.566] Capture standard output: TRUE
[13:19:02.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:02.566] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:02.566] Packages: 1 packages (‘future.apply’)
[13:19:02.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:02.566] Resolved: FALSE
[13:19:02.566] Value: <not collected>
[13:19:02.566] Conditions captured: <none>
[13:19:02.566] Early signaling: FALSE
[13:19:02.566] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:02.566] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.578] Chunk #1 of 2 ... DONE
[13:19:02.578] Chunk #2 of 2 ...
[13:19:02.578]  - Finding globals in 'X' for chunk #2 ...
[13:19:02.578] getGlobalsAndPackages() ...
[13:19:02.578] Searching for globals...
[13:19:02.578] 
[13:19:02.578] Searching for globals ... DONE
[13:19:02.579] - globals: [0] <none>
[13:19:02.579] getGlobalsAndPackages() ... DONE
[13:19:02.579]    + additional globals found: [n=0] 
[13:19:02.579]    + additional namespaces needed: [n=0] 
[13:19:02.579]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:02.579]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:02.579]  - seeds: <none>
[13:19:02.579] getGlobalsAndPackages() ...
[13:19:02.579] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.580] Resolving globals: FALSE
[13:19:02.580] Tweak future expression to call with '...' arguments ...
[13:19:02.580] {
[13:19:02.580]     do.call(function(...) {
[13:19:02.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.580]             on.exit(options(oopts), add = TRUE)
[13:19:02.580]         }
[13:19:02.580]         {
[13:19:02.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.580]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.580]             })
[13:19:02.580]         }
[13:19:02.580]     }, args = future.call.arguments)
[13:19:02.580] }
[13:19:02.580] Tweak future expression to call with '...' arguments ... DONE
[13:19:02.581] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.581] - packages: [1] ‘future.apply’
[13:19:02.581] getGlobalsAndPackages() ... DONE
[13:19:02.581] run() for ‘Future’ ...
[13:19:02.581] - state: ‘created’
[13:19:02.581] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:02.597] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:02.597]   - Field: ‘node’
[13:19:02.597]   - Field: ‘label’
[13:19:02.597]   - Field: ‘local’
[13:19:02.597]   - Field: ‘owner’
[13:19:02.597]   - Field: ‘envir’
[13:19:02.597]   - Field: ‘workers’
[13:19:02.598]   - Field: ‘packages’
[13:19:02.598]   - Field: ‘gc’
[13:19:02.598]   - Field: ‘conditions’
[13:19:02.598]   - Field: ‘persistent’
[13:19:02.598]   - Field: ‘expr’
[13:19:02.598]   - Field: ‘uuid’
[13:19:02.598]   - Field: ‘seed’
[13:19:02.598]   - Field: ‘version’
[13:19:02.598]   - Field: ‘result’
[13:19:02.598]   - Field: ‘asynchronous’
[13:19:02.598]   - Field: ‘calls’
[13:19:02.599]   - Field: ‘globals’
[13:19:02.599]   - Field: ‘stdout’
[13:19:02.599]   - Field: ‘earlySignal’
[13:19:02.599]   - Field: ‘lazy’
[13:19:02.599]   - Field: ‘state’
[13:19:02.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:02.599] - Launch lazy future ...
[13:19:02.599] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:02.600] Packages needed by future strategies (n = 0): <none>
[13:19:02.600] {
[13:19:02.600]     {
[13:19:02.600]         {
[13:19:02.600]             ...future.startTime <- base::Sys.time()
[13:19:02.600]             {
[13:19:02.600]                 {
[13:19:02.600]                   {
[13:19:02.600]                     {
[13:19:02.600]                       {
[13:19:02.600]                         base::local({
[13:19:02.600]                           has_future <- base::requireNamespace("future", 
[13:19:02.600]                             quietly = TRUE)
[13:19:02.600]                           if (has_future) {
[13:19:02.600]                             ns <- base::getNamespace("future")
[13:19:02.600]                             version <- ns[[".package"]][["version"]]
[13:19:02.600]                             if (is.null(version)) 
[13:19:02.600]                               version <- utils::packageVersion("future")
[13:19:02.600]                           }
[13:19:02.600]                           else {
[13:19:02.600]                             version <- NULL
[13:19:02.600]                           }
[13:19:02.600]                           if (!has_future || version < "1.8.0") {
[13:19:02.600]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:02.600]                               "", base::R.version$version.string), 
[13:19:02.600]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:02.600]                                 base::R.version$platform, 8 * 
[13:19:02.600]                                   base::.Machine$sizeof.pointer), 
[13:19:02.600]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:02.600]                                 "release", "version")], collapse = " "), 
[13:19:02.600]                               hostname = base::Sys.info()[["nodename"]])
[13:19:02.600]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:02.600]                               info)
[13:19:02.600]                             info <- base::paste(info, collapse = "; ")
[13:19:02.600]                             if (!has_future) {
[13:19:02.600]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:02.600]                                 info)
[13:19:02.600]                             }
[13:19:02.600]                             else {
[13:19:02.600]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:02.600]                                 info, version)
[13:19:02.600]                             }
[13:19:02.600]                             base::stop(msg)
[13:19:02.600]                           }
[13:19:02.600]                         })
[13:19:02.600]                       }
[13:19:02.600]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:02.600]                       base::options(mc.cores = 1L)
[13:19:02.600]                     }
[13:19:02.600]                     base::local({
[13:19:02.600]                       for (pkg in "future.apply") {
[13:19:02.600]                         base::loadNamespace(pkg)
[13:19:02.600]                         base::library(pkg, character.only = TRUE)
[13:19:02.600]                       }
[13:19:02.600]                     })
[13:19:02.600]                   }
[13:19:02.600]                   options(future.plan = NULL)
[13:19:02.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:02.600]                 }
[13:19:02.600]                 ...future.workdir <- getwd()
[13:19:02.600]             }
[13:19:02.600]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:02.600]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:02.600]         }
[13:19:02.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:02.600]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:02.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:02.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:02.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:02.600]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:02.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:02.600]             base::names(...future.oldOptions))
[13:19:02.600]     }
[13:19:02.600]     if (FALSE) {
[13:19:02.600]     }
[13:19:02.600]     else {
[13:19:02.600]         if (TRUE) {
[13:19:02.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:02.600]                 open = "w")
[13:19:02.600]         }
[13:19:02.600]         else {
[13:19:02.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:02.600]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:02.600]         }
[13:19:02.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:02.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:02.600]             base::sink(type = "output", split = FALSE)
[13:19:02.600]             base::close(...future.stdout)
[13:19:02.600]         }, add = TRUE)
[13:19:02.600]     }
[13:19:02.600]     ...future.frame <- base::sys.nframe()
[13:19:02.600]     ...future.conditions <- base::list()
[13:19:02.600]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:02.600]     if (FALSE) {
[13:19:02.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:02.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:02.600]     }
[13:19:02.600]     ...future.result <- base::tryCatch({
[13:19:02.600]         base::withCallingHandlers({
[13:19:02.600]             ...future.value <- base::withVisible(base::local({
[13:19:02.600]                 ...future.makeSendCondition <- local({
[13:19:02.600]                   sendCondition <- NULL
[13:19:02.600]                   function(frame = 1L) {
[13:19:02.600]                     if (is.function(sendCondition)) 
[13:19:02.600]                       return(sendCondition)
[13:19:02.600]                     ns <- getNamespace("parallel")
[13:19:02.600]                     if (exists("sendData", mode = "function", 
[13:19:02.600]                       envir = ns)) {
[13:19:02.600]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:02.600]                         envir = ns)
[13:19:02.600]                       envir <- sys.frame(frame)
[13:19:02.600]                       master <- NULL
[13:19:02.600]                       while (!identical(envir, .GlobalEnv) && 
[13:19:02.600]                         !identical(envir, emptyenv())) {
[13:19:02.600]                         if (exists("master", mode = "list", envir = envir, 
[13:19:02.600]                           inherits = FALSE)) {
[13:19:02.600]                           master <- get("master", mode = "list", 
[13:19:02.600]                             envir = envir, inherits = FALSE)
[13:19:02.600]                           if (inherits(master, c("SOCKnode", 
[13:19:02.600]                             "SOCK0node"))) {
[13:19:02.600]                             sendCondition <<- function(cond) {
[13:19:02.600]                               data <- list(type = "VALUE", value = cond, 
[13:19:02.600]                                 success = TRUE)
[13:19:02.600]                               parallel_sendData(master, data)
[13:19:02.600]                             }
[13:19:02.600]                             return(sendCondition)
[13:19:02.600]                           }
[13:19:02.600]                         }
[13:19:02.600]                         frame <- frame + 1L
[13:19:02.600]                         envir <- sys.frame(frame)
[13:19:02.600]                       }
[13:19:02.600]                     }
[13:19:02.600]                     sendCondition <<- function(cond) NULL
[13:19:02.600]                   }
[13:19:02.600]                 })
[13:19:02.600]                 withCallingHandlers({
[13:19:02.600]                   {
[13:19:02.600]                     do.call(function(...) {
[13:19:02.600]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.600]                       if (!identical(...future.globals.maxSize.org, 
[13:19:02.600]                         ...future.globals.maxSize)) {
[13:19:02.600]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.600]                         on.exit(options(oopts), add = TRUE)
[13:19:02.600]                       }
[13:19:02.600]                       {
[13:19:02.600]                         lapply(seq_along(...future.elements_ii), 
[13:19:02.600]                           FUN = function(jj) {
[13:19:02.600]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.600]                             ...future.FUN(...future.X_jj, ...)
[13:19:02.600]                           })
[13:19:02.600]                       }
[13:19:02.600]                     }, args = future.call.arguments)
[13:19:02.600]                   }
[13:19:02.600]                 }, immediateCondition = function(cond) {
[13:19:02.600]                   sendCondition <- ...future.makeSendCondition()
[13:19:02.600]                   sendCondition(cond)
[13:19:02.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.600]                   {
[13:19:02.600]                     inherits <- base::inherits
[13:19:02.600]                     invokeRestart <- base::invokeRestart
[13:19:02.600]                     is.null <- base::is.null
[13:19:02.600]                     muffled <- FALSE
[13:19:02.600]                     if (inherits(cond, "message")) {
[13:19:02.600]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:02.600]                       if (muffled) 
[13:19:02.600]                         invokeRestart("muffleMessage")
[13:19:02.600]                     }
[13:19:02.600]                     else if (inherits(cond, "warning")) {
[13:19:02.600]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:02.600]                       if (muffled) 
[13:19:02.600]                         invokeRestart("muffleWarning")
[13:19:02.600]                     }
[13:19:02.600]                     else if (inherits(cond, "condition")) {
[13:19:02.600]                       if (!is.null(pattern)) {
[13:19:02.600]                         computeRestarts <- base::computeRestarts
[13:19:02.600]                         grepl <- base::grepl
[13:19:02.600]                         restarts <- computeRestarts(cond)
[13:19:02.600]                         for (restart in restarts) {
[13:19:02.600]                           name <- restart$name
[13:19:02.600]                           if (is.null(name)) 
[13:19:02.600]                             next
[13:19:02.600]                           if (!grepl(pattern, name)) 
[13:19:02.600]                             next
[13:19:02.600]                           invokeRestart(restart)
[13:19:02.600]                           muffled <- TRUE
[13:19:02.600]                           break
[13:19:02.600]                         }
[13:19:02.600]                       }
[13:19:02.600]                     }
[13:19:02.600]                     invisible(muffled)
[13:19:02.600]                   }
[13:19:02.600]                   muffleCondition(cond)
[13:19:02.600]                 })
[13:19:02.600]             }))
[13:19:02.600]             future::FutureResult(value = ...future.value$value, 
[13:19:02.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.600]                   ...future.rng), globalenv = if (FALSE) 
[13:19:02.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:02.600]                     ...future.globalenv.names))
[13:19:02.600]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:02.600]         }, condition = base::local({
[13:19:02.600]             c <- base::c
[13:19:02.600]             inherits <- base::inherits
[13:19:02.600]             invokeRestart <- base::invokeRestart
[13:19:02.600]             length <- base::length
[13:19:02.600]             list <- base::list
[13:19:02.600]             seq.int <- base::seq.int
[13:19:02.600]             signalCondition <- base::signalCondition
[13:19:02.600]             sys.calls <- base::sys.calls
[13:19:02.600]             `[[` <- base::`[[`
[13:19:02.600]             `+` <- base::`+`
[13:19:02.600]             `<<-` <- base::`<<-`
[13:19:02.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:02.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:02.600]                   3L)]
[13:19:02.600]             }
[13:19:02.600]             function(cond) {
[13:19:02.600]                 is_error <- inherits(cond, "error")
[13:19:02.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:02.600]                   NULL)
[13:19:02.600]                 if (is_error) {
[13:19:02.600]                   sessionInformation <- function() {
[13:19:02.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:02.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:02.600]                       search = base::search(), system = base::Sys.info())
[13:19:02.600]                   }
[13:19:02.600]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:02.600]                     cond$call), session = sessionInformation(), 
[13:19:02.600]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:02.600]                   signalCondition(cond)
[13:19:02.600]                 }
[13:19:02.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:02.600]                 "immediateCondition"))) {
[13:19:02.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:02.600]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:02.600]                   if (TRUE && !signal) {
[13:19:02.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.600]                     {
[13:19:02.600]                       inherits <- base::inherits
[13:19:02.600]                       invokeRestart <- base::invokeRestart
[13:19:02.600]                       is.null <- base::is.null
[13:19:02.600]                       muffled <- FALSE
[13:19:02.600]                       if (inherits(cond, "message")) {
[13:19:02.600]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.600]                         if (muffled) 
[13:19:02.600]                           invokeRestart("muffleMessage")
[13:19:02.600]                       }
[13:19:02.600]                       else if (inherits(cond, "warning")) {
[13:19:02.600]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.600]                         if (muffled) 
[13:19:02.600]                           invokeRestart("muffleWarning")
[13:19:02.600]                       }
[13:19:02.600]                       else if (inherits(cond, "condition")) {
[13:19:02.600]                         if (!is.null(pattern)) {
[13:19:02.600]                           computeRestarts <- base::computeRestarts
[13:19:02.600]                           grepl <- base::grepl
[13:19:02.600]                           restarts <- computeRestarts(cond)
[13:19:02.600]                           for (restart in restarts) {
[13:19:02.600]                             name <- restart$name
[13:19:02.600]                             if (is.null(name)) 
[13:19:02.600]                               next
[13:19:02.600]                             if (!grepl(pattern, name)) 
[13:19:02.600]                               next
[13:19:02.600]                             invokeRestart(restart)
[13:19:02.600]                             muffled <- TRUE
[13:19:02.600]                             break
[13:19:02.600]                           }
[13:19:02.600]                         }
[13:19:02.600]                       }
[13:19:02.600]                       invisible(muffled)
[13:19:02.600]                     }
[13:19:02.600]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.600]                   }
[13:19:02.600]                 }
[13:19:02.600]                 else {
[13:19:02.600]                   if (TRUE) {
[13:19:02.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.600]                     {
[13:19:02.600]                       inherits <- base::inherits
[13:19:02.600]                       invokeRestart <- base::invokeRestart
[13:19:02.600]                       is.null <- base::is.null
[13:19:02.600]                       muffled <- FALSE
[13:19:02.600]                       if (inherits(cond, "message")) {
[13:19:02.600]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.600]                         if (muffled) 
[13:19:02.600]                           invokeRestart("muffleMessage")
[13:19:02.600]                       }
[13:19:02.600]                       else if (inherits(cond, "warning")) {
[13:19:02.600]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.600]                         if (muffled) 
[13:19:02.600]                           invokeRestart("muffleWarning")
[13:19:02.600]                       }
[13:19:02.600]                       else if (inherits(cond, "condition")) {
[13:19:02.600]                         if (!is.null(pattern)) {
[13:19:02.600]                           computeRestarts <- base::computeRestarts
[13:19:02.600]                           grepl <- base::grepl
[13:19:02.600]                           restarts <- computeRestarts(cond)
[13:19:02.600]                           for (restart in restarts) {
[13:19:02.600]                             name <- restart$name
[13:19:02.600]                             if (is.null(name)) 
[13:19:02.600]                               next
[13:19:02.600]                             if (!grepl(pattern, name)) 
[13:19:02.600]                               next
[13:19:02.600]                             invokeRestart(restart)
[13:19:02.600]                             muffled <- TRUE
[13:19:02.600]                             break
[13:19:02.600]                           }
[13:19:02.600]                         }
[13:19:02.600]                       }
[13:19:02.600]                       invisible(muffled)
[13:19:02.600]                     }
[13:19:02.600]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.600]                   }
[13:19:02.600]                 }
[13:19:02.600]             }
[13:19:02.600]         }))
[13:19:02.600]     }, error = function(ex) {
[13:19:02.600]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:02.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.600]                 ...future.rng), started = ...future.startTime, 
[13:19:02.600]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:02.600]             version = "1.8"), class = "FutureResult")
[13:19:02.600]     }, finally = {
[13:19:02.600]         if (!identical(...future.workdir, getwd())) 
[13:19:02.600]             setwd(...future.workdir)
[13:19:02.600]         {
[13:19:02.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:02.600]                 ...future.oldOptions$nwarnings <- NULL
[13:19:02.600]             }
[13:19:02.600]             base::options(...future.oldOptions)
[13:19:02.600]             if (.Platform$OS.type == "windows") {
[13:19:02.600]                 old_names <- names(...future.oldEnvVars)
[13:19:02.600]                 envs <- base::Sys.getenv()
[13:19:02.600]                 names <- names(envs)
[13:19:02.600]                 common <- intersect(names, old_names)
[13:19:02.600]                 added <- setdiff(names, old_names)
[13:19:02.600]                 removed <- setdiff(old_names, names)
[13:19:02.600]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:02.600]                   envs[common]]
[13:19:02.600]                 NAMES <- toupper(changed)
[13:19:02.600]                 args <- list()
[13:19:02.600]                 for (kk in seq_along(NAMES)) {
[13:19:02.600]                   name <- changed[[kk]]
[13:19:02.600]                   NAME <- NAMES[[kk]]
[13:19:02.600]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.600]                     next
[13:19:02.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.600]                 }
[13:19:02.600]                 NAMES <- toupper(added)
[13:19:02.600]                 for (kk in seq_along(NAMES)) {
[13:19:02.600]                   name <- added[[kk]]
[13:19:02.600]                   NAME <- NAMES[[kk]]
[13:19:02.600]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.600]                     next
[13:19:02.600]                   args[[name]] <- ""
[13:19:02.600]                 }
[13:19:02.600]                 NAMES <- toupper(removed)
[13:19:02.600]                 for (kk in seq_along(NAMES)) {
[13:19:02.600]                   name <- removed[[kk]]
[13:19:02.600]                   NAME <- NAMES[[kk]]
[13:19:02.600]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.600]                     next
[13:19:02.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.600]                 }
[13:19:02.600]                 if (length(args) > 0) 
[13:19:02.600]                   base::do.call(base::Sys.setenv, args = args)
[13:19:02.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:02.600]             }
[13:19:02.600]             else {
[13:19:02.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:02.600]             }
[13:19:02.600]             {
[13:19:02.600]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:02.600]                   0L) {
[13:19:02.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:02.600]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:02.600]                   base::options(opts)
[13:19:02.600]                 }
[13:19:02.600]                 {
[13:19:02.600]                   {
[13:19:02.600]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:02.600]                     NULL
[13:19:02.600]                   }
[13:19:02.600]                   options(future.plan = NULL)
[13:19:02.600]                   if (is.na(NA_character_)) 
[13:19:02.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:02.600]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:02.600]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:02.600]                     envir = parent.frame()) 
[13:19:02.600]                   {
[13:19:02.600]                     if (is.function(workers)) 
[13:19:02.600]                       workers <- workers()
[13:19:02.600]                     workers <- structure(as.integer(workers), 
[13:19:02.600]                       class = class(workers))
[13:19:02.600]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:02.600]                       workers >= 1)
[13:19:02.600]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:02.600]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:02.600]                     }
[13:19:02.600]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:02.600]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:02.600]                       envir = envir)
[13:19:02.600]                     if (!future$lazy) 
[13:19:02.600]                       future <- run(future)
[13:19:02.600]                     invisible(future)
[13:19:02.600]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:02.600]                 }
[13:19:02.600]             }
[13:19:02.600]         }
[13:19:02.600]     })
[13:19:02.600]     if (TRUE) {
[13:19:02.600]         base::sink(type = "output", split = FALSE)
[13:19:02.600]         if (TRUE) {
[13:19:02.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:02.600]         }
[13:19:02.600]         else {
[13:19:02.600]             ...future.result["stdout"] <- base::list(NULL)
[13:19:02.600]         }
[13:19:02.600]         base::close(...future.stdout)
[13:19:02.600]         ...future.stdout <- NULL
[13:19:02.600]     }
[13:19:02.600]     ...future.result$conditions <- ...future.conditions
[13:19:02.600]     ...future.result$finished <- base::Sys.time()
[13:19:02.600]     ...future.result
[13:19:02.600] }
[13:19:02.603] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[13:19:02.603] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:02.645] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:02.645] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:19:02.646] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:19:02.646] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:02.646] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:02.646] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:02.689] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:02.689] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:02.733] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:02.733] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:02.734] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.734] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:02.734] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:02.734] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:02.735] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.735] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:02.735] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:02.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:02.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:02.737] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:02.737] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[13:19:02.737] MultisessionFuture started
[13:19:02.738] - Launch lazy future ... done
[13:19:02.738] run() for ‘MultisessionFuture’ ... done
[13:19:02.738] Created future:
[13:19:02.738] MultisessionFuture:
[13:19:02.738] Label: ‘future_vapply-2’
[13:19:02.738] Expression:
[13:19:02.738] {
[13:19:02.738]     do.call(function(...) {
[13:19:02.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.738]             on.exit(options(oopts), add = TRUE)
[13:19:02.738]         }
[13:19:02.738]         {
[13:19:02.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.738]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.738]             })
[13:19:02.738]         }
[13:19:02.738]     }, args = future.call.arguments)
[13:19:02.738] }
[13:19:02.738] Lazy evaluation: FALSE
[13:19:02.738] Asynchronous evaluation: TRUE
[13:19:02.738] Local evaluation: TRUE
[13:19:02.738] Environment: R_GlobalEnv
[13:19:02.738] Capture standard output: TRUE
[13:19:02.738] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:02.738] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:02.738] Packages: 1 packages (‘future.apply’)
[13:19:02.738] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:02.738] Resolved: FALSE
[13:19:02.738] Value: <not collected>
[13:19:02.738] Conditions captured: <none>
[13:19:02.738] Early signaling: FALSE
[13:19:02.738] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:02.738] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.750] Chunk #2 of 2 ... DONE
[13:19:02.750] Launching 2 futures (chunks) ... DONE
[13:19:02.750] Resolving 2 futures (chunks) ...
[13:19:02.750] resolve() on list ...
[13:19:02.750]  recursive: 0
[13:19:02.750]  length: 2
[13:19:02.750] 
[13:19:02.751] receiveMessageFromWorker() for ClusterFuture ...
[13:19:02.751] - Validating connection of MultisessionFuture
[13:19:02.751] - received message: FutureResult
[13:19:02.751] - Received FutureResult
[13:19:02.751] - Erased future from FutureRegistry
[13:19:02.752] result() for ClusterFuture ...
[13:19:02.752] - result already collected: FutureResult
[13:19:02.752] result() for ClusterFuture ... done
[13:19:02.752] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:02.752] Future #1
[13:19:02.752] result() for ClusterFuture ...
[13:19:02.752] - result already collected: FutureResult
[13:19:02.752] result() for ClusterFuture ... done
[13:19:02.752] result() for ClusterFuture ...
[13:19:02.752] - result already collected: FutureResult
[13:19:02.752] result() for ClusterFuture ... done
[13:19:02.753] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:02.753] - nx: 2
[13:19:02.753] - relay: TRUE
[13:19:02.753] - stdout: TRUE
[13:19:02.753] - signal: TRUE
[13:19:02.753] - resignal: FALSE
[13:19:02.753] - force: TRUE
[13:19:02.753] - relayed: [n=2] FALSE, FALSE
[13:19:02.753] - queued futures: [n=2] FALSE, FALSE
[13:19:02.753]  - until=1
[13:19:02.753]  - relaying element #1
[13:19:02.754] result() for ClusterFuture ...
[13:19:02.754] - result already collected: FutureResult
[13:19:02.754] result() for ClusterFuture ... done
[13:19:02.754] result() for ClusterFuture ...
[13:19:02.754] - result already collected: FutureResult
[13:19:02.754] result() for ClusterFuture ... done
[13:19:02.754] result() for ClusterFuture ...
[13:19:02.754] - result already collected: FutureResult
[13:19:02.754] result() for ClusterFuture ... done
[13:19:02.754] result() for ClusterFuture ...
[13:19:02.754] - result already collected: FutureResult
[13:19:02.755] result() for ClusterFuture ... done
[13:19:02.755] - relayed: [n=2] TRUE, FALSE
[13:19:02.755] - queued futures: [n=2] TRUE, FALSE
[13:19:02.755] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:02.755]  length: 1 (resolved future 1)
[13:19:02.786] receiveMessageFromWorker() for ClusterFuture ...
[13:19:02.786] - Validating connection of MultisessionFuture
[13:19:02.786] - received message: FutureResult
[13:19:02.786] - Received FutureResult
[13:19:02.787] - Erased future from FutureRegistry
[13:19:02.787] result() for ClusterFuture ...
[13:19:02.787] - result already collected: FutureResult
[13:19:02.787] result() for ClusterFuture ... done
[13:19:02.787] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:02.787] Future #2
[13:19:02.787] result() for ClusterFuture ...
[13:19:02.787] - result already collected: FutureResult
[13:19:02.787] result() for ClusterFuture ... done
[13:19:02.787] result() for ClusterFuture ...
[13:19:02.788] - result already collected: FutureResult
[13:19:02.788] result() for ClusterFuture ... done
[13:19:02.788] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:02.788] - nx: 2
[13:19:02.788] - relay: TRUE
[13:19:02.788] - stdout: TRUE
[13:19:02.788] - signal: TRUE
[13:19:02.788] - resignal: FALSE
[13:19:02.788] - force: TRUE
[13:19:02.788] - relayed: [n=2] TRUE, FALSE
[13:19:02.788] - queued futures: [n=2] TRUE, FALSE
[13:19:02.789]  - until=2
[13:19:02.789]  - relaying element #2
[13:19:02.789] result() for ClusterFuture ...
[13:19:02.789] - result already collected: FutureResult
[13:19:02.789] result() for ClusterFuture ... done
[13:19:02.789] result() for ClusterFuture ...
[13:19:02.789] - result already collected: FutureResult
[13:19:02.789] result() for ClusterFuture ... done
[13:19:02.789] result() for ClusterFuture ...
[13:19:02.789] - result already collected: FutureResult
[13:19:02.789] result() for ClusterFuture ... done
[13:19:02.790] result() for ClusterFuture ...
[13:19:02.790] - result already collected: FutureResult
[13:19:02.790] result() for ClusterFuture ... done
[13:19:02.790] - relayed: [n=2] TRUE, TRUE
[13:19:02.790] - queued futures: [n=2] TRUE, TRUE
[13:19:02.790] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:02.790]  length: 0 (resolved future 2)
[13:19:02.790] Relaying remaining futures
[13:19:02.790] signalConditionsASAP(NULL, pos=0) ...
[13:19:02.790] - nx: 2
[13:19:02.790] - relay: TRUE
[13:19:02.791] - stdout: TRUE
[13:19:02.791] - signal: TRUE
[13:19:02.791] - resignal: FALSE
[13:19:02.791] - force: TRUE
[13:19:02.791] - relayed: [n=2] TRUE, TRUE
[13:19:02.791] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:02.791] - relayed: [n=2] TRUE, TRUE
[13:19:02.791] - queued futures: [n=2] TRUE, TRUE
[13:19:02.791] signalConditionsASAP(NULL, pos=0) ... done
[13:19:02.791] resolve() on list ... DONE
[13:19:02.791] result() for ClusterFuture ...
[13:19:02.792] - result already collected: FutureResult
[13:19:02.792] result() for ClusterFuture ... done
[13:19:02.792] result() for ClusterFuture ...
[13:19:02.792] - result already collected: FutureResult
[13:19:02.792] result() for ClusterFuture ... done
[13:19:02.792] result() for ClusterFuture ...
[13:19:02.792] - result already collected: FutureResult
[13:19:02.792] result() for ClusterFuture ... done
[13:19:02.792] result() for ClusterFuture ...
[13:19:02.792] - result already collected: FutureResult
[13:19:02.792] result() for ClusterFuture ... done
[13:19:02.793]  - Number of value chunks collected: 2
[13:19:02.793] Resolving 2 futures (chunks) ... DONE
[13:19:02.793] Reducing values from 2 chunks ...
[13:19:02.793]  - Number of values collected after concatenation: 10
[13:19:02.793]  - Number of values expected: 10
[13:19:02.793] Reducing values from 2 chunks ... DONE
[13:19:02.793] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:19:02.794] future_lapply() ...
[13:19:02.799] Number of chunks: 2
[13:19:02.800] getGlobalsAndPackagesXApply() ...
[13:19:02.800]  - future.globals: TRUE
[13:19:02.800] getGlobalsAndPackages() ...
[13:19:02.800] Searching for globals...
[13:19:02.803] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:19:02.803] Searching for globals ... DONE
[13:19:02.804] Resolving globals: FALSE
[13:19:02.804] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:19:02.805] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:02.805] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:02.805] - packages: [1] ‘future.apply’
[13:19:02.805] getGlobalsAndPackages() ... DONE
[13:19:02.805]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:02.805]  - needed namespaces: [n=1] ‘future.apply’
[13:19:02.806] Finding globals ... DONE
[13:19:02.806]  - use_args: TRUE
[13:19:02.806]  - Getting '...' globals ...
[13:19:02.806] resolve() on list ...
[13:19:02.806]  recursive: 0
[13:19:02.806]  length: 1
[13:19:02.806]  elements: ‘...’
[13:19:02.806]  length: 0 (resolved future 1)
[13:19:02.807] resolve() on list ... DONE
[13:19:02.807]    - '...' content: [n=0] 
[13:19:02.807] List of 1
[13:19:02.807]  $ ...: list()
[13:19:02.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:02.807]  - attr(*, "where")=List of 1
[13:19:02.807]   ..$ ...:<environment: 0x555f7cf7d0d0> 
[13:19:02.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:02.807]  - attr(*, "resolved")= logi TRUE
[13:19:02.807]  - attr(*, "total_size")= num NA
[13:19:02.809]  - Getting '...' globals ... DONE
[13:19:02.809] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:02.810] List of 8
[13:19:02.810]  $ ...future.FUN:function (x, ...)  
[13:19:02.810]  $ x_FUN        :function (x)  
[13:19:02.810]  $ times        : int 2
[13:19:02.810]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:02.810]  $ stop_if_not  :function (...)  
[13:19:02.810]  $ dim          : NULL
[13:19:02.810]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:02.810]  $ ...          : list()
[13:19:02.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:02.810]  - attr(*, "where")=List of 8
[13:19:02.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:02.810]   ..$ ...          :<environment: 0x555f7cf7d0d0> 
[13:19:02.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:02.810]  - attr(*, "resolved")= logi FALSE
[13:19:02.810]  - attr(*, "total_size")= num 96456
[13:19:02.815] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:02.815] getGlobalsAndPackagesXApply() ... DONE
[13:19:02.815] Number of futures (= number of chunks): 2
[13:19:02.815] Launching 2 futures (chunks) ...
[13:19:02.815] Chunk #1 of 2 ...
[13:19:02.815]  - Finding globals in 'X' for chunk #1 ...
[13:19:02.815] getGlobalsAndPackages() ...
[13:19:02.816] Searching for globals...
[13:19:02.816] 
[13:19:02.816] Searching for globals ... DONE
[13:19:02.816] - globals: [0] <none>
[13:19:02.816] getGlobalsAndPackages() ... DONE
[13:19:02.816]    + additional globals found: [n=0] 
[13:19:02.816]    + additional namespaces needed: [n=0] 
[13:19:02.816]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:02.816]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:02.817]  - seeds: <none>
[13:19:02.817] getGlobalsAndPackages() ...
[13:19:02.817] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.817] Resolving globals: FALSE
[13:19:02.817] Tweak future expression to call with '...' arguments ...
[13:19:02.817] {
[13:19:02.817]     do.call(function(...) {
[13:19:02.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.817]             on.exit(options(oopts), add = TRUE)
[13:19:02.817]         }
[13:19:02.817]         {
[13:19:02.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.817]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.817]             })
[13:19:02.817]         }
[13:19:02.817]     }, args = future.call.arguments)
[13:19:02.817] }
[13:19:02.817] Tweak future expression to call with '...' arguments ... DONE
[13:19:02.818] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.818] - packages: [1] ‘future.apply’
[13:19:02.818] getGlobalsAndPackages() ... DONE
[13:19:02.818] run() for ‘Future’ ...
[13:19:02.819] - state: ‘created’
[13:19:02.819] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:02.834] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.834] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:02.834]   - Field: ‘node’
[13:19:02.834]   - Field: ‘label’
[13:19:02.834]   - Field: ‘local’
[13:19:02.834]   - Field: ‘owner’
[13:19:02.834]   - Field: ‘envir’
[13:19:02.834]   - Field: ‘workers’
[13:19:02.835]   - Field: ‘packages’
[13:19:02.835]   - Field: ‘gc’
[13:19:02.835]   - Field: ‘conditions’
[13:19:02.835]   - Field: ‘persistent’
[13:19:02.835]   - Field: ‘expr’
[13:19:02.835]   - Field: ‘uuid’
[13:19:02.835]   - Field: ‘seed’
[13:19:02.835]   - Field: ‘version’
[13:19:02.835]   - Field: ‘result’
[13:19:02.835]   - Field: ‘asynchronous’
[13:19:02.835]   - Field: ‘calls’
[13:19:02.836]   - Field: ‘globals’
[13:19:02.836]   - Field: ‘stdout’
[13:19:02.836]   - Field: ‘earlySignal’
[13:19:02.836]   - Field: ‘lazy’
[13:19:02.836]   - Field: ‘state’
[13:19:02.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:02.836] - Launch lazy future ...
[13:19:02.836] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:02.836] Packages needed by future strategies (n = 0): <none>
[13:19:02.837] {
[13:19:02.837]     {
[13:19:02.837]         {
[13:19:02.837]             ...future.startTime <- base::Sys.time()
[13:19:02.837]             {
[13:19:02.837]                 {
[13:19:02.837]                   {
[13:19:02.837]                     {
[13:19:02.837]                       {
[13:19:02.837]                         base::local({
[13:19:02.837]                           has_future <- base::requireNamespace("future", 
[13:19:02.837]                             quietly = TRUE)
[13:19:02.837]                           if (has_future) {
[13:19:02.837]                             ns <- base::getNamespace("future")
[13:19:02.837]                             version <- ns[[".package"]][["version"]]
[13:19:02.837]                             if (is.null(version)) 
[13:19:02.837]                               version <- utils::packageVersion("future")
[13:19:02.837]                           }
[13:19:02.837]                           else {
[13:19:02.837]                             version <- NULL
[13:19:02.837]                           }
[13:19:02.837]                           if (!has_future || version < "1.8.0") {
[13:19:02.837]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:02.837]                               "", base::R.version$version.string), 
[13:19:02.837]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:02.837]                                 base::R.version$platform, 8 * 
[13:19:02.837]                                   base::.Machine$sizeof.pointer), 
[13:19:02.837]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:02.837]                                 "release", "version")], collapse = " "), 
[13:19:02.837]                               hostname = base::Sys.info()[["nodename"]])
[13:19:02.837]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:02.837]                               info)
[13:19:02.837]                             info <- base::paste(info, collapse = "; ")
[13:19:02.837]                             if (!has_future) {
[13:19:02.837]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:02.837]                                 info)
[13:19:02.837]                             }
[13:19:02.837]                             else {
[13:19:02.837]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:02.837]                                 info, version)
[13:19:02.837]                             }
[13:19:02.837]                             base::stop(msg)
[13:19:02.837]                           }
[13:19:02.837]                         })
[13:19:02.837]                       }
[13:19:02.837]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:02.837]                       base::options(mc.cores = 1L)
[13:19:02.837]                     }
[13:19:02.837]                     base::local({
[13:19:02.837]                       for (pkg in "future.apply") {
[13:19:02.837]                         base::loadNamespace(pkg)
[13:19:02.837]                         base::library(pkg, character.only = TRUE)
[13:19:02.837]                       }
[13:19:02.837]                     })
[13:19:02.837]                   }
[13:19:02.837]                   options(future.plan = NULL)
[13:19:02.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:02.837]                 }
[13:19:02.837]                 ...future.workdir <- getwd()
[13:19:02.837]             }
[13:19:02.837]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:02.837]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:02.837]         }
[13:19:02.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:02.837]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:02.837]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:02.837]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:02.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:02.837]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:02.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:02.837]             base::names(...future.oldOptions))
[13:19:02.837]     }
[13:19:02.837]     if (FALSE) {
[13:19:02.837]     }
[13:19:02.837]     else {
[13:19:02.837]         if (TRUE) {
[13:19:02.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:02.837]                 open = "w")
[13:19:02.837]         }
[13:19:02.837]         else {
[13:19:02.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:02.837]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:02.837]         }
[13:19:02.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:02.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:02.837]             base::sink(type = "output", split = FALSE)
[13:19:02.837]             base::close(...future.stdout)
[13:19:02.837]         }, add = TRUE)
[13:19:02.837]     }
[13:19:02.837]     ...future.frame <- base::sys.nframe()
[13:19:02.837]     ...future.conditions <- base::list()
[13:19:02.837]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:02.837]     if (FALSE) {
[13:19:02.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:02.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:02.837]     }
[13:19:02.837]     ...future.result <- base::tryCatch({
[13:19:02.837]         base::withCallingHandlers({
[13:19:02.837]             ...future.value <- base::withVisible(base::local({
[13:19:02.837]                 ...future.makeSendCondition <- local({
[13:19:02.837]                   sendCondition <- NULL
[13:19:02.837]                   function(frame = 1L) {
[13:19:02.837]                     if (is.function(sendCondition)) 
[13:19:02.837]                       return(sendCondition)
[13:19:02.837]                     ns <- getNamespace("parallel")
[13:19:02.837]                     if (exists("sendData", mode = "function", 
[13:19:02.837]                       envir = ns)) {
[13:19:02.837]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:02.837]                         envir = ns)
[13:19:02.837]                       envir <- sys.frame(frame)
[13:19:02.837]                       master <- NULL
[13:19:02.837]                       while (!identical(envir, .GlobalEnv) && 
[13:19:02.837]                         !identical(envir, emptyenv())) {
[13:19:02.837]                         if (exists("master", mode = "list", envir = envir, 
[13:19:02.837]                           inherits = FALSE)) {
[13:19:02.837]                           master <- get("master", mode = "list", 
[13:19:02.837]                             envir = envir, inherits = FALSE)
[13:19:02.837]                           if (inherits(master, c("SOCKnode", 
[13:19:02.837]                             "SOCK0node"))) {
[13:19:02.837]                             sendCondition <<- function(cond) {
[13:19:02.837]                               data <- list(type = "VALUE", value = cond, 
[13:19:02.837]                                 success = TRUE)
[13:19:02.837]                               parallel_sendData(master, data)
[13:19:02.837]                             }
[13:19:02.837]                             return(sendCondition)
[13:19:02.837]                           }
[13:19:02.837]                         }
[13:19:02.837]                         frame <- frame + 1L
[13:19:02.837]                         envir <- sys.frame(frame)
[13:19:02.837]                       }
[13:19:02.837]                     }
[13:19:02.837]                     sendCondition <<- function(cond) NULL
[13:19:02.837]                   }
[13:19:02.837]                 })
[13:19:02.837]                 withCallingHandlers({
[13:19:02.837]                   {
[13:19:02.837]                     do.call(function(...) {
[13:19:02.837]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.837]                       if (!identical(...future.globals.maxSize.org, 
[13:19:02.837]                         ...future.globals.maxSize)) {
[13:19:02.837]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.837]                         on.exit(options(oopts), add = TRUE)
[13:19:02.837]                       }
[13:19:02.837]                       {
[13:19:02.837]                         lapply(seq_along(...future.elements_ii), 
[13:19:02.837]                           FUN = function(jj) {
[13:19:02.837]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.837]                             ...future.FUN(...future.X_jj, ...)
[13:19:02.837]                           })
[13:19:02.837]                       }
[13:19:02.837]                     }, args = future.call.arguments)
[13:19:02.837]                   }
[13:19:02.837]                 }, immediateCondition = function(cond) {
[13:19:02.837]                   sendCondition <- ...future.makeSendCondition()
[13:19:02.837]                   sendCondition(cond)
[13:19:02.837]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.837]                   {
[13:19:02.837]                     inherits <- base::inherits
[13:19:02.837]                     invokeRestart <- base::invokeRestart
[13:19:02.837]                     is.null <- base::is.null
[13:19:02.837]                     muffled <- FALSE
[13:19:02.837]                     if (inherits(cond, "message")) {
[13:19:02.837]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:02.837]                       if (muffled) 
[13:19:02.837]                         invokeRestart("muffleMessage")
[13:19:02.837]                     }
[13:19:02.837]                     else if (inherits(cond, "warning")) {
[13:19:02.837]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:02.837]                       if (muffled) 
[13:19:02.837]                         invokeRestart("muffleWarning")
[13:19:02.837]                     }
[13:19:02.837]                     else if (inherits(cond, "condition")) {
[13:19:02.837]                       if (!is.null(pattern)) {
[13:19:02.837]                         computeRestarts <- base::computeRestarts
[13:19:02.837]                         grepl <- base::grepl
[13:19:02.837]                         restarts <- computeRestarts(cond)
[13:19:02.837]                         for (restart in restarts) {
[13:19:02.837]                           name <- restart$name
[13:19:02.837]                           if (is.null(name)) 
[13:19:02.837]                             next
[13:19:02.837]                           if (!grepl(pattern, name)) 
[13:19:02.837]                             next
[13:19:02.837]                           invokeRestart(restart)
[13:19:02.837]                           muffled <- TRUE
[13:19:02.837]                           break
[13:19:02.837]                         }
[13:19:02.837]                       }
[13:19:02.837]                     }
[13:19:02.837]                     invisible(muffled)
[13:19:02.837]                   }
[13:19:02.837]                   muffleCondition(cond)
[13:19:02.837]                 })
[13:19:02.837]             }))
[13:19:02.837]             future::FutureResult(value = ...future.value$value, 
[13:19:02.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.837]                   ...future.rng), globalenv = if (FALSE) 
[13:19:02.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:02.837]                     ...future.globalenv.names))
[13:19:02.837]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:02.837]         }, condition = base::local({
[13:19:02.837]             c <- base::c
[13:19:02.837]             inherits <- base::inherits
[13:19:02.837]             invokeRestart <- base::invokeRestart
[13:19:02.837]             length <- base::length
[13:19:02.837]             list <- base::list
[13:19:02.837]             seq.int <- base::seq.int
[13:19:02.837]             signalCondition <- base::signalCondition
[13:19:02.837]             sys.calls <- base::sys.calls
[13:19:02.837]             `[[` <- base::`[[`
[13:19:02.837]             `+` <- base::`+`
[13:19:02.837]             `<<-` <- base::`<<-`
[13:19:02.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:02.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:02.837]                   3L)]
[13:19:02.837]             }
[13:19:02.837]             function(cond) {
[13:19:02.837]                 is_error <- inherits(cond, "error")
[13:19:02.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:02.837]                   NULL)
[13:19:02.837]                 if (is_error) {
[13:19:02.837]                   sessionInformation <- function() {
[13:19:02.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:02.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:02.837]                       search = base::search(), system = base::Sys.info())
[13:19:02.837]                   }
[13:19:02.837]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:02.837]                     cond$call), session = sessionInformation(), 
[13:19:02.837]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:02.837]                   signalCondition(cond)
[13:19:02.837]                 }
[13:19:02.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:02.837]                 "immediateCondition"))) {
[13:19:02.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:02.837]                   ...future.conditions[[length(...future.conditions) + 
[13:19:02.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:02.837]                   if (TRUE && !signal) {
[13:19:02.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.837]                     {
[13:19:02.837]                       inherits <- base::inherits
[13:19:02.837]                       invokeRestart <- base::invokeRestart
[13:19:02.837]                       is.null <- base::is.null
[13:19:02.837]                       muffled <- FALSE
[13:19:02.837]                       if (inherits(cond, "message")) {
[13:19:02.837]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.837]                         if (muffled) 
[13:19:02.837]                           invokeRestart("muffleMessage")
[13:19:02.837]                       }
[13:19:02.837]                       else if (inherits(cond, "warning")) {
[13:19:02.837]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.837]                         if (muffled) 
[13:19:02.837]                           invokeRestart("muffleWarning")
[13:19:02.837]                       }
[13:19:02.837]                       else if (inherits(cond, "condition")) {
[13:19:02.837]                         if (!is.null(pattern)) {
[13:19:02.837]                           computeRestarts <- base::computeRestarts
[13:19:02.837]                           grepl <- base::grepl
[13:19:02.837]                           restarts <- computeRestarts(cond)
[13:19:02.837]                           for (restart in restarts) {
[13:19:02.837]                             name <- restart$name
[13:19:02.837]                             if (is.null(name)) 
[13:19:02.837]                               next
[13:19:02.837]                             if (!grepl(pattern, name)) 
[13:19:02.837]                               next
[13:19:02.837]                             invokeRestart(restart)
[13:19:02.837]                             muffled <- TRUE
[13:19:02.837]                             break
[13:19:02.837]                           }
[13:19:02.837]                         }
[13:19:02.837]                       }
[13:19:02.837]                       invisible(muffled)
[13:19:02.837]                     }
[13:19:02.837]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.837]                   }
[13:19:02.837]                 }
[13:19:02.837]                 else {
[13:19:02.837]                   if (TRUE) {
[13:19:02.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:02.837]                     {
[13:19:02.837]                       inherits <- base::inherits
[13:19:02.837]                       invokeRestart <- base::invokeRestart
[13:19:02.837]                       is.null <- base::is.null
[13:19:02.837]                       muffled <- FALSE
[13:19:02.837]                       if (inherits(cond, "message")) {
[13:19:02.837]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:02.837]                         if (muffled) 
[13:19:02.837]                           invokeRestart("muffleMessage")
[13:19:02.837]                       }
[13:19:02.837]                       else if (inherits(cond, "warning")) {
[13:19:02.837]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:02.837]                         if (muffled) 
[13:19:02.837]                           invokeRestart("muffleWarning")
[13:19:02.837]                       }
[13:19:02.837]                       else if (inherits(cond, "condition")) {
[13:19:02.837]                         if (!is.null(pattern)) {
[13:19:02.837]                           computeRestarts <- base::computeRestarts
[13:19:02.837]                           grepl <- base::grepl
[13:19:02.837]                           restarts <- computeRestarts(cond)
[13:19:02.837]                           for (restart in restarts) {
[13:19:02.837]                             name <- restart$name
[13:19:02.837]                             if (is.null(name)) 
[13:19:02.837]                               next
[13:19:02.837]                             if (!grepl(pattern, name)) 
[13:19:02.837]                               next
[13:19:02.837]                             invokeRestart(restart)
[13:19:02.837]                             muffled <- TRUE
[13:19:02.837]                             break
[13:19:02.837]                           }
[13:19:02.837]                         }
[13:19:02.837]                       }
[13:19:02.837]                       invisible(muffled)
[13:19:02.837]                     }
[13:19:02.837]                     muffleCondition(cond, pattern = "^muffle")
[13:19:02.837]                   }
[13:19:02.837]                 }
[13:19:02.837]             }
[13:19:02.837]         }))
[13:19:02.837]     }, error = function(ex) {
[13:19:02.837]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:02.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:02.837]                 ...future.rng), started = ...future.startTime, 
[13:19:02.837]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:02.837]             version = "1.8"), class = "FutureResult")
[13:19:02.837]     }, finally = {
[13:19:02.837]         if (!identical(...future.workdir, getwd())) 
[13:19:02.837]             setwd(...future.workdir)
[13:19:02.837]         {
[13:19:02.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:02.837]                 ...future.oldOptions$nwarnings <- NULL
[13:19:02.837]             }
[13:19:02.837]             base::options(...future.oldOptions)
[13:19:02.837]             if (.Platform$OS.type == "windows") {
[13:19:02.837]                 old_names <- names(...future.oldEnvVars)
[13:19:02.837]                 envs <- base::Sys.getenv()
[13:19:02.837]                 names <- names(envs)
[13:19:02.837]                 common <- intersect(names, old_names)
[13:19:02.837]                 added <- setdiff(names, old_names)
[13:19:02.837]                 removed <- setdiff(old_names, names)
[13:19:02.837]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:02.837]                   envs[common]]
[13:19:02.837]                 NAMES <- toupper(changed)
[13:19:02.837]                 args <- list()
[13:19:02.837]                 for (kk in seq_along(NAMES)) {
[13:19:02.837]                   name <- changed[[kk]]
[13:19:02.837]                   NAME <- NAMES[[kk]]
[13:19:02.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.837]                     next
[13:19:02.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.837]                 }
[13:19:02.837]                 NAMES <- toupper(added)
[13:19:02.837]                 for (kk in seq_along(NAMES)) {
[13:19:02.837]                   name <- added[[kk]]
[13:19:02.837]                   NAME <- NAMES[[kk]]
[13:19:02.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.837]                     next
[13:19:02.837]                   args[[name]] <- ""
[13:19:02.837]                 }
[13:19:02.837]                 NAMES <- toupper(removed)
[13:19:02.837]                 for (kk in seq_along(NAMES)) {
[13:19:02.837]                   name <- removed[[kk]]
[13:19:02.837]                   NAME <- NAMES[[kk]]
[13:19:02.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:02.837]                     next
[13:19:02.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:02.837]                 }
[13:19:02.837]                 if (length(args) > 0) 
[13:19:02.837]                   base::do.call(base::Sys.setenv, args = args)
[13:19:02.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:02.837]             }
[13:19:02.837]             else {
[13:19:02.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:02.837]             }
[13:19:02.837]             {
[13:19:02.837]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:02.837]                   0L) {
[13:19:02.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:02.837]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:02.837]                   base::options(opts)
[13:19:02.837]                 }
[13:19:02.837]                 {
[13:19:02.837]                   {
[13:19:02.837]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:02.837]                     NULL
[13:19:02.837]                   }
[13:19:02.837]                   options(future.plan = NULL)
[13:19:02.837]                   if (is.na(NA_character_)) 
[13:19:02.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:02.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:02.837]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:02.837]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:02.837]                     envir = parent.frame()) 
[13:19:02.837]                   {
[13:19:02.837]                     if (is.function(workers)) 
[13:19:02.837]                       workers <- workers()
[13:19:02.837]                     workers <- structure(as.integer(workers), 
[13:19:02.837]                       class = class(workers))
[13:19:02.837]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:02.837]                       workers >= 1)
[13:19:02.837]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:02.837]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:02.837]                     }
[13:19:02.837]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:02.837]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:02.837]                       envir = envir)
[13:19:02.837]                     if (!future$lazy) 
[13:19:02.837]                       future <- run(future)
[13:19:02.837]                     invisible(future)
[13:19:02.837]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:02.837]                 }
[13:19:02.837]             }
[13:19:02.837]         }
[13:19:02.837]     })
[13:19:02.837]     if (TRUE) {
[13:19:02.837]         base::sink(type = "output", split = FALSE)
[13:19:02.837]         if (TRUE) {
[13:19:02.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:02.837]         }
[13:19:02.837]         else {
[13:19:02.837]             ...future.result["stdout"] <- base::list(NULL)
[13:19:02.837]         }
[13:19:02.837]         base::close(...future.stdout)
[13:19:02.837]         ...future.stdout <- NULL
[13:19:02.837]     }
[13:19:02.837]     ...future.result$conditions <- ...future.conditions
[13:19:02.837]     ...future.result$finished <- base::Sys.time()
[13:19:02.837]     ...future.result
[13:19:02.837] }
[13:19:02.840] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[13:19:02.840] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:02.881] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:02.881] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[13:19:02.882] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[13:19:02.882] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:02.882] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:02.882] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:02.925] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:02.925] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:02.969] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:02.969] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:02.970] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.970] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:02.970] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:02.971] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:02.971] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.971] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:02.972] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:02.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:02.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:02.973] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:02.973] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[13:19:02.973] MultisessionFuture started
[13:19:02.974] - Launch lazy future ... done
[13:19:02.974] run() for ‘MultisessionFuture’ ... done
[13:19:02.974] Created future:
[13:19:02.974] MultisessionFuture:
[13:19:02.974] Label: ‘future_vapply-1’
[13:19:02.974] Expression:
[13:19:02.974] {
[13:19:02.974]     do.call(function(...) {
[13:19:02.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.974]             on.exit(options(oopts), add = TRUE)
[13:19:02.974]         }
[13:19:02.974]         {
[13:19:02.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.974]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.974]             })
[13:19:02.974]         }
[13:19:02.974]     }, args = future.call.arguments)
[13:19:02.974] }
[13:19:02.974] Lazy evaluation: FALSE
[13:19:02.974] Asynchronous evaluation: TRUE
[13:19:02.974] Local evaluation: TRUE
[13:19:02.974] Environment: R_GlobalEnv
[13:19:02.974] Capture standard output: TRUE
[13:19:02.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:02.974] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:02.974] Packages: 1 packages (‘future.apply’)
[13:19:02.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:02.974] Resolved: FALSE
[13:19:02.974] Value: <not collected>
[13:19:02.974] Conditions captured: <none>
[13:19:02.974] Early signaling: FALSE
[13:19:02.974] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:02.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:02.986] Chunk #1 of 2 ... DONE
[13:19:02.986] Chunk #2 of 2 ...
[13:19:02.986]  - Finding globals in 'X' for chunk #2 ...
[13:19:02.986] getGlobalsAndPackages() ...
[13:19:02.986] Searching for globals...
[13:19:02.987] 
[13:19:02.987] Searching for globals ... DONE
[13:19:02.987] - globals: [0] <none>
[13:19:02.987] getGlobalsAndPackages() ... DONE
[13:19:02.987]    + additional globals found: [n=0] 
[13:19:02.987]    + additional namespaces needed: [n=0] 
[13:19:02.987]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:02.987]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:02.987]  - seeds: <none>
[13:19:02.988] getGlobalsAndPackages() ...
[13:19:02.988] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.988] Resolving globals: FALSE
[13:19:02.988] Tweak future expression to call with '...' arguments ...
[13:19:02.988] {
[13:19:02.988]     do.call(function(...) {
[13:19:02.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:02.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:02.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:02.988]             on.exit(options(oopts), add = TRUE)
[13:19:02.988]         }
[13:19:02.988]         {
[13:19:02.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:02.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:02.988]                 ...future.FUN(...future.X_jj, ...)
[13:19:02.988]             })
[13:19:02.988]         }
[13:19:02.988]     }, args = future.call.arguments)
[13:19:02.988] }
[13:19:02.988] Tweak future expression to call with '...' arguments ... DONE
[13:19:02.989] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:02.989] - packages: [1] ‘future.apply’
[13:19:02.989] getGlobalsAndPackages() ... DONE
[13:19:02.989] run() for ‘Future’ ...
[13:19:03.030] - state: ‘created’
[13:19:03.030] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:03.045] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:03.045]   - Field: ‘node’
[13:19:03.045]   - Field: ‘label’
[13:19:03.045]   - Field: ‘local’
[13:19:03.045]   - Field: ‘owner’
[13:19:03.045]   - Field: ‘envir’
[13:19:03.046]   - Field: ‘workers’
[13:19:03.046]   - Field: ‘packages’
[13:19:03.046]   - Field: ‘gc’
[13:19:03.046]   - Field: ‘conditions’
[13:19:03.046]   - Field: ‘persistent’
[13:19:03.046]   - Field: ‘expr’
[13:19:03.046]   - Field: ‘uuid’
[13:19:03.046]   - Field: ‘seed’
[13:19:03.046]   - Field: ‘version’
[13:19:03.046]   - Field: ‘result’
[13:19:03.046]   - Field: ‘asynchronous’
[13:19:03.047]   - Field: ‘calls’
[13:19:03.047]   - Field: ‘globals’
[13:19:03.047]   - Field: ‘stdout’
[13:19:03.047]   - Field: ‘earlySignal’
[13:19:03.047]   - Field: ‘lazy’
[13:19:03.047]   - Field: ‘state’
[13:19:03.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:03.047] - Launch lazy future ...
[13:19:03.047] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:03.048] Packages needed by future strategies (n = 0): <none>
[13:19:03.048] {
[13:19:03.048]     {
[13:19:03.048]         {
[13:19:03.048]             ...future.startTime <- base::Sys.time()
[13:19:03.048]             {
[13:19:03.048]                 {
[13:19:03.048]                   {
[13:19:03.048]                     {
[13:19:03.048]                       {
[13:19:03.048]                         base::local({
[13:19:03.048]                           has_future <- base::requireNamespace("future", 
[13:19:03.048]                             quietly = TRUE)
[13:19:03.048]                           if (has_future) {
[13:19:03.048]                             ns <- base::getNamespace("future")
[13:19:03.048]                             version <- ns[[".package"]][["version"]]
[13:19:03.048]                             if (is.null(version)) 
[13:19:03.048]                               version <- utils::packageVersion("future")
[13:19:03.048]                           }
[13:19:03.048]                           else {
[13:19:03.048]                             version <- NULL
[13:19:03.048]                           }
[13:19:03.048]                           if (!has_future || version < "1.8.0") {
[13:19:03.048]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:03.048]                               "", base::R.version$version.string), 
[13:19:03.048]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:03.048]                                 base::R.version$platform, 8 * 
[13:19:03.048]                                   base::.Machine$sizeof.pointer), 
[13:19:03.048]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:03.048]                                 "release", "version")], collapse = " "), 
[13:19:03.048]                               hostname = base::Sys.info()[["nodename"]])
[13:19:03.048]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:03.048]                               info)
[13:19:03.048]                             info <- base::paste(info, collapse = "; ")
[13:19:03.048]                             if (!has_future) {
[13:19:03.048]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:03.048]                                 info)
[13:19:03.048]                             }
[13:19:03.048]                             else {
[13:19:03.048]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:03.048]                                 info, version)
[13:19:03.048]                             }
[13:19:03.048]                             base::stop(msg)
[13:19:03.048]                           }
[13:19:03.048]                         })
[13:19:03.048]                       }
[13:19:03.048]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:03.048]                       base::options(mc.cores = 1L)
[13:19:03.048]                     }
[13:19:03.048]                     base::local({
[13:19:03.048]                       for (pkg in "future.apply") {
[13:19:03.048]                         base::loadNamespace(pkg)
[13:19:03.048]                         base::library(pkg, character.only = TRUE)
[13:19:03.048]                       }
[13:19:03.048]                     })
[13:19:03.048]                   }
[13:19:03.048]                   options(future.plan = NULL)
[13:19:03.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:03.048]                 }
[13:19:03.048]                 ...future.workdir <- getwd()
[13:19:03.048]             }
[13:19:03.048]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:03.048]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:03.048]         }
[13:19:03.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:03.048]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:03.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:03.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:03.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:03.048]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:03.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:03.048]             base::names(...future.oldOptions))
[13:19:03.048]     }
[13:19:03.048]     if (FALSE) {
[13:19:03.048]     }
[13:19:03.048]     else {
[13:19:03.048]         if (TRUE) {
[13:19:03.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:03.048]                 open = "w")
[13:19:03.048]         }
[13:19:03.048]         else {
[13:19:03.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:03.048]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:03.048]         }
[13:19:03.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:03.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:03.048]             base::sink(type = "output", split = FALSE)
[13:19:03.048]             base::close(...future.stdout)
[13:19:03.048]         }, add = TRUE)
[13:19:03.048]     }
[13:19:03.048]     ...future.frame <- base::sys.nframe()
[13:19:03.048]     ...future.conditions <- base::list()
[13:19:03.048]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:03.048]     if (FALSE) {
[13:19:03.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:03.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:03.048]     }
[13:19:03.048]     ...future.result <- base::tryCatch({
[13:19:03.048]         base::withCallingHandlers({
[13:19:03.048]             ...future.value <- base::withVisible(base::local({
[13:19:03.048]                 ...future.makeSendCondition <- local({
[13:19:03.048]                   sendCondition <- NULL
[13:19:03.048]                   function(frame = 1L) {
[13:19:03.048]                     if (is.function(sendCondition)) 
[13:19:03.048]                       return(sendCondition)
[13:19:03.048]                     ns <- getNamespace("parallel")
[13:19:03.048]                     if (exists("sendData", mode = "function", 
[13:19:03.048]                       envir = ns)) {
[13:19:03.048]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:03.048]                         envir = ns)
[13:19:03.048]                       envir <- sys.frame(frame)
[13:19:03.048]                       master <- NULL
[13:19:03.048]                       while (!identical(envir, .GlobalEnv) && 
[13:19:03.048]                         !identical(envir, emptyenv())) {
[13:19:03.048]                         if (exists("master", mode = "list", envir = envir, 
[13:19:03.048]                           inherits = FALSE)) {
[13:19:03.048]                           master <- get("master", mode = "list", 
[13:19:03.048]                             envir = envir, inherits = FALSE)
[13:19:03.048]                           if (inherits(master, c("SOCKnode", 
[13:19:03.048]                             "SOCK0node"))) {
[13:19:03.048]                             sendCondition <<- function(cond) {
[13:19:03.048]                               data <- list(type = "VALUE", value = cond, 
[13:19:03.048]                                 success = TRUE)
[13:19:03.048]                               parallel_sendData(master, data)
[13:19:03.048]                             }
[13:19:03.048]                             return(sendCondition)
[13:19:03.048]                           }
[13:19:03.048]                         }
[13:19:03.048]                         frame <- frame + 1L
[13:19:03.048]                         envir <- sys.frame(frame)
[13:19:03.048]                       }
[13:19:03.048]                     }
[13:19:03.048]                     sendCondition <<- function(cond) NULL
[13:19:03.048]                   }
[13:19:03.048]                 })
[13:19:03.048]                 withCallingHandlers({
[13:19:03.048]                   {
[13:19:03.048]                     do.call(function(...) {
[13:19:03.048]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.048]                       if (!identical(...future.globals.maxSize.org, 
[13:19:03.048]                         ...future.globals.maxSize)) {
[13:19:03.048]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.048]                         on.exit(options(oopts), add = TRUE)
[13:19:03.048]                       }
[13:19:03.048]                       {
[13:19:03.048]                         lapply(seq_along(...future.elements_ii), 
[13:19:03.048]                           FUN = function(jj) {
[13:19:03.048]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.048]                             ...future.FUN(...future.X_jj, ...)
[13:19:03.048]                           })
[13:19:03.048]                       }
[13:19:03.048]                     }, args = future.call.arguments)
[13:19:03.048]                   }
[13:19:03.048]                 }, immediateCondition = function(cond) {
[13:19:03.048]                   sendCondition <- ...future.makeSendCondition()
[13:19:03.048]                   sendCondition(cond)
[13:19:03.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.048]                   {
[13:19:03.048]                     inherits <- base::inherits
[13:19:03.048]                     invokeRestart <- base::invokeRestart
[13:19:03.048]                     is.null <- base::is.null
[13:19:03.048]                     muffled <- FALSE
[13:19:03.048]                     if (inherits(cond, "message")) {
[13:19:03.048]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:03.048]                       if (muffled) 
[13:19:03.048]                         invokeRestart("muffleMessage")
[13:19:03.048]                     }
[13:19:03.048]                     else if (inherits(cond, "warning")) {
[13:19:03.048]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:03.048]                       if (muffled) 
[13:19:03.048]                         invokeRestart("muffleWarning")
[13:19:03.048]                     }
[13:19:03.048]                     else if (inherits(cond, "condition")) {
[13:19:03.048]                       if (!is.null(pattern)) {
[13:19:03.048]                         computeRestarts <- base::computeRestarts
[13:19:03.048]                         grepl <- base::grepl
[13:19:03.048]                         restarts <- computeRestarts(cond)
[13:19:03.048]                         for (restart in restarts) {
[13:19:03.048]                           name <- restart$name
[13:19:03.048]                           if (is.null(name)) 
[13:19:03.048]                             next
[13:19:03.048]                           if (!grepl(pattern, name)) 
[13:19:03.048]                             next
[13:19:03.048]                           invokeRestart(restart)
[13:19:03.048]                           muffled <- TRUE
[13:19:03.048]                           break
[13:19:03.048]                         }
[13:19:03.048]                       }
[13:19:03.048]                     }
[13:19:03.048]                     invisible(muffled)
[13:19:03.048]                   }
[13:19:03.048]                   muffleCondition(cond)
[13:19:03.048]                 })
[13:19:03.048]             }))
[13:19:03.048]             future::FutureResult(value = ...future.value$value, 
[13:19:03.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.048]                   ...future.rng), globalenv = if (FALSE) 
[13:19:03.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:03.048]                     ...future.globalenv.names))
[13:19:03.048]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:03.048]         }, condition = base::local({
[13:19:03.048]             c <- base::c
[13:19:03.048]             inherits <- base::inherits
[13:19:03.048]             invokeRestart <- base::invokeRestart
[13:19:03.048]             length <- base::length
[13:19:03.048]             list <- base::list
[13:19:03.048]             seq.int <- base::seq.int
[13:19:03.048]             signalCondition <- base::signalCondition
[13:19:03.048]             sys.calls <- base::sys.calls
[13:19:03.048]             `[[` <- base::`[[`
[13:19:03.048]             `+` <- base::`+`
[13:19:03.048]             `<<-` <- base::`<<-`
[13:19:03.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:03.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:03.048]                   3L)]
[13:19:03.048]             }
[13:19:03.048]             function(cond) {
[13:19:03.048]                 is_error <- inherits(cond, "error")
[13:19:03.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:03.048]                   NULL)
[13:19:03.048]                 if (is_error) {
[13:19:03.048]                   sessionInformation <- function() {
[13:19:03.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:03.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:03.048]                       search = base::search(), system = base::Sys.info())
[13:19:03.048]                   }
[13:19:03.048]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:03.048]                     cond$call), session = sessionInformation(), 
[13:19:03.048]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:03.048]                   signalCondition(cond)
[13:19:03.048]                 }
[13:19:03.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:03.048]                 "immediateCondition"))) {
[13:19:03.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:03.048]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:03.048]                   if (TRUE && !signal) {
[13:19:03.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.048]                     {
[13:19:03.048]                       inherits <- base::inherits
[13:19:03.048]                       invokeRestart <- base::invokeRestart
[13:19:03.048]                       is.null <- base::is.null
[13:19:03.048]                       muffled <- FALSE
[13:19:03.048]                       if (inherits(cond, "message")) {
[13:19:03.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.048]                         if (muffled) 
[13:19:03.048]                           invokeRestart("muffleMessage")
[13:19:03.048]                       }
[13:19:03.048]                       else if (inherits(cond, "warning")) {
[13:19:03.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.048]                         if (muffled) 
[13:19:03.048]                           invokeRestart("muffleWarning")
[13:19:03.048]                       }
[13:19:03.048]                       else if (inherits(cond, "condition")) {
[13:19:03.048]                         if (!is.null(pattern)) {
[13:19:03.048]                           computeRestarts <- base::computeRestarts
[13:19:03.048]                           grepl <- base::grepl
[13:19:03.048]                           restarts <- computeRestarts(cond)
[13:19:03.048]                           for (restart in restarts) {
[13:19:03.048]                             name <- restart$name
[13:19:03.048]                             if (is.null(name)) 
[13:19:03.048]                               next
[13:19:03.048]                             if (!grepl(pattern, name)) 
[13:19:03.048]                               next
[13:19:03.048]                             invokeRestart(restart)
[13:19:03.048]                             muffled <- TRUE
[13:19:03.048]                             break
[13:19:03.048]                           }
[13:19:03.048]                         }
[13:19:03.048]                       }
[13:19:03.048]                       invisible(muffled)
[13:19:03.048]                     }
[13:19:03.048]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.048]                   }
[13:19:03.048]                 }
[13:19:03.048]                 else {
[13:19:03.048]                   if (TRUE) {
[13:19:03.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.048]                     {
[13:19:03.048]                       inherits <- base::inherits
[13:19:03.048]                       invokeRestart <- base::invokeRestart
[13:19:03.048]                       is.null <- base::is.null
[13:19:03.048]                       muffled <- FALSE
[13:19:03.048]                       if (inherits(cond, "message")) {
[13:19:03.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.048]                         if (muffled) 
[13:19:03.048]                           invokeRestart("muffleMessage")
[13:19:03.048]                       }
[13:19:03.048]                       else if (inherits(cond, "warning")) {
[13:19:03.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.048]                         if (muffled) 
[13:19:03.048]                           invokeRestart("muffleWarning")
[13:19:03.048]                       }
[13:19:03.048]                       else if (inherits(cond, "condition")) {
[13:19:03.048]                         if (!is.null(pattern)) {
[13:19:03.048]                           computeRestarts <- base::computeRestarts
[13:19:03.048]                           grepl <- base::grepl
[13:19:03.048]                           restarts <- computeRestarts(cond)
[13:19:03.048]                           for (restart in restarts) {
[13:19:03.048]                             name <- restart$name
[13:19:03.048]                             if (is.null(name)) 
[13:19:03.048]                               next
[13:19:03.048]                             if (!grepl(pattern, name)) 
[13:19:03.048]                               next
[13:19:03.048]                             invokeRestart(restart)
[13:19:03.048]                             muffled <- TRUE
[13:19:03.048]                             break
[13:19:03.048]                           }
[13:19:03.048]                         }
[13:19:03.048]                       }
[13:19:03.048]                       invisible(muffled)
[13:19:03.048]                     }
[13:19:03.048]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.048]                   }
[13:19:03.048]                 }
[13:19:03.048]             }
[13:19:03.048]         }))
[13:19:03.048]     }, error = function(ex) {
[13:19:03.048]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:03.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.048]                 ...future.rng), started = ...future.startTime, 
[13:19:03.048]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:03.048]             version = "1.8"), class = "FutureResult")
[13:19:03.048]     }, finally = {
[13:19:03.048]         if (!identical(...future.workdir, getwd())) 
[13:19:03.048]             setwd(...future.workdir)
[13:19:03.048]         {
[13:19:03.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:03.048]                 ...future.oldOptions$nwarnings <- NULL
[13:19:03.048]             }
[13:19:03.048]             base::options(...future.oldOptions)
[13:19:03.048]             if (.Platform$OS.type == "windows") {
[13:19:03.048]                 old_names <- names(...future.oldEnvVars)
[13:19:03.048]                 envs <- base::Sys.getenv()
[13:19:03.048]                 names <- names(envs)
[13:19:03.048]                 common <- intersect(names, old_names)
[13:19:03.048]                 added <- setdiff(names, old_names)
[13:19:03.048]                 removed <- setdiff(old_names, names)
[13:19:03.048]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:03.048]                   envs[common]]
[13:19:03.048]                 NAMES <- toupper(changed)
[13:19:03.048]                 args <- list()
[13:19:03.048]                 for (kk in seq_along(NAMES)) {
[13:19:03.048]                   name <- changed[[kk]]
[13:19:03.048]                   NAME <- NAMES[[kk]]
[13:19:03.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.048]                     next
[13:19:03.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.048]                 }
[13:19:03.048]                 NAMES <- toupper(added)
[13:19:03.048]                 for (kk in seq_along(NAMES)) {
[13:19:03.048]                   name <- added[[kk]]
[13:19:03.048]                   NAME <- NAMES[[kk]]
[13:19:03.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.048]                     next
[13:19:03.048]                   args[[name]] <- ""
[13:19:03.048]                 }
[13:19:03.048]                 NAMES <- toupper(removed)
[13:19:03.048]                 for (kk in seq_along(NAMES)) {
[13:19:03.048]                   name <- removed[[kk]]
[13:19:03.048]                   NAME <- NAMES[[kk]]
[13:19:03.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.048]                     next
[13:19:03.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.048]                 }
[13:19:03.048]                 if (length(args) > 0) 
[13:19:03.048]                   base::do.call(base::Sys.setenv, args = args)
[13:19:03.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:03.048]             }
[13:19:03.048]             else {
[13:19:03.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:03.048]             }
[13:19:03.048]             {
[13:19:03.048]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:03.048]                   0L) {
[13:19:03.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:03.048]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:03.048]                   base::options(opts)
[13:19:03.048]                 }
[13:19:03.048]                 {
[13:19:03.048]                   {
[13:19:03.048]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:03.048]                     NULL
[13:19:03.048]                   }
[13:19:03.048]                   options(future.plan = NULL)
[13:19:03.048]                   if (is.na(NA_character_)) 
[13:19:03.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:03.048]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:03.048]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:03.048]                     envir = parent.frame()) 
[13:19:03.048]                   {
[13:19:03.048]                     if (is.function(workers)) 
[13:19:03.048]                       workers <- workers()
[13:19:03.048]                     workers <- structure(as.integer(workers), 
[13:19:03.048]                       class = class(workers))
[13:19:03.048]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:03.048]                       workers >= 1)
[13:19:03.048]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:03.048]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:03.048]                     }
[13:19:03.048]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:03.048]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:03.048]                       envir = envir)
[13:19:03.048]                     if (!future$lazy) 
[13:19:03.048]                       future <- run(future)
[13:19:03.048]                     invisible(future)
[13:19:03.048]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:03.048]                 }
[13:19:03.048]             }
[13:19:03.048]         }
[13:19:03.048]     })
[13:19:03.048]     if (TRUE) {
[13:19:03.048]         base::sink(type = "output", split = FALSE)
[13:19:03.048]         if (TRUE) {
[13:19:03.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:03.048]         }
[13:19:03.048]         else {
[13:19:03.048]             ...future.result["stdout"] <- base::list(NULL)
[13:19:03.048]         }
[13:19:03.048]         base::close(...future.stdout)
[13:19:03.048]         ...future.stdout <- NULL
[13:19:03.048]     }
[13:19:03.048]     ...future.result$conditions <- ...future.conditions
[13:19:03.048]     ...future.result$finished <- base::Sys.time()
[13:19:03.048]     ...future.result
[13:19:03.048] }
[13:19:03.051] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[13:19:03.051] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:03.093] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:03.093] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[13:19:03.094] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[13:19:03.094] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:03.094] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:03.094] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:03.137] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:03.137] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:03.181] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:03.181] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:03.182] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.182] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:03.182] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:03.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:03.183] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.183] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:03.183] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:03.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:03.184] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.184] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:03.184] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.184] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[13:19:03.185] MultisessionFuture started
[13:19:03.185] - Launch lazy future ... done
[13:19:03.185] run() for ‘MultisessionFuture’ ... done
[13:19:03.185] Created future:
[13:19:03.185] MultisessionFuture:
[13:19:03.185] Label: ‘future_vapply-2’
[13:19:03.185] Expression:
[13:19:03.185] {
[13:19:03.185]     do.call(function(...) {
[13:19:03.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.185]             on.exit(options(oopts), add = TRUE)
[13:19:03.185]         }
[13:19:03.185]         {
[13:19:03.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.185]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.185]             })
[13:19:03.185]         }
[13:19:03.185]     }, args = future.call.arguments)
[13:19:03.185] }
[13:19:03.185] Lazy evaluation: FALSE
[13:19:03.185] Asynchronous evaluation: TRUE
[13:19:03.185] Local evaluation: TRUE
[13:19:03.185] Environment: R_GlobalEnv
[13:19:03.185] Capture standard output: TRUE
[13:19:03.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:03.185] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:03.185] Packages: 1 packages (‘future.apply’)
[13:19:03.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:03.185] Resolved: FALSE
[13:19:03.185] Value: <not collected>
[13:19:03.185] Conditions captured: <none>
[13:19:03.185] Early signaling: FALSE
[13:19:03.185] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:03.185] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.197] Chunk #2 of 2 ... DONE
[13:19:03.197] Launching 2 futures (chunks) ... DONE
[13:19:03.197] Resolving 2 futures (chunks) ...
[13:19:03.197] resolve() on list ...
[13:19:03.197]  recursive: 0
[13:19:03.198]  length: 2
[13:19:03.198] 
[13:19:03.198] receiveMessageFromWorker() for ClusterFuture ...
[13:19:03.198] - Validating connection of MultisessionFuture
[13:19:03.198] - received message: FutureResult
[13:19:03.199] - Received FutureResult
[13:19:03.199] - Erased future from FutureRegistry
[13:19:03.199] result() for ClusterFuture ...
[13:19:03.199] - result already collected: FutureResult
[13:19:03.199] result() for ClusterFuture ... done
[13:19:03.199] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:03.199] Future #1
[13:19:03.199] result() for ClusterFuture ...
[13:19:03.199] - result already collected: FutureResult
[13:19:03.199] result() for ClusterFuture ... done
[13:19:03.199] result() for ClusterFuture ...
[13:19:03.200] - result already collected: FutureResult
[13:19:03.200] result() for ClusterFuture ... done
[13:19:03.200] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:03.200] - nx: 2
[13:19:03.200] - relay: TRUE
[13:19:03.200] - stdout: TRUE
[13:19:03.200] - signal: TRUE
[13:19:03.200] - resignal: FALSE
[13:19:03.200] - force: TRUE
[13:19:03.200] - relayed: [n=2] FALSE, FALSE
[13:19:03.200] - queued futures: [n=2] FALSE, FALSE
[13:19:03.200]  - until=1
[13:19:03.201]  - relaying element #1
[13:19:03.201] result() for ClusterFuture ...
[13:19:03.201] - result already collected: FutureResult
[13:19:03.201] result() for ClusterFuture ... done
[13:19:03.201] result() for ClusterFuture ...
[13:19:03.201] - result already collected: FutureResult
[13:19:03.201] result() for ClusterFuture ... done
[13:19:03.201] result() for ClusterFuture ...
[13:19:03.201] - result already collected: FutureResult
[13:19:03.201] result() for ClusterFuture ... done
[13:19:03.201] result() for ClusterFuture ...
[13:19:03.202] - result already collected: FutureResult
[13:19:03.202] result() for ClusterFuture ... done
[13:19:03.202] - relayed: [n=2] TRUE, FALSE
[13:19:03.202] - queued futures: [n=2] TRUE, FALSE
[13:19:03.202] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:03.202]  length: 1 (resolved future 1)
[13:19:03.244] receiveMessageFromWorker() for ClusterFuture ...
[13:19:03.244] - Validating connection of MultisessionFuture
[13:19:03.244] - received message: FutureResult
[13:19:03.244] - Received FutureResult
[13:19:03.244] - Erased future from FutureRegistry
[13:19:03.245] result() for ClusterFuture ...
[13:19:03.245] - result already collected: FutureResult
[13:19:03.245] result() for ClusterFuture ... done
[13:19:03.245] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:03.245] Future #2
[13:19:03.245] result() for ClusterFuture ...
[13:19:03.245] - result already collected: FutureResult
[13:19:03.245] result() for ClusterFuture ... done
[13:19:03.245] result() for ClusterFuture ...
[13:19:03.245] - result already collected: FutureResult
[13:19:03.245] result() for ClusterFuture ... done
[13:19:03.246] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:03.246] - nx: 2
[13:19:03.246] - relay: TRUE
[13:19:03.246] - stdout: TRUE
[13:19:03.246] - signal: TRUE
[13:19:03.246] - resignal: FALSE
[13:19:03.246] - force: TRUE
[13:19:03.246] - relayed: [n=2] TRUE, FALSE
[13:19:03.246] - queued futures: [n=2] TRUE, FALSE
[13:19:03.246]  - until=2
[13:19:03.246]  - relaying element #2
[13:19:03.246] result() for ClusterFuture ...
[13:19:03.247] - result already collected: FutureResult
[13:19:03.247] result() for ClusterFuture ... done
[13:19:03.247] result() for ClusterFuture ...
[13:19:03.247] - result already collected: FutureResult
[13:19:03.247] result() for ClusterFuture ... done
[13:19:03.247] result() for ClusterFuture ...
[13:19:03.247] - result already collected: FutureResult
[13:19:03.247] result() for ClusterFuture ... done
[13:19:03.247] result() for ClusterFuture ...
[13:19:03.247] - result already collected: FutureResult
[13:19:03.247] result() for ClusterFuture ... done
[13:19:03.248] - relayed: [n=2] TRUE, TRUE
[13:19:03.248] - queued futures: [n=2] TRUE, TRUE
[13:19:03.248] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:03.248]  length: 0 (resolved future 2)
[13:19:03.248] Relaying remaining futures
[13:19:03.248] signalConditionsASAP(NULL, pos=0) ...
[13:19:03.248] - nx: 2
[13:19:03.248] - relay: TRUE
[13:19:03.248] - stdout: TRUE
[13:19:03.248] - signal: TRUE
[13:19:03.248] - resignal: FALSE
[13:19:03.248] - force: TRUE
[13:19:03.249] - relayed: [n=2] TRUE, TRUE
[13:19:03.249] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:03.249] - relayed: [n=2] TRUE, TRUE
[13:19:03.249] - queued futures: [n=2] TRUE, TRUE
[13:19:03.249] signalConditionsASAP(NULL, pos=0) ... done
[13:19:03.249] resolve() on list ... DONE
[13:19:03.249] result() for ClusterFuture ...
[13:19:03.249] - result already collected: FutureResult
[13:19:03.249] result() for ClusterFuture ... done
[13:19:03.249] result() for ClusterFuture ...
[13:19:03.249] - result already collected: FutureResult
[13:19:03.250] result() for ClusterFuture ... done
[13:19:03.250] result() for ClusterFuture ...
[13:19:03.250] - result already collected: FutureResult
[13:19:03.250] result() for ClusterFuture ... done
[13:19:03.250] result() for ClusterFuture ...
[13:19:03.250] - result already collected: FutureResult
[13:19:03.250] result() for ClusterFuture ... done
[13:19:03.250]  - Number of value chunks collected: 2
[13:19:03.250] Resolving 2 futures (chunks) ... DONE
[13:19:03.250] Reducing values from 2 chunks ...
[13:19:03.250]  - Number of values collected after concatenation: 10
[13:19:03.251]  - Number of values expected: 10
[13:19:03.251] Reducing values from 2 chunks ... DONE
[13:19:03.251] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:19:03.252] future_lapply() ...
[13:19:03.257] Number of chunks: 2
[13:19:03.257] getGlobalsAndPackagesXApply() ...
[13:19:03.257]  - future.globals: TRUE
[13:19:03.257] getGlobalsAndPackages() ...
[13:19:03.257] Searching for globals...
[13:19:03.260] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:19:03.261] Searching for globals ... DONE
[13:19:03.261] Resolving globals: FALSE
[13:19:03.261] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:19:03.262] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:03.262] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:03.262] - packages: [1] ‘future.apply’
[13:19:03.262] getGlobalsAndPackages() ... DONE
[13:19:03.262]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:03.262]  - needed namespaces: [n=1] ‘future.apply’
[13:19:03.263] Finding globals ... DONE
[13:19:03.263]  - use_args: TRUE
[13:19:03.263]  - Getting '...' globals ...
[13:19:03.263] resolve() on list ...
[13:19:03.263]  recursive: 0
[13:19:03.263]  length: 1
[13:19:03.263]  elements: ‘...’
[13:19:03.263]  length: 0 (resolved future 1)
[13:19:03.263] resolve() on list ... DONE
[13:19:03.264]    - '...' content: [n=0] 
[13:19:03.264] List of 1
[13:19:03.264]  $ ...: list()
[13:19:03.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:03.264]  - attr(*, "where")=List of 1
[13:19:03.264]   ..$ ...:<environment: 0x555f7d5d5190> 
[13:19:03.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:03.264]  - attr(*, "resolved")= logi TRUE
[13:19:03.264]  - attr(*, "total_size")= num NA
[13:19:03.266]  - Getting '...' globals ... DONE
[13:19:03.266] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:03.266] List of 8
[13:19:03.266]  $ ...future.FUN:function (x, ...)  
[13:19:03.266]  $ x_FUN        :function (x)  
[13:19:03.266]  $ times        : int 4
[13:19:03.266]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:03.266]  $ stop_if_not  :function (...)  
[13:19:03.266]  $ dim          : int [1:2] 2 2
[13:19:03.266]  $ valid_types  : chr [1:2] "logical" "integer"
[13:19:03.266]  $ ...          : list()
[13:19:03.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:03.266]  - attr(*, "where")=List of 8
[13:19:03.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:03.266]   ..$ ...          :<environment: 0x555f7d5d5190> 
[13:19:03.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:03.266]  - attr(*, "resolved")= logi FALSE
[13:19:03.266]  - attr(*, "total_size")= num 97232
[13:19:03.272] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:03.272] getGlobalsAndPackagesXApply() ... DONE
[13:19:03.272] Number of futures (= number of chunks): 2
[13:19:03.272] Launching 2 futures (chunks) ...
[13:19:03.272] Chunk #1 of 2 ...
[13:19:03.272]  - Finding globals in 'X' for chunk #1 ...
[13:19:03.272] getGlobalsAndPackages() ...
[13:19:03.272] Searching for globals...
[13:19:03.273] 
[13:19:03.273] Searching for globals ... DONE
[13:19:03.273] - globals: [0] <none>
[13:19:03.273] getGlobalsAndPackages() ... DONE
[13:19:03.273]    + additional globals found: [n=0] 
[13:19:03.273]    + additional namespaces needed: [n=0] 
[13:19:03.273]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:03.273]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:03.273]  - seeds: <none>
[13:19:03.273] getGlobalsAndPackages() ...
[13:19:03.274] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.274] Resolving globals: FALSE
[13:19:03.274] Tweak future expression to call with '...' arguments ...
[13:19:03.274] {
[13:19:03.274]     do.call(function(...) {
[13:19:03.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.274]             on.exit(options(oopts), add = TRUE)
[13:19:03.274]         }
[13:19:03.274]         {
[13:19:03.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.274]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.274]             })
[13:19:03.274]         }
[13:19:03.274]     }, args = future.call.arguments)
[13:19:03.274] }
[13:19:03.274] Tweak future expression to call with '...' arguments ... DONE
[13:19:03.275] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.275] - packages: [1] ‘future.apply’
[13:19:03.275] getGlobalsAndPackages() ... DONE
[13:19:03.275] run() for ‘Future’ ...
[13:19:03.275] - state: ‘created’
[13:19:03.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:03.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:03.290]   - Field: ‘node’
[13:19:03.290]   - Field: ‘label’
[13:19:03.290]   - Field: ‘local’
[13:19:03.290]   - Field: ‘owner’
[13:19:03.290]   - Field: ‘envir’
[13:19:03.290]   - Field: ‘workers’
[13:19:03.291]   - Field: ‘packages’
[13:19:03.291]   - Field: ‘gc’
[13:19:03.291]   - Field: ‘conditions’
[13:19:03.291]   - Field: ‘persistent’
[13:19:03.291]   - Field: ‘expr’
[13:19:03.291]   - Field: ‘uuid’
[13:19:03.291]   - Field: ‘seed’
[13:19:03.291]   - Field: ‘version’
[13:19:03.291]   - Field: ‘result’
[13:19:03.291]   - Field: ‘asynchronous’
[13:19:03.291]   - Field: ‘calls’
[13:19:03.291]   - Field: ‘globals’
[13:19:03.292]   - Field: ‘stdout’
[13:19:03.292]   - Field: ‘earlySignal’
[13:19:03.292]   - Field: ‘lazy’
[13:19:03.292]   - Field: ‘state’
[13:19:03.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:03.292] - Launch lazy future ...
[13:19:03.292] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:03.292] Packages needed by future strategies (n = 0): <none>
[13:19:03.293] {
[13:19:03.293]     {
[13:19:03.293]         {
[13:19:03.293]             ...future.startTime <- base::Sys.time()
[13:19:03.293]             {
[13:19:03.293]                 {
[13:19:03.293]                   {
[13:19:03.293]                     {
[13:19:03.293]                       {
[13:19:03.293]                         base::local({
[13:19:03.293]                           has_future <- base::requireNamespace("future", 
[13:19:03.293]                             quietly = TRUE)
[13:19:03.293]                           if (has_future) {
[13:19:03.293]                             ns <- base::getNamespace("future")
[13:19:03.293]                             version <- ns[[".package"]][["version"]]
[13:19:03.293]                             if (is.null(version)) 
[13:19:03.293]                               version <- utils::packageVersion("future")
[13:19:03.293]                           }
[13:19:03.293]                           else {
[13:19:03.293]                             version <- NULL
[13:19:03.293]                           }
[13:19:03.293]                           if (!has_future || version < "1.8.0") {
[13:19:03.293]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:03.293]                               "", base::R.version$version.string), 
[13:19:03.293]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:03.293]                                 base::R.version$platform, 8 * 
[13:19:03.293]                                   base::.Machine$sizeof.pointer), 
[13:19:03.293]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:03.293]                                 "release", "version")], collapse = " "), 
[13:19:03.293]                               hostname = base::Sys.info()[["nodename"]])
[13:19:03.293]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:03.293]                               info)
[13:19:03.293]                             info <- base::paste(info, collapse = "; ")
[13:19:03.293]                             if (!has_future) {
[13:19:03.293]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:03.293]                                 info)
[13:19:03.293]                             }
[13:19:03.293]                             else {
[13:19:03.293]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:03.293]                                 info, version)
[13:19:03.293]                             }
[13:19:03.293]                             base::stop(msg)
[13:19:03.293]                           }
[13:19:03.293]                         })
[13:19:03.293]                       }
[13:19:03.293]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:03.293]                       base::options(mc.cores = 1L)
[13:19:03.293]                     }
[13:19:03.293]                     base::local({
[13:19:03.293]                       for (pkg in "future.apply") {
[13:19:03.293]                         base::loadNamespace(pkg)
[13:19:03.293]                         base::library(pkg, character.only = TRUE)
[13:19:03.293]                       }
[13:19:03.293]                     })
[13:19:03.293]                   }
[13:19:03.293]                   options(future.plan = NULL)
[13:19:03.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:03.293]                 }
[13:19:03.293]                 ...future.workdir <- getwd()
[13:19:03.293]             }
[13:19:03.293]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:03.293]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:03.293]         }
[13:19:03.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:03.293]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:03.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:03.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:03.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:03.293]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:03.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:03.293]             base::names(...future.oldOptions))
[13:19:03.293]     }
[13:19:03.293]     if (FALSE) {
[13:19:03.293]     }
[13:19:03.293]     else {
[13:19:03.293]         if (TRUE) {
[13:19:03.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:03.293]                 open = "w")
[13:19:03.293]         }
[13:19:03.293]         else {
[13:19:03.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:03.293]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:03.293]         }
[13:19:03.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:03.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:03.293]             base::sink(type = "output", split = FALSE)
[13:19:03.293]             base::close(...future.stdout)
[13:19:03.293]         }, add = TRUE)
[13:19:03.293]     }
[13:19:03.293]     ...future.frame <- base::sys.nframe()
[13:19:03.293]     ...future.conditions <- base::list()
[13:19:03.293]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:03.293]     if (FALSE) {
[13:19:03.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:03.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:03.293]     }
[13:19:03.293]     ...future.result <- base::tryCatch({
[13:19:03.293]         base::withCallingHandlers({
[13:19:03.293]             ...future.value <- base::withVisible(base::local({
[13:19:03.293]                 ...future.makeSendCondition <- local({
[13:19:03.293]                   sendCondition <- NULL
[13:19:03.293]                   function(frame = 1L) {
[13:19:03.293]                     if (is.function(sendCondition)) 
[13:19:03.293]                       return(sendCondition)
[13:19:03.293]                     ns <- getNamespace("parallel")
[13:19:03.293]                     if (exists("sendData", mode = "function", 
[13:19:03.293]                       envir = ns)) {
[13:19:03.293]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:03.293]                         envir = ns)
[13:19:03.293]                       envir <- sys.frame(frame)
[13:19:03.293]                       master <- NULL
[13:19:03.293]                       while (!identical(envir, .GlobalEnv) && 
[13:19:03.293]                         !identical(envir, emptyenv())) {
[13:19:03.293]                         if (exists("master", mode = "list", envir = envir, 
[13:19:03.293]                           inherits = FALSE)) {
[13:19:03.293]                           master <- get("master", mode = "list", 
[13:19:03.293]                             envir = envir, inherits = FALSE)
[13:19:03.293]                           if (inherits(master, c("SOCKnode", 
[13:19:03.293]                             "SOCK0node"))) {
[13:19:03.293]                             sendCondition <<- function(cond) {
[13:19:03.293]                               data <- list(type = "VALUE", value = cond, 
[13:19:03.293]                                 success = TRUE)
[13:19:03.293]                               parallel_sendData(master, data)
[13:19:03.293]                             }
[13:19:03.293]                             return(sendCondition)
[13:19:03.293]                           }
[13:19:03.293]                         }
[13:19:03.293]                         frame <- frame + 1L
[13:19:03.293]                         envir <- sys.frame(frame)
[13:19:03.293]                       }
[13:19:03.293]                     }
[13:19:03.293]                     sendCondition <<- function(cond) NULL
[13:19:03.293]                   }
[13:19:03.293]                 })
[13:19:03.293]                 withCallingHandlers({
[13:19:03.293]                   {
[13:19:03.293]                     do.call(function(...) {
[13:19:03.293]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.293]                       if (!identical(...future.globals.maxSize.org, 
[13:19:03.293]                         ...future.globals.maxSize)) {
[13:19:03.293]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.293]                         on.exit(options(oopts), add = TRUE)
[13:19:03.293]                       }
[13:19:03.293]                       {
[13:19:03.293]                         lapply(seq_along(...future.elements_ii), 
[13:19:03.293]                           FUN = function(jj) {
[13:19:03.293]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.293]                             ...future.FUN(...future.X_jj, ...)
[13:19:03.293]                           })
[13:19:03.293]                       }
[13:19:03.293]                     }, args = future.call.arguments)
[13:19:03.293]                   }
[13:19:03.293]                 }, immediateCondition = function(cond) {
[13:19:03.293]                   sendCondition <- ...future.makeSendCondition()
[13:19:03.293]                   sendCondition(cond)
[13:19:03.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.293]                   {
[13:19:03.293]                     inherits <- base::inherits
[13:19:03.293]                     invokeRestart <- base::invokeRestart
[13:19:03.293]                     is.null <- base::is.null
[13:19:03.293]                     muffled <- FALSE
[13:19:03.293]                     if (inherits(cond, "message")) {
[13:19:03.293]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:03.293]                       if (muffled) 
[13:19:03.293]                         invokeRestart("muffleMessage")
[13:19:03.293]                     }
[13:19:03.293]                     else if (inherits(cond, "warning")) {
[13:19:03.293]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:03.293]                       if (muffled) 
[13:19:03.293]                         invokeRestart("muffleWarning")
[13:19:03.293]                     }
[13:19:03.293]                     else if (inherits(cond, "condition")) {
[13:19:03.293]                       if (!is.null(pattern)) {
[13:19:03.293]                         computeRestarts <- base::computeRestarts
[13:19:03.293]                         grepl <- base::grepl
[13:19:03.293]                         restarts <- computeRestarts(cond)
[13:19:03.293]                         for (restart in restarts) {
[13:19:03.293]                           name <- restart$name
[13:19:03.293]                           if (is.null(name)) 
[13:19:03.293]                             next
[13:19:03.293]                           if (!grepl(pattern, name)) 
[13:19:03.293]                             next
[13:19:03.293]                           invokeRestart(restart)
[13:19:03.293]                           muffled <- TRUE
[13:19:03.293]                           break
[13:19:03.293]                         }
[13:19:03.293]                       }
[13:19:03.293]                     }
[13:19:03.293]                     invisible(muffled)
[13:19:03.293]                   }
[13:19:03.293]                   muffleCondition(cond)
[13:19:03.293]                 })
[13:19:03.293]             }))
[13:19:03.293]             future::FutureResult(value = ...future.value$value, 
[13:19:03.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.293]                   ...future.rng), globalenv = if (FALSE) 
[13:19:03.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:03.293]                     ...future.globalenv.names))
[13:19:03.293]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:03.293]         }, condition = base::local({
[13:19:03.293]             c <- base::c
[13:19:03.293]             inherits <- base::inherits
[13:19:03.293]             invokeRestart <- base::invokeRestart
[13:19:03.293]             length <- base::length
[13:19:03.293]             list <- base::list
[13:19:03.293]             seq.int <- base::seq.int
[13:19:03.293]             signalCondition <- base::signalCondition
[13:19:03.293]             sys.calls <- base::sys.calls
[13:19:03.293]             `[[` <- base::`[[`
[13:19:03.293]             `+` <- base::`+`
[13:19:03.293]             `<<-` <- base::`<<-`
[13:19:03.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:03.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:03.293]                   3L)]
[13:19:03.293]             }
[13:19:03.293]             function(cond) {
[13:19:03.293]                 is_error <- inherits(cond, "error")
[13:19:03.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:03.293]                   NULL)
[13:19:03.293]                 if (is_error) {
[13:19:03.293]                   sessionInformation <- function() {
[13:19:03.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:03.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:03.293]                       search = base::search(), system = base::Sys.info())
[13:19:03.293]                   }
[13:19:03.293]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:03.293]                     cond$call), session = sessionInformation(), 
[13:19:03.293]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:03.293]                   signalCondition(cond)
[13:19:03.293]                 }
[13:19:03.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:03.293]                 "immediateCondition"))) {
[13:19:03.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:03.293]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:03.293]                   if (TRUE && !signal) {
[13:19:03.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.293]                     {
[13:19:03.293]                       inherits <- base::inherits
[13:19:03.293]                       invokeRestart <- base::invokeRestart
[13:19:03.293]                       is.null <- base::is.null
[13:19:03.293]                       muffled <- FALSE
[13:19:03.293]                       if (inherits(cond, "message")) {
[13:19:03.293]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.293]                         if (muffled) 
[13:19:03.293]                           invokeRestart("muffleMessage")
[13:19:03.293]                       }
[13:19:03.293]                       else if (inherits(cond, "warning")) {
[13:19:03.293]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.293]                         if (muffled) 
[13:19:03.293]                           invokeRestart("muffleWarning")
[13:19:03.293]                       }
[13:19:03.293]                       else if (inherits(cond, "condition")) {
[13:19:03.293]                         if (!is.null(pattern)) {
[13:19:03.293]                           computeRestarts <- base::computeRestarts
[13:19:03.293]                           grepl <- base::grepl
[13:19:03.293]                           restarts <- computeRestarts(cond)
[13:19:03.293]                           for (restart in restarts) {
[13:19:03.293]                             name <- restart$name
[13:19:03.293]                             if (is.null(name)) 
[13:19:03.293]                               next
[13:19:03.293]                             if (!grepl(pattern, name)) 
[13:19:03.293]                               next
[13:19:03.293]                             invokeRestart(restart)
[13:19:03.293]                             muffled <- TRUE
[13:19:03.293]                             break
[13:19:03.293]                           }
[13:19:03.293]                         }
[13:19:03.293]                       }
[13:19:03.293]                       invisible(muffled)
[13:19:03.293]                     }
[13:19:03.293]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.293]                   }
[13:19:03.293]                 }
[13:19:03.293]                 else {
[13:19:03.293]                   if (TRUE) {
[13:19:03.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.293]                     {
[13:19:03.293]                       inherits <- base::inherits
[13:19:03.293]                       invokeRestart <- base::invokeRestart
[13:19:03.293]                       is.null <- base::is.null
[13:19:03.293]                       muffled <- FALSE
[13:19:03.293]                       if (inherits(cond, "message")) {
[13:19:03.293]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.293]                         if (muffled) 
[13:19:03.293]                           invokeRestart("muffleMessage")
[13:19:03.293]                       }
[13:19:03.293]                       else if (inherits(cond, "warning")) {
[13:19:03.293]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.293]                         if (muffled) 
[13:19:03.293]                           invokeRestart("muffleWarning")
[13:19:03.293]                       }
[13:19:03.293]                       else if (inherits(cond, "condition")) {
[13:19:03.293]                         if (!is.null(pattern)) {
[13:19:03.293]                           computeRestarts <- base::computeRestarts
[13:19:03.293]                           grepl <- base::grepl
[13:19:03.293]                           restarts <- computeRestarts(cond)
[13:19:03.293]                           for (restart in restarts) {
[13:19:03.293]                             name <- restart$name
[13:19:03.293]                             if (is.null(name)) 
[13:19:03.293]                               next
[13:19:03.293]                             if (!grepl(pattern, name)) 
[13:19:03.293]                               next
[13:19:03.293]                             invokeRestart(restart)
[13:19:03.293]                             muffled <- TRUE
[13:19:03.293]                             break
[13:19:03.293]                           }
[13:19:03.293]                         }
[13:19:03.293]                       }
[13:19:03.293]                       invisible(muffled)
[13:19:03.293]                     }
[13:19:03.293]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.293]                   }
[13:19:03.293]                 }
[13:19:03.293]             }
[13:19:03.293]         }))
[13:19:03.293]     }, error = function(ex) {
[13:19:03.293]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:03.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.293]                 ...future.rng), started = ...future.startTime, 
[13:19:03.293]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:03.293]             version = "1.8"), class = "FutureResult")
[13:19:03.293]     }, finally = {
[13:19:03.293]         if (!identical(...future.workdir, getwd())) 
[13:19:03.293]             setwd(...future.workdir)
[13:19:03.293]         {
[13:19:03.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:03.293]                 ...future.oldOptions$nwarnings <- NULL
[13:19:03.293]             }
[13:19:03.293]             base::options(...future.oldOptions)
[13:19:03.293]             if (.Platform$OS.type == "windows") {
[13:19:03.293]                 old_names <- names(...future.oldEnvVars)
[13:19:03.293]                 envs <- base::Sys.getenv()
[13:19:03.293]                 names <- names(envs)
[13:19:03.293]                 common <- intersect(names, old_names)
[13:19:03.293]                 added <- setdiff(names, old_names)
[13:19:03.293]                 removed <- setdiff(old_names, names)
[13:19:03.293]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:03.293]                   envs[common]]
[13:19:03.293]                 NAMES <- toupper(changed)
[13:19:03.293]                 args <- list()
[13:19:03.293]                 for (kk in seq_along(NAMES)) {
[13:19:03.293]                   name <- changed[[kk]]
[13:19:03.293]                   NAME <- NAMES[[kk]]
[13:19:03.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.293]                     next
[13:19:03.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.293]                 }
[13:19:03.293]                 NAMES <- toupper(added)
[13:19:03.293]                 for (kk in seq_along(NAMES)) {
[13:19:03.293]                   name <- added[[kk]]
[13:19:03.293]                   NAME <- NAMES[[kk]]
[13:19:03.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.293]                     next
[13:19:03.293]                   args[[name]] <- ""
[13:19:03.293]                 }
[13:19:03.293]                 NAMES <- toupper(removed)
[13:19:03.293]                 for (kk in seq_along(NAMES)) {
[13:19:03.293]                   name <- removed[[kk]]
[13:19:03.293]                   NAME <- NAMES[[kk]]
[13:19:03.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.293]                     next
[13:19:03.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.293]                 }
[13:19:03.293]                 if (length(args) > 0) 
[13:19:03.293]                   base::do.call(base::Sys.setenv, args = args)
[13:19:03.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:03.293]             }
[13:19:03.293]             else {
[13:19:03.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:03.293]             }
[13:19:03.293]             {
[13:19:03.293]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:03.293]                   0L) {
[13:19:03.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:03.293]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:03.293]                   base::options(opts)
[13:19:03.293]                 }
[13:19:03.293]                 {
[13:19:03.293]                   {
[13:19:03.293]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:03.293]                     NULL
[13:19:03.293]                   }
[13:19:03.293]                   options(future.plan = NULL)
[13:19:03.293]                   if (is.na(NA_character_)) 
[13:19:03.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:03.293]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:03.293]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:03.293]                     envir = parent.frame()) 
[13:19:03.293]                   {
[13:19:03.293]                     if (is.function(workers)) 
[13:19:03.293]                       workers <- workers()
[13:19:03.293]                     workers <- structure(as.integer(workers), 
[13:19:03.293]                       class = class(workers))
[13:19:03.293]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:03.293]                       workers >= 1)
[13:19:03.293]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:03.293]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:03.293]                     }
[13:19:03.293]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:03.293]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:03.293]                       envir = envir)
[13:19:03.293]                     if (!future$lazy) 
[13:19:03.293]                       future <- run(future)
[13:19:03.293]                     invisible(future)
[13:19:03.293]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:03.293]                 }
[13:19:03.293]             }
[13:19:03.293]         }
[13:19:03.293]     })
[13:19:03.293]     if (TRUE) {
[13:19:03.293]         base::sink(type = "output", split = FALSE)
[13:19:03.293]         if (TRUE) {
[13:19:03.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:03.293]         }
[13:19:03.293]         else {
[13:19:03.293]             ...future.result["stdout"] <- base::list(NULL)
[13:19:03.293]         }
[13:19:03.293]         base::close(...future.stdout)
[13:19:03.293]         ...future.stdout <- NULL
[13:19:03.293]     }
[13:19:03.293]     ...future.result$conditions <- ...future.conditions
[13:19:03.293]     ...future.result$finished <- base::Sys.time()
[13:19:03.293]     ...future.result
[13:19:03.293] }
[13:19:03.296] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[13:19:03.296] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:03.337] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:03.337] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[13:19:03.338] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[13:19:03.338] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:03.338] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:03.338] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:03.381] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:03.381] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:03.425] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:03.425] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:19:03.425] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:19:03.426] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:19:03.426] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:19:03.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:03.427] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:03.427] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:03.427] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:03.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:03.428] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:03.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:03.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:03.428] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[13:19:03.429] MultisessionFuture started
[13:19:03.429] - Launch lazy future ... done
[13:19:03.429] run() for ‘MultisessionFuture’ ... done
[13:19:03.429] Created future:
[13:19:03.429] MultisessionFuture:
[13:19:03.429] Label: ‘future_vapply-1’
[13:19:03.429] Expression:
[13:19:03.429] {
[13:19:03.429]     do.call(function(...) {
[13:19:03.429]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.429]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.429]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.429]             on.exit(options(oopts), add = TRUE)
[13:19:03.429]         }
[13:19:03.429]         {
[13:19:03.429]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.429]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.429]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.429]             })
[13:19:03.429]         }
[13:19:03.429]     }, args = future.call.arguments)
[13:19:03.429] }
[13:19:03.429] Lazy evaluation: FALSE
[13:19:03.429] Asynchronous evaluation: TRUE
[13:19:03.429] Local evaluation: TRUE
[13:19:03.429] Environment: R_GlobalEnv
[13:19:03.429] Capture standard output: TRUE
[13:19:03.429] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:03.429] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:03.429] Packages: 1 packages (‘future.apply’)
[13:19:03.429] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:03.429] Resolved: FALSE
[13:19:03.429] Value: <not collected>
[13:19:03.429] Conditions captured: <none>
[13:19:03.429] Early signaling: FALSE
[13:19:03.429] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:03.429] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.441] Chunk #1 of 2 ... DONE
[13:19:03.441] Chunk #2 of 2 ...
[13:19:03.441]  - Finding globals in 'X' for chunk #2 ...
[13:19:03.442] getGlobalsAndPackages() ...
[13:19:03.442] Searching for globals...
[13:19:03.442] 
[13:19:03.442] Searching for globals ... DONE
[13:19:03.442] - globals: [0] <none>
[13:19:03.442] getGlobalsAndPackages() ... DONE
[13:19:03.442]    + additional globals found: [n=0] 
[13:19:03.442]    + additional namespaces needed: [n=0] 
[13:19:03.443]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:03.443]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:03.443]  - seeds: <none>
[13:19:03.443] getGlobalsAndPackages() ...
[13:19:03.443] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.443] Resolving globals: FALSE
[13:19:03.443] Tweak future expression to call with '...' arguments ...
[13:19:03.443] {
[13:19:03.443]     do.call(function(...) {
[13:19:03.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.443]             on.exit(options(oopts), add = TRUE)
[13:19:03.443]         }
[13:19:03.443]         {
[13:19:03.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.443]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.443]             })
[13:19:03.443]         }
[13:19:03.443]     }, args = future.call.arguments)
[13:19:03.443] }
[13:19:03.444] Tweak future expression to call with '...' arguments ... DONE
[13:19:03.444] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.444] - packages: [1] ‘future.apply’
[13:19:03.444] getGlobalsAndPackages() ... DONE
[13:19:03.445] run() for ‘Future’ ...
[13:19:03.445] - state: ‘created’
[13:19:03.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:03.460] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:03.460]   - Field: ‘node’
[13:19:03.460]   - Field: ‘label’
[13:19:03.461]   - Field: ‘local’
[13:19:03.461]   - Field: ‘owner’
[13:19:03.461]   - Field: ‘envir’
[13:19:03.461]   - Field: ‘workers’
[13:19:03.461]   - Field: ‘packages’
[13:19:03.461]   - Field: ‘gc’
[13:19:03.461]   - Field: ‘conditions’
[13:19:03.461]   - Field: ‘persistent’
[13:19:03.461]   - Field: ‘expr’
[13:19:03.461]   - Field: ‘uuid’
[13:19:03.461]   - Field: ‘seed’
[13:19:03.462]   - Field: ‘version’
[13:19:03.462]   - Field: ‘result’
[13:19:03.462]   - Field: ‘asynchronous’
[13:19:03.462]   - Field: ‘calls’
[13:19:03.462]   - Field: ‘globals’
[13:19:03.462]   - Field: ‘stdout’
[13:19:03.462]   - Field: ‘earlySignal’
[13:19:03.462]   - Field: ‘lazy’
[13:19:03.462]   - Field: ‘state’
[13:19:03.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:03.462] - Launch lazy future ...
[13:19:03.463] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:03.463] Packages needed by future strategies (n = 0): <none>
[13:19:03.463] {
[13:19:03.463]     {
[13:19:03.463]         {
[13:19:03.463]             ...future.startTime <- base::Sys.time()
[13:19:03.463]             {
[13:19:03.463]                 {
[13:19:03.463]                   {
[13:19:03.463]                     {
[13:19:03.463]                       {
[13:19:03.463]                         base::local({
[13:19:03.463]                           has_future <- base::requireNamespace("future", 
[13:19:03.463]                             quietly = TRUE)
[13:19:03.463]                           if (has_future) {
[13:19:03.463]                             ns <- base::getNamespace("future")
[13:19:03.463]                             version <- ns[[".package"]][["version"]]
[13:19:03.463]                             if (is.null(version)) 
[13:19:03.463]                               version <- utils::packageVersion("future")
[13:19:03.463]                           }
[13:19:03.463]                           else {
[13:19:03.463]                             version <- NULL
[13:19:03.463]                           }
[13:19:03.463]                           if (!has_future || version < "1.8.0") {
[13:19:03.463]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:03.463]                               "", base::R.version$version.string), 
[13:19:03.463]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:03.463]                                 base::R.version$platform, 8 * 
[13:19:03.463]                                   base::.Machine$sizeof.pointer), 
[13:19:03.463]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:03.463]                                 "release", "version")], collapse = " "), 
[13:19:03.463]                               hostname = base::Sys.info()[["nodename"]])
[13:19:03.463]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:03.463]                               info)
[13:19:03.463]                             info <- base::paste(info, collapse = "; ")
[13:19:03.463]                             if (!has_future) {
[13:19:03.463]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:03.463]                                 info)
[13:19:03.463]                             }
[13:19:03.463]                             else {
[13:19:03.463]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:03.463]                                 info, version)
[13:19:03.463]                             }
[13:19:03.463]                             base::stop(msg)
[13:19:03.463]                           }
[13:19:03.463]                         })
[13:19:03.463]                       }
[13:19:03.463]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:03.463]                       base::options(mc.cores = 1L)
[13:19:03.463]                     }
[13:19:03.463]                     base::local({
[13:19:03.463]                       for (pkg in "future.apply") {
[13:19:03.463]                         base::loadNamespace(pkg)
[13:19:03.463]                         base::library(pkg, character.only = TRUE)
[13:19:03.463]                       }
[13:19:03.463]                     })
[13:19:03.463]                   }
[13:19:03.463]                   options(future.plan = NULL)
[13:19:03.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:03.463]                 }
[13:19:03.463]                 ...future.workdir <- getwd()
[13:19:03.463]             }
[13:19:03.463]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:03.463]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:03.463]         }
[13:19:03.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:03.463]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:03.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:03.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:03.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:03.463]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:03.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:03.463]             base::names(...future.oldOptions))
[13:19:03.463]     }
[13:19:03.463]     if (FALSE) {
[13:19:03.463]     }
[13:19:03.463]     else {
[13:19:03.463]         if (TRUE) {
[13:19:03.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:03.463]                 open = "w")
[13:19:03.463]         }
[13:19:03.463]         else {
[13:19:03.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:03.463]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:03.463]         }
[13:19:03.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:03.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:03.463]             base::sink(type = "output", split = FALSE)
[13:19:03.463]             base::close(...future.stdout)
[13:19:03.463]         }, add = TRUE)
[13:19:03.463]     }
[13:19:03.463]     ...future.frame <- base::sys.nframe()
[13:19:03.463]     ...future.conditions <- base::list()
[13:19:03.463]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:03.463]     if (FALSE) {
[13:19:03.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:03.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:03.463]     }
[13:19:03.463]     ...future.result <- base::tryCatch({
[13:19:03.463]         base::withCallingHandlers({
[13:19:03.463]             ...future.value <- base::withVisible(base::local({
[13:19:03.463]                 ...future.makeSendCondition <- local({
[13:19:03.463]                   sendCondition <- NULL
[13:19:03.463]                   function(frame = 1L) {
[13:19:03.463]                     if (is.function(sendCondition)) 
[13:19:03.463]                       return(sendCondition)
[13:19:03.463]                     ns <- getNamespace("parallel")
[13:19:03.463]                     if (exists("sendData", mode = "function", 
[13:19:03.463]                       envir = ns)) {
[13:19:03.463]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:03.463]                         envir = ns)
[13:19:03.463]                       envir <- sys.frame(frame)
[13:19:03.463]                       master <- NULL
[13:19:03.463]                       while (!identical(envir, .GlobalEnv) && 
[13:19:03.463]                         !identical(envir, emptyenv())) {
[13:19:03.463]                         if (exists("master", mode = "list", envir = envir, 
[13:19:03.463]                           inherits = FALSE)) {
[13:19:03.463]                           master <- get("master", mode = "list", 
[13:19:03.463]                             envir = envir, inherits = FALSE)
[13:19:03.463]                           if (inherits(master, c("SOCKnode", 
[13:19:03.463]                             "SOCK0node"))) {
[13:19:03.463]                             sendCondition <<- function(cond) {
[13:19:03.463]                               data <- list(type = "VALUE", value = cond, 
[13:19:03.463]                                 success = TRUE)
[13:19:03.463]                               parallel_sendData(master, data)
[13:19:03.463]                             }
[13:19:03.463]                             return(sendCondition)
[13:19:03.463]                           }
[13:19:03.463]                         }
[13:19:03.463]                         frame <- frame + 1L
[13:19:03.463]                         envir <- sys.frame(frame)
[13:19:03.463]                       }
[13:19:03.463]                     }
[13:19:03.463]                     sendCondition <<- function(cond) NULL
[13:19:03.463]                   }
[13:19:03.463]                 })
[13:19:03.463]                 withCallingHandlers({
[13:19:03.463]                   {
[13:19:03.463]                     do.call(function(...) {
[13:19:03.463]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.463]                       if (!identical(...future.globals.maxSize.org, 
[13:19:03.463]                         ...future.globals.maxSize)) {
[13:19:03.463]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.463]                         on.exit(options(oopts), add = TRUE)
[13:19:03.463]                       }
[13:19:03.463]                       {
[13:19:03.463]                         lapply(seq_along(...future.elements_ii), 
[13:19:03.463]                           FUN = function(jj) {
[13:19:03.463]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.463]                             ...future.FUN(...future.X_jj, ...)
[13:19:03.463]                           })
[13:19:03.463]                       }
[13:19:03.463]                     }, args = future.call.arguments)
[13:19:03.463]                   }
[13:19:03.463]                 }, immediateCondition = function(cond) {
[13:19:03.463]                   sendCondition <- ...future.makeSendCondition()
[13:19:03.463]                   sendCondition(cond)
[13:19:03.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.463]                   {
[13:19:03.463]                     inherits <- base::inherits
[13:19:03.463]                     invokeRestart <- base::invokeRestart
[13:19:03.463]                     is.null <- base::is.null
[13:19:03.463]                     muffled <- FALSE
[13:19:03.463]                     if (inherits(cond, "message")) {
[13:19:03.463]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:03.463]                       if (muffled) 
[13:19:03.463]                         invokeRestart("muffleMessage")
[13:19:03.463]                     }
[13:19:03.463]                     else if (inherits(cond, "warning")) {
[13:19:03.463]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:03.463]                       if (muffled) 
[13:19:03.463]                         invokeRestart("muffleWarning")
[13:19:03.463]                     }
[13:19:03.463]                     else if (inherits(cond, "condition")) {
[13:19:03.463]                       if (!is.null(pattern)) {
[13:19:03.463]                         computeRestarts <- base::computeRestarts
[13:19:03.463]                         grepl <- base::grepl
[13:19:03.463]                         restarts <- computeRestarts(cond)
[13:19:03.463]                         for (restart in restarts) {
[13:19:03.463]                           name <- restart$name
[13:19:03.463]                           if (is.null(name)) 
[13:19:03.463]                             next
[13:19:03.463]                           if (!grepl(pattern, name)) 
[13:19:03.463]                             next
[13:19:03.463]                           invokeRestart(restart)
[13:19:03.463]                           muffled <- TRUE
[13:19:03.463]                           break
[13:19:03.463]                         }
[13:19:03.463]                       }
[13:19:03.463]                     }
[13:19:03.463]                     invisible(muffled)
[13:19:03.463]                   }
[13:19:03.463]                   muffleCondition(cond)
[13:19:03.463]                 })
[13:19:03.463]             }))
[13:19:03.463]             future::FutureResult(value = ...future.value$value, 
[13:19:03.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.463]                   ...future.rng), globalenv = if (FALSE) 
[13:19:03.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:03.463]                     ...future.globalenv.names))
[13:19:03.463]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:03.463]         }, condition = base::local({
[13:19:03.463]             c <- base::c
[13:19:03.463]             inherits <- base::inherits
[13:19:03.463]             invokeRestart <- base::invokeRestart
[13:19:03.463]             length <- base::length
[13:19:03.463]             list <- base::list
[13:19:03.463]             seq.int <- base::seq.int
[13:19:03.463]             signalCondition <- base::signalCondition
[13:19:03.463]             sys.calls <- base::sys.calls
[13:19:03.463]             `[[` <- base::`[[`
[13:19:03.463]             `+` <- base::`+`
[13:19:03.463]             `<<-` <- base::`<<-`
[13:19:03.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:03.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:03.463]                   3L)]
[13:19:03.463]             }
[13:19:03.463]             function(cond) {
[13:19:03.463]                 is_error <- inherits(cond, "error")
[13:19:03.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:03.463]                   NULL)
[13:19:03.463]                 if (is_error) {
[13:19:03.463]                   sessionInformation <- function() {
[13:19:03.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:03.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:03.463]                       search = base::search(), system = base::Sys.info())
[13:19:03.463]                   }
[13:19:03.463]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:03.463]                     cond$call), session = sessionInformation(), 
[13:19:03.463]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:03.463]                   signalCondition(cond)
[13:19:03.463]                 }
[13:19:03.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:03.463]                 "immediateCondition"))) {
[13:19:03.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:03.463]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:03.463]                   if (TRUE && !signal) {
[13:19:03.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.463]                     {
[13:19:03.463]                       inherits <- base::inherits
[13:19:03.463]                       invokeRestart <- base::invokeRestart
[13:19:03.463]                       is.null <- base::is.null
[13:19:03.463]                       muffled <- FALSE
[13:19:03.463]                       if (inherits(cond, "message")) {
[13:19:03.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.463]                         if (muffled) 
[13:19:03.463]                           invokeRestart("muffleMessage")
[13:19:03.463]                       }
[13:19:03.463]                       else if (inherits(cond, "warning")) {
[13:19:03.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.463]                         if (muffled) 
[13:19:03.463]                           invokeRestart("muffleWarning")
[13:19:03.463]                       }
[13:19:03.463]                       else if (inherits(cond, "condition")) {
[13:19:03.463]                         if (!is.null(pattern)) {
[13:19:03.463]                           computeRestarts <- base::computeRestarts
[13:19:03.463]                           grepl <- base::grepl
[13:19:03.463]                           restarts <- computeRestarts(cond)
[13:19:03.463]                           for (restart in restarts) {
[13:19:03.463]                             name <- restart$name
[13:19:03.463]                             if (is.null(name)) 
[13:19:03.463]                               next
[13:19:03.463]                             if (!grepl(pattern, name)) 
[13:19:03.463]                               next
[13:19:03.463]                             invokeRestart(restart)
[13:19:03.463]                             muffled <- TRUE
[13:19:03.463]                             break
[13:19:03.463]                           }
[13:19:03.463]                         }
[13:19:03.463]                       }
[13:19:03.463]                       invisible(muffled)
[13:19:03.463]                     }
[13:19:03.463]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.463]                   }
[13:19:03.463]                 }
[13:19:03.463]                 else {
[13:19:03.463]                   if (TRUE) {
[13:19:03.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.463]                     {
[13:19:03.463]                       inherits <- base::inherits
[13:19:03.463]                       invokeRestart <- base::invokeRestart
[13:19:03.463]                       is.null <- base::is.null
[13:19:03.463]                       muffled <- FALSE
[13:19:03.463]                       if (inherits(cond, "message")) {
[13:19:03.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.463]                         if (muffled) 
[13:19:03.463]                           invokeRestart("muffleMessage")
[13:19:03.463]                       }
[13:19:03.463]                       else if (inherits(cond, "warning")) {
[13:19:03.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.463]                         if (muffled) 
[13:19:03.463]                           invokeRestart("muffleWarning")
[13:19:03.463]                       }
[13:19:03.463]                       else if (inherits(cond, "condition")) {
[13:19:03.463]                         if (!is.null(pattern)) {
[13:19:03.463]                           computeRestarts <- base::computeRestarts
[13:19:03.463]                           grepl <- base::grepl
[13:19:03.463]                           restarts <- computeRestarts(cond)
[13:19:03.463]                           for (restart in restarts) {
[13:19:03.463]                             name <- restart$name
[13:19:03.463]                             if (is.null(name)) 
[13:19:03.463]                               next
[13:19:03.463]                             if (!grepl(pattern, name)) 
[13:19:03.463]                               next
[13:19:03.463]                             invokeRestart(restart)
[13:19:03.463]                             muffled <- TRUE
[13:19:03.463]                             break
[13:19:03.463]                           }
[13:19:03.463]                         }
[13:19:03.463]                       }
[13:19:03.463]                       invisible(muffled)
[13:19:03.463]                     }
[13:19:03.463]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.463]                   }
[13:19:03.463]                 }
[13:19:03.463]             }
[13:19:03.463]         }))
[13:19:03.463]     }, error = function(ex) {
[13:19:03.463]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:03.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.463]                 ...future.rng), started = ...future.startTime, 
[13:19:03.463]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:03.463]             version = "1.8"), class = "FutureResult")
[13:19:03.463]     }, finally = {
[13:19:03.463]         if (!identical(...future.workdir, getwd())) 
[13:19:03.463]             setwd(...future.workdir)
[13:19:03.463]         {
[13:19:03.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:03.463]                 ...future.oldOptions$nwarnings <- NULL
[13:19:03.463]             }
[13:19:03.463]             base::options(...future.oldOptions)
[13:19:03.463]             if (.Platform$OS.type == "windows") {
[13:19:03.463]                 old_names <- names(...future.oldEnvVars)
[13:19:03.463]                 envs <- base::Sys.getenv()
[13:19:03.463]                 names <- names(envs)
[13:19:03.463]                 common <- intersect(names, old_names)
[13:19:03.463]                 added <- setdiff(names, old_names)
[13:19:03.463]                 removed <- setdiff(old_names, names)
[13:19:03.463]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:03.463]                   envs[common]]
[13:19:03.463]                 NAMES <- toupper(changed)
[13:19:03.463]                 args <- list()
[13:19:03.463]                 for (kk in seq_along(NAMES)) {
[13:19:03.463]                   name <- changed[[kk]]
[13:19:03.463]                   NAME <- NAMES[[kk]]
[13:19:03.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.463]                     next
[13:19:03.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.463]                 }
[13:19:03.463]                 NAMES <- toupper(added)
[13:19:03.463]                 for (kk in seq_along(NAMES)) {
[13:19:03.463]                   name <- added[[kk]]
[13:19:03.463]                   NAME <- NAMES[[kk]]
[13:19:03.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.463]                     next
[13:19:03.463]                   args[[name]] <- ""
[13:19:03.463]                 }
[13:19:03.463]                 NAMES <- toupper(removed)
[13:19:03.463]                 for (kk in seq_along(NAMES)) {
[13:19:03.463]                   name <- removed[[kk]]
[13:19:03.463]                   NAME <- NAMES[[kk]]
[13:19:03.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.463]                     next
[13:19:03.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.463]                 }
[13:19:03.463]                 if (length(args) > 0) 
[13:19:03.463]                   base::do.call(base::Sys.setenv, args = args)
[13:19:03.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:03.463]             }
[13:19:03.463]             else {
[13:19:03.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:03.463]             }
[13:19:03.463]             {
[13:19:03.463]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:03.463]                   0L) {
[13:19:03.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:03.463]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:03.463]                   base::options(opts)
[13:19:03.463]                 }
[13:19:03.463]                 {
[13:19:03.463]                   {
[13:19:03.463]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:03.463]                     NULL
[13:19:03.463]                   }
[13:19:03.463]                   options(future.plan = NULL)
[13:19:03.463]                   if (is.na(NA_character_)) 
[13:19:03.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:03.463]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:03.463]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:03.463]                     envir = parent.frame()) 
[13:19:03.463]                   {
[13:19:03.463]                     if (is.function(workers)) 
[13:19:03.463]                       workers <- workers()
[13:19:03.463]                     workers <- structure(as.integer(workers), 
[13:19:03.463]                       class = class(workers))
[13:19:03.463]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:03.463]                       workers >= 1)
[13:19:03.463]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:03.463]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:03.463]                     }
[13:19:03.463]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:03.463]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:03.463]                       envir = envir)
[13:19:03.463]                     if (!future$lazy) 
[13:19:03.463]                       future <- run(future)
[13:19:03.463]                     invisible(future)
[13:19:03.463]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:03.463]                 }
[13:19:03.463]             }
[13:19:03.463]         }
[13:19:03.463]     })
[13:19:03.463]     if (TRUE) {
[13:19:03.463]         base::sink(type = "output", split = FALSE)
[13:19:03.463]         if (TRUE) {
[13:19:03.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:03.463]         }
[13:19:03.463]         else {
[13:19:03.463]             ...future.result["stdout"] <- base::list(NULL)
[13:19:03.463]         }
[13:19:03.463]         base::close(...future.stdout)
[13:19:03.463]         ...future.stdout <- NULL
[13:19:03.463]     }
[13:19:03.463]     ...future.result$conditions <- ...future.conditions
[13:19:03.463]     ...future.result$finished <- base::Sys.time()
[13:19:03.463]     ...future.result
[13:19:03.463] }
[13:19:03.466] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[13:19:03.467] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:03.513] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:03.513] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[13:19:03.514] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[13:19:03.514] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:03.514] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:03.514] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:03.557] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:03.557] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:03.601] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:03.601] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:19:03.602] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:19:03.602] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:19:03.602] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:19:03.602] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:03.603] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.603] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:03.603] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:03.603] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:03.603] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.604] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:03.604] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:03.604] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[13:19:03.605] MultisessionFuture started
[13:19:03.605] - Launch lazy future ... done
[13:19:03.605] run() for ‘MultisessionFuture’ ... done
[13:19:03.605] Created future:
[13:19:03.605] MultisessionFuture:
[13:19:03.605] Label: ‘future_vapply-2’
[13:19:03.605] Expression:
[13:19:03.605] {
[13:19:03.605]     do.call(function(...) {
[13:19:03.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.605]             on.exit(options(oopts), add = TRUE)
[13:19:03.605]         }
[13:19:03.605]         {
[13:19:03.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.605]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.605]             })
[13:19:03.605]         }
[13:19:03.605]     }, args = future.call.arguments)
[13:19:03.605] }
[13:19:03.605] Lazy evaluation: FALSE
[13:19:03.605] Asynchronous evaluation: TRUE
[13:19:03.605] Local evaluation: TRUE
[13:19:03.605] Environment: R_GlobalEnv
[13:19:03.605] Capture standard output: TRUE
[13:19:03.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:03.605] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:03.605] Packages: 1 packages (‘future.apply’)
[13:19:03.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:03.605] Resolved: FALSE
[13:19:03.605] Value: <not collected>
[13:19:03.605] Conditions captured: <none>
[13:19:03.605] Early signaling: FALSE
[13:19:03.605] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:03.605] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.617] Chunk #2 of 2 ... DONE
[13:19:03.617] Launching 2 futures (chunks) ... DONE
[13:19:03.617] Resolving 2 futures (chunks) ...
[13:19:03.617] resolve() on list ...
[13:19:03.617]  recursive: 0
[13:19:03.617]  length: 2
[13:19:03.618] 
[13:19:03.618] receiveMessageFromWorker() for ClusterFuture ...
[13:19:03.618] - Validating connection of MultisessionFuture
[13:19:03.618] - received message: FutureResult
[13:19:03.618] - Received FutureResult
[13:19:03.619] - Erased future from FutureRegistry
[13:19:03.619] result() for ClusterFuture ...
[13:19:03.619] - result already collected: FutureResult
[13:19:03.619] result() for ClusterFuture ... done
[13:19:03.619] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:03.619] Future #1
[13:19:03.619] result() for ClusterFuture ...
[13:19:03.619] - result already collected: FutureResult
[13:19:03.619] result() for ClusterFuture ... done
[13:19:03.619] result() for ClusterFuture ...
[13:19:03.619] - result already collected: FutureResult
[13:19:03.620] result() for ClusterFuture ... done
[13:19:03.620] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:03.620] - nx: 2
[13:19:03.620] - relay: TRUE
[13:19:03.620] - stdout: TRUE
[13:19:03.620] - signal: TRUE
[13:19:03.620] - resignal: FALSE
[13:19:03.620] - force: TRUE
[13:19:03.620] - relayed: [n=2] FALSE, FALSE
[13:19:03.620] - queued futures: [n=2] FALSE, FALSE
[13:19:03.620]  - until=1
[13:19:03.621]  - relaying element #1
[13:19:03.621] result() for ClusterFuture ...
[13:19:03.621] - result already collected: FutureResult
[13:19:03.621] result() for ClusterFuture ... done
[13:19:03.621] result() for ClusterFuture ...
[13:19:03.621] - result already collected: FutureResult
[13:19:03.621] result() for ClusterFuture ... done
[13:19:03.621] result() for ClusterFuture ...
[13:19:03.621] - result already collected: FutureResult
[13:19:03.621] result() for ClusterFuture ... done
[13:19:03.622] result() for ClusterFuture ...
[13:19:03.622] - result already collected: FutureResult
[13:19:03.622] result() for ClusterFuture ... done
[13:19:03.622] - relayed: [n=2] TRUE, FALSE
[13:19:03.622] - queued futures: [n=2] TRUE, FALSE
[13:19:03.622] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:03.622]  length: 1 (resolved future 1)
[13:19:03.650] receiveMessageFromWorker() for ClusterFuture ...
[13:19:03.650] - Validating connection of MultisessionFuture
[13:19:03.650] - received message: FutureResult
[13:19:03.650] - Received FutureResult
[13:19:03.652] - Erased future from FutureRegistry
[13:19:03.652] result() for ClusterFuture ...
[13:19:03.653] - result already collected: FutureResult
[13:19:03.653] result() for ClusterFuture ... done
[13:19:03.653] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:03.653] Future #2
[13:19:03.653] result() for ClusterFuture ...
[13:19:03.653] - result already collected: FutureResult
[13:19:03.653] result() for ClusterFuture ... done
[13:19:03.653] result() for ClusterFuture ...
[13:19:03.653] - result already collected: FutureResult
[13:19:03.653] result() for ClusterFuture ... done
[13:19:03.653] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:03.654] - nx: 2
[13:19:03.654] - relay: TRUE
[13:19:03.654] - stdout: TRUE
[13:19:03.654] - signal: TRUE
[13:19:03.654] - resignal: FALSE
[13:19:03.654] - force: TRUE
[13:19:03.654] - relayed: [n=2] TRUE, FALSE
[13:19:03.654] - queued futures: [n=2] TRUE, FALSE
[13:19:03.654]  - until=2
[13:19:03.654]  - relaying element #2
[13:19:03.654] result() for ClusterFuture ...
[13:19:03.654] - result already collected: FutureResult
[13:19:03.655] result() for ClusterFuture ... done
[13:19:03.655] result() for ClusterFuture ...
[13:19:03.655] - result already collected: FutureResult
[13:19:03.655] result() for ClusterFuture ... done
[13:19:03.655] result() for ClusterFuture ...
[13:19:03.655] - result already collected: FutureResult
[13:19:03.655] result() for ClusterFuture ... done
[13:19:03.655] result() for ClusterFuture ...
[13:19:03.655] - result already collected: FutureResult
[13:19:03.655] result() for ClusterFuture ... done
[13:19:03.655] - relayed: [n=2] TRUE, TRUE
[13:19:03.655] - queued futures: [n=2] TRUE, TRUE
[13:19:03.656] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:03.656]  length: 0 (resolved future 2)
[13:19:03.656] Relaying remaining futures
[13:19:03.656] signalConditionsASAP(NULL, pos=0) ...
[13:19:03.656] - nx: 2
[13:19:03.656] - relay: TRUE
[13:19:03.656] - stdout: TRUE
[13:19:03.656] - signal: TRUE
[13:19:03.656] - resignal: FALSE
[13:19:03.656] - force: TRUE
[13:19:03.656] - relayed: [n=2] TRUE, TRUE
[13:19:03.656] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:03.657] - relayed: [n=2] TRUE, TRUE
[13:19:03.657] - queued futures: [n=2] TRUE, TRUE
[13:19:03.657] signalConditionsASAP(NULL, pos=0) ... done
[13:19:03.657] resolve() on list ... DONE
[13:19:03.657] result() for ClusterFuture ...
[13:19:03.657] - result already collected: FutureResult
[13:19:03.657] result() for ClusterFuture ... done
[13:19:03.657] result() for ClusterFuture ...
[13:19:03.657] - result already collected: FutureResult
[13:19:03.657] result() for ClusterFuture ... done
[13:19:03.658] result() for ClusterFuture ...
[13:19:03.658] - result already collected: FutureResult
[13:19:03.658] result() for ClusterFuture ... done
[13:19:03.658] result() for ClusterFuture ...
[13:19:03.658] - result already collected: FutureResult
[13:19:03.658] result() for ClusterFuture ... done
[13:19:03.658]  - Number of value chunks collected: 2
[13:19:03.658] Resolving 2 futures (chunks) ... DONE
[13:19:03.658] Reducing values from 2 chunks ...
[13:19:03.658]  - Number of values collected after concatenation: 10
[13:19:03.658]  - Number of values expected: 10
[13:19:03.658] Reducing values from 2 chunks ... DONE
[13:19:03.659] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:19:03.660] future_lapply() ...
[13:19:03.665] Number of chunks: 2
[13:19:03.665] getGlobalsAndPackagesXApply() ...
[13:19:03.665]  - future.globals: TRUE
[13:19:03.665] getGlobalsAndPackages() ...
[13:19:03.665] Searching for globals...
[13:19:03.669] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:19:03.669] Searching for globals ... DONE
[13:19:03.669] Resolving globals: FALSE
[13:19:03.670] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:19:03.670] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:03.670] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:03.670] - packages: [1] ‘future.apply’
[13:19:03.670] getGlobalsAndPackages() ... DONE
[13:19:03.670]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:03.671]  - needed namespaces: [n=1] ‘future.apply’
[13:19:03.671] Finding globals ... DONE
[13:19:03.671]  - use_args: TRUE
[13:19:03.671]  - Getting '...' globals ...
[13:19:03.671] resolve() on list ...
[13:19:03.671]  recursive: 0
[13:19:03.671]  length: 1
[13:19:03.671]  elements: ‘...’
[13:19:03.671]  length: 0 (resolved future 1)
[13:19:03.672] resolve() on list ... DONE
[13:19:03.672]    - '...' content: [n=0] 
[13:19:03.672] List of 1
[13:19:03.672]  $ ...: list()
[13:19:03.672]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:03.672]  - attr(*, "where")=List of 1
[13:19:03.672]   ..$ ...:<environment: 0x555f7df70938> 
[13:19:03.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:03.672]  - attr(*, "resolved")= logi TRUE
[13:19:03.672]  - attr(*, "total_size")= num NA
[13:19:03.674]  - Getting '...' globals ... DONE
[13:19:03.674] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:03.674] List of 8
[13:19:03.674]  $ ...future.FUN:function (x, ...)  
[13:19:03.674]  $ x_FUN        :function (x)  
[13:19:03.674]  $ times        : int 4
[13:19:03.674]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:03.674]  $ stop_if_not  :function (...)  
[13:19:03.674]  $ dim          : int [1:2] 2 2
[13:19:03.674]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:03.674]  $ ...          : list()
[13:19:03.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:03.674]  - attr(*, "where")=List of 8
[13:19:03.674]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:03.674]   ..$ ...          :<environment: 0x555f7df70938> 
[13:19:03.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:03.674]  - attr(*, "resolved")= logi FALSE
[13:19:03.674]  - attr(*, "total_size")= num 97304
[13:19:03.680] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:03.680] getGlobalsAndPackagesXApply() ... DONE
[13:19:03.680] Number of futures (= number of chunks): 2
[13:19:03.680] Launching 2 futures (chunks) ...
[13:19:03.680] Chunk #1 of 2 ...
[13:19:03.680]  - Finding globals in 'X' for chunk #1 ...
[13:19:03.680] getGlobalsAndPackages() ...
[13:19:03.680] Searching for globals...
[13:19:03.681] 
[13:19:03.681] Searching for globals ... DONE
[13:19:03.681] - globals: [0] <none>
[13:19:03.681] getGlobalsAndPackages() ... DONE
[13:19:03.681]    + additional globals found: [n=0] 
[13:19:03.681]    + additional namespaces needed: [n=0] 
[13:19:03.681]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:03.681]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:03.681]  - seeds: <none>
[13:19:03.682] getGlobalsAndPackages() ...
[13:19:03.682] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.682] Resolving globals: FALSE
[13:19:03.682] Tweak future expression to call with '...' arguments ...
[13:19:03.682] {
[13:19:03.682]     do.call(function(...) {
[13:19:03.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.682]             on.exit(options(oopts), add = TRUE)
[13:19:03.682]         }
[13:19:03.682]         {
[13:19:03.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.682]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.682]             })
[13:19:03.682]         }
[13:19:03.682]     }, args = future.call.arguments)
[13:19:03.682] }
[13:19:03.682] Tweak future expression to call with '...' arguments ... DONE
[13:19:03.683] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.683] - packages: [1] ‘future.apply’
[13:19:03.683] getGlobalsAndPackages() ... DONE
[13:19:03.683] run() for ‘Future’ ...
[13:19:03.683] - state: ‘created’
[13:19:03.683] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:03.698] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:03.698]   - Field: ‘node’
[13:19:03.699]   - Field: ‘label’
[13:19:03.699]   - Field: ‘local’
[13:19:03.699]   - Field: ‘owner’
[13:19:03.699]   - Field: ‘envir’
[13:19:03.699]   - Field: ‘workers’
[13:19:03.699]   - Field: ‘packages’
[13:19:03.699]   - Field: ‘gc’
[13:19:03.699]   - Field: ‘conditions’
[13:19:03.700]   - Field: ‘persistent’
[13:19:03.700]   - Field: ‘expr’
[13:19:03.700]   - Field: ‘uuid’
[13:19:03.700]   - Field: ‘seed’
[13:19:03.700]   - Field: ‘version’
[13:19:03.700]   - Field: ‘result’
[13:19:03.700]   - Field: ‘asynchronous’
[13:19:03.700]   - Field: ‘calls’
[13:19:03.701]   - Field: ‘globals’
[13:19:03.701]   - Field: ‘stdout’
[13:19:03.701]   - Field: ‘earlySignal’
[13:19:03.701]   - Field: ‘lazy’
[13:19:03.701]   - Field: ‘state’
[13:19:03.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:03.701] - Launch lazy future ...
[13:19:03.702] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:03.702] Packages needed by future strategies (n = 0): <none>
[13:19:03.702] {
[13:19:03.702]     {
[13:19:03.702]         {
[13:19:03.702]             ...future.startTime <- base::Sys.time()
[13:19:03.702]             {
[13:19:03.702]                 {
[13:19:03.702]                   {
[13:19:03.702]                     {
[13:19:03.702]                       {
[13:19:03.702]                         base::local({
[13:19:03.702]                           has_future <- base::requireNamespace("future", 
[13:19:03.702]                             quietly = TRUE)
[13:19:03.702]                           if (has_future) {
[13:19:03.702]                             ns <- base::getNamespace("future")
[13:19:03.702]                             version <- ns[[".package"]][["version"]]
[13:19:03.702]                             if (is.null(version)) 
[13:19:03.702]                               version <- utils::packageVersion("future")
[13:19:03.702]                           }
[13:19:03.702]                           else {
[13:19:03.702]                             version <- NULL
[13:19:03.702]                           }
[13:19:03.702]                           if (!has_future || version < "1.8.0") {
[13:19:03.702]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:03.702]                               "", base::R.version$version.string), 
[13:19:03.702]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:03.702]                                 base::R.version$platform, 8 * 
[13:19:03.702]                                   base::.Machine$sizeof.pointer), 
[13:19:03.702]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:03.702]                                 "release", "version")], collapse = " "), 
[13:19:03.702]                               hostname = base::Sys.info()[["nodename"]])
[13:19:03.702]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:03.702]                               info)
[13:19:03.702]                             info <- base::paste(info, collapse = "; ")
[13:19:03.702]                             if (!has_future) {
[13:19:03.702]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:03.702]                                 info)
[13:19:03.702]                             }
[13:19:03.702]                             else {
[13:19:03.702]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:03.702]                                 info, version)
[13:19:03.702]                             }
[13:19:03.702]                             base::stop(msg)
[13:19:03.702]                           }
[13:19:03.702]                         })
[13:19:03.702]                       }
[13:19:03.702]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:03.702]                       base::options(mc.cores = 1L)
[13:19:03.702]                     }
[13:19:03.702]                     base::local({
[13:19:03.702]                       for (pkg in "future.apply") {
[13:19:03.702]                         base::loadNamespace(pkg)
[13:19:03.702]                         base::library(pkg, character.only = TRUE)
[13:19:03.702]                       }
[13:19:03.702]                     })
[13:19:03.702]                   }
[13:19:03.702]                   options(future.plan = NULL)
[13:19:03.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:03.702]                 }
[13:19:03.702]                 ...future.workdir <- getwd()
[13:19:03.702]             }
[13:19:03.702]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:03.702]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:03.702]         }
[13:19:03.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:03.702]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:03.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:03.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:03.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:03.702]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:03.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:03.702]             base::names(...future.oldOptions))
[13:19:03.702]     }
[13:19:03.702]     if (FALSE) {
[13:19:03.702]     }
[13:19:03.702]     else {
[13:19:03.702]         if (TRUE) {
[13:19:03.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:03.702]                 open = "w")
[13:19:03.702]         }
[13:19:03.702]         else {
[13:19:03.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:03.702]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:03.702]         }
[13:19:03.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:03.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:03.702]             base::sink(type = "output", split = FALSE)
[13:19:03.702]             base::close(...future.stdout)
[13:19:03.702]         }, add = TRUE)
[13:19:03.702]     }
[13:19:03.702]     ...future.frame <- base::sys.nframe()
[13:19:03.702]     ...future.conditions <- base::list()
[13:19:03.702]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:03.702]     if (FALSE) {
[13:19:03.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:03.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:03.702]     }
[13:19:03.702]     ...future.result <- base::tryCatch({
[13:19:03.702]         base::withCallingHandlers({
[13:19:03.702]             ...future.value <- base::withVisible(base::local({
[13:19:03.702]                 ...future.makeSendCondition <- local({
[13:19:03.702]                   sendCondition <- NULL
[13:19:03.702]                   function(frame = 1L) {
[13:19:03.702]                     if (is.function(sendCondition)) 
[13:19:03.702]                       return(sendCondition)
[13:19:03.702]                     ns <- getNamespace("parallel")
[13:19:03.702]                     if (exists("sendData", mode = "function", 
[13:19:03.702]                       envir = ns)) {
[13:19:03.702]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:03.702]                         envir = ns)
[13:19:03.702]                       envir <- sys.frame(frame)
[13:19:03.702]                       master <- NULL
[13:19:03.702]                       while (!identical(envir, .GlobalEnv) && 
[13:19:03.702]                         !identical(envir, emptyenv())) {
[13:19:03.702]                         if (exists("master", mode = "list", envir = envir, 
[13:19:03.702]                           inherits = FALSE)) {
[13:19:03.702]                           master <- get("master", mode = "list", 
[13:19:03.702]                             envir = envir, inherits = FALSE)
[13:19:03.702]                           if (inherits(master, c("SOCKnode", 
[13:19:03.702]                             "SOCK0node"))) {
[13:19:03.702]                             sendCondition <<- function(cond) {
[13:19:03.702]                               data <- list(type = "VALUE", value = cond, 
[13:19:03.702]                                 success = TRUE)
[13:19:03.702]                               parallel_sendData(master, data)
[13:19:03.702]                             }
[13:19:03.702]                             return(sendCondition)
[13:19:03.702]                           }
[13:19:03.702]                         }
[13:19:03.702]                         frame <- frame + 1L
[13:19:03.702]                         envir <- sys.frame(frame)
[13:19:03.702]                       }
[13:19:03.702]                     }
[13:19:03.702]                     sendCondition <<- function(cond) NULL
[13:19:03.702]                   }
[13:19:03.702]                 })
[13:19:03.702]                 withCallingHandlers({
[13:19:03.702]                   {
[13:19:03.702]                     do.call(function(...) {
[13:19:03.702]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.702]                       if (!identical(...future.globals.maxSize.org, 
[13:19:03.702]                         ...future.globals.maxSize)) {
[13:19:03.702]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.702]                         on.exit(options(oopts), add = TRUE)
[13:19:03.702]                       }
[13:19:03.702]                       {
[13:19:03.702]                         lapply(seq_along(...future.elements_ii), 
[13:19:03.702]                           FUN = function(jj) {
[13:19:03.702]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.702]                             ...future.FUN(...future.X_jj, ...)
[13:19:03.702]                           })
[13:19:03.702]                       }
[13:19:03.702]                     }, args = future.call.arguments)
[13:19:03.702]                   }
[13:19:03.702]                 }, immediateCondition = function(cond) {
[13:19:03.702]                   sendCondition <- ...future.makeSendCondition()
[13:19:03.702]                   sendCondition(cond)
[13:19:03.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.702]                   {
[13:19:03.702]                     inherits <- base::inherits
[13:19:03.702]                     invokeRestart <- base::invokeRestart
[13:19:03.702]                     is.null <- base::is.null
[13:19:03.702]                     muffled <- FALSE
[13:19:03.702]                     if (inherits(cond, "message")) {
[13:19:03.702]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:03.702]                       if (muffled) 
[13:19:03.702]                         invokeRestart("muffleMessage")
[13:19:03.702]                     }
[13:19:03.702]                     else if (inherits(cond, "warning")) {
[13:19:03.702]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:03.702]                       if (muffled) 
[13:19:03.702]                         invokeRestart("muffleWarning")
[13:19:03.702]                     }
[13:19:03.702]                     else if (inherits(cond, "condition")) {
[13:19:03.702]                       if (!is.null(pattern)) {
[13:19:03.702]                         computeRestarts <- base::computeRestarts
[13:19:03.702]                         grepl <- base::grepl
[13:19:03.702]                         restarts <- computeRestarts(cond)
[13:19:03.702]                         for (restart in restarts) {
[13:19:03.702]                           name <- restart$name
[13:19:03.702]                           if (is.null(name)) 
[13:19:03.702]                             next
[13:19:03.702]                           if (!grepl(pattern, name)) 
[13:19:03.702]                             next
[13:19:03.702]                           invokeRestart(restart)
[13:19:03.702]                           muffled <- TRUE
[13:19:03.702]                           break
[13:19:03.702]                         }
[13:19:03.702]                       }
[13:19:03.702]                     }
[13:19:03.702]                     invisible(muffled)
[13:19:03.702]                   }
[13:19:03.702]                   muffleCondition(cond)
[13:19:03.702]                 })
[13:19:03.702]             }))
[13:19:03.702]             future::FutureResult(value = ...future.value$value, 
[13:19:03.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.702]                   ...future.rng), globalenv = if (FALSE) 
[13:19:03.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:03.702]                     ...future.globalenv.names))
[13:19:03.702]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:03.702]         }, condition = base::local({
[13:19:03.702]             c <- base::c
[13:19:03.702]             inherits <- base::inherits
[13:19:03.702]             invokeRestart <- base::invokeRestart
[13:19:03.702]             length <- base::length
[13:19:03.702]             list <- base::list
[13:19:03.702]             seq.int <- base::seq.int
[13:19:03.702]             signalCondition <- base::signalCondition
[13:19:03.702]             sys.calls <- base::sys.calls
[13:19:03.702]             `[[` <- base::`[[`
[13:19:03.702]             `+` <- base::`+`
[13:19:03.702]             `<<-` <- base::`<<-`
[13:19:03.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:03.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:03.702]                   3L)]
[13:19:03.702]             }
[13:19:03.702]             function(cond) {
[13:19:03.702]                 is_error <- inherits(cond, "error")
[13:19:03.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:03.702]                   NULL)
[13:19:03.702]                 if (is_error) {
[13:19:03.702]                   sessionInformation <- function() {
[13:19:03.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:03.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:03.702]                       search = base::search(), system = base::Sys.info())
[13:19:03.702]                   }
[13:19:03.702]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:03.702]                     cond$call), session = sessionInformation(), 
[13:19:03.702]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:03.702]                   signalCondition(cond)
[13:19:03.702]                 }
[13:19:03.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:03.702]                 "immediateCondition"))) {
[13:19:03.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:03.702]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:03.702]                   if (TRUE && !signal) {
[13:19:03.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.702]                     {
[13:19:03.702]                       inherits <- base::inherits
[13:19:03.702]                       invokeRestart <- base::invokeRestart
[13:19:03.702]                       is.null <- base::is.null
[13:19:03.702]                       muffled <- FALSE
[13:19:03.702]                       if (inherits(cond, "message")) {
[13:19:03.702]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.702]                         if (muffled) 
[13:19:03.702]                           invokeRestart("muffleMessage")
[13:19:03.702]                       }
[13:19:03.702]                       else if (inherits(cond, "warning")) {
[13:19:03.702]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.702]                         if (muffled) 
[13:19:03.702]                           invokeRestart("muffleWarning")
[13:19:03.702]                       }
[13:19:03.702]                       else if (inherits(cond, "condition")) {
[13:19:03.702]                         if (!is.null(pattern)) {
[13:19:03.702]                           computeRestarts <- base::computeRestarts
[13:19:03.702]                           grepl <- base::grepl
[13:19:03.702]                           restarts <- computeRestarts(cond)
[13:19:03.702]                           for (restart in restarts) {
[13:19:03.702]                             name <- restart$name
[13:19:03.702]                             if (is.null(name)) 
[13:19:03.702]                               next
[13:19:03.702]                             if (!grepl(pattern, name)) 
[13:19:03.702]                               next
[13:19:03.702]                             invokeRestart(restart)
[13:19:03.702]                             muffled <- TRUE
[13:19:03.702]                             break
[13:19:03.702]                           }
[13:19:03.702]                         }
[13:19:03.702]                       }
[13:19:03.702]                       invisible(muffled)
[13:19:03.702]                     }
[13:19:03.702]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.702]                   }
[13:19:03.702]                 }
[13:19:03.702]                 else {
[13:19:03.702]                   if (TRUE) {
[13:19:03.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.702]                     {
[13:19:03.702]                       inherits <- base::inherits
[13:19:03.702]                       invokeRestart <- base::invokeRestart
[13:19:03.702]                       is.null <- base::is.null
[13:19:03.702]                       muffled <- FALSE
[13:19:03.702]                       if (inherits(cond, "message")) {
[13:19:03.702]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.702]                         if (muffled) 
[13:19:03.702]                           invokeRestart("muffleMessage")
[13:19:03.702]                       }
[13:19:03.702]                       else if (inherits(cond, "warning")) {
[13:19:03.702]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.702]                         if (muffled) 
[13:19:03.702]                           invokeRestart("muffleWarning")
[13:19:03.702]                       }
[13:19:03.702]                       else if (inherits(cond, "condition")) {
[13:19:03.702]                         if (!is.null(pattern)) {
[13:19:03.702]                           computeRestarts <- base::computeRestarts
[13:19:03.702]                           grepl <- base::grepl
[13:19:03.702]                           restarts <- computeRestarts(cond)
[13:19:03.702]                           for (restart in restarts) {
[13:19:03.702]                             name <- restart$name
[13:19:03.702]                             if (is.null(name)) 
[13:19:03.702]                               next
[13:19:03.702]                             if (!grepl(pattern, name)) 
[13:19:03.702]                               next
[13:19:03.702]                             invokeRestart(restart)
[13:19:03.702]                             muffled <- TRUE
[13:19:03.702]                             break
[13:19:03.702]                           }
[13:19:03.702]                         }
[13:19:03.702]                       }
[13:19:03.702]                       invisible(muffled)
[13:19:03.702]                     }
[13:19:03.702]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.702]                   }
[13:19:03.702]                 }
[13:19:03.702]             }
[13:19:03.702]         }))
[13:19:03.702]     }, error = function(ex) {
[13:19:03.702]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:03.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.702]                 ...future.rng), started = ...future.startTime, 
[13:19:03.702]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:03.702]             version = "1.8"), class = "FutureResult")
[13:19:03.702]     }, finally = {
[13:19:03.702]         if (!identical(...future.workdir, getwd())) 
[13:19:03.702]             setwd(...future.workdir)
[13:19:03.702]         {
[13:19:03.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:03.702]                 ...future.oldOptions$nwarnings <- NULL
[13:19:03.702]             }
[13:19:03.702]             base::options(...future.oldOptions)
[13:19:03.702]             if (.Platform$OS.type == "windows") {
[13:19:03.702]                 old_names <- names(...future.oldEnvVars)
[13:19:03.702]                 envs <- base::Sys.getenv()
[13:19:03.702]                 names <- names(envs)
[13:19:03.702]                 common <- intersect(names, old_names)
[13:19:03.702]                 added <- setdiff(names, old_names)
[13:19:03.702]                 removed <- setdiff(old_names, names)
[13:19:03.702]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:03.702]                   envs[common]]
[13:19:03.702]                 NAMES <- toupper(changed)
[13:19:03.702]                 args <- list()
[13:19:03.702]                 for (kk in seq_along(NAMES)) {
[13:19:03.702]                   name <- changed[[kk]]
[13:19:03.702]                   NAME <- NAMES[[kk]]
[13:19:03.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.702]                     next
[13:19:03.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.702]                 }
[13:19:03.702]                 NAMES <- toupper(added)
[13:19:03.702]                 for (kk in seq_along(NAMES)) {
[13:19:03.702]                   name <- added[[kk]]
[13:19:03.702]                   NAME <- NAMES[[kk]]
[13:19:03.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.702]                     next
[13:19:03.702]                   args[[name]] <- ""
[13:19:03.702]                 }
[13:19:03.702]                 NAMES <- toupper(removed)
[13:19:03.702]                 for (kk in seq_along(NAMES)) {
[13:19:03.702]                   name <- removed[[kk]]
[13:19:03.702]                   NAME <- NAMES[[kk]]
[13:19:03.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.702]                     next
[13:19:03.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.702]                 }
[13:19:03.702]                 if (length(args) > 0) 
[13:19:03.702]                   base::do.call(base::Sys.setenv, args = args)
[13:19:03.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:03.702]             }
[13:19:03.702]             else {
[13:19:03.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:03.702]             }
[13:19:03.702]             {
[13:19:03.702]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:03.702]                   0L) {
[13:19:03.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:03.702]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:03.702]                   base::options(opts)
[13:19:03.702]                 }
[13:19:03.702]                 {
[13:19:03.702]                   {
[13:19:03.702]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:03.702]                     NULL
[13:19:03.702]                   }
[13:19:03.702]                   options(future.plan = NULL)
[13:19:03.702]                   if (is.na(NA_character_)) 
[13:19:03.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:03.702]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:03.702]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:03.702]                     envir = parent.frame()) 
[13:19:03.702]                   {
[13:19:03.702]                     if (is.function(workers)) 
[13:19:03.702]                       workers <- workers()
[13:19:03.702]                     workers <- structure(as.integer(workers), 
[13:19:03.702]                       class = class(workers))
[13:19:03.702]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:03.702]                       workers >= 1)
[13:19:03.702]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:03.702]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:03.702]                     }
[13:19:03.702]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:03.702]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:03.702]                       envir = envir)
[13:19:03.702]                     if (!future$lazy) 
[13:19:03.702]                       future <- run(future)
[13:19:03.702]                     invisible(future)
[13:19:03.702]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:03.702]                 }
[13:19:03.702]             }
[13:19:03.702]         }
[13:19:03.702]     })
[13:19:03.702]     if (TRUE) {
[13:19:03.702]         base::sink(type = "output", split = FALSE)
[13:19:03.702]         if (TRUE) {
[13:19:03.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:03.702]         }
[13:19:03.702]         else {
[13:19:03.702]             ...future.result["stdout"] <- base::list(NULL)
[13:19:03.702]         }
[13:19:03.702]         base::close(...future.stdout)
[13:19:03.702]         ...future.stdout <- NULL
[13:19:03.702]     }
[13:19:03.702]     ...future.result$conditions <- ...future.conditions
[13:19:03.702]     ...future.result$finished <- base::Sys.time()
[13:19:03.702]     ...future.result
[13:19:03.702] }
[13:19:03.706] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[13:19:03.706] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:03.749] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:03.749] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[13:19:03.750] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[13:19:03.750] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:03.750] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:03.750] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:03.793] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:03.793] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:03.837] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:03.837] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:19:03.838] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:19:03.838] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:03.838] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:03.838] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:03.839] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:03.839] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:03.839] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:03.839] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:03.840] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:03.840] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:03.840] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:03.840] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[13:19:03.841] MultisessionFuture started
[13:19:03.841] - Launch lazy future ... done
[13:19:03.841] run() for ‘MultisessionFuture’ ... done
[13:19:03.842] Created future:
[13:19:03.842] MultisessionFuture:
[13:19:03.842] Label: ‘future_vapply-1’
[13:19:03.842] Expression:
[13:19:03.842] {
[13:19:03.842]     do.call(function(...) {
[13:19:03.842]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.842]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.842]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.842]             on.exit(options(oopts), add = TRUE)
[13:19:03.842]         }
[13:19:03.842]         {
[13:19:03.842]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.842]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.842]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.842]             })
[13:19:03.842]         }
[13:19:03.842]     }, args = future.call.arguments)
[13:19:03.842] }
[13:19:03.842] Lazy evaluation: FALSE
[13:19:03.842] Asynchronous evaluation: TRUE
[13:19:03.842] Local evaluation: TRUE
[13:19:03.842] Environment: R_GlobalEnv
[13:19:03.842] Capture standard output: TRUE
[13:19:03.842] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:03.842] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:03.842] Packages: 1 packages (‘future.apply’)
[13:19:03.842] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:03.842] Resolved: FALSE
[13:19:03.842] Value: <not collected>
[13:19:03.842] Conditions captured: <none>
[13:19:03.842] Early signaling: FALSE
[13:19:03.842] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:03.842] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.853] Chunk #1 of 2 ... DONE
[13:19:03.853] Chunk #2 of 2 ...
[13:19:03.854]  - Finding globals in 'X' for chunk #2 ...
[13:19:03.854] getGlobalsAndPackages() ...
[13:19:03.854] Searching for globals...
[13:19:03.854] 
[13:19:03.854] Searching for globals ... DONE
[13:19:03.854] - globals: [0] <none>
[13:19:03.854] getGlobalsAndPackages() ... DONE
[13:19:03.854]    + additional globals found: [n=0] 
[13:19:03.855]    + additional namespaces needed: [n=0] 
[13:19:03.855]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:03.855]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:03.855]  - seeds: <none>
[13:19:03.855] getGlobalsAndPackages() ...
[13:19:03.855] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.855] Resolving globals: FALSE
[13:19:03.855] Tweak future expression to call with '...' arguments ...
[13:19:03.855] {
[13:19:03.855]     do.call(function(...) {
[13:19:03.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:03.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.855]             on.exit(options(oopts), add = TRUE)
[13:19:03.855]         }
[13:19:03.855]         {
[13:19:03.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:03.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.855]                 ...future.FUN(...future.X_jj, ...)
[13:19:03.855]             })
[13:19:03.855]         }
[13:19:03.855]     }, args = future.call.arguments)
[13:19:03.855] }
[13:19:03.856] Tweak future expression to call with '...' arguments ... DONE
[13:19:03.856] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:03.856] - packages: [1] ‘future.apply’
[13:19:03.856] getGlobalsAndPackages() ... DONE
[13:19:03.857] run() for ‘Future’ ...
[13:19:03.857] - state: ‘created’
[13:19:03.857] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:03.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:03.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:03.872]   - Field: ‘node’
[13:19:03.872]   - Field: ‘label’
[13:19:03.872]   - Field: ‘local’
[13:19:03.872]   - Field: ‘owner’
[13:19:03.872]   - Field: ‘envir’
[13:19:03.872]   - Field: ‘workers’
[13:19:03.872]   - Field: ‘packages’
[13:19:03.873]   - Field: ‘gc’
[13:19:03.873]   - Field: ‘conditions’
[13:19:03.873]   - Field: ‘persistent’
[13:19:03.873]   - Field: ‘expr’
[13:19:03.873]   - Field: ‘uuid’
[13:19:03.873]   - Field: ‘seed’
[13:19:03.873]   - Field: ‘version’
[13:19:03.873]   - Field: ‘result’
[13:19:03.873]   - Field: ‘asynchronous’
[13:19:03.873]   - Field: ‘calls’
[13:19:03.873]   - Field: ‘globals’
[13:19:03.874]   - Field: ‘stdout’
[13:19:03.874]   - Field: ‘earlySignal’
[13:19:03.874]   - Field: ‘lazy’
[13:19:03.874]   - Field: ‘state’
[13:19:03.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:03.874] - Launch lazy future ...
[13:19:03.874] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:03.874] Packages needed by future strategies (n = 0): <none>
[13:19:03.875] {
[13:19:03.875]     {
[13:19:03.875]         {
[13:19:03.875]             ...future.startTime <- base::Sys.time()
[13:19:03.875]             {
[13:19:03.875]                 {
[13:19:03.875]                   {
[13:19:03.875]                     {
[13:19:03.875]                       {
[13:19:03.875]                         base::local({
[13:19:03.875]                           has_future <- base::requireNamespace("future", 
[13:19:03.875]                             quietly = TRUE)
[13:19:03.875]                           if (has_future) {
[13:19:03.875]                             ns <- base::getNamespace("future")
[13:19:03.875]                             version <- ns[[".package"]][["version"]]
[13:19:03.875]                             if (is.null(version)) 
[13:19:03.875]                               version <- utils::packageVersion("future")
[13:19:03.875]                           }
[13:19:03.875]                           else {
[13:19:03.875]                             version <- NULL
[13:19:03.875]                           }
[13:19:03.875]                           if (!has_future || version < "1.8.0") {
[13:19:03.875]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:03.875]                               "", base::R.version$version.string), 
[13:19:03.875]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:03.875]                                 base::R.version$platform, 8 * 
[13:19:03.875]                                   base::.Machine$sizeof.pointer), 
[13:19:03.875]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:03.875]                                 "release", "version")], collapse = " "), 
[13:19:03.875]                               hostname = base::Sys.info()[["nodename"]])
[13:19:03.875]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:03.875]                               info)
[13:19:03.875]                             info <- base::paste(info, collapse = "; ")
[13:19:03.875]                             if (!has_future) {
[13:19:03.875]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:03.875]                                 info)
[13:19:03.875]                             }
[13:19:03.875]                             else {
[13:19:03.875]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:03.875]                                 info, version)
[13:19:03.875]                             }
[13:19:03.875]                             base::stop(msg)
[13:19:03.875]                           }
[13:19:03.875]                         })
[13:19:03.875]                       }
[13:19:03.875]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:03.875]                       base::options(mc.cores = 1L)
[13:19:03.875]                     }
[13:19:03.875]                     base::local({
[13:19:03.875]                       for (pkg in "future.apply") {
[13:19:03.875]                         base::loadNamespace(pkg)
[13:19:03.875]                         base::library(pkg, character.only = TRUE)
[13:19:03.875]                       }
[13:19:03.875]                     })
[13:19:03.875]                   }
[13:19:03.875]                   options(future.plan = NULL)
[13:19:03.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:03.875]                 }
[13:19:03.875]                 ...future.workdir <- getwd()
[13:19:03.875]             }
[13:19:03.875]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:03.875]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:03.875]         }
[13:19:03.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:03.875]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:03.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:03.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:03.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:03.875]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:03.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:03.875]             base::names(...future.oldOptions))
[13:19:03.875]     }
[13:19:03.875]     if (FALSE) {
[13:19:03.875]     }
[13:19:03.875]     else {
[13:19:03.875]         if (TRUE) {
[13:19:03.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:03.875]                 open = "w")
[13:19:03.875]         }
[13:19:03.875]         else {
[13:19:03.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:03.875]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:03.875]         }
[13:19:03.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:03.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:03.875]             base::sink(type = "output", split = FALSE)
[13:19:03.875]             base::close(...future.stdout)
[13:19:03.875]         }, add = TRUE)
[13:19:03.875]     }
[13:19:03.875]     ...future.frame <- base::sys.nframe()
[13:19:03.875]     ...future.conditions <- base::list()
[13:19:03.875]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:03.875]     if (FALSE) {
[13:19:03.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:03.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:03.875]     }
[13:19:03.875]     ...future.result <- base::tryCatch({
[13:19:03.875]         base::withCallingHandlers({
[13:19:03.875]             ...future.value <- base::withVisible(base::local({
[13:19:03.875]                 ...future.makeSendCondition <- local({
[13:19:03.875]                   sendCondition <- NULL
[13:19:03.875]                   function(frame = 1L) {
[13:19:03.875]                     if (is.function(sendCondition)) 
[13:19:03.875]                       return(sendCondition)
[13:19:03.875]                     ns <- getNamespace("parallel")
[13:19:03.875]                     if (exists("sendData", mode = "function", 
[13:19:03.875]                       envir = ns)) {
[13:19:03.875]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:03.875]                         envir = ns)
[13:19:03.875]                       envir <- sys.frame(frame)
[13:19:03.875]                       master <- NULL
[13:19:03.875]                       while (!identical(envir, .GlobalEnv) && 
[13:19:03.875]                         !identical(envir, emptyenv())) {
[13:19:03.875]                         if (exists("master", mode = "list", envir = envir, 
[13:19:03.875]                           inherits = FALSE)) {
[13:19:03.875]                           master <- get("master", mode = "list", 
[13:19:03.875]                             envir = envir, inherits = FALSE)
[13:19:03.875]                           if (inherits(master, c("SOCKnode", 
[13:19:03.875]                             "SOCK0node"))) {
[13:19:03.875]                             sendCondition <<- function(cond) {
[13:19:03.875]                               data <- list(type = "VALUE", value = cond, 
[13:19:03.875]                                 success = TRUE)
[13:19:03.875]                               parallel_sendData(master, data)
[13:19:03.875]                             }
[13:19:03.875]                             return(sendCondition)
[13:19:03.875]                           }
[13:19:03.875]                         }
[13:19:03.875]                         frame <- frame + 1L
[13:19:03.875]                         envir <- sys.frame(frame)
[13:19:03.875]                       }
[13:19:03.875]                     }
[13:19:03.875]                     sendCondition <<- function(cond) NULL
[13:19:03.875]                   }
[13:19:03.875]                 })
[13:19:03.875]                 withCallingHandlers({
[13:19:03.875]                   {
[13:19:03.875]                     do.call(function(...) {
[13:19:03.875]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:03.875]                       if (!identical(...future.globals.maxSize.org, 
[13:19:03.875]                         ...future.globals.maxSize)) {
[13:19:03.875]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:03.875]                         on.exit(options(oopts), add = TRUE)
[13:19:03.875]                       }
[13:19:03.875]                       {
[13:19:03.875]                         lapply(seq_along(...future.elements_ii), 
[13:19:03.875]                           FUN = function(jj) {
[13:19:03.875]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:03.875]                             ...future.FUN(...future.X_jj, ...)
[13:19:03.875]                           })
[13:19:03.875]                       }
[13:19:03.875]                     }, args = future.call.arguments)
[13:19:03.875]                   }
[13:19:03.875]                 }, immediateCondition = function(cond) {
[13:19:03.875]                   sendCondition <- ...future.makeSendCondition()
[13:19:03.875]                   sendCondition(cond)
[13:19:03.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.875]                   {
[13:19:03.875]                     inherits <- base::inherits
[13:19:03.875]                     invokeRestart <- base::invokeRestart
[13:19:03.875]                     is.null <- base::is.null
[13:19:03.875]                     muffled <- FALSE
[13:19:03.875]                     if (inherits(cond, "message")) {
[13:19:03.875]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:03.875]                       if (muffled) 
[13:19:03.875]                         invokeRestart("muffleMessage")
[13:19:03.875]                     }
[13:19:03.875]                     else if (inherits(cond, "warning")) {
[13:19:03.875]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:03.875]                       if (muffled) 
[13:19:03.875]                         invokeRestart("muffleWarning")
[13:19:03.875]                     }
[13:19:03.875]                     else if (inherits(cond, "condition")) {
[13:19:03.875]                       if (!is.null(pattern)) {
[13:19:03.875]                         computeRestarts <- base::computeRestarts
[13:19:03.875]                         grepl <- base::grepl
[13:19:03.875]                         restarts <- computeRestarts(cond)
[13:19:03.875]                         for (restart in restarts) {
[13:19:03.875]                           name <- restart$name
[13:19:03.875]                           if (is.null(name)) 
[13:19:03.875]                             next
[13:19:03.875]                           if (!grepl(pattern, name)) 
[13:19:03.875]                             next
[13:19:03.875]                           invokeRestart(restart)
[13:19:03.875]                           muffled <- TRUE
[13:19:03.875]                           break
[13:19:03.875]                         }
[13:19:03.875]                       }
[13:19:03.875]                     }
[13:19:03.875]                     invisible(muffled)
[13:19:03.875]                   }
[13:19:03.875]                   muffleCondition(cond)
[13:19:03.875]                 })
[13:19:03.875]             }))
[13:19:03.875]             future::FutureResult(value = ...future.value$value, 
[13:19:03.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.875]                   ...future.rng), globalenv = if (FALSE) 
[13:19:03.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:03.875]                     ...future.globalenv.names))
[13:19:03.875]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:03.875]         }, condition = base::local({
[13:19:03.875]             c <- base::c
[13:19:03.875]             inherits <- base::inherits
[13:19:03.875]             invokeRestart <- base::invokeRestart
[13:19:03.875]             length <- base::length
[13:19:03.875]             list <- base::list
[13:19:03.875]             seq.int <- base::seq.int
[13:19:03.875]             signalCondition <- base::signalCondition
[13:19:03.875]             sys.calls <- base::sys.calls
[13:19:03.875]             `[[` <- base::`[[`
[13:19:03.875]             `+` <- base::`+`
[13:19:03.875]             `<<-` <- base::`<<-`
[13:19:03.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:03.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:03.875]                   3L)]
[13:19:03.875]             }
[13:19:03.875]             function(cond) {
[13:19:03.875]                 is_error <- inherits(cond, "error")
[13:19:03.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:03.875]                   NULL)
[13:19:03.875]                 if (is_error) {
[13:19:03.875]                   sessionInformation <- function() {
[13:19:03.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:03.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:03.875]                       search = base::search(), system = base::Sys.info())
[13:19:03.875]                   }
[13:19:03.875]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:03.875]                     cond$call), session = sessionInformation(), 
[13:19:03.875]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:03.875]                   signalCondition(cond)
[13:19:03.875]                 }
[13:19:03.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:03.875]                 "immediateCondition"))) {
[13:19:03.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:03.875]                   ...future.conditions[[length(...future.conditions) + 
[13:19:03.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:03.875]                   if (TRUE && !signal) {
[13:19:03.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.875]                     {
[13:19:03.875]                       inherits <- base::inherits
[13:19:03.875]                       invokeRestart <- base::invokeRestart
[13:19:03.875]                       is.null <- base::is.null
[13:19:03.875]                       muffled <- FALSE
[13:19:03.875]                       if (inherits(cond, "message")) {
[13:19:03.875]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.875]                         if (muffled) 
[13:19:03.875]                           invokeRestart("muffleMessage")
[13:19:03.875]                       }
[13:19:03.875]                       else if (inherits(cond, "warning")) {
[13:19:03.875]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.875]                         if (muffled) 
[13:19:03.875]                           invokeRestart("muffleWarning")
[13:19:03.875]                       }
[13:19:03.875]                       else if (inherits(cond, "condition")) {
[13:19:03.875]                         if (!is.null(pattern)) {
[13:19:03.875]                           computeRestarts <- base::computeRestarts
[13:19:03.875]                           grepl <- base::grepl
[13:19:03.875]                           restarts <- computeRestarts(cond)
[13:19:03.875]                           for (restart in restarts) {
[13:19:03.875]                             name <- restart$name
[13:19:03.875]                             if (is.null(name)) 
[13:19:03.875]                               next
[13:19:03.875]                             if (!grepl(pattern, name)) 
[13:19:03.875]                               next
[13:19:03.875]                             invokeRestart(restart)
[13:19:03.875]                             muffled <- TRUE
[13:19:03.875]                             break
[13:19:03.875]                           }
[13:19:03.875]                         }
[13:19:03.875]                       }
[13:19:03.875]                       invisible(muffled)
[13:19:03.875]                     }
[13:19:03.875]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.875]                   }
[13:19:03.875]                 }
[13:19:03.875]                 else {
[13:19:03.875]                   if (TRUE) {
[13:19:03.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:03.875]                     {
[13:19:03.875]                       inherits <- base::inherits
[13:19:03.875]                       invokeRestart <- base::invokeRestart
[13:19:03.875]                       is.null <- base::is.null
[13:19:03.875]                       muffled <- FALSE
[13:19:03.875]                       if (inherits(cond, "message")) {
[13:19:03.875]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:03.875]                         if (muffled) 
[13:19:03.875]                           invokeRestart("muffleMessage")
[13:19:03.875]                       }
[13:19:03.875]                       else if (inherits(cond, "warning")) {
[13:19:03.875]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:03.875]                         if (muffled) 
[13:19:03.875]                           invokeRestart("muffleWarning")
[13:19:03.875]                       }
[13:19:03.875]                       else if (inherits(cond, "condition")) {
[13:19:03.875]                         if (!is.null(pattern)) {
[13:19:03.875]                           computeRestarts <- base::computeRestarts
[13:19:03.875]                           grepl <- base::grepl
[13:19:03.875]                           restarts <- computeRestarts(cond)
[13:19:03.875]                           for (restart in restarts) {
[13:19:03.875]                             name <- restart$name
[13:19:03.875]                             if (is.null(name)) 
[13:19:03.875]                               next
[13:19:03.875]                             if (!grepl(pattern, name)) 
[13:19:03.875]                               next
[13:19:03.875]                             invokeRestart(restart)
[13:19:03.875]                             muffled <- TRUE
[13:19:03.875]                             break
[13:19:03.875]                           }
[13:19:03.875]                         }
[13:19:03.875]                       }
[13:19:03.875]                       invisible(muffled)
[13:19:03.875]                     }
[13:19:03.875]                     muffleCondition(cond, pattern = "^muffle")
[13:19:03.875]                   }
[13:19:03.875]                 }
[13:19:03.875]             }
[13:19:03.875]         }))
[13:19:03.875]     }, error = function(ex) {
[13:19:03.875]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:03.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:03.875]                 ...future.rng), started = ...future.startTime, 
[13:19:03.875]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:03.875]             version = "1.8"), class = "FutureResult")
[13:19:03.875]     }, finally = {
[13:19:03.875]         if (!identical(...future.workdir, getwd())) 
[13:19:03.875]             setwd(...future.workdir)
[13:19:03.875]         {
[13:19:03.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:03.875]                 ...future.oldOptions$nwarnings <- NULL
[13:19:03.875]             }
[13:19:03.875]             base::options(...future.oldOptions)
[13:19:03.875]             if (.Platform$OS.type == "windows") {
[13:19:03.875]                 old_names <- names(...future.oldEnvVars)
[13:19:03.875]                 envs <- base::Sys.getenv()
[13:19:03.875]                 names <- names(envs)
[13:19:03.875]                 common <- intersect(names, old_names)
[13:19:03.875]                 added <- setdiff(names, old_names)
[13:19:03.875]                 removed <- setdiff(old_names, names)
[13:19:03.875]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:03.875]                   envs[common]]
[13:19:03.875]                 NAMES <- toupper(changed)
[13:19:03.875]                 args <- list()
[13:19:03.875]                 for (kk in seq_along(NAMES)) {
[13:19:03.875]                   name <- changed[[kk]]
[13:19:03.875]                   NAME <- NAMES[[kk]]
[13:19:03.875]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.875]                     next
[13:19:03.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.875]                 }
[13:19:03.875]                 NAMES <- toupper(added)
[13:19:03.875]                 for (kk in seq_along(NAMES)) {
[13:19:03.875]                   name <- added[[kk]]
[13:19:03.875]                   NAME <- NAMES[[kk]]
[13:19:03.875]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.875]                     next
[13:19:03.875]                   args[[name]] <- ""
[13:19:03.875]                 }
[13:19:03.875]                 NAMES <- toupper(removed)
[13:19:03.875]                 for (kk in seq_along(NAMES)) {
[13:19:03.875]                   name <- removed[[kk]]
[13:19:03.875]                   NAME <- NAMES[[kk]]
[13:19:03.875]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:03.875]                     next
[13:19:03.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:03.875]                 }
[13:19:03.875]                 if (length(args) > 0) 
[13:19:03.875]                   base::do.call(base::Sys.setenv, args = args)
[13:19:03.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:03.875]             }
[13:19:03.875]             else {
[13:19:03.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:03.875]             }
[13:19:03.875]             {
[13:19:03.875]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:03.875]                   0L) {
[13:19:03.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:03.875]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:03.875]                   base::options(opts)
[13:19:03.875]                 }
[13:19:03.875]                 {
[13:19:03.875]                   {
[13:19:03.875]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:03.875]                     NULL
[13:19:03.875]                   }
[13:19:03.875]                   options(future.plan = NULL)
[13:19:03.875]                   if (is.na(NA_character_)) 
[13:19:03.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:03.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:03.875]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:03.875]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:03.875]                     envir = parent.frame()) 
[13:19:03.875]                   {
[13:19:03.875]                     if (is.function(workers)) 
[13:19:03.875]                       workers <- workers()
[13:19:03.875]                     workers <- structure(as.integer(workers), 
[13:19:03.875]                       class = class(workers))
[13:19:03.875]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:03.875]                       workers >= 1)
[13:19:03.875]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:03.875]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:03.875]                     }
[13:19:03.875]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:03.875]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:03.875]                       envir = envir)
[13:19:03.875]                     if (!future$lazy) 
[13:19:03.875]                       future <- run(future)
[13:19:03.875]                     invisible(future)
[13:19:03.875]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:03.875]                 }
[13:19:03.875]             }
[13:19:03.875]         }
[13:19:03.875]     })
[13:19:03.875]     if (TRUE) {
[13:19:03.875]         base::sink(type = "output", split = FALSE)
[13:19:03.875]         if (TRUE) {
[13:19:03.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:03.875]         }
[13:19:03.875]         else {
[13:19:03.875]             ...future.result["stdout"] <- base::list(NULL)
[13:19:03.875]         }
[13:19:03.875]         base::close(...future.stdout)
[13:19:03.875]         ...future.stdout <- NULL
[13:19:03.875]     }
[13:19:03.875]     ...future.result$conditions <- ...future.conditions
[13:19:03.875]     ...future.result$finished <- base::Sys.time()
[13:19:03.875]     ...future.result
[13:19:03.875] }
[13:19:03.878] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[13:19:03.878] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:03.921] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:03.921] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[13:19:03.922] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[13:19:03.922] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:03.922] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:03.922] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:03.965] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:03.965] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:04.009] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:04.009] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:19:04.009] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:19:04.010] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:04.010] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:04.010] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:04.011] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.011] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:04.013] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:04.013] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:04.014] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.014] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:04.014] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.014] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[13:19:04.015] MultisessionFuture started
[13:19:04.015] - Launch lazy future ... done
[13:19:04.015] run() for ‘MultisessionFuture’ ... done
[13:19:04.015] Created future:
[13:19:04.015] MultisessionFuture:
[13:19:04.015] Label: ‘future_vapply-2’
[13:19:04.015] Expression:
[13:19:04.015] {
[13:19:04.015]     do.call(function(...) {
[13:19:04.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.015]             on.exit(options(oopts), add = TRUE)
[13:19:04.015]         }
[13:19:04.015]         {
[13:19:04.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.015]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.015]             })
[13:19:04.015]         }
[13:19:04.015]     }, args = future.call.arguments)
[13:19:04.015] }
[13:19:04.015] Lazy evaluation: FALSE
[13:19:04.015] Asynchronous evaluation: TRUE
[13:19:04.015] Local evaluation: TRUE
[13:19:04.015] Environment: R_GlobalEnv
[13:19:04.015] Capture standard output: TRUE
[13:19:04.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:04.015] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:04.015] Packages: 1 packages (‘future.apply’)
[13:19:04.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:04.015] Resolved: FALSE
[13:19:04.015] Value: <not collected>
[13:19:04.015] Conditions captured: <none>
[13:19:04.015] Early signaling: FALSE
[13:19:04.015] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:04.015] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.027] Chunk #2 of 2 ... DONE
[13:19:04.027] Launching 2 futures (chunks) ... DONE
[13:19:04.027] Resolving 2 futures (chunks) ...
[13:19:04.027] resolve() on list ...
[13:19:04.027]  recursive: 0
[13:19:04.027]  length: 2
[13:19:04.028] 
[13:19:04.028] receiveMessageFromWorker() for ClusterFuture ...
[13:19:04.028] - Validating connection of MultisessionFuture
[13:19:04.028] - received message: FutureResult
[13:19:04.028] - Received FutureResult
[13:19:04.029] - Erased future from FutureRegistry
[13:19:04.029] result() for ClusterFuture ...
[13:19:04.029] - result already collected: FutureResult
[13:19:04.029] result() for ClusterFuture ... done
[13:19:04.029] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:04.029] Future #1
[13:19:04.029] result() for ClusterFuture ...
[13:19:04.029] - result already collected: FutureResult
[13:19:04.029] result() for ClusterFuture ... done
[13:19:04.029] result() for ClusterFuture ...
[13:19:04.029] - result already collected: FutureResult
[13:19:04.030] result() for ClusterFuture ... done
[13:19:04.030] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:04.030] - nx: 2
[13:19:04.030] - relay: TRUE
[13:19:04.030] - stdout: TRUE
[13:19:04.030] - signal: TRUE
[13:19:04.030] - resignal: FALSE
[13:19:04.030] - force: TRUE
[13:19:04.030] - relayed: [n=2] FALSE, FALSE
[13:19:04.030] - queued futures: [n=2] FALSE, FALSE
[13:19:04.030]  - until=1
[13:19:04.031]  - relaying element #1
[13:19:04.031] result() for ClusterFuture ...
[13:19:04.031] - result already collected: FutureResult
[13:19:04.031] result() for ClusterFuture ... done
[13:19:04.031] result() for ClusterFuture ...
[13:19:04.031] - result already collected: FutureResult
[13:19:04.031] result() for ClusterFuture ... done
[13:19:04.031] result() for ClusterFuture ...
[13:19:04.031] - result already collected: FutureResult
[13:19:04.031] result() for ClusterFuture ... done
[13:19:04.031] result() for ClusterFuture ...
[13:19:04.031] - result already collected: FutureResult
[13:19:04.032] result() for ClusterFuture ... done
[13:19:04.032] - relayed: [n=2] TRUE, FALSE
[13:19:04.032] - queued futures: [n=2] TRUE, FALSE
[13:19:04.032] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:04.032]  length: 1 (resolved future 1)
[13:19:04.062] receiveMessageFromWorker() for ClusterFuture ...
[13:19:04.062] - Validating connection of MultisessionFuture
[13:19:04.062] - received message: FutureResult
[13:19:04.062] - Received FutureResult
[13:19:04.063] - Erased future from FutureRegistry
[13:19:04.063] result() for ClusterFuture ...
[13:19:04.063] - result already collected: FutureResult
[13:19:04.063] result() for ClusterFuture ... done
[13:19:04.063] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:04.063] Future #2
[13:19:04.063] result() for ClusterFuture ...
[13:19:04.063] - result already collected: FutureResult
[13:19:04.063] result() for ClusterFuture ... done
[13:19:04.063] result() for ClusterFuture ...
[13:19:04.064] - result already collected: FutureResult
[13:19:04.064] result() for ClusterFuture ... done
[13:19:04.064] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:04.064] - nx: 2
[13:19:04.064] - relay: TRUE
[13:19:04.064] - stdout: TRUE
[13:19:04.064] - signal: TRUE
[13:19:04.064] - resignal: FALSE
[13:19:04.064] - force: TRUE
[13:19:04.064] - relayed: [n=2] TRUE, FALSE
[13:19:04.064] - queued futures: [n=2] TRUE, FALSE
[13:19:04.064]  - until=2
[13:19:04.065]  - relaying element #2
[13:19:04.065] result() for ClusterFuture ...
[13:19:04.065] - result already collected: FutureResult
[13:19:04.065] result() for ClusterFuture ... done
[13:19:04.065] result() for ClusterFuture ...
[13:19:04.065] - result already collected: FutureResult
[13:19:04.065] result() for ClusterFuture ... done
[13:19:04.065] result() for ClusterFuture ...
[13:19:04.065] - result already collected: FutureResult
[13:19:04.065] result() for ClusterFuture ... done
[13:19:04.066] result() for ClusterFuture ...
[13:19:04.066] - result already collected: FutureResult
[13:19:04.066] result() for ClusterFuture ... done
[13:19:04.066] - relayed: [n=2] TRUE, TRUE
[13:19:04.066] - queued futures: [n=2] TRUE, TRUE
[13:19:04.066] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:04.066]  length: 0 (resolved future 2)
[13:19:04.066] Relaying remaining futures
[13:19:04.066] signalConditionsASAP(NULL, pos=0) ...
[13:19:04.066] - nx: 2
[13:19:04.066] - relay: TRUE
[13:19:04.067] - stdout: TRUE
[13:19:04.067] - signal: TRUE
[13:19:04.067] - resignal: FALSE
[13:19:04.067] - force: TRUE
[13:19:04.067] - relayed: [n=2] TRUE, TRUE
[13:19:04.067] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:04.067] - relayed: [n=2] TRUE, TRUE
[13:19:04.067] - queued futures: [n=2] TRUE, TRUE
[13:19:04.067] signalConditionsASAP(NULL, pos=0) ... done
[13:19:04.067] resolve() on list ... DONE
[13:19:04.067] result() for ClusterFuture ...
[13:19:04.068] - result already collected: FutureResult
[13:19:04.068] result() for ClusterFuture ... done
[13:19:04.068] result() for ClusterFuture ...
[13:19:04.068] - result already collected: FutureResult
[13:19:04.068] result() for ClusterFuture ... done
[13:19:04.068] result() for ClusterFuture ...
[13:19:04.068] - result already collected: FutureResult
[13:19:04.068] result() for ClusterFuture ... done
[13:19:04.068] result() for ClusterFuture ...
[13:19:04.068] - result already collected: FutureResult
[13:19:04.068] result() for ClusterFuture ... done
[13:19:04.068]  - Number of value chunks collected: 2
[13:19:04.069] Resolving 2 futures (chunks) ... DONE
[13:19:04.069] Reducing values from 2 chunks ...
[13:19:04.069]  - Number of values collected after concatenation: 10
[13:19:04.069]  - Number of values expected: 10
[13:19:04.069] Reducing values from 2 chunks ... DONE
[13:19:04.069] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:19:04.071] future_lapply() ...
[13:19:04.076] Number of chunks: 2
[13:19:04.076] getGlobalsAndPackagesXApply() ...
[13:19:04.076]  - future.globals: TRUE
[13:19:04.077] getGlobalsAndPackages() ...
[13:19:04.077] Searching for globals...
[13:19:04.081] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:19:04.081] Searching for globals ... DONE
[13:19:04.081] Resolving globals: FALSE
[13:19:04.082] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:19:04.084] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:04.084] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:04.084] - packages: [1] ‘future.apply’
[13:19:04.084] getGlobalsAndPackages() ... DONE
[13:19:04.084]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:04.084]  - needed namespaces: [n=1] ‘future.apply’
[13:19:04.085] Finding globals ... DONE
[13:19:04.085]  - use_args: TRUE
[13:19:04.085]  - Getting '...' globals ...
[13:19:04.085] resolve() on list ...
[13:19:04.085]  recursive: 0
[13:19:04.085]  length: 1
[13:19:04.085]  elements: ‘...’
[13:19:04.085]  length: 0 (resolved future 1)
[13:19:04.086] resolve() on list ... DONE
[13:19:04.086]    - '...' content: [n=0] 
[13:19:04.086] List of 1
[13:19:04.086]  $ ...: list()
[13:19:04.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:04.086]  - attr(*, "where")=List of 1
[13:19:04.086]   ..$ ...:<environment: 0x555f7b6d0b30> 
[13:19:04.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:04.086]  - attr(*, "resolved")= logi TRUE
[13:19:04.086]  - attr(*, "total_size")= num NA
[13:19:04.088]  - Getting '...' globals ... DONE
[13:19:04.088] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:04.088] List of 8
[13:19:04.088]  $ ...future.FUN:function (x, ...)  
[13:19:04.088]  $ x_FUN        :function (x)  
[13:19:04.088]  $ times        : int 4
[13:19:04.088]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:04.088]  $ stop_if_not  :function (...)  
[13:19:04.088]  $ dim          : int [1:2] 2 2
[13:19:04.088]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:04.088]  $ ...          : list()
[13:19:04.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:04.088]  - attr(*, "where")=List of 8
[13:19:04.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:04.088]   ..$ ...          :<environment: 0x555f7b6d0b30> 
[13:19:04.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:04.088]  - attr(*, "resolved")= logi FALSE
[13:19:04.088]  - attr(*, "total_size")= num 105552
[13:19:04.094] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:04.094] getGlobalsAndPackagesXApply() ... DONE
[13:19:04.094] Number of futures (= number of chunks): 2
[13:19:04.094] Launching 2 futures (chunks) ...
[13:19:04.094] Chunk #1 of 2 ...
[13:19:04.094]  - Finding globals in 'X' for chunk #1 ...
[13:19:04.094] getGlobalsAndPackages() ...
[13:19:04.094] Searching for globals...
[13:19:04.095] 
[13:19:04.095] Searching for globals ... DONE
[13:19:04.095] - globals: [0] <none>
[13:19:04.095] getGlobalsAndPackages() ... DONE
[13:19:04.095]    + additional globals found: [n=0] 
[13:19:04.095]    + additional namespaces needed: [n=0] 
[13:19:04.095]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:04.095]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:04.095]  - seeds: <none>
[13:19:04.095] getGlobalsAndPackages() ...
[13:19:04.096] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.096] Resolving globals: FALSE
[13:19:04.096] Tweak future expression to call with '...' arguments ...
[13:19:04.096] {
[13:19:04.096]     do.call(function(...) {
[13:19:04.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.096]             on.exit(options(oopts), add = TRUE)
[13:19:04.096]         }
[13:19:04.096]         {
[13:19:04.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.096]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.096]             })
[13:19:04.096]         }
[13:19:04.096]     }, args = future.call.arguments)
[13:19:04.096] }
[13:19:04.096] Tweak future expression to call with '...' arguments ... DONE
[13:19:04.097] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.097] - packages: [1] ‘future.apply’
[13:19:04.097] getGlobalsAndPackages() ... DONE
[13:19:04.097] run() for ‘Future’ ...
[13:19:04.097] - state: ‘created’
[13:19:04.097] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:04.112] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:04.112]   - Field: ‘node’
[13:19:04.112]   - Field: ‘label’
[13:19:04.112]   - Field: ‘local’
[13:19:04.112]   - Field: ‘owner’
[13:19:04.112]   - Field: ‘envir’
[13:19:04.113]   - Field: ‘workers’
[13:19:04.113]   - Field: ‘packages’
[13:19:04.113]   - Field: ‘gc’
[13:19:04.113]   - Field: ‘conditions’
[13:19:04.113]   - Field: ‘persistent’
[13:19:04.113]   - Field: ‘expr’
[13:19:04.113]   - Field: ‘uuid’
[13:19:04.113]   - Field: ‘seed’
[13:19:04.113]   - Field: ‘version’
[13:19:04.113]   - Field: ‘result’
[13:19:04.113]   - Field: ‘asynchronous’
[13:19:04.114]   - Field: ‘calls’
[13:19:04.114]   - Field: ‘globals’
[13:19:04.114]   - Field: ‘stdout’
[13:19:04.114]   - Field: ‘earlySignal’
[13:19:04.114]   - Field: ‘lazy’
[13:19:04.114]   - Field: ‘state’
[13:19:04.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:04.114] - Launch lazy future ...
[13:19:04.114] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:04.115] Packages needed by future strategies (n = 0): <none>
[13:19:04.115] {
[13:19:04.115]     {
[13:19:04.115]         {
[13:19:04.115]             ...future.startTime <- base::Sys.time()
[13:19:04.115]             {
[13:19:04.115]                 {
[13:19:04.115]                   {
[13:19:04.115]                     {
[13:19:04.115]                       {
[13:19:04.115]                         base::local({
[13:19:04.115]                           has_future <- base::requireNamespace("future", 
[13:19:04.115]                             quietly = TRUE)
[13:19:04.115]                           if (has_future) {
[13:19:04.115]                             ns <- base::getNamespace("future")
[13:19:04.115]                             version <- ns[[".package"]][["version"]]
[13:19:04.115]                             if (is.null(version)) 
[13:19:04.115]                               version <- utils::packageVersion("future")
[13:19:04.115]                           }
[13:19:04.115]                           else {
[13:19:04.115]                             version <- NULL
[13:19:04.115]                           }
[13:19:04.115]                           if (!has_future || version < "1.8.0") {
[13:19:04.115]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:04.115]                               "", base::R.version$version.string), 
[13:19:04.115]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:04.115]                                 base::R.version$platform, 8 * 
[13:19:04.115]                                   base::.Machine$sizeof.pointer), 
[13:19:04.115]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:04.115]                                 "release", "version")], collapse = " "), 
[13:19:04.115]                               hostname = base::Sys.info()[["nodename"]])
[13:19:04.115]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:04.115]                               info)
[13:19:04.115]                             info <- base::paste(info, collapse = "; ")
[13:19:04.115]                             if (!has_future) {
[13:19:04.115]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:04.115]                                 info)
[13:19:04.115]                             }
[13:19:04.115]                             else {
[13:19:04.115]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:04.115]                                 info, version)
[13:19:04.115]                             }
[13:19:04.115]                             base::stop(msg)
[13:19:04.115]                           }
[13:19:04.115]                         })
[13:19:04.115]                       }
[13:19:04.115]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:04.115]                       base::options(mc.cores = 1L)
[13:19:04.115]                     }
[13:19:04.115]                     base::local({
[13:19:04.115]                       for (pkg in "future.apply") {
[13:19:04.115]                         base::loadNamespace(pkg)
[13:19:04.115]                         base::library(pkg, character.only = TRUE)
[13:19:04.115]                       }
[13:19:04.115]                     })
[13:19:04.115]                   }
[13:19:04.115]                   options(future.plan = NULL)
[13:19:04.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:04.115]                 }
[13:19:04.115]                 ...future.workdir <- getwd()
[13:19:04.115]             }
[13:19:04.115]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:04.115]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:04.115]         }
[13:19:04.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:04.115]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:04.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:04.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:04.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:04.115]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:04.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:04.115]             base::names(...future.oldOptions))
[13:19:04.115]     }
[13:19:04.115]     if (FALSE) {
[13:19:04.115]     }
[13:19:04.115]     else {
[13:19:04.115]         if (TRUE) {
[13:19:04.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:04.115]                 open = "w")
[13:19:04.115]         }
[13:19:04.115]         else {
[13:19:04.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:04.115]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:04.115]         }
[13:19:04.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:04.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:04.115]             base::sink(type = "output", split = FALSE)
[13:19:04.115]             base::close(...future.stdout)
[13:19:04.115]         }, add = TRUE)
[13:19:04.115]     }
[13:19:04.115]     ...future.frame <- base::sys.nframe()
[13:19:04.115]     ...future.conditions <- base::list()
[13:19:04.115]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:04.115]     if (FALSE) {
[13:19:04.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:04.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:04.115]     }
[13:19:04.115]     ...future.result <- base::tryCatch({
[13:19:04.115]         base::withCallingHandlers({
[13:19:04.115]             ...future.value <- base::withVisible(base::local({
[13:19:04.115]                 ...future.makeSendCondition <- local({
[13:19:04.115]                   sendCondition <- NULL
[13:19:04.115]                   function(frame = 1L) {
[13:19:04.115]                     if (is.function(sendCondition)) 
[13:19:04.115]                       return(sendCondition)
[13:19:04.115]                     ns <- getNamespace("parallel")
[13:19:04.115]                     if (exists("sendData", mode = "function", 
[13:19:04.115]                       envir = ns)) {
[13:19:04.115]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:04.115]                         envir = ns)
[13:19:04.115]                       envir <- sys.frame(frame)
[13:19:04.115]                       master <- NULL
[13:19:04.115]                       while (!identical(envir, .GlobalEnv) && 
[13:19:04.115]                         !identical(envir, emptyenv())) {
[13:19:04.115]                         if (exists("master", mode = "list", envir = envir, 
[13:19:04.115]                           inherits = FALSE)) {
[13:19:04.115]                           master <- get("master", mode = "list", 
[13:19:04.115]                             envir = envir, inherits = FALSE)
[13:19:04.115]                           if (inherits(master, c("SOCKnode", 
[13:19:04.115]                             "SOCK0node"))) {
[13:19:04.115]                             sendCondition <<- function(cond) {
[13:19:04.115]                               data <- list(type = "VALUE", value = cond, 
[13:19:04.115]                                 success = TRUE)
[13:19:04.115]                               parallel_sendData(master, data)
[13:19:04.115]                             }
[13:19:04.115]                             return(sendCondition)
[13:19:04.115]                           }
[13:19:04.115]                         }
[13:19:04.115]                         frame <- frame + 1L
[13:19:04.115]                         envir <- sys.frame(frame)
[13:19:04.115]                       }
[13:19:04.115]                     }
[13:19:04.115]                     sendCondition <<- function(cond) NULL
[13:19:04.115]                   }
[13:19:04.115]                 })
[13:19:04.115]                 withCallingHandlers({
[13:19:04.115]                   {
[13:19:04.115]                     do.call(function(...) {
[13:19:04.115]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.115]                       if (!identical(...future.globals.maxSize.org, 
[13:19:04.115]                         ...future.globals.maxSize)) {
[13:19:04.115]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.115]                         on.exit(options(oopts), add = TRUE)
[13:19:04.115]                       }
[13:19:04.115]                       {
[13:19:04.115]                         lapply(seq_along(...future.elements_ii), 
[13:19:04.115]                           FUN = function(jj) {
[13:19:04.115]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.115]                             ...future.FUN(...future.X_jj, ...)
[13:19:04.115]                           })
[13:19:04.115]                       }
[13:19:04.115]                     }, args = future.call.arguments)
[13:19:04.115]                   }
[13:19:04.115]                 }, immediateCondition = function(cond) {
[13:19:04.115]                   sendCondition <- ...future.makeSendCondition()
[13:19:04.115]                   sendCondition(cond)
[13:19:04.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.115]                   {
[13:19:04.115]                     inherits <- base::inherits
[13:19:04.115]                     invokeRestart <- base::invokeRestart
[13:19:04.115]                     is.null <- base::is.null
[13:19:04.115]                     muffled <- FALSE
[13:19:04.115]                     if (inherits(cond, "message")) {
[13:19:04.115]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:04.115]                       if (muffled) 
[13:19:04.115]                         invokeRestart("muffleMessage")
[13:19:04.115]                     }
[13:19:04.115]                     else if (inherits(cond, "warning")) {
[13:19:04.115]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:04.115]                       if (muffled) 
[13:19:04.115]                         invokeRestart("muffleWarning")
[13:19:04.115]                     }
[13:19:04.115]                     else if (inherits(cond, "condition")) {
[13:19:04.115]                       if (!is.null(pattern)) {
[13:19:04.115]                         computeRestarts <- base::computeRestarts
[13:19:04.115]                         grepl <- base::grepl
[13:19:04.115]                         restarts <- computeRestarts(cond)
[13:19:04.115]                         for (restart in restarts) {
[13:19:04.115]                           name <- restart$name
[13:19:04.115]                           if (is.null(name)) 
[13:19:04.115]                             next
[13:19:04.115]                           if (!grepl(pattern, name)) 
[13:19:04.115]                             next
[13:19:04.115]                           invokeRestart(restart)
[13:19:04.115]                           muffled <- TRUE
[13:19:04.115]                           break
[13:19:04.115]                         }
[13:19:04.115]                       }
[13:19:04.115]                     }
[13:19:04.115]                     invisible(muffled)
[13:19:04.115]                   }
[13:19:04.115]                   muffleCondition(cond)
[13:19:04.115]                 })
[13:19:04.115]             }))
[13:19:04.115]             future::FutureResult(value = ...future.value$value, 
[13:19:04.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.115]                   ...future.rng), globalenv = if (FALSE) 
[13:19:04.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:04.115]                     ...future.globalenv.names))
[13:19:04.115]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:04.115]         }, condition = base::local({
[13:19:04.115]             c <- base::c
[13:19:04.115]             inherits <- base::inherits
[13:19:04.115]             invokeRestart <- base::invokeRestart
[13:19:04.115]             length <- base::length
[13:19:04.115]             list <- base::list
[13:19:04.115]             seq.int <- base::seq.int
[13:19:04.115]             signalCondition <- base::signalCondition
[13:19:04.115]             sys.calls <- base::sys.calls
[13:19:04.115]             `[[` <- base::`[[`
[13:19:04.115]             `+` <- base::`+`
[13:19:04.115]             `<<-` <- base::`<<-`
[13:19:04.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:04.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:04.115]                   3L)]
[13:19:04.115]             }
[13:19:04.115]             function(cond) {
[13:19:04.115]                 is_error <- inherits(cond, "error")
[13:19:04.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:04.115]                   NULL)
[13:19:04.115]                 if (is_error) {
[13:19:04.115]                   sessionInformation <- function() {
[13:19:04.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:04.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:04.115]                       search = base::search(), system = base::Sys.info())
[13:19:04.115]                   }
[13:19:04.115]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:04.115]                     cond$call), session = sessionInformation(), 
[13:19:04.115]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:04.115]                   signalCondition(cond)
[13:19:04.115]                 }
[13:19:04.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:04.115]                 "immediateCondition"))) {
[13:19:04.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:04.115]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:04.115]                   if (TRUE && !signal) {
[13:19:04.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.115]                     {
[13:19:04.115]                       inherits <- base::inherits
[13:19:04.115]                       invokeRestart <- base::invokeRestart
[13:19:04.115]                       is.null <- base::is.null
[13:19:04.115]                       muffled <- FALSE
[13:19:04.115]                       if (inherits(cond, "message")) {
[13:19:04.115]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.115]                         if (muffled) 
[13:19:04.115]                           invokeRestart("muffleMessage")
[13:19:04.115]                       }
[13:19:04.115]                       else if (inherits(cond, "warning")) {
[13:19:04.115]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.115]                         if (muffled) 
[13:19:04.115]                           invokeRestart("muffleWarning")
[13:19:04.115]                       }
[13:19:04.115]                       else if (inherits(cond, "condition")) {
[13:19:04.115]                         if (!is.null(pattern)) {
[13:19:04.115]                           computeRestarts <- base::computeRestarts
[13:19:04.115]                           grepl <- base::grepl
[13:19:04.115]                           restarts <- computeRestarts(cond)
[13:19:04.115]                           for (restart in restarts) {
[13:19:04.115]                             name <- restart$name
[13:19:04.115]                             if (is.null(name)) 
[13:19:04.115]                               next
[13:19:04.115]                             if (!grepl(pattern, name)) 
[13:19:04.115]                               next
[13:19:04.115]                             invokeRestart(restart)
[13:19:04.115]                             muffled <- TRUE
[13:19:04.115]                             break
[13:19:04.115]                           }
[13:19:04.115]                         }
[13:19:04.115]                       }
[13:19:04.115]                       invisible(muffled)
[13:19:04.115]                     }
[13:19:04.115]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.115]                   }
[13:19:04.115]                 }
[13:19:04.115]                 else {
[13:19:04.115]                   if (TRUE) {
[13:19:04.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.115]                     {
[13:19:04.115]                       inherits <- base::inherits
[13:19:04.115]                       invokeRestart <- base::invokeRestart
[13:19:04.115]                       is.null <- base::is.null
[13:19:04.115]                       muffled <- FALSE
[13:19:04.115]                       if (inherits(cond, "message")) {
[13:19:04.115]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.115]                         if (muffled) 
[13:19:04.115]                           invokeRestart("muffleMessage")
[13:19:04.115]                       }
[13:19:04.115]                       else if (inherits(cond, "warning")) {
[13:19:04.115]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.115]                         if (muffled) 
[13:19:04.115]                           invokeRestart("muffleWarning")
[13:19:04.115]                       }
[13:19:04.115]                       else if (inherits(cond, "condition")) {
[13:19:04.115]                         if (!is.null(pattern)) {
[13:19:04.115]                           computeRestarts <- base::computeRestarts
[13:19:04.115]                           grepl <- base::grepl
[13:19:04.115]                           restarts <- computeRestarts(cond)
[13:19:04.115]                           for (restart in restarts) {
[13:19:04.115]                             name <- restart$name
[13:19:04.115]                             if (is.null(name)) 
[13:19:04.115]                               next
[13:19:04.115]                             if (!grepl(pattern, name)) 
[13:19:04.115]                               next
[13:19:04.115]                             invokeRestart(restart)
[13:19:04.115]                             muffled <- TRUE
[13:19:04.115]                             break
[13:19:04.115]                           }
[13:19:04.115]                         }
[13:19:04.115]                       }
[13:19:04.115]                       invisible(muffled)
[13:19:04.115]                     }
[13:19:04.115]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.115]                   }
[13:19:04.115]                 }
[13:19:04.115]             }
[13:19:04.115]         }))
[13:19:04.115]     }, error = function(ex) {
[13:19:04.115]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:04.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.115]                 ...future.rng), started = ...future.startTime, 
[13:19:04.115]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:04.115]             version = "1.8"), class = "FutureResult")
[13:19:04.115]     }, finally = {
[13:19:04.115]         if (!identical(...future.workdir, getwd())) 
[13:19:04.115]             setwd(...future.workdir)
[13:19:04.115]         {
[13:19:04.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:04.115]                 ...future.oldOptions$nwarnings <- NULL
[13:19:04.115]             }
[13:19:04.115]             base::options(...future.oldOptions)
[13:19:04.115]             if (.Platform$OS.type == "windows") {
[13:19:04.115]                 old_names <- names(...future.oldEnvVars)
[13:19:04.115]                 envs <- base::Sys.getenv()
[13:19:04.115]                 names <- names(envs)
[13:19:04.115]                 common <- intersect(names, old_names)
[13:19:04.115]                 added <- setdiff(names, old_names)
[13:19:04.115]                 removed <- setdiff(old_names, names)
[13:19:04.115]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:04.115]                   envs[common]]
[13:19:04.115]                 NAMES <- toupper(changed)
[13:19:04.115]                 args <- list()
[13:19:04.115]                 for (kk in seq_along(NAMES)) {
[13:19:04.115]                   name <- changed[[kk]]
[13:19:04.115]                   NAME <- NAMES[[kk]]
[13:19:04.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.115]                     next
[13:19:04.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.115]                 }
[13:19:04.115]                 NAMES <- toupper(added)
[13:19:04.115]                 for (kk in seq_along(NAMES)) {
[13:19:04.115]                   name <- added[[kk]]
[13:19:04.115]                   NAME <- NAMES[[kk]]
[13:19:04.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.115]                     next
[13:19:04.115]                   args[[name]] <- ""
[13:19:04.115]                 }
[13:19:04.115]                 NAMES <- toupper(removed)
[13:19:04.115]                 for (kk in seq_along(NAMES)) {
[13:19:04.115]                   name <- removed[[kk]]
[13:19:04.115]                   NAME <- NAMES[[kk]]
[13:19:04.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.115]                     next
[13:19:04.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.115]                 }
[13:19:04.115]                 if (length(args) > 0) 
[13:19:04.115]                   base::do.call(base::Sys.setenv, args = args)
[13:19:04.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:04.115]             }
[13:19:04.115]             else {
[13:19:04.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:04.115]             }
[13:19:04.115]             {
[13:19:04.115]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:04.115]                   0L) {
[13:19:04.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:04.115]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:04.115]                   base::options(opts)
[13:19:04.115]                 }
[13:19:04.115]                 {
[13:19:04.115]                   {
[13:19:04.115]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:04.115]                     NULL
[13:19:04.115]                   }
[13:19:04.115]                   options(future.plan = NULL)
[13:19:04.115]                   if (is.na(NA_character_)) 
[13:19:04.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:04.115]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:04.115]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:04.115]                     envir = parent.frame()) 
[13:19:04.115]                   {
[13:19:04.115]                     if (is.function(workers)) 
[13:19:04.115]                       workers <- workers()
[13:19:04.115]                     workers <- structure(as.integer(workers), 
[13:19:04.115]                       class = class(workers))
[13:19:04.115]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:04.115]                       workers >= 1)
[13:19:04.115]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:04.115]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:04.115]                     }
[13:19:04.115]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:04.115]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:04.115]                       envir = envir)
[13:19:04.115]                     if (!future$lazy) 
[13:19:04.115]                       future <- run(future)
[13:19:04.115]                     invisible(future)
[13:19:04.115]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:04.115]                 }
[13:19:04.115]             }
[13:19:04.115]         }
[13:19:04.115]     })
[13:19:04.115]     if (TRUE) {
[13:19:04.115]         base::sink(type = "output", split = FALSE)
[13:19:04.115]         if (TRUE) {
[13:19:04.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:04.115]         }
[13:19:04.115]         else {
[13:19:04.115]             ...future.result["stdout"] <- base::list(NULL)
[13:19:04.115]         }
[13:19:04.115]         base::close(...future.stdout)
[13:19:04.115]         ...future.stdout <- NULL
[13:19:04.115]     }
[13:19:04.115]     ...future.result$conditions <- ...future.conditions
[13:19:04.115]     ...future.result$finished <- base::Sys.time()
[13:19:04.115]     ...future.result
[13:19:04.115] }
[13:19:04.118] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[13:19:04.118] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:04.161] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:04.161] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[13:19:04.162] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[13:19:04.162] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:04.162] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:04.162] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:04.205] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:04.205] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:04.249] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:04.249] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:19:04.250] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:19:04.250] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:04.250] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:04.250] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:04.251] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.251] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:19:04.251] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:19:04.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:04.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.252] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:04.252] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.253] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[13:19:04.253] MultisessionFuture started
[13:19:04.253] - Launch lazy future ... done
[13:19:04.254] run() for ‘MultisessionFuture’ ... done
[13:19:04.254] Created future:
[13:19:04.254] MultisessionFuture:
[13:19:04.254] Label: ‘future_vapply-1’
[13:19:04.254] Expression:
[13:19:04.254] {
[13:19:04.254]     do.call(function(...) {
[13:19:04.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.254]             on.exit(options(oopts), add = TRUE)
[13:19:04.254]         }
[13:19:04.254]         {
[13:19:04.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.254]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.254]             })
[13:19:04.254]         }
[13:19:04.254]     }, args = future.call.arguments)
[13:19:04.254] }
[13:19:04.254] Lazy evaluation: FALSE
[13:19:04.254] Asynchronous evaluation: TRUE
[13:19:04.254] Local evaluation: TRUE
[13:19:04.254] Environment: R_GlobalEnv
[13:19:04.254] Capture standard output: TRUE
[13:19:04.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:04.254] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:04.254] Packages: 1 packages (‘future.apply’)
[13:19:04.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:04.254] Resolved: FALSE
[13:19:04.254] Value: <not collected>
[13:19:04.254] Conditions captured: <none>
[13:19:04.254] Early signaling: FALSE
[13:19:04.254] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:04.254] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.266] Chunk #1 of 2 ... DONE
[13:19:04.266] Chunk #2 of 2 ...
[13:19:04.266]  - Finding globals in 'X' for chunk #2 ...
[13:19:04.266] getGlobalsAndPackages() ...
[13:19:04.266] Searching for globals...
[13:19:04.266] 
[13:19:04.266] Searching for globals ... DONE
[13:19:04.266] - globals: [0] <none>
[13:19:04.267] getGlobalsAndPackages() ... DONE
[13:19:04.267]    + additional globals found: [n=0] 
[13:19:04.267]    + additional namespaces needed: [n=0] 
[13:19:04.267]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:04.267]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:04.267]  - seeds: <none>
[13:19:04.267] getGlobalsAndPackages() ...
[13:19:04.267] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.267] Resolving globals: FALSE
[13:19:04.267] Tweak future expression to call with '...' arguments ...
[13:19:04.268] {
[13:19:04.268]     do.call(function(...) {
[13:19:04.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.268]             on.exit(options(oopts), add = TRUE)
[13:19:04.268]         }
[13:19:04.268]         {
[13:19:04.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.268]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.268]             })
[13:19:04.268]         }
[13:19:04.268]     }, args = future.call.arguments)
[13:19:04.268] }
[13:19:04.268] Tweak future expression to call with '...' arguments ... DONE
[13:19:04.268] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.268] - packages: [1] ‘future.apply’
[13:19:04.269] getGlobalsAndPackages() ... DONE
[13:19:04.269] run() for ‘Future’ ...
[13:19:04.269] - state: ‘created’
[13:19:04.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:04.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:04.284]   - Field: ‘node’
[13:19:04.284]   - Field: ‘label’
[13:19:04.284]   - Field: ‘local’
[13:19:04.284]   - Field: ‘owner’
[13:19:04.284]   - Field: ‘envir’
[13:19:04.284]   - Field: ‘workers’
[13:19:04.284]   - Field: ‘packages’
[13:19:04.285]   - Field: ‘gc’
[13:19:04.285]   - Field: ‘conditions’
[13:19:04.285]   - Field: ‘persistent’
[13:19:04.285]   - Field: ‘expr’
[13:19:04.285]   - Field: ‘uuid’
[13:19:04.285]   - Field: ‘seed’
[13:19:04.285]   - Field: ‘version’
[13:19:04.285]   - Field: ‘result’
[13:19:04.285]   - Field: ‘asynchronous’
[13:19:04.285]   - Field: ‘calls’
[13:19:04.285]   - Field: ‘globals’
[13:19:04.286]   - Field: ‘stdout’
[13:19:04.286]   - Field: ‘earlySignal’
[13:19:04.286]   - Field: ‘lazy’
[13:19:04.286]   - Field: ‘state’
[13:19:04.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:04.286] - Launch lazy future ...
[13:19:04.286] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:04.286] Packages needed by future strategies (n = 0): <none>
[13:19:04.287] {
[13:19:04.287]     {
[13:19:04.287]         {
[13:19:04.287]             ...future.startTime <- base::Sys.time()
[13:19:04.287]             {
[13:19:04.287]                 {
[13:19:04.287]                   {
[13:19:04.287]                     {
[13:19:04.287]                       {
[13:19:04.287]                         base::local({
[13:19:04.287]                           has_future <- base::requireNamespace("future", 
[13:19:04.287]                             quietly = TRUE)
[13:19:04.287]                           if (has_future) {
[13:19:04.287]                             ns <- base::getNamespace("future")
[13:19:04.287]                             version <- ns[[".package"]][["version"]]
[13:19:04.287]                             if (is.null(version)) 
[13:19:04.287]                               version <- utils::packageVersion("future")
[13:19:04.287]                           }
[13:19:04.287]                           else {
[13:19:04.287]                             version <- NULL
[13:19:04.287]                           }
[13:19:04.287]                           if (!has_future || version < "1.8.0") {
[13:19:04.287]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:04.287]                               "", base::R.version$version.string), 
[13:19:04.287]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:04.287]                                 base::R.version$platform, 8 * 
[13:19:04.287]                                   base::.Machine$sizeof.pointer), 
[13:19:04.287]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:04.287]                                 "release", "version")], collapse = " "), 
[13:19:04.287]                               hostname = base::Sys.info()[["nodename"]])
[13:19:04.287]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:04.287]                               info)
[13:19:04.287]                             info <- base::paste(info, collapse = "; ")
[13:19:04.287]                             if (!has_future) {
[13:19:04.287]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:04.287]                                 info)
[13:19:04.287]                             }
[13:19:04.287]                             else {
[13:19:04.287]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:04.287]                                 info, version)
[13:19:04.287]                             }
[13:19:04.287]                             base::stop(msg)
[13:19:04.287]                           }
[13:19:04.287]                         })
[13:19:04.287]                       }
[13:19:04.287]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:04.287]                       base::options(mc.cores = 1L)
[13:19:04.287]                     }
[13:19:04.287]                     base::local({
[13:19:04.287]                       for (pkg in "future.apply") {
[13:19:04.287]                         base::loadNamespace(pkg)
[13:19:04.287]                         base::library(pkg, character.only = TRUE)
[13:19:04.287]                       }
[13:19:04.287]                     })
[13:19:04.287]                   }
[13:19:04.287]                   options(future.plan = NULL)
[13:19:04.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:04.287]                 }
[13:19:04.287]                 ...future.workdir <- getwd()
[13:19:04.287]             }
[13:19:04.287]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:04.287]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:04.287]         }
[13:19:04.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:04.287]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:04.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:04.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:04.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:04.287]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:04.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:04.287]             base::names(...future.oldOptions))
[13:19:04.287]     }
[13:19:04.287]     if (FALSE) {
[13:19:04.287]     }
[13:19:04.287]     else {
[13:19:04.287]         if (TRUE) {
[13:19:04.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:04.287]                 open = "w")
[13:19:04.287]         }
[13:19:04.287]         else {
[13:19:04.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:04.287]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:04.287]         }
[13:19:04.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:04.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:04.287]             base::sink(type = "output", split = FALSE)
[13:19:04.287]             base::close(...future.stdout)
[13:19:04.287]         }, add = TRUE)
[13:19:04.287]     }
[13:19:04.287]     ...future.frame <- base::sys.nframe()
[13:19:04.287]     ...future.conditions <- base::list()
[13:19:04.287]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:04.287]     if (FALSE) {
[13:19:04.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:04.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:04.287]     }
[13:19:04.287]     ...future.result <- base::tryCatch({
[13:19:04.287]         base::withCallingHandlers({
[13:19:04.287]             ...future.value <- base::withVisible(base::local({
[13:19:04.287]                 ...future.makeSendCondition <- local({
[13:19:04.287]                   sendCondition <- NULL
[13:19:04.287]                   function(frame = 1L) {
[13:19:04.287]                     if (is.function(sendCondition)) 
[13:19:04.287]                       return(sendCondition)
[13:19:04.287]                     ns <- getNamespace("parallel")
[13:19:04.287]                     if (exists("sendData", mode = "function", 
[13:19:04.287]                       envir = ns)) {
[13:19:04.287]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:04.287]                         envir = ns)
[13:19:04.287]                       envir <- sys.frame(frame)
[13:19:04.287]                       master <- NULL
[13:19:04.287]                       while (!identical(envir, .GlobalEnv) && 
[13:19:04.287]                         !identical(envir, emptyenv())) {
[13:19:04.287]                         if (exists("master", mode = "list", envir = envir, 
[13:19:04.287]                           inherits = FALSE)) {
[13:19:04.287]                           master <- get("master", mode = "list", 
[13:19:04.287]                             envir = envir, inherits = FALSE)
[13:19:04.287]                           if (inherits(master, c("SOCKnode", 
[13:19:04.287]                             "SOCK0node"))) {
[13:19:04.287]                             sendCondition <<- function(cond) {
[13:19:04.287]                               data <- list(type = "VALUE", value = cond, 
[13:19:04.287]                                 success = TRUE)
[13:19:04.287]                               parallel_sendData(master, data)
[13:19:04.287]                             }
[13:19:04.287]                             return(sendCondition)
[13:19:04.287]                           }
[13:19:04.287]                         }
[13:19:04.287]                         frame <- frame + 1L
[13:19:04.287]                         envir <- sys.frame(frame)
[13:19:04.287]                       }
[13:19:04.287]                     }
[13:19:04.287]                     sendCondition <<- function(cond) NULL
[13:19:04.287]                   }
[13:19:04.287]                 })
[13:19:04.287]                 withCallingHandlers({
[13:19:04.287]                   {
[13:19:04.287]                     do.call(function(...) {
[13:19:04.287]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.287]                       if (!identical(...future.globals.maxSize.org, 
[13:19:04.287]                         ...future.globals.maxSize)) {
[13:19:04.287]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.287]                         on.exit(options(oopts), add = TRUE)
[13:19:04.287]                       }
[13:19:04.287]                       {
[13:19:04.287]                         lapply(seq_along(...future.elements_ii), 
[13:19:04.287]                           FUN = function(jj) {
[13:19:04.287]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.287]                             ...future.FUN(...future.X_jj, ...)
[13:19:04.287]                           })
[13:19:04.287]                       }
[13:19:04.287]                     }, args = future.call.arguments)
[13:19:04.287]                   }
[13:19:04.287]                 }, immediateCondition = function(cond) {
[13:19:04.287]                   sendCondition <- ...future.makeSendCondition()
[13:19:04.287]                   sendCondition(cond)
[13:19:04.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.287]                   {
[13:19:04.287]                     inherits <- base::inherits
[13:19:04.287]                     invokeRestart <- base::invokeRestart
[13:19:04.287]                     is.null <- base::is.null
[13:19:04.287]                     muffled <- FALSE
[13:19:04.287]                     if (inherits(cond, "message")) {
[13:19:04.287]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:04.287]                       if (muffled) 
[13:19:04.287]                         invokeRestart("muffleMessage")
[13:19:04.287]                     }
[13:19:04.287]                     else if (inherits(cond, "warning")) {
[13:19:04.287]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:04.287]                       if (muffled) 
[13:19:04.287]                         invokeRestart("muffleWarning")
[13:19:04.287]                     }
[13:19:04.287]                     else if (inherits(cond, "condition")) {
[13:19:04.287]                       if (!is.null(pattern)) {
[13:19:04.287]                         computeRestarts <- base::computeRestarts
[13:19:04.287]                         grepl <- base::grepl
[13:19:04.287]                         restarts <- computeRestarts(cond)
[13:19:04.287]                         for (restart in restarts) {
[13:19:04.287]                           name <- restart$name
[13:19:04.287]                           if (is.null(name)) 
[13:19:04.287]                             next
[13:19:04.287]                           if (!grepl(pattern, name)) 
[13:19:04.287]                             next
[13:19:04.287]                           invokeRestart(restart)
[13:19:04.287]                           muffled <- TRUE
[13:19:04.287]                           break
[13:19:04.287]                         }
[13:19:04.287]                       }
[13:19:04.287]                     }
[13:19:04.287]                     invisible(muffled)
[13:19:04.287]                   }
[13:19:04.287]                   muffleCondition(cond)
[13:19:04.287]                 })
[13:19:04.287]             }))
[13:19:04.287]             future::FutureResult(value = ...future.value$value, 
[13:19:04.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.287]                   ...future.rng), globalenv = if (FALSE) 
[13:19:04.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:04.287]                     ...future.globalenv.names))
[13:19:04.287]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:04.287]         }, condition = base::local({
[13:19:04.287]             c <- base::c
[13:19:04.287]             inherits <- base::inherits
[13:19:04.287]             invokeRestart <- base::invokeRestart
[13:19:04.287]             length <- base::length
[13:19:04.287]             list <- base::list
[13:19:04.287]             seq.int <- base::seq.int
[13:19:04.287]             signalCondition <- base::signalCondition
[13:19:04.287]             sys.calls <- base::sys.calls
[13:19:04.287]             `[[` <- base::`[[`
[13:19:04.287]             `+` <- base::`+`
[13:19:04.287]             `<<-` <- base::`<<-`
[13:19:04.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:04.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:04.287]                   3L)]
[13:19:04.287]             }
[13:19:04.287]             function(cond) {
[13:19:04.287]                 is_error <- inherits(cond, "error")
[13:19:04.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:04.287]                   NULL)
[13:19:04.287]                 if (is_error) {
[13:19:04.287]                   sessionInformation <- function() {
[13:19:04.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:04.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:04.287]                       search = base::search(), system = base::Sys.info())
[13:19:04.287]                   }
[13:19:04.287]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:04.287]                     cond$call), session = sessionInformation(), 
[13:19:04.287]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:04.287]                   signalCondition(cond)
[13:19:04.287]                 }
[13:19:04.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:04.287]                 "immediateCondition"))) {
[13:19:04.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:04.287]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:04.287]                   if (TRUE && !signal) {
[13:19:04.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.287]                     {
[13:19:04.287]                       inherits <- base::inherits
[13:19:04.287]                       invokeRestart <- base::invokeRestart
[13:19:04.287]                       is.null <- base::is.null
[13:19:04.287]                       muffled <- FALSE
[13:19:04.287]                       if (inherits(cond, "message")) {
[13:19:04.287]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.287]                         if (muffled) 
[13:19:04.287]                           invokeRestart("muffleMessage")
[13:19:04.287]                       }
[13:19:04.287]                       else if (inherits(cond, "warning")) {
[13:19:04.287]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.287]                         if (muffled) 
[13:19:04.287]                           invokeRestart("muffleWarning")
[13:19:04.287]                       }
[13:19:04.287]                       else if (inherits(cond, "condition")) {
[13:19:04.287]                         if (!is.null(pattern)) {
[13:19:04.287]                           computeRestarts <- base::computeRestarts
[13:19:04.287]                           grepl <- base::grepl
[13:19:04.287]                           restarts <- computeRestarts(cond)
[13:19:04.287]                           for (restart in restarts) {
[13:19:04.287]                             name <- restart$name
[13:19:04.287]                             if (is.null(name)) 
[13:19:04.287]                               next
[13:19:04.287]                             if (!grepl(pattern, name)) 
[13:19:04.287]                               next
[13:19:04.287]                             invokeRestart(restart)
[13:19:04.287]                             muffled <- TRUE
[13:19:04.287]                             break
[13:19:04.287]                           }
[13:19:04.287]                         }
[13:19:04.287]                       }
[13:19:04.287]                       invisible(muffled)
[13:19:04.287]                     }
[13:19:04.287]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.287]                   }
[13:19:04.287]                 }
[13:19:04.287]                 else {
[13:19:04.287]                   if (TRUE) {
[13:19:04.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.287]                     {
[13:19:04.287]                       inherits <- base::inherits
[13:19:04.287]                       invokeRestart <- base::invokeRestart
[13:19:04.287]                       is.null <- base::is.null
[13:19:04.287]                       muffled <- FALSE
[13:19:04.287]                       if (inherits(cond, "message")) {
[13:19:04.287]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.287]                         if (muffled) 
[13:19:04.287]                           invokeRestart("muffleMessage")
[13:19:04.287]                       }
[13:19:04.287]                       else if (inherits(cond, "warning")) {
[13:19:04.287]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.287]                         if (muffled) 
[13:19:04.287]                           invokeRestart("muffleWarning")
[13:19:04.287]                       }
[13:19:04.287]                       else if (inherits(cond, "condition")) {
[13:19:04.287]                         if (!is.null(pattern)) {
[13:19:04.287]                           computeRestarts <- base::computeRestarts
[13:19:04.287]                           grepl <- base::grepl
[13:19:04.287]                           restarts <- computeRestarts(cond)
[13:19:04.287]                           for (restart in restarts) {
[13:19:04.287]                             name <- restart$name
[13:19:04.287]                             if (is.null(name)) 
[13:19:04.287]                               next
[13:19:04.287]                             if (!grepl(pattern, name)) 
[13:19:04.287]                               next
[13:19:04.287]                             invokeRestart(restart)
[13:19:04.287]                             muffled <- TRUE
[13:19:04.287]                             break
[13:19:04.287]                           }
[13:19:04.287]                         }
[13:19:04.287]                       }
[13:19:04.287]                       invisible(muffled)
[13:19:04.287]                     }
[13:19:04.287]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.287]                   }
[13:19:04.287]                 }
[13:19:04.287]             }
[13:19:04.287]         }))
[13:19:04.287]     }, error = function(ex) {
[13:19:04.287]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:04.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.287]                 ...future.rng), started = ...future.startTime, 
[13:19:04.287]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:04.287]             version = "1.8"), class = "FutureResult")
[13:19:04.287]     }, finally = {
[13:19:04.287]         if (!identical(...future.workdir, getwd())) 
[13:19:04.287]             setwd(...future.workdir)
[13:19:04.287]         {
[13:19:04.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:04.287]                 ...future.oldOptions$nwarnings <- NULL
[13:19:04.287]             }
[13:19:04.287]             base::options(...future.oldOptions)
[13:19:04.287]             if (.Platform$OS.type == "windows") {
[13:19:04.287]                 old_names <- names(...future.oldEnvVars)
[13:19:04.287]                 envs <- base::Sys.getenv()
[13:19:04.287]                 names <- names(envs)
[13:19:04.287]                 common <- intersect(names, old_names)
[13:19:04.287]                 added <- setdiff(names, old_names)
[13:19:04.287]                 removed <- setdiff(old_names, names)
[13:19:04.287]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:04.287]                   envs[common]]
[13:19:04.287]                 NAMES <- toupper(changed)
[13:19:04.287]                 args <- list()
[13:19:04.287]                 for (kk in seq_along(NAMES)) {
[13:19:04.287]                   name <- changed[[kk]]
[13:19:04.287]                   NAME <- NAMES[[kk]]
[13:19:04.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.287]                     next
[13:19:04.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.287]                 }
[13:19:04.287]                 NAMES <- toupper(added)
[13:19:04.287]                 for (kk in seq_along(NAMES)) {
[13:19:04.287]                   name <- added[[kk]]
[13:19:04.287]                   NAME <- NAMES[[kk]]
[13:19:04.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.287]                     next
[13:19:04.287]                   args[[name]] <- ""
[13:19:04.287]                 }
[13:19:04.287]                 NAMES <- toupper(removed)
[13:19:04.287]                 for (kk in seq_along(NAMES)) {
[13:19:04.287]                   name <- removed[[kk]]
[13:19:04.287]                   NAME <- NAMES[[kk]]
[13:19:04.287]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.287]                     next
[13:19:04.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.287]                 }
[13:19:04.287]                 if (length(args) > 0) 
[13:19:04.287]                   base::do.call(base::Sys.setenv, args = args)
[13:19:04.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:04.287]             }
[13:19:04.287]             else {
[13:19:04.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:04.287]             }
[13:19:04.287]             {
[13:19:04.287]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:04.287]                   0L) {
[13:19:04.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:04.287]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:04.287]                   base::options(opts)
[13:19:04.287]                 }
[13:19:04.287]                 {
[13:19:04.287]                   {
[13:19:04.287]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:04.287]                     NULL
[13:19:04.287]                   }
[13:19:04.287]                   options(future.plan = NULL)
[13:19:04.287]                   if (is.na(NA_character_)) 
[13:19:04.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:04.287]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:04.287]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:04.287]                     envir = parent.frame()) 
[13:19:04.287]                   {
[13:19:04.287]                     if (is.function(workers)) 
[13:19:04.287]                       workers <- workers()
[13:19:04.287]                     workers <- structure(as.integer(workers), 
[13:19:04.287]                       class = class(workers))
[13:19:04.287]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:04.287]                       workers >= 1)
[13:19:04.287]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:04.287]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:04.287]                     }
[13:19:04.287]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:04.287]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:04.287]                       envir = envir)
[13:19:04.287]                     if (!future$lazy) 
[13:19:04.287]                       future <- run(future)
[13:19:04.287]                     invisible(future)
[13:19:04.287]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:04.287]                 }
[13:19:04.287]             }
[13:19:04.287]         }
[13:19:04.287]     })
[13:19:04.287]     if (TRUE) {
[13:19:04.287]         base::sink(type = "output", split = FALSE)
[13:19:04.287]         if (TRUE) {
[13:19:04.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:04.287]         }
[13:19:04.287]         else {
[13:19:04.287]             ...future.result["stdout"] <- base::list(NULL)
[13:19:04.287]         }
[13:19:04.287]         base::close(...future.stdout)
[13:19:04.287]         ...future.stdout <- NULL
[13:19:04.287]     }
[13:19:04.287]     ...future.result$conditions <- ...future.conditions
[13:19:04.287]     ...future.result$finished <- base::Sys.time()
[13:19:04.287]     ...future.result
[13:19:04.287] }
[13:19:04.290] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[13:19:04.290] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:04.333] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:04.333] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[13:19:04.334] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[13:19:04.334] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:04.334] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:04.334] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:04.377] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:04.377] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:04.421] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:04.421] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:19:04.421] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:19:04.422] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:04.422] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:04.422] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:04.423] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.423] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:19:04.423] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:19:04.423] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:04.424] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.424] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:04.424] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.424] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[13:19:04.425] MultisessionFuture started
[13:19:04.425] - Launch lazy future ... done
[13:19:04.425] run() for ‘MultisessionFuture’ ... done
[13:19:04.425] Created future:
[13:19:04.425] MultisessionFuture:
[13:19:04.425] Label: ‘future_vapply-2’
[13:19:04.425] Expression:
[13:19:04.425] {
[13:19:04.425]     do.call(function(...) {
[13:19:04.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.425]             on.exit(options(oopts), add = TRUE)
[13:19:04.425]         }
[13:19:04.425]         {
[13:19:04.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.425]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.425]             })
[13:19:04.425]         }
[13:19:04.425]     }, args = future.call.arguments)
[13:19:04.425] }
[13:19:04.425] Lazy evaluation: FALSE
[13:19:04.425] Asynchronous evaluation: TRUE
[13:19:04.425] Local evaluation: TRUE
[13:19:04.425] Environment: R_GlobalEnv
[13:19:04.425] Capture standard output: TRUE
[13:19:04.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:04.425] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:04.425] Packages: 1 packages (‘future.apply’)
[13:19:04.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:04.425] Resolved: FALSE
[13:19:04.425] Value: <not collected>
[13:19:04.425] Conditions captured: <none>
[13:19:04.425] Early signaling: FALSE
[13:19:04.425] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:04.425] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.437] Chunk #2 of 2 ... DONE
[13:19:04.437] Launching 2 futures (chunks) ... DONE
[13:19:04.437] Resolving 2 futures (chunks) ...
[13:19:04.437] resolve() on list ...
[13:19:04.437]  recursive: 0
[13:19:04.438]  length: 2
[13:19:04.438] 
[13:19:04.438] receiveMessageFromWorker() for ClusterFuture ...
[13:19:04.438] - Validating connection of MultisessionFuture
[13:19:04.439] - received message: FutureResult
[13:19:04.439] - Received FutureResult
[13:19:04.439] - Erased future from FutureRegistry
[13:19:04.439] result() for ClusterFuture ...
[13:19:04.439] - result already collected: FutureResult
[13:19:04.439] result() for ClusterFuture ... done
[13:19:04.439] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:04.439] Future #1
[13:19:04.439] result() for ClusterFuture ...
[13:19:04.439] - result already collected: FutureResult
[13:19:04.439] result() for ClusterFuture ... done
[13:19:04.440] result() for ClusterFuture ...
[13:19:04.440] - result already collected: FutureResult
[13:19:04.440] result() for ClusterFuture ... done
[13:19:04.440] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:04.440] - nx: 2
[13:19:04.440] - relay: TRUE
[13:19:04.440] - stdout: TRUE
[13:19:04.440] - signal: TRUE
[13:19:04.440] - resignal: FALSE
[13:19:04.440] - force: TRUE
[13:19:04.440] - relayed: [n=2] FALSE, FALSE
[13:19:04.440] - queued futures: [n=2] FALSE, FALSE
[13:19:04.441]  - until=1
[13:19:04.441]  - relaying element #1
[13:19:04.441] result() for ClusterFuture ...
[13:19:04.441] - result already collected: FutureResult
[13:19:04.441] result() for ClusterFuture ... done
[13:19:04.441] result() for ClusterFuture ...
[13:19:04.441] - result already collected: FutureResult
[13:19:04.441] result() for ClusterFuture ... done
[13:19:04.441] result() for ClusterFuture ...
[13:19:04.441] - result already collected: FutureResult
[13:19:04.441] result() for ClusterFuture ... done
[13:19:04.442] result() for ClusterFuture ...
[13:19:04.442] - result already collected: FutureResult
[13:19:04.442] result() for ClusterFuture ... done
[13:19:04.442] - relayed: [n=2] TRUE, FALSE
[13:19:04.442] - queued futures: [n=2] TRUE, FALSE
[13:19:04.442] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:04.442]  length: 1 (resolved future 1)
[13:19:04.484] receiveMessageFromWorker() for ClusterFuture ...
[13:19:04.484] - Validating connection of MultisessionFuture
[13:19:04.484] - received message: FutureResult
[13:19:04.484] - Received FutureResult
[13:19:04.484] - Erased future from FutureRegistry
[13:19:04.484] result() for ClusterFuture ...
[13:19:04.485] - result already collected: FutureResult
[13:19:04.485] result() for ClusterFuture ... done
[13:19:04.485] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:04.485] Future #2
[13:19:04.485] result() for ClusterFuture ...
[13:19:04.485] - result already collected: FutureResult
[13:19:04.485] result() for ClusterFuture ... done
[13:19:04.485] result() for ClusterFuture ...
[13:19:04.485] - result already collected: FutureResult
[13:19:04.485] result() for ClusterFuture ... done
[13:19:04.486] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:04.486] - nx: 2
[13:19:04.486] - relay: TRUE
[13:19:04.486] - stdout: TRUE
[13:19:04.486] - signal: TRUE
[13:19:04.486] - resignal: FALSE
[13:19:04.486] - force: TRUE
[13:19:04.486] - relayed: [n=2] TRUE, FALSE
[13:19:04.486] - queued futures: [n=2] TRUE, FALSE
[13:19:04.486]  - until=2
[13:19:04.486]  - relaying element #2
[13:19:04.486] result() for ClusterFuture ...
[13:19:04.487] - result already collected: FutureResult
[13:19:04.487] result() for ClusterFuture ... done
[13:19:04.487] result() for ClusterFuture ...
[13:19:04.487] - result already collected: FutureResult
[13:19:04.487] result() for ClusterFuture ... done
[13:19:04.487] result() for ClusterFuture ...
[13:19:04.487] - result already collected: FutureResult
[13:19:04.487] result() for ClusterFuture ... done
[13:19:04.487] result() for ClusterFuture ...
[13:19:04.487] - result already collected: FutureResult
[13:19:04.487] result() for ClusterFuture ... done
[13:19:04.488] - relayed: [n=2] TRUE, TRUE
[13:19:04.488] - queued futures: [n=2] TRUE, TRUE
[13:19:04.488] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:04.488]  length: 0 (resolved future 2)
[13:19:04.488] Relaying remaining futures
[13:19:04.488] signalConditionsASAP(NULL, pos=0) ...
[13:19:04.488] - nx: 2
[13:19:04.488] - relay: TRUE
[13:19:04.488] - stdout: TRUE
[13:19:04.488] - signal: TRUE
[13:19:04.488] - resignal: FALSE
[13:19:04.488] - force: TRUE
[13:19:04.489] - relayed: [n=2] TRUE, TRUE
[13:19:04.489] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:04.489] - relayed: [n=2] TRUE, TRUE
[13:19:04.489] - queued futures: [n=2] TRUE, TRUE
[13:19:04.489] signalConditionsASAP(NULL, pos=0) ... done
[13:19:04.489] resolve() on list ... DONE
[13:19:04.489] result() for ClusterFuture ...
[13:19:04.489] - result already collected: FutureResult
[13:19:04.489] result() for ClusterFuture ... done
[13:19:04.489] result() for ClusterFuture ...
[13:19:04.489] - result already collected: FutureResult
[13:19:04.490] result() for ClusterFuture ... done
[13:19:04.490] result() for ClusterFuture ...
[13:19:04.490] - result already collected: FutureResult
[13:19:04.490] result() for ClusterFuture ... done
[13:19:04.490] result() for ClusterFuture ...
[13:19:04.490] - result already collected: FutureResult
[13:19:04.490] result() for ClusterFuture ... done
[13:19:04.490]  - Number of value chunks collected: 2
[13:19:04.490] Resolving 2 futures (chunks) ... DONE
[13:19:04.490] Reducing values from 2 chunks ...
[13:19:04.490]  - Number of values collected after concatenation: 10
[13:19:04.491]  - Number of values expected: 10
[13:19:04.491] Reducing values from 2 chunks ... DONE
[13:19:04.491] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:19:04.493] future_lapply() ...
[13:19:04.498] Number of chunks: 2
[13:19:04.498] getGlobalsAndPackagesXApply() ...
[13:19:04.498]  - future.globals: TRUE
[13:19:04.498] getGlobalsAndPackages() ...
[13:19:04.499] Searching for globals...
[13:19:04.502] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:19:04.502] Searching for globals ... DONE
[13:19:04.502] Resolving globals: FALSE
[13:19:04.503] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:19:04.503] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:04.504] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:04.504] - packages: [2] ‘stats’, ‘future.apply’
[13:19:04.504] getGlobalsAndPackages() ... DONE
[13:19:04.504]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:04.504]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:19:04.504] Finding globals ... DONE
[13:19:04.504]  - use_args: TRUE
[13:19:04.504]  - Getting '...' globals ...
[13:19:04.505] resolve() on list ...
[13:19:04.505]  recursive: 0
[13:19:04.505]  length: 1
[13:19:04.505]  elements: ‘...’
[13:19:04.505]  length: 0 (resolved future 1)
[13:19:04.505] resolve() on list ... DONE
[13:19:04.505]    - '...' content: [n=0] 
[13:19:04.505] List of 1
[13:19:04.505]  $ ...: list()
[13:19:04.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:04.505]  - attr(*, "where")=List of 1
[13:19:04.505]   ..$ ...:<environment: 0x555f7c644d98> 
[13:19:04.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:04.505]  - attr(*, "resolved")= logi TRUE
[13:19:04.505]  - attr(*, "total_size")= num NA
[13:19:04.508]  - Getting '...' globals ... DONE
[13:19:04.508] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:04.508] List of 8
[13:19:04.508]  $ ...future.FUN:function (x, ...)  
[13:19:04.508]  $ x_FUN        :function (x, ...)  
[13:19:04.508]  $ times        : int 5
[13:19:04.508]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:04.508]  $ stop_if_not  :function (...)  
[13:19:04.508]  $ dim          : NULL
[13:19:04.508]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:04.508]  $ ...          : list()
[13:19:04.508]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:04.508]  - attr(*, "where")=List of 8
[13:19:04.508]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:04.508]   ..$ ...          :<environment: 0x555f7c644d98> 
[13:19:04.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:04.508]  - attr(*, "resolved")= logi FALSE
[13:19:04.508]  - attr(*, "total_size")= num 95528
[13:19:04.513] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:19:04.514] getGlobalsAndPackagesXApply() ... DONE
[13:19:04.514] Number of futures (= number of chunks): 2
[13:19:04.514] Launching 2 futures (chunks) ...
[13:19:04.514] Chunk #1 of 2 ...
[13:19:04.514]  - Finding globals in 'X' for chunk #1 ...
[13:19:04.514] getGlobalsAndPackages() ...
[13:19:04.514] Searching for globals...
[13:19:04.515] 
[13:19:04.515] Searching for globals ... DONE
[13:19:04.515] - globals: [0] <none>
[13:19:04.515] getGlobalsAndPackages() ... DONE
[13:19:04.515]    + additional globals found: [n=0] 
[13:19:04.515]    + additional namespaces needed: [n=0] 
[13:19:04.515]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:04.515]  - seeds: <none>
[13:19:04.515] getGlobalsAndPackages() ...
[13:19:04.515] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.516] Resolving globals: FALSE
[13:19:04.516] Tweak future expression to call with '...' arguments ...
[13:19:04.516] {
[13:19:04.516]     do.call(function(...) {
[13:19:04.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.516]             on.exit(options(oopts), add = TRUE)
[13:19:04.516]         }
[13:19:04.516]         {
[13:19:04.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.516]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.516]             })
[13:19:04.516]         }
[13:19:04.516]     }, args = future.call.arguments)
[13:19:04.516] }
[13:19:04.516] Tweak future expression to call with '...' arguments ... DONE
[13:19:04.517] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.517] - packages: [2] ‘stats’, ‘future.apply’
[13:19:04.517] getGlobalsAndPackages() ... DONE
[13:19:04.517] run() for ‘Future’ ...
[13:19:04.517] - state: ‘created’
[13:19:04.517] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:04.535] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:04.535]   - Field: ‘node’
[13:19:04.535]   - Field: ‘label’
[13:19:04.535]   - Field: ‘local’
[13:19:04.535]   - Field: ‘owner’
[13:19:04.536]   - Field: ‘envir’
[13:19:04.536]   - Field: ‘workers’
[13:19:04.536]   - Field: ‘packages’
[13:19:04.536]   - Field: ‘gc’
[13:19:04.536]   - Field: ‘conditions’
[13:19:04.536]   - Field: ‘persistent’
[13:19:04.536]   - Field: ‘expr’
[13:19:04.536]   - Field: ‘uuid’
[13:19:04.536]   - Field: ‘seed’
[13:19:04.536]   - Field: ‘version’
[13:19:04.536]   - Field: ‘result’
[13:19:04.537]   - Field: ‘asynchronous’
[13:19:04.537]   - Field: ‘calls’
[13:19:04.537]   - Field: ‘globals’
[13:19:04.537]   - Field: ‘stdout’
[13:19:04.537]   - Field: ‘earlySignal’
[13:19:04.537]   - Field: ‘lazy’
[13:19:04.537]   - Field: ‘state’
[13:19:04.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:04.537] - Launch lazy future ...
[13:19:04.538] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:19:04.538] Packages needed by future strategies (n = 0): <none>
[13:19:04.538] {
[13:19:04.538]     {
[13:19:04.538]         {
[13:19:04.538]             ...future.startTime <- base::Sys.time()
[13:19:04.538]             {
[13:19:04.538]                 {
[13:19:04.538]                   {
[13:19:04.538]                     {
[13:19:04.538]                       {
[13:19:04.538]                         base::local({
[13:19:04.538]                           has_future <- base::requireNamespace("future", 
[13:19:04.538]                             quietly = TRUE)
[13:19:04.538]                           if (has_future) {
[13:19:04.538]                             ns <- base::getNamespace("future")
[13:19:04.538]                             version <- ns[[".package"]][["version"]]
[13:19:04.538]                             if (is.null(version)) 
[13:19:04.538]                               version <- utils::packageVersion("future")
[13:19:04.538]                           }
[13:19:04.538]                           else {
[13:19:04.538]                             version <- NULL
[13:19:04.538]                           }
[13:19:04.538]                           if (!has_future || version < "1.8.0") {
[13:19:04.538]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:04.538]                               "", base::R.version$version.string), 
[13:19:04.538]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:04.538]                                 base::R.version$platform, 8 * 
[13:19:04.538]                                   base::.Machine$sizeof.pointer), 
[13:19:04.538]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:04.538]                                 "release", "version")], collapse = " "), 
[13:19:04.538]                               hostname = base::Sys.info()[["nodename"]])
[13:19:04.538]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:04.538]                               info)
[13:19:04.538]                             info <- base::paste(info, collapse = "; ")
[13:19:04.538]                             if (!has_future) {
[13:19:04.538]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:04.538]                                 info)
[13:19:04.538]                             }
[13:19:04.538]                             else {
[13:19:04.538]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:04.538]                                 info, version)
[13:19:04.538]                             }
[13:19:04.538]                             base::stop(msg)
[13:19:04.538]                           }
[13:19:04.538]                         })
[13:19:04.538]                       }
[13:19:04.538]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:04.538]                       base::options(mc.cores = 1L)
[13:19:04.538]                     }
[13:19:04.538]                     base::local({
[13:19:04.538]                       for (pkg in c("stats", "future.apply")) {
[13:19:04.538]                         base::loadNamespace(pkg)
[13:19:04.538]                         base::library(pkg, character.only = TRUE)
[13:19:04.538]                       }
[13:19:04.538]                     })
[13:19:04.538]                   }
[13:19:04.538]                   options(future.plan = NULL)
[13:19:04.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:04.538]                 }
[13:19:04.538]                 ...future.workdir <- getwd()
[13:19:04.538]             }
[13:19:04.538]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:04.538]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:04.538]         }
[13:19:04.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:04.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:04.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:04.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:04.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:04.538]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:04.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:04.538]             base::names(...future.oldOptions))
[13:19:04.538]     }
[13:19:04.538]     if (FALSE) {
[13:19:04.538]     }
[13:19:04.538]     else {
[13:19:04.538]         if (TRUE) {
[13:19:04.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:04.538]                 open = "w")
[13:19:04.538]         }
[13:19:04.538]         else {
[13:19:04.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:04.538]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:04.538]         }
[13:19:04.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:04.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:04.538]             base::sink(type = "output", split = FALSE)
[13:19:04.538]             base::close(...future.stdout)
[13:19:04.538]         }, add = TRUE)
[13:19:04.538]     }
[13:19:04.538]     ...future.frame <- base::sys.nframe()
[13:19:04.538]     ...future.conditions <- base::list()
[13:19:04.538]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:04.538]     if (FALSE) {
[13:19:04.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:04.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:04.538]     }
[13:19:04.538]     ...future.result <- base::tryCatch({
[13:19:04.538]         base::withCallingHandlers({
[13:19:04.538]             ...future.value <- base::withVisible(base::local({
[13:19:04.538]                 ...future.makeSendCondition <- local({
[13:19:04.538]                   sendCondition <- NULL
[13:19:04.538]                   function(frame = 1L) {
[13:19:04.538]                     if (is.function(sendCondition)) 
[13:19:04.538]                       return(sendCondition)
[13:19:04.538]                     ns <- getNamespace("parallel")
[13:19:04.538]                     if (exists("sendData", mode = "function", 
[13:19:04.538]                       envir = ns)) {
[13:19:04.538]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:04.538]                         envir = ns)
[13:19:04.538]                       envir <- sys.frame(frame)
[13:19:04.538]                       master <- NULL
[13:19:04.538]                       while (!identical(envir, .GlobalEnv) && 
[13:19:04.538]                         !identical(envir, emptyenv())) {
[13:19:04.538]                         if (exists("master", mode = "list", envir = envir, 
[13:19:04.538]                           inherits = FALSE)) {
[13:19:04.538]                           master <- get("master", mode = "list", 
[13:19:04.538]                             envir = envir, inherits = FALSE)
[13:19:04.538]                           if (inherits(master, c("SOCKnode", 
[13:19:04.538]                             "SOCK0node"))) {
[13:19:04.538]                             sendCondition <<- function(cond) {
[13:19:04.538]                               data <- list(type = "VALUE", value = cond, 
[13:19:04.538]                                 success = TRUE)
[13:19:04.538]                               parallel_sendData(master, data)
[13:19:04.538]                             }
[13:19:04.538]                             return(sendCondition)
[13:19:04.538]                           }
[13:19:04.538]                         }
[13:19:04.538]                         frame <- frame + 1L
[13:19:04.538]                         envir <- sys.frame(frame)
[13:19:04.538]                       }
[13:19:04.538]                     }
[13:19:04.538]                     sendCondition <<- function(cond) NULL
[13:19:04.538]                   }
[13:19:04.538]                 })
[13:19:04.538]                 withCallingHandlers({
[13:19:04.538]                   {
[13:19:04.538]                     do.call(function(...) {
[13:19:04.538]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.538]                       if (!identical(...future.globals.maxSize.org, 
[13:19:04.538]                         ...future.globals.maxSize)) {
[13:19:04.538]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.538]                         on.exit(options(oopts), add = TRUE)
[13:19:04.538]                       }
[13:19:04.538]                       {
[13:19:04.538]                         lapply(seq_along(...future.elements_ii), 
[13:19:04.538]                           FUN = function(jj) {
[13:19:04.538]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.538]                             ...future.FUN(...future.X_jj, ...)
[13:19:04.538]                           })
[13:19:04.538]                       }
[13:19:04.538]                     }, args = future.call.arguments)
[13:19:04.538]                   }
[13:19:04.538]                 }, immediateCondition = function(cond) {
[13:19:04.538]                   sendCondition <- ...future.makeSendCondition()
[13:19:04.538]                   sendCondition(cond)
[13:19:04.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.538]                   {
[13:19:04.538]                     inherits <- base::inherits
[13:19:04.538]                     invokeRestart <- base::invokeRestart
[13:19:04.538]                     is.null <- base::is.null
[13:19:04.538]                     muffled <- FALSE
[13:19:04.538]                     if (inherits(cond, "message")) {
[13:19:04.538]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:04.538]                       if (muffled) 
[13:19:04.538]                         invokeRestart("muffleMessage")
[13:19:04.538]                     }
[13:19:04.538]                     else if (inherits(cond, "warning")) {
[13:19:04.538]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:04.538]                       if (muffled) 
[13:19:04.538]                         invokeRestart("muffleWarning")
[13:19:04.538]                     }
[13:19:04.538]                     else if (inherits(cond, "condition")) {
[13:19:04.538]                       if (!is.null(pattern)) {
[13:19:04.538]                         computeRestarts <- base::computeRestarts
[13:19:04.538]                         grepl <- base::grepl
[13:19:04.538]                         restarts <- computeRestarts(cond)
[13:19:04.538]                         for (restart in restarts) {
[13:19:04.538]                           name <- restart$name
[13:19:04.538]                           if (is.null(name)) 
[13:19:04.538]                             next
[13:19:04.538]                           if (!grepl(pattern, name)) 
[13:19:04.538]                             next
[13:19:04.538]                           invokeRestart(restart)
[13:19:04.538]                           muffled <- TRUE
[13:19:04.538]                           break
[13:19:04.538]                         }
[13:19:04.538]                       }
[13:19:04.538]                     }
[13:19:04.538]                     invisible(muffled)
[13:19:04.538]                   }
[13:19:04.538]                   muffleCondition(cond)
[13:19:04.538]                 })
[13:19:04.538]             }))
[13:19:04.538]             future::FutureResult(value = ...future.value$value, 
[13:19:04.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.538]                   ...future.rng), globalenv = if (FALSE) 
[13:19:04.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:04.538]                     ...future.globalenv.names))
[13:19:04.538]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:04.538]         }, condition = base::local({
[13:19:04.538]             c <- base::c
[13:19:04.538]             inherits <- base::inherits
[13:19:04.538]             invokeRestart <- base::invokeRestart
[13:19:04.538]             length <- base::length
[13:19:04.538]             list <- base::list
[13:19:04.538]             seq.int <- base::seq.int
[13:19:04.538]             signalCondition <- base::signalCondition
[13:19:04.538]             sys.calls <- base::sys.calls
[13:19:04.538]             `[[` <- base::`[[`
[13:19:04.538]             `+` <- base::`+`
[13:19:04.538]             `<<-` <- base::`<<-`
[13:19:04.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:04.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:04.538]                   3L)]
[13:19:04.538]             }
[13:19:04.538]             function(cond) {
[13:19:04.538]                 is_error <- inherits(cond, "error")
[13:19:04.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:04.538]                   NULL)
[13:19:04.538]                 if (is_error) {
[13:19:04.538]                   sessionInformation <- function() {
[13:19:04.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:04.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:04.538]                       search = base::search(), system = base::Sys.info())
[13:19:04.538]                   }
[13:19:04.538]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:04.538]                     cond$call), session = sessionInformation(), 
[13:19:04.538]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:04.538]                   signalCondition(cond)
[13:19:04.538]                 }
[13:19:04.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:04.538]                 "immediateCondition"))) {
[13:19:04.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:04.538]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:04.538]                   if (TRUE && !signal) {
[13:19:04.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.538]                     {
[13:19:04.538]                       inherits <- base::inherits
[13:19:04.538]                       invokeRestart <- base::invokeRestart
[13:19:04.538]                       is.null <- base::is.null
[13:19:04.538]                       muffled <- FALSE
[13:19:04.538]                       if (inherits(cond, "message")) {
[13:19:04.538]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.538]                         if (muffled) 
[13:19:04.538]                           invokeRestart("muffleMessage")
[13:19:04.538]                       }
[13:19:04.538]                       else if (inherits(cond, "warning")) {
[13:19:04.538]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.538]                         if (muffled) 
[13:19:04.538]                           invokeRestart("muffleWarning")
[13:19:04.538]                       }
[13:19:04.538]                       else if (inherits(cond, "condition")) {
[13:19:04.538]                         if (!is.null(pattern)) {
[13:19:04.538]                           computeRestarts <- base::computeRestarts
[13:19:04.538]                           grepl <- base::grepl
[13:19:04.538]                           restarts <- computeRestarts(cond)
[13:19:04.538]                           for (restart in restarts) {
[13:19:04.538]                             name <- restart$name
[13:19:04.538]                             if (is.null(name)) 
[13:19:04.538]                               next
[13:19:04.538]                             if (!grepl(pattern, name)) 
[13:19:04.538]                               next
[13:19:04.538]                             invokeRestart(restart)
[13:19:04.538]                             muffled <- TRUE
[13:19:04.538]                             break
[13:19:04.538]                           }
[13:19:04.538]                         }
[13:19:04.538]                       }
[13:19:04.538]                       invisible(muffled)
[13:19:04.538]                     }
[13:19:04.538]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.538]                   }
[13:19:04.538]                 }
[13:19:04.538]                 else {
[13:19:04.538]                   if (TRUE) {
[13:19:04.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.538]                     {
[13:19:04.538]                       inherits <- base::inherits
[13:19:04.538]                       invokeRestart <- base::invokeRestart
[13:19:04.538]                       is.null <- base::is.null
[13:19:04.538]                       muffled <- FALSE
[13:19:04.538]                       if (inherits(cond, "message")) {
[13:19:04.538]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.538]                         if (muffled) 
[13:19:04.538]                           invokeRestart("muffleMessage")
[13:19:04.538]                       }
[13:19:04.538]                       else if (inherits(cond, "warning")) {
[13:19:04.538]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.538]                         if (muffled) 
[13:19:04.538]                           invokeRestart("muffleWarning")
[13:19:04.538]                       }
[13:19:04.538]                       else if (inherits(cond, "condition")) {
[13:19:04.538]                         if (!is.null(pattern)) {
[13:19:04.538]                           computeRestarts <- base::computeRestarts
[13:19:04.538]                           grepl <- base::grepl
[13:19:04.538]                           restarts <- computeRestarts(cond)
[13:19:04.538]                           for (restart in restarts) {
[13:19:04.538]                             name <- restart$name
[13:19:04.538]                             if (is.null(name)) 
[13:19:04.538]                               next
[13:19:04.538]                             if (!grepl(pattern, name)) 
[13:19:04.538]                               next
[13:19:04.538]                             invokeRestart(restart)
[13:19:04.538]                             muffled <- TRUE
[13:19:04.538]                             break
[13:19:04.538]                           }
[13:19:04.538]                         }
[13:19:04.538]                       }
[13:19:04.538]                       invisible(muffled)
[13:19:04.538]                     }
[13:19:04.538]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.538]                   }
[13:19:04.538]                 }
[13:19:04.538]             }
[13:19:04.538]         }))
[13:19:04.538]     }, error = function(ex) {
[13:19:04.538]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:04.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.538]                 ...future.rng), started = ...future.startTime, 
[13:19:04.538]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:04.538]             version = "1.8"), class = "FutureResult")
[13:19:04.538]     }, finally = {
[13:19:04.538]         if (!identical(...future.workdir, getwd())) 
[13:19:04.538]             setwd(...future.workdir)
[13:19:04.538]         {
[13:19:04.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:04.538]                 ...future.oldOptions$nwarnings <- NULL
[13:19:04.538]             }
[13:19:04.538]             base::options(...future.oldOptions)
[13:19:04.538]             if (.Platform$OS.type == "windows") {
[13:19:04.538]                 old_names <- names(...future.oldEnvVars)
[13:19:04.538]                 envs <- base::Sys.getenv()
[13:19:04.538]                 names <- names(envs)
[13:19:04.538]                 common <- intersect(names, old_names)
[13:19:04.538]                 added <- setdiff(names, old_names)
[13:19:04.538]                 removed <- setdiff(old_names, names)
[13:19:04.538]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:04.538]                   envs[common]]
[13:19:04.538]                 NAMES <- toupper(changed)
[13:19:04.538]                 args <- list()
[13:19:04.538]                 for (kk in seq_along(NAMES)) {
[13:19:04.538]                   name <- changed[[kk]]
[13:19:04.538]                   NAME <- NAMES[[kk]]
[13:19:04.538]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.538]                     next
[13:19:04.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.538]                 }
[13:19:04.538]                 NAMES <- toupper(added)
[13:19:04.538]                 for (kk in seq_along(NAMES)) {
[13:19:04.538]                   name <- added[[kk]]
[13:19:04.538]                   NAME <- NAMES[[kk]]
[13:19:04.538]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.538]                     next
[13:19:04.538]                   args[[name]] <- ""
[13:19:04.538]                 }
[13:19:04.538]                 NAMES <- toupper(removed)
[13:19:04.538]                 for (kk in seq_along(NAMES)) {
[13:19:04.538]                   name <- removed[[kk]]
[13:19:04.538]                   NAME <- NAMES[[kk]]
[13:19:04.538]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.538]                     next
[13:19:04.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.538]                 }
[13:19:04.538]                 if (length(args) > 0) 
[13:19:04.538]                   base::do.call(base::Sys.setenv, args = args)
[13:19:04.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:04.538]             }
[13:19:04.538]             else {
[13:19:04.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:04.538]             }
[13:19:04.538]             {
[13:19:04.538]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:04.538]                   0L) {
[13:19:04.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:04.538]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:04.538]                   base::options(opts)
[13:19:04.538]                 }
[13:19:04.538]                 {
[13:19:04.538]                   {
[13:19:04.538]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:04.538]                     NULL
[13:19:04.538]                   }
[13:19:04.538]                   options(future.plan = NULL)
[13:19:04.538]                   if (is.na(NA_character_)) 
[13:19:04.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:04.538]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:04.538]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:04.538]                     envir = parent.frame()) 
[13:19:04.538]                   {
[13:19:04.538]                     if (is.function(workers)) 
[13:19:04.538]                       workers <- workers()
[13:19:04.538]                     workers <- structure(as.integer(workers), 
[13:19:04.538]                       class = class(workers))
[13:19:04.538]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:04.538]                       workers >= 1)
[13:19:04.538]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:04.538]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:04.538]                     }
[13:19:04.538]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:04.538]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:04.538]                       envir = envir)
[13:19:04.538]                     if (!future$lazy) 
[13:19:04.538]                       future <- run(future)
[13:19:04.538]                     invisible(future)
[13:19:04.538]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:04.538]                 }
[13:19:04.538]             }
[13:19:04.538]         }
[13:19:04.538]     })
[13:19:04.538]     if (TRUE) {
[13:19:04.538]         base::sink(type = "output", split = FALSE)
[13:19:04.538]         if (TRUE) {
[13:19:04.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:04.538]         }
[13:19:04.538]         else {
[13:19:04.538]             ...future.result["stdout"] <- base::list(NULL)
[13:19:04.538]         }
[13:19:04.538]         base::close(...future.stdout)
[13:19:04.538]         ...future.stdout <- NULL
[13:19:04.538]     }
[13:19:04.538]     ...future.result$conditions <- ...future.conditions
[13:19:04.538]     ...future.result$finished <- base::Sys.time()
[13:19:04.538]     ...future.result
[13:19:04.538] }
[13:19:04.541] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[13:19:04.541] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:04.585] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:04.585] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[13:19:04.586] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:19:04.586] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:04.586] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:04.586] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:04.629] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:04.629] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:04.673] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:04.673] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:04.673] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.674] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:04.674] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:04.674] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:04.674] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.675] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[13:19:04.675] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[13:19:04.675] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:04.675] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.675] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:04.676] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:04.676] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[13:19:04.676] MultisessionFuture started
[13:19:04.677] - Launch lazy future ... done
[13:19:04.677] run() for ‘MultisessionFuture’ ... done
[13:19:04.677] Created future:
[13:19:04.677] MultisessionFuture:
[13:19:04.677] Label: ‘future_vapply-1’
[13:19:04.677] Expression:
[13:19:04.677] {
[13:19:04.677]     do.call(function(...) {
[13:19:04.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.677]             on.exit(options(oopts), add = TRUE)
[13:19:04.677]         }
[13:19:04.677]         {
[13:19:04.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.677]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.677]             })
[13:19:04.677]         }
[13:19:04.677]     }, args = future.call.arguments)
[13:19:04.677] }
[13:19:04.677] Lazy evaluation: FALSE
[13:19:04.677] Asynchronous evaluation: TRUE
[13:19:04.677] Local evaluation: TRUE
[13:19:04.677] Environment: R_GlobalEnv
[13:19:04.677] Capture standard output: TRUE
[13:19:04.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:04.677] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:04.677] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:19:04.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:04.677] Resolved: FALSE
[13:19:04.677] Value: <not collected>
[13:19:04.677] Conditions captured: <none>
[13:19:04.677] Early signaling: FALSE
[13:19:04.677] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:04.677] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.689] Chunk #1 of 2 ... DONE
[13:19:04.689] Chunk #2 of 2 ...
[13:19:04.689]  - Finding globals in 'X' for chunk #2 ...
[13:19:04.689] getGlobalsAndPackages() ...
[13:19:04.689] Searching for globals...
[13:19:04.689] 
[13:19:04.690] Searching for globals ... DONE
[13:19:04.690] - globals: [0] <none>
[13:19:04.690] getGlobalsAndPackages() ... DONE
[13:19:04.690]    + additional globals found: [n=0] 
[13:19:04.690]    + additional namespaces needed: [n=0] 
[13:19:04.690]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:04.690]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:04.690]  - seeds: <none>
[13:19:04.690] getGlobalsAndPackages() ...
[13:19:04.690] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.691] Resolving globals: FALSE
[13:19:04.691] Tweak future expression to call with '...' arguments ...
[13:19:04.691] {
[13:19:04.691]     do.call(function(...) {
[13:19:04.691]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.691]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.691]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.691]             on.exit(options(oopts), add = TRUE)
[13:19:04.691]         }
[13:19:04.691]         {
[13:19:04.691]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.691]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.691]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.691]             })
[13:19:04.691]         }
[13:19:04.691]     }, args = future.call.arguments)
[13:19:04.691] }
[13:19:04.691] Tweak future expression to call with '...' arguments ... DONE
[13:19:04.692] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.692] - packages: [2] ‘stats’, ‘future.apply’
[13:19:04.692] getGlobalsAndPackages() ... DONE
[13:19:04.692] run() for ‘Future’ ...
[13:19:04.692] - state: ‘created’
[13:19:04.692] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:04.707] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:04.708]   - Field: ‘node’
[13:19:04.708]   - Field: ‘label’
[13:19:04.708]   - Field: ‘local’
[13:19:04.708]   - Field: ‘owner’
[13:19:04.708]   - Field: ‘envir’
[13:19:04.708]   - Field: ‘workers’
[13:19:04.708]   - Field: ‘packages’
[13:19:04.708]   - Field: ‘gc’
[13:19:04.708]   - Field: ‘conditions’
[13:19:04.708]   - Field: ‘persistent’
[13:19:04.708]   - Field: ‘expr’
[13:19:04.709]   - Field: ‘uuid’
[13:19:04.709]   - Field: ‘seed’
[13:19:04.709]   - Field: ‘version’
[13:19:04.709]   - Field: ‘result’
[13:19:04.709]   - Field: ‘asynchronous’
[13:19:04.709]   - Field: ‘calls’
[13:19:04.709]   - Field: ‘globals’
[13:19:04.709]   - Field: ‘stdout’
[13:19:04.709]   - Field: ‘earlySignal’
[13:19:04.709]   - Field: ‘lazy’
[13:19:04.710]   - Field: ‘state’
[13:19:04.710] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:04.710] - Launch lazy future ...
[13:19:04.710] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:19:04.710] Packages needed by future strategies (n = 0): <none>
[13:19:04.711] {
[13:19:04.711]     {
[13:19:04.711]         {
[13:19:04.711]             ...future.startTime <- base::Sys.time()
[13:19:04.711]             {
[13:19:04.711]                 {
[13:19:04.711]                   {
[13:19:04.711]                     {
[13:19:04.711]                       {
[13:19:04.711]                         base::local({
[13:19:04.711]                           has_future <- base::requireNamespace("future", 
[13:19:04.711]                             quietly = TRUE)
[13:19:04.711]                           if (has_future) {
[13:19:04.711]                             ns <- base::getNamespace("future")
[13:19:04.711]                             version <- ns[[".package"]][["version"]]
[13:19:04.711]                             if (is.null(version)) 
[13:19:04.711]                               version <- utils::packageVersion("future")
[13:19:04.711]                           }
[13:19:04.711]                           else {
[13:19:04.711]                             version <- NULL
[13:19:04.711]                           }
[13:19:04.711]                           if (!has_future || version < "1.8.0") {
[13:19:04.711]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:04.711]                               "", base::R.version$version.string), 
[13:19:04.711]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:04.711]                                 base::R.version$platform, 8 * 
[13:19:04.711]                                   base::.Machine$sizeof.pointer), 
[13:19:04.711]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:04.711]                                 "release", "version")], collapse = " "), 
[13:19:04.711]                               hostname = base::Sys.info()[["nodename"]])
[13:19:04.711]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:04.711]                               info)
[13:19:04.711]                             info <- base::paste(info, collapse = "; ")
[13:19:04.711]                             if (!has_future) {
[13:19:04.711]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:04.711]                                 info)
[13:19:04.711]                             }
[13:19:04.711]                             else {
[13:19:04.711]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:04.711]                                 info, version)
[13:19:04.711]                             }
[13:19:04.711]                             base::stop(msg)
[13:19:04.711]                           }
[13:19:04.711]                         })
[13:19:04.711]                       }
[13:19:04.711]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:04.711]                       base::options(mc.cores = 1L)
[13:19:04.711]                     }
[13:19:04.711]                     base::local({
[13:19:04.711]                       for (pkg in c("stats", "future.apply")) {
[13:19:04.711]                         base::loadNamespace(pkg)
[13:19:04.711]                         base::library(pkg, character.only = TRUE)
[13:19:04.711]                       }
[13:19:04.711]                     })
[13:19:04.711]                   }
[13:19:04.711]                   options(future.plan = NULL)
[13:19:04.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:04.711]                 }
[13:19:04.711]                 ...future.workdir <- getwd()
[13:19:04.711]             }
[13:19:04.711]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:04.711]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:04.711]         }
[13:19:04.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:04.711]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:04.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:04.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:04.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:04.711]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:04.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:04.711]             base::names(...future.oldOptions))
[13:19:04.711]     }
[13:19:04.711]     if (FALSE) {
[13:19:04.711]     }
[13:19:04.711]     else {
[13:19:04.711]         if (TRUE) {
[13:19:04.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:04.711]                 open = "w")
[13:19:04.711]         }
[13:19:04.711]         else {
[13:19:04.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:04.711]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:04.711]         }
[13:19:04.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:04.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:04.711]             base::sink(type = "output", split = FALSE)
[13:19:04.711]             base::close(...future.stdout)
[13:19:04.711]         }, add = TRUE)
[13:19:04.711]     }
[13:19:04.711]     ...future.frame <- base::sys.nframe()
[13:19:04.711]     ...future.conditions <- base::list()
[13:19:04.711]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:04.711]     if (FALSE) {
[13:19:04.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:04.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:04.711]     }
[13:19:04.711]     ...future.result <- base::tryCatch({
[13:19:04.711]         base::withCallingHandlers({
[13:19:04.711]             ...future.value <- base::withVisible(base::local({
[13:19:04.711]                 ...future.makeSendCondition <- local({
[13:19:04.711]                   sendCondition <- NULL
[13:19:04.711]                   function(frame = 1L) {
[13:19:04.711]                     if (is.function(sendCondition)) 
[13:19:04.711]                       return(sendCondition)
[13:19:04.711]                     ns <- getNamespace("parallel")
[13:19:04.711]                     if (exists("sendData", mode = "function", 
[13:19:04.711]                       envir = ns)) {
[13:19:04.711]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:04.711]                         envir = ns)
[13:19:04.711]                       envir <- sys.frame(frame)
[13:19:04.711]                       master <- NULL
[13:19:04.711]                       while (!identical(envir, .GlobalEnv) && 
[13:19:04.711]                         !identical(envir, emptyenv())) {
[13:19:04.711]                         if (exists("master", mode = "list", envir = envir, 
[13:19:04.711]                           inherits = FALSE)) {
[13:19:04.711]                           master <- get("master", mode = "list", 
[13:19:04.711]                             envir = envir, inherits = FALSE)
[13:19:04.711]                           if (inherits(master, c("SOCKnode", 
[13:19:04.711]                             "SOCK0node"))) {
[13:19:04.711]                             sendCondition <<- function(cond) {
[13:19:04.711]                               data <- list(type = "VALUE", value = cond, 
[13:19:04.711]                                 success = TRUE)
[13:19:04.711]                               parallel_sendData(master, data)
[13:19:04.711]                             }
[13:19:04.711]                             return(sendCondition)
[13:19:04.711]                           }
[13:19:04.711]                         }
[13:19:04.711]                         frame <- frame + 1L
[13:19:04.711]                         envir <- sys.frame(frame)
[13:19:04.711]                       }
[13:19:04.711]                     }
[13:19:04.711]                     sendCondition <<- function(cond) NULL
[13:19:04.711]                   }
[13:19:04.711]                 })
[13:19:04.711]                 withCallingHandlers({
[13:19:04.711]                   {
[13:19:04.711]                     do.call(function(...) {
[13:19:04.711]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.711]                       if (!identical(...future.globals.maxSize.org, 
[13:19:04.711]                         ...future.globals.maxSize)) {
[13:19:04.711]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.711]                         on.exit(options(oopts), add = TRUE)
[13:19:04.711]                       }
[13:19:04.711]                       {
[13:19:04.711]                         lapply(seq_along(...future.elements_ii), 
[13:19:04.711]                           FUN = function(jj) {
[13:19:04.711]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.711]                             ...future.FUN(...future.X_jj, ...)
[13:19:04.711]                           })
[13:19:04.711]                       }
[13:19:04.711]                     }, args = future.call.arguments)
[13:19:04.711]                   }
[13:19:04.711]                 }, immediateCondition = function(cond) {
[13:19:04.711]                   sendCondition <- ...future.makeSendCondition()
[13:19:04.711]                   sendCondition(cond)
[13:19:04.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.711]                   {
[13:19:04.711]                     inherits <- base::inherits
[13:19:04.711]                     invokeRestart <- base::invokeRestart
[13:19:04.711]                     is.null <- base::is.null
[13:19:04.711]                     muffled <- FALSE
[13:19:04.711]                     if (inherits(cond, "message")) {
[13:19:04.711]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:04.711]                       if (muffled) 
[13:19:04.711]                         invokeRestart("muffleMessage")
[13:19:04.711]                     }
[13:19:04.711]                     else if (inherits(cond, "warning")) {
[13:19:04.711]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:04.711]                       if (muffled) 
[13:19:04.711]                         invokeRestart("muffleWarning")
[13:19:04.711]                     }
[13:19:04.711]                     else if (inherits(cond, "condition")) {
[13:19:04.711]                       if (!is.null(pattern)) {
[13:19:04.711]                         computeRestarts <- base::computeRestarts
[13:19:04.711]                         grepl <- base::grepl
[13:19:04.711]                         restarts <- computeRestarts(cond)
[13:19:04.711]                         for (restart in restarts) {
[13:19:04.711]                           name <- restart$name
[13:19:04.711]                           if (is.null(name)) 
[13:19:04.711]                             next
[13:19:04.711]                           if (!grepl(pattern, name)) 
[13:19:04.711]                             next
[13:19:04.711]                           invokeRestart(restart)
[13:19:04.711]                           muffled <- TRUE
[13:19:04.711]                           break
[13:19:04.711]                         }
[13:19:04.711]                       }
[13:19:04.711]                     }
[13:19:04.711]                     invisible(muffled)
[13:19:04.711]                   }
[13:19:04.711]                   muffleCondition(cond)
[13:19:04.711]                 })
[13:19:04.711]             }))
[13:19:04.711]             future::FutureResult(value = ...future.value$value, 
[13:19:04.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.711]                   ...future.rng), globalenv = if (FALSE) 
[13:19:04.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:04.711]                     ...future.globalenv.names))
[13:19:04.711]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:04.711]         }, condition = base::local({
[13:19:04.711]             c <- base::c
[13:19:04.711]             inherits <- base::inherits
[13:19:04.711]             invokeRestart <- base::invokeRestart
[13:19:04.711]             length <- base::length
[13:19:04.711]             list <- base::list
[13:19:04.711]             seq.int <- base::seq.int
[13:19:04.711]             signalCondition <- base::signalCondition
[13:19:04.711]             sys.calls <- base::sys.calls
[13:19:04.711]             `[[` <- base::`[[`
[13:19:04.711]             `+` <- base::`+`
[13:19:04.711]             `<<-` <- base::`<<-`
[13:19:04.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:04.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:04.711]                   3L)]
[13:19:04.711]             }
[13:19:04.711]             function(cond) {
[13:19:04.711]                 is_error <- inherits(cond, "error")
[13:19:04.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:04.711]                   NULL)
[13:19:04.711]                 if (is_error) {
[13:19:04.711]                   sessionInformation <- function() {
[13:19:04.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:04.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:04.711]                       search = base::search(), system = base::Sys.info())
[13:19:04.711]                   }
[13:19:04.711]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:04.711]                     cond$call), session = sessionInformation(), 
[13:19:04.711]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:04.711]                   signalCondition(cond)
[13:19:04.711]                 }
[13:19:04.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:04.711]                 "immediateCondition"))) {
[13:19:04.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:04.711]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:04.711]                   if (TRUE && !signal) {
[13:19:04.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.711]                     {
[13:19:04.711]                       inherits <- base::inherits
[13:19:04.711]                       invokeRestart <- base::invokeRestart
[13:19:04.711]                       is.null <- base::is.null
[13:19:04.711]                       muffled <- FALSE
[13:19:04.711]                       if (inherits(cond, "message")) {
[13:19:04.711]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.711]                         if (muffled) 
[13:19:04.711]                           invokeRestart("muffleMessage")
[13:19:04.711]                       }
[13:19:04.711]                       else if (inherits(cond, "warning")) {
[13:19:04.711]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.711]                         if (muffled) 
[13:19:04.711]                           invokeRestart("muffleWarning")
[13:19:04.711]                       }
[13:19:04.711]                       else if (inherits(cond, "condition")) {
[13:19:04.711]                         if (!is.null(pattern)) {
[13:19:04.711]                           computeRestarts <- base::computeRestarts
[13:19:04.711]                           grepl <- base::grepl
[13:19:04.711]                           restarts <- computeRestarts(cond)
[13:19:04.711]                           for (restart in restarts) {
[13:19:04.711]                             name <- restart$name
[13:19:04.711]                             if (is.null(name)) 
[13:19:04.711]                               next
[13:19:04.711]                             if (!grepl(pattern, name)) 
[13:19:04.711]                               next
[13:19:04.711]                             invokeRestart(restart)
[13:19:04.711]                             muffled <- TRUE
[13:19:04.711]                             break
[13:19:04.711]                           }
[13:19:04.711]                         }
[13:19:04.711]                       }
[13:19:04.711]                       invisible(muffled)
[13:19:04.711]                     }
[13:19:04.711]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.711]                   }
[13:19:04.711]                 }
[13:19:04.711]                 else {
[13:19:04.711]                   if (TRUE) {
[13:19:04.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.711]                     {
[13:19:04.711]                       inherits <- base::inherits
[13:19:04.711]                       invokeRestart <- base::invokeRestart
[13:19:04.711]                       is.null <- base::is.null
[13:19:04.711]                       muffled <- FALSE
[13:19:04.711]                       if (inherits(cond, "message")) {
[13:19:04.711]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.711]                         if (muffled) 
[13:19:04.711]                           invokeRestart("muffleMessage")
[13:19:04.711]                       }
[13:19:04.711]                       else if (inherits(cond, "warning")) {
[13:19:04.711]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.711]                         if (muffled) 
[13:19:04.711]                           invokeRestart("muffleWarning")
[13:19:04.711]                       }
[13:19:04.711]                       else if (inherits(cond, "condition")) {
[13:19:04.711]                         if (!is.null(pattern)) {
[13:19:04.711]                           computeRestarts <- base::computeRestarts
[13:19:04.711]                           grepl <- base::grepl
[13:19:04.711]                           restarts <- computeRestarts(cond)
[13:19:04.711]                           for (restart in restarts) {
[13:19:04.711]                             name <- restart$name
[13:19:04.711]                             if (is.null(name)) 
[13:19:04.711]                               next
[13:19:04.711]                             if (!grepl(pattern, name)) 
[13:19:04.711]                               next
[13:19:04.711]                             invokeRestart(restart)
[13:19:04.711]                             muffled <- TRUE
[13:19:04.711]                             break
[13:19:04.711]                           }
[13:19:04.711]                         }
[13:19:04.711]                       }
[13:19:04.711]                       invisible(muffled)
[13:19:04.711]                     }
[13:19:04.711]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.711]                   }
[13:19:04.711]                 }
[13:19:04.711]             }
[13:19:04.711]         }))
[13:19:04.711]     }, error = function(ex) {
[13:19:04.711]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:04.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.711]                 ...future.rng), started = ...future.startTime, 
[13:19:04.711]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:04.711]             version = "1.8"), class = "FutureResult")
[13:19:04.711]     }, finally = {
[13:19:04.711]         if (!identical(...future.workdir, getwd())) 
[13:19:04.711]             setwd(...future.workdir)
[13:19:04.711]         {
[13:19:04.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:04.711]                 ...future.oldOptions$nwarnings <- NULL
[13:19:04.711]             }
[13:19:04.711]             base::options(...future.oldOptions)
[13:19:04.711]             if (.Platform$OS.type == "windows") {
[13:19:04.711]                 old_names <- names(...future.oldEnvVars)
[13:19:04.711]                 envs <- base::Sys.getenv()
[13:19:04.711]                 names <- names(envs)
[13:19:04.711]                 common <- intersect(names, old_names)
[13:19:04.711]                 added <- setdiff(names, old_names)
[13:19:04.711]                 removed <- setdiff(old_names, names)
[13:19:04.711]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:04.711]                   envs[common]]
[13:19:04.711]                 NAMES <- toupper(changed)
[13:19:04.711]                 args <- list()
[13:19:04.711]                 for (kk in seq_along(NAMES)) {
[13:19:04.711]                   name <- changed[[kk]]
[13:19:04.711]                   NAME <- NAMES[[kk]]
[13:19:04.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.711]                     next
[13:19:04.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.711]                 }
[13:19:04.711]                 NAMES <- toupper(added)
[13:19:04.711]                 for (kk in seq_along(NAMES)) {
[13:19:04.711]                   name <- added[[kk]]
[13:19:04.711]                   NAME <- NAMES[[kk]]
[13:19:04.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.711]                     next
[13:19:04.711]                   args[[name]] <- ""
[13:19:04.711]                 }
[13:19:04.711]                 NAMES <- toupper(removed)
[13:19:04.711]                 for (kk in seq_along(NAMES)) {
[13:19:04.711]                   name <- removed[[kk]]
[13:19:04.711]                   NAME <- NAMES[[kk]]
[13:19:04.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.711]                     next
[13:19:04.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.711]                 }
[13:19:04.711]                 if (length(args) > 0) 
[13:19:04.711]                   base::do.call(base::Sys.setenv, args = args)
[13:19:04.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:04.711]             }
[13:19:04.711]             else {
[13:19:04.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:04.711]             }
[13:19:04.711]             {
[13:19:04.711]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:04.711]                   0L) {
[13:19:04.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:04.711]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:04.711]                   base::options(opts)
[13:19:04.711]                 }
[13:19:04.711]                 {
[13:19:04.711]                   {
[13:19:04.711]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:04.711]                     NULL
[13:19:04.711]                   }
[13:19:04.711]                   options(future.plan = NULL)
[13:19:04.711]                   if (is.na(NA_character_)) 
[13:19:04.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:04.711]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:04.711]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:04.711]                     envir = parent.frame()) 
[13:19:04.711]                   {
[13:19:04.711]                     if (is.function(workers)) 
[13:19:04.711]                       workers <- workers()
[13:19:04.711]                     workers <- structure(as.integer(workers), 
[13:19:04.711]                       class = class(workers))
[13:19:04.711]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:04.711]                       workers >= 1)
[13:19:04.711]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:04.711]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:04.711]                     }
[13:19:04.711]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:04.711]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:04.711]                       envir = envir)
[13:19:04.711]                     if (!future$lazy) 
[13:19:04.711]                       future <- run(future)
[13:19:04.711]                     invisible(future)
[13:19:04.711]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:04.711]                 }
[13:19:04.711]             }
[13:19:04.711]         }
[13:19:04.711]     })
[13:19:04.711]     if (TRUE) {
[13:19:04.711]         base::sink(type = "output", split = FALSE)
[13:19:04.711]         if (TRUE) {
[13:19:04.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:04.711]         }
[13:19:04.711]         else {
[13:19:04.711]             ...future.result["stdout"] <- base::list(NULL)
[13:19:04.711]         }
[13:19:04.711]         base::close(...future.stdout)
[13:19:04.711]         ...future.stdout <- NULL
[13:19:04.711]     }
[13:19:04.711]     ...future.result$conditions <- ...future.conditions
[13:19:04.711]     ...future.result$finished <- base::Sys.time()
[13:19:04.711]     ...future.result
[13:19:04.711] }
[13:19:04.714] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[13:19:04.714] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:04.757] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:04.757] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[13:19:04.758] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:19:04.758] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:04.758] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:04.758] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:04.801] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:04.801] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:04.845] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:04.845] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:04.846] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.846] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:04.846] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:04.847] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:04.847] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.847] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[13:19:04.847] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[13:19:04.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:04.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.848] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:04.848] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:04.849] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[13:19:04.849] MultisessionFuture started
[13:19:04.849] - Launch lazy future ... done
[13:19:04.850] run() for ‘MultisessionFuture’ ... done
[13:19:04.850] Created future:
[13:19:04.850] MultisessionFuture:
[13:19:04.850] Label: ‘future_vapply-2’
[13:19:04.850] Expression:
[13:19:04.850] {
[13:19:04.850]     do.call(function(...) {
[13:19:04.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.850]             on.exit(options(oopts), add = TRUE)
[13:19:04.850]         }
[13:19:04.850]         {
[13:19:04.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.850]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.850]             })
[13:19:04.850]         }
[13:19:04.850]     }, args = future.call.arguments)
[13:19:04.850] }
[13:19:04.850] Lazy evaluation: FALSE
[13:19:04.850] Asynchronous evaluation: TRUE
[13:19:04.850] Local evaluation: TRUE
[13:19:04.850] Environment: R_GlobalEnv
[13:19:04.850] Capture standard output: TRUE
[13:19:04.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:04.850] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:04.850] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:19:04.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:04.850] Resolved: FALSE
[13:19:04.850] Value: <not collected>
[13:19:04.850] Conditions captured: <none>
[13:19:04.850] Early signaling: FALSE
[13:19:04.850] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:04.850] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.862] Chunk #2 of 2 ... DONE
[13:19:04.862] Launching 2 futures (chunks) ... DONE
[13:19:04.862] Resolving 2 futures (chunks) ...
[13:19:04.862] resolve() on list ...
[13:19:04.862]  recursive: 0
[13:19:04.862]  length: 2
[13:19:04.862] 
[13:19:04.863] receiveMessageFromWorker() for ClusterFuture ...
[13:19:04.863] - Validating connection of MultisessionFuture
[13:19:04.863] - received message: FutureResult
[13:19:04.863] - Received FutureResult
[13:19:04.863] - Erased future from FutureRegistry
[13:19:04.863] result() for ClusterFuture ...
[13:19:04.863] - result already collected: FutureResult
[13:19:04.863] result() for ClusterFuture ... done
[13:19:04.864] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:04.864] Future #1
[13:19:04.864] result() for ClusterFuture ...
[13:19:04.864] - result already collected: FutureResult
[13:19:04.864] result() for ClusterFuture ... done
[13:19:04.864] result() for ClusterFuture ...
[13:19:04.864] - result already collected: FutureResult
[13:19:04.864] result() for ClusterFuture ... done
[13:19:04.864] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:04.864] - nx: 2
[13:19:04.864] - relay: TRUE
[13:19:04.864] - stdout: TRUE
[13:19:04.865] - signal: TRUE
[13:19:04.865] - resignal: FALSE
[13:19:04.865] - force: TRUE
[13:19:04.865] - relayed: [n=2] FALSE, FALSE
[13:19:04.865] - queued futures: [n=2] FALSE, FALSE
[13:19:04.865]  - until=1
[13:19:04.865]  - relaying element #1
[13:19:04.865] result() for ClusterFuture ...
[13:19:04.865] - result already collected: FutureResult
[13:19:04.865] result() for ClusterFuture ... done
[13:19:04.865] result() for ClusterFuture ...
[13:19:04.866] - result already collected: FutureResult
[13:19:04.866] result() for ClusterFuture ... done
[13:19:04.866] result() for ClusterFuture ...
[13:19:04.866] - result already collected: FutureResult
[13:19:04.866] result() for ClusterFuture ... done
[13:19:04.866] result() for ClusterFuture ...
[13:19:04.866] - result already collected: FutureResult
[13:19:04.866] result() for ClusterFuture ... done
[13:19:04.866] - relayed: [n=2] TRUE, FALSE
[13:19:04.866] - queued futures: [n=2] TRUE, FALSE
[13:19:04.866] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:04.867]  length: 1 (resolved future 1)
[13:19:04.908] receiveMessageFromWorker() for ClusterFuture ...
[13:19:04.909] - Validating connection of MultisessionFuture
[13:19:04.909] - received message: FutureResult
[13:19:04.909] - Received FutureResult
[13:19:04.909] - Erased future from FutureRegistry
[13:19:04.909] result() for ClusterFuture ...
[13:19:04.909] - result already collected: FutureResult
[13:19:04.909] result() for ClusterFuture ... done
[13:19:04.909] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:04.910] Future #2
[13:19:04.910] result() for ClusterFuture ...
[13:19:04.910] - result already collected: FutureResult
[13:19:04.910] result() for ClusterFuture ... done
[13:19:04.910] result() for ClusterFuture ...
[13:19:04.910] - result already collected: FutureResult
[13:19:04.910] result() for ClusterFuture ... done
[13:19:04.910] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:04.910] - nx: 2
[13:19:04.910] - relay: TRUE
[13:19:04.910] - stdout: TRUE
[13:19:04.911] - signal: TRUE
[13:19:04.911] - resignal: FALSE
[13:19:04.911] - force: TRUE
[13:19:04.911] - relayed: [n=2] TRUE, FALSE
[13:19:04.911] - queued futures: [n=2] TRUE, FALSE
[13:19:04.911]  - until=2
[13:19:04.911]  - relaying element #2
[13:19:04.911] result() for ClusterFuture ...
[13:19:04.911] - result already collected: FutureResult
[13:19:04.911] result() for ClusterFuture ... done
[13:19:04.911] result() for ClusterFuture ...
[13:19:04.911] - result already collected: FutureResult
[13:19:04.912] result() for ClusterFuture ... done
[13:19:04.912] result() for ClusterFuture ...
[13:19:04.912] - result already collected: FutureResult
[13:19:04.912] result() for ClusterFuture ... done
[13:19:04.912] result() for ClusterFuture ...
[13:19:04.912] - result already collected: FutureResult
[13:19:04.912] result() for ClusterFuture ... done
[13:19:04.912] - relayed: [n=2] TRUE, TRUE
[13:19:04.912] - queued futures: [n=2] TRUE, TRUE
[13:19:04.912] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:04.913]  length: 0 (resolved future 2)
[13:19:04.913] Relaying remaining futures
[13:19:04.913] signalConditionsASAP(NULL, pos=0) ...
[13:19:04.913] - nx: 2
[13:19:04.913] - relay: TRUE
[13:19:04.913] - stdout: TRUE
[13:19:04.913] - signal: TRUE
[13:19:04.913] - resignal: FALSE
[13:19:04.913] - force: TRUE
[13:19:04.913] - relayed: [n=2] TRUE, TRUE
[13:19:04.913] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:04.914] - relayed: [n=2] TRUE, TRUE
[13:19:04.914] - queued futures: [n=2] TRUE, TRUE
[13:19:04.914] signalConditionsASAP(NULL, pos=0) ... done
[13:19:04.914] resolve() on list ... DONE
[13:19:04.914] result() for ClusterFuture ...
[13:19:04.914] - result already collected: FutureResult
[13:19:04.914] result() for ClusterFuture ... done
[13:19:04.914] result() for ClusterFuture ...
[13:19:04.914] - result already collected: FutureResult
[13:19:04.914] result() for ClusterFuture ... done
[13:19:04.914] result() for ClusterFuture ...
[13:19:04.914] - result already collected: FutureResult
[13:19:04.915] result() for ClusterFuture ... done
[13:19:04.915] result() for ClusterFuture ...
[13:19:04.915] - result already collected: FutureResult
[13:19:04.915] result() for ClusterFuture ... done
[13:19:04.915]  - Number of value chunks collected: 2
[13:19:04.915] Resolving 2 futures (chunks) ... DONE
[13:19:04.915] Reducing values from 2 chunks ...
[13:19:04.915]  - Number of values collected after concatenation: 3
[13:19:04.915]  - Number of values expected: 3
[13:19:04.915] Reducing values from 2 chunks ... DONE
[13:19:04.915] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:19:04.917] future_lapply() ...
[13:19:04.925] Number of chunks: 2
[13:19:04.925] getGlobalsAndPackagesXApply() ...
[13:19:04.925]  - future.globals: TRUE
[13:19:04.925] getGlobalsAndPackages() ...
[13:19:04.925] Searching for globals...
[13:19:04.930] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:19:04.930] Searching for globals ... DONE
[13:19:04.930] Resolving globals: FALSE
[13:19:04.931] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:19:04.931] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:19:04.932] - globals: [1] ‘FUN’
[13:19:04.932] - packages: [1] ‘stats’
[13:19:04.932] getGlobalsAndPackages() ... DONE
[13:19:04.932]  - globals found/used: [n=1] ‘FUN’
[13:19:04.932]  - needed namespaces: [n=1] ‘stats’
[13:19:04.932] Finding globals ... DONE
[13:19:04.932]  - use_args: TRUE
[13:19:04.932]  - Getting '...' globals ...
[13:19:04.932] resolve() on list ...
[13:19:04.933]  recursive: 0
[13:19:04.933]  length: 1
[13:19:04.933]  elements: ‘...’
[13:19:04.933]  length: 0 (resolved future 1)
[13:19:04.933] resolve() on list ... DONE
[13:19:04.933]    - '...' content: [n=0] 
[13:19:04.933] List of 1
[13:19:04.933]  $ ...: list()
[13:19:04.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:04.933]  - attr(*, "where")=List of 1
[13:19:04.933]   ..$ ...:<environment: 0x555f7cffc3d8> 
[13:19:04.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:04.933]  - attr(*, "resolved")= logi TRUE
[13:19:04.933]  - attr(*, "total_size")= num NA
[13:19:04.936]  - Getting '...' globals ... DONE
[13:19:04.936] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:04.936] List of 2
[13:19:04.936]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:19:04.936]  $ ...          : list()
[13:19:04.936]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:04.936]  - attr(*, "where")=List of 2
[13:19:04.936]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:04.936]   ..$ ...          :<environment: 0x555f7cffc3d8> 
[13:19:04.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:04.936]  - attr(*, "resolved")= logi FALSE
[13:19:04.936]  - attr(*, "total_size")= num 46960
[13:19:04.938] Packages to be attached in all futures: [n=1] ‘stats’
[13:19:04.939] getGlobalsAndPackagesXApply() ... DONE
[13:19:04.939] Number of futures (= number of chunks): 2
[13:19:04.939] Launching 2 futures (chunks) ...
[13:19:04.939] Chunk #1 of 2 ...
[13:19:04.939]  - Finding globals in 'X' for chunk #1 ...
[13:19:04.939] getGlobalsAndPackages() ...
[13:19:04.939] Searching for globals...
[13:19:04.940] 
[13:19:04.940] Searching for globals ... DONE
[13:19:04.940] - globals: [0] <none>
[13:19:04.940] getGlobalsAndPackages() ... DONE
[13:19:04.940]    + additional globals found: [n=0] 
[13:19:04.940]    + additional namespaces needed: [n=0] 
[13:19:04.940]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:04.940]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[13:19:04.940]  - seeds: <none>
[13:19:04.940] getGlobalsAndPackages() ...
[13:19:04.940] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.941] Resolving globals: FALSE
[13:19:04.941] Tweak future expression to call with '...' arguments ...
[13:19:04.941] {
[13:19:04.941]     do.call(function(...) {
[13:19:04.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:04.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.941]             on.exit(options(oopts), add = TRUE)
[13:19:04.941]         }
[13:19:04.941]         {
[13:19:04.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:04.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.941]                 ...future.FUN(...future.X_jj, ...)
[13:19:04.941]             })
[13:19:04.941]         }
[13:19:04.941]     }, args = future.call.arguments)
[13:19:04.941] }
[13:19:04.941] Tweak future expression to call with '...' arguments ... DONE
[13:19:04.941] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:04.942] - packages: [1] ‘stats’
[13:19:04.942] getGlobalsAndPackages() ... DONE
[13:19:04.942] run() for ‘Future’ ...
[13:19:04.942] - state: ‘created’
[13:19:04.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:04.958] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:04.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:04.958]   - Field: ‘node’
[13:19:04.958]   - Field: ‘label’
[13:19:04.958]   - Field: ‘local’
[13:19:04.958]   - Field: ‘owner’
[13:19:04.959]   - Field: ‘envir’
[13:19:04.959]   - Field: ‘workers’
[13:19:04.959]   - Field: ‘packages’
[13:19:04.959]   - Field: ‘gc’
[13:19:04.959]   - Field: ‘conditions’
[13:19:04.959]   - Field: ‘persistent’
[13:19:04.959]   - Field: ‘expr’
[13:19:04.959]   - Field: ‘uuid’
[13:19:04.959]   - Field: ‘seed’
[13:19:04.959]   - Field: ‘version’
[13:19:04.959]   - Field: ‘result’
[13:19:04.960]   - Field: ‘asynchronous’
[13:19:04.960]   - Field: ‘calls’
[13:19:04.960]   - Field: ‘globals’
[13:19:04.960]   - Field: ‘stdout’
[13:19:04.960]   - Field: ‘earlySignal’
[13:19:04.960]   - Field: ‘lazy’
[13:19:04.960]   - Field: ‘state’
[13:19:04.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:04.960] - Launch lazy future ...
[13:19:04.961] Packages needed by the future expression (n = 1): ‘stats’
[13:19:04.961] Packages needed by future strategies (n = 0): <none>
[13:19:04.961] {
[13:19:04.961]     {
[13:19:04.961]         {
[13:19:04.961]             ...future.startTime <- base::Sys.time()
[13:19:04.961]             {
[13:19:04.961]                 {
[13:19:04.961]                   {
[13:19:04.961]                     {
[13:19:04.961]                       {
[13:19:04.961]                         base::local({
[13:19:04.961]                           has_future <- base::requireNamespace("future", 
[13:19:04.961]                             quietly = TRUE)
[13:19:04.961]                           if (has_future) {
[13:19:04.961]                             ns <- base::getNamespace("future")
[13:19:04.961]                             version <- ns[[".package"]][["version"]]
[13:19:04.961]                             if (is.null(version)) 
[13:19:04.961]                               version <- utils::packageVersion("future")
[13:19:04.961]                           }
[13:19:04.961]                           else {
[13:19:04.961]                             version <- NULL
[13:19:04.961]                           }
[13:19:04.961]                           if (!has_future || version < "1.8.0") {
[13:19:04.961]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:04.961]                               "", base::R.version$version.string), 
[13:19:04.961]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:04.961]                                 base::R.version$platform, 8 * 
[13:19:04.961]                                   base::.Machine$sizeof.pointer), 
[13:19:04.961]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:04.961]                                 "release", "version")], collapse = " "), 
[13:19:04.961]                               hostname = base::Sys.info()[["nodename"]])
[13:19:04.961]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:04.961]                               info)
[13:19:04.961]                             info <- base::paste(info, collapse = "; ")
[13:19:04.961]                             if (!has_future) {
[13:19:04.961]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:04.961]                                 info)
[13:19:04.961]                             }
[13:19:04.961]                             else {
[13:19:04.961]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:04.961]                                 info, version)
[13:19:04.961]                             }
[13:19:04.961]                             base::stop(msg)
[13:19:04.961]                           }
[13:19:04.961]                         })
[13:19:04.961]                       }
[13:19:04.961]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:04.961]                       base::options(mc.cores = 1L)
[13:19:04.961]                     }
[13:19:04.961]                     base::local({
[13:19:04.961]                       for (pkg in "stats") {
[13:19:04.961]                         base::loadNamespace(pkg)
[13:19:04.961]                         base::library(pkg, character.only = TRUE)
[13:19:04.961]                       }
[13:19:04.961]                     })
[13:19:04.961]                   }
[13:19:04.961]                   options(future.plan = NULL)
[13:19:04.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:04.961]                 }
[13:19:04.961]                 ...future.workdir <- getwd()
[13:19:04.961]             }
[13:19:04.961]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:04.961]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:04.961]         }
[13:19:04.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:04.961]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[13:19:04.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:04.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:04.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:04.961]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:04.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:04.961]             base::names(...future.oldOptions))
[13:19:04.961]     }
[13:19:04.961]     if (FALSE) {
[13:19:04.961]     }
[13:19:04.961]     else {
[13:19:04.961]         if (TRUE) {
[13:19:04.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:04.961]                 open = "w")
[13:19:04.961]         }
[13:19:04.961]         else {
[13:19:04.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:04.961]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:04.961]         }
[13:19:04.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:04.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:04.961]             base::sink(type = "output", split = FALSE)
[13:19:04.961]             base::close(...future.stdout)
[13:19:04.961]         }, add = TRUE)
[13:19:04.961]     }
[13:19:04.961]     ...future.frame <- base::sys.nframe()
[13:19:04.961]     ...future.conditions <- base::list()
[13:19:04.961]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:04.961]     if (FALSE) {
[13:19:04.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:04.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:04.961]     }
[13:19:04.961]     ...future.result <- base::tryCatch({
[13:19:04.961]         base::withCallingHandlers({
[13:19:04.961]             ...future.value <- base::withVisible(base::local({
[13:19:04.961]                 ...future.makeSendCondition <- local({
[13:19:04.961]                   sendCondition <- NULL
[13:19:04.961]                   function(frame = 1L) {
[13:19:04.961]                     if (is.function(sendCondition)) 
[13:19:04.961]                       return(sendCondition)
[13:19:04.961]                     ns <- getNamespace("parallel")
[13:19:04.961]                     if (exists("sendData", mode = "function", 
[13:19:04.961]                       envir = ns)) {
[13:19:04.961]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:04.961]                         envir = ns)
[13:19:04.961]                       envir <- sys.frame(frame)
[13:19:04.961]                       master <- NULL
[13:19:04.961]                       while (!identical(envir, .GlobalEnv) && 
[13:19:04.961]                         !identical(envir, emptyenv())) {
[13:19:04.961]                         if (exists("master", mode = "list", envir = envir, 
[13:19:04.961]                           inherits = FALSE)) {
[13:19:04.961]                           master <- get("master", mode = "list", 
[13:19:04.961]                             envir = envir, inherits = FALSE)
[13:19:04.961]                           if (inherits(master, c("SOCKnode", 
[13:19:04.961]                             "SOCK0node"))) {
[13:19:04.961]                             sendCondition <<- function(cond) {
[13:19:04.961]                               data <- list(type = "VALUE", value = cond, 
[13:19:04.961]                                 success = TRUE)
[13:19:04.961]                               parallel_sendData(master, data)
[13:19:04.961]                             }
[13:19:04.961]                             return(sendCondition)
[13:19:04.961]                           }
[13:19:04.961]                         }
[13:19:04.961]                         frame <- frame + 1L
[13:19:04.961]                         envir <- sys.frame(frame)
[13:19:04.961]                       }
[13:19:04.961]                     }
[13:19:04.961]                     sendCondition <<- function(cond) NULL
[13:19:04.961]                   }
[13:19:04.961]                 })
[13:19:04.961]                 withCallingHandlers({
[13:19:04.961]                   {
[13:19:04.961]                     do.call(function(...) {
[13:19:04.961]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:04.961]                       if (!identical(...future.globals.maxSize.org, 
[13:19:04.961]                         ...future.globals.maxSize)) {
[13:19:04.961]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:04.961]                         on.exit(options(oopts), add = TRUE)
[13:19:04.961]                       }
[13:19:04.961]                       {
[13:19:04.961]                         lapply(seq_along(...future.elements_ii), 
[13:19:04.961]                           FUN = function(jj) {
[13:19:04.961]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:04.961]                             ...future.FUN(...future.X_jj, ...)
[13:19:04.961]                           })
[13:19:04.961]                       }
[13:19:04.961]                     }, args = future.call.arguments)
[13:19:04.961]                   }
[13:19:04.961]                 }, immediateCondition = function(cond) {
[13:19:04.961]                   sendCondition <- ...future.makeSendCondition()
[13:19:04.961]                   sendCondition(cond)
[13:19:04.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.961]                   {
[13:19:04.961]                     inherits <- base::inherits
[13:19:04.961]                     invokeRestart <- base::invokeRestart
[13:19:04.961]                     is.null <- base::is.null
[13:19:04.961]                     muffled <- FALSE
[13:19:04.961]                     if (inherits(cond, "message")) {
[13:19:04.961]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:04.961]                       if (muffled) 
[13:19:04.961]                         invokeRestart("muffleMessage")
[13:19:04.961]                     }
[13:19:04.961]                     else if (inherits(cond, "warning")) {
[13:19:04.961]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:04.961]                       if (muffled) 
[13:19:04.961]                         invokeRestart("muffleWarning")
[13:19:04.961]                     }
[13:19:04.961]                     else if (inherits(cond, "condition")) {
[13:19:04.961]                       if (!is.null(pattern)) {
[13:19:04.961]                         computeRestarts <- base::computeRestarts
[13:19:04.961]                         grepl <- base::grepl
[13:19:04.961]                         restarts <- computeRestarts(cond)
[13:19:04.961]                         for (restart in restarts) {
[13:19:04.961]                           name <- restart$name
[13:19:04.961]                           if (is.null(name)) 
[13:19:04.961]                             next
[13:19:04.961]                           if (!grepl(pattern, name)) 
[13:19:04.961]                             next
[13:19:04.961]                           invokeRestart(restart)
[13:19:04.961]                           muffled <- TRUE
[13:19:04.961]                           break
[13:19:04.961]                         }
[13:19:04.961]                       }
[13:19:04.961]                     }
[13:19:04.961]                     invisible(muffled)
[13:19:04.961]                   }
[13:19:04.961]                   muffleCondition(cond)
[13:19:04.961]                 })
[13:19:04.961]             }))
[13:19:04.961]             future::FutureResult(value = ...future.value$value, 
[13:19:04.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.961]                   ...future.rng), globalenv = if (FALSE) 
[13:19:04.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:04.961]                     ...future.globalenv.names))
[13:19:04.961]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:04.961]         }, condition = base::local({
[13:19:04.961]             c <- base::c
[13:19:04.961]             inherits <- base::inherits
[13:19:04.961]             invokeRestart <- base::invokeRestart
[13:19:04.961]             length <- base::length
[13:19:04.961]             list <- base::list
[13:19:04.961]             seq.int <- base::seq.int
[13:19:04.961]             signalCondition <- base::signalCondition
[13:19:04.961]             sys.calls <- base::sys.calls
[13:19:04.961]             `[[` <- base::`[[`
[13:19:04.961]             `+` <- base::`+`
[13:19:04.961]             `<<-` <- base::`<<-`
[13:19:04.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:04.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:04.961]                   3L)]
[13:19:04.961]             }
[13:19:04.961]             function(cond) {
[13:19:04.961]                 is_error <- inherits(cond, "error")
[13:19:04.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:04.961]                   NULL)
[13:19:04.961]                 if (is_error) {
[13:19:04.961]                   sessionInformation <- function() {
[13:19:04.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:04.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:04.961]                       search = base::search(), system = base::Sys.info())
[13:19:04.961]                   }
[13:19:04.961]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:04.961]                     cond$call), session = sessionInformation(), 
[13:19:04.961]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:04.961]                   signalCondition(cond)
[13:19:04.961]                 }
[13:19:04.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:04.961]                 "immediateCondition"))) {
[13:19:04.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:04.961]                   ...future.conditions[[length(...future.conditions) + 
[13:19:04.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:04.961]                   if (TRUE && !signal) {
[13:19:04.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.961]                     {
[13:19:04.961]                       inherits <- base::inherits
[13:19:04.961]                       invokeRestart <- base::invokeRestart
[13:19:04.961]                       is.null <- base::is.null
[13:19:04.961]                       muffled <- FALSE
[13:19:04.961]                       if (inherits(cond, "message")) {
[13:19:04.961]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.961]                         if (muffled) 
[13:19:04.961]                           invokeRestart("muffleMessage")
[13:19:04.961]                       }
[13:19:04.961]                       else if (inherits(cond, "warning")) {
[13:19:04.961]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.961]                         if (muffled) 
[13:19:04.961]                           invokeRestart("muffleWarning")
[13:19:04.961]                       }
[13:19:04.961]                       else if (inherits(cond, "condition")) {
[13:19:04.961]                         if (!is.null(pattern)) {
[13:19:04.961]                           computeRestarts <- base::computeRestarts
[13:19:04.961]                           grepl <- base::grepl
[13:19:04.961]                           restarts <- computeRestarts(cond)
[13:19:04.961]                           for (restart in restarts) {
[13:19:04.961]                             name <- restart$name
[13:19:04.961]                             if (is.null(name)) 
[13:19:04.961]                               next
[13:19:04.961]                             if (!grepl(pattern, name)) 
[13:19:04.961]                               next
[13:19:04.961]                             invokeRestart(restart)
[13:19:04.961]                             muffled <- TRUE
[13:19:04.961]                             break
[13:19:04.961]                           }
[13:19:04.961]                         }
[13:19:04.961]                       }
[13:19:04.961]                       invisible(muffled)
[13:19:04.961]                     }
[13:19:04.961]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.961]                   }
[13:19:04.961]                 }
[13:19:04.961]                 else {
[13:19:04.961]                   if (TRUE) {
[13:19:04.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:04.961]                     {
[13:19:04.961]                       inherits <- base::inherits
[13:19:04.961]                       invokeRestart <- base::invokeRestart
[13:19:04.961]                       is.null <- base::is.null
[13:19:04.961]                       muffled <- FALSE
[13:19:04.961]                       if (inherits(cond, "message")) {
[13:19:04.961]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:04.961]                         if (muffled) 
[13:19:04.961]                           invokeRestart("muffleMessage")
[13:19:04.961]                       }
[13:19:04.961]                       else if (inherits(cond, "warning")) {
[13:19:04.961]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:04.961]                         if (muffled) 
[13:19:04.961]                           invokeRestart("muffleWarning")
[13:19:04.961]                       }
[13:19:04.961]                       else if (inherits(cond, "condition")) {
[13:19:04.961]                         if (!is.null(pattern)) {
[13:19:04.961]                           computeRestarts <- base::computeRestarts
[13:19:04.961]                           grepl <- base::grepl
[13:19:04.961]                           restarts <- computeRestarts(cond)
[13:19:04.961]                           for (restart in restarts) {
[13:19:04.961]                             name <- restart$name
[13:19:04.961]                             if (is.null(name)) 
[13:19:04.961]                               next
[13:19:04.961]                             if (!grepl(pattern, name)) 
[13:19:04.961]                               next
[13:19:04.961]                             invokeRestart(restart)
[13:19:04.961]                             muffled <- TRUE
[13:19:04.961]                             break
[13:19:04.961]                           }
[13:19:04.961]                         }
[13:19:04.961]                       }
[13:19:04.961]                       invisible(muffled)
[13:19:04.961]                     }
[13:19:04.961]                     muffleCondition(cond, pattern = "^muffle")
[13:19:04.961]                   }
[13:19:04.961]                 }
[13:19:04.961]             }
[13:19:04.961]         }))
[13:19:04.961]     }, error = function(ex) {
[13:19:04.961]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:04.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:04.961]                 ...future.rng), started = ...future.startTime, 
[13:19:04.961]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:04.961]             version = "1.8"), class = "FutureResult")
[13:19:04.961]     }, finally = {
[13:19:04.961]         if (!identical(...future.workdir, getwd())) 
[13:19:04.961]             setwd(...future.workdir)
[13:19:04.961]         {
[13:19:04.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:04.961]                 ...future.oldOptions$nwarnings <- NULL
[13:19:04.961]             }
[13:19:04.961]             base::options(...future.oldOptions)
[13:19:04.961]             if (.Platform$OS.type == "windows") {
[13:19:04.961]                 old_names <- names(...future.oldEnvVars)
[13:19:04.961]                 envs <- base::Sys.getenv()
[13:19:04.961]                 names <- names(envs)
[13:19:04.961]                 common <- intersect(names, old_names)
[13:19:04.961]                 added <- setdiff(names, old_names)
[13:19:04.961]                 removed <- setdiff(old_names, names)
[13:19:04.961]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:04.961]                   envs[common]]
[13:19:04.961]                 NAMES <- toupper(changed)
[13:19:04.961]                 args <- list()
[13:19:04.961]                 for (kk in seq_along(NAMES)) {
[13:19:04.961]                   name <- changed[[kk]]
[13:19:04.961]                   NAME <- NAMES[[kk]]
[13:19:04.961]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.961]                     next
[13:19:04.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.961]                 }
[13:19:04.961]                 NAMES <- toupper(added)
[13:19:04.961]                 for (kk in seq_along(NAMES)) {
[13:19:04.961]                   name <- added[[kk]]
[13:19:04.961]                   NAME <- NAMES[[kk]]
[13:19:04.961]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.961]                     next
[13:19:04.961]                   args[[name]] <- ""
[13:19:04.961]                 }
[13:19:04.961]                 NAMES <- toupper(removed)
[13:19:04.961]                 for (kk in seq_along(NAMES)) {
[13:19:04.961]                   name <- removed[[kk]]
[13:19:04.961]                   NAME <- NAMES[[kk]]
[13:19:04.961]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:04.961]                     next
[13:19:04.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:04.961]                 }
[13:19:04.961]                 if (length(args) > 0) 
[13:19:04.961]                   base::do.call(base::Sys.setenv, args = args)
[13:19:04.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:04.961]             }
[13:19:04.961]             else {
[13:19:04.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:04.961]             }
[13:19:04.961]             {
[13:19:04.961]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:04.961]                   0L) {
[13:19:04.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:04.961]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:04.961]                   base::options(opts)
[13:19:04.961]                 }
[13:19:04.961]                 {
[13:19:04.961]                   {
[13:19:04.961]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:04.961]                     NULL
[13:19:04.961]                   }
[13:19:04.961]                   options(future.plan = NULL)
[13:19:04.961]                   if (is.na(NA_character_)) 
[13:19:04.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:04.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:04.961]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:04.961]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:04.961]                     envir = parent.frame()) 
[13:19:04.961]                   {
[13:19:04.961]                     if (is.function(workers)) 
[13:19:04.961]                       workers <- workers()
[13:19:04.961]                     workers <- structure(as.integer(workers), 
[13:19:04.961]                       class = class(workers))
[13:19:04.961]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:04.961]                       workers >= 1)
[13:19:04.961]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:04.961]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:04.961]                     }
[13:19:04.961]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:04.961]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:04.961]                       envir = envir)
[13:19:04.961]                     if (!future$lazy) 
[13:19:04.961]                       future <- run(future)
[13:19:04.961]                     invisible(future)
[13:19:04.961]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:04.961]                 }
[13:19:04.961]             }
[13:19:04.961]         }
[13:19:04.961]     })
[13:19:04.961]     if (TRUE) {
[13:19:04.961]         base::sink(type = "output", split = FALSE)
[13:19:04.961]         if (TRUE) {
[13:19:04.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:04.961]         }
[13:19:04.961]         else {
[13:19:04.961]             ...future.result["stdout"] <- base::list(NULL)
[13:19:04.961]         }
[13:19:04.961]         base::close(...future.stdout)
[13:19:04.961]         ...future.stdout <- NULL
[13:19:04.961]     }
[13:19:04.961]     ...future.result$conditions <- ...future.conditions
[13:19:04.961]     ...future.result$finished <- base::Sys.time()
[13:19:04.961]     ...future.result
[13:19:04.961] }
[13:19:04.964] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[13:19:04.964] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[13:19:05.009] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[13:19:05.009] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:05.010] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.010] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[13:19:05.010] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[13:19:05.010] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:05.011] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.011] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:05.011] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.011] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[13:19:05.012] MultisessionFuture started
[13:19:05.012] - Launch lazy future ... done
[13:19:05.012] run() for ‘MultisessionFuture’ ... done
[13:19:05.012] Created future:
[13:19:05.012] MultisessionFuture:
[13:19:05.012] Label: ‘future_sapply-1’
[13:19:05.012] Expression:
[13:19:05.012] {
[13:19:05.012]     do.call(function(...) {
[13:19:05.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.012]             on.exit(options(oopts), add = TRUE)
[13:19:05.012]         }
[13:19:05.012]         {
[13:19:05.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.012]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.012]             })
[13:19:05.012]         }
[13:19:05.012]     }, args = future.call.arguments)
[13:19:05.012] }
[13:19:05.012] Lazy evaluation: FALSE
[13:19:05.012] Asynchronous evaluation: TRUE
[13:19:05.012] Local evaluation: TRUE
[13:19:05.012] Environment: R_GlobalEnv
[13:19:05.012] Capture standard output: TRUE
[13:19:05.012] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.012] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:05.012] Packages: 1 packages (‘stats’)
[13:19:05.012] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.012] Resolved: FALSE
[13:19:05.012] Value: <not collected>
[13:19:05.012] Conditions captured: <none>
[13:19:05.012] Early signaling: FALSE
[13:19:05.012] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.012] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.024] Chunk #1 of 2 ... DONE
[13:19:05.024] Chunk #2 of 2 ...
[13:19:05.024]  - Finding globals in 'X' for chunk #2 ...
[13:19:05.024] getGlobalsAndPackages() ...
[13:19:05.025] Searching for globals...
[13:19:05.025] 
[13:19:05.025] Searching for globals ... DONE
[13:19:05.025] - globals: [0] <none>
[13:19:05.025] getGlobalsAndPackages() ... DONE
[13:19:05.025]    + additional globals found: [n=0] 
[13:19:05.025]    + additional namespaces needed: [n=0] 
[13:19:05.025]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:05.026]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:19:05.026]  - seeds: <none>
[13:19:05.026] getGlobalsAndPackages() ...
[13:19:05.026] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.026] Resolving globals: FALSE
[13:19:05.026] Tweak future expression to call with '...' arguments ...
[13:19:05.026] {
[13:19:05.026]     do.call(function(...) {
[13:19:05.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.026]             on.exit(options(oopts), add = TRUE)
[13:19:05.026]         }
[13:19:05.026]         {
[13:19:05.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.026]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.026]             })
[13:19:05.026]         }
[13:19:05.026]     }, args = future.call.arguments)
[13:19:05.026] }
[13:19:05.026] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.027] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.027] - packages: [1] ‘stats’
[13:19:05.027] getGlobalsAndPackages() ... DONE
[13:19:05.027] run() for ‘Future’ ...
[13:19:05.028] - state: ‘created’
[13:19:05.028] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:05.045] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:05.045]   - Field: ‘node’
[13:19:05.045]   - Field: ‘label’
[13:19:05.045]   - Field: ‘local’
[13:19:05.045]   - Field: ‘owner’
[13:19:05.045]   - Field: ‘envir’
[13:19:05.046]   - Field: ‘workers’
[13:19:05.046]   - Field: ‘packages’
[13:19:05.048]   - Field: ‘gc’
[13:19:05.048]   - Field: ‘conditions’
[13:19:05.048]   - Field: ‘persistent’
[13:19:05.048]   - Field: ‘expr’
[13:19:05.048]   - Field: ‘uuid’
[13:19:05.048]   - Field: ‘seed’
[13:19:05.049]   - Field: ‘version’
[13:19:05.049]   - Field: ‘result’
[13:19:05.049]   - Field: ‘asynchronous’
[13:19:05.049]   - Field: ‘calls’
[13:19:05.049]   - Field: ‘globals’
[13:19:05.049]   - Field: ‘stdout’
[13:19:05.049]   - Field: ‘earlySignal’
[13:19:05.049]   - Field: ‘lazy’
[13:19:05.049]   - Field: ‘state’
[13:19:05.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:05.049] - Launch lazy future ...
[13:19:05.050] Packages needed by the future expression (n = 1): ‘stats’
[13:19:05.050] Packages needed by future strategies (n = 0): <none>
[13:19:05.050] {
[13:19:05.050]     {
[13:19:05.050]         {
[13:19:05.050]             ...future.startTime <- base::Sys.time()
[13:19:05.050]             {
[13:19:05.050]                 {
[13:19:05.050]                   {
[13:19:05.050]                     {
[13:19:05.050]                       {
[13:19:05.050]                         base::local({
[13:19:05.050]                           has_future <- base::requireNamespace("future", 
[13:19:05.050]                             quietly = TRUE)
[13:19:05.050]                           if (has_future) {
[13:19:05.050]                             ns <- base::getNamespace("future")
[13:19:05.050]                             version <- ns[[".package"]][["version"]]
[13:19:05.050]                             if (is.null(version)) 
[13:19:05.050]                               version <- utils::packageVersion("future")
[13:19:05.050]                           }
[13:19:05.050]                           else {
[13:19:05.050]                             version <- NULL
[13:19:05.050]                           }
[13:19:05.050]                           if (!has_future || version < "1.8.0") {
[13:19:05.050]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:05.050]                               "", base::R.version$version.string), 
[13:19:05.050]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:05.050]                                 base::R.version$platform, 8 * 
[13:19:05.050]                                   base::.Machine$sizeof.pointer), 
[13:19:05.050]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:05.050]                                 "release", "version")], collapse = " "), 
[13:19:05.050]                               hostname = base::Sys.info()[["nodename"]])
[13:19:05.050]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:05.050]                               info)
[13:19:05.050]                             info <- base::paste(info, collapse = "; ")
[13:19:05.050]                             if (!has_future) {
[13:19:05.050]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:05.050]                                 info)
[13:19:05.050]                             }
[13:19:05.050]                             else {
[13:19:05.050]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:05.050]                                 info, version)
[13:19:05.050]                             }
[13:19:05.050]                             base::stop(msg)
[13:19:05.050]                           }
[13:19:05.050]                         })
[13:19:05.050]                       }
[13:19:05.050]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:05.050]                       base::options(mc.cores = 1L)
[13:19:05.050]                     }
[13:19:05.050]                     base::local({
[13:19:05.050]                       for (pkg in "stats") {
[13:19:05.050]                         base::loadNamespace(pkg)
[13:19:05.050]                         base::library(pkg, character.only = TRUE)
[13:19:05.050]                       }
[13:19:05.050]                     })
[13:19:05.050]                   }
[13:19:05.050]                   options(future.plan = NULL)
[13:19:05.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:05.050]                 }
[13:19:05.050]                 ...future.workdir <- getwd()
[13:19:05.050]             }
[13:19:05.050]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:05.050]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:05.050]         }
[13:19:05.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:05.050]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:19:05.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:05.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:05.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:05.050]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:05.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:05.050]             base::names(...future.oldOptions))
[13:19:05.050]     }
[13:19:05.050]     if (FALSE) {
[13:19:05.050]     }
[13:19:05.050]     else {
[13:19:05.050]         if (TRUE) {
[13:19:05.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:05.050]                 open = "w")
[13:19:05.050]         }
[13:19:05.050]         else {
[13:19:05.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:05.050]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:05.050]         }
[13:19:05.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:05.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:05.050]             base::sink(type = "output", split = FALSE)
[13:19:05.050]             base::close(...future.stdout)
[13:19:05.050]         }, add = TRUE)
[13:19:05.050]     }
[13:19:05.050]     ...future.frame <- base::sys.nframe()
[13:19:05.050]     ...future.conditions <- base::list()
[13:19:05.050]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:05.050]     if (FALSE) {
[13:19:05.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:05.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:05.050]     }
[13:19:05.050]     ...future.result <- base::tryCatch({
[13:19:05.050]         base::withCallingHandlers({
[13:19:05.050]             ...future.value <- base::withVisible(base::local({
[13:19:05.050]                 ...future.makeSendCondition <- local({
[13:19:05.050]                   sendCondition <- NULL
[13:19:05.050]                   function(frame = 1L) {
[13:19:05.050]                     if (is.function(sendCondition)) 
[13:19:05.050]                       return(sendCondition)
[13:19:05.050]                     ns <- getNamespace("parallel")
[13:19:05.050]                     if (exists("sendData", mode = "function", 
[13:19:05.050]                       envir = ns)) {
[13:19:05.050]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:05.050]                         envir = ns)
[13:19:05.050]                       envir <- sys.frame(frame)
[13:19:05.050]                       master <- NULL
[13:19:05.050]                       while (!identical(envir, .GlobalEnv) && 
[13:19:05.050]                         !identical(envir, emptyenv())) {
[13:19:05.050]                         if (exists("master", mode = "list", envir = envir, 
[13:19:05.050]                           inherits = FALSE)) {
[13:19:05.050]                           master <- get("master", mode = "list", 
[13:19:05.050]                             envir = envir, inherits = FALSE)
[13:19:05.050]                           if (inherits(master, c("SOCKnode", 
[13:19:05.050]                             "SOCK0node"))) {
[13:19:05.050]                             sendCondition <<- function(cond) {
[13:19:05.050]                               data <- list(type = "VALUE", value = cond, 
[13:19:05.050]                                 success = TRUE)
[13:19:05.050]                               parallel_sendData(master, data)
[13:19:05.050]                             }
[13:19:05.050]                             return(sendCondition)
[13:19:05.050]                           }
[13:19:05.050]                         }
[13:19:05.050]                         frame <- frame + 1L
[13:19:05.050]                         envir <- sys.frame(frame)
[13:19:05.050]                       }
[13:19:05.050]                     }
[13:19:05.050]                     sendCondition <<- function(cond) NULL
[13:19:05.050]                   }
[13:19:05.050]                 })
[13:19:05.050]                 withCallingHandlers({
[13:19:05.050]                   {
[13:19:05.050]                     do.call(function(...) {
[13:19:05.050]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.050]                       if (!identical(...future.globals.maxSize.org, 
[13:19:05.050]                         ...future.globals.maxSize)) {
[13:19:05.050]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.050]                         on.exit(options(oopts), add = TRUE)
[13:19:05.050]                       }
[13:19:05.050]                       {
[13:19:05.050]                         lapply(seq_along(...future.elements_ii), 
[13:19:05.050]                           FUN = function(jj) {
[13:19:05.050]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.050]                             ...future.FUN(...future.X_jj, ...)
[13:19:05.050]                           })
[13:19:05.050]                       }
[13:19:05.050]                     }, args = future.call.arguments)
[13:19:05.050]                   }
[13:19:05.050]                 }, immediateCondition = function(cond) {
[13:19:05.050]                   sendCondition <- ...future.makeSendCondition()
[13:19:05.050]                   sendCondition(cond)
[13:19:05.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.050]                   {
[13:19:05.050]                     inherits <- base::inherits
[13:19:05.050]                     invokeRestart <- base::invokeRestart
[13:19:05.050]                     is.null <- base::is.null
[13:19:05.050]                     muffled <- FALSE
[13:19:05.050]                     if (inherits(cond, "message")) {
[13:19:05.050]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:05.050]                       if (muffled) 
[13:19:05.050]                         invokeRestart("muffleMessage")
[13:19:05.050]                     }
[13:19:05.050]                     else if (inherits(cond, "warning")) {
[13:19:05.050]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:05.050]                       if (muffled) 
[13:19:05.050]                         invokeRestart("muffleWarning")
[13:19:05.050]                     }
[13:19:05.050]                     else if (inherits(cond, "condition")) {
[13:19:05.050]                       if (!is.null(pattern)) {
[13:19:05.050]                         computeRestarts <- base::computeRestarts
[13:19:05.050]                         grepl <- base::grepl
[13:19:05.050]                         restarts <- computeRestarts(cond)
[13:19:05.050]                         for (restart in restarts) {
[13:19:05.050]                           name <- restart$name
[13:19:05.050]                           if (is.null(name)) 
[13:19:05.050]                             next
[13:19:05.050]                           if (!grepl(pattern, name)) 
[13:19:05.050]                             next
[13:19:05.050]                           invokeRestart(restart)
[13:19:05.050]                           muffled <- TRUE
[13:19:05.050]                           break
[13:19:05.050]                         }
[13:19:05.050]                       }
[13:19:05.050]                     }
[13:19:05.050]                     invisible(muffled)
[13:19:05.050]                   }
[13:19:05.050]                   muffleCondition(cond)
[13:19:05.050]                 })
[13:19:05.050]             }))
[13:19:05.050]             future::FutureResult(value = ...future.value$value, 
[13:19:05.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.050]                   ...future.rng), globalenv = if (FALSE) 
[13:19:05.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:05.050]                     ...future.globalenv.names))
[13:19:05.050]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:05.050]         }, condition = base::local({
[13:19:05.050]             c <- base::c
[13:19:05.050]             inherits <- base::inherits
[13:19:05.050]             invokeRestart <- base::invokeRestart
[13:19:05.050]             length <- base::length
[13:19:05.050]             list <- base::list
[13:19:05.050]             seq.int <- base::seq.int
[13:19:05.050]             signalCondition <- base::signalCondition
[13:19:05.050]             sys.calls <- base::sys.calls
[13:19:05.050]             `[[` <- base::`[[`
[13:19:05.050]             `+` <- base::`+`
[13:19:05.050]             `<<-` <- base::`<<-`
[13:19:05.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:05.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:05.050]                   3L)]
[13:19:05.050]             }
[13:19:05.050]             function(cond) {
[13:19:05.050]                 is_error <- inherits(cond, "error")
[13:19:05.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:05.050]                   NULL)
[13:19:05.050]                 if (is_error) {
[13:19:05.050]                   sessionInformation <- function() {
[13:19:05.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:05.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:05.050]                       search = base::search(), system = base::Sys.info())
[13:19:05.050]                   }
[13:19:05.050]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:05.050]                     cond$call), session = sessionInformation(), 
[13:19:05.050]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:05.050]                   signalCondition(cond)
[13:19:05.050]                 }
[13:19:05.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:05.050]                 "immediateCondition"))) {
[13:19:05.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:05.050]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:05.050]                   if (TRUE && !signal) {
[13:19:05.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.050]                     {
[13:19:05.050]                       inherits <- base::inherits
[13:19:05.050]                       invokeRestart <- base::invokeRestart
[13:19:05.050]                       is.null <- base::is.null
[13:19:05.050]                       muffled <- FALSE
[13:19:05.050]                       if (inherits(cond, "message")) {
[13:19:05.050]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.050]                         if (muffled) 
[13:19:05.050]                           invokeRestart("muffleMessage")
[13:19:05.050]                       }
[13:19:05.050]                       else if (inherits(cond, "warning")) {
[13:19:05.050]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.050]                         if (muffled) 
[13:19:05.050]                           invokeRestart("muffleWarning")
[13:19:05.050]                       }
[13:19:05.050]                       else if (inherits(cond, "condition")) {
[13:19:05.050]                         if (!is.null(pattern)) {
[13:19:05.050]                           computeRestarts <- base::computeRestarts
[13:19:05.050]                           grepl <- base::grepl
[13:19:05.050]                           restarts <- computeRestarts(cond)
[13:19:05.050]                           for (restart in restarts) {
[13:19:05.050]                             name <- restart$name
[13:19:05.050]                             if (is.null(name)) 
[13:19:05.050]                               next
[13:19:05.050]                             if (!grepl(pattern, name)) 
[13:19:05.050]                               next
[13:19:05.050]                             invokeRestart(restart)
[13:19:05.050]                             muffled <- TRUE
[13:19:05.050]                             break
[13:19:05.050]                           }
[13:19:05.050]                         }
[13:19:05.050]                       }
[13:19:05.050]                       invisible(muffled)
[13:19:05.050]                     }
[13:19:05.050]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.050]                   }
[13:19:05.050]                 }
[13:19:05.050]                 else {
[13:19:05.050]                   if (TRUE) {
[13:19:05.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.050]                     {
[13:19:05.050]                       inherits <- base::inherits
[13:19:05.050]                       invokeRestart <- base::invokeRestart
[13:19:05.050]                       is.null <- base::is.null
[13:19:05.050]                       muffled <- FALSE
[13:19:05.050]                       if (inherits(cond, "message")) {
[13:19:05.050]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.050]                         if (muffled) 
[13:19:05.050]                           invokeRestart("muffleMessage")
[13:19:05.050]                       }
[13:19:05.050]                       else if (inherits(cond, "warning")) {
[13:19:05.050]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.050]                         if (muffled) 
[13:19:05.050]                           invokeRestart("muffleWarning")
[13:19:05.050]                       }
[13:19:05.050]                       else if (inherits(cond, "condition")) {
[13:19:05.050]                         if (!is.null(pattern)) {
[13:19:05.050]                           computeRestarts <- base::computeRestarts
[13:19:05.050]                           grepl <- base::grepl
[13:19:05.050]                           restarts <- computeRestarts(cond)
[13:19:05.050]                           for (restart in restarts) {
[13:19:05.050]                             name <- restart$name
[13:19:05.050]                             if (is.null(name)) 
[13:19:05.050]                               next
[13:19:05.050]                             if (!grepl(pattern, name)) 
[13:19:05.050]                               next
[13:19:05.050]                             invokeRestart(restart)
[13:19:05.050]                             muffled <- TRUE
[13:19:05.050]                             break
[13:19:05.050]                           }
[13:19:05.050]                         }
[13:19:05.050]                       }
[13:19:05.050]                       invisible(muffled)
[13:19:05.050]                     }
[13:19:05.050]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.050]                   }
[13:19:05.050]                 }
[13:19:05.050]             }
[13:19:05.050]         }))
[13:19:05.050]     }, error = function(ex) {
[13:19:05.050]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:05.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.050]                 ...future.rng), started = ...future.startTime, 
[13:19:05.050]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:05.050]             version = "1.8"), class = "FutureResult")
[13:19:05.050]     }, finally = {
[13:19:05.050]         if (!identical(...future.workdir, getwd())) 
[13:19:05.050]             setwd(...future.workdir)
[13:19:05.050]         {
[13:19:05.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:05.050]                 ...future.oldOptions$nwarnings <- NULL
[13:19:05.050]             }
[13:19:05.050]             base::options(...future.oldOptions)
[13:19:05.050]             if (.Platform$OS.type == "windows") {
[13:19:05.050]                 old_names <- names(...future.oldEnvVars)
[13:19:05.050]                 envs <- base::Sys.getenv()
[13:19:05.050]                 names <- names(envs)
[13:19:05.050]                 common <- intersect(names, old_names)
[13:19:05.050]                 added <- setdiff(names, old_names)
[13:19:05.050]                 removed <- setdiff(old_names, names)
[13:19:05.050]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:05.050]                   envs[common]]
[13:19:05.050]                 NAMES <- toupper(changed)
[13:19:05.050]                 args <- list()
[13:19:05.050]                 for (kk in seq_along(NAMES)) {
[13:19:05.050]                   name <- changed[[kk]]
[13:19:05.050]                   NAME <- NAMES[[kk]]
[13:19:05.050]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.050]                     next
[13:19:05.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.050]                 }
[13:19:05.050]                 NAMES <- toupper(added)
[13:19:05.050]                 for (kk in seq_along(NAMES)) {
[13:19:05.050]                   name <- added[[kk]]
[13:19:05.050]                   NAME <- NAMES[[kk]]
[13:19:05.050]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.050]                     next
[13:19:05.050]                   args[[name]] <- ""
[13:19:05.050]                 }
[13:19:05.050]                 NAMES <- toupper(removed)
[13:19:05.050]                 for (kk in seq_along(NAMES)) {
[13:19:05.050]                   name <- removed[[kk]]
[13:19:05.050]                   NAME <- NAMES[[kk]]
[13:19:05.050]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.050]                     next
[13:19:05.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.050]                 }
[13:19:05.050]                 if (length(args) > 0) 
[13:19:05.050]                   base::do.call(base::Sys.setenv, args = args)
[13:19:05.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:05.050]             }
[13:19:05.050]             else {
[13:19:05.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:05.050]             }
[13:19:05.050]             {
[13:19:05.050]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:05.050]                   0L) {
[13:19:05.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:05.050]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:05.050]                   base::options(opts)
[13:19:05.050]                 }
[13:19:05.050]                 {
[13:19:05.050]                   {
[13:19:05.050]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:05.050]                     NULL
[13:19:05.050]                   }
[13:19:05.050]                   options(future.plan = NULL)
[13:19:05.050]                   if (is.na(NA_character_)) 
[13:19:05.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:05.050]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:05.050]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:05.050]                     envir = parent.frame()) 
[13:19:05.050]                   {
[13:19:05.050]                     if (is.function(workers)) 
[13:19:05.050]                       workers <- workers()
[13:19:05.050]                     workers <- structure(as.integer(workers), 
[13:19:05.050]                       class = class(workers))
[13:19:05.050]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:05.050]                       workers >= 1)
[13:19:05.050]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:05.050]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:05.050]                     }
[13:19:05.050]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:05.050]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:05.050]                       envir = envir)
[13:19:05.050]                     if (!future$lazy) 
[13:19:05.050]                       future <- run(future)
[13:19:05.050]                     invisible(future)
[13:19:05.050]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:05.050]                 }
[13:19:05.050]             }
[13:19:05.050]         }
[13:19:05.050]     })
[13:19:05.050]     if (TRUE) {
[13:19:05.050]         base::sink(type = "output", split = FALSE)
[13:19:05.050]         if (TRUE) {
[13:19:05.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:05.050]         }
[13:19:05.050]         else {
[13:19:05.050]             ...future.result["stdout"] <- base::list(NULL)
[13:19:05.050]         }
[13:19:05.050]         base::close(...future.stdout)
[13:19:05.050]         ...future.stdout <- NULL
[13:19:05.050]     }
[13:19:05.050]     ...future.result$conditions <- ...future.conditions
[13:19:05.050]     ...future.result$finished <- base::Sys.time()
[13:19:05.050]     ...future.result
[13:19:05.050] }
[13:19:05.053] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[13:19:05.054] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[13:19:05.101] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[13:19:05.101] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:05.102] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.102] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[13:19:05.102] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[13:19:05.103] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:05.103] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.103] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:05.103] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.104] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[13:19:05.104] MultisessionFuture started
[13:19:05.104] - Launch lazy future ... done
[13:19:05.105] run() for ‘MultisessionFuture’ ... done
[13:19:05.105] Created future:
[13:19:05.105] MultisessionFuture:
[13:19:05.105] Label: ‘future_sapply-2’
[13:19:05.105] Expression:
[13:19:05.105] {
[13:19:05.105]     do.call(function(...) {
[13:19:05.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.105]             on.exit(options(oopts), add = TRUE)
[13:19:05.105]         }
[13:19:05.105]         {
[13:19:05.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.105]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.105]             })
[13:19:05.105]         }
[13:19:05.105]     }, args = future.call.arguments)
[13:19:05.105] }
[13:19:05.105] Lazy evaluation: FALSE
[13:19:05.105] Asynchronous evaluation: TRUE
[13:19:05.105] Local evaluation: TRUE
[13:19:05.105] Environment: R_GlobalEnv
[13:19:05.105] Capture standard output: TRUE
[13:19:05.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.105] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:05.105] Packages: 1 packages (‘stats’)
[13:19:05.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.105] Resolved: FALSE
[13:19:05.105] Value: <not collected>
[13:19:05.105] Conditions captured: <none>
[13:19:05.105] Early signaling: FALSE
[13:19:05.105] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.105] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.117] Chunk #2 of 2 ... DONE
[13:19:05.117] Launching 2 futures (chunks) ... DONE
[13:19:05.117] Resolving 2 futures (chunks) ...
[13:19:05.117] resolve() on list ...
[13:19:05.117]  recursive: 0
[13:19:05.117]  length: 2
[13:19:05.117] 
[13:19:05.118] receiveMessageFromWorker() for ClusterFuture ...
[13:19:05.118] - Validating connection of MultisessionFuture
[13:19:05.118] - received message: FutureResult
[13:19:05.118] - Received FutureResult
[13:19:05.118] - Erased future from FutureRegistry
[13:19:05.119] result() for ClusterFuture ...
[13:19:05.119] - result already collected: FutureResult
[13:19:05.119] result() for ClusterFuture ... done
[13:19:05.119] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:05.119] Future #1
[13:19:05.119] result() for ClusterFuture ...
[13:19:05.119] - result already collected: FutureResult
[13:19:05.119] result() for ClusterFuture ... done
[13:19:05.119] result() for ClusterFuture ...
[13:19:05.119] - result already collected: FutureResult
[13:19:05.119] result() for ClusterFuture ... done
[13:19:05.120] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:05.120] - nx: 2
[13:19:05.120] - relay: TRUE
[13:19:05.120] - stdout: TRUE
[13:19:05.120] - signal: TRUE
[13:19:05.120] - resignal: FALSE
[13:19:05.120] - force: TRUE
[13:19:05.120] - relayed: [n=2] FALSE, FALSE
[13:19:05.120] - queued futures: [n=2] FALSE, FALSE
[13:19:05.120]  - until=1
[13:19:05.120]  - relaying element #1
[13:19:05.120] result() for ClusterFuture ...
[13:19:05.121] - result already collected: FutureResult
[13:19:05.121] result() for ClusterFuture ... done
[13:19:05.121] result() for ClusterFuture ...
[13:19:05.121] - result already collected: FutureResult
[13:19:05.121] result() for ClusterFuture ... done
[13:19:05.121] result() for ClusterFuture ...
[13:19:05.121] - result already collected: FutureResult
[13:19:05.121] result() for ClusterFuture ... done
[13:19:05.121] result() for ClusterFuture ...
[13:19:05.121] - result already collected: FutureResult
[13:19:05.121] result() for ClusterFuture ... done
[13:19:05.122] - relayed: [n=2] TRUE, FALSE
[13:19:05.122] - queued futures: [n=2] TRUE, FALSE
[13:19:05.122] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:05.122]  length: 1 (resolved future 1)
[13:19:05.150] receiveMessageFromWorker() for ClusterFuture ...
[13:19:05.150] - Validating connection of MultisessionFuture
[13:19:05.150] - received message: FutureResult
[13:19:05.151] - Received FutureResult
[13:19:05.151] - Erased future from FutureRegistry
[13:19:05.151] result() for ClusterFuture ...
[13:19:05.151] - result already collected: FutureResult
[13:19:05.151] result() for ClusterFuture ... done
[13:19:05.151] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:05.151] Future #2
[13:19:05.151] result() for ClusterFuture ...
[13:19:05.151] - result already collected: FutureResult
[13:19:05.151] result() for ClusterFuture ... done
[13:19:05.152] result() for ClusterFuture ...
[13:19:05.152] - result already collected: FutureResult
[13:19:05.152] result() for ClusterFuture ... done
[13:19:05.152] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:05.152] - nx: 2
[13:19:05.152] - relay: TRUE
[13:19:05.152] - stdout: TRUE
[13:19:05.152] - signal: TRUE
[13:19:05.152] - resignal: FALSE
[13:19:05.152] - force: TRUE
[13:19:05.152] - relayed: [n=2] TRUE, FALSE
[13:19:05.152] - queued futures: [n=2] TRUE, FALSE
[13:19:05.153]  - until=2
[13:19:05.153]  - relaying element #2
[13:19:05.153] result() for ClusterFuture ...
[13:19:05.153] - result already collected: FutureResult
[13:19:05.153] result() for ClusterFuture ... done
[13:19:05.153] result() for ClusterFuture ...
[13:19:05.153] - result already collected: FutureResult
[13:19:05.153] result() for ClusterFuture ... done
[13:19:05.153] result() for ClusterFuture ...
[13:19:05.154] - result already collected: FutureResult
[13:19:05.154] result() for ClusterFuture ... done
[13:19:05.154] result() for ClusterFuture ...
[13:19:05.154] - result already collected: FutureResult
[13:19:05.154] result() for ClusterFuture ... done
[13:19:05.154] - relayed: [n=2] TRUE, TRUE
[13:19:05.154] - queued futures: [n=2] TRUE, TRUE
[13:19:05.154] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:05.154]  length: 0 (resolved future 2)
[13:19:05.154] Relaying remaining futures
[13:19:05.154] signalConditionsASAP(NULL, pos=0) ...
[13:19:05.155] - nx: 2
[13:19:05.155] - relay: TRUE
[13:19:05.155] - stdout: TRUE
[13:19:05.155] - signal: TRUE
[13:19:05.155] - resignal: FALSE
[13:19:05.155] - force: TRUE
[13:19:05.155] - relayed: [n=2] TRUE, TRUE
[13:19:05.155] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:05.155] - relayed: [n=2] TRUE, TRUE
[13:19:05.155] - queued futures: [n=2] TRUE, TRUE
[13:19:05.155] signalConditionsASAP(NULL, pos=0) ... done
[13:19:05.155] resolve() on list ... DONE
[13:19:05.156] result() for ClusterFuture ...
[13:19:05.156] - result already collected: FutureResult
[13:19:05.156] result() for ClusterFuture ... done
[13:19:05.156] result() for ClusterFuture ...
[13:19:05.156] - result already collected: FutureResult
[13:19:05.156] result() for ClusterFuture ... done
[13:19:05.156] result() for ClusterFuture ...
[13:19:05.156] - result already collected: FutureResult
[13:19:05.156] result() for ClusterFuture ... done
[13:19:05.156] result() for ClusterFuture ...
[13:19:05.156] - result already collected: FutureResult
[13:19:05.156] result() for ClusterFuture ... done
[13:19:05.157]  - Number of value chunks collected: 2
[13:19:05.157] Resolving 2 futures (chunks) ... DONE
[13:19:05.157] Reducing values from 2 chunks ...
[13:19:05.157]  - Number of values collected after concatenation: 7
[13:19:05.157]  - Number of values expected: 7
[13:19:05.157] Reducing values from 2 chunks ... DONE
[13:19:05.157] future_lapply() ... DONE
[13:19:05.158] future_lapply() ...
[13:19:05.163] Number of chunks: 2
[13:19:05.163] getGlobalsAndPackagesXApply() ...
[13:19:05.163]  - future.globals: TRUE
[13:19:05.163] getGlobalsAndPackages() ...
[13:19:05.163] Searching for globals...
[13:19:05.170] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:19:05.170] Searching for globals ... DONE
[13:19:05.170] Resolving globals: FALSE
[13:19:05.172] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:19:05.172] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:19:05.172] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:05.172] - packages: [2] ‘stats’, ‘future.apply’
[13:19:05.172] getGlobalsAndPackages() ... DONE
[13:19:05.172]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:05.173]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:19:05.173] Finding globals ... DONE
[13:19:05.173]  - use_args: TRUE
[13:19:05.173]  - Getting '...' globals ...
[13:19:05.173] resolve() on list ...
[13:19:05.173]  recursive: 0
[13:19:05.173]  length: 1
[13:19:05.173]  elements: ‘...’
[13:19:05.174]  length: 0 (resolved future 1)
[13:19:05.174] resolve() on list ... DONE
[13:19:05.174]    - '...' content: [n=0] 
[13:19:05.174] List of 1
[13:19:05.174]  $ ...: list()
[13:19:05.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:05.174]  - attr(*, "where")=List of 1
[13:19:05.174]   ..$ ...:<environment: 0x555f7d8f9568> 
[13:19:05.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:05.174]  - attr(*, "resolved")= logi TRUE
[13:19:05.174]  - attr(*, "total_size")= num NA
[13:19:05.176]  - Getting '...' globals ... DONE
[13:19:05.177] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:05.177] List of 8
[13:19:05.177]  $ ...future.FUN:function (x, ...)  
[13:19:05.177]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:19:05.177]  $ times        : int 5
[13:19:05.177]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:05.177]  $ stop_if_not  :function (...)  
[13:19:05.177]  $ dim          : NULL
[13:19:05.177]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:05.177]  $ ...          : list()
[13:19:05.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:05.177]  - attr(*, "where")=List of 8
[13:19:05.177]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:05.177]   ..$ ...          :<environment: 0x555f7d8f9568> 
[13:19:05.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:05.177]  - attr(*, "resolved")= logi FALSE
[13:19:05.177]  - attr(*, "total_size")= num 141240
[13:19:05.182] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:19:05.182] getGlobalsAndPackagesXApply() ... DONE
[13:19:05.182] Number of futures (= number of chunks): 2
[13:19:05.182] Launching 2 futures (chunks) ...
[13:19:05.182] Chunk #1 of 2 ...
[13:19:05.183]  - Finding globals in 'X' for chunk #1 ...
[13:19:05.183] getGlobalsAndPackages() ...
[13:19:05.183] Searching for globals...
[13:19:05.183] 
[13:19:05.183] Searching for globals ... DONE
[13:19:05.183] - globals: [0] <none>
[13:19:05.183] getGlobalsAndPackages() ... DONE
[13:19:05.183]    + additional globals found: [n=0] 
[13:19:05.183]    + additional namespaces needed: [n=0] 
[13:19:05.183]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:05.184]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[13:19:05.184]  - seeds: <none>
[13:19:05.184] getGlobalsAndPackages() ...
[13:19:05.184] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.184] Resolving globals: FALSE
[13:19:05.184] Tweak future expression to call with '...' arguments ...
[13:19:05.184] {
[13:19:05.184]     do.call(function(...) {
[13:19:05.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.184]             on.exit(options(oopts), add = TRUE)
[13:19:05.184]         }
[13:19:05.184]         {
[13:19:05.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.184]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.184]             })
[13:19:05.184]         }
[13:19:05.184]     }, args = future.call.arguments)
[13:19:05.184] }
[13:19:05.184] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.185] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.185] - packages: [2] ‘stats’, ‘future.apply’
[13:19:05.185] getGlobalsAndPackages() ... DONE
[13:19:05.186] run() for ‘Future’ ...
[13:19:05.186] - state: ‘created’
[13:19:05.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:05.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:05.201]   - Field: ‘node’
[13:19:05.201]   - Field: ‘label’
[13:19:05.201]   - Field: ‘local’
[13:19:05.201]   - Field: ‘owner’
[13:19:05.201]   - Field: ‘envir’
[13:19:05.201]   - Field: ‘workers’
[13:19:05.201]   - Field: ‘packages’
[13:19:05.201]   - Field: ‘gc’
[13:19:05.201]   - Field: ‘conditions’
[13:19:05.201]   - Field: ‘persistent’
[13:19:05.202]   - Field: ‘expr’
[13:19:05.202]   - Field: ‘uuid’
[13:19:05.202]   - Field: ‘seed’
[13:19:05.202]   - Field: ‘version’
[13:19:05.202]   - Field: ‘result’
[13:19:05.202]   - Field: ‘asynchronous’
[13:19:05.202]   - Field: ‘calls’
[13:19:05.202]   - Field: ‘globals’
[13:19:05.202]   - Field: ‘stdout’
[13:19:05.202]   - Field: ‘earlySignal’
[13:19:05.202]   - Field: ‘lazy’
[13:19:05.202]   - Field: ‘state’
[13:19:05.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:05.203] - Launch lazy future ...
[13:19:05.203] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:19:05.203] Packages needed by future strategies (n = 0): <none>
[13:19:05.204] {
[13:19:05.204]     {
[13:19:05.204]         {
[13:19:05.204]             ...future.startTime <- base::Sys.time()
[13:19:05.204]             {
[13:19:05.204]                 {
[13:19:05.204]                   {
[13:19:05.204]                     {
[13:19:05.204]                       {
[13:19:05.204]                         base::local({
[13:19:05.204]                           has_future <- base::requireNamespace("future", 
[13:19:05.204]                             quietly = TRUE)
[13:19:05.204]                           if (has_future) {
[13:19:05.204]                             ns <- base::getNamespace("future")
[13:19:05.204]                             version <- ns[[".package"]][["version"]]
[13:19:05.204]                             if (is.null(version)) 
[13:19:05.204]                               version <- utils::packageVersion("future")
[13:19:05.204]                           }
[13:19:05.204]                           else {
[13:19:05.204]                             version <- NULL
[13:19:05.204]                           }
[13:19:05.204]                           if (!has_future || version < "1.8.0") {
[13:19:05.204]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:05.204]                               "", base::R.version$version.string), 
[13:19:05.204]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:05.204]                                 base::R.version$platform, 8 * 
[13:19:05.204]                                   base::.Machine$sizeof.pointer), 
[13:19:05.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:05.204]                                 "release", "version")], collapse = " "), 
[13:19:05.204]                               hostname = base::Sys.info()[["nodename"]])
[13:19:05.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:05.204]                               info)
[13:19:05.204]                             info <- base::paste(info, collapse = "; ")
[13:19:05.204]                             if (!has_future) {
[13:19:05.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:05.204]                                 info)
[13:19:05.204]                             }
[13:19:05.204]                             else {
[13:19:05.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:05.204]                                 info, version)
[13:19:05.204]                             }
[13:19:05.204]                             base::stop(msg)
[13:19:05.204]                           }
[13:19:05.204]                         })
[13:19:05.204]                       }
[13:19:05.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:05.204]                       base::options(mc.cores = 1L)
[13:19:05.204]                     }
[13:19:05.204]                     base::local({
[13:19:05.204]                       for (pkg in c("stats", "future.apply")) {
[13:19:05.204]                         base::loadNamespace(pkg)
[13:19:05.204]                         base::library(pkg, character.only = TRUE)
[13:19:05.204]                       }
[13:19:05.204]                     })
[13:19:05.204]                   }
[13:19:05.204]                   options(future.plan = NULL)
[13:19:05.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:05.204]                 }
[13:19:05.204]                 ...future.workdir <- getwd()
[13:19:05.204]             }
[13:19:05.204]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:05.204]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:05.204]         }
[13:19:05.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:05.204]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[13:19:05.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:05.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:05.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:05.204]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:05.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:05.204]             base::names(...future.oldOptions))
[13:19:05.204]     }
[13:19:05.204]     if (FALSE) {
[13:19:05.204]     }
[13:19:05.204]     else {
[13:19:05.204]         if (TRUE) {
[13:19:05.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:05.204]                 open = "w")
[13:19:05.204]         }
[13:19:05.204]         else {
[13:19:05.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:05.204]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:05.204]         }
[13:19:05.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:05.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:05.204]             base::sink(type = "output", split = FALSE)
[13:19:05.204]             base::close(...future.stdout)
[13:19:05.204]         }, add = TRUE)
[13:19:05.204]     }
[13:19:05.204]     ...future.frame <- base::sys.nframe()
[13:19:05.204]     ...future.conditions <- base::list()
[13:19:05.204]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:05.204]     if (FALSE) {
[13:19:05.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:05.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:05.204]     }
[13:19:05.204]     ...future.result <- base::tryCatch({
[13:19:05.204]         base::withCallingHandlers({
[13:19:05.204]             ...future.value <- base::withVisible(base::local({
[13:19:05.204]                 ...future.makeSendCondition <- local({
[13:19:05.204]                   sendCondition <- NULL
[13:19:05.204]                   function(frame = 1L) {
[13:19:05.204]                     if (is.function(sendCondition)) 
[13:19:05.204]                       return(sendCondition)
[13:19:05.204]                     ns <- getNamespace("parallel")
[13:19:05.204]                     if (exists("sendData", mode = "function", 
[13:19:05.204]                       envir = ns)) {
[13:19:05.204]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:05.204]                         envir = ns)
[13:19:05.204]                       envir <- sys.frame(frame)
[13:19:05.204]                       master <- NULL
[13:19:05.204]                       while (!identical(envir, .GlobalEnv) && 
[13:19:05.204]                         !identical(envir, emptyenv())) {
[13:19:05.204]                         if (exists("master", mode = "list", envir = envir, 
[13:19:05.204]                           inherits = FALSE)) {
[13:19:05.204]                           master <- get("master", mode = "list", 
[13:19:05.204]                             envir = envir, inherits = FALSE)
[13:19:05.204]                           if (inherits(master, c("SOCKnode", 
[13:19:05.204]                             "SOCK0node"))) {
[13:19:05.204]                             sendCondition <<- function(cond) {
[13:19:05.204]                               data <- list(type = "VALUE", value = cond, 
[13:19:05.204]                                 success = TRUE)
[13:19:05.204]                               parallel_sendData(master, data)
[13:19:05.204]                             }
[13:19:05.204]                             return(sendCondition)
[13:19:05.204]                           }
[13:19:05.204]                         }
[13:19:05.204]                         frame <- frame + 1L
[13:19:05.204]                         envir <- sys.frame(frame)
[13:19:05.204]                       }
[13:19:05.204]                     }
[13:19:05.204]                     sendCondition <<- function(cond) NULL
[13:19:05.204]                   }
[13:19:05.204]                 })
[13:19:05.204]                 withCallingHandlers({
[13:19:05.204]                   {
[13:19:05.204]                     do.call(function(...) {
[13:19:05.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.204]                       if (!identical(...future.globals.maxSize.org, 
[13:19:05.204]                         ...future.globals.maxSize)) {
[13:19:05.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.204]                         on.exit(options(oopts), add = TRUE)
[13:19:05.204]                       }
[13:19:05.204]                       {
[13:19:05.204]                         lapply(seq_along(...future.elements_ii), 
[13:19:05.204]                           FUN = function(jj) {
[13:19:05.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.204]                             ...future.FUN(...future.X_jj, ...)
[13:19:05.204]                           })
[13:19:05.204]                       }
[13:19:05.204]                     }, args = future.call.arguments)
[13:19:05.204]                   }
[13:19:05.204]                 }, immediateCondition = function(cond) {
[13:19:05.204]                   sendCondition <- ...future.makeSendCondition()
[13:19:05.204]                   sendCondition(cond)
[13:19:05.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.204]                   {
[13:19:05.204]                     inherits <- base::inherits
[13:19:05.204]                     invokeRestart <- base::invokeRestart
[13:19:05.204]                     is.null <- base::is.null
[13:19:05.204]                     muffled <- FALSE
[13:19:05.204]                     if (inherits(cond, "message")) {
[13:19:05.204]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:05.204]                       if (muffled) 
[13:19:05.204]                         invokeRestart("muffleMessage")
[13:19:05.204]                     }
[13:19:05.204]                     else if (inherits(cond, "warning")) {
[13:19:05.204]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:05.204]                       if (muffled) 
[13:19:05.204]                         invokeRestart("muffleWarning")
[13:19:05.204]                     }
[13:19:05.204]                     else if (inherits(cond, "condition")) {
[13:19:05.204]                       if (!is.null(pattern)) {
[13:19:05.204]                         computeRestarts <- base::computeRestarts
[13:19:05.204]                         grepl <- base::grepl
[13:19:05.204]                         restarts <- computeRestarts(cond)
[13:19:05.204]                         for (restart in restarts) {
[13:19:05.204]                           name <- restart$name
[13:19:05.204]                           if (is.null(name)) 
[13:19:05.204]                             next
[13:19:05.204]                           if (!grepl(pattern, name)) 
[13:19:05.204]                             next
[13:19:05.204]                           invokeRestart(restart)
[13:19:05.204]                           muffled <- TRUE
[13:19:05.204]                           break
[13:19:05.204]                         }
[13:19:05.204]                       }
[13:19:05.204]                     }
[13:19:05.204]                     invisible(muffled)
[13:19:05.204]                   }
[13:19:05.204]                   muffleCondition(cond)
[13:19:05.204]                 })
[13:19:05.204]             }))
[13:19:05.204]             future::FutureResult(value = ...future.value$value, 
[13:19:05.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.204]                   ...future.rng), globalenv = if (FALSE) 
[13:19:05.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:05.204]                     ...future.globalenv.names))
[13:19:05.204]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:05.204]         }, condition = base::local({
[13:19:05.204]             c <- base::c
[13:19:05.204]             inherits <- base::inherits
[13:19:05.204]             invokeRestart <- base::invokeRestart
[13:19:05.204]             length <- base::length
[13:19:05.204]             list <- base::list
[13:19:05.204]             seq.int <- base::seq.int
[13:19:05.204]             signalCondition <- base::signalCondition
[13:19:05.204]             sys.calls <- base::sys.calls
[13:19:05.204]             `[[` <- base::`[[`
[13:19:05.204]             `+` <- base::`+`
[13:19:05.204]             `<<-` <- base::`<<-`
[13:19:05.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:05.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:05.204]                   3L)]
[13:19:05.204]             }
[13:19:05.204]             function(cond) {
[13:19:05.204]                 is_error <- inherits(cond, "error")
[13:19:05.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:05.204]                   NULL)
[13:19:05.204]                 if (is_error) {
[13:19:05.204]                   sessionInformation <- function() {
[13:19:05.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:05.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:05.204]                       search = base::search(), system = base::Sys.info())
[13:19:05.204]                   }
[13:19:05.204]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:05.204]                     cond$call), session = sessionInformation(), 
[13:19:05.204]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:05.204]                   signalCondition(cond)
[13:19:05.204]                 }
[13:19:05.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:05.204]                 "immediateCondition"))) {
[13:19:05.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:05.204]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:05.204]                   if (TRUE && !signal) {
[13:19:05.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.204]                     {
[13:19:05.204]                       inherits <- base::inherits
[13:19:05.204]                       invokeRestart <- base::invokeRestart
[13:19:05.204]                       is.null <- base::is.null
[13:19:05.204]                       muffled <- FALSE
[13:19:05.204]                       if (inherits(cond, "message")) {
[13:19:05.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.204]                         if (muffled) 
[13:19:05.204]                           invokeRestart("muffleMessage")
[13:19:05.204]                       }
[13:19:05.204]                       else if (inherits(cond, "warning")) {
[13:19:05.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.204]                         if (muffled) 
[13:19:05.204]                           invokeRestart("muffleWarning")
[13:19:05.204]                       }
[13:19:05.204]                       else if (inherits(cond, "condition")) {
[13:19:05.204]                         if (!is.null(pattern)) {
[13:19:05.204]                           computeRestarts <- base::computeRestarts
[13:19:05.204]                           grepl <- base::grepl
[13:19:05.204]                           restarts <- computeRestarts(cond)
[13:19:05.204]                           for (restart in restarts) {
[13:19:05.204]                             name <- restart$name
[13:19:05.204]                             if (is.null(name)) 
[13:19:05.204]                               next
[13:19:05.204]                             if (!grepl(pattern, name)) 
[13:19:05.204]                               next
[13:19:05.204]                             invokeRestart(restart)
[13:19:05.204]                             muffled <- TRUE
[13:19:05.204]                             break
[13:19:05.204]                           }
[13:19:05.204]                         }
[13:19:05.204]                       }
[13:19:05.204]                       invisible(muffled)
[13:19:05.204]                     }
[13:19:05.204]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.204]                   }
[13:19:05.204]                 }
[13:19:05.204]                 else {
[13:19:05.204]                   if (TRUE) {
[13:19:05.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.204]                     {
[13:19:05.204]                       inherits <- base::inherits
[13:19:05.204]                       invokeRestart <- base::invokeRestart
[13:19:05.204]                       is.null <- base::is.null
[13:19:05.204]                       muffled <- FALSE
[13:19:05.204]                       if (inherits(cond, "message")) {
[13:19:05.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.204]                         if (muffled) 
[13:19:05.204]                           invokeRestart("muffleMessage")
[13:19:05.204]                       }
[13:19:05.204]                       else if (inherits(cond, "warning")) {
[13:19:05.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.204]                         if (muffled) 
[13:19:05.204]                           invokeRestart("muffleWarning")
[13:19:05.204]                       }
[13:19:05.204]                       else if (inherits(cond, "condition")) {
[13:19:05.204]                         if (!is.null(pattern)) {
[13:19:05.204]                           computeRestarts <- base::computeRestarts
[13:19:05.204]                           grepl <- base::grepl
[13:19:05.204]                           restarts <- computeRestarts(cond)
[13:19:05.204]                           for (restart in restarts) {
[13:19:05.204]                             name <- restart$name
[13:19:05.204]                             if (is.null(name)) 
[13:19:05.204]                               next
[13:19:05.204]                             if (!grepl(pattern, name)) 
[13:19:05.204]                               next
[13:19:05.204]                             invokeRestart(restart)
[13:19:05.204]                             muffled <- TRUE
[13:19:05.204]                             break
[13:19:05.204]                           }
[13:19:05.204]                         }
[13:19:05.204]                       }
[13:19:05.204]                       invisible(muffled)
[13:19:05.204]                     }
[13:19:05.204]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.204]                   }
[13:19:05.204]                 }
[13:19:05.204]             }
[13:19:05.204]         }))
[13:19:05.204]     }, error = function(ex) {
[13:19:05.204]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:05.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.204]                 ...future.rng), started = ...future.startTime, 
[13:19:05.204]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:05.204]             version = "1.8"), class = "FutureResult")
[13:19:05.204]     }, finally = {
[13:19:05.204]         if (!identical(...future.workdir, getwd())) 
[13:19:05.204]             setwd(...future.workdir)
[13:19:05.204]         {
[13:19:05.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:05.204]                 ...future.oldOptions$nwarnings <- NULL
[13:19:05.204]             }
[13:19:05.204]             base::options(...future.oldOptions)
[13:19:05.204]             if (.Platform$OS.type == "windows") {
[13:19:05.204]                 old_names <- names(...future.oldEnvVars)
[13:19:05.204]                 envs <- base::Sys.getenv()
[13:19:05.204]                 names <- names(envs)
[13:19:05.204]                 common <- intersect(names, old_names)
[13:19:05.204]                 added <- setdiff(names, old_names)
[13:19:05.204]                 removed <- setdiff(old_names, names)
[13:19:05.204]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:05.204]                   envs[common]]
[13:19:05.204]                 NAMES <- toupper(changed)
[13:19:05.204]                 args <- list()
[13:19:05.204]                 for (kk in seq_along(NAMES)) {
[13:19:05.204]                   name <- changed[[kk]]
[13:19:05.204]                   NAME <- NAMES[[kk]]
[13:19:05.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.204]                     next
[13:19:05.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.204]                 }
[13:19:05.204]                 NAMES <- toupper(added)
[13:19:05.204]                 for (kk in seq_along(NAMES)) {
[13:19:05.204]                   name <- added[[kk]]
[13:19:05.204]                   NAME <- NAMES[[kk]]
[13:19:05.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.204]                     next
[13:19:05.204]                   args[[name]] <- ""
[13:19:05.204]                 }
[13:19:05.204]                 NAMES <- toupper(removed)
[13:19:05.204]                 for (kk in seq_along(NAMES)) {
[13:19:05.204]                   name <- removed[[kk]]
[13:19:05.204]                   NAME <- NAMES[[kk]]
[13:19:05.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.204]                     next
[13:19:05.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.204]                 }
[13:19:05.204]                 if (length(args) > 0) 
[13:19:05.204]                   base::do.call(base::Sys.setenv, args = args)
[13:19:05.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:05.204]             }
[13:19:05.204]             else {
[13:19:05.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:05.204]             }
[13:19:05.204]             {
[13:19:05.204]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:05.204]                   0L) {
[13:19:05.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:05.204]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:05.204]                   base::options(opts)
[13:19:05.204]                 }
[13:19:05.204]                 {
[13:19:05.204]                   {
[13:19:05.204]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:05.204]                     NULL
[13:19:05.204]                   }
[13:19:05.204]                   options(future.plan = NULL)
[13:19:05.204]                   if (is.na(NA_character_)) 
[13:19:05.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:05.204]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:05.204]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:05.204]                     envir = parent.frame()) 
[13:19:05.204]                   {
[13:19:05.204]                     if (is.function(workers)) 
[13:19:05.204]                       workers <- workers()
[13:19:05.204]                     workers <- structure(as.integer(workers), 
[13:19:05.204]                       class = class(workers))
[13:19:05.204]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:05.204]                       workers >= 1)
[13:19:05.204]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:05.204]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:05.204]                     }
[13:19:05.204]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:05.204]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:05.204]                       envir = envir)
[13:19:05.204]                     if (!future$lazy) 
[13:19:05.204]                       future <- run(future)
[13:19:05.204]                     invisible(future)
[13:19:05.204]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:05.204]                 }
[13:19:05.204]             }
[13:19:05.204]         }
[13:19:05.204]     })
[13:19:05.204]     if (TRUE) {
[13:19:05.204]         base::sink(type = "output", split = FALSE)
[13:19:05.204]         if (TRUE) {
[13:19:05.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:05.204]         }
[13:19:05.204]         else {
[13:19:05.204]             ...future.result["stdout"] <- base::list(NULL)
[13:19:05.204]         }
[13:19:05.204]         base::close(...future.stdout)
[13:19:05.204]         ...future.stdout <- NULL
[13:19:05.204]     }
[13:19:05.204]     ...future.result$conditions <- ...future.conditions
[13:19:05.204]     ...future.result$finished <- base::Sys.time()
[13:19:05.204]     ...future.result
[13:19:05.204] }
[13:19:05.207] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[13:19:05.207] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:05.249] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:05.249] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[13:19:05.293] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[13:19:05.293] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:05.294] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:05.294] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:05.337] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:05.337] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:05.381] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:05.381] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:05.382] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.382] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:05.382] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:05.383] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:05.383] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.383] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[13:19:05.384] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[13:19:05.384] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:05.384] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.384] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:05.385] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.385] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[13:19:05.385] MultisessionFuture started
[13:19:05.385] - Launch lazy future ... done
[13:19:05.385] run() for ‘MultisessionFuture’ ... done
[13:19:05.386] Created future:
[13:19:05.386] MultisessionFuture:
[13:19:05.386] Label: ‘future_vapply-1’
[13:19:05.386] Expression:
[13:19:05.386] {
[13:19:05.386]     do.call(function(...) {
[13:19:05.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.386]             on.exit(options(oopts), add = TRUE)
[13:19:05.386]         }
[13:19:05.386]         {
[13:19:05.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.386]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.386]             })
[13:19:05.386]         }
[13:19:05.386]     }, args = future.call.arguments)
[13:19:05.386] }
[13:19:05.386] Lazy evaluation: FALSE
[13:19:05.386] Asynchronous evaluation: TRUE
[13:19:05.386] Local evaluation: TRUE
[13:19:05.386] Environment: R_GlobalEnv
[13:19:05.386] Capture standard output: TRUE
[13:19:05.386] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.386] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:05.386] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:19:05.386] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.386] Resolved: FALSE
[13:19:05.386] Value: <not collected>
[13:19:05.386] Conditions captured: <none>
[13:19:05.386] Early signaling: FALSE
[13:19:05.386] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.386] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.397] Chunk #1 of 2 ... DONE
[13:19:05.398] Chunk #2 of 2 ...
[13:19:05.398]  - Finding globals in 'X' for chunk #2 ...
[13:19:05.398] getGlobalsAndPackages() ...
[13:19:05.398] Searching for globals...
[13:19:05.398] 
[13:19:05.398] Searching for globals ... DONE
[13:19:05.398] - globals: [0] <none>
[13:19:05.399] getGlobalsAndPackages() ... DONE
[13:19:05.399]    + additional globals found: [n=0] 
[13:19:05.399]    + additional namespaces needed: [n=0] 
[13:19:05.399]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:05.399]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:19:05.399]  - seeds: <none>
[13:19:05.399] getGlobalsAndPackages() ...
[13:19:05.399] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.399] Resolving globals: FALSE
[13:19:05.399] Tweak future expression to call with '...' arguments ...
[13:19:05.400] {
[13:19:05.400]     do.call(function(...) {
[13:19:05.400]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.400]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.400]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.400]             on.exit(options(oopts), add = TRUE)
[13:19:05.400]         }
[13:19:05.400]         {
[13:19:05.400]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.400]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.400]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.400]             })
[13:19:05.400]         }
[13:19:05.400]     }, args = future.call.arguments)
[13:19:05.400] }
[13:19:05.400] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.400] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.400] - packages: [2] ‘stats’, ‘future.apply’
[13:19:05.401] getGlobalsAndPackages() ... DONE
[13:19:05.401] run() for ‘Future’ ...
[13:19:05.401] - state: ‘created’
[13:19:05.401] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:05.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:05.416]   - Field: ‘node’
[13:19:05.416]   - Field: ‘label’
[13:19:05.416]   - Field: ‘local’
[13:19:05.416]   - Field: ‘owner’
[13:19:05.417]   - Field: ‘envir’
[13:19:05.417]   - Field: ‘workers’
[13:19:05.417]   - Field: ‘packages’
[13:19:05.417]   - Field: ‘gc’
[13:19:05.417]   - Field: ‘conditions’
[13:19:05.417]   - Field: ‘persistent’
[13:19:05.417]   - Field: ‘expr’
[13:19:05.417]   - Field: ‘uuid’
[13:19:05.417]   - Field: ‘seed’
[13:19:05.417]   - Field: ‘version’
[13:19:05.418]   - Field: ‘result’
[13:19:05.418]   - Field: ‘asynchronous’
[13:19:05.418]   - Field: ‘calls’
[13:19:05.418]   - Field: ‘globals’
[13:19:05.418]   - Field: ‘stdout’
[13:19:05.418]   - Field: ‘earlySignal’
[13:19:05.418]   - Field: ‘lazy’
[13:19:05.418]   - Field: ‘state’
[13:19:05.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:05.418] - Launch lazy future ...
[13:19:05.419] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:19:05.419] Packages needed by future strategies (n = 0): <none>
[13:19:05.419] {
[13:19:05.419]     {
[13:19:05.419]         {
[13:19:05.419]             ...future.startTime <- base::Sys.time()
[13:19:05.419]             {
[13:19:05.419]                 {
[13:19:05.419]                   {
[13:19:05.419]                     {
[13:19:05.419]                       {
[13:19:05.419]                         base::local({
[13:19:05.419]                           has_future <- base::requireNamespace("future", 
[13:19:05.419]                             quietly = TRUE)
[13:19:05.419]                           if (has_future) {
[13:19:05.419]                             ns <- base::getNamespace("future")
[13:19:05.419]                             version <- ns[[".package"]][["version"]]
[13:19:05.419]                             if (is.null(version)) 
[13:19:05.419]                               version <- utils::packageVersion("future")
[13:19:05.419]                           }
[13:19:05.419]                           else {
[13:19:05.419]                             version <- NULL
[13:19:05.419]                           }
[13:19:05.419]                           if (!has_future || version < "1.8.0") {
[13:19:05.419]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:05.419]                               "", base::R.version$version.string), 
[13:19:05.419]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:05.419]                                 base::R.version$platform, 8 * 
[13:19:05.419]                                   base::.Machine$sizeof.pointer), 
[13:19:05.419]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:05.419]                                 "release", "version")], collapse = " "), 
[13:19:05.419]                               hostname = base::Sys.info()[["nodename"]])
[13:19:05.419]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:05.419]                               info)
[13:19:05.419]                             info <- base::paste(info, collapse = "; ")
[13:19:05.419]                             if (!has_future) {
[13:19:05.419]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:05.419]                                 info)
[13:19:05.419]                             }
[13:19:05.419]                             else {
[13:19:05.419]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:05.419]                                 info, version)
[13:19:05.419]                             }
[13:19:05.419]                             base::stop(msg)
[13:19:05.419]                           }
[13:19:05.419]                         })
[13:19:05.419]                       }
[13:19:05.419]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:05.419]                       base::options(mc.cores = 1L)
[13:19:05.419]                     }
[13:19:05.419]                     base::local({
[13:19:05.419]                       for (pkg in c("stats", "future.apply")) {
[13:19:05.419]                         base::loadNamespace(pkg)
[13:19:05.419]                         base::library(pkg, character.only = TRUE)
[13:19:05.419]                       }
[13:19:05.419]                     })
[13:19:05.419]                   }
[13:19:05.419]                   options(future.plan = NULL)
[13:19:05.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:05.419]                 }
[13:19:05.419]                 ...future.workdir <- getwd()
[13:19:05.419]             }
[13:19:05.419]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:05.419]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:05.419]         }
[13:19:05.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:05.419]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:19:05.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:05.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:05.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:05.419]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:05.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:05.419]             base::names(...future.oldOptions))
[13:19:05.419]     }
[13:19:05.419]     if (FALSE) {
[13:19:05.419]     }
[13:19:05.419]     else {
[13:19:05.419]         if (TRUE) {
[13:19:05.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:05.419]                 open = "w")
[13:19:05.419]         }
[13:19:05.419]         else {
[13:19:05.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:05.419]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:05.419]         }
[13:19:05.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:05.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:05.419]             base::sink(type = "output", split = FALSE)
[13:19:05.419]             base::close(...future.stdout)
[13:19:05.419]         }, add = TRUE)
[13:19:05.419]     }
[13:19:05.419]     ...future.frame <- base::sys.nframe()
[13:19:05.419]     ...future.conditions <- base::list()
[13:19:05.419]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:05.419]     if (FALSE) {
[13:19:05.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:05.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:05.419]     }
[13:19:05.419]     ...future.result <- base::tryCatch({
[13:19:05.419]         base::withCallingHandlers({
[13:19:05.419]             ...future.value <- base::withVisible(base::local({
[13:19:05.419]                 ...future.makeSendCondition <- local({
[13:19:05.419]                   sendCondition <- NULL
[13:19:05.419]                   function(frame = 1L) {
[13:19:05.419]                     if (is.function(sendCondition)) 
[13:19:05.419]                       return(sendCondition)
[13:19:05.419]                     ns <- getNamespace("parallel")
[13:19:05.419]                     if (exists("sendData", mode = "function", 
[13:19:05.419]                       envir = ns)) {
[13:19:05.419]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:05.419]                         envir = ns)
[13:19:05.419]                       envir <- sys.frame(frame)
[13:19:05.419]                       master <- NULL
[13:19:05.419]                       while (!identical(envir, .GlobalEnv) && 
[13:19:05.419]                         !identical(envir, emptyenv())) {
[13:19:05.419]                         if (exists("master", mode = "list", envir = envir, 
[13:19:05.419]                           inherits = FALSE)) {
[13:19:05.419]                           master <- get("master", mode = "list", 
[13:19:05.419]                             envir = envir, inherits = FALSE)
[13:19:05.419]                           if (inherits(master, c("SOCKnode", 
[13:19:05.419]                             "SOCK0node"))) {
[13:19:05.419]                             sendCondition <<- function(cond) {
[13:19:05.419]                               data <- list(type = "VALUE", value = cond, 
[13:19:05.419]                                 success = TRUE)
[13:19:05.419]                               parallel_sendData(master, data)
[13:19:05.419]                             }
[13:19:05.419]                             return(sendCondition)
[13:19:05.419]                           }
[13:19:05.419]                         }
[13:19:05.419]                         frame <- frame + 1L
[13:19:05.419]                         envir <- sys.frame(frame)
[13:19:05.419]                       }
[13:19:05.419]                     }
[13:19:05.419]                     sendCondition <<- function(cond) NULL
[13:19:05.419]                   }
[13:19:05.419]                 })
[13:19:05.419]                 withCallingHandlers({
[13:19:05.419]                   {
[13:19:05.419]                     do.call(function(...) {
[13:19:05.419]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.419]                       if (!identical(...future.globals.maxSize.org, 
[13:19:05.419]                         ...future.globals.maxSize)) {
[13:19:05.419]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.419]                         on.exit(options(oopts), add = TRUE)
[13:19:05.419]                       }
[13:19:05.419]                       {
[13:19:05.419]                         lapply(seq_along(...future.elements_ii), 
[13:19:05.419]                           FUN = function(jj) {
[13:19:05.419]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.419]                             ...future.FUN(...future.X_jj, ...)
[13:19:05.419]                           })
[13:19:05.419]                       }
[13:19:05.419]                     }, args = future.call.arguments)
[13:19:05.419]                   }
[13:19:05.419]                 }, immediateCondition = function(cond) {
[13:19:05.419]                   sendCondition <- ...future.makeSendCondition()
[13:19:05.419]                   sendCondition(cond)
[13:19:05.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.419]                   {
[13:19:05.419]                     inherits <- base::inherits
[13:19:05.419]                     invokeRestart <- base::invokeRestart
[13:19:05.419]                     is.null <- base::is.null
[13:19:05.419]                     muffled <- FALSE
[13:19:05.419]                     if (inherits(cond, "message")) {
[13:19:05.419]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:05.419]                       if (muffled) 
[13:19:05.419]                         invokeRestart("muffleMessage")
[13:19:05.419]                     }
[13:19:05.419]                     else if (inherits(cond, "warning")) {
[13:19:05.419]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:05.419]                       if (muffled) 
[13:19:05.419]                         invokeRestart("muffleWarning")
[13:19:05.419]                     }
[13:19:05.419]                     else if (inherits(cond, "condition")) {
[13:19:05.419]                       if (!is.null(pattern)) {
[13:19:05.419]                         computeRestarts <- base::computeRestarts
[13:19:05.419]                         grepl <- base::grepl
[13:19:05.419]                         restarts <- computeRestarts(cond)
[13:19:05.419]                         for (restart in restarts) {
[13:19:05.419]                           name <- restart$name
[13:19:05.419]                           if (is.null(name)) 
[13:19:05.419]                             next
[13:19:05.419]                           if (!grepl(pattern, name)) 
[13:19:05.419]                             next
[13:19:05.419]                           invokeRestart(restart)
[13:19:05.419]                           muffled <- TRUE
[13:19:05.419]                           break
[13:19:05.419]                         }
[13:19:05.419]                       }
[13:19:05.419]                     }
[13:19:05.419]                     invisible(muffled)
[13:19:05.419]                   }
[13:19:05.419]                   muffleCondition(cond)
[13:19:05.419]                 })
[13:19:05.419]             }))
[13:19:05.419]             future::FutureResult(value = ...future.value$value, 
[13:19:05.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.419]                   ...future.rng), globalenv = if (FALSE) 
[13:19:05.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:05.419]                     ...future.globalenv.names))
[13:19:05.419]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:05.419]         }, condition = base::local({
[13:19:05.419]             c <- base::c
[13:19:05.419]             inherits <- base::inherits
[13:19:05.419]             invokeRestart <- base::invokeRestart
[13:19:05.419]             length <- base::length
[13:19:05.419]             list <- base::list
[13:19:05.419]             seq.int <- base::seq.int
[13:19:05.419]             signalCondition <- base::signalCondition
[13:19:05.419]             sys.calls <- base::sys.calls
[13:19:05.419]             `[[` <- base::`[[`
[13:19:05.419]             `+` <- base::`+`
[13:19:05.419]             `<<-` <- base::`<<-`
[13:19:05.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:05.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:05.419]                   3L)]
[13:19:05.419]             }
[13:19:05.419]             function(cond) {
[13:19:05.419]                 is_error <- inherits(cond, "error")
[13:19:05.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:05.419]                   NULL)
[13:19:05.419]                 if (is_error) {
[13:19:05.419]                   sessionInformation <- function() {
[13:19:05.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:05.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:05.419]                       search = base::search(), system = base::Sys.info())
[13:19:05.419]                   }
[13:19:05.419]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:05.419]                     cond$call), session = sessionInformation(), 
[13:19:05.419]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:05.419]                   signalCondition(cond)
[13:19:05.419]                 }
[13:19:05.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:05.419]                 "immediateCondition"))) {
[13:19:05.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:05.419]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:05.419]                   if (TRUE && !signal) {
[13:19:05.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.419]                     {
[13:19:05.419]                       inherits <- base::inherits
[13:19:05.419]                       invokeRestart <- base::invokeRestart
[13:19:05.419]                       is.null <- base::is.null
[13:19:05.419]                       muffled <- FALSE
[13:19:05.419]                       if (inherits(cond, "message")) {
[13:19:05.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.419]                         if (muffled) 
[13:19:05.419]                           invokeRestart("muffleMessage")
[13:19:05.419]                       }
[13:19:05.419]                       else if (inherits(cond, "warning")) {
[13:19:05.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.419]                         if (muffled) 
[13:19:05.419]                           invokeRestart("muffleWarning")
[13:19:05.419]                       }
[13:19:05.419]                       else if (inherits(cond, "condition")) {
[13:19:05.419]                         if (!is.null(pattern)) {
[13:19:05.419]                           computeRestarts <- base::computeRestarts
[13:19:05.419]                           grepl <- base::grepl
[13:19:05.419]                           restarts <- computeRestarts(cond)
[13:19:05.419]                           for (restart in restarts) {
[13:19:05.419]                             name <- restart$name
[13:19:05.419]                             if (is.null(name)) 
[13:19:05.419]                               next
[13:19:05.419]                             if (!grepl(pattern, name)) 
[13:19:05.419]                               next
[13:19:05.419]                             invokeRestart(restart)
[13:19:05.419]                             muffled <- TRUE
[13:19:05.419]                             break
[13:19:05.419]                           }
[13:19:05.419]                         }
[13:19:05.419]                       }
[13:19:05.419]                       invisible(muffled)
[13:19:05.419]                     }
[13:19:05.419]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.419]                   }
[13:19:05.419]                 }
[13:19:05.419]                 else {
[13:19:05.419]                   if (TRUE) {
[13:19:05.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.419]                     {
[13:19:05.419]                       inherits <- base::inherits
[13:19:05.419]                       invokeRestart <- base::invokeRestart
[13:19:05.419]                       is.null <- base::is.null
[13:19:05.419]                       muffled <- FALSE
[13:19:05.419]                       if (inherits(cond, "message")) {
[13:19:05.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.419]                         if (muffled) 
[13:19:05.419]                           invokeRestart("muffleMessage")
[13:19:05.419]                       }
[13:19:05.419]                       else if (inherits(cond, "warning")) {
[13:19:05.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.419]                         if (muffled) 
[13:19:05.419]                           invokeRestart("muffleWarning")
[13:19:05.419]                       }
[13:19:05.419]                       else if (inherits(cond, "condition")) {
[13:19:05.419]                         if (!is.null(pattern)) {
[13:19:05.419]                           computeRestarts <- base::computeRestarts
[13:19:05.419]                           grepl <- base::grepl
[13:19:05.419]                           restarts <- computeRestarts(cond)
[13:19:05.419]                           for (restart in restarts) {
[13:19:05.419]                             name <- restart$name
[13:19:05.419]                             if (is.null(name)) 
[13:19:05.419]                               next
[13:19:05.419]                             if (!grepl(pattern, name)) 
[13:19:05.419]                               next
[13:19:05.419]                             invokeRestart(restart)
[13:19:05.419]                             muffled <- TRUE
[13:19:05.419]                             break
[13:19:05.419]                           }
[13:19:05.419]                         }
[13:19:05.419]                       }
[13:19:05.419]                       invisible(muffled)
[13:19:05.419]                     }
[13:19:05.419]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.419]                   }
[13:19:05.419]                 }
[13:19:05.419]             }
[13:19:05.419]         }))
[13:19:05.419]     }, error = function(ex) {
[13:19:05.419]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:05.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.419]                 ...future.rng), started = ...future.startTime, 
[13:19:05.419]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:05.419]             version = "1.8"), class = "FutureResult")
[13:19:05.419]     }, finally = {
[13:19:05.419]         if (!identical(...future.workdir, getwd())) 
[13:19:05.419]             setwd(...future.workdir)
[13:19:05.419]         {
[13:19:05.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:05.419]                 ...future.oldOptions$nwarnings <- NULL
[13:19:05.419]             }
[13:19:05.419]             base::options(...future.oldOptions)
[13:19:05.419]             if (.Platform$OS.type == "windows") {
[13:19:05.419]                 old_names <- names(...future.oldEnvVars)
[13:19:05.419]                 envs <- base::Sys.getenv()
[13:19:05.419]                 names <- names(envs)
[13:19:05.419]                 common <- intersect(names, old_names)
[13:19:05.419]                 added <- setdiff(names, old_names)
[13:19:05.419]                 removed <- setdiff(old_names, names)
[13:19:05.419]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:05.419]                   envs[common]]
[13:19:05.419]                 NAMES <- toupper(changed)
[13:19:05.419]                 args <- list()
[13:19:05.419]                 for (kk in seq_along(NAMES)) {
[13:19:05.419]                   name <- changed[[kk]]
[13:19:05.419]                   NAME <- NAMES[[kk]]
[13:19:05.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.419]                     next
[13:19:05.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.419]                 }
[13:19:05.419]                 NAMES <- toupper(added)
[13:19:05.419]                 for (kk in seq_along(NAMES)) {
[13:19:05.419]                   name <- added[[kk]]
[13:19:05.419]                   NAME <- NAMES[[kk]]
[13:19:05.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.419]                     next
[13:19:05.419]                   args[[name]] <- ""
[13:19:05.419]                 }
[13:19:05.419]                 NAMES <- toupper(removed)
[13:19:05.419]                 for (kk in seq_along(NAMES)) {
[13:19:05.419]                   name <- removed[[kk]]
[13:19:05.419]                   NAME <- NAMES[[kk]]
[13:19:05.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.419]                     next
[13:19:05.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.419]                 }
[13:19:05.419]                 if (length(args) > 0) 
[13:19:05.419]                   base::do.call(base::Sys.setenv, args = args)
[13:19:05.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:05.419]             }
[13:19:05.419]             else {
[13:19:05.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:05.419]             }
[13:19:05.419]             {
[13:19:05.419]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:05.419]                   0L) {
[13:19:05.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:05.419]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:05.419]                   base::options(opts)
[13:19:05.419]                 }
[13:19:05.419]                 {
[13:19:05.419]                   {
[13:19:05.419]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:05.419]                     NULL
[13:19:05.419]                   }
[13:19:05.419]                   options(future.plan = NULL)
[13:19:05.419]                   if (is.na(NA_character_)) 
[13:19:05.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:05.419]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:05.419]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:05.419]                     envir = parent.frame()) 
[13:19:05.419]                   {
[13:19:05.419]                     if (is.function(workers)) 
[13:19:05.419]                       workers <- workers()
[13:19:05.419]                     workers <- structure(as.integer(workers), 
[13:19:05.419]                       class = class(workers))
[13:19:05.419]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:05.419]                       workers >= 1)
[13:19:05.419]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:05.419]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:05.419]                     }
[13:19:05.419]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:05.419]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:05.419]                       envir = envir)
[13:19:05.419]                     if (!future$lazy) 
[13:19:05.419]                       future <- run(future)
[13:19:05.419]                     invisible(future)
[13:19:05.419]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:05.419]                 }
[13:19:05.419]             }
[13:19:05.419]         }
[13:19:05.419]     })
[13:19:05.419]     if (TRUE) {
[13:19:05.419]         base::sink(type = "output", split = FALSE)
[13:19:05.419]         if (TRUE) {
[13:19:05.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:05.419]         }
[13:19:05.419]         else {
[13:19:05.419]             ...future.result["stdout"] <- base::list(NULL)
[13:19:05.419]         }
[13:19:05.419]         base::close(...future.stdout)
[13:19:05.419]         ...future.stdout <- NULL
[13:19:05.419]     }
[13:19:05.419]     ...future.result$conditions <- ...future.conditions
[13:19:05.419]     ...future.result$finished <- base::Sys.time()
[13:19:05.419]     ...future.result
[13:19:05.419] }
[13:19:05.422] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[13:19:05.423] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:05.465] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:05.465] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[13:19:05.509] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[13:19:05.509] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:05.510] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:05.510] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:05.553] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:05.553] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:05.597] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:05.597] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:05.598] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.598] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:05.598] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:05.599] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:05.599] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.599] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[13:19:05.600] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[13:19:05.600] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:05.600] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.600] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:05.601] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.601] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[13:19:05.601] MultisessionFuture started
[13:19:05.602] - Launch lazy future ... done
[13:19:05.602] run() for ‘MultisessionFuture’ ... done
[13:19:05.602] Created future:
[13:19:05.602] MultisessionFuture:
[13:19:05.602] Label: ‘future_vapply-2’
[13:19:05.602] Expression:
[13:19:05.602] {
[13:19:05.602]     do.call(function(...) {
[13:19:05.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.602]             on.exit(options(oopts), add = TRUE)
[13:19:05.602]         }
[13:19:05.602]         {
[13:19:05.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.602]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.602]             })
[13:19:05.602]         }
[13:19:05.602]     }, args = future.call.arguments)
[13:19:05.602] }
[13:19:05.602] Lazy evaluation: FALSE
[13:19:05.602] Asynchronous evaluation: TRUE
[13:19:05.602] Local evaluation: TRUE
[13:19:05.602] Environment: R_GlobalEnv
[13:19:05.602] Capture standard output: TRUE
[13:19:05.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.602] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:05.602] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:19:05.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.602] Resolved: FALSE
[13:19:05.602] Value: <not collected>
[13:19:05.602] Conditions captured: <none>
[13:19:05.602] Early signaling: FALSE
[13:19:05.602] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.602] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.614] Chunk #2 of 2 ... DONE
[13:19:05.614] Launching 2 futures (chunks) ... DONE
[13:19:05.614] Resolving 2 futures (chunks) ...
[13:19:05.614] resolve() on list ...
[13:19:05.614]  recursive: 0
[13:19:05.614]  length: 2
[13:19:05.615] 
[13:19:05.615] receiveMessageFromWorker() for ClusterFuture ...
[13:19:05.615] - Validating connection of MultisessionFuture
[13:19:05.615] - received message: FutureResult
[13:19:05.616] - Received FutureResult
[13:19:05.616] - Erased future from FutureRegistry
[13:19:05.616] result() for ClusterFuture ...
[13:19:05.616] - result already collected: FutureResult
[13:19:05.616] result() for ClusterFuture ... done
[13:19:05.616] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:05.616] Future #1
[13:19:05.616] result() for ClusterFuture ...
[13:19:05.616] - result already collected: FutureResult
[13:19:05.616] result() for ClusterFuture ... done
[13:19:05.616] result() for ClusterFuture ...
[13:19:05.617] - result already collected: FutureResult
[13:19:05.617] result() for ClusterFuture ... done
[13:19:05.617] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:05.617] - nx: 2
[13:19:05.617] - relay: TRUE
[13:19:05.617] - stdout: TRUE
[13:19:05.617] - signal: TRUE
[13:19:05.617] - resignal: FALSE
[13:19:05.617] - force: TRUE
[13:19:05.617] - relayed: [n=2] FALSE, FALSE
[13:19:05.617] - queued futures: [n=2] FALSE, FALSE
[13:19:05.618]  - until=1
[13:19:05.618]  - relaying element #1
[13:19:05.618] result() for ClusterFuture ...
[13:19:05.618] - result already collected: FutureResult
[13:19:05.618] result() for ClusterFuture ... done
[13:19:05.618] result() for ClusterFuture ...
[13:19:05.618] - result already collected: FutureResult
[13:19:05.618] result() for ClusterFuture ... done
[13:19:05.618] result() for ClusterFuture ...
[13:19:05.618] - result already collected: FutureResult
[13:19:05.619] result() for ClusterFuture ... done
[13:19:05.619] result() for ClusterFuture ...
[13:19:05.619] - result already collected: FutureResult
[13:19:05.619] result() for ClusterFuture ... done
[13:19:05.619] - relayed: [n=2] TRUE, FALSE
[13:19:05.621] - queued futures: [n=2] TRUE, FALSE
[13:19:05.621] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:05.621]  length: 1 (resolved future 1)
[13:19:05.650] receiveMessageFromWorker() for ClusterFuture ...
[13:19:05.650] - Validating connection of MultisessionFuture
[13:19:05.650] - received message: FutureResult
[13:19:05.651] - Received FutureResult
[13:19:05.651] - Erased future from FutureRegistry
[13:19:05.651] result() for ClusterFuture ...
[13:19:05.651] - result already collected: FutureResult
[13:19:05.651] result() for ClusterFuture ... done
[13:19:05.651] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:05.651] Future #2
[13:19:05.651] result() for ClusterFuture ...
[13:19:05.651] - result already collected: FutureResult
[13:19:05.651] result() for ClusterFuture ... done
[13:19:05.652] result() for ClusterFuture ...
[13:19:05.652] - result already collected: FutureResult
[13:19:05.652] result() for ClusterFuture ... done
[13:19:05.652] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:05.652] - nx: 2
[13:19:05.652] - relay: TRUE
[13:19:05.652] - stdout: TRUE
[13:19:05.652] - signal: TRUE
[13:19:05.652] - resignal: FALSE
[13:19:05.652] - force: TRUE
[13:19:05.652] - relayed: [n=2] TRUE, FALSE
[13:19:05.652] - queued futures: [n=2] TRUE, FALSE
[13:19:05.653]  - until=2
[13:19:05.653]  - relaying element #2
[13:19:05.653] result() for ClusterFuture ...
[13:19:05.653] - result already collected: FutureResult
[13:19:05.653] result() for ClusterFuture ... done
[13:19:05.653] result() for ClusterFuture ...
[13:19:05.653] - result already collected: FutureResult
[13:19:05.653] result() for ClusterFuture ... done
[13:19:05.653] result() for ClusterFuture ...
[13:19:05.653] - result already collected: FutureResult
[13:19:05.654] result() for ClusterFuture ... done
[13:19:05.654] result() for ClusterFuture ...
[13:19:05.654] - result already collected: FutureResult
[13:19:05.654] result() for ClusterFuture ... done
[13:19:05.654] - relayed: [n=2] TRUE, TRUE
[13:19:05.654] - queued futures: [n=2] TRUE, TRUE
[13:19:05.654] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:05.654]  length: 0 (resolved future 2)
[13:19:05.654] Relaying remaining futures
[13:19:05.654] signalConditionsASAP(NULL, pos=0) ...
[13:19:05.654] - nx: 2
[13:19:05.654] - relay: TRUE
[13:19:05.655] - stdout: TRUE
[13:19:05.655] - signal: TRUE
[13:19:05.655] - resignal: FALSE
[13:19:05.655] - force: TRUE
[13:19:05.655] - relayed: [n=2] TRUE, TRUE
[13:19:05.655] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:05.655] - relayed: [n=2] TRUE, TRUE
[13:19:05.655] - queued futures: [n=2] TRUE, TRUE
[13:19:05.655] signalConditionsASAP(NULL, pos=0) ... done
[13:19:05.655] resolve() on list ... DONE
[13:19:05.655] result() for ClusterFuture ...
[13:19:05.655] - result already collected: FutureResult
[13:19:05.656] result() for ClusterFuture ... done
[13:19:05.656] result() for ClusterFuture ...
[13:19:05.656] - result already collected: FutureResult
[13:19:05.656] result() for ClusterFuture ... done
[13:19:05.656] result() for ClusterFuture ...
[13:19:05.656] - result already collected: FutureResult
[13:19:05.656] result() for ClusterFuture ... done
[13:19:05.656] result() for ClusterFuture ...
[13:19:05.656] - result already collected: FutureResult
[13:19:05.656] result() for ClusterFuture ... done
[13:19:05.656]  - Number of value chunks collected: 2
[13:19:05.657] Resolving 2 futures (chunks) ... DONE
[13:19:05.657] Reducing values from 2 chunks ...
[13:19:05.657]  - Number of values collected after concatenation: 7
[13:19:05.657]  - Number of values expected: 7
[13:19:05.657] Reducing values from 2 chunks ... DONE
[13:19:05.657] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:19:05.659] future_lapply() ...
[13:19:05.663] Number of chunks: 2
[13:19:05.663] getGlobalsAndPackagesXApply() ...
[13:19:05.663]  - future.globals: TRUE
[13:19:05.663] getGlobalsAndPackages() ...
[13:19:05.663] Searching for globals...
[13:19:05.664] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:19:05.664] Searching for globals ... DONE
[13:19:05.665] Resolving globals: FALSE
[13:19:05.665] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:19:05.665] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:19:05.665] - globals: [1] ‘FUN’
[13:19:05.666] 
[13:19:05.666] getGlobalsAndPackages() ... DONE
[13:19:05.666]  - globals found/used: [n=1] ‘FUN’
[13:19:05.666]  - needed namespaces: [n=0] 
[13:19:05.666] Finding globals ... DONE
[13:19:05.666]  - use_args: TRUE
[13:19:05.666]  - Getting '...' globals ...
[13:19:05.666] resolve() on list ...
[13:19:05.666]  recursive: 0
[13:19:05.667]  length: 1
[13:19:05.667]  elements: ‘...’
[13:19:05.667]  length: 0 (resolved future 1)
[13:19:05.667] resolve() on list ... DONE
[13:19:05.667]    - '...' content: [n=1] ‘y’
[13:19:05.667] List of 1
[13:19:05.667]  $ ...:List of 1
[13:19:05.667]   ..$ y: num [1:5] 2 4 6 8 10
[13:19:05.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:05.667]  - attr(*, "where")=List of 1
[13:19:05.667]   ..$ ...:<environment: 0x555f7de94650> 
[13:19:05.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:05.667]  - attr(*, "resolved")= logi TRUE
[13:19:05.667]  - attr(*, "total_size")= num NA
[13:19:05.670]  - Getting '...' globals ... DONE
[13:19:05.670] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:05.670] List of 2
[13:19:05.670]  $ ...future.FUN:function (x, y)  
[13:19:05.670]  $ ...          :List of 1
[13:19:05.670]   ..$ y: num [1:5] 2 4 6 8 10
[13:19:05.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:05.670]  - attr(*, "where")=List of 2
[13:19:05.670]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:05.670]   ..$ ...          :<environment: 0x555f7de94650> 
[13:19:05.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:05.670]  - attr(*, "resolved")= logi FALSE
[13:19:05.670]  - attr(*, "total_size")= num 4264
[13:19:05.673] Packages to be attached in all futures: [n=0] 
[13:19:05.673] getGlobalsAndPackagesXApply() ... DONE
[13:19:05.673] Number of futures (= number of chunks): 2
[13:19:05.674] Launching 2 futures (chunks) ...
[13:19:05.674] Chunk #1 of 2 ...
[13:19:05.674]  - Finding globals in 'X' for chunk #1 ...
[13:19:05.674] getGlobalsAndPackages() ...
[13:19:05.674] Searching for globals...
[13:19:05.674] 
[13:19:05.674] Searching for globals ... DONE
[13:19:05.674] - globals: [0] <none>
[13:19:05.674] getGlobalsAndPackages() ... DONE
[13:19:05.675]    + additional globals found: [n=0] 
[13:19:05.675]    + additional namespaces needed: [n=0] 
[13:19:05.675]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:05.675]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:05.675]  - seeds: <none>
[13:19:05.675] getGlobalsAndPackages() ...
[13:19:05.675] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.675] Resolving globals: FALSE
[13:19:05.675] Tweak future expression to call with '...' arguments ...
[13:19:05.675] {
[13:19:05.675]     do.call(function(...) {
[13:19:05.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.675]             on.exit(options(oopts), add = TRUE)
[13:19:05.675]         }
[13:19:05.675]         {
[13:19:05.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.675]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.675]             })
[13:19:05.675]         }
[13:19:05.675]     }, args = future.call.arguments)
[13:19:05.675] }
[13:19:05.676] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.676] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.676] 
[13:19:05.676] getGlobalsAndPackages() ... DONE
[13:19:05.677] run() for ‘Future’ ...
[13:19:05.677] - state: ‘created’
[13:19:05.677] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:05.691] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:05.691]   - Field: ‘node’
[13:19:05.692]   - Field: ‘label’
[13:19:05.692]   - Field: ‘local’
[13:19:05.692]   - Field: ‘owner’
[13:19:05.692]   - Field: ‘envir’
[13:19:05.692]   - Field: ‘workers’
[13:19:05.692]   - Field: ‘packages’
[13:19:05.692]   - Field: ‘gc’
[13:19:05.692]   - Field: ‘conditions’
[13:19:05.692]   - Field: ‘persistent’
[13:19:05.692]   - Field: ‘expr’
[13:19:05.692]   - Field: ‘uuid’
[13:19:05.693]   - Field: ‘seed’
[13:19:05.693]   - Field: ‘version’
[13:19:05.693]   - Field: ‘result’
[13:19:05.693]   - Field: ‘asynchronous’
[13:19:05.693]   - Field: ‘calls’
[13:19:05.693]   - Field: ‘globals’
[13:19:05.693]   - Field: ‘stdout’
[13:19:05.693]   - Field: ‘earlySignal’
[13:19:05.693]   - Field: ‘lazy’
[13:19:05.693]   - Field: ‘state’
[13:19:05.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:05.694] - Launch lazy future ...
[13:19:05.694] Packages needed by the future expression (n = 0): <none>
[13:19:05.694] Packages needed by future strategies (n = 0): <none>
[13:19:05.694] {
[13:19:05.694]     {
[13:19:05.694]         {
[13:19:05.694]             ...future.startTime <- base::Sys.time()
[13:19:05.694]             {
[13:19:05.694]                 {
[13:19:05.694]                   {
[13:19:05.694]                     {
[13:19:05.694]                       base::local({
[13:19:05.694]                         has_future <- base::requireNamespace("future", 
[13:19:05.694]                           quietly = TRUE)
[13:19:05.694]                         if (has_future) {
[13:19:05.694]                           ns <- base::getNamespace("future")
[13:19:05.694]                           version <- ns[[".package"]][["version"]]
[13:19:05.694]                           if (is.null(version)) 
[13:19:05.694]                             version <- utils::packageVersion("future")
[13:19:05.694]                         }
[13:19:05.694]                         else {
[13:19:05.694]                           version <- NULL
[13:19:05.694]                         }
[13:19:05.694]                         if (!has_future || version < "1.8.0") {
[13:19:05.694]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:05.694]                             "", base::R.version$version.string), 
[13:19:05.694]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:05.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:05.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:05.694]                               "release", "version")], collapse = " "), 
[13:19:05.694]                             hostname = base::Sys.info()[["nodename"]])
[13:19:05.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:05.694]                             info)
[13:19:05.694]                           info <- base::paste(info, collapse = "; ")
[13:19:05.694]                           if (!has_future) {
[13:19:05.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:05.694]                               info)
[13:19:05.694]                           }
[13:19:05.694]                           else {
[13:19:05.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:05.694]                               info, version)
[13:19:05.694]                           }
[13:19:05.694]                           base::stop(msg)
[13:19:05.694]                         }
[13:19:05.694]                       })
[13:19:05.694]                     }
[13:19:05.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:05.694]                     base::options(mc.cores = 1L)
[13:19:05.694]                   }
[13:19:05.694]                   options(future.plan = NULL)
[13:19:05.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:05.694]                 }
[13:19:05.694]                 ...future.workdir <- getwd()
[13:19:05.694]             }
[13:19:05.694]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:05.694]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:05.694]         }
[13:19:05.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:05.694]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:05.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:05.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:05.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:05.694]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:05.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:05.694]             base::names(...future.oldOptions))
[13:19:05.694]     }
[13:19:05.694]     if (FALSE) {
[13:19:05.694]     }
[13:19:05.694]     else {
[13:19:05.694]         if (TRUE) {
[13:19:05.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:05.694]                 open = "w")
[13:19:05.694]         }
[13:19:05.694]         else {
[13:19:05.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:05.694]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:05.694]         }
[13:19:05.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:05.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:05.694]             base::sink(type = "output", split = FALSE)
[13:19:05.694]             base::close(...future.stdout)
[13:19:05.694]         }, add = TRUE)
[13:19:05.694]     }
[13:19:05.694]     ...future.frame <- base::sys.nframe()
[13:19:05.694]     ...future.conditions <- base::list()
[13:19:05.694]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:05.694]     if (FALSE) {
[13:19:05.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:05.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:05.694]     }
[13:19:05.694]     ...future.result <- base::tryCatch({
[13:19:05.694]         base::withCallingHandlers({
[13:19:05.694]             ...future.value <- base::withVisible(base::local({
[13:19:05.694]                 ...future.makeSendCondition <- local({
[13:19:05.694]                   sendCondition <- NULL
[13:19:05.694]                   function(frame = 1L) {
[13:19:05.694]                     if (is.function(sendCondition)) 
[13:19:05.694]                       return(sendCondition)
[13:19:05.694]                     ns <- getNamespace("parallel")
[13:19:05.694]                     if (exists("sendData", mode = "function", 
[13:19:05.694]                       envir = ns)) {
[13:19:05.694]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:05.694]                         envir = ns)
[13:19:05.694]                       envir <- sys.frame(frame)
[13:19:05.694]                       master <- NULL
[13:19:05.694]                       while (!identical(envir, .GlobalEnv) && 
[13:19:05.694]                         !identical(envir, emptyenv())) {
[13:19:05.694]                         if (exists("master", mode = "list", envir = envir, 
[13:19:05.694]                           inherits = FALSE)) {
[13:19:05.694]                           master <- get("master", mode = "list", 
[13:19:05.694]                             envir = envir, inherits = FALSE)
[13:19:05.694]                           if (inherits(master, c("SOCKnode", 
[13:19:05.694]                             "SOCK0node"))) {
[13:19:05.694]                             sendCondition <<- function(cond) {
[13:19:05.694]                               data <- list(type = "VALUE", value = cond, 
[13:19:05.694]                                 success = TRUE)
[13:19:05.694]                               parallel_sendData(master, data)
[13:19:05.694]                             }
[13:19:05.694]                             return(sendCondition)
[13:19:05.694]                           }
[13:19:05.694]                         }
[13:19:05.694]                         frame <- frame + 1L
[13:19:05.694]                         envir <- sys.frame(frame)
[13:19:05.694]                       }
[13:19:05.694]                     }
[13:19:05.694]                     sendCondition <<- function(cond) NULL
[13:19:05.694]                   }
[13:19:05.694]                 })
[13:19:05.694]                 withCallingHandlers({
[13:19:05.694]                   {
[13:19:05.694]                     do.call(function(...) {
[13:19:05.694]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.694]                       if (!identical(...future.globals.maxSize.org, 
[13:19:05.694]                         ...future.globals.maxSize)) {
[13:19:05.694]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.694]                         on.exit(options(oopts), add = TRUE)
[13:19:05.694]                       }
[13:19:05.694]                       {
[13:19:05.694]                         lapply(seq_along(...future.elements_ii), 
[13:19:05.694]                           FUN = function(jj) {
[13:19:05.694]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.694]                             ...future.FUN(...future.X_jj, ...)
[13:19:05.694]                           })
[13:19:05.694]                       }
[13:19:05.694]                     }, args = future.call.arguments)
[13:19:05.694]                   }
[13:19:05.694]                 }, immediateCondition = function(cond) {
[13:19:05.694]                   sendCondition <- ...future.makeSendCondition()
[13:19:05.694]                   sendCondition(cond)
[13:19:05.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.694]                   {
[13:19:05.694]                     inherits <- base::inherits
[13:19:05.694]                     invokeRestart <- base::invokeRestart
[13:19:05.694]                     is.null <- base::is.null
[13:19:05.694]                     muffled <- FALSE
[13:19:05.694]                     if (inherits(cond, "message")) {
[13:19:05.694]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:05.694]                       if (muffled) 
[13:19:05.694]                         invokeRestart("muffleMessage")
[13:19:05.694]                     }
[13:19:05.694]                     else if (inherits(cond, "warning")) {
[13:19:05.694]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:05.694]                       if (muffled) 
[13:19:05.694]                         invokeRestart("muffleWarning")
[13:19:05.694]                     }
[13:19:05.694]                     else if (inherits(cond, "condition")) {
[13:19:05.694]                       if (!is.null(pattern)) {
[13:19:05.694]                         computeRestarts <- base::computeRestarts
[13:19:05.694]                         grepl <- base::grepl
[13:19:05.694]                         restarts <- computeRestarts(cond)
[13:19:05.694]                         for (restart in restarts) {
[13:19:05.694]                           name <- restart$name
[13:19:05.694]                           if (is.null(name)) 
[13:19:05.694]                             next
[13:19:05.694]                           if (!grepl(pattern, name)) 
[13:19:05.694]                             next
[13:19:05.694]                           invokeRestart(restart)
[13:19:05.694]                           muffled <- TRUE
[13:19:05.694]                           break
[13:19:05.694]                         }
[13:19:05.694]                       }
[13:19:05.694]                     }
[13:19:05.694]                     invisible(muffled)
[13:19:05.694]                   }
[13:19:05.694]                   muffleCondition(cond)
[13:19:05.694]                 })
[13:19:05.694]             }))
[13:19:05.694]             future::FutureResult(value = ...future.value$value, 
[13:19:05.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.694]                   ...future.rng), globalenv = if (FALSE) 
[13:19:05.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:05.694]                     ...future.globalenv.names))
[13:19:05.694]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:05.694]         }, condition = base::local({
[13:19:05.694]             c <- base::c
[13:19:05.694]             inherits <- base::inherits
[13:19:05.694]             invokeRestart <- base::invokeRestart
[13:19:05.694]             length <- base::length
[13:19:05.694]             list <- base::list
[13:19:05.694]             seq.int <- base::seq.int
[13:19:05.694]             signalCondition <- base::signalCondition
[13:19:05.694]             sys.calls <- base::sys.calls
[13:19:05.694]             `[[` <- base::`[[`
[13:19:05.694]             `+` <- base::`+`
[13:19:05.694]             `<<-` <- base::`<<-`
[13:19:05.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:05.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:05.694]                   3L)]
[13:19:05.694]             }
[13:19:05.694]             function(cond) {
[13:19:05.694]                 is_error <- inherits(cond, "error")
[13:19:05.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:05.694]                   NULL)
[13:19:05.694]                 if (is_error) {
[13:19:05.694]                   sessionInformation <- function() {
[13:19:05.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:05.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:05.694]                       search = base::search(), system = base::Sys.info())
[13:19:05.694]                   }
[13:19:05.694]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:05.694]                     cond$call), session = sessionInformation(), 
[13:19:05.694]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:05.694]                   signalCondition(cond)
[13:19:05.694]                 }
[13:19:05.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:05.694]                 "immediateCondition"))) {
[13:19:05.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:05.694]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:05.694]                   if (TRUE && !signal) {
[13:19:05.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.694]                     {
[13:19:05.694]                       inherits <- base::inherits
[13:19:05.694]                       invokeRestart <- base::invokeRestart
[13:19:05.694]                       is.null <- base::is.null
[13:19:05.694]                       muffled <- FALSE
[13:19:05.694]                       if (inherits(cond, "message")) {
[13:19:05.694]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.694]                         if (muffled) 
[13:19:05.694]                           invokeRestart("muffleMessage")
[13:19:05.694]                       }
[13:19:05.694]                       else if (inherits(cond, "warning")) {
[13:19:05.694]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.694]                         if (muffled) 
[13:19:05.694]                           invokeRestart("muffleWarning")
[13:19:05.694]                       }
[13:19:05.694]                       else if (inherits(cond, "condition")) {
[13:19:05.694]                         if (!is.null(pattern)) {
[13:19:05.694]                           computeRestarts <- base::computeRestarts
[13:19:05.694]                           grepl <- base::grepl
[13:19:05.694]                           restarts <- computeRestarts(cond)
[13:19:05.694]                           for (restart in restarts) {
[13:19:05.694]                             name <- restart$name
[13:19:05.694]                             if (is.null(name)) 
[13:19:05.694]                               next
[13:19:05.694]                             if (!grepl(pattern, name)) 
[13:19:05.694]                               next
[13:19:05.694]                             invokeRestart(restart)
[13:19:05.694]                             muffled <- TRUE
[13:19:05.694]                             break
[13:19:05.694]                           }
[13:19:05.694]                         }
[13:19:05.694]                       }
[13:19:05.694]                       invisible(muffled)
[13:19:05.694]                     }
[13:19:05.694]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.694]                   }
[13:19:05.694]                 }
[13:19:05.694]                 else {
[13:19:05.694]                   if (TRUE) {
[13:19:05.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.694]                     {
[13:19:05.694]                       inherits <- base::inherits
[13:19:05.694]                       invokeRestart <- base::invokeRestart
[13:19:05.694]                       is.null <- base::is.null
[13:19:05.694]                       muffled <- FALSE
[13:19:05.694]                       if (inherits(cond, "message")) {
[13:19:05.694]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.694]                         if (muffled) 
[13:19:05.694]                           invokeRestart("muffleMessage")
[13:19:05.694]                       }
[13:19:05.694]                       else if (inherits(cond, "warning")) {
[13:19:05.694]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.694]                         if (muffled) 
[13:19:05.694]                           invokeRestart("muffleWarning")
[13:19:05.694]                       }
[13:19:05.694]                       else if (inherits(cond, "condition")) {
[13:19:05.694]                         if (!is.null(pattern)) {
[13:19:05.694]                           computeRestarts <- base::computeRestarts
[13:19:05.694]                           grepl <- base::grepl
[13:19:05.694]                           restarts <- computeRestarts(cond)
[13:19:05.694]                           for (restart in restarts) {
[13:19:05.694]                             name <- restart$name
[13:19:05.694]                             if (is.null(name)) 
[13:19:05.694]                               next
[13:19:05.694]                             if (!grepl(pattern, name)) 
[13:19:05.694]                               next
[13:19:05.694]                             invokeRestart(restart)
[13:19:05.694]                             muffled <- TRUE
[13:19:05.694]                             break
[13:19:05.694]                           }
[13:19:05.694]                         }
[13:19:05.694]                       }
[13:19:05.694]                       invisible(muffled)
[13:19:05.694]                     }
[13:19:05.694]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.694]                   }
[13:19:05.694]                 }
[13:19:05.694]             }
[13:19:05.694]         }))
[13:19:05.694]     }, error = function(ex) {
[13:19:05.694]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:05.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.694]                 ...future.rng), started = ...future.startTime, 
[13:19:05.694]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:05.694]             version = "1.8"), class = "FutureResult")
[13:19:05.694]     }, finally = {
[13:19:05.694]         if (!identical(...future.workdir, getwd())) 
[13:19:05.694]             setwd(...future.workdir)
[13:19:05.694]         {
[13:19:05.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:05.694]                 ...future.oldOptions$nwarnings <- NULL
[13:19:05.694]             }
[13:19:05.694]             base::options(...future.oldOptions)
[13:19:05.694]             if (.Platform$OS.type == "windows") {
[13:19:05.694]                 old_names <- names(...future.oldEnvVars)
[13:19:05.694]                 envs <- base::Sys.getenv()
[13:19:05.694]                 names <- names(envs)
[13:19:05.694]                 common <- intersect(names, old_names)
[13:19:05.694]                 added <- setdiff(names, old_names)
[13:19:05.694]                 removed <- setdiff(old_names, names)
[13:19:05.694]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:05.694]                   envs[common]]
[13:19:05.694]                 NAMES <- toupper(changed)
[13:19:05.694]                 args <- list()
[13:19:05.694]                 for (kk in seq_along(NAMES)) {
[13:19:05.694]                   name <- changed[[kk]]
[13:19:05.694]                   NAME <- NAMES[[kk]]
[13:19:05.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.694]                     next
[13:19:05.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.694]                 }
[13:19:05.694]                 NAMES <- toupper(added)
[13:19:05.694]                 for (kk in seq_along(NAMES)) {
[13:19:05.694]                   name <- added[[kk]]
[13:19:05.694]                   NAME <- NAMES[[kk]]
[13:19:05.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.694]                     next
[13:19:05.694]                   args[[name]] <- ""
[13:19:05.694]                 }
[13:19:05.694]                 NAMES <- toupper(removed)
[13:19:05.694]                 for (kk in seq_along(NAMES)) {
[13:19:05.694]                   name <- removed[[kk]]
[13:19:05.694]                   NAME <- NAMES[[kk]]
[13:19:05.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.694]                     next
[13:19:05.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.694]                 }
[13:19:05.694]                 if (length(args) > 0) 
[13:19:05.694]                   base::do.call(base::Sys.setenv, args = args)
[13:19:05.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:05.694]             }
[13:19:05.694]             else {
[13:19:05.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:05.694]             }
[13:19:05.694]             {
[13:19:05.694]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:05.694]                   0L) {
[13:19:05.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:05.694]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:05.694]                   base::options(opts)
[13:19:05.694]                 }
[13:19:05.694]                 {
[13:19:05.694]                   {
[13:19:05.694]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:05.694]                     NULL
[13:19:05.694]                   }
[13:19:05.694]                   options(future.plan = NULL)
[13:19:05.694]                   if (is.na(NA_character_)) 
[13:19:05.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:05.694]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:05.694]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:05.694]                     envir = parent.frame()) 
[13:19:05.694]                   {
[13:19:05.694]                     if (is.function(workers)) 
[13:19:05.694]                       workers <- workers()
[13:19:05.694]                     workers <- structure(as.integer(workers), 
[13:19:05.694]                       class = class(workers))
[13:19:05.694]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:05.694]                       workers >= 1)
[13:19:05.694]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:05.694]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:05.694]                     }
[13:19:05.694]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:05.694]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:05.694]                       envir = envir)
[13:19:05.694]                     if (!future$lazy) 
[13:19:05.694]                       future <- run(future)
[13:19:05.694]                     invisible(future)
[13:19:05.694]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:05.694]                 }
[13:19:05.694]             }
[13:19:05.694]         }
[13:19:05.694]     })
[13:19:05.694]     if (TRUE) {
[13:19:05.694]         base::sink(type = "output", split = FALSE)
[13:19:05.694]         if (TRUE) {
[13:19:05.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:05.694]         }
[13:19:05.694]         else {
[13:19:05.694]             ...future.result["stdout"] <- base::list(NULL)
[13:19:05.694]         }
[13:19:05.694]         base::close(...future.stdout)
[13:19:05.694]         ...future.stdout <- NULL
[13:19:05.694]     }
[13:19:05.694]     ...future.result$conditions <- ...future.conditions
[13:19:05.694]     ...future.result$finished <- base::Sys.time()
[13:19:05.694]     ...future.result
[13:19:05.694] }
[13:19:05.697] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[13:19:05.697] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[13:19:05.698] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[13:19:05.698] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[13:19:05.698] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[13:19:05.699] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:19:05.699] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:19:05.699] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:05.699] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.699] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:05.700] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.700] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[13:19:05.700] MultisessionFuture started
[13:19:05.700] - Launch lazy future ... done
[13:19:05.700] run() for ‘MultisessionFuture’ ... done
[13:19:05.701] Created future:
[13:19:05.701] MultisessionFuture:
[13:19:05.701] Label: ‘future_sapply-1’
[13:19:05.701] Expression:
[13:19:05.701] {
[13:19:05.701]     do.call(function(...) {
[13:19:05.701]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.701]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.701]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.701]             on.exit(options(oopts), add = TRUE)
[13:19:05.701]         }
[13:19:05.701]         {
[13:19:05.701]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.701]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.701]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.701]             })
[13:19:05.701]         }
[13:19:05.701]     }, args = future.call.arguments)
[13:19:05.701] }
[13:19:05.701] Lazy evaluation: FALSE
[13:19:05.701] Asynchronous evaluation: TRUE
[13:19:05.701] Local evaluation: TRUE
[13:19:05.701] Environment: R_GlobalEnv
[13:19:05.701] Capture standard output: TRUE
[13:19:05.701] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.701] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:05.701] Packages: <none>
[13:19:05.701] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.701] Resolved: FALSE
[13:19:05.701] Value: <not collected>
[13:19:05.701] Conditions captured: <none>
[13:19:05.701] Early signaling: FALSE
[13:19:05.701] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.701] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.712] Chunk #1 of 2 ... DONE
[13:19:05.712] Chunk #2 of 2 ...
[13:19:05.713]  - Finding globals in 'X' for chunk #2 ...
[13:19:05.713] getGlobalsAndPackages() ...
[13:19:05.713] Searching for globals...
[13:19:05.713] 
[13:19:05.713] Searching for globals ... DONE
[13:19:05.713] - globals: [0] <none>
[13:19:05.713] getGlobalsAndPackages() ... DONE
[13:19:05.713]    + additional globals found: [n=0] 
[13:19:05.713]    + additional namespaces needed: [n=0] 
[13:19:05.714]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:05.714]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:05.714]  - seeds: <none>
[13:19:05.714] getGlobalsAndPackages() ...
[13:19:05.714] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.714] Resolving globals: FALSE
[13:19:05.714] Tweak future expression to call with '...' arguments ...
[13:19:05.714] {
[13:19:05.714]     do.call(function(...) {
[13:19:05.714]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.714]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.714]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.714]             on.exit(options(oopts), add = TRUE)
[13:19:05.714]         }
[13:19:05.714]         {
[13:19:05.714]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.714]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.714]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.714]             })
[13:19:05.714]         }
[13:19:05.714]     }, args = future.call.arguments)
[13:19:05.714] }
[13:19:05.715] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.715] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.715] 
[13:19:05.715] getGlobalsAndPackages() ... DONE
[13:19:05.715] run() for ‘Future’ ...
[13:19:05.715] - state: ‘created’
[13:19:05.716] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:05.730] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:05.730]   - Field: ‘node’
[13:19:05.730]   - Field: ‘label’
[13:19:05.731]   - Field: ‘local’
[13:19:05.731]   - Field: ‘owner’
[13:19:05.731]   - Field: ‘envir’
[13:19:05.731]   - Field: ‘workers’
[13:19:05.731]   - Field: ‘packages’
[13:19:05.731]   - Field: ‘gc’
[13:19:05.731]   - Field: ‘conditions’
[13:19:05.731]   - Field: ‘persistent’
[13:19:05.731]   - Field: ‘expr’
[13:19:05.731]   - Field: ‘uuid’
[13:19:05.731]   - Field: ‘seed’
[13:19:05.732]   - Field: ‘version’
[13:19:05.732]   - Field: ‘result’
[13:19:05.732]   - Field: ‘asynchronous’
[13:19:05.732]   - Field: ‘calls’
[13:19:05.732]   - Field: ‘globals’
[13:19:05.732]   - Field: ‘stdout’
[13:19:05.732]   - Field: ‘earlySignal’
[13:19:05.732]   - Field: ‘lazy’
[13:19:05.732]   - Field: ‘state’
[13:19:05.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:05.732] - Launch lazy future ...
[13:19:05.733] Packages needed by the future expression (n = 0): <none>
[13:19:05.733] Packages needed by future strategies (n = 0): <none>
[13:19:05.733] {
[13:19:05.733]     {
[13:19:05.733]         {
[13:19:05.733]             ...future.startTime <- base::Sys.time()
[13:19:05.733]             {
[13:19:05.733]                 {
[13:19:05.733]                   {
[13:19:05.733]                     {
[13:19:05.733]                       base::local({
[13:19:05.733]                         has_future <- base::requireNamespace("future", 
[13:19:05.733]                           quietly = TRUE)
[13:19:05.733]                         if (has_future) {
[13:19:05.733]                           ns <- base::getNamespace("future")
[13:19:05.733]                           version <- ns[[".package"]][["version"]]
[13:19:05.733]                           if (is.null(version)) 
[13:19:05.733]                             version <- utils::packageVersion("future")
[13:19:05.733]                         }
[13:19:05.733]                         else {
[13:19:05.733]                           version <- NULL
[13:19:05.733]                         }
[13:19:05.733]                         if (!has_future || version < "1.8.0") {
[13:19:05.733]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:05.733]                             "", base::R.version$version.string), 
[13:19:05.733]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:05.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:05.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:05.733]                               "release", "version")], collapse = " "), 
[13:19:05.733]                             hostname = base::Sys.info()[["nodename"]])
[13:19:05.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:05.733]                             info)
[13:19:05.733]                           info <- base::paste(info, collapse = "; ")
[13:19:05.733]                           if (!has_future) {
[13:19:05.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:05.733]                               info)
[13:19:05.733]                           }
[13:19:05.733]                           else {
[13:19:05.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:05.733]                               info, version)
[13:19:05.733]                           }
[13:19:05.733]                           base::stop(msg)
[13:19:05.733]                         }
[13:19:05.733]                       })
[13:19:05.733]                     }
[13:19:05.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:05.733]                     base::options(mc.cores = 1L)
[13:19:05.733]                   }
[13:19:05.733]                   options(future.plan = NULL)
[13:19:05.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:05.733]                 }
[13:19:05.733]                 ...future.workdir <- getwd()
[13:19:05.733]             }
[13:19:05.733]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:05.733]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:05.733]         }
[13:19:05.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:05.733]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:05.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:05.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:05.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:05.733]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:05.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:05.733]             base::names(...future.oldOptions))
[13:19:05.733]     }
[13:19:05.733]     if (FALSE) {
[13:19:05.733]     }
[13:19:05.733]     else {
[13:19:05.733]         if (TRUE) {
[13:19:05.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:05.733]                 open = "w")
[13:19:05.733]         }
[13:19:05.733]         else {
[13:19:05.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:05.733]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:05.733]         }
[13:19:05.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:05.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:05.733]             base::sink(type = "output", split = FALSE)
[13:19:05.733]             base::close(...future.stdout)
[13:19:05.733]         }, add = TRUE)
[13:19:05.733]     }
[13:19:05.733]     ...future.frame <- base::sys.nframe()
[13:19:05.733]     ...future.conditions <- base::list()
[13:19:05.733]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:05.733]     if (FALSE) {
[13:19:05.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:05.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:05.733]     }
[13:19:05.733]     ...future.result <- base::tryCatch({
[13:19:05.733]         base::withCallingHandlers({
[13:19:05.733]             ...future.value <- base::withVisible(base::local({
[13:19:05.733]                 ...future.makeSendCondition <- local({
[13:19:05.733]                   sendCondition <- NULL
[13:19:05.733]                   function(frame = 1L) {
[13:19:05.733]                     if (is.function(sendCondition)) 
[13:19:05.733]                       return(sendCondition)
[13:19:05.733]                     ns <- getNamespace("parallel")
[13:19:05.733]                     if (exists("sendData", mode = "function", 
[13:19:05.733]                       envir = ns)) {
[13:19:05.733]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:05.733]                         envir = ns)
[13:19:05.733]                       envir <- sys.frame(frame)
[13:19:05.733]                       master <- NULL
[13:19:05.733]                       while (!identical(envir, .GlobalEnv) && 
[13:19:05.733]                         !identical(envir, emptyenv())) {
[13:19:05.733]                         if (exists("master", mode = "list", envir = envir, 
[13:19:05.733]                           inherits = FALSE)) {
[13:19:05.733]                           master <- get("master", mode = "list", 
[13:19:05.733]                             envir = envir, inherits = FALSE)
[13:19:05.733]                           if (inherits(master, c("SOCKnode", 
[13:19:05.733]                             "SOCK0node"))) {
[13:19:05.733]                             sendCondition <<- function(cond) {
[13:19:05.733]                               data <- list(type = "VALUE", value = cond, 
[13:19:05.733]                                 success = TRUE)
[13:19:05.733]                               parallel_sendData(master, data)
[13:19:05.733]                             }
[13:19:05.733]                             return(sendCondition)
[13:19:05.733]                           }
[13:19:05.733]                         }
[13:19:05.733]                         frame <- frame + 1L
[13:19:05.733]                         envir <- sys.frame(frame)
[13:19:05.733]                       }
[13:19:05.733]                     }
[13:19:05.733]                     sendCondition <<- function(cond) NULL
[13:19:05.733]                   }
[13:19:05.733]                 })
[13:19:05.733]                 withCallingHandlers({
[13:19:05.733]                   {
[13:19:05.733]                     do.call(function(...) {
[13:19:05.733]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.733]                       if (!identical(...future.globals.maxSize.org, 
[13:19:05.733]                         ...future.globals.maxSize)) {
[13:19:05.733]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.733]                         on.exit(options(oopts), add = TRUE)
[13:19:05.733]                       }
[13:19:05.733]                       {
[13:19:05.733]                         lapply(seq_along(...future.elements_ii), 
[13:19:05.733]                           FUN = function(jj) {
[13:19:05.733]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.733]                             ...future.FUN(...future.X_jj, ...)
[13:19:05.733]                           })
[13:19:05.733]                       }
[13:19:05.733]                     }, args = future.call.arguments)
[13:19:05.733]                   }
[13:19:05.733]                 }, immediateCondition = function(cond) {
[13:19:05.733]                   sendCondition <- ...future.makeSendCondition()
[13:19:05.733]                   sendCondition(cond)
[13:19:05.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.733]                   {
[13:19:05.733]                     inherits <- base::inherits
[13:19:05.733]                     invokeRestart <- base::invokeRestart
[13:19:05.733]                     is.null <- base::is.null
[13:19:05.733]                     muffled <- FALSE
[13:19:05.733]                     if (inherits(cond, "message")) {
[13:19:05.733]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:05.733]                       if (muffled) 
[13:19:05.733]                         invokeRestart("muffleMessage")
[13:19:05.733]                     }
[13:19:05.733]                     else if (inherits(cond, "warning")) {
[13:19:05.733]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:05.733]                       if (muffled) 
[13:19:05.733]                         invokeRestart("muffleWarning")
[13:19:05.733]                     }
[13:19:05.733]                     else if (inherits(cond, "condition")) {
[13:19:05.733]                       if (!is.null(pattern)) {
[13:19:05.733]                         computeRestarts <- base::computeRestarts
[13:19:05.733]                         grepl <- base::grepl
[13:19:05.733]                         restarts <- computeRestarts(cond)
[13:19:05.733]                         for (restart in restarts) {
[13:19:05.733]                           name <- restart$name
[13:19:05.733]                           if (is.null(name)) 
[13:19:05.733]                             next
[13:19:05.733]                           if (!grepl(pattern, name)) 
[13:19:05.733]                             next
[13:19:05.733]                           invokeRestart(restart)
[13:19:05.733]                           muffled <- TRUE
[13:19:05.733]                           break
[13:19:05.733]                         }
[13:19:05.733]                       }
[13:19:05.733]                     }
[13:19:05.733]                     invisible(muffled)
[13:19:05.733]                   }
[13:19:05.733]                   muffleCondition(cond)
[13:19:05.733]                 })
[13:19:05.733]             }))
[13:19:05.733]             future::FutureResult(value = ...future.value$value, 
[13:19:05.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.733]                   ...future.rng), globalenv = if (FALSE) 
[13:19:05.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:05.733]                     ...future.globalenv.names))
[13:19:05.733]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:05.733]         }, condition = base::local({
[13:19:05.733]             c <- base::c
[13:19:05.733]             inherits <- base::inherits
[13:19:05.733]             invokeRestart <- base::invokeRestart
[13:19:05.733]             length <- base::length
[13:19:05.733]             list <- base::list
[13:19:05.733]             seq.int <- base::seq.int
[13:19:05.733]             signalCondition <- base::signalCondition
[13:19:05.733]             sys.calls <- base::sys.calls
[13:19:05.733]             `[[` <- base::`[[`
[13:19:05.733]             `+` <- base::`+`
[13:19:05.733]             `<<-` <- base::`<<-`
[13:19:05.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:05.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:05.733]                   3L)]
[13:19:05.733]             }
[13:19:05.733]             function(cond) {
[13:19:05.733]                 is_error <- inherits(cond, "error")
[13:19:05.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:05.733]                   NULL)
[13:19:05.733]                 if (is_error) {
[13:19:05.733]                   sessionInformation <- function() {
[13:19:05.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:05.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:05.733]                       search = base::search(), system = base::Sys.info())
[13:19:05.733]                   }
[13:19:05.733]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:05.733]                     cond$call), session = sessionInformation(), 
[13:19:05.733]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:05.733]                   signalCondition(cond)
[13:19:05.733]                 }
[13:19:05.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:05.733]                 "immediateCondition"))) {
[13:19:05.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:05.733]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:05.733]                   if (TRUE && !signal) {
[13:19:05.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.733]                     {
[13:19:05.733]                       inherits <- base::inherits
[13:19:05.733]                       invokeRestart <- base::invokeRestart
[13:19:05.733]                       is.null <- base::is.null
[13:19:05.733]                       muffled <- FALSE
[13:19:05.733]                       if (inherits(cond, "message")) {
[13:19:05.733]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.733]                         if (muffled) 
[13:19:05.733]                           invokeRestart("muffleMessage")
[13:19:05.733]                       }
[13:19:05.733]                       else if (inherits(cond, "warning")) {
[13:19:05.733]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.733]                         if (muffled) 
[13:19:05.733]                           invokeRestart("muffleWarning")
[13:19:05.733]                       }
[13:19:05.733]                       else if (inherits(cond, "condition")) {
[13:19:05.733]                         if (!is.null(pattern)) {
[13:19:05.733]                           computeRestarts <- base::computeRestarts
[13:19:05.733]                           grepl <- base::grepl
[13:19:05.733]                           restarts <- computeRestarts(cond)
[13:19:05.733]                           for (restart in restarts) {
[13:19:05.733]                             name <- restart$name
[13:19:05.733]                             if (is.null(name)) 
[13:19:05.733]                               next
[13:19:05.733]                             if (!grepl(pattern, name)) 
[13:19:05.733]                               next
[13:19:05.733]                             invokeRestart(restart)
[13:19:05.733]                             muffled <- TRUE
[13:19:05.733]                             break
[13:19:05.733]                           }
[13:19:05.733]                         }
[13:19:05.733]                       }
[13:19:05.733]                       invisible(muffled)
[13:19:05.733]                     }
[13:19:05.733]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.733]                   }
[13:19:05.733]                 }
[13:19:05.733]                 else {
[13:19:05.733]                   if (TRUE) {
[13:19:05.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.733]                     {
[13:19:05.733]                       inherits <- base::inherits
[13:19:05.733]                       invokeRestart <- base::invokeRestart
[13:19:05.733]                       is.null <- base::is.null
[13:19:05.733]                       muffled <- FALSE
[13:19:05.733]                       if (inherits(cond, "message")) {
[13:19:05.733]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.733]                         if (muffled) 
[13:19:05.733]                           invokeRestart("muffleMessage")
[13:19:05.733]                       }
[13:19:05.733]                       else if (inherits(cond, "warning")) {
[13:19:05.733]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.733]                         if (muffled) 
[13:19:05.733]                           invokeRestart("muffleWarning")
[13:19:05.733]                       }
[13:19:05.733]                       else if (inherits(cond, "condition")) {
[13:19:05.733]                         if (!is.null(pattern)) {
[13:19:05.733]                           computeRestarts <- base::computeRestarts
[13:19:05.733]                           grepl <- base::grepl
[13:19:05.733]                           restarts <- computeRestarts(cond)
[13:19:05.733]                           for (restart in restarts) {
[13:19:05.733]                             name <- restart$name
[13:19:05.733]                             if (is.null(name)) 
[13:19:05.733]                               next
[13:19:05.733]                             if (!grepl(pattern, name)) 
[13:19:05.733]                               next
[13:19:05.733]                             invokeRestart(restart)
[13:19:05.733]                             muffled <- TRUE
[13:19:05.733]                             break
[13:19:05.733]                           }
[13:19:05.733]                         }
[13:19:05.733]                       }
[13:19:05.733]                       invisible(muffled)
[13:19:05.733]                     }
[13:19:05.733]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.733]                   }
[13:19:05.733]                 }
[13:19:05.733]             }
[13:19:05.733]         }))
[13:19:05.733]     }, error = function(ex) {
[13:19:05.733]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:05.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.733]                 ...future.rng), started = ...future.startTime, 
[13:19:05.733]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:05.733]             version = "1.8"), class = "FutureResult")
[13:19:05.733]     }, finally = {
[13:19:05.733]         if (!identical(...future.workdir, getwd())) 
[13:19:05.733]             setwd(...future.workdir)
[13:19:05.733]         {
[13:19:05.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:05.733]                 ...future.oldOptions$nwarnings <- NULL
[13:19:05.733]             }
[13:19:05.733]             base::options(...future.oldOptions)
[13:19:05.733]             if (.Platform$OS.type == "windows") {
[13:19:05.733]                 old_names <- names(...future.oldEnvVars)
[13:19:05.733]                 envs <- base::Sys.getenv()
[13:19:05.733]                 names <- names(envs)
[13:19:05.733]                 common <- intersect(names, old_names)
[13:19:05.733]                 added <- setdiff(names, old_names)
[13:19:05.733]                 removed <- setdiff(old_names, names)
[13:19:05.733]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:05.733]                   envs[common]]
[13:19:05.733]                 NAMES <- toupper(changed)
[13:19:05.733]                 args <- list()
[13:19:05.733]                 for (kk in seq_along(NAMES)) {
[13:19:05.733]                   name <- changed[[kk]]
[13:19:05.733]                   NAME <- NAMES[[kk]]
[13:19:05.733]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.733]                     next
[13:19:05.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.733]                 }
[13:19:05.733]                 NAMES <- toupper(added)
[13:19:05.733]                 for (kk in seq_along(NAMES)) {
[13:19:05.733]                   name <- added[[kk]]
[13:19:05.733]                   NAME <- NAMES[[kk]]
[13:19:05.733]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.733]                     next
[13:19:05.733]                   args[[name]] <- ""
[13:19:05.733]                 }
[13:19:05.733]                 NAMES <- toupper(removed)
[13:19:05.733]                 for (kk in seq_along(NAMES)) {
[13:19:05.733]                   name <- removed[[kk]]
[13:19:05.733]                   NAME <- NAMES[[kk]]
[13:19:05.733]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.733]                     next
[13:19:05.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.733]                 }
[13:19:05.733]                 if (length(args) > 0) 
[13:19:05.733]                   base::do.call(base::Sys.setenv, args = args)
[13:19:05.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:05.733]             }
[13:19:05.733]             else {
[13:19:05.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:05.733]             }
[13:19:05.733]             {
[13:19:05.733]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:05.733]                   0L) {
[13:19:05.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:05.733]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:05.733]                   base::options(opts)
[13:19:05.733]                 }
[13:19:05.733]                 {
[13:19:05.733]                   {
[13:19:05.733]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:05.733]                     NULL
[13:19:05.733]                   }
[13:19:05.733]                   options(future.plan = NULL)
[13:19:05.733]                   if (is.na(NA_character_)) 
[13:19:05.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:05.733]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:05.733]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:05.733]                     envir = parent.frame()) 
[13:19:05.733]                   {
[13:19:05.733]                     if (is.function(workers)) 
[13:19:05.733]                       workers <- workers()
[13:19:05.733]                     workers <- structure(as.integer(workers), 
[13:19:05.733]                       class = class(workers))
[13:19:05.733]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:05.733]                       workers >= 1)
[13:19:05.733]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:05.733]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:05.733]                     }
[13:19:05.733]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:05.733]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:05.733]                       envir = envir)
[13:19:05.733]                     if (!future$lazy) 
[13:19:05.733]                       future <- run(future)
[13:19:05.733]                     invisible(future)
[13:19:05.733]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:05.733]                 }
[13:19:05.733]             }
[13:19:05.733]         }
[13:19:05.733]     })
[13:19:05.733]     if (TRUE) {
[13:19:05.733]         base::sink(type = "output", split = FALSE)
[13:19:05.733]         if (TRUE) {
[13:19:05.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:05.733]         }
[13:19:05.733]         else {
[13:19:05.733]             ...future.result["stdout"] <- base::list(NULL)
[13:19:05.733]         }
[13:19:05.733]         base::close(...future.stdout)
[13:19:05.733]         ...future.stdout <- NULL
[13:19:05.733]     }
[13:19:05.733]     ...future.result$conditions <- ...future.conditions
[13:19:05.733]     ...future.result$finished <- base::Sys.time()
[13:19:05.733]     ...future.result
[13:19:05.733] }
[13:19:05.736] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[13:19:05.736] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[13:19:05.737] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[13:19:05.737] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[13:19:05.737] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[13:19:05.737] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:05.738] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:05.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:05.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.738] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:05.738] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:05.739] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[13:19:05.739] MultisessionFuture started
[13:19:05.739] - Launch lazy future ... done
[13:19:05.739] run() for ‘MultisessionFuture’ ... done
[13:19:05.739] Created future:
[13:19:05.739] MultisessionFuture:
[13:19:05.739] Label: ‘future_sapply-2’
[13:19:05.739] Expression:
[13:19:05.739] {
[13:19:05.739]     do.call(function(...) {
[13:19:05.739]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.739]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.739]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.739]             on.exit(options(oopts), add = TRUE)
[13:19:05.739]         }
[13:19:05.739]         {
[13:19:05.739]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.739]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.739]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.739]             })
[13:19:05.739]         }
[13:19:05.739]     }, args = future.call.arguments)
[13:19:05.739] }
[13:19:05.739] Lazy evaluation: FALSE
[13:19:05.739] Asynchronous evaluation: TRUE
[13:19:05.739] Local evaluation: TRUE
[13:19:05.739] Environment: R_GlobalEnv
[13:19:05.739] Capture standard output: TRUE
[13:19:05.739] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.739] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:05.739] Packages: <none>
[13:19:05.739] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.739] Resolved: FALSE
[13:19:05.739] Value: <not collected>
[13:19:05.739] Conditions captured: <none>
[13:19:05.739] Early signaling: FALSE
[13:19:05.739] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.739] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.751] Chunk #2 of 2 ... DONE
[13:19:05.751] Launching 2 futures (chunks) ... DONE
[13:19:05.751] Resolving 2 futures (chunks) ...
[13:19:05.751] resolve() on list ...
[13:19:05.752]  recursive: 0
[13:19:05.752]  length: 2
[13:19:05.752] 
[13:19:05.752] receiveMessageFromWorker() for ClusterFuture ...
[13:19:05.752] - Validating connection of MultisessionFuture
[13:19:05.753] - received message: FutureResult
[13:19:05.753] - Received FutureResult
[13:19:05.753] - Erased future from FutureRegistry
[13:19:05.753] result() for ClusterFuture ...
[13:19:05.753] - result already collected: FutureResult
[13:19:05.753] result() for ClusterFuture ... done
[13:19:05.753] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:05.753] Future #1
[13:19:05.753] result() for ClusterFuture ...
[13:19:05.753] - result already collected: FutureResult
[13:19:05.754] result() for ClusterFuture ... done
[13:19:05.754] result() for ClusterFuture ...
[13:19:05.754] - result already collected: FutureResult
[13:19:05.754] result() for ClusterFuture ... done
[13:19:05.754] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:05.754] - nx: 2
[13:19:05.754] - relay: TRUE
[13:19:05.754] - stdout: TRUE
[13:19:05.754] - signal: TRUE
[13:19:05.754] - resignal: FALSE
[13:19:05.754] - force: TRUE
[13:19:05.754] - relayed: [n=2] FALSE, FALSE
[13:19:05.755] - queued futures: [n=2] FALSE, FALSE
[13:19:05.755]  - until=1
[13:19:05.755]  - relaying element #1
[13:19:05.755] result() for ClusterFuture ...
[13:19:05.755] - result already collected: FutureResult
[13:19:05.755] result() for ClusterFuture ... done
[13:19:05.755] result() for ClusterFuture ...
[13:19:05.755] - result already collected: FutureResult
[13:19:05.755] result() for ClusterFuture ... done
[13:19:05.755] result() for ClusterFuture ...
[13:19:05.755] - result already collected: FutureResult
[13:19:05.756] result() for ClusterFuture ... done
[13:19:05.756] result() for ClusterFuture ...
[13:19:05.756] - result already collected: FutureResult
[13:19:05.756] result() for ClusterFuture ... done
[13:19:05.756] - relayed: [n=2] TRUE, FALSE
[13:19:05.756] - queued futures: [n=2] TRUE, FALSE
[13:19:05.756] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:05.756]  length: 1 (resolved future 1)
[13:19:05.786] receiveMessageFromWorker() for ClusterFuture ...
[13:19:05.786] - Validating connection of MultisessionFuture
[13:19:05.786] - received message: FutureResult
[13:19:05.786] - Received FutureResult
[13:19:05.786] - Erased future from FutureRegistry
[13:19:05.787] result() for ClusterFuture ...
[13:19:05.787] - result already collected: FutureResult
[13:19:05.787] result() for ClusterFuture ... done
[13:19:05.787] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:05.787] Future #2
[13:19:05.787] result() for ClusterFuture ...
[13:19:05.787] - result already collected: FutureResult
[13:19:05.787] result() for ClusterFuture ... done
[13:19:05.787] result() for ClusterFuture ...
[13:19:05.787] - result already collected: FutureResult
[13:19:05.787] result() for ClusterFuture ... done
[13:19:05.788] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:05.788] - nx: 2
[13:19:05.788] - relay: TRUE
[13:19:05.788] - stdout: TRUE
[13:19:05.788] - signal: TRUE
[13:19:05.788] - resignal: FALSE
[13:19:05.788] - force: TRUE
[13:19:05.788] - relayed: [n=2] TRUE, FALSE
[13:19:05.788] - queued futures: [n=2] TRUE, FALSE
[13:19:05.788]  - until=2
[13:19:05.788]  - relaying element #2
[13:19:05.789] result() for ClusterFuture ...
[13:19:05.789] - result already collected: FutureResult
[13:19:05.789] result() for ClusterFuture ... done
[13:19:05.789] result() for ClusterFuture ...
[13:19:05.789] - result already collected: FutureResult
[13:19:05.789] result() for ClusterFuture ... done
[13:19:05.789] result() for ClusterFuture ...
[13:19:05.789] - result already collected: FutureResult
[13:19:05.789] result() for ClusterFuture ... done
[13:19:05.789] result() for ClusterFuture ...
[13:19:05.789] - result already collected: FutureResult
[13:19:05.790] result() for ClusterFuture ... done
[13:19:05.790] - relayed: [n=2] TRUE, TRUE
[13:19:05.790] - queued futures: [n=2] TRUE, TRUE
[13:19:05.790] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:05.790]  length: 0 (resolved future 2)
[13:19:05.790] Relaying remaining futures
[13:19:05.790] signalConditionsASAP(NULL, pos=0) ...
[13:19:05.790] - nx: 2
[13:19:05.790] - relay: TRUE
[13:19:05.790] - stdout: TRUE
[13:19:05.790] - signal: TRUE
[13:19:05.790] - resignal: FALSE
[13:19:05.791] - force: TRUE
[13:19:05.791] - relayed: [n=2] TRUE, TRUE
[13:19:05.791] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:05.791] - relayed: [n=2] TRUE, TRUE
[13:19:05.791] - queued futures: [n=2] TRUE, TRUE
[13:19:05.791] signalConditionsASAP(NULL, pos=0) ... done
[13:19:05.791] resolve() on list ... DONE
[13:19:05.791] result() for ClusterFuture ...
[13:19:05.791] - result already collected: FutureResult
[13:19:05.791] result() for ClusterFuture ... done
[13:19:05.791] result() for ClusterFuture ...
[13:19:05.792] - result already collected: FutureResult
[13:19:05.792] result() for ClusterFuture ... done
[13:19:05.792] result() for ClusterFuture ...
[13:19:05.792] - result already collected: FutureResult
[13:19:05.792] result() for ClusterFuture ... done
[13:19:05.792] result() for ClusterFuture ...
[13:19:05.792] - result already collected: FutureResult
[13:19:05.792] result() for ClusterFuture ... done
[13:19:05.792]  - Number of value chunks collected: 2
[13:19:05.792] Resolving 2 futures (chunks) ... DONE
[13:19:05.792] Reducing values from 2 chunks ...
[13:19:05.793]  - Number of values collected after concatenation: 4
[13:19:05.793]  - Number of values expected: 4
[13:19:05.793] Reducing values from 2 chunks ... DONE
[13:19:05.793] future_lapply() ... DONE
[13:19:05.793] future_lapply() ...
[13:19:05.799] Number of chunks: 2
[13:19:05.799] getGlobalsAndPackagesXApply() ...
[13:19:05.799]  - future.globals: TRUE
[13:19:05.799] getGlobalsAndPackages() ...
[13:19:05.799] Searching for globals...
[13:19:05.803] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:19:05.803] Searching for globals ... DONE
[13:19:05.803] Resolving globals: FALSE
[13:19:05.804] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:19:05.804] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:05.804] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:05.805] - packages: [1] ‘future.apply’
[13:19:05.805] getGlobalsAndPackages() ... DONE
[13:19:05.805]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:05.805]  - needed namespaces: [n=1] ‘future.apply’
[13:19:05.805] Finding globals ... DONE
[13:19:05.805]  - use_args: TRUE
[13:19:05.805]  - Getting '...' globals ...
[13:19:05.805] resolve() on list ...
[13:19:05.806]  recursive: 0
[13:19:05.806]  length: 1
[13:19:05.806]  elements: ‘...’
[13:19:05.806]  length: 0 (resolved future 1)
[13:19:05.806] resolve() on list ... DONE
[13:19:05.806]    - '...' content: [n=1] ‘y’
[13:19:05.806] List of 1
[13:19:05.806]  $ ...:List of 1
[13:19:05.806]   ..$ y: num [1:5] 2 4 6 8 10
[13:19:05.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:05.806]  - attr(*, "where")=List of 1
[13:19:05.806]   ..$ ...:<environment: 0x555f7c17ae38> 
[13:19:05.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:05.806]  - attr(*, "resolved")= logi TRUE
[13:19:05.806]  - attr(*, "total_size")= num NA
[13:19:05.809]  - Getting '...' globals ... DONE
[13:19:05.809] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:05.810] List of 8
[13:19:05.810]  $ ...future.FUN:function (x, ...)  
[13:19:05.810]  $ x_FUN        :function (x, y)  
[13:19:05.810]  $ times        : int 15
[13:19:05.810]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:05.810]  $ stop_if_not  :function (...)  
[13:19:05.810]  $ dim          : int [1:2] 3 5
[13:19:05.810]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:05.810]  $ ...          :List of 1
[13:19:05.810]   ..$ y: num [1:5] 2 4 6 8 10
[13:19:05.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:05.810]  - attr(*, "where")=List of 8
[13:19:05.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:05.810]   ..$ ...          :<environment: 0x555f7c17ae38> 
[13:19:05.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:05.810]  - attr(*, "resolved")= logi FALSE
[13:19:05.810]  - attr(*, "total_size")= num 98600
[13:19:05.818] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:05.818] getGlobalsAndPackagesXApply() ... DONE
[13:19:05.818] Number of futures (= number of chunks): 2
[13:19:05.818] Launching 2 futures (chunks) ...
[13:19:05.818] Chunk #1 of 2 ...
[13:19:05.818]  - Finding globals in 'X' for chunk #1 ...
[13:19:05.818] getGlobalsAndPackages() ...
[13:19:05.819] Searching for globals...
[13:19:05.819] 
[13:19:05.819] Searching for globals ... DONE
[13:19:05.819] - globals: [0] <none>
[13:19:05.819] getGlobalsAndPackages() ... DONE
[13:19:05.819]    + additional globals found: [n=0] 
[13:19:05.819]    + additional namespaces needed: [n=0] 
[13:19:05.819]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:05.819]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:05.819]  - seeds: <none>
[13:19:05.820] getGlobalsAndPackages() ...
[13:19:05.820] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.820] Resolving globals: FALSE
[13:19:05.820] Tweak future expression to call with '...' arguments ...
[13:19:05.820] {
[13:19:05.820]     do.call(function(...) {
[13:19:05.820]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.820]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.820]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.820]             on.exit(options(oopts), add = TRUE)
[13:19:05.820]         }
[13:19:05.820]         {
[13:19:05.820]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.820]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.820]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.820]             })
[13:19:05.820]         }
[13:19:05.820]     }, args = future.call.arguments)
[13:19:05.820] }
[13:19:05.820] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.821] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.821] - packages: [1] ‘future.apply’
[13:19:05.821] getGlobalsAndPackages() ... DONE
[13:19:05.821] run() for ‘Future’ ...
[13:19:05.821] - state: ‘created’
[13:19:05.822] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:05.836] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:05.836]   - Field: ‘node’
[13:19:05.836]   - Field: ‘label’
[13:19:05.836]   - Field: ‘local’
[13:19:05.836]   - Field: ‘owner’
[13:19:05.837]   - Field: ‘envir’
[13:19:05.837]   - Field: ‘workers’
[13:19:05.837]   - Field: ‘packages’
[13:19:05.837]   - Field: ‘gc’
[13:19:05.837]   - Field: ‘conditions’
[13:19:05.837]   - Field: ‘persistent’
[13:19:05.837]   - Field: ‘expr’
[13:19:05.837]   - Field: ‘uuid’
[13:19:05.837]   - Field: ‘seed’
[13:19:05.837]   - Field: ‘version’
[13:19:05.837]   - Field: ‘result’
[13:19:05.838]   - Field: ‘asynchronous’
[13:19:05.838]   - Field: ‘calls’
[13:19:05.838]   - Field: ‘globals’
[13:19:05.838]   - Field: ‘stdout’
[13:19:05.838]   - Field: ‘earlySignal’
[13:19:05.838]   - Field: ‘lazy’
[13:19:05.838]   - Field: ‘state’
[13:19:05.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:05.838] - Launch lazy future ...
[13:19:05.838] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:05.839] Packages needed by future strategies (n = 0): <none>
[13:19:05.839] {
[13:19:05.839]     {
[13:19:05.839]         {
[13:19:05.839]             ...future.startTime <- base::Sys.time()
[13:19:05.839]             {
[13:19:05.839]                 {
[13:19:05.839]                   {
[13:19:05.839]                     {
[13:19:05.839]                       {
[13:19:05.839]                         base::local({
[13:19:05.839]                           has_future <- base::requireNamespace("future", 
[13:19:05.839]                             quietly = TRUE)
[13:19:05.839]                           if (has_future) {
[13:19:05.839]                             ns <- base::getNamespace("future")
[13:19:05.839]                             version <- ns[[".package"]][["version"]]
[13:19:05.839]                             if (is.null(version)) 
[13:19:05.839]                               version <- utils::packageVersion("future")
[13:19:05.839]                           }
[13:19:05.839]                           else {
[13:19:05.839]                             version <- NULL
[13:19:05.839]                           }
[13:19:05.839]                           if (!has_future || version < "1.8.0") {
[13:19:05.839]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:05.839]                               "", base::R.version$version.string), 
[13:19:05.839]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:05.839]                                 base::R.version$platform, 8 * 
[13:19:05.839]                                   base::.Machine$sizeof.pointer), 
[13:19:05.839]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:05.839]                                 "release", "version")], collapse = " "), 
[13:19:05.839]                               hostname = base::Sys.info()[["nodename"]])
[13:19:05.839]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:05.839]                               info)
[13:19:05.839]                             info <- base::paste(info, collapse = "; ")
[13:19:05.839]                             if (!has_future) {
[13:19:05.839]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:05.839]                                 info)
[13:19:05.839]                             }
[13:19:05.839]                             else {
[13:19:05.839]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:05.839]                                 info, version)
[13:19:05.839]                             }
[13:19:05.839]                             base::stop(msg)
[13:19:05.839]                           }
[13:19:05.839]                         })
[13:19:05.839]                       }
[13:19:05.839]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:05.839]                       base::options(mc.cores = 1L)
[13:19:05.839]                     }
[13:19:05.839]                     base::local({
[13:19:05.839]                       for (pkg in "future.apply") {
[13:19:05.839]                         base::loadNamespace(pkg)
[13:19:05.839]                         base::library(pkg, character.only = TRUE)
[13:19:05.839]                       }
[13:19:05.839]                     })
[13:19:05.839]                   }
[13:19:05.839]                   options(future.plan = NULL)
[13:19:05.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:05.839]                 }
[13:19:05.839]                 ...future.workdir <- getwd()
[13:19:05.839]             }
[13:19:05.839]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:05.839]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:05.839]         }
[13:19:05.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:05.839]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:05.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:05.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:05.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:05.839]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:05.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:05.839]             base::names(...future.oldOptions))
[13:19:05.839]     }
[13:19:05.839]     if (FALSE) {
[13:19:05.839]     }
[13:19:05.839]     else {
[13:19:05.839]         if (TRUE) {
[13:19:05.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:05.839]                 open = "w")
[13:19:05.839]         }
[13:19:05.839]         else {
[13:19:05.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:05.839]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:05.839]         }
[13:19:05.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:05.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:05.839]             base::sink(type = "output", split = FALSE)
[13:19:05.839]             base::close(...future.stdout)
[13:19:05.839]         }, add = TRUE)
[13:19:05.839]     }
[13:19:05.839]     ...future.frame <- base::sys.nframe()
[13:19:05.839]     ...future.conditions <- base::list()
[13:19:05.839]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:05.839]     if (FALSE) {
[13:19:05.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:05.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:05.839]     }
[13:19:05.839]     ...future.result <- base::tryCatch({
[13:19:05.839]         base::withCallingHandlers({
[13:19:05.839]             ...future.value <- base::withVisible(base::local({
[13:19:05.839]                 ...future.makeSendCondition <- local({
[13:19:05.839]                   sendCondition <- NULL
[13:19:05.839]                   function(frame = 1L) {
[13:19:05.839]                     if (is.function(sendCondition)) 
[13:19:05.839]                       return(sendCondition)
[13:19:05.839]                     ns <- getNamespace("parallel")
[13:19:05.839]                     if (exists("sendData", mode = "function", 
[13:19:05.839]                       envir = ns)) {
[13:19:05.839]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:05.839]                         envir = ns)
[13:19:05.839]                       envir <- sys.frame(frame)
[13:19:05.839]                       master <- NULL
[13:19:05.839]                       while (!identical(envir, .GlobalEnv) && 
[13:19:05.839]                         !identical(envir, emptyenv())) {
[13:19:05.839]                         if (exists("master", mode = "list", envir = envir, 
[13:19:05.839]                           inherits = FALSE)) {
[13:19:05.839]                           master <- get("master", mode = "list", 
[13:19:05.839]                             envir = envir, inherits = FALSE)
[13:19:05.839]                           if (inherits(master, c("SOCKnode", 
[13:19:05.839]                             "SOCK0node"))) {
[13:19:05.839]                             sendCondition <<- function(cond) {
[13:19:05.839]                               data <- list(type = "VALUE", value = cond, 
[13:19:05.839]                                 success = TRUE)
[13:19:05.839]                               parallel_sendData(master, data)
[13:19:05.839]                             }
[13:19:05.839]                             return(sendCondition)
[13:19:05.839]                           }
[13:19:05.839]                         }
[13:19:05.839]                         frame <- frame + 1L
[13:19:05.839]                         envir <- sys.frame(frame)
[13:19:05.839]                       }
[13:19:05.839]                     }
[13:19:05.839]                     sendCondition <<- function(cond) NULL
[13:19:05.839]                   }
[13:19:05.839]                 })
[13:19:05.839]                 withCallingHandlers({
[13:19:05.839]                   {
[13:19:05.839]                     do.call(function(...) {
[13:19:05.839]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.839]                       if (!identical(...future.globals.maxSize.org, 
[13:19:05.839]                         ...future.globals.maxSize)) {
[13:19:05.839]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.839]                         on.exit(options(oopts), add = TRUE)
[13:19:05.839]                       }
[13:19:05.839]                       {
[13:19:05.839]                         lapply(seq_along(...future.elements_ii), 
[13:19:05.839]                           FUN = function(jj) {
[13:19:05.839]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.839]                             ...future.FUN(...future.X_jj, ...)
[13:19:05.839]                           })
[13:19:05.839]                       }
[13:19:05.839]                     }, args = future.call.arguments)
[13:19:05.839]                   }
[13:19:05.839]                 }, immediateCondition = function(cond) {
[13:19:05.839]                   sendCondition <- ...future.makeSendCondition()
[13:19:05.839]                   sendCondition(cond)
[13:19:05.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.839]                   {
[13:19:05.839]                     inherits <- base::inherits
[13:19:05.839]                     invokeRestart <- base::invokeRestart
[13:19:05.839]                     is.null <- base::is.null
[13:19:05.839]                     muffled <- FALSE
[13:19:05.839]                     if (inherits(cond, "message")) {
[13:19:05.839]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:05.839]                       if (muffled) 
[13:19:05.839]                         invokeRestart("muffleMessage")
[13:19:05.839]                     }
[13:19:05.839]                     else if (inherits(cond, "warning")) {
[13:19:05.839]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:05.839]                       if (muffled) 
[13:19:05.839]                         invokeRestart("muffleWarning")
[13:19:05.839]                     }
[13:19:05.839]                     else if (inherits(cond, "condition")) {
[13:19:05.839]                       if (!is.null(pattern)) {
[13:19:05.839]                         computeRestarts <- base::computeRestarts
[13:19:05.839]                         grepl <- base::grepl
[13:19:05.839]                         restarts <- computeRestarts(cond)
[13:19:05.839]                         for (restart in restarts) {
[13:19:05.839]                           name <- restart$name
[13:19:05.839]                           if (is.null(name)) 
[13:19:05.839]                             next
[13:19:05.839]                           if (!grepl(pattern, name)) 
[13:19:05.839]                             next
[13:19:05.839]                           invokeRestart(restart)
[13:19:05.839]                           muffled <- TRUE
[13:19:05.839]                           break
[13:19:05.839]                         }
[13:19:05.839]                       }
[13:19:05.839]                     }
[13:19:05.839]                     invisible(muffled)
[13:19:05.839]                   }
[13:19:05.839]                   muffleCondition(cond)
[13:19:05.839]                 })
[13:19:05.839]             }))
[13:19:05.839]             future::FutureResult(value = ...future.value$value, 
[13:19:05.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.839]                   ...future.rng), globalenv = if (FALSE) 
[13:19:05.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:05.839]                     ...future.globalenv.names))
[13:19:05.839]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:05.839]         }, condition = base::local({
[13:19:05.839]             c <- base::c
[13:19:05.839]             inherits <- base::inherits
[13:19:05.839]             invokeRestart <- base::invokeRestart
[13:19:05.839]             length <- base::length
[13:19:05.839]             list <- base::list
[13:19:05.839]             seq.int <- base::seq.int
[13:19:05.839]             signalCondition <- base::signalCondition
[13:19:05.839]             sys.calls <- base::sys.calls
[13:19:05.839]             `[[` <- base::`[[`
[13:19:05.839]             `+` <- base::`+`
[13:19:05.839]             `<<-` <- base::`<<-`
[13:19:05.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:05.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:05.839]                   3L)]
[13:19:05.839]             }
[13:19:05.839]             function(cond) {
[13:19:05.839]                 is_error <- inherits(cond, "error")
[13:19:05.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:05.839]                   NULL)
[13:19:05.839]                 if (is_error) {
[13:19:05.839]                   sessionInformation <- function() {
[13:19:05.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:05.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:05.839]                       search = base::search(), system = base::Sys.info())
[13:19:05.839]                   }
[13:19:05.839]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:05.839]                     cond$call), session = sessionInformation(), 
[13:19:05.839]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:05.839]                   signalCondition(cond)
[13:19:05.839]                 }
[13:19:05.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:05.839]                 "immediateCondition"))) {
[13:19:05.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:05.839]                   ...future.conditions[[length(...future.conditions) + 
[13:19:05.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:05.839]                   if (TRUE && !signal) {
[13:19:05.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.839]                     {
[13:19:05.839]                       inherits <- base::inherits
[13:19:05.839]                       invokeRestart <- base::invokeRestart
[13:19:05.839]                       is.null <- base::is.null
[13:19:05.839]                       muffled <- FALSE
[13:19:05.839]                       if (inherits(cond, "message")) {
[13:19:05.839]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.839]                         if (muffled) 
[13:19:05.839]                           invokeRestart("muffleMessage")
[13:19:05.839]                       }
[13:19:05.839]                       else if (inherits(cond, "warning")) {
[13:19:05.839]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.839]                         if (muffled) 
[13:19:05.839]                           invokeRestart("muffleWarning")
[13:19:05.839]                       }
[13:19:05.839]                       else if (inherits(cond, "condition")) {
[13:19:05.839]                         if (!is.null(pattern)) {
[13:19:05.839]                           computeRestarts <- base::computeRestarts
[13:19:05.839]                           grepl <- base::grepl
[13:19:05.839]                           restarts <- computeRestarts(cond)
[13:19:05.839]                           for (restart in restarts) {
[13:19:05.839]                             name <- restart$name
[13:19:05.839]                             if (is.null(name)) 
[13:19:05.839]                               next
[13:19:05.839]                             if (!grepl(pattern, name)) 
[13:19:05.839]                               next
[13:19:05.839]                             invokeRestart(restart)
[13:19:05.839]                             muffled <- TRUE
[13:19:05.839]                             break
[13:19:05.839]                           }
[13:19:05.839]                         }
[13:19:05.839]                       }
[13:19:05.839]                       invisible(muffled)
[13:19:05.839]                     }
[13:19:05.839]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.839]                   }
[13:19:05.839]                 }
[13:19:05.839]                 else {
[13:19:05.839]                   if (TRUE) {
[13:19:05.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:05.839]                     {
[13:19:05.839]                       inherits <- base::inherits
[13:19:05.839]                       invokeRestart <- base::invokeRestart
[13:19:05.839]                       is.null <- base::is.null
[13:19:05.839]                       muffled <- FALSE
[13:19:05.839]                       if (inherits(cond, "message")) {
[13:19:05.839]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:05.839]                         if (muffled) 
[13:19:05.839]                           invokeRestart("muffleMessage")
[13:19:05.839]                       }
[13:19:05.839]                       else if (inherits(cond, "warning")) {
[13:19:05.839]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:05.839]                         if (muffled) 
[13:19:05.839]                           invokeRestart("muffleWarning")
[13:19:05.839]                       }
[13:19:05.839]                       else if (inherits(cond, "condition")) {
[13:19:05.839]                         if (!is.null(pattern)) {
[13:19:05.839]                           computeRestarts <- base::computeRestarts
[13:19:05.839]                           grepl <- base::grepl
[13:19:05.839]                           restarts <- computeRestarts(cond)
[13:19:05.839]                           for (restart in restarts) {
[13:19:05.839]                             name <- restart$name
[13:19:05.839]                             if (is.null(name)) 
[13:19:05.839]                               next
[13:19:05.839]                             if (!grepl(pattern, name)) 
[13:19:05.839]                               next
[13:19:05.839]                             invokeRestart(restart)
[13:19:05.839]                             muffled <- TRUE
[13:19:05.839]                             break
[13:19:05.839]                           }
[13:19:05.839]                         }
[13:19:05.839]                       }
[13:19:05.839]                       invisible(muffled)
[13:19:05.839]                     }
[13:19:05.839]                     muffleCondition(cond, pattern = "^muffle")
[13:19:05.839]                   }
[13:19:05.839]                 }
[13:19:05.839]             }
[13:19:05.839]         }))
[13:19:05.839]     }, error = function(ex) {
[13:19:05.839]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:05.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:05.839]                 ...future.rng), started = ...future.startTime, 
[13:19:05.839]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:05.839]             version = "1.8"), class = "FutureResult")
[13:19:05.839]     }, finally = {
[13:19:05.839]         if (!identical(...future.workdir, getwd())) 
[13:19:05.839]             setwd(...future.workdir)
[13:19:05.839]         {
[13:19:05.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:05.839]                 ...future.oldOptions$nwarnings <- NULL
[13:19:05.839]             }
[13:19:05.839]             base::options(...future.oldOptions)
[13:19:05.839]             if (.Platform$OS.type == "windows") {
[13:19:05.839]                 old_names <- names(...future.oldEnvVars)
[13:19:05.839]                 envs <- base::Sys.getenv()
[13:19:05.839]                 names <- names(envs)
[13:19:05.839]                 common <- intersect(names, old_names)
[13:19:05.839]                 added <- setdiff(names, old_names)
[13:19:05.839]                 removed <- setdiff(old_names, names)
[13:19:05.839]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:05.839]                   envs[common]]
[13:19:05.839]                 NAMES <- toupper(changed)
[13:19:05.839]                 args <- list()
[13:19:05.839]                 for (kk in seq_along(NAMES)) {
[13:19:05.839]                   name <- changed[[kk]]
[13:19:05.839]                   NAME <- NAMES[[kk]]
[13:19:05.839]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.839]                     next
[13:19:05.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.839]                 }
[13:19:05.839]                 NAMES <- toupper(added)
[13:19:05.839]                 for (kk in seq_along(NAMES)) {
[13:19:05.839]                   name <- added[[kk]]
[13:19:05.839]                   NAME <- NAMES[[kk]]
[13:19:05.839]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.839]                     next
[13:19:05.839]                   args[[name]] <- ""
[13:19:05.839]                 }
[13:19:05.839]                 NAMES <- toupper(removed)
[13:19:05.839]                 for (kk in seq_along(NAMES)) {
[13:19:05.839]                   name <- removed[[kk]]
[13:19:05.839]                   NAME <- NAMES[[kk]]
[13:19:05.839]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:05.839]                     next
[13:19:05.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:05.839]                 }
[13:19:05.839]                 if (length(args) > 0) 
[13:19:05.839]                   base::do.call(base::Sys.setenv, args = args)
[13:19:05.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:05.839]             }
[13:19:05.839]             else {
[13:19:05.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:05.839]             }
[13:19:05.839]             {
[13:19:05.839]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:05.839]                   0L) {
[13:19:05.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:05.839]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:05.839]                   base::options(opts)
[13:19:05.839]                 }
[13:19:05.839]                 {
[13:19:05.839]                   {
[13:19:05.839]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:05.839]                     NULL
[13:19:05.839]                   }
[13:19:05.839]                   options(future.plan = NULL)
[13:19:05.839]                   if (is.na(NA_character_)) 
[13:19:05.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:05.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:05.839]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:05.839]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:05.839]                     envir = parent.frame()) 
[13:19:05.839]                   {
[13:19:05.839]                     if (is.function(workers)) 
[13:19:05.839]                       workers <- workers()
[13:19:05.839]                     workers <- structure(as.integer(workers), 
[13:19:05.839]                       class = class(workers))
[13:19:05.839]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:05.839]                       workers >= 1)
[13:19:05.839]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:05.839]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:05.839]                     }
[13:19:05.839]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:05.839]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:05.839]                       envir = envir)
[13:19:05.839]                     if (!future$lazy) 
[13:19:05.839]                       future <- run(future)
[13:19:05.839]                     invisible(future)
[13:19:05.839]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:05.839]                 }
[13:19:05.839]             }
[13:19:05.839]         }
[13:19:05.839]     })
[13:19:05.839]     if (TRUE) {
[13:19:05.839]         base::sink(type = "output", split = FALSE)
[13:19:05.839]         if (TRUE) {
[13:19:05.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:05.839]         }
[13:19:05.839]         else {
[13:19:05.839]             ...future.result["stdout"] <- base::list(NULL)
[13:19:05.839]         }
[13:19:05.839]         base::close(...future.stdout)
[13:19:05.839]         ...future.stdout <- NULL
[13:19:05.839]     }
[13:19:05.839]     ...future.result$conditions <- ...future.conditions
[13:19:05.839]     ...future.result$finished <- base::Sys.time()
[13:19:05.839]     ...future.result
[13:19:05.839] }
[13:19:05.842] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[13:19:05.842] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:05.885] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:05.885] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[13:19:05.886] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[13:19:05.886] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:05.886] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:05.886] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:05.929] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:05.929] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:05.973] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:05.973] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:19:05.974] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:19:05.974] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:05.974] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:05.974] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[13:19:05.975] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[13:19:05.975] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:19:05.975] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:19:05.975] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:05.976] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.976] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:05.976] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:05.976] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[13:19:05.977] MultisessionFuture started
[13:19:05.977] - Launch lazy future ... done
[13:19:05.977] run() for ‘MultisessionFuture’ ... done
[13:19:05.977] Created future:
[13:19:05.977] MultisessionFuture:
[13:19:05.977] Label: ‘future_vapply-1’
[13:19:05.977] Expression:
[13:19:05.977] {
[13:19:05.977]     do.call(function(...) {
[13:19:05.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.977]             on.exit(options(oopts), add = TRUE)
[13:19:05.977]         }
[13:19:05.977]         {
[13:19:05.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.977]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.977]             })
[13:19:05.977]         }
[13:19:05.977]     }, args = future.call.arguments)
[13:19:05.977] }
[13:19:05.977] Lazy evaluation: FALSE
[13:19:05.977] Asynchronous evaluation: TRUE
[13:19:05.977] Local evaluation: TRUE
[13:19:05.977] Environment: R_GlobalEnv
[13:19:05.977] Capture standard output: TRUE
[13:19:05.977] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:05.977] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:05.977] Packages: 1 packages (‘future.apply’)
[13:19:05.977] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:05.977] Resolved: FALSE
[13:19:05.977] Value: <not collected>
[13:19:05.977] Conditions captured: <none>
[13:19:05.977] Early signaling: FALSE
[13:19:05.977] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:05.977] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:05.989] Chunk #1 of 2 ... DONE
[13:19:05.989] Chunk #2 of 2 ...
[13:19:05.989]  - Finding globals in 'X' for chunk #2 ...
[13:19:05.990] getGlobalsAndPackages() ...
[13:19:05.990] Searching for globals...
[13:19:05.990] 
[13:19:05.990] Searching for globals ... DONE
[13:19:05.990] - globals: [0] <none>
[13:19:05.990] getGlobalsAndPackages() ... DONE
[13:19:05.990]    + additional globals found: [n=0] 
[13:19:05.990]    + additional namespaces needed: [n=0] 
[13:19:05.991]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:05.991]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:05.991]  - seeds: <none>
[13:19:05.991] getGlobalsAndPackages() ...
[13:19:05.991] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.991] Resolving globals: FALSE
[13:19:05.991] Tweak future expression to call with '...' arguments ...
[13:19:05.991] {
[13:19:05.991]     do.call(function(...) {
[13:19:05.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:05.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:05.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:05.991]             on.exit(options(oopts), add = TRUE)
[13:19:05.991]         }
[13:19:05.991]         {
[13:19:05.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:05.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:05.991]                 ...future.FUN(...future.X_jj, ...)
[13:19:05.991]             })
[13:19:05.991]         }
[13:19:05.991]     }, args = future.call.arguments)
[13:19:05.991] }
[13:19:05.992] Tweak future expression to call with '...' arguments ... DONE
[13:19:05.992] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:05.992] - packages: [1] ‘future.apply’
[13:19:05.992] getGlobalsAndPackages() ... DONE
[13:19:05.993] run() for ‘Future’ ...
[13:19:05.993] - state: ‘created’
[13:19:05.993] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:06.008] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:06.008]   - Field: ‘node’
[13:19:06.008]   - Field: ‘label’
[13:19:06.008]   - Field: ‘local’
[13:19:06.008]   - Field: ‘owner’
[13:19:06.008]   - Field: ‘envir’
[13:19:06.009]   - Field: ‘workers’
[13:19:06.009]   - Field: ‘packages’
[13:19:06.009]   - Field: ‘gc’
[13:19:06.009]   - Field: ‘conditions’
[13:19:06.009]   - Field: ‘persistent’
[13:19:06.009]   - Field: ‘expr’
[13:19:06.009]   - Field: ‘uuid’
[13:19:06.009]   - Field: ‘seed’
[13:19:06.009]   - Field: ‘version’
[13:19:06.009]   - Field: ‘result’
[13:19:06.010]   - Field: ‘asynchronous’
[13:19:06.010]   - Field: ‘calls’
[13:19:06.010]   - Field: ‘globals’
[13:19:06.010]   - Field: ‘stdout’
[13:19:06.010]   - Field: ‘earlySignal’
[13:19:06.010]   - Field: ‘lazy’
[13:19:06.010]   - Field: ‘state’
[13:19:06.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:06.010] - Launch lazy future ...
[13:19:06.011] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:06.011] Packages needed by future strategies (n = 0): <none>
[13:19:06.011] {
[13:19:06.011]     {
[13:19:06.011]         {
[13:19:06.011]             ...future.startTime <- base::Sys.time()
[13:19:06.011]             {
[13:19:06.011]                 {
[13:19:06.011]                   {
[13:19:06.011]                     {
[13:19:06.011]                       {
[13:19:06.011]                         base::local({
[13:19:06.011]                           has_future <- base::requireNamespace("future", 
[13:19:06.011]                             quietly = TRUE)
[13:19:06.011]                           if (has_future) {
[13:19:06.011]                             ns <- base::getNamespace("future")
[13:19:06.011]                             version <- ns[[".package"]][["version"]]
[13:19:06.011]                             if (is.null(version)) 
[13:19:06.011]                               version <- utils::packageVersion("future")
[13:19:06.011]                           }
[13:19:06.011]                           else {
[13:19:06.011]                             version <- NULL
[13:19:06.011]                           }
[13:19:06.011]                           if (!has_future || version < "1.8.0") {
[13:19:06.011]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:06.011]                               "", base::R.version$version.string), 
[13:19:06.011]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:06.011]                                 base::R.version$platform, 8 * 
[13:19:06.011]                                   base::.Machine$sizeof.pointer), 
[13:19:06.011]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:06.011]                                 "release", "version")], collapse = " "), 
[13:19:06.011]                               hostname = base::Sys.info()[["nodename"]])
[13:19:06.011]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:06.011]                               info)
[13:19:06.011]                             info <- base::paste(info, collapse = "; ")
[13:19:06.011]                             if (!has_future) {
[13:19:06.011]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:06.011]                                 info)
[13:19:06.011]                             }
[13:19:06.011]                             else {
[13:19:06.011]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:06.011]                                 info, version)
[13:19:06.011]                             }
[13:19:06.011]                             base::stop(msg)
[13:19:06.011]                           }
[13:19:06.011]                         })
[13:19:06.011]                       }
[13:19:06.011]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:06.011]                       base::options(mc.cores = 1L)
[13:19:06.011]                     }
[13:19:06.011]                     base::local({
[13:19:06.011]                       for (pkg in "future.apply") {
[13:19:06.011]                         base::loadNamespace(pkg)
[13:19:06.011]                         base::library(pkg, character.only = TRUE)
[13:19:06.011]                       }
[13:19:06.011]                     })
[13:19:06.011]                   }
[13:19:06.011]                   options(future.plan = NULL)
[13:19:06.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:06.011]                 }
[13:19:06.011]                 ...future.workdir <- getwd()
[13:19:06.011]             }
[13:19:06.011]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:06.011]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:06.011]         }
[13:19:06.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:06.011]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:06.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:06.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:06.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:06.011]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:06.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:06.011]             base::names(...future.oldOptions))
[13:19:06.011]     }
[13:19:06.011]     if (FALSE) {
[13:19:06.011]     }
[13:19:06.011]     else {
[13:19:06.011]         if (TRUE) {
[13:19:06.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:06.011]                 open = "w")
[13:19:06.011]         }
[13:19:06.011]         else {
[13:19:06.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:06.011]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:06.011]         }
[13:19:06.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:06.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:06.011]             base::sink(type = "output", split = FALSE)
[13:19:06.011]             base::close(...future.stdout)
[13:19:06.011]         }, add = TRUE)
[13:19:06.011]     }
[13:19:06.011]     ...future.frame <- base::sys.nframe()
[13:19:06.011]     ...future.conditions <- base::list()
[13:19:06.011]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:06.011]     if (FALSE) {
[13:19:06.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:06.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:06.011]     }
[13:19:06.011]     ...future.result <- base::tryCatch({
[13:19:06.011]         base::withCallingHandlers({
[13:19:06.011]             ...future.value <- base::withVisible(base::local({
[13:19:06.011]                 ...future.makeSendCondition <- local({
[13:19:06.011]                   sendCondition <- NULL
[13:19:06.011]                   function(frame = 1L) {
[13:19:06.011]                     if (is.function(sendCondition)) 
[13:19:06.011]                       return(sendCondition)
[13:19:06.011]                     ns <- getNamespace("parallel")
[13:19:06.011]                     if (exists("sendData", mode = "function", 
[13:19:06.011]                       envir = ns)) {
[13:19:06.011]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:06.011]                         envir = ns)
[13:19:06.011]                       envir <- sys.frame(frame)
[13:19:06.011]                       master <- NULL
[13:19:06.011]                       while (!identical(envir, .GlobalEnv) && 
[13:19:06.011]                         !identical(envir, emptyenv())) {
[13:19:06.011]                         if (exists("master", mode = "list", envir = envir, 
[13:19:06.011]                           inherits = FALSE)) {
[13:19:06.011]                           master <- get("master", mode = "list", 
[13:19:06.011]                             envir = envir, inherits = FALSE)
[13:19:06.011]                           if (inherits(master, c("SOCKnode", 
[13:19:06.011]                             "SOCK0node"))) {
[13:19:06.011]                             sendCondition <<- function(cond) {
[13:19:06.011]                               data <- list(type = "VALUE", value = cond, 
[13:19:06.011]                                 success = TRUE)
[13:19:06.011]                               parallel_sendData(master, data)
[13:19:06.011]                             }
[13:19:06.011]                             return(sendCondition)
[13:19:06.011]                           }
[13:19:06.011]                         }
[13:19:06.011]                         frame <- frame + 1L
[13:19:06.011]                         envir <- sys.frame(frame)
[13:19:06.011]                       }
[13:19:06.011]                     }
[13:19:06.011]                     sendCondition <<- function(cond) NULL
[13:19:06.011]                   }
[13:19:06.011]                 })
[13:19:06.011]                 withCallingHandlers({
[13:19:06.011]                   {
[13:19:06.011]                     do.call(function(...) {
[13:19:06.011]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.011]                       if (!identical(...future.globals.maxSize.org, 
[13:19:06.011]                         ...future.globals.maxSize)) {
[13:19:06.011]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.011]                         on.exit(options(oopts), add = TRUE)
[13:19:06.011]                       }
[13:19:06.011]                       {
[13:19:06.011]                         lapply(seq_along(...future.elements_ii), 
[13:19:06.011]                           FUN = function(jj) {
[13:19:06.011]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.011]                             ...future.FUN(...future.X_jj, ...)
[13:19:06.011]                           })
[13:19:06.011]                       }
[13:19:06.011]                     }, args = future.call.arguments)
[13:19:06.011]                   }
[13:19:06.011]                 }, immediateCondition = function(cond) {
[13:19:06.011]                   sendCondition <- ...future.makeSendCondition()
[13:19:06.011]                   sendCondition(cond)
[13:19:06.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.011]                   {
[13:19:06.011]                     inherits <- base::inherits
[13:19:06.011]                     invokeRestart <- base::invokeRestart
[13:19:06.011]                     is.null <- base::is.null
[13:19:06.011]                     muffled <- FALSE
[13:19:06.011]                     if (inherits(cond, "message")) {
[13:19:06.011]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:06.011]                       if (muffled) 
[13:19:06.011]                         invokeRestart("muffleMessage")
[13:19:06.011]                     }
[13:19:06.011]                     else if (inherits(cond, "warning")) {
[13:19:06.011]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:06.011]                       if (muffled) 
[13:19:06.011]                         invokeRestart("muffleWarning")
[13:19:06.011]                     }
[13:19:06.011]                     else if (inherits(cond, "condition")) {
[13:19:06.011]                       if (!is.null(pattern)) {
[13:19:06.011]                         computeRestarts <- base::computeRestarts
[13:19:06.011]                         grepl <- base::grepl
[13:19:06.011]                         restarts <- computeRestarts(cond)
[13:19:06.011]                         for (restart in restarts) {
[13:19:06.011]                           name <- restart$name
[13:19:06.011]                           if (is.null(name)) 
[13:19:06.011]                             next
[13:19:06.011]                           if (!grepl(pattern, name)) 
[13:19:06.011]                             next
[13:19:06.011]                           invokeRestart(restart)
[13:19:06.011]                           muffled <- TRUE
[13:19:06.011]                           break
[13:19:06.011]                         }
[13:19:06.011]                       }
[13:19:06.011]                     }
[13:19:06.011]                     invisible(muffled)
[13:19:06.011]                   }
[13:19:06.011]                   muffleCondition(cond)
[13:19:06.011]                 })
[13:19:06.011]             }))
[13:19:06.011]             future::FutureResult(value = ...future.value$value, 
[13:19:06.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.011]                   ...future.rng), globalenv = if (FALSE) 
[13:19:06.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:06.011]                     ...future.globalenv.names))
[13:19:06.011]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:06.011]         }, condition = base::local({
[13:19:06.011]             c <- base::c
[13:19:06.011]             inherits <- base::inherits
[13:19:06.011]             invokeRestart <- base::invokeRestart
[13:19:06.011]             length <- base::length
[13:19:06.011]             list <- base::list
[13:19:06.011]             seq.int <- base::seq.int
[13:19:06.011]             signalCondition <- base::signalCondition
[13:19:06.011]             sys.calls <- base::sys.calls
[13:19:06.011]             `[[` <- base::`[[`
[13:19:06.011]             `+` <- base::`+`
[13:19:06.011]             `<<-` <- base::`<<-`
[13:19:06.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:06.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:06.011]                   3L)]
[13:19:06.011]             }
[13:19:06.011]             function(cond) {
[13:19:06.011]                 is_error <- inherits(cond, "error")
[13:19:06.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:06.011]                   NULL)
[13:19:06.011]                 if (is_error) {
[13:19:06.011]                   sessionInformation <- function() {
[13:19:06.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:06.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:06.011]                       search = base::search(), system = base::Sys.info())
[13:19:06.011]                   }
[13:19:06.011]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:06.011]                     cond$call), session = sessionInformation(), 
[13:19:06.011]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:06.011]                   signalCondition(cond)
[13:19:06.011]                 }
[13:19:06.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:06.011]                 "immediateCondition"))) {
[13:19:06.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:06.011]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:06.011]                   if (TRUE && !signal) {
[13:19:06.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.011]                     {
[13:19:06.011]                       inherits <- base::inherits
[13:19:06.011]                       invokeRestart <- base::invokeRestart
[13:19:06.011]                       is.null <- base::is.null
[13:19:06.011]                       muffled <- FALSE
[13:19:06.011]                       if (inherits(cond, "message")) {
[13:19:06.011]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.011]                         if (muffled) 
[13:19:06.011]                           invokeRestart("muffleMessage")
[13:19:06.011]                       }
[13:19:06.011]                       else if (inherits(cond, "warning")) {
[13:19:06.011]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.011]                         if (muffled) 
[13:19:06.011]                           invokeRestart("muffleWarning")
[13:19:06.011]                       }
[13:19:06.011]                       else if (inherits(cond, "condition")) {
[13:19:06.011]                         if (!is.null(pattern)) {
[13:19:06.011]                           computeRestarts <- base::computeRestarts
[13:19:06.011]                           grepl <- base::grepl
[13:19:06.011]                           restarts <- computeRestarts(cond)
[13:19:06.011]                           for (restart in restarts) {
[13:19:06.011]                             name <- restart$name
[13:19:06.011]                             if (is.null(name)) 
[13:19:06.011]                               next
[13:19:06.011]                             if (!grepl(pattern, name)) 
[13:19:06.011]                               next
[13:19:06.011]                             invokeRestart(restart)
[13:19:06.011]                             muffled <- TRUE
[13:19:06.011]                             break
[13:19:06.011]                           }
[13:19:06.011]                         }
[13:19:06.011]                       }
[13:19:06.011]                       invisible(muffled)
[13:19:06.011]                     }
[13:19:06.011]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.011]                   }
[13:19:06.011]                 }
[13:19:06.011]                 else {
[13:19:06.011]                   if (TRUE) {
[13:19:06.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.011]                     {
[13:19:06.011]                       inherits <- base::inherits
[13:19:06.011]                       invokeRestart <- base::invokeRestart
[13:19:06.011]                       is.null <- base::is.null
[13:19:06.011]                       muffled <- FALSE
[13:19:06.011]                       if (inherits(cond, "message")) {
[13:19:06.011]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.011]                         if (muffled) 
[13:19:06.011]                           invokeRestart("muffleMessage")
[13:19:06.011]                       }
[13:19:06.011]                       else if (inherits(cond, "warning")) {
[13:19:06.011]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.011]                         if (muffled) 
[13:19:06.011]                           invokeRestart("muffleWarning")
[13:19:06.011]                       }
[13:19:06.011]                       else if (inherits(cond, "condition")) {
[13:19:06.011]                         if (!is.null(pattern)) {
[13:19:06.011]                           computeRestarts <- base::computeRestarts
[13:19:06.011]                           grepl <- base::grepl
[13:19:06.011]                           restarts <- computeRestarts(cond)
[13:19:06.011]                           for (restart in restarts) {
[13:19:06.011]                             name <- restart$name
[13:19:06.011]                             if (is.null(name)) 
[13:19:06.011]                               next
[13:19:06.011]                             if (!grepl(pattern, name)) 
[13:19:06.011]                               next
[13:19:06.011]                             invokeRestart(restart)
[13:19:06.011]                             muffled <- TRUE
[13:19:06.011]                             break
[13:19:06.011]                           }
[13:19:06.011]                         }
[13:19:06.011]                       }
[13:19:06.011]                       invisible(muffled)
[13:19:06.011]                     }
[13:19:06.011]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.011]                   }
[13:19:06.011]                 }
[13:19:06.011]             }
[13:19:06.011]         }))
[13:19:06.011]     }, error = function(ex) {
[13:19:06.011]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:06.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.011]                 ...future.rng), started = ...future.startTime, 
[13:19:06.011]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:06.011]             version = "1.8"), class = "FutureResult")
[13:19:06.011]     }, finally = {
[13:19:06.011]         if (!identical(...future.workdir, getwd())) 
[13:19:06.011]             setwd(...future.workdir)
[13:19:06.011]         {
[13:19:06.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:06.011]                 ...future.oldOptions$nwarnings <- NULL
[13:19:06.011]             }
[13:19:06.011]             base::options(...future.oldOptions)
[13:19:06.011]             if (.Platform$OS.type == "windows") {
[13:19:06.011]                 old_names <- names(...future.oldEnvVars)
[13:19:06.011]                 envs <- base::Sys.getenv()
[13:19:06.011]                 names <- names(envs)
[13:19:06.011]                 common <- intersect(names, old_names)
[13:19:06.011]                 added <- setdiff(names, old_names)
[13:19:06.011]                 removed <- setdiff(old_names, names)
[13:19:06.011]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:06.011]                   envs[common]]
[13:19:06.011]                 NAMES <- toupper(changed)
[13:19:06.011]                 args <- list()
[13:19:06.011]                 for (kk in seq_along(NAMES)) {
[13:19:06.011]                   name <- changed[[kk]]
[13:19:06.011]                   NAME <- NAMES[[kk]]
[13:19:06.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.011]                     next
[13:19:06.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.011]                 }
[13:19:06.011]                 NAMES <- toupper(added)
[13:19:06.011]                 for (kk in seq_along(NAMES)) {
[13:19:06.011]                   name <- added[[kk]]
[13:19:06.011]                   NAME <- NAMES[[kk]]
[13:19:06.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.011]                     next
[13:19:06.011]                   args[[name]] <- ""
[13:19:06.011]                 }
[13:19:06.011]                 NAMES <- toupper(removed)
[13:19:06.011]                 for (kk in seq_along(NAMES)) {
[13:19:06.011]                   name <- removed[[kk]]
[13:19:06.011]                   NAME <- NAMES[[kk]]
[13:19:06.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.011]                     next
[13:19:06.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.011]                 }
[13:19:06.011]                 if (length(args) > 0) 
[13:19:06.011]                   base::do.call(base::Sys.setenv, args = args)
[13:19:06.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:06.011]             }
[13:19:06.011]             else {
[13:19:06.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:06.011]             }
[13:19:06.011]             {
[13:19:06.011]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:06.011]                   0L) {
[13:19:06.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:06.011]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:06.011]                   base::options(opts)
[13:19:06.011]                 }
[13:19:06.011]                 {
[13:19:06.011]                   {
[13:19:06.011]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:06.011]                     NULL
[13:19:06.011]                   }
[13:19:06.011]                   options(future.plan = NULL)
[13:19:06.011]                   if (is.na(NA_character_)) 
[13:19:06.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:06.011]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:06.011]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:06.011]                     envir = parent.frame()) 
[13:19:06.011]                   {
[13:19:06.011]                     if (is.function(workers)) 
[13:19:06.011]                       workers <- workers()
[13:19:06.011]                     workers <- structure(as.integer(workers), 
[13:19:06.011]                       class = class(workers))
[13:19:06.011]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:06.011]                       workers >= 1)
[13:19:06.011]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:06.011]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:06.011]                     }
[13:19:06.011]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:06.011]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:06.011]                       envir = envir)
[13:19:06.011]                     if (!future$lazy) 
[13:19:06.011]                       future <- run(future)
[13:19:06.011]                     invisible(future)
[13:19:06.011]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:06.011]                 }
[13:19:06.011]             }
[13:19:06.011]         }
[13:19:06.011]     })
[13:19:06.011]     if (TRUE) {
[13:19:06.011]         base::sink(type = "output", split = FALSE)
[13:19:06.011]         if (TRUE) {
[13:19:06.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:06.011]         }
[13:19:06.011]         else {
[13:19:06.011]             ...future.result["stdout"] <- base::list(NULL)
[13:19:06.011]         }
[13:19:06.011]         base::close(...future.stdout)
[13:19:06.011]         ...future.stdout <- NULL
[13:19:06.011]     }
[13:19:06.011]     ...future.result$conditions <- ...future.conditions
[13:19:06.011]     ...future.result$finished <- base::Sys.time()
[13:19:06.011]     ...future.result
[13:19:06.011] }
[13:19:06.014] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[13:19:06.014] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:06.061] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:06.061] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[13:19:06.062] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[13:19:06.062] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:06.062] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:06.062] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:06.105] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:06.105] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:06.149] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:06.149] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:19:06.150] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:19:06.150] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:06.150] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:06.150] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[13:19:06.151] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[13:19:06.151] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:06.151] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:06.151] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:06.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:06.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.152] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[13:19:06.153] MultisessionFuture started
[13:19:06.153] - Launch lazy future ... done
[13:19:06.153] run() for ‘MultisessionFuture’ ... done
[13:19:06.153] Created future:
[13:19:06.153] MultisessionFuture:
[13:19:06.153] Label: ‘future_vapply-2’
[13:19:06.153] Expression:
[13:19:06.153] {
[13:19:06.153]     do.call(function(...) {
[13:19:06.153]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.153]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.153]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.153]             on.exit(options(oopts), add = TRUE)
[13:19:06.153]         }
[13:19:06.153]         {
[13:19:06.153]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.153]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.153]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.153]             })
[13:19:06.153]         }
[13:19:06.153]     }, args = future.call.arguments)
[13:19:06.153] }
[13:19:06.153] Lazy evaluation: FALSE
[13:19:06.153] Asynchronous evaluation: TRUE
[13:19:06.153] Local evaluation: TRUE
[13:19:06.153] Environment: R_GlobalEnv
[13:19:06.153] Capture standard output: TRUE
[13:19:06.153] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:06.153] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:06.153] Packages: 1 packages (‘future.apply’)
[13:19:06.153] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:06.153] Resolved: FALSE
[13:19:06.153] Value: <not collected>
[13:19:06.153] Conditions captured: <none>
[13:19:06.153] Early signaling: FALSE
[13:19:06.153] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:06.153] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.165] Chunk #2 of 2 ... DONE
[13:19:06.165] Launching 2 futures (chunks) ... DONE
[13:19:06.165] Resolving 2 futures (chunks) ...
[13:19:06.165] resolve() on list ...
[13:19:06.166]  recursive: 0
[13:19:06.166]  length: 2
[13:19:06.166] 
[13:19:06.166] receiveMessageFromWorker() for ClusterFuture ...
[13:19:06.166] - Validating connection of MultisessionFuture
[13:19:06.166] - received message: FutureResult
[13:19:06.167] - Received FutureResult
[13:19:06.167] - Erased future from FutureRegistry
[13:19:06.167] result() for ClusterFuture ...
[13:19:06.167] - result already collected: FutureResult
[13:19:06.167] result() for ClusterFuture ... done
[13:19:06.167] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:06.167] Future #1
[13:19:06.167] result() for ClusterFuture ...
[13:19:06.167] - result already collected: FutureResult
[13:19:06.167] result() for ClusterFuture ... done
[13:19:06.168] result() for ClusterFuture ...
[13:19:06.168] - result already collected: FutureResult
[13:19:06.168] result() for ClusterFuture ... done
[13:19:06.168] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:06.168] - nx: 2
[13:19:06.168] - relay: TRUE
[13:19:06.168] - stdout: TRUE
[13:19:06.168] - signal: TRUE
[13:19:06.168] - resignal: FALSE
[13:19:06.168] - force: TRUE
[13:19:06.168] - relayed: [n=2] FALSE, FALSE
[13:19:06.168] - queued futures: [n=2] FALSE, FALSE
[13:19:06.169]  - until=1
[13:19:06.169]  - relaying element #1
[13:19:06.169] result() for ClusterFuture ...
[13:19:06.169] - result already collected: FutureResult
[13:19:06.169] result() for ClusterFuture ... done
[13:19:06.169] result() for ClusterFuture ...
[13:19:06.169] - result already collected: FutureResult
[13:19:06.169] result() for ClusterFuture ... done
[13:19:06.169] result() for ClusterFuture ...
[13:19:06.169] - result already collected: FutureResult
[13:19:06.169] result() for ClusterFuture ... done
[13:19:06.170] result() for ClusterFuture ...
[13:19:06.170] - result already collected: FutureResult
[13:19:06.170] result() for ClusterFuture ... done
[13:19:06.170] - relayed: [n=2] TRUE, FALSE
[13:19:06.170] - queued futures: [n=2] TRUE, FALSE
[13:19:06.170] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:06.170]  length: 1 (resolved future 1)
[13:19:06.212] receiveMessageFromWorker() for ClusterFuture ...
[13:19:06.212] - Validating connection of MultisessionFuture
[13:19:06.212] - received message: FutureResult
[13:19:06.212] - Received FutureResult
[13:19:06.213] - Erased future from FutureRegistry
[13:19:06.213] result() for ClusterFuture ...
[13:19:06.213] - result already collected: FutureResult
[13:19:06.213] result() for ClusterFuture ... done
[13:19:06.213] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:06.213] Future #2
[13:19:06.213] result() for ClusterFuture ...
[13:19:06.213] - result already collected: FutureResult
[13:19:06.213] result() for ClusterFuture ... done
[13:19:06.213] result() for ClusterFuture ...
[13:19:06.214] - result already collected: FutureResult
[13:19:06.214] result() for ClusterFuture ... done
[13:19:06.214] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:06.214] - nx: 2
[13:19:06.214] - relay: TRUE
[13:19:06.214] - stdout: TRUE
[13:19:06.214] - signal: TRUE
[13:19:06.214] - resignal: FALSE
[13:19:06.214] - force: TRUE
[13:19:06.214] - relayed: [n=2] TRUE, FALSE
[13:19:06.214] - queued futures: [n=2] TRUE, FALSE
[13:19:06.215]  - until=2
[13:19:06.215]  - relaying element #2
[13:19:06.215] result() for ClusterFuture ...
[13:19:06.215] - result already collected: FutureResult
[13:19:06.215] result() for ClusterFuture ... done
[13:19:06.215] result() for ClusterFuture ...
[13:19:06.215] - result already collected: FutureResult
[13:19:06.215] result() for ClusterFuture ... done
[13:19:06.215] result() for ClusterFuture ...
[13:19:06.215] - result already collected: FutureResult
[13:19:06.215] result() for ClusterFuture ... done
[13:19:06.216] result() for ClusterFuture ...
[13:19:06.216] - result already collected: FutureResult
[13:19:06.216] result() for ClusterFuture ... done
[13:19:06.216] - relayed: [n=2] TRUE, TRUE
[13:19:06.216] - queued futures: [n=2] TRUE, TRUE
[13:19:06.216] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:06.216]  length: 0 (resolved future 2)
[13:19:06.216] Relaying remaining futures
[13:19:06.216] signalConditionsASAP(NULL, pos=0) ...
[13:19:06.216] - nx: 2
[13:19:06.216] - relay: TRUE
[13:19:06.216] - stdout: TRUE
[13:19:06.217] - signal: TRUE
[13:19:06.217] - resignal: FALSE
[13:19:06.217] - force: TRUE
[13:19:06.217] - relayed: [n=2] TRUE, TRUE
[13:19:06.217] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:06.217] - relayed: [n=2] TRUE, TRUE
[13:19:06.217] - queued futures: [n=2] TRUE, TRUE
[13:19:06.217] signalConditionsASAP(NULL, pos=0) ... done
[13:19:06.217] resolve() on list ... DONE
[13:19:06.217] result() for ClusterFuture ...
[13:19:06.217] - result already collected: FutureResult
[13:19:06.218] result() for ClusterFuture ... done
[13:19:06.218] result() for ClusterFuture ...
[13:19:06.218] - result already collected: FutureResult
[13:19:06.218] result() for ClusterFuture ... done
[13:19:06.218] result() for ClusterFuture ...
[13:19:06.218] - result already collected: FutureResult
[13:19:06.218] result() for ClusterFuture ... done
[13:19:06.218] result() for ClusterFuture ...
[13:19:06.218] - result already collected: FutureResult
[13:19:06.218] result() for ClusterFuture ... done
[13:19:06.218]  - Number of value chunks collected: 2
[13:19:06.219] Resolving 2 futures (chunks) ... DONE
[13:19:06.219] Reducing values from 2 chunks ...
[13:19:06.219]  - Number of values collected after concatenation: 4
[13:19:06.219]  - Number of values expected: 4
[13:19:06.219] Reducing values from 2 chunks ... DONE
[13:19:06.219] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:19:06.221] future_lapply() ...
[13:19:06.226] Number of chunks: 2
[13:19:06.227] getGlobalsAndPackagesXApply() ...
[13:19:06.227]  - future.globals: TRUE
[13:19:06.227] getGlobalsAndPackages() ...
[13:19:06.227] Searching for globals...
[13:19:06.230] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:06.230] Searching for globals ... DONE
[13:19:06.230] Resolving globals: FALSE
[13:19:06.231] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:19:06.232] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:06.232] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:06.232] - packages: [1] ‘future.apply’
[13:19:06.232] getGlobalsAndPackages() ... DONE
[13:19:06.232]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:06.232]  - needed namespaces: [n=1] ‘future.apply’
[13:19:06.232] Finding globals ... DONE
[13:19:06.232]  - use_args: TRUE
[13:19:06.232]  - Getting '...' globals ...
[13:19:06.233] resolve() on list ...
[13:19:06.233]  recursive: 0
[13:19:06.233]  length: 1
[13:19:06.233]  elements: ‘...’
[13:19:06.233]  length: 0 (resolved future 1)
[13:19:06.233] resolve() on list ... DONE
[13:19:06.233]    - '...' content: [n=0] 
[13:19:06.233] List of 1
[13:19:06.233]  $ ...: list()
[13:19:06.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:06.233]  - attr(*, "where")=List of 1
[13:19:06.233]   ..$ ...:<environment: 0x555f7ccd88d0> 
[13:19:06.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:06.233]  - attr(*, "resolved")= logi TRUE
[13:19:06.233]  - attr(*, "total_size")= num NA
[13:19:06.236]  - Getting '...' globals ... DONE
[13:19:06.236] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:06.236] List of 8
[13:19:06.236]  $ ...future.FUN:function (x, ...)  
[13:19:06.236]  $ x_FUN        :function (x)  
[13:19:06.236]  $ times        : int 1
[13:19:06.236]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:06.236]  $ stop_if_not  :function (...)  
[13:19:06.236]  $ dim          : NULL
[13:19:06.236]  $ valid_types  : chr "logical"
[13:19:06.236]  $ ...          : list()
[13:19:06.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:06.236]  - attr(*, "where")=List of 8
[13:19:06.236]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:06.236]   ..$ ...          :<environment: 0x555f7ccd88d0> 
[13:19:06.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:06.236]  - attr(*, "resolved")= logi FALSE
[13:19:06.236]  - attr(*, "total_size")= num 94200
[13:19:06.242] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:06.242] getGlobalsAndPackagesXApply() ... DONE
[13:19:06.242] Number of futures (= number of chunks): 2
[13:19:06.242] Launching 2 futures (chunks) ...
[13:19:06.242] Chunk #1 of 2 ...
[13:19:06.242]  - Finding globals in 'X' for chunk #1 ...
[13:19:06.242] getGlobalsAndPackages() ...
[13:19:06.242] Searching for globals...
[13:19:06.243] 
[13:19:06.243] Searching for globals ... DONE
[13:19:06.243] - globals: [0] <none>
[13:19:06.243] getGlobalsAndPackages() ... DONE
[13:19:06.243]    + additional globals found: [n=0] 
[13:19:06.243]    + additional namespaces needed: [n=0] 
[13:19:06.243]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:06.243]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[13:19:06.243]  - seeds: <none>
[13:19:06.244] getGlobalsAndPackages() ...
[13:19:06.244] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.244] Resolving globals: FALSE
[13:19:06.244] Tweak future expression to call with '...' arguments ...
[13:19:06.244] {
[13:19:06.244]     do.call(function(...) {
[13:19:06.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.244]             on.exit(options(oopts), add = TRUE)
[13:19:06.244]         }
[13:19:06.244]         {
[13:19:06.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.244]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.244]             })
[13:19:06.244]         }
[13:19:06.244]     }, args = future.call.arguments)
[13:19:06.244] }
[13:19:06.244] Tweak future expression to call with '...' arguments ... DONE
[13:19:06.245] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.245] - packages: [1] ‘future.apply’
[13:19:06.245] getGlobalsAndPackages() ... DONE
[13:19:06.245] run() for ‘Future’ ...
[13:19:06.246] - state: ‘created’
[13:19:06.246] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:06.262] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:06.263]   - Field: ‘node’
[13:19:06.263]   - Field: ‘label’
[13:19:06.263]   - Field: ‘local’
[13:19:06.263]   - Field: ‘owner’
[13:19:06.263]   - Field: ‘envir’
[13:19:06.263]   - Field: ‘workers’
[13:19:06.263]   - Field: ‘packages’
[13:19:06.263]   - Field: ‘gc’
[13:19:06.263]   - Field: ‘conditions’
[13:19:06.263]   - Field: ‘persistent’
[13:19:06.264]   - Field: ‘expr’
[13:19:06.264]   - Field: ‘uuid’
[13:19:06.264]   - Field: ‘seed’
[13:19:06.264]   - Field: ‘version’
[13:19:06.264]   - Field: ‘result’
[13:19:06.264]   - Field: ‘asynchronous’
[13:19:06.264]   - Field: ‘calls’
[13:19:06.264]   - Field: ‘globals’
[13:19:06.264]   - Field: ‘stdout’
[13:19:06.264]   - Field: ‘earlySignal’
[13:19:06.264]   - Field: ‘lazy’
[13:19:06.265]   - Field: ‘state’
[13:19:06.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:06.265] - Launch lazy future ...
[13:19:06.265] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:06.265] Packages needed by future strategies (n = 0): <none>
[13:19:06.266] {
[13:19:06.266]     {
[13:19:06.266]         {
[13:19:06.266]             ...future.startTime <- base::Sys.time()
[13:19:06.266]             {
[13:19:06.266]                 {
[13:19:06.266]                   {
[13:19:06.266]                     {
[13:19:06.266]                       {
[13:19:06.266]                         base::local({
[13:19:06.266]                           has_future <- base::requireNamespace("future", 
[13:19:06.266]                             quietly = TRUE)
[13:19:06.266]                           if (has_future) {
[13:19:06.266]                             ns <- base::getNamespace("future")
[13:19:06.266]                             version <- ns[[".package"]][["version"]]
[13:19:06.266]                             if (is.null(version)) 
[13:19:06.266]                               version <- utils::packageVersion("future")
[13:19:06.266]                           }
[13:19:06.266]                           else {
[13:19:06.266]                             version <- NULL
[13:19:06.266]                           }
[13:19:06.266]                           if (!has_future || version < "1.8.0") {
[13:19:06.266]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:06.266]                               "", base::R.version$version.string), 
[13:19:06.266]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:06.266]                                 base::R.version$platform, 8 * 
[13:19:06.266]                                   base::.Machine$sizeof.pointer), 
[13:19:06.266]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:06.266]                                 "release", "version")], collapse = " "), 
[13:19:06.266]                               hostname = base::Sys.info()[["nodename"]])
[13:19:06.266]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:06.266]                               info)
[13:19:06.266]                             info <- base::paste(info, collapse = "; ")
[13:19:06.266]                             if (!has_future) {
[13:19:06.266]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:06.266]                                 info)
[13:19:06.266]                             }
[13:19:06.266]                             else {
[13:19:06.266]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:06.266]                                 info, version)
[13:19:06.266]                             }
[13:19:06.266]                             base::stop(msg)
[13:19:06.266]                           }
[13:19:06.266]                         })
[13:19:06.266]                       }
[13:19:06.266]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:06.266]                       base::options(mc.cores = 1L)
[13:19:06.266]                     }
[13:19:06.266]                     base::local({
[13:19:06.266]                       for (pkg in "future.apply") {
[13:19:06.266]                         base::loadNamespace(pkg)
[13:19:06.266]                         base::library(pkg, character.only = TRUE)
[13:19:06.266]                       }
[13:19:06.266]                     })
[13:19:06.266]                   }
[13:19:06.266]                   options(future.plan = NULL)
[13:19:06.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:06.266]                 }
[13:19:06.266]                 ...future.workdir <- getwd()
[13:19:06.266]             }
[13:19:06.266]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:06.266]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:06.266]         }
[13:19:06.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:06.266]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[13:19:06.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:06.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:06.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:06.266]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:06.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:06.266]             base::names(...future.oldOptions))
[13:19:06.266]     }
[13:19:06.266]     if (FALSE) {
[13:19:06.266]     }
[13:19:06.266]     else {
[13:19:06.266]         if (TRUE) {
[13:19:06.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:06.266]                 open = "w")
[13:19:06.266]         }
[13:19:06.266]         else {
[13:19:06.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:06.266]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:06.266]         }
[13:19:06.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:06.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:06.266]             base::sink(type = "output", split = FALSE)
[13:19:06.266]             base::close(...future.stdout)
[13:19:06.266]         }, add = TRUE)
[13:19:06.266]     }
[13:19:06.266]     ...future.frame <- base::sys.nframe()
[13:19:06.266]     ...future.conditions <- base::list()
[13:19:06.266]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:06.266]     if (FALSE) {
[13:19:06.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:06.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:06.266]     }
[13:19:06.266]     ...future.result <- base::tryCatch({
[13:19:06.266]         base::withCallingHandlers({
[13:19:06.266]             ...future.value <- base::withVisible(base::local({
[13:19:06.266]                 ...future.makeSendCondition <- local({
[13:19:06.266]                   sendCondition <- NULL
[13:19:06.266]                   function(frame = 1L) {
[13:19:06.266]                     if (is.function(sendCondition)) 
[13:19:06.266]                       return(sendCondition)
[13:19:06.266]                     ns <- getNamespace("parallel")
[13:19:06.266]                     if (exists("sendData", mode = "function", 
[13:19:06.266]                       envir = ns)) {
[13:19:06.266]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:06.266]                         envir = ns)
[13:19:06.266]                       envir <- sys.frame(frame)
[13:19:06.266]                       master <- NULL
[13:19:06.266]                       while (!identical(envir, .GlobalEnv) && 
[13:19:06.266]                         !identical(envir, emptyenv())) {
[13:19:06.266]                         if (exists("master", mode = "list", envir = envir, 
[13:19:06.266]                           inherits = FALSE)) {
[13:19:06.266]                           master <- get("master", mode = "list", 
[13:19:06.266]                             envir = envir, inherits = FALSE)
[13:19:06.266]                           if (inherits(master, c("SOCKnode", 
[13:19:06.266]                             "SOCK0node"))) {
[13:19:06.266]                             sendCondition <<- function(cond) {
[13:19:06.266]                               data <- list(type = "VALUE", value = cond, 
[13:19:06.266]                                 success = TRUE)
[13:19:06.266]                               parallel_sendData(master, data)
[13:19:06.266]                             }
[13:19:06.266]                             return(sendCondition)
[13:19:06.266]                           }
[13:19:06.266]                         }
[13:19:06.266]                         frame <- frame + 1L
[13:19:06.266]                         envir <- sys.frame(frame)
[13:19:06.266]                       }
[13:19:06.266]                     }
[13:19:06.266]                     sendCondition <<- function(cond) NULL
[13:19:06.266]                   }
[13:19:06.266]                 })
[13:19:06.266]                 withCallingHandlers({
[13:19:06.266]                   {
[13:19:06.266]                     do.call(function(...) {
[13:19:06.266]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.266]                       if (!identical(...future.globals.maxSize.org, 
[13:19:06.266]                         ...future.globals.maxSize)) {
[13:19:06.266]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.266]                         on.exit(options(oopts), add = TRUE)
[13:19:06.266]                       }
[13:19:06.266]                       {
[13:19:06.266]                         lapply(seq_along(...future.elements_ii), 
[13:19:06.266]                           FUN = function(jj) {
[13:19:06.266]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.266]                             ...future.FUN(...future.X_jj, ...)
[13:19:06.266]                           })
[13:19:06.266]                       }
[13:19:06.266]                     }, args = future.call.arguments)
[13:19:06.266]                   }
[13:19:06.266]                 }, immediateCondition = function(cond) {
[13:19:06.266]                   sendCondition <- ...future.makeSendCondition()
[13:19:06.266]                   sendCondition(cond)
[13:19:06.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.266]                   {
[13:19:06.266]                     inherits <- base::inherits
[13:19:06.266]                     invokeRestart <- base::invokeRestart
[13:19:06.266]                     is.null <- base::is.null
[13:19:06.266]                     muffled <- FALSE
[13:19:06.266]                     if (inherits(cond, "message")) {
[13:19:06.266]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:06.266]                       if (muffled) 
[13:19:06.266]                         invokeRestart("muffleMessage")
[13:19:06.266]                     }
[13:19:06.266]                     else if (inherits(cond, "warning")) {
[13:19:06.266]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:06.266]                       if (muffled) 
[13:19:06.266]                         invokeRestart("muffleWarning")
[13:19:06.266]                     }
[13:19:06.266]                     else if (inherits(cond, "condition")) {
[13:19:06.266]                       if (!is.null(pattern)) {
[13:19:06.266]                         computeRestarts <- base::computeRestarts
[13:19:06.266]                         grepl <- base::grepl
[13:19:06.266]                         restarts <- computeRestarts(cond)
[13:19:06.266]                         for (restart in restarts) {
[13:19:06.266]                           name <- restart$name
[13:19:06.266]                           if (is.null(name)) 
[13:19:06.266]                             next
[13:19:06.266]                           if (!grepl(pattern, name)) 
[13:19:06.266]                             next
[13:19:06.266]                           invokeRestart(restart)
[13:19:06.266]                           muffled <- TRUE
[13:19:06.266]                           break
[13:19:06.266]                         }
[13:19:06.266]                       }
[13:19:06.266]                     }
[13:19:06.266]                     invisible(muffled)
[13:19:06.266]                   }
[13:19:06.266]                   muffleCondition(cond)
[13:19:06.266]                 })
[13:19:06.266]             }))
[13:19:06.266]             future::FutureResult(value = ...future.value$value, 
[13:19:06.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.266]                   ...future.rng), globalenv = if (FALSE) 
[13:19:06.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:06.266]                     ...future.globalenv.names))
[13:19:06.266]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:06.266]         }, condition = base::local({
[13:19:06.266]             c <- base::c
[13:19:06.266]             inherits <- base::inherits
[13:19:06.266]             invokeRestart <- base::invokeRestart
[13:19:06.266]             length <- base::length
[13:19:06.266]             list <- base::list
[13:19:06.266]             seq.int <- base::seq.int
[13:19:06.266]             signalCondition <- base::signalCondition
[13:19:06.266]             sys.calls <- base::sys.calls
[13:19:06.266]             `[[` <- base::`[[`
[13:19:06.266]             `+` <- base::`+`
[13:19:06.266]             `<<-` <- base::`<<-`
[13:19:06.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:06.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:06.266]                   3L)]
[13:19:06.266]             }
[13:19:06.266]             function(cond) {
[13:19:06.266]                 is_error <- inherits(cond, "error")
[13:19:06.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:06.266]                   NULL)
[13:19:06.266]                 if (is_error) {
[13:19:06.266]                   sessionInformation <- function() {
[13:19:06.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:06.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:06.266]                       search = base::search(), system = base::Sys.info())
[13:19:06.266]                   }
[13:19:06.266]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:06.266]                     cond$call), session = sessionInformation(), 
[13:19:06.266]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:06.266]                   signalCondition(cond)
[13:19:06.266]                 }
[13:19:06.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:06.266]                 "immediateCondition"))) {
[13:19:06.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:06.266]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:06.266]                   if (TRUE && !signal) {
[13:19:06.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.266]                     {
[13:19:06.266]                       inherits <- base::inherits
[13:19:06.266]                       invokeRestart <- base::invokeRestart
[13:19:06.266]                       is.null <- base::is.null
[13:19:06.266]                       muffled <- FALSE
[13:19:06.266]                       if (inherits(cond, "message")) {
[13:19:06.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.266]                         if (muffled) 
[13:19:06.266]                           invokeRestart("muffleMessage")
[13:19:06.266]                       }
[13:19:06.266]                       else if (inherits(cond, "warning")) {
[13:19:06.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.266]                         if (muffled) 
[13:19:06.266]                           invokeRestart("muffleWarning")
[13:19:06.266]                       }
[13:19:06.266]                       else if (inherits(cond, "condition")) {
[13:19:06.266]                         if (!is.null(pattern)) {
[13:19:06.266]                           computeRestarts <- base::computeRestarts
[13:19:06.266]                           grepl <- base::grepl
[13:19:06.266]                           restarts <- computeRestarts(cond)
[13:19:06.266]                           for (restart in restarts) {
[13:19:06.266]                             name <- restart$name
[13:19:06.266]                             if (is.null(name)) 
[13:19:06.266]                               next
[13:19:06.266]                             if (!grepl(pattern, name)) 
[13:19:06.266]                               next
[13:19:06.266]                             invokeRestart(restart)
[13:19:06.266]                             muffled <- TRUE
[13:19:06.266]                             break
[13:19:06.266]                           }
[13:19:06.266]                         }
[13:19:06.266]                       }
[13:19:06.266]                       invisible(muffled)
[13:19:06.266]                     }
[13:19:06.266]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.266]                   }
[13:19:06.266]                 }
[13:19:06.266]                 else {
[13:19:06.266]                   if (TRUE) {
[13:19:06.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.266]                     {
[13:19:06.266]                       inherits <- base::inherits
[13:19:06.266]                       invokeRestart <- base::invokeRestart
[13:19:06.266]                       is.null <- base::is.null
[13:19:06.266]                       muffled <- FALSE
[13:19:06.266]                       if (inherits(cond, "message")) {
[13:19:06.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.266]                         if (muffled) 
[13:19:06.266]                           invokeRestart("muffleMessage")
[13:19:06.266]                       }
[13:19:06.266]                       else if (inherits(cond, "warning")) {
[13:19:06.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.266]                         if (muffled) 
[13:19:06.266]                           invokeRestart("muffleWarning")
[13:19:06.266]                       }
[13:19:06.266]                       else if (inherits(cond, "condition")) {
[13:19:06.266]                         if (!is.null(pattern)) {
[13:19:06.266]                           computeRestarts <- base::computeRestarts
[13:19:06.266]                           grepl <- base::grepl
[13:19:06.266]                           restarts <- computeRestarts(cond)
[13:19:06.266]                           for (restart in restarts) {
[13:19:06.266]                             name <- restart$name
[13:19:06.266]                             if (is.null(name)) 
[13:19:06.266]                               next
[13:19:06.266]                             if (!grepl(pattern, name)) 
[13:19:06.266]                               next
[13:19:06.266]                             invokeRestart(restart)
[13:19:06.266]                             muffled <- TRUE
[13:19:06.266]                             break
[13:19:06.266]                           }
[13:19:06.266]                         }
[13:19:06.266]                       }
[13:19:06.266]                       invisible(muffled)
[13:19:06.266]                     }
[13:19:06.266]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.266]                   }
[13:19:06.266]                 }
[13:19:06.266]             }
[13:19:06.266]         }))
[13:19:06.266]     }, error = function(ex) {
[13:19:06.266]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:06.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.266]                 ...future.rng), started = ...future.startTime, 
[13:19:06.266]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:06.266]             version = "1.8"), class = "FutureResult")
[13:19:06.266]     }, finally = {
[13:19:06.266]         if (!identical(...future.workdir, getwd())) 
[13:19:06.266]             setwd(...future.workdir)
[13:19:06.266]         {
[13:19:06.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:06.266]                 ...future.oldOptions$nwarnings <- NULL
[13:19:06.266]             }
[13:19:06.266]             base::options(...future.oldOptions)
[13:19:06.266]             if (.Platform$OS.type == "windows") {
[13:19:06.266]                 old_names <- names(...future.oldEnvVars)
[13:19:06.266]                 envs <- base::Sys.getenv()
[13:19:06.266]                 names <- names(envs)
[13:19:06.266]                 common <- intersect(names, old_names)
[13:19:06.266]                 added <- setdiff(names, old_names)
[13:19:06.266]                 removed <- setdiff(old_names, names)
[13:19:06.266]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:06.266]                   envs[common]]
[13:19:06.266]                 NAMES <- toupper(changed)
[13:19:06.266]                 args <- list()
[13:19:06.266]                 for (kk in seq_along(NAMES)) {
[13:19:06.266]                   name <- changed[[kk]]
[13:19:06.266]                   NAME <- NAMES[[kk]]
[13:19:06.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.266]                     next
[13:19:06.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.266]                 }
[13:19:06.266]                 NAMES <- toupper(added)
[13:19:06.266]                 for (kk in seq_along(NAMES)) {
[13:19:06.266]                   name <- added[[kk]]
[13:19:06.266]                   NAME <- NAMES[[kk]]
[13:19:06.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.266]                     next
[13:19:06.266]                   args[[name]] <- ""
[13:19:06.266]                 }
[13:19:06.266]                 NAMES <- toupper(removed)
[13:19:06.266]                 for (kk in seq_along(NAMES)) {
[13:19:06.266]                   name <- removed[[kk]]
[13:19:06.266]                   NAME <- NAMES[[kk]]
[13:19:06.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.266]                     next
[13:19:06.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.266]                 }
[13:19:06.266]                 if (length(args) > 0) 
[13:19:06.266]                   base::do.call(base::Sys.setenv, args = args)
[13:19:06.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:06.266]             }
[13:19:06.266]             else {
[13:19:06.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:06.266]             }
[13:19:06.266]             {
[13:19:06.266]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:06.266]                   0L) {
[13:19:06.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:06.266]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:06.266]                   base::options(opts)
[13:19:06.266]                 }
[13:19:06.266]                 {
[13:19:06.266]                   {
[13:19:06.266]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:06.266]                     NULL
[13:19:06.266]                   }
[13:19:06.266]                   options(future.plan = NULL)
[13:19:06.266]                   if (is.na(NA_character_)) 
[13:19:06.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:06.266]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:06.266]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:06.266]                     envir = parent.frame()) 
[13:19:06.266]                   {
[13:19:06.266]                     if (is.function(workers)) 
[13:19:06.266]                       workers <- workers()
[13:19:06.266]                     workers <- structure(as.integer(workers), 
[13:19:06.266]                       class = class(workers))
[13:19:06.266]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:06.266]                       workers >= 1)
[13:19:06.266]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:06.266]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:06.266]                     }
[13:19:06.266]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:06.266]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:06.266]                       envir = envir)
[13:19:06.266]                     if (!future$lazy) 
[13:19:06.266]                       future <- run(future)
[13:19:06.266]                     invisible(future)
[13:19:06.266]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:06.266]                 }
[13:19:06.266]             }
[13:19:06.266]         }
[13:19:06.266]     })
[13:19:06.266]     if (TRUE) {
[13:19:06.266]         base::sink(type = "output", split = FALSE)
[13:19:06.266]         if (TRUE) {
[13:19:06.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:06.266]         }
[13:19:06.266]         else {
[13:19:06.266]             ...future.result["stdout"] <- base::list(NULL)
[13:19:06.266]         }
[13:19:06.266]         base::close(...future.stdout)
[13:19:06.266]         ...future.stdout <- NULL
[13:19:06.266]     }
[13:19:06.266]     ...future.result$conditions <- ...future.conditions
[13:19:06.266]     ...future.result$finished <- base::Sys.time()
[13:19:06.266]     ...future.result
[13:19:06.266] }
[13:19:06.269] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[13:19:06.269] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:06.313] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:06.313] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:19:06.314] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:19:06.314] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:06.314] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:06.315] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:06.357] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:06.357] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:06.401] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:06.401] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:06.402] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.402] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[13:19:06.402] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[13:19:06.403] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:06.403] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.403] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[13:19:06.403] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[13:19:06.404] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:06.404] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.404] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:06.407] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.407] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[13:19:06.407] MultisessionFuture started
[13:19:06.408] - Launch lazy future ... done
[13:19:06.408] run() for ‘MultisessionFuture’ ... done
[13:19:06.408] Created future:
[13:19:06.408] MultisessionFuture:
[13:19:06.408] Label: ‘future_vapply-1’
[13:19:06.408] Expression:
[13:19:06.408] {
[13:19:06.408]     do.call(function(...) {
[13:19:06.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.408]             on.exit(options(oopts), add = TRUE)
[13:19:06.408]         }
[13:19:06.408]         {
[13:19:06.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.408]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.408]             })
[13:19:06.408]         }
[13:19:06.408]     }, args = future.call.arguments)
[13:19:06.408] }
[13:19:06.408] Lazy evaluation: FALSE
[13:19:06.408] Asynchronous evaluation: TRUE
[13:19:06.408] Local evaluation: TRUE
[13:19:06.408] Environment: R_GlobalEnv
[13:19:06.408] Capture standard output: TRUE
[13:19:06.408] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:06.408] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:06.408] Packages: 1 packages (‘future.apply’)
[13:19:06.408] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:06.408] Resolved: FALSE
[13:19:06.408] Value: <not collected>
[13:19:06.408] Conditions captured: <none>
[13:19:06.408] Early signaling: FALSE
[13:19:06.408] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:06.408] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.420] Chunk #1 of 2 ... DONE
[13:19:06.420] Chunk #2 of 2 ...
[13:19:06.420]  - Finding globals in 'X' for chunk #2 ...
[13:19:06.420] getGlobalsAndPackages() ...
[13:19:06.420] Searching for globals...
[13:19:06.420] 
[13:19:06.420] Searching for globals ... DONE
[13:19:06.421] - globals: [0] <none>
[13:19:06.421] getGlobalsAndPackages() ... DONE
[13:19:06.421]    + additional globals found: [n=0] 
[13:19:06.421]    + additional namespaces needed: [n=0] 
[13:19:06.421]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:06.421]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:19:06.421]  - seeds: <none>
[13:19:06.421] getGlobalsAndPackages() ...
[13:19:06.421] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.421] Resolving globals: FALSE
[13:19:06.422] Tweak future expression to call with '...' arguments ...
[13:19:06.422] {
[13:19:06.422]     do.call(function(...) {
[13:19:06.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.422]             on.exit(options(oopts), add = TRUE)
[13:19:06.422]         }
[13:19:06.422]         {
[13:19:06.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.422]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.422]             })
[13:19:06.422]         }
[13:19:06.422]     }, args = future.call.arguments)
[13:19:06.422] }
[13:19:06.422] Tweak future expression to call with '...' arguments ... DONE
[13:19:06.423] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.423] - packages: [1] ‘future.apply’
[13:19:06.423] getGlobalsAndPackages() ... DONE
[13:19:06.423] run() for ‘Future’ ...
[13:19:06.423] - state: ‘created’
[13:19:06.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:06.438] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:06.438]   - Field: ‘node’
[13:19:06.438]   - Field: ‘label’
[13:19:06.438]   - Field: ‘local’
[13:19:06.438]   - Field: ‘owner’
[13:19:06.438]   - Field: ‘envir’
[13:19:06.438]   - Field: ‘workers’
[13:19:06.439]   - Field: ‘packages’
[13:19:06.439]   - Field: ‘gc’
[13:19:06.439]   - Field: ‘conditions’
[13:19:06.439]   - Field: ‘persistent’
[13:19:06.439]   - Field: ‘expr’
[13:19:06.439]   - Field: ‘uuid’
[13:19:06.439]   - Field: ‘seed’
[13:19:06.439]   - Field: ‘version’
[13:19:06.439]   - Field: ‘result’
[13:19:06.439]   - Field: ‘asynchronous’
[13:19:06.439]   - Field: ‘calls’
[13:19:06.440]   - Field: ‘globals’
[13:19:06.440]   - Field: ‘stdout’
[13:19:06.440]   - Field: ‘earlySignal’
[13:19:06.440]   - Field: ‘lazy’
[13:19:06.440]   - Field: ‘state’
[13:19:06.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:06.440] - Launch lazy future ...
[13:19:06.440] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:06.440] Packages needed by future strategies (n = 0): <none>
[13:19:06.441] {
[13:19:06.441]     {
[13:19:06.441]         {
[13:19:06.441]             ...future.startTime <- base::Sys.time()
[13:19:06.441]             {
[13:19:06.441]                 {
[13:19:06.441]                   {
[13:19:06.441]                     {
[13:19:06.441]                       {
[13:19:06.441]                         base::local({
[13:19:06.441]                           has_future <- base::requireNamespace("future", 
[13:19:06.441]                             quietly = TRUE)
[13:19:06.441]                           if (has_future) {
[13:19:06.441]                             ns <- base::getNamespace("future")
[13:19:06.441]                             version <- ns[[".package"]][["version"]]
[13:19:06.441]                             if (is.null(version)) 
[13:19:06.441]                               version <- utils::packageVersion("future")
[13:19:06.441]                           }
[13:19:06.441]                           else {
[13:19:06.441]                             version <- NULL
[13:19:06.441]                           }
[13:19:06.441]                           if (!has_future || version < "1.8.0") {
[13:19:06.441]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:06.441]                               "", base::R.version$version.string), 
[13:19:06.441]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:06.441]                                 base::R.version$platform, 8 * 
[13:19:06.441]                                   base::.Machine$sizeof.pointer), 
[13:19:06.441]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:06.441]                                 "release", "version")], collapse = " "), 
[13:19:06.441]                               hostname = base::Sys.info()[["nodename"]])
[13:19:06.441]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:06.441]                               info)
[13:19:06.441]                             info <- base::paste(info, collapse = "; ")
[13:19:06.441]                             if (!has_future) {
[13:19:06.441]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:06.441]                                 info)
[13:19:06.441]                             }
[13:19:06.441]                             else {
[13:19:06.441]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:06.441]                                 info, version)
[13:19:06.441]                             }
[13:19:06.441]                             base::stop(msg)
[13:19:06.441]                           }
[13:19:06.441]                         })
[13:19:06.441]                       }
[13:19:06.441]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:06.441]                       base::options(mc.cores = 1L)
[13:19:06.441]                     }
[13:19:06.441]                     base::local({
[13:19:06.441]                       for (pkg in "future.apply") {
[13:19:06.441]                         base::loadNamespace(pkg)
[13:19:06.441]                         base::library(pkg, character.only = TRUE)
[13:19:06.441]                       }
[13:19:06.441]                     })
[13:19:06.441]                   }
[13:19:06.441]                   options(future.plan = NULL)
[13:19:06.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:06.441]                 }
[13:19:06.441]                 ...future.workdir <- getwd()
[13:19:06.441]             }
[13:19:06.441]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:06.441]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:06.441]         }
[13:19:06.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:06.441]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:19:06.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:06.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:06.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:06.441]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:06.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:06.441]             base::names(...future.oldOptions))
[13:19:06.441]     }
[13:19:06.441]     if (FALSE) {
[13:19:06.441]     }
[13:19:06.441]     else {
[13:19:06.441]         if (TRUE) {
[13:19:06.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:06.441]                 open = "w")
[13:19:06.441]         }
[13:19:06.441]         else {
[13:19:06.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:06.441]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:06.441]         }
[13:19:06.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:06.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:06.441]             base::sink(type = "output", split = FALSE)
[13:19:06.441]             base::close(...future.stdout)
[13:19:06.441]         }, add = TRUE)
[13:19:06.441]     }
[13:19:06.441]     ...future.frame <- base::sys.nframe()
[13:19:06.441]     ...future.conditions <- base::list()
[13:19:06.441]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:06.441]     if (FALSE) {
[13:19:06.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:06.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:06.441]     }
[13:19:06.441]     ...future.result <- base::tryCatch({
[13:19:06.441]         base::withCallingHandlers({
[13:19:06.441]             ...future.value <- base::withVisible(base::local({
[13:19:06.441]                 ...future.makeSendCondition <- local({
[13:19:06.441]                   sendCondition <- NULL
[13:19:06.441]                   function(frame = 1L) {
[13:19:06.441]                     if (is.function(sendCondition)) 
[13:19:06.441]                       return(sendCondition)
[13:19:06.441]                     ns <- getNamespace("parallel")
[13:19:06.441]                     if (exists("sendData", mode = "function", 
[13:19:06.441]                       envir = ns)) {
[13:19:06.441]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:06.441]                         envir = ns)
[13:19:06.441]                       envir <- sys.frame(frame)
[13:19:06.441]                       master <- NULL
[13:19:06.441]                       while (!identical(envir, .GlobalEnv) && 
[13:19:06.441]                         !identical(envir, emptyenv())) {
[13:19:06.441]                         if (exists("master", mode = "list", envir = envir, 
[13:19:06.441]                           inherits = FALSE)) {
[13:19:06.441]                           master <- get("master", mode = "list", 
[13:19:06.441]                             envir = envir, inherits = FALSE)
[13:19:06.441]                           if (inherits(master, c("SOCKnode", 
[13:19:06.441]                             "SOCK0node"))) {
[13:19:06.441]                             sendCondition <<- function(cond) {
[13:19:06.441]                               data <- list(type = "VALUE", value = cond, 
[13:19:06.441]                                 success = TRUE)
[13:19:06.441]                               parallel_sendData(master, data)
[13:19:06.441]                             }
[13:19:06.441]                             return(sendCondition)
[13:19:06.441]                           }
[13:19:06.441]                         }
[13:19:06.441]                         frame <- frame + 1L
[13:19:06.441]                         envir <- sys.frame(frame)
[13:19:06.441]                       }
[13:19:06.441]                     }
[13:19:06.441]                     sendCondition <<- function(cond) NULL
[13:19:06.441]                   }
[13:19:06.441]                 })
[13:19:06.441]                 withCallingHandlers({
[13:19:06.441]                   {
[13:19:06.441]                     do.call(function(...) {
[13:19:06.441]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.441]                       if (!identical(...future.globals.maxSize.org, 
[13:19:06.441]                         ...future.globals.maxSize)) {
[13:19:06.441]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.441]                         on.exit(options(oopts), add = TRUE)
[13:19:06.441]                       }
[13:19:06.441]                       {
[13:19:06.441]                         lapply(seq_along(...future.elements_ii), 
[13:19:06.441]                           FUN = function(jj) {
[13:19:06.441]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.441]                             ...future.FUN(...future.X_jj, ...)
[13:19:06.441]                           })
[13:19:06.441]                       }
[13:19:06.441]                     }, args = future.call.arguments)
[13:19:06.441]                   }
[13:19:06.441]                 }, immediateCondition = function(cond) {
[13:19:06.441]                   sendCondition <- ...future.makeSendCondition()
[13:19:06.441]                   sendCondition(cond)
[13:19:06.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.441]                   {
[13:19:06.441]                     inherits <- base::inherits
[13:19:06.441]                     invokeRestart <- base::invokeRestart
[13:19:06.441]                     is.null <- base::is.null
[13:19:06.441]                     muffled <- FALSE
[13:19:06.441]                     if (inherits(cond, "message")) {
[13:19:06.441]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:06.441]                       if (muffled) 
[13:19:06.441]                         invokeRestart("muffleMessage")
[13:19:06.441]                     }
[13:19:06.441]                     else if (inherits(cond, "warning")) {
[13:19:06.441]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:06.441]                       if (muffled) 
[13:19:06.441]                         invokeRestart("muffleWarning")
[13:19:06.441]                     }
[13:19:06.441]                     else if (inherits(cond, "condition")) {
[13:19:06.441]                       if (!is.null(pattern)) {
[13:19:06.441]                         computeRestarts <- base::computeRestarts
[13:19:06.441]                         grepl <- base::grepl
[13:19:06.441]                         restarts <- computeRestarts(cond)
[13:19:06.441]                         for (restart in restarts) {
[13:19:06.441]                           name <- restart$name
[13:19:06.441]                           if (is.null(name)) 
[13:19:06.441]                             next
[13:19:06.441]                           if (!grepl(pattern, name)) 
[13:19:06.441]                             next
[13:19:06.441]                           invokeRestart(restart)
[13:19:06.441]                           muffled <- TRUE
[13:19:06.441]                           break
[13:19:06.441]                         }
[13:19:06.441]                       }
[13:19:06.441]                     }
[13:19:06.441]                     invisible(muffled)
[13:19:06.441]                   }
[13:19:06.441]                   muffleCondition(cond)
[13:19:06.441]                 })
[13:19:06.441]             }))
[13:19:06.441]             future::FutureResult(value = ...future.value$value, 
[13:19:06.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.441]                   ...future.rng), globalenv = if (FALSE) 
[13:19:06.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:06.441]                     ...future.globalenv.names))
[13:19:06.441]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:06.441]         }, condition = base::local({
[13:19:06.441]             c <- base::c
[13:19:06.441]             inherits <- base::inherits
[13:19:06.441]             invokeRestart <- base::invokeRestart
[13:19:06.441]             length <- base::length
[13:19:06.441]             list <- base::list
[13:19:06.441]             seq.int <- base::seq.int
[13:19:06.441]             signalCondition <- base::signalCondition
[13:19:06.441]             sys.calls <- base::sys.calls
[13:19:06.441]             `[[` <- base::`[[`
[13:19:06.441]             `+` <- base::`+`
[13:19:06.441]             `<<-` <- base::`<<-`
[13:19:06.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:06.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:06.441]                   3L)]
[13:19:06.441]             }
[13:19:06.441]             function(cond) {
[13:19:06.441]                 is_error <- inherits(cond, "error")
[13:19:06.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:06.441]                   NULL)
[13:19:06.441]                 if (is_error) {
[13:19:06.441]                   sessionInformation <- function() {
[13:19:06.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:06.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:06.441]                       search = base::search(), system = base::Sys.info())
[13:19:06.441]                   }
[13:19:06.441]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:06.441]                     cond$call), session = sessionInformation(), 
[13:19:06.441]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:06.441]                   signalCondition(cond)
[13:19:06.441]                 }
[13:19:06.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:06.441]                 "immediateCondition"))) {
[13:19:06.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:06.441]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:06.441]                   if (TRUE && !signal) {
[13:19:06.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.441]                     {
[13:19:06.441]                       inherits <- base::inherits
[13:19:06.441]                       invokeRestart <- base::invokeRestart
[13:19:06.441]                       is.null <- base::is.null
[13:19:06.441]                       muffled <- FALSE
[13:19:06.441]                       if (inherits(cond, "message")) {
[13:19:06.441]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.441]                         if (muffled) 
[13:19:06.441]                           invokeRestart("muffleMessage")
[13:19:06.441]                       }
[13:19:06.441]                       else if (inherits(cond, "warning")) {
[13:19:06.441]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.441]                         if (muffled) 
[13:19:06.441]                           invokeRestart("muffleWarning")
[13:19:06.441]                       }
[13:19:06.441]                       else if (inherits(cond, "condition")) {
[13:19:06.441]                         if (!is.null(pattern)) {
[13:19:06.441]                           computeRestarts <- base::computeRestarts
[13:19:06.441]                           grepl <- base::grepl
[13:19:06.441]                           restarts <- computeRestarts(cond)
[13:19:06.441]                           for (restart in restarts) {
[13:19:06.441]                             name <- restart$name
[13:19:06.441]                             if (is.null(name)) 
[13:19:06.441]                               next
[13:19:06.441]                             if (!grepl(pattern, name)) 
[13:19:06.441]                               next
[13:19:06.441]                             invokeRestart(restart)
[13:19:06.441]                             muffled <- TRUE
[13:19:06.441]                             break
[13:19:06.441]                           }
[13:19:06.441]                         }
[13:19:06.441]                       }
[13:19:06.441]                       invisible(muffled)
[13:19:06.441]                     }
[13:19:06.441]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.441]                   }
[13:19:06.441]                 }
[13:19:06.441]                 else {
[13:19:06.441]                   if (TRUE) {
[13:19:06.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.441]                     {
[13:19:06.441]                       inherits <- base::inherits
[13:19:06.441]                       invokeRestart <- base::invokeRestart
[13:19:06.441]                       is.null <- base::is.null
[13:19:06.441]                       muffled <- FALSE
[13:19:06.441]                       if (inherits(cond, "message")) {
[13:19:06.441]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.441]                         if (muffled) 
[13:19:06.441]                           invokeRestart("muffleMessage")
[13:19:06.441]                       }
[13:19:06.441]                       else if (inherits(cond, "warning")) {
[13:19:06.441]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.441]                         if (muffled) 
[13:19:06.441]                           invokeRestart("muffleWarning")
[13:19:06.441]                       }
[13:19:06.441]                       else if (inherits(cond, "condition")) {
[13:19:06.441]                         if (!is.null(pattern)) {
[13:19:06.441]                           computeRestarts <- base::computeRestarts
[13:19:06.441]                           grepl <- base::grepl
[13:19:06.441]                           restarts <- computeRestarts(cond)
[13:19:06.441]                           for (restart in restarts) {
[13:19:06.441]                             name <- restart$name
[13:19:06.441]                             if (is.null(name)) 
[13:19:06.441]                               next
[13:19:06.441]                             if (!grepl(pattern, name)) 
[13:19:06.441]                               next
[13:19:06.441]                             invokeRestart(restart)
[13:19:06.441]                             muffled <- TRUE
[13:19:06.441]                             break
[13:19:06.441]                           }
[13:19:06.441]                         }
[13:19:06.441]                       }
[13:19:06.441]                       invisible(muffled)
[13:19:06.441]                     }
[13:19:06.441]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.441]                   }
[13:19:06.441]                 }
[13:19:06.441]             }
[13:19:06.441]         }))
[13:19:06.441]     }, error = function(ex) {
[13:19:06.441]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:06.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.441]                 ...future.rng), started = ...future.startTime, 
[13:19:06.441]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:06.441]             version = "1.8"), class = "FutureResult")
[13:19:06.441]     }, finally = {
[13:19:06.441]         if (!identical(...future.workdir, getwd())) 
[13:19:06.441]             setwd(...future.workdir)
[13:19:06.441]         {
[13:19:06.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:06.441]                 ...future.oldOptions$nwarnings <- NULL
[13:19:06.441]             }
[13:19:06.441]             base::options(...future.oldOptions)
[13:19:06.441]             if (.Platform$OS.type == "windows") {
[13:19:06.441]                 old_names <- names(...future.oldEnvVars)
[13:19:06.441]                 envs <- base::Sys.getenv()
[13:19:06.441]                 names <- names(envs)
[13:19:06.441]                 common <- intersect(names, old_names)
[13:19:06.441]                 added <- setdiff(names, old_names)
[13:19:06.441]                 removed <- setdiff(old_names, names)
[13:19:06.441]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:06.441]                   envs[common]]
[13:19:06.441]                 NAMES <- toupper(changed)
[13:19:06.441]                 args <- list()
[13:19:06.441]                 for (kk in seq_along(NAMES)) {
[13:19:06.441]                   name <- changed[[kk]]
[13:19:06.441]                   NAME <- NAMES[[kk]]
[13:19:06.441]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.441]                     next
[13:19:06.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.441]                 }
[13:19:06.441]                 NAMES <- toupper(added)
[13:19:06.441]                 for (kk in seq_along(NAMES)) {
[13:19:06.441]                   name <- added[[kk]]
[13:19:06.441]                   NAME <- NAMES[[kk]]
[13:19:06.441]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.441]                     next
[13:19:06.441]                   args[[name]] <- ""
[13:19:06.441]                 }
[13:19:06.441]                 NAMES <- toupper(removed)
[13:19:06.441]                 for (kk in seq_along(NAMES)) {
[13:19:06.441]                   name <- removed[[kk]]
[13:19:06.441]                   NAME <- NAMES[[kk]]
[13:19:06.441]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.441]                     next
[13:19:06.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.441]                 }
[13:19:06.441]                 if (length(args) > 0) 
[13:19:06.441]                   base::do.call(base::Sys.setenv, args = args)
[13:19:06.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:06.441]             }
[13:19:06.441]             else {
[13:19:06.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:06.441]             }
[13:19:06.441]             {
[13:19:06.441]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:06.441]                   0L) {
[13:19:06.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:06.441]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:06.441]                   base::options(opts)
[13:19:06.441]                 }
[13:19:06.441]                 {
[13:19:06.441]                   {
[13:19:06.441]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:06.441]                     NULL
[13:19:06.441]                   }
[13:19:06.441]                   options(future.plan = NULL)
[13:19:06.441]                   if (is.na(NA_character_)) 
[13:19:06.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:06.441]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:06.441]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:06.441]                     envir = parent.frame()) 
[13:19:06.441]                   {
[13:19:06.441]                     if (is.function(workers)) 
[13:19:06.441]                       workers <- workers()
[13:19:06.441]                     workers <- structure(as.integer(workers), 
[13:19:06.441]                       class = class(workers))
[13:19:06.441]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:06.441]                       workers >= 1)
[13:19:06.441]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:06.441]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:06.441]                     }
[13:19:06.441]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:06.441]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:06.441]                       envir = envir)
[13:19:06.441]                     if (!future$lazy) 
[13:19:06.441]                       future <- run(future)
[13:19:06.441]                     invisible(future)
[13:19:06.441]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:06.441]                 }
[13:19:06.441]             }
[13:19:06.441]         }
[13:19:06.441]     })
[13:19:06.441]     if (TRUE) {
[13:19:06.441]         base::sink(type = "output", split = FALSE)
[13:19:06.441]         if (TRUE) {
[13:19:06.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:06.441]         }
[13:19:06.441]         else {
[13:19:06.441]             ...future.result["stdout"] <- base::list(NULL)
[13:19:06.441]         }
[13:19:06.441]         base::close(...future.stdout)
[13:19:06.441]         ...future.stdout <- NULL
[13:19:06.441]     }
[13:19:06.441]     ...future.result$conditions <- ...future.conditions
[13:19:06.441]     ...future.result$finished <- base::Sys.time()
[13:19:06.441]     ...future.result
[13:19:06.441] }
[13:19:06.444] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[13:19:06.444] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:06.485] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:06.485] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:19:06.486] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:19:06.486] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:06.486] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:06.486] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:06.529] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:06.529] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:06.573] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:06.573] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:06.574] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.574] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[13:19:06.574] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[13:19:06.575] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:06.575] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.575] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[13:19:06.576] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[13:19:06.576] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:06.576] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.576] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:06.577] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.577] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[13:19:06.577] MultisessionFuture started
[13:19:06.577] - Launch lazy future ... done
[13:19:06.578] run() for ‘MultisessionFuture’ ... done
[13:19:06.578] Created future:
[13:19:06.578] MultisessionFuture:
[13:19:06.578] Label: ‘future_vapply-2’
[13:19:06.578] Expression:
[13:19:06.578] {
[13:19:06.578]     do.call(function(...) {
[13:19:06.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.578]             on.exit(options(oopts), add = TRUE)
[13:19:06.578]         }
[13:19:06.578]         {
[13:19:06.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.578]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.578]             })
[13:19:06.578]         }
[13:19:06.578]     }, args = future.call.arguments)
[13:19:06.578] }
[13:19:06.578] Lazy evaluation: FALSE
[13:19:06.578] Asynchronous evaluation: TRUE
[13:19:06.578] Local evaluation: TRUE
[13:19:06.578] Environment: R_GlobalEnv
[13:19:06.578] Capture standard output: TRUE
[13:19:06.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:06.578] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:06.578] Packages: 1 packages (‘future.apply’)
[13:19:06.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:06.578] Resolved: FALSE
[13:19:06.578] Value: <not collected>
[13:19:06.578] Conditions captured: <none>
[13:19:06.578] Early signaling: FALSE
[13:19:06.578] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:06.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.590] Chunk #2 of 2 ... DONE
[13:19:06.590] Launching 2 futures (chunks) ... DONE
[13:19:06.590] Resolving 2 futures (chunks) ...
[13:19:06.590] resolve() on list ...
[13:19:06.590]  recursive: 0
[13:19:06.590]  length: 2
[13:19:06.590] 
[13:19:06.591] receiveMessageFromWorker() for ClusterFuture ...
[13:19:06.591] - Validating connection of MultisessionFuture
[13:19:06.591] - received message: FutureResult
[13:19:06.591] - Received FutureResult
[13:19:06.591] - Erased future from FutureRegistry
[13:19:06.591] result() for ClusterFuture ...
[13:19:06.591] - result already collected: FutureResult
[13:19:06.591] result() for ClusterFuture ... done
[13:19:06.591] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:06.592] Future #1
[13:19:06.592] result() for ClusterFuture ...
[13:19:06.592] - result already collected: FutureResult
[13:19:06.592] result() for ClusterFuture ... done
[13:19:06.592] result() for ClusterFuture ...
[13:19:06.592] - result already collected: FutureResult
[13:19:06.592] result() for ClusterFuture ... done
[13:19:06.592] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:06.592] - nx: 2
[13:19:06.592] - relay: TRUE
[13:19:06.592] - stdout: TRUE
[13:19:06.592] - signal: TRUE
[13:19:06.593] - resignal: FALSE
[13:19:06.593] - force: TRUE
[13:19:06.593] - relayed: [n=2] FALSE, FALSE
[13:19:06.593] - queued futures: [n=2] FALSE, FALSE
[13:19:06.593]  - until=1
[13:19:06.593]  - relaying element #1
[13:19:06.593] result() for ClusterFuture ...
[13:19:06.593] - result already collected: FutureResult
[13:19:06.593] result() for ClusterFuture ... done
[13:19:06.593] result() for ClusterFuture ...
[13:19:06.593] - result already collected: FutureResult
[13:19:06.594] result() for ClusterFuture ... done
[13:19:06.594] result() for ClusterFuture ...
[13:19:06.594] - result already collected: FutureResult
[13:19:06.594] result() for ClusterFuture ... done
[13:19:06.594] result() for ClusterFuture ...
[13:19:06.594] - result already collected: FutureResult
[13:19:06.594] result() for ClusterFuture ... done
[13:19:06.594] - relayed: [n=2] TRUE, FALSE
[13:19:06.594] - queued futures: [n=2] TRUE, FALSE
[13:19:06.594] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:06.594]  length: 1 (resolved future 1)
[13:19:06.636] receiveMessageFromWorker() for ClusterFuture ...
[13:19:06.636] - Validating connection of MultisessionFuture
[13:19:06.637] - received message: FutureResult
[13:19:06.637] - Received FutureResult
[13:19:06.637] - Erased future from FutureRegistry
[13:19:06.637] result() for ClusterFuture ...
[13:19:06.637] - result already collected: FutureResult
[13:19:06.637] result() for ClusterFuture ... done
[13:19:06.637] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:06.637] Future #2
[13:19:06.637] result() for ClusterFuture ...
[13:19:06.638] - result already collected: FutureResult
[13:19:06.638] result() for ClusterFuture ... done
[13:19:06.638] result() for ClusterFuture ...
[13:19:06.638] - result already collected: FutureResult
[13:19:06.638] result() for ClusterFuture ... done
[13:19:06.638] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:06.638] - nx: 2
[13:19:06.638] - relay: TRUE
[13:19:06.638] - stdout: TRUE
[13:19:06.638] - signal: TRUE
[13:19:06.638] - resignal: FALSE
[13:19:06.638] - force: TRUE
[13:19:06.639] - relayed: [n=2] TRUE, FALSE
[13:19:06.639] - queued futures: [n=2] TRUE, FALSE
[13:19:06.639]  - until=2
[13:19:06.639]  - relaying element #2
[13:19:06.639] result() for ClusterFuture ...
[13:19:06.639] - result already collected: FutureResult
[13:19:06.639] result() for ClusterFuture ... done
[13:19:06.639] result() for ClusterFuture ...
[13:19:06.639] - result already collected: FutureResult
[13:19:06.639] result() for ClusterFuture ... done
[13:19:06.639] result() for ClusterFuture ...
[13:19:06.640] - result already collected: FutureResult
[13:19:06.640] result() for ClusterFuture ... done
[13:19:06.640] result() for ClusterFuture ...
[13:19:06.640] - result already collected: FutureResult
[13:19:06.640] result() for ClusterFuture ... done
[13:19:06.640] - relayed: [n=2] TRUE, TRUE
[13:19:06.640] - queued futures: [n=2] TRUE, TRUE
[13:19:06.640] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:06.640]  length: 0 (resolved future 2)
[13:19:06.640] Relaying remaining futures
[13:19:06.640] signalConditionsASAP(NULL, pos=0) ...
[13:19:06.641] - nx: 2
[13:19:06.641] - relay: TRUE
[13:19:06.641] - stdout: TRUE
[13:19:06.641] - signal: TRUE
[13:19:06.641] - resignal: FALSE
[13:19:06.641] - force: TRUE
[13:19:06.641] - relayed: [n=2] TRUE, TRUE
[13:19:06.641] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:06.641] - relayed: [n=2] TRUE, TRUE
[13:19:06.641] - queued futures: [n=2] TRUE, TRUE
[13:19:06.641] signalConditionsASAP(NULL, pos=0) ... done
[13:19:06.641] resolve() on list ... DONE
[13:19:06.642] result() for ClusterFuture ...
[13:19:06.642] - result already collected: FutureResult
[13:19:06.642] result() for ClusterFuture ... done
[13:19:06.642] result() for ClusterFuture ...
[13:19:06.642] - result already collected: FutureResult
[13:19:06.642] result() for ClusterFuture ... done
[13:19:06.642] result() for ClusterFuture ...
[13:19:06.642] - result already collected: FutureResult
[13:19:06.642] result() for ClusterFuture ... done
[13:19:06.642] result() for ClusterFuture ...
[13:19:06.642] - result already collected: FutureResult
[13:19:06.642] result() for ClusterFuture ... done
[13:19:06.643]  - Number of value chunks collected: 2
[13:19:06.643] Resolving 2 futures (chunks) ... DONE
[13:19:06.643] Reducing values from 2 chunks ...
[13:19:06.643]  - Number of values collected after concatenation: 11
[13:19:06.643]  - Number of values expected: 11
[13:19:06.643] Reducing values from 2 chunks ... DONE
[13:19:06.643] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:19:06.644] future_lapply() ...
[13:19:06.649] Number of chunks: 2
[13:19:06.650] getGlobalsAndPackagesXApply() ...
[13:19:06.650]  - future.globals: TRUE
[13:19:06.650] getGlobalsAndPackages() ...
[13:19:06.650] Searching for globals...
[13:19:06.653] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:06.653] Searching for globals ... DONE
[13:19:06.653] Resolving globals: FALSE
[13:19:06.654] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:19:06.654] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:06.655] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:06.655] - packages: [1] ‘future.apply’
[13:19:06.655] getGlobalsAndPackages() ... DONE
[13:19:06.655]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:06.655]  - needed namespaces: [n=1] ‘future.apply’
[13:19:06.655] Finding globals ... DONE
[13:19:06.655]  - use_args: TRUE
[13:19:06.655]  - Getting '...' globals ...
[13:19:06.656] resolve() on list ...
[13:19:06.656]  recursive: 0
[13:19:06.656]  length: 1
[13:19:06.656]  elements: ‘...’
[13:19:06.656]  length: 0 (resolved future 1)
[13:19:06.656] resolve() on list ... DONE
[13:19:06.656]    - '...' content: [n=0] 
[13:19:06.656] List of 1
[13:19:06.656]  $ ...: list()
[13:19:06.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:06.656]  - attr(*, "where")=List of 1
[13:19:06.656]   ..$ ...:<environment: 0x555f7d3acf48> 
[13:19:06.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:06.656]  - attr(*, "resolved")= logi TRUE
[13:19:06.656]  - attr(*, "total_size")= num NA
[13:19:06.659]  - Getting '...' globals ... DONE
[13:19:06.659] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:06.659] List of 8
[13:19:06.659]  $ ...future.FUN:function (x, ...)  
[13:19:06.659]  $ x_FUN        :function (x)  
[13:19:06.659]  $ times        : int 1
[13:19:06.659]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:06.659]  $ stop_if_not  :function (...)  
[13:19:06.659]  $ dim          : NULL
[13:19:06.659]  $ valid_types  : chr [1:2] "logical" "integer"
[13:19:06.659]  $ ...          : list()
[13:19:06.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:06.659]  - attr(*, "where")=List of 8
[13:19:06.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:06.659]   ..$ ...          :<environment: 0x555f7d3acf48> 
[13:19:06.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:06.659]  - attr(*, "resolved")= logi FALSE
[13:19:06.659]  - attr(*, "total_size")= num 94264
[13:19:06.664] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:06.664] getGlobalsAndPackagesXApply() ... DONE
[13:19:06.664] Number of futures (= number of chunks): 2
[13:19:06.665] Launching 2 futures (chunks) ...
[13:19:06.665] Chunk #1 of 2 ...
[13:19:06.665]  - Finding globals in 'X' for chunk #1 ...
[13:19:06.665] getGlobalsAndPackages() ...
[13:19:06.665] Searching for globals...
[13:19:06.665] 
[13:19:06.665] Searching for globals ... DONE
[13:19:06.665] - globals: [0] <none>
[13:19:06.666] getGlobalsAndPackages() ... DONE
[13:19:06.666]    + additional globals found: [n=0] 
[13:19:06.666]    + additional namespaces needed: [n=0] 
[13:19:06.666]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:06.666]  - seeds: <none>
[13:19:06.666] getGlobalsAndPackages() ...
[13:19:06.666] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.666] Resolving globals: FALSE
[13:19:06.666] Tweak future expression to call with '...' arguments ...
[13:19:06.666] {
[13:19:06.666]     do.call(function(...) {
[13:19:06.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.666]             on.exit(options(oopts), add = TRUE)
[13:19:06.666]         }
[13:19:06.666]         {
[13:19:06.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.666]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.666]             })
[13:19:06.666]         }
[13:19:06.666]     }, args = future.call.arguments)
[13:19:06.666] }
[13:19:06.667] Tweak future expression to call with '...' arguments ... DONE
[13:19:06.667] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.667] - packages: [1] ‘future.apply’
[13:19:06.667] getGlobalsAndPackages() ... DONE
[13:19:06.668] run() for ‘Future’ ...
[13:19:06.668] - state: ‘created’
[13:19:06.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:06.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:06.683]   - Field: ‘node’
[13:19:06.683]   - Field: ‘label’
[13:19:06.684]   - Field: ‘local’
[13:19:06.684]   - Field: ‘owner’
[13:19:06.684]   - Field: ‘envir’
[13:19:06.684]   - Field: ‘workers’
[13:19:06.684]   - Field: ‘packages’
[13:19:06.684]   - Field: ‘gc’
[13:19:06.684]   - Field: ‘conditions’
[13:19:06.684]   - Field: ‘persistent’
[13:19:06.684]   - Field: ‘expr’
[13:19:06.684]   - Field: ‘uuid’
[13:19:06.684]   - Field: ‘seed’
[13:19:06.685]   - Field: ‘version’
[13:19:06.685]   - Field: ‘result’
[13:19:06.685]   - Field: ‘asynchronous’
[13:19:06.685]   - Field: ‘calls’
[13:19:06.685]   - Field: ‘globals’
[13:19:06.685]   - Field: ‘stdout’
[13:19:06.685]   - Field: ‘earlySignal’
[13:19:06.685]   - Field: ‘lazy’
[13:19:06.685]   - Field: ‘state’
[13:19:06.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:06.686] - Launch lazy future ...
[13:19:06.686] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:06.686] Packages needed by future strategies (n = 0): <none>
[13:19:06.686] {
[13:19:06.686]     {
[13:19:06.686]         {
[13:19:06.686]             ...future.startTime <- base::Sys.time()
[13:19:06.686]             {
[13:19:06.686]                 {
[13:19:06.686]                   {
[13:19:06.686]                     {
[13:19:06.686]                       {
[13:19:06.686]                         base::local({
[13:19:06.686]                           has_future <- base::requireNamespace("future", 
[13:19:06.686]                             quietly = TRUE)
[13:19:06.686]                           if (has_future) {
[13:19:06.686]                             ns <- base::getNamespace("future")
[13:19:06.686]                             version <- ns[[".package"]][["version"]]
[13:19:06.686]                             if (is.null(version)) 
[13:19:06.686]                               version <- utils::packageVersion("future")
[13:19:06.686]                           }
[13:19:06.686]                           else {
[13:19:06.686]                             version <- NULL
[13:19:06.686]                           }
[13:19:06.686]                           if (!has_future || version < "1.8.0") {
[13:19:06.686]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:06.686]                               "", base::R.version$version.string), 
[13:19:06.686]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:06.686]                                 base::R.version$platform, 8 * 
[13:19:06.686]                                   base::.Machine$sizeof.pointer), 
[13:19:06.686]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:06.686]                                 "release", "version")], collapse = " "), 
[13:19:06.686]                               hostname = base::Sys.info()[["nodename"]])
[13:19:06.686]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:06.686]                               info)
[13:19:06.686]                             info <- base::paste(info, collapse = "; ")
[13:19:06.686]                             if (!has_future) {
[13:19:06.686]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:06.686]                                 info)
[13:19:06.686]                             }
[13:19:06.686]                             else {
[13:19:06.686]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:06.686]                                 info, version)
[13:19:06.686]                             }
[13:19:06.686]                             base::stop(msg)
[13:19:06.686]                           }
[13:19:06.686]                         })
[13:19:06.686]                       }
[13:19:06.686]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:06.686]                       base::options(mc.cores = 1L)
[13:19:06.686]                     }
[13:19:06.686]                     base::local({
[13:19:06.686]                       for (pkg in "future.apply") {
[13:19:06.686]                         base::loadNamespace(pkg)
[13:19:06.686]                         base::library(pkg, character.only = TRUE)
[13:19:06.686]                       }
[13:19:06.686]                     })
[13:19:06.686]                   }
[13:19:06.686]                   options(future.plan = NULL)
[13:19:06.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:06.686]                 }
[13:19:06.686]                 ...future.workdir <- getwd()
[13:19:06.686]             }
[13:19:06.686]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:06.686]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:06.686]         }
[13:19:06.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:06.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:06.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:06.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:06.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:06.686]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:06.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:06.686]             base::names(...future.oldOptions))
[13:19:06.686]     }
[13:19:06.686]     if (FALSE) {
[13:19:06.686]     }
[13:19:06.686]     else {
[13:19:06.686]         if (TRUE) {
[13:19:06.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:06.686]                 open = "w")
[13:19:06.686]         }
[13:19:06.686]         else {
[13:19:06.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:06.686]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:06.686]         }
[13:19:06.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:06.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:06.686]             base::sink(type = "output", split = FALSE)
[13:19:06.686]             base::close(...future.stdout)
[13:19:06.686]         }, add = TRUE)
[13:19:06.686]     }
[13:19:06.686]     ...future.frame <- base::sys.nframe()
[13:19:06.686]     ...future.conditions <- base::list()
[13:19:06.686]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:06.686]     if (FALSE) {
[13:19:06.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:06.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:06.686]     }
[13:19:06.686]     ...future.result <- base::tryCatch({
[13:19:06.686]         base::withCallingHandlers({
[13:19:06.686]             ...future.value <- base::withVisible(base::local({
[13:19:06.686]                 ...future.makeSendCondition <- local({
[13:19:06.686]                   sendCondition <- NULL
[13:19:06.686]                   function(frame = 1L) {
[13:19:06.686]                     if (is.function(sendCondition)) 
[13:19:06.686]                       return(sendCondition)
[13:19:06.686]                     ns <- getNamespace("parallel")
[13:19:06.686]                     if (exists("sendData", mode = "function", 
[13:19:06.686]                       envir = ns)) {
[13:19:06.686]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:06.686]                         envir = ns)
[13:19:06.686]                       envir <- sys.frame(frame)
[13:19:06.686]                       master <- NULL
[13:19:06.686]                       while (!identical(envir, .GlobalEnv) && 
[13:19:06.686]                         !identical(envir, emptyenv())) {
[13:19:06.686]                         if (exists("master", mode = "list", envir = envir, 
[13:19:06.686]                           inherits = FALSE)) {
[13:19:06.686]                           master <- get("master", mode = "list", 
[13:19:06.686]                             envir = envir, inherits = FALSE)
[13:19:06.686]                           if (inherits(master, c("SOCKnode", 
[13:19:06.686]                             "SOCK0node"))) {
[13:19:06.686]                             sendCondition <<- function(cond) {
[13:19:06.686]                               data <- list(type = "VALUE", value = cond, 
[13:19:06.686]                                 success = TRUE)
[13:19:06.686]                               parallel_sendData(master, data)
[13:19:06.686]                             }
[13:19:06.686]                             return(sendCondition)
[13:19:06.686]                           }
[13:19:06.686]                         }
[13:19:06.686]                         frame <- frame + 1L
[13:19:06.686]                         envir <- sys.frame(frame)
[13:19:06.686]                       }
[13:19:06.686]                     }
[13:19:06.686]                     sendCondition <<- function(cond) NULL
[13:19:06.686]                   }
[13:19:06.686]                 })
[13:19:06.686]                 withCallingHandlers({
[13:19:06.686]                   {
[13:19:06.686]                     do.call(function(...) {
[13:19:06.686]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.686]                       if (!identical(...future.globals.maxSize.org, 
[13:19:06.686]                         ...future.globals.maxSize)) {
[13:19:06.686]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.686]                         on.exit(options(oopts), add = TRUE)
[13:19:06.686]                       }
[13:19:06.686]                       {
[13:19:06.686]                         lapply(seq_along(...future.elements_ii), 
[13:19:06.686]                           FUN = function(jj) {
[13:19:06.686]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.686]                             ...future.FUN(...future.X_jj, ...)
[13:19:06.686]                           })
[13:19:06.686]                       }
[13:19:06.686]                     }, args = future.call.arguments)
[13:19:06.686]                   }
[13:19:06.686]                 }, immediateCondition = function(cond) {
[13:19:06.686]                   sendCondition <- ...future.makeSendCondition()
[13:19:06.686]                   sendCondition(cond)
[13:19:06.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.686]                   {
[13:19:06.686]                     inherits <- base::inherits
[13:19:06.686]                     invokeRestart <- base::invokeRestart
[13:19:06.686]                     is.null <- base::is.null
[13:19:06.686]                     muffled <- FALSE
[13:19:06.686]                     if (inherits(cond, "message")) {
[13:19:06.686]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:06.686]                       if (muffled) 
[13:19:06.686]                         invokeRestart("muffleMessage")
[13:19:06.686]                     }
[13:19:06.686]                     else if (inherits(cond, "warning")) {
[13:19:06.686]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:06.686]                       if (muffled) 
[13:19:06.686]                         invokeRestart("muffleWarning")
[13:19:06.686]                     }
[13:19:06.686]                     else if (inherits(cond, "condition")) {
[13:19:06.686]                       if (!is.null(pattern)) {
[13:19:06.686]                         computeRestarts <- base::computeRestarts
[13:19:06.686]                         grepl <- base::grepl
[13:19:06.686]                         restarts <- computeRestarts(cond)
[13:19:06.686]                         for (restart in restarts) {
[13:19:06.686]                           name <- restart$name
[13:19:06.686]                           if (is.null(name)) 
[13:19:06.686]                             next
[13:19:06.686]                           if (!grepl(pattern, name)) 
[13:19:06.686]                             next
[13:19:06.686]                           invokeRestart(restart)
[13:19:06.686]                           muffled <- TRUE
[13:19:06.686]                           break
[13:19:06.686]                         }
[13:19:06.686]                       }
[13:19:06.686]                     }
[13:19:06.686]                     invisible(muffled)
[13:19:06.686]                   }
[13:19:06.686]                   muffleCondition(cond)
[13:19:06.686]                 })
[13:19:06.686]             }))
[13:19:06.686]             future::FutureResult(value = ...future.value$value, 
[13:19:06.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.686]                   ...future.rng), globalenv = if (FALSE) 
[13:19:06.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:06.686]                     ...future.globalenv.names))
[13:19:06.686]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:06.686]         }, condition = base::local({
[13:19:06.686]             c <- base::c
[13:19:06.686]             inherits <- base::inherits
[13:19:06.686]             invokeRestart <- base::invokeRestart
[13:19:06.686]             length <- base::length
[13:19:06.686]             list <- base::list
[13:19:06.686]             seq.int <- base::seq.int
[13:19:06.686]             signalCondition <- base::signalCondition
[13:19:06.686]             sys.calls <- base::sys.calls
[13:19:06.686]             `[[` <- base::`[[`
[13:19:06.686]             `+` <- base::`+`
[13:19:06.686]             `<<-` <- base::`<<-`
[13:19:06.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:06.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:06.686]                   3L)]
[13:19:06.686]             }
[13:19:06.686]             function(cond) {
[13:19:06.686]                 is_error <- inherits(cond, "error")
[13:19:06.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:06.686]                   NULL)
[13:19:06.686]                 if (is_error) {
[13:19:06.686]                   sessionInformation <- function() {
[13:19:06.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:06.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:06.686]                       search = base::search(), system = base::Sys.info())
[13:19:06.686]                   }
[13:19:06.686]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:06.686]                     cond$call), session = sessionInformation(), 
[13:19:06.686]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:06.686]                   signalCondition(cond)
[13:19:06.686]                 }
[13:19:06.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:06.686]                 "immediateCondition"))) {
[13:19:06.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:06.686]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:06.686]                   if (TRUE && !signal) {
[13:19:06.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.686]                     {
[13:19:06.686]                       inherits <- base::inherits
[13:19:06.686]                       invokeRestart <- base::invokeRestart
[13:19:06.686]                       is.null <- base::is.null
[13:19:06.686]                       muffled <- FALSE
[13:19:06.686]                       if (inherits(cond, "message")) {
[13:19:06.686]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.686]                         if (muffled) 
[13:19:06.686]                           invokeRestart("muffleMessage")
[13:19:06.686]                       }
[13:19:06.686]                       else if (inherits(cond, "warning")) {
[13:19:06.686]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.686]                         if (muffled) 
[13:19:06.686]                           invokeRestart("muffleWarning")
[13:19:06.686]                       }
[13:19:06.686]                       else if (inherits(cond, "condition")) {
[13:19:06.686]                         if (!is.null(pattern)) {
[13:19:06.686]                           computeRestarts <- base::computeRestarts
[13:19:06.686]                           grepl <- base::grepl
[13:19:06.686]                           restarts <- computeRestarts(cond)
[13:19:06.686]                           for (restart in restarts) {
[13:19:06.686]                             name <- restart$name
[13:19:06.686]                             if (is.null(name)) 
[13:19:06.686]                               next
[13:19:06.686]                             if (!grepl(pattern, name)) 
[13:19:06.686]                               next
[13:19:06.686]                             invokeRestart(restart)
[13:19:06.686]                             muffled <- TRUE
[13:19:06.686]                             break
[13:19:06.686]                           }
[13:19:06.686]                         }
[13:19:06.686]                       }
[13:19:06.686]                       invisible(muffled)
[13:19:06.686]                     }
[13:19:06.686]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.686]                   }
[13:19:06.686]                 }
[13:19:06.686]                 else {
[13:19:06.686]                   if (TRUE) {
[13:19:06.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.686]                     {
[13:19:06.686]                       inherits <- base::inherits
[13:19:06.686]                       invokeRestart <- base::invokeRestart
[13:19:06.686]                       is.null <- base::is.null
[13:19:06.686]                       muffled <- FALSE
[13:19:06.686]                       if (inherits(cond, "message")) {
[13:19:06.686]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.686]                         if (muffled) 
[13:19:06.686]                           invokeRestart("muffleMessage")
[13:19:06.686]                       }
[13:19:06.686]                       else if (inherits(cond, "warning")) {
[13:19:06.686]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.686]                         if (muffled) 
[13:19:06.686]                           invokeRestart("muffleWarning")
[13:19:06.686]                       }
[13:19:06.686]                       else if (inherits(cond, "condition")) {
[13:19:06.686]                         if (!is.null(pattern)) {
[13:19:06.686]                           computeRestarts <- base::computeRestarts
[13:19:06.686]                           grepl <- base::grepl
[13:19:06.686]                           restarts <- computeRestarts(cond)
[13:19:06.686]                           for (restart in restarts) {
[13:19:06.686]                             name <- restart$name
[13:19:06.686]                             if (is.null(name)) 
[13:19:06.686]                               next
[13:19:06.686]                             if (!grepl(pattern, name)) 
[13:19:06.686]                               next
[13:19:06.686]                             invokeRestart(restart)
[13:19:06.686]                             muffled <- TRUE
[13:19:06.686]                             break
[13:19:06.686]                           }
[13:19:06.686]                         }
[13:19:06.686]                       }
[13:19:06.686]                       invisible(muffled)
[13:19:06.686]                     }
[13:19:06.686]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.686]                   }
[13:19:06.686]                 }
[13:19:06.686]             }
[13:19:06.686]         }))
[13:19:06.686]     }, error = function(ex) {
[13:19:06.686]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:06.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.686]                 ...future.rng), started = ...future.startTime, 
[13:19:06.686]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:06.686]             version = "1.8"), class = "FutureResult")
[13:19:06.686]     }, finally = {
[13:19:06.686]         if (!identical(...future.workdir, getwd())) 
[13:19:06.686]             setwd(...future.workdir)
[13:19:06.686]         {
[13:19:06.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:06.686]                 ...future.oldOptions$nwarnings <- NULL
[13:19:06.686]             }
[13:19:06.686]             base::options(...future.oldOptions)
[13:19:06.686]             if (.Platform$OS.type == "windows") {
[13:19:06.686]                 old_names <- names(...future.oldEnvVars)
[13:19:06.686]                 envs <- base::Sys.getenv()
[13:19:06.686]                 names <- names(envs)
[13:19:06.686]                 common <- intersect(names, old_names)
[13:19:06.686]                 added <- setdiff(names, old_names)
[13:19:06.686]                 removed <- setdiff(old_names, names)
[13:19:06.686]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:06.686]                   envs[common]]
[13:19:06.686]                 NAMES <- toupper(changed)
[13:19:06.686]                 args <- list()
[13:19:06.686]                 for (kk in seq_along(NAMES)) {
[13:19:06.686]                   name <- changed[[kk]]
[13:19:06.686]                   NAME <- NAMES[[kk]]
[13:19:06.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.686]                     next
[13:19:06.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.686]                 }
[13:19:06.686]                 NAMES <- toupper(added)
[13:19:06.686]                 for (kk in seq_along(NAMES)) {
[13:19:06.686]                   name <- added[[kk]]
[13:19:06.686]                   NAME <- NAMES[[kk]]
[13:19:06.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.686]                     next
[13:19:06.686]                   args[[name]] <- ""
[13:19:06.686]                 }
[13:19:06.686]                 NAMES <- toupper(removed)
[13:19:06.686]                 for (kk in seq_along(NAMES)) {
[13:19:06.686]                   name <- removed[[kk]]
[13:19:06.686]                   NAME <- NAMES[[kk]]
[13:19:06.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.686]                     next
[13:19:06.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.686]                 }
[13:19:06.686]                 if (length(args) > 0) 
[13:19:06.686]                   base::do.call(base::Sys.setenv, args = args)
[13:19:06.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:06.686]             }
[13:19:06.686]             else {
[13:19:06.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:06.686]             }
[13:19:06.686]             {
[13:19:06.686]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:06.686]                   0L) {
[13:19:06.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:06.686]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:06.686]                   base::options(opts)
[13:19:06.686]                 }
[13:19:06.686]                 {
[13:19:06.686]                   {
[13:19:06.686]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:06.686]                     NULL
[13:19:06.686]                   }
[13:19:06.686]                   options(future.plan = NULL)
[13:19:06.686]                   if (is.na(NA_character_)) 
[13:19:06.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:06.686]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:06.686]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:06.686]                     envir = parent.frame()) 
[13:19:06.686]                   {
[13:19:06.686]                     if (is.function(workers)) 
[13:19:06.686]                       workers <- workers()
[13:19:06.686]                     workers <- structure(as.integer(workers), 
[13:19:06.686]                       class = class(workers))
[13:19:06.686]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:06.686]                       workers >= 1)
[13:19:06.686]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:06.686]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:06.686]                     }
[13:19:06.686]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:06.686]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:06.686]                       envir = envir)
[13:19:06.686]                     if (!future$lazy) 
[13:19:06.686]                       future <- run(future)
[13:19:06.686]                     invisible(future)
[13:19:06.686]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:06.686]                 }
[13:19:06.686]             }
[13:19:06.686]         }
[13:19:06.686]     })
[13:19:06.686]     if (TRUE) {
[13:19:06.686]         base::sink(type = "output", split = FALSE)
[13:19:06.686]         if (TRUE) {
[13:19:06.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:06.686]         }
[13:19:06.686]         else {
[13:19:06.686]             ...future.result["stdout"] <- base::list(NULL)
[13:19:06.686]         }
[13:19:06.686]         base::close(...future.stdout)
[13:19:06.686]         ...future.stdout <- NULL
[13:19:06.686]     }
[13:19:06.686]     ...future.result$conditions <- ...future.conditions
[13:19:06.686]     ...future.result$finished <- base::Sys.time()
[13:19:06.686]     ...future.result
[13:19:06.686] }
[13:19:06.689] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[13:19:06.690] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:06.733] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:06.733] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:19:06.734] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:19:06.734] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:06.734] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:06.734] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:06.777] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:06.777] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:06.821] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:06.821] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:06.822] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.822] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:19:06.822] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:19:06.823] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:06.823] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.823] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:19:06.824] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:06.824] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:06.824] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.824] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:06.825] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:06.825] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[13:19:06.825] MultisessionFuture started
[13:19:06.825] - Launch lazy future ... done
[13:19:06.825] run() for ‘MultisessionFuture’ ... done
[13:19:06.826] Created future:
[13:19:06.826] MultisessionFuture:
[13:19:06.826] Label: ‘future_vapply-1’
[13:19:06.826] Expression:
[13:19:06.826] {
[13:19:06.826]     do.call(function(...) {
[13:19:06.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.826]             on.exit(options(oopts), add = TRUE)
[13:19:06.826]         }
[13:19:06.826]         {
[13:19:06.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.826]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.826]             })
[13:19:06.826]         }
[13:19:06.826]     }, args = future.call.arguments)
[13:19:06.826] }
[13:19:06.826] Lazy evaluation: FALSE
[13:19:06.826] Asynchronous evaluation: TRUE
[13:19:06.826] Local evaluation: TRUE
[13:19:06.826] Environment: R_GlobalEnv
[13:19:06.826] Capture standard output: TRUE
[13:19:06.826] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:06.826] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:06.826] Packages: 1 packages (‘future.apply’)
[13:19:06.826] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:06.826] Resolved: FALSE
[13:19:06.826] Value: <not collected>
[13:19:06.826] Conditions captured: <none>
[13:19:06.826] Early signaling: FALSE
[13:19:06.826] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:06.826] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.838] Chunk #1 of 2 ... DONE
[13:19:06.838] Chunk #2 of 2 ...
[13:19:06.838]  - Finding globals in 'X' for chunk #2 ...
[13:19:06.838] getGlobalsAndPackages() ...
[13:19:06.838] Searching for globals...
[13:19:06.838] 
[13:19:06.838] Searching for globals ... DONE
[13:19:06.839] - globals: [0] <none>
[13:19:06.839] getGlobalsAndPackages() ... DONE
[13:19:06.839]    + additional globals found: [n=0] 
[13:19:06.839]    + additional namespaces needed: [n=0] 
[13:19:06.839]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:06.839]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:06.839]  - seeds: <none>
[13:19:06.839] getGlobalsAndPackages() ...
[13:19:06.839] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.839] Resolving globals: FALSE
[13:19:06.840] Tweak future expression to call with '...' arguments ...
[13:19:06.840] {
[13:19:06.840]     do.call(function(...) {
[13:19:06.840]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.840]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:06.840]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.840]             on.exit(options(oopts), add = TRUE)
[13:19:06.840]         }
[13:19:06.840]         {
[13:19:06.840]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:06.840]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.840]                 ...future.FUN(...future.X_jj, ...)
[13:19:06.840]             })
[13:19:06.840]         }
[13:19:06.840]     }, args = future.call.arguments)
[13:19:06.840] }
[13:19:06.840] Tweak future expression to call with '...' arguments ... DONE
[13:19:06.841] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:06.841] - packages: [1] ‘future.apply’
[13:19:06.841] getGlobalsAndPackages() ... DONE
[13:19:06.841] run() for ‘Future’ ...
[13:19:06.841] - state: ‘created’
[13:19:06.841] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:06.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:06.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:06.857]   - Field: ‘node’
[13:19:06.857]   - Field: ‘label’
[13:19:06.857]   - Field: ‘local’
[13:19:06.857]   - Field: ‘owner’
[13:19:06.857]   - Field: ‘envir’
[13:19:06.857]   - Field: ‘workers’
[13:19:06.857]   - Field: ‘packages’
[13:19:06.857]   - Field: ‘gc’
[13:19:06.858]   - Field: ‘conditions’
[13:19:06.858]   - Field: ‘persistent’
[13:19:06.858]   - Field: ‘expr’
[13:19:06.858]   - Field: ‘uuid’
[13:19:06.858]   - Field: ‘seed’
[13:19:06.858]   - Field: ‘version’
[13:19:06.858]   - Field: ‘result’
[13:19:06.858]   - Field: ‘asynchronous’
[13:19:06.858]   - Field: ‘calls’
[13:19:06.858]   - Field: ‘globals’
[13:19:06.858]   - Field: ‘stdout’
[13:19:06.859]   - Field: ‘earlySignal’
[13:19:06.859]   - Field: ‘lazy’
[13:19:06.859]   - Field: ‘state’
[13:19:06.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:06.859] - Launch lazy future ...
[13:19:06.859] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:06.859] Packages needed by future strategies (n = 0): <none>
[13:19:06.860] {
[13:19:06.860]     {
[13:19:06.860]         {
[13:19:06.860]             ...future.startTime <- base::Sys.time()
[13:19:06.860]             {
[13:19:06.860]                 {
[13:19:06.860]                   {
[13:19:06.860]                     {
[13:19:06.860]                       {
[13:19:06.860]                         base::local({
[13:19:06.860]                           has_future <- base::requireNamespace("future", 
[13:19:06.860]                             quietly = TRUE)
[13:19:06.860]                           if (has_future) {
[13:19:06.860]                             ns <- base::getNamespace("future")
[13:19:06.860]                             version <- ns[[".package"]][["version"]]
[13:19:06.860]                             if (is.null(version)) 
[13:19:06.860]                               version <- utils::packageVersion("future")
[13:19:06.860]                           }
[13:19:06.860]                           else {
[13:19:06.860]                             version <- NULL
[13:19:06.860]                           }
[13:19:06.860]                           if (!has_future || version < "1.8.0") {
[13:19:06.860]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:06.860]                               "", base::R.version$version.string), 
[13:19:06.860]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:06.860]                                 base::R.version$platform, 8 * 
[13:19:06.860]                                   base::.Machine$sizeof.pointer), 
[13:19:06.860]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:06.860]                                 "release", "version")], collapse = " "), 
[13:19:06.860]                               hostname = base::Sys.info()[["nodename"]])
[13:19:06.860]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:06.860]                               info)
[13:19:06.860]                             info <- base::paste(info, collapse = "; ")
[13:19:06.860]                             if (!has_future) {
[13:19:06.860]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:06.860]                                 info)
[13:19:06.860]                             }
[13:19:06.860]                             else {
[13:19:06.860]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:06.860]                                 info, version)
[13:19:06.860]                             }
[13:19:06.860]                             base::stop(msg)
[13:19:06.860]                           }
[13:19:06.860]                         })
[13:19:06.860]                       }
[13:19:06.860]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:06.860]                       base::options(mc.cores = 1L)
[13:19:06.860]                     }
[13:19:06.860]                     base::local({
[13:19:06.860]                       for (pkg in "future.apply") {
[13:19:06.860]                         base::loadNamespace(pkg)
[13:19:06.860]                         base::library(pkg, character.only = TRUE)
[13:19:06.860]                       }
[13:19:06.860]                     })
[13:19:06.860]                   }
[13:19:06.860]                   options(future.plan = NULL)
[13:19:06.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:06.860]                 }
[13:19:06.860]                 ...future.workdir <- getwd()
[13:19:06.860]             }
[13:19:06.860]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:06.860]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:06.860]         }
[13:19:06.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:06.860]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:06.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:06.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:06.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:06.860]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:06.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:06.860]             base::names(...future.oldOptions))
[13:19:06.860]     }
[13:19:06.860]     if (FALSE) {
[13:19:06.860]     }
[13:19:06.860]     else {
[13:19:06.860]         if (TRUE) {
[13:19:06.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:06.860]                 open = "w")
[13:19:06.860]         }
[13:19:06.860]         else {
[13:19:06.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:06.860]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:06.860]         }
[13:19:06.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:06.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:06.860]             base::sink(type = "output", split = FALSE)
[13:19:06.860]             base::close(...future.stdout)
[13:19:06.860]         }, add = TRUE)
[13:19:06.860]     }
[13:19:06.860]     ...future.frame <- base::sys.nframe()
[13:19:06.860]     ...future.conditions <- base::list()
[13:19:06.860]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:06.860]     if (FALSE) {
[13:19:06.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:06.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:06.860]     }
[13:19:06.860]     ...future.result <- base::tryCatch({
[13:19:06.860]         base::withCallingHandlers({
[13:19:06.860]             ...future.value <- base::withVisible(base::local({
[13:19:06.860]                 ...future.makeSendCondition <- local({
[13:19:06.860]                   sendCondition <- NULL
[13:19:06.860]                   function(frame = 1L) {
[13:19:06.860]                     if (is.function(sendCondition)) 
[13:19:06.860]                       return(sendCondition)
[13:19:06.860]                     ns <- getNamespace("parallel")
[13:19:06.860]                     if (exists("sendData", mode = "function", 
[13:19:06.860]                       envir = ns)) {
[13:19:06.860]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:06.860]                         envir = ns)
[13:19:06.860]                       envir <- sys.frame(frame)
[13:19:06.860]                       master <- NULL
[13:19:06.860]                       while (!identical(envir, .GlobalEnv) && 
[13:19:06.860]                         !identical(envir, emptyenv())) {
[13:19:06.860]                         if (exists("master", mode = "list", envir = envir, 
[13:19:06.860]                           inherits = FALSE)) {
[13:19:06.860]                           master <- get("master", mode = "list", 
[13:19:06.860]                             envir = envir, inherits = FALSE)
[13:19:06.860]                           if (inherits(master, c("SOCKnode", 
[13:19:06.860]                             "SOCK0node"))) {
[13:19:06.860]                             sendCondition <<- function(cond) {
[13:19:06.860]                               data <- list(type = "VALUE", value = cond, 
[13:19:06.860]                                 success = TRUE)
[13:19:06.860]                               parallel_sendData(master, data)
[13:19:06.860]                             }
[13:19:06.860]                             return(sendCondition)
[13:19:06.860]                           }
[13:19:06.860]                         }
[13:19:06.860]                         frame <- frame + 1L
[13:19:06.860]                         envir <- sys.frame(frame)
[13:19:06.860]                       }
[13:19:06.860]                     }
[13:19:06.860]                     sendCondition <<- function(cond) NULL
[13:19:06.860]                   }
[13:19:06.860]                 })
[13:19:06.860]                 withCallingHandlers({
[13:19:06.860]                   {
[13:19:06.860]                     do.call(function(...) {
[13:19:06.860]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:06.860]                       if (!identical(...future.globals.maxSize.org, 
[13:19:06.860]                         ...future.globals.maxSize)) {
[13:19:06.860]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:06.860]                         on.exit(options(oopts), add = TRUE)
[13:19:06.860]                       }
[13:19:06.860]                       {
[13:19:06.860]                         lapply(seq_along(...future.elements_ii), 
[13:19:06.860]                           FUN = function(jj) {
[13:19:06.860]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:06.860]                             ...future.FUN(...future.X_jj, ...)
[13:19:06.860]                           })
[13:19:06.860]                       }
[13:19:06.860]                     }, args = future.call.arguments)
[13:19:06.860]                   }
[13:19:06.860]                 }, immediateCondition = function(cond) {
[13:19:06.860]                   sendCondition <- ...future.makeSendCondition()
[13:19:06.860]                   sendCondition(cond)
[13:19:06.860]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.860]                   {
[13:19:06.860]                     inherits <- base::inherits
[13:19:06.860]                     invokeRestart <- base::invokeRestart
[13:19:06.860]                     is.null <- base::is.null
[13:19:06.860]                     muffled <- FALSE
[13:19:06.860]                     if (inherits(cond, "message")) {
[13:19:06.860]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:06.860]                       if (muffled) 
[13:19:06.860]                         invokeRestart("muffleMessage")
[13:19:06.860]                     }
[13:19:06.860]                     else if (inherits(cond, "warning")) {
[13:19:06.860]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:06.860]                       if (muffled) 
[13:19:06.860]                         invokeRestart("muffleWarning")
[13:19:06.860]                     }
[13:19:06.860]                     else if (inherits(cond, "condition")) {
[13:19:06.860]                       if (!is.null(pattern)) {
[13:19:06.860]                         computeRestarts <- base::computeRestarts
[13:19:06.860]                         grepl <- base::grepl
[13:19:06.860]                         restarts <- computeRestarts(cond)
[13:19:06.860]                         for (restart in restarts) {
[13:19:06.860]                           name <- restart$name
[13:19:06.860]                           if (is.null(name)) 
[13:19:06.860]                             next
[13:19:06.860]                           if (!grepl(pattern, name)) 
[13:19:06.860]                             next
[13:19:06.860]                           invokeRestart(restart)
[13:19:06.860]                           muffled <- TRUE
[13:19:06.860]                           break
[13:19:06.860]                         }
[13:19:06.860]                       }
[13:19:06.860]                     }
[13:19:06.860]                     invisible(muffled)
[13:19:06.860]                   }
[13:19:06.860]                   muffleCondition(cond)
[13:19:06.860]                 })
[13:19:06.860]             }))
[13:19:06.860]             future::FutureResult(value = ...future.value$value, 
[13:19:06.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.860]                   ...future.rng), globalenv = if (FALSE) 
[13:19:06.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:06.860]                     ...future.globalenv.names))
[13:19:06.860]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:06.860]         }, condition = base::local({
[13:19:06.860]             c <- base::c
[13:19:06.860]             inherits <- base::inherits
[13:19:06.860]             invokeRestart <- base::invokeRestart
[13:19:06.860]             length <- base::length
[13:19:06.860]             list <- base::list
[13:19:06.860]             seq.int <- base::seq.int
[13:19:06.860]             signalCondition <- base::signalCondition
[13:19:06.860]             sys.calls <- base::sys.calls
[13:19:06.860]             `[[` <- base::`[[`
[13:19:06.860]             `+` <- base::`+`
[13:19:06.860]             `<<-` <- base::`<<-`
[13:19:06.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:06.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:06.860]                   3L)]
[13:19:06.860]             }
[13:19:06.860]             function(cond) {
[13:19:06.860]                 is_error <- inherits(cond, "error")
[13:19:06.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:06.860]                   NULL)
[13:19:06.860]                 if (is_error) {
[13:19:06.860]                   sessionInformation <- function() {
[13:19:06.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:06.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:06.860]                       search = base::search(), system = base::Sys.info())
[13:19:06.860]                   }
[13:19:06.860]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:06.860]                     cond$call), session = sessionInformation(), 
[13:19:06.860]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:06.860]                   signalCondition(cond)
[13:19:06.860]                 }
[13:19:06.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:06.860]                 "immediateCondition"))) {
[13:19:06.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:06.860]                   ...future.conditions[[length(...future.conditions) + 
[13:19:06.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:06.860]                   if (TRUE && !signal) {
[13:19:06.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.860]                     {
[13:19:06.860]                       inherits <- base::inherits
[13:19:06.860]                       invokeRestart <- base::invokeRestart
[13:19:06.860]                       is.null <- base::is.null
[13:19:06.860]                       muffled <- FALSE
[13:19:06.860]                       if (inherits(cond, "message")) {
[13:19:06.860]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.860]                         if (muffled) 
[13:19:06.860]                           invokeRestart("muffleMessage")
[13:19:06.860]                       }
[13:19:06.860]                       else if (inherits(cond, "warning")) {
[13:19:06.860]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.860]                         if (muffled) 
[13:19:06.860]                           invokeRestart("muffleWarning")
[13:19:06.860]                       }
[13:19:06.860]                       else if (inherits(cond, "condition")) {
[13:19:06.860]                         if (!is.null(pattern)) {
[13:19:06.860]                           computeRestarts <- base::computeRestarts
[13:19:06.860]                           grepl <- base::grepl
[13:19:06.860]                           restarts <- computeRestarts(cond)
[13:19:06.860]                           for (restart in restarts) {
[13:19:06.860]                             name <- restart$name
[13:19:06.860]                             if (is.null(name)) 
[13:19:06.860]                               next
[13:19:06.860]                             if (!grepl(pattern, name)) 
[13:19:06.860]                               next
[13:19:06.860]                             invokeRestart(restart)
[13:19:06.860]                             muffled <- TRUE
[13:19:06.860]                             break
[13:19:06.860]                           }
[13:19:06.860]                         }
[13:19:06.860]                       }
[13:19:06.860]                       invisible(muffled)
[13:19:06.860]                     }
[13:19:06.860]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.860]                   }
[13:19:06.860]                 }
[13:19:06.860]                 else {
[13:19:06.860]                   if (TRUE) {
[13:19:06.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:06.860]                     {
[13:19:06.860]                       inherits <- base::inherits
[13:19:06.860]                       invokeRestart <- base::invokeRestart
[13:19:06.860]                       is.null <- base::is.null
[13:19:06.860]                       muffled <- FALSE
[13:19:06.860]                       if (inherits(cond, "message")) {
[13:19:06.860]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:06.860]                         if (muffled) 
[13:19:06.860]                           invokeRestart("muffleMessage")
[13:19:06.860]                       }
[13:19:06.860]                       else if (inherits(cond, "warning")) {
[13:19:06.860]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:06.860]                         if (muffled) 
[13:19:06.860]                           invokeRestart("muffleWarning")
[13:19:06.860]                       }
[13:19:06.860]                       else if (inherits(cond, "condition")) {
[13:19:06.860]                         if (!is.null(pattern)) {
[13:19:06.860]                           computeRestarts <- base::computeRestarts
[13:19:06.860]                           grepl <- base::grepl
[13:19:06.860]                           restarts <- computeRestarts(cond)
[13:19:06.860]                           for (restart in restarts) {
[13:19:06.860]                             name <- restart$name
[13:19:06.860]                             if (is.null(name)) 
[13:19:06.860]                               next
[13:19:06.860]                             if (!grepl(pattern, name)) 
[13:19:06.860]                               next
[13:19:06.860]                             invokeRestart(restart)
[13:19:06.860]                             muffled <- TRUE
[13:19:06.860]                             break
[13:19:06.860]                           }
[13:19:06.860]                         }
[13:19:06.860]                       }
[13:19:06.860]                       invisible(muffled)
[13:19:06.860]                     }
[13:19:06.860]                     muffleCondition(cond, pattern = "^muffle")
[13:19:06.860]                   }
[13:19:06.860]                 }
[13:19:06.860]             }
[13:19:06.860]         }))
[13:19:06.860]     }, error = function(ex) {
[13:19:06.860]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:06.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:06.860]                 ...future.rng), started = ...future.startTime, 
[13:19:06.860]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:06.860]             version = "1.8"), class = "FutureResult")
[13:19:06.860]     }, finally = {
[13:19:06.860]         if (!identical(...future.workdir, getwd())) 
[13:19:06.860]             setwd(...future.workdir)
[13:19:06.860]         {
[13:19:06.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:06.860]                 ...future.oldOptions$nwarnings <- NULL
[13:19:06.860]             }
[13:19:06.860]             base::options(...future.oldOptions)
[13:19:06.860]             if (.Platform$OS.type == "windows") {
[13:19:06.860]                 old_names <- names(...future.oldEnvVars)
[13:19:06.860]                 envs <- base::Sys.getenv()
[13:19:06.860]                 names <- names(envs)
[13:19:06.860]                 common <- intersect(names, old_names)
[13:19:06.860]                 added <- setdiff(names, old_names)
[13:19:06.860]                 removed <- setdiff(old_names, names)
[13:19:06.860]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:06.860]                   envs[common]]
[13:19:06.860]                 NAMES <- toupper(changed)
[13:19:06.860]                 args <- list()
[13:19:06.860]                 for (kk in seq_along(NAMES)) {
[13:19:06.860]                   name <- changed[[kk]]
[13:19:06.860]                   NAME <- NAMES[[kk]]
[13:19:06.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.860]                     next
[13:19:06.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.860]                 }
[13:19:06.860]                 NAMES <- toupper(added)
[13:19:06.860]                 for (kk in seq_along(NAMES)) {
[13:19:06.860]                   name <- added[[kk]]
[13:19:06.860]                   NAME <- NAMES[[kk]]
[13:19:06.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.860]                     next
[13:19:06.860]                   args[[name]] <- ""
[13:19:06.860]                 }
[13:19:06.860]                 NAMES <- toupper(removed)
[13:19:06.860]                 for (kk in seq_along(NAMES)) {
[13:19:06.860]                   name <- removed[[kk]]
[13:19:06.860]                   NAME <- NAMES[[kk]]
[13:19:06.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:06.860]                     next
[13:19:06.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:06.860]                 }
[13:19:06.860]                 if (length(args) > 0) 
[13:19:06.860]                   base::do.call(base::Sys.setenv, args = args)
[13:19:06.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:06.860]             }
[13:19:06.860]             else {
[13:19:06.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:06.860]             }
[13:19:06.860]             {
[13:19:06.860]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:06.860]                   0L) {
[13:19:06.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:06.860]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:06.860]                   base::options(opts)
[13:19:06.860]                 }
[13:19:06.860]                 {
[13:19:06.860]                   {
[13:19:06.860]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:06.860]                     NULL
[13:19:06.860]                   }
[13:19:06.860]                   options(future.plan = NULL)
[13:19:06.860]                   if (is.na(NA_character_)) 
[13:19:06.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:06.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:06.860]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:06.860]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:06.860]                     envir = parent.frame()) 
[13:19:06.860]                   {
[13:19:06.860]                     if (is.function(workers)) 
[13:19:06.860]                       workers <- workers()
[13:19:06.860]                     workers <- structure(as.integer(workers), 
[13:19:06.860]                       class = class(workers))
[13:19:06.860]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:06.860]                       workers >= 1)
[13:19:06.860]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:06.860]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:06.860]                     }
[13:19:06.860]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:06.860]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:06.860]                       envir = envir)
[13:19:06.860]                     if (!future$lazy) 
[13:19:06.860]                       future <- run(future)
[13:19:06.860]                     invisible(future)
[13:19:06.860]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:06.860]                 }
[13:19:06.860]             }
[13:19:06.860]         }
[13:19:06.860]     })
[13:19:06.860]     if (TRUE) {
[13:19:06.860]         base::sink(type = "output", split = FALSE)
[13:19:06.860]         if (TRUE) {
[13:19:06.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:06.860]         }
[13:19:06.860]         else {
[13:19:06.860]             ...future.result["stdout"] <- base::list(NULL)
[13:19:06.860]         }
[13:19:06.860]         base::close(...future.stdout)
[13:19:06.860]         ...future.stdout <- NULL
[13:19:06.860]     }
[13:19:06.860]     ...future.result$conditions <- ...future.conditions
[13:19:06.860]     ...future.result$finished <- base::Sys.time()
[13:19:06.860]     ...future.result
[13:19:06.860] }
[13:19:06.863] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[13:19:06.863] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:06.909] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:06.909] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:19:06.910] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:19:06.910] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:06.910] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:06.910] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:06.953] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:06.953] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:06.997] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:06.997] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:06.998] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.998] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:19:06.998] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:19:06.998] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:06.999] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:06.999] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:06.999] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:06.999] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:07.000] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:07.000] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:07.000] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:07.000] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[13:19:07.001] MultisessionFuture started
[13:19:07.001] - Launch lazy future ... done
[13:19:07.001] run() for ‘MultisessionFuture’ ... done
[13:19:07.002] Created future:
[13:19:07.002] MultisessionFuture:
[13:19:07.002] Label: ‘future_vapply-2’
[13:19:07.002] Expression:
[13:19:07.002] {
[13:19:07.002]     do.call(function(...) {
[13:19:07.002]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.002]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:07.002]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.002]             on.exit(options(oopts), add = TRUE)
[13:19:07.002]         }
[13:19:07.002]         {
[13:19:07.002]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:07.002]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.002]                 ...future.FUN(...future.X_jj, ...)
[13:19:07.002]             })
[13:19:07.002]         }
[13:19:07.002]     }, args = future.call.arguments)
[13:19:07.002] }
[13:19:07.002] Lazy evaluation: FALSE
[13:19:07.002] Asynchronous evaluation: TRUE
[13:19:07.002] Local evaluation: TRUE
[13:19:07.002] Environment: R_GlobalEnv
[13:19:07.002] Capture standard output: TRUE
[13:19:07.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:07.002] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:07.002] Packages: 1 packages (‘future.apply’)
[13:19:07.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:07.002] Resolved: FALSE
[13:19:07.002] Value: <not collected>
[13:19:07.002] Conditions captured: <none>
[13:19:07.002] Early signaling: FALSE
[13:19:07.002] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:07.002] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:07.016] Chunk #2 of 2 ... DONE
[13:19:07.016] Launching 2 futures (chunks) ... DONE
[13:19:07.016] Resolving 2 futures (chunks) ...
[13:19:07.016] resolve() on list ...
[13:19:07.016]  recursive: 0
[13:19:07.016]  length: 2
[13:19:07.016] 
[13:19:07.017] receiveMessageFromWorker() for ClusterFuture ...
[13:19:07.017] - Validating connection of MultisessionFuture
[13:19:07.017] - received message: FutureResult
[13:19:07.017] - Received FutureResult
[13:19:07.017] - Erased future from FutureRegistry
[13:19:07.018] result() for ClusterFuture ...
[13:19:07.018] - result already collected: FutureResult
[13:19:07.018] result() for ClusterFuture ... done
[13:19:07.018] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:07.018] Future #1
[13:19:07.018] result() for ClusterFuture ...
[13:19:07.018] - result already collected: FutureResult
[13:19:07.018] result() for ClusterFuture ... done
[13:19:07.018] result() for ClusterFuture ...
[13:19:07.018] - result already collected: FutureResult
[13:19:07.018] result() for ClusterFuture ... done
[13:19:07.018] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:07.019] - nx: 2
[13:19:07.019] - relay: TRUE
[13:19:07.019] - stdout: TRUE
[13:19:07.019] - signal: TRUE
[13:19:07.019] - resignal: FALSE
[13:19:07.019] - force: TRUE
[13:19:07.019] - relayed: [n=2] FALSE, FALSE
[13:19:07.019] - queued futures: [n=2] FALSE, FALSE
[13:19:07.019]  - until=1
[13:19:07.019]  - relaying element #1
[13:19:07.019] result() for ClusterFuture ...
[13:19:07.020] - result already collected: FutureResult
[13:19:07.020] result() for ClusterFuture ... done
[13:19:07.020] result() for ClusterFuture ...
[13:19:07.020] - result already collected: FutureResult
[13:19:07.020] result() for ClusterFuture ... done
[13:19:07.020] result() for ClusterFuture ...
[13:19:07.020] - result already collected: FutureResult
[13:19:07.020] result() for ClusterFuture ... done
[13:19:07.020] result() for ClusterFuture ...
[13:19:07.020] - result already collected: FutureResult
[13:19:07.020] result() for ClusterFuture ... done
[13:19:07.020] - relayed: [n=2] TRUE, FALSE
[13:19:07.021] - queued futures: [n=2] TRUE, FALSE
[13:19:07.021] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:07.021]  length: 1 (resolved future 1)
[13:19:07.050] receiveMessageFromWorker() for ClusterFuture ...
[13:19:07.050] - Validating connection of MultisessionFuture
[13:19:07.050] - received message: FutureResult
[13:19:07.050] - Received FutureResult
[13:19:07.051] - Erased future from FutureRegistry
[13:19:07.051] result() for ClusterFuture ...
[13:19:07.051] - result already collected: FutureResult
[13:19:07.051] result() for ClusterFuture ... done
[13:19:07.051] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:07.051] Future #2
[13:19:07.051] result() for ClusterFuture ...
[13:19:07.051] - result already collected: FutureResult
[13:19:07.051] result() for ClusterFuture ... done
[13:19:07.051] result() for ClusterFuture ...
[13:19:07.051] - result already collected: FutureResult
[13:19:07.051] result() for ClusterFuture ... done
[13:19:07.052] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:07.052] - nx: 2
[13:19:07.052] - relay: TRUE
[13:19:07.052] - stdout: TRUE
[13:19:07.052] - signal: TRUE
[13:19:07.052] - resignal: FALSE
[13:19:07.052] - force: TRUE
[13:19:07.052] - relayed: [n=2] TRUE, FALSE
[13:19:07.052] - queued futures: [n=2] TRUE, FALSE
[13:19:07.052]  - until=2
[13:19:07.052]  - relaying element #2
[13:19:07.053] result() for ClusterFuture ...
[13:19:07.053] - result already collected: FutureResult
[13:19:07.053] result() for ClusterFuture ... done
[13:19:07.053] result() for ClusterFuture ...
[13:19:07.053] - result already collected: FutureResult
[13:19:07.053] result() for ClusterFuture ... done
[13:19:07.053] result() for ClusterFuture ...
[13:19:07.053] - result already collected: FutureResult
[13:19:07.053] result() for ClusterFuture ... done
[13:19:07.053] result() for ClusterFuture ...
[13:19:07.053] - result already collected: FutureResult
[13:19:07.054] result() for ClusterFuture ... done
[13:19:07.054] - relayed: [n=2] TRUE, TRUE
[13:19:07.054] - queued futures: [n=2] TRUE, TRUE
[13:19:07.054] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:19:07.054]  length: 0 (resolved future 2)
[13:19:07.054] Relaying remaining futures
[13:19:07.054] signalConditionsASAP(NULL, pos=0) ...
[13:19:07.054] - nx: 2
[13:19:07.054] - relay: TRUE
[13:19:07.054] - stdout: TRUE
[13:19:07.054] - signal: TRUE
[13:19:07.054] - resignal: FALSE
[13:19:07.055] - force: TRUE
[13:19:07.055] - relayed: [n=2] TRUE, TRUE
[13:19:07.055] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:07.055] - relayed: [n=2] TRUE, TRUE
[13:19:07.055] - queued futures: [n=2] TRUE, TRUE
[13:19:07.055] signalConditionsASAP(NULL, pos=0) ... done
[13:19:07.055] resolve() on list ... DONE
[13:19:07.055] result() for ClusterFuture ...
[13:19:07.055] - result already collected: FutureResult
[13:19:07.055] result() for ClusterFuture ... done
[13:19:07.055] result() for ClusterFuture ...
[13:19:07.056] - result already collected: FutureResult
[13:19:07.056] result() for ClusterFuture ... done
[13:19:07.056] result() for ClusterFuture ...
[13:19:07.056] - result already collected: FutureResult
[13:19:07.056] result() for ClusterFuture ... done
[13:19:07.056] result() for ClusterFuture ...
[13:19:07.056] - result already collected: FutureResult
[13:19:07.056] result() for ClusterFuture ... done
[13:19:07.056]  - Number of value chunks collected: 2
[13:19:07.056] Resolving 2 futures (chunks) ... DONE
[13:19:07.056] Reducing values from 2 chunks ...
[13:19:07.057]  - Number of values collected after concatenation: 3
[13:19:07.057]  - Number of values expected: 3
[13:19:07.057] Reducing values from 2 chunks ... DONE
[13:19:07.057] future_lapply() ... DONE
- exceptions ...
[13:19:07.057] future_lapply() ...
[13:19:07.062] Number of chunks: 2
[13:19:07.062] getGlobalsAndPackagesXApply() ...
[13:19:07.062]  - future.globals: TRUE
[13:19:07.063] getGlobalsAndPackages() ...
[13:19:07.063] Searching for globals...
[13:19:07.066] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:19:07.066] Searching for globals ... DONE
[13:19:07.066] Resolving globals: FALSE
[13:19:07.067] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:19:07.067] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:19:07.067] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:07.068] - packages: [1] ‘future.apply’
[13:19:07.068] getGlobalsAndPackages() ... DONE
[13:19:07.068]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:19:07.068]  - needed namespaces: [n=1] ‘future.apply’
[13:19:07.068] Finding globals ... DONE
[13:19:07.068]  - use_args: TRUE
[13:19:07.068]  - Getting '...' globals ...
[13:19:07.068] resolve() on list ...
[13:19:07.069]  recursive: 0
[13:19:07.069]  length: 1
[13:19:07.069]  elements: ‘...’
[13:19:07.069]  length: 0 (resolved future 1)
[13:19:07.069] resolve() on list ... DONE
[13:19:07.069]    - '...' content: [n=0] 
[13:19:07.069] List of 1
[13:19:07.069]  $ ...: list()
[13:19:07.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:07.069]  - attr(*, "where")=List of 1
[13:19:07.069]   ..$ ...:<environment: 0x555f7dc71430> 
[13:19:07.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:07.069]  - attr(*, "resolved")= logi TRUE
[13:19:07.069]  - attr(*, "total_size")= num NA
[13:19:07.072]  - Getting '...' globals ... DONE
[13:19:07.072] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:19:07.072] List of 8
[13:19:07.072]  $ ...future.FUN:function (x, ...)  
[13:19:07.072]  $ x_FUN        :function (x)  
[13:19:07.072]  $ times        : int 2
[13:19:07.072]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:19:07.072]  $ stop_if_not  :function (...)  
[13:19:07.072]  $ dim          : NULL
[13:19:07.072]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:19:07.072]  $ ...          : list()
[13:19:07.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:07.072]  - attr(*, "where")=List of 8
[13:19:07.072]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ times        :<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ dim          :<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:19:07.072]   ..$ ...          :<environment: 0x555f7dc71430> 
[13:19:07.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:07.072]  - attr(*, "resolved")= logi FALSE
[13:19:07.072]  - attr(*, "total_size")= num 95128
[13:19:07.077] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:19:07.077] getGlobalsAndPackagesXApply() ... DONE
[13:19:07.077] Number of futures (= number of chunks): 2
[13:19:07.077] Launching 2 futures (chunks) ...
[13:19:07.077] Chunk #1 of 2 ...
[13:19:07.078]  - Finding globals in 'X' for chunk #1 ...
[13:19:07.078] getGlobalsAndPackages() ...
[13:19:07.078] Searching for globals...
[13:19:07.078] 
[13:19:07.078] Searching for globals ... DONE
[13:19:07.078] - globals: [0] <none>
[13:19:07.078] getGlobalsAndPackages() ... DONE
[13:19:07.078]    + additional globals found: [n=0] 
[13:19:07.078]    + additional namespaces needed: [n=0] 
[13:19:07.079]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:07.079]  - seeds: <none>
[13:19:07.079] getGlobalsAndPackages() ...
[13:19:07.079] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:07.079] Resolving globals: FALSE
[13:19:07.079] Tweak future expression to call with '...' arguments ...
[13:19:07.079] {
[13:19:07.079]     do.call(function(...) {
[13:19:07.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:07.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.079]             on.exit(options(oopts), add = TRUE)
[13:19:07.079]         }
[13:19:07.079]         {
[13:19:07.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:07.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.079]                 ...future.FUN(...future.X_jj, ...)
[13:19:07.079]             })
[13:19:07.079]         }
[13:19:07.079]     }, args = future.call.arguments)
[13:19:07.079] }
[13:19:07.079] Tweak future expression to call with '...' arguments ... DONE
[13:19:07.080] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:07.080] - packages: [1] ‘future.apply’
[13:19:07.080] getGlobalsAndPackages() ... DONE
[13:19:07.080] run() for ‘Future’ ...
[13:19:07.080] - state: ‘created’
[13:19:07.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:07.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:07.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:07.097]   - Field: ‘node’
[13:19:07.097]   - Field: ‘label’
[13:19:07.097]   - Field: ‘local’
[13:19:07.097]   - Field: ‘owner’
[13:19:07.097]   - Field: ‘envir’
[13:19:07.097]   - Field: ‘workers’
[13:19:07.097]   - Field: ‘packages’
[13:19:07.097]   - Field: ‘gc’
[13:19:07.097]   - Field: ‘conditions’
[13:19:07.097]   - Field: ‘persistent’
[13:19:07.098]   - Field: ‘expr’
[13:19:07.098]   - Field: ‘uuid’
[13:19:07.098]   - Field: ‘seed’
[13:19:07.098]   - Field: ‘version’
[13:19:07.098]   - Field: ‘result’
[13:19:07.098]   - Field: ‘asynchronous’
[13:19:07.098]   - Field: ‘calls’
[13:19:07.098]   - Field: ‘globals’
[13:19:07.098]   - Field: ‘stdout’
[13:19:07.098]   - Field: ‘earlySignal’
[13:19:07.098]   - Field: ‘lazy’
[13:19:07.098]   - Field: ‘state’
[13:19:07.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:07.099] - Launch lazy future ...
[13:19:07.099] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:07.099] Packages needed by future strategies (n = 0): <none>
[13:19:07.100] {
[13:19:07.100]     {
[13:19:07.100]         {
[13:19:07.100]             ...future.startTime <- base::Sys.time()
[13:19:07.100]             {
[13:19:07.100]                 {
[13:19:07.100]                   {
[13:19:07.100]                     {
[13:19:07.100]                       {
[13:19:07.100]                         base::local({
[13:19:07.100]                           has_future <- base::requireNamespace("future", 
[13:19:07.100]                             quietly = TRUE)
[13:19:07.100]                           if (has_future) {
[13:19:07.100]                             ns <- base::getNamespace("future")
[13:19:07.100]                             version <- ns[[".package"]][["version"]]
[13:19:07.100]                             if (is.null(version)) 
[13:19:07.100]                               version <- utils::packageVersion("future")
[13:19:07.100]                           }
[13:19:07.100]                           else {
[13:19:07.100]                             version <- NULL
[13:19:07.100]                           }
[13:19:07.100]                           if (!has_future || version < "1.8.0") {
[13:19:07.100]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:07.100]                               "", base::R.version$version.string), 
[13:19:07.100]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:07.100]                                 base::R.version$platform, 8 * 
[13:19:07.100]                                   base::.Machine$sizeof.pointer), 
[13:19:07.100]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:07.100]                                 "release", "version")], collapse = " "), 
[13:19:07.100]                               hostname = base::Sys.info()[["nodename"]])
[13:19:07.100]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:07.100]                               info)
[13:19:07.100]                             info <- base::paste(info, collapse = "; ")
[13:19:07.100]                             if (!has_future) {
[13:19:07.100]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:07.100]                                 info)
[13:19:07.100]                             }
[13:19:07.100]                             else {
[13:19:07.100]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:07.100]                                 info, version)
[13:19:07.100]                             }
[13:19:07.100]                             base::stop(msg)
[13:19:07.100]                           }
[13:19:07.100]                         })
[13:19:07.100]                       }
[13:19:07.100]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:07.100]                       base::options(mc.cores = 1L)
[13:19:07.100]                     }
[13:19:07.100]                     base::local({
[13:19:07.100]                       for (pkg in "future.apply") {
[13:19:07.100]                         base::loadNamespace(pkg)
[13:19:07.100]                         base::library(pkg, character.only = TRUE)
[13:19:07.100]                       }
[13:19:07.100]                     })
[13:19:07.100]                   }
[13:19:07.100]                   options(future.plan = NULL)
[13:19:07.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:07.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:07.100]                 }
[13:19:07.100]                 ...future.workdir <- getwd()
[13:19:07.100]             }
[13:19:07.100]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:07.100]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:07.100]         }
[13:19:07.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:07.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:07.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:07.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:07.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:07.100]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:07.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:07.100]             base::names(...future.oldOptions))
[13:19:07.100]     }
[13:19:07.100]     if (FALSE) {
[13:19:07.100]     }
[13:19:07.100]     else {
[13:19:07.100]         if (TRUE) {
[13:19:07.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:07.100]                 open = "w")
[13:19:07.100]         }
[13:19:07.100]         else {
[13:19:07.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:07.100]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:07.100]         }
[13:19:07.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:07.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:07.100]             base::sink(type = "output", split = FALSE)
[13:19:07.100]             base::close(...future.stdout)
[13:19:07.100]         }, add = TRUE)
[13:19:07.100]     }
[13:19:07.100]     ...future.frame <- base::sys.nframe()
[13:19:07.100]     ...future.conditions <- base::list()
[13:19:07.100]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:07.100]     if (FALSE) {
[13:19:07.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:07.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:07.100]     }
[13:19:07.100]     ...future.result <- base::tryCatch({
[13:19:07.100]         base::withCallingHandlers({
[13:19:07.100]             ...future.value <- base::withVisible(base::local({
[13:19:07.100]                 ...future.makeSendCondition <- local({
[13:19:07.100]                   sendCondition <- NULL
[13:19:07.100]                   function(frame = 1L) {
[13:19:07.100]                     if (is.function(sendCondition)) 
[13:19:07.100]                       return(sendCondition)
[13:19:07.100]                     ns <- getNamespace("parallel")
[13:19:07.100]                     if (exists("sendData", mode = "function", 
[13:19:07.100]                       envir = ns)) {
[13:19:07.100]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:07.100]                         envir = ns)
[13:19:07.100]                       envir <- sys.frame(frame)
[13:19:07.100]                       master <- NULL
[13:19:07.100]                       while (!identical(envir, .GlobalEnv) && 
[13:19:07.100]                         !identical(envir, emptyenv())) {
[13:19:07.100]                         if (exists("master", mode = "list", envir = envir, 
[13:19:07.100]                           inherits = FALSE)) {
[13:19:07.100]                           master <- get("master", mode = "list", 
[13:19:07.100]                             envir = envir, inherits = FALSE)
[13:19:07.100]                           if (inherits(master, c("SOCKnode", 
[13:19:07.100]                             "SOCK0node"))) {
[13:19:07.100]                             sendCondition <<- function(cond) {
[13:19:07.100]                               data <- list(type = "VALUE", value = cond, 
[13:19:07.100]                                 success = TRUE)
[13:19:07.100]                               parallel_sendData(master, data)
[13:19:07.100]                             }
[13:19:07.100]                             return(sendCondition)
[13:19:07.100]                           }
[13:19:07.100]                         }
[13:19:07.100]                         frame <- frame + 1L
[13:19:07.100]                         envir <- sys.frame(frame)
[13:19:07.100]                       }
[13:19:07.100]                     }
[13:19:07.100]                     sendCondition <<- function(cond) NULL
[13:19:07.100]                   }
[13:19:07.100]                 })
[13:19:07.100]                 withCallingHandlers({
[13:19:07.100]                   {
[13:19:07.100]                     do.call(function(...) {
[13:19:07.100]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.100]                       if (!identical(...future.globals.maxSize.org, 
[13:19:07.100]                         ...future.globals.maxSize)) {
[13:19:07.100]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.100]                         on.exit(options(oopts), add = TRUE)
[13:19:07.100]                       }
[13:19:07.100]                       {
[13:19:07.100]                         lapply(seq_along(...future.elements_ii), 
[13:19:07.100]                           FUN = function(jj) {
[13:19:07.100]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.100]                             ...future.FUN(...future.X_jj, ...)
[13:19:07.100]                           })
[13:19:07.100]                       }
[13:19:07.100]                     }, args = future.call.arguments)
[13:19:07.100]                   }
[13:19:07.100]                 }, immediateCondition = function(cond) {
[13:19:07.100]                   sendCondition <- ...future.makeSendCondition()
[13:19:07.100]                   sendCondition(cond)
[13:19:07.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:07.100]                   {
[13:19:07.100]                     inherits <- base::inherits
[13:19:07.100]                     invokeRestart <- base::invokeRestart
[13:19:07.100]                     is.null <- base::is.null
[13:19:07.100]                     muffled <- FALSE
[13:19:07.100]                     if (inherits(cond, "message")) {
[13:19:07.100]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:07.100]                       if (muffled) 
[13:19:07.100]                         invokeRestart("muffleMessage")
[13:19:07.100]                     }
[13:19:07.100]                     else if (inherits(cond, "warning")) {
[13:19:07.100]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:07.100]                       if (muffled) 
[13:19:07.100]                         invokeRestart("muffleWarning")
[13:19:07.100]                     }
[13:19:07.100]                     else if (inherits(cond, "condition")) {
[13:19:07.100]                       if (!is.null(pattern)) {
[13:19:07.100]                         computeRestarts <- base::computeRestarts
[13:19:07.100]                         grepl <- base::grepl
[13:19:07.100]                         restarts <- computeRestarts(cond)
[13:19:07.100]                         for (restart in restarts) {
[13:19:07.100]                           name <- restart$name
[13:19:07.100]                           if (is.null(name)) 
[13:19:07.100]                             next
[13:19:07.100]                           if (!grepl(pattern, name)) 
[13:19:07.100]                             next
[13:19:07.100]                           invokeRestart(restart)
[13:19:07.100]                           muffled <- TRUE
[13:19:07.100]                           break
[13:19:07.100]                         }
[13:19:07.100]                       }
[13:19:07.100]                     }
[13:19:07.100]                     invisible(muffled)
[13:19:07.100]                   }
[13:19:07.100]                   muffleCondition(cond)
[13:19:07.100]                 })
[13:19:07.100]             }))
[13:19:07.100]             future::FutureResult(value = ...future.value$value, 
[13:19:07.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:07.100]                   ...future.rng), globalenv = if (FALSE) 
[13:19:07.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:07.100]                     ...future.globalenv.names))
[13:19:07.100]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:07.100]         }, condition = base::local({
[13:19:07.100]             c <- base::c
[13:19:07.100]             inherits <- base::inherits
[13:19:07.100]             invokeRestart <- base::invokeRestart
[13:19:07.100]             length <- base::length
[13:19:07.100]             list <- base::list
[13:19:07.100]             seq.int <- base::seq.int
[13:19:07.100]             signalCondition <- base::signalCondition
[13:19:07.100]             sys.calls <- base::sys.calls
[13:19:07.100]             `[[` <- base::`[[`
[13:19:07.100]             `+` <- base::`+`
[13:19:07.100]             `<<-` <- base::`<<-`
[13:19:07.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:07.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:07.100]                   3L)]
[13:19:07.100]             }
[13:19:07.100]             function(cond) {
[13:19:07.100]                 is_error <- inherits(cond, "error")
[13:19:07.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:07.100]                   NULL)
[13:19:07.100]                 if (is_error) {
[13:19:07.100]                   sessionInformation <- function() {
[13:19:07.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:07.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:07.100]                       search = base::search(), system = base::Sys.info())
[13:19:07.100]                   }
[13:19:07.100]                   ...future.conditions[[length(...future.conditions) + 
[13:19:07.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:07.100]                     cond$call), session = sessionInformation(), 
[13:19:07.100]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:07.100]                   signalCondition(cond)
[13:19:07.100]                 }
[13:19:07.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:07.100]                 "immediateCondition"))) {
[13:19:07.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:07.100]                   ...future.conditions[[length(...future.conditions) + 
[13:19:07.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:07.100]                   if (TRUE && !signal) {
[13:19:07.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:07.100]                     {
[13:19:07.100]                       inherits <- base::inherits
[13:19:07.100]                       invokeRestart <- base::invokeRestart
[13:19:07.100]                       is.null <- base::is.null
[13:19:07.100]                       muffled <- FALSE
[13:19:07.100]                       if (inherits(cond, "message")) {
[13:19:07.100]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:07.100]                         if (muffled) 
[13:19:07.100]                           invokeRestart("muffleMessage")
[13:19:07.100]                       }
[13:19:07.100]                       else if (inherits(cond, "warning")) {
[13:19:07.100]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:07.100]                         if (muffled) 
[13:19:07.100]                           invokeRestart("muffleWarning")
[13:19:07.100]                       }
[13:19:07.100]                       else if (inherits(cond, "condition")) {
[13:19:07.100]                         if (!is.null(pattern)) {
[13:19:07.100]                           computeRestarts <- base::computeRestarts
[13:19:07.100]                           grepl <- base::grepl
[13:19:07.100]                           restarts <- computeRestarts(cond)
[13:19:07.100]                           for (restart in restarts) {
[13:19:07.100]                             name <- restart$name
[13:19:07.100]                             if (is.null(name)) 
[13:19:07.100]                               next
[13:19:07.100]                             if (!grepl(pattern, name)) 
[13:19:07.100]                               next
[13:19:07.100]                             invokeRestart(restart)
[13:19:07.100]                             muffled <- TRUE
[13:19:07.100]                             break
[13:19:07.100]                           }
[13:19:07.100]                         }
[13:19:07.100]                       }
[13:19:07.100]                       invisible(muffled)
[13:19:07.100]                     }
[13:19:07.100]                     muffleCondition(cond, pattern = "^muffle")
[13:19:07.100]                   }
[13:19:07.100]                 }
[13:19:07.100]                 else {
[13:19:07.100]                   if (TRUE) {
[13:19:07.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:07.100]                     {
[13:19:07.100]                       inherits <- base::inherits
[13:19:07.100]                       invokeRestart <- base::invokeRestart
[13:19:07.100]                       is.null <- base::is.null
[13:19:07.100]                       muffled <- FALSE
[13:19:07.100]                       if (inherits(cond, "message")) {
[13:19:07.100]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:07.100]                         if (muffled) 
[13:19:07.100]                           invokeRestart("muffleMessage")
[13:19:07.100]                       }
[13:19:07.100]                       else if (inherits(cond, "warning")) {
[13:19:07.100]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:07.100]                         if (muffled) 
[13:19:07.100]                           invokeRestart("muffleWarning")
[13:19:07.100]                       }
[13:19:07.100]                       else if (inherits(cond, "condition")) {
[13:19:07.100]                         if (!is.null(pattern)) {
[13:19:07.100]                           computeRestarts <- base::computeRestarts
[13:19:07.100]                           grepl <- base::grepl
[13:19:07.100]                           restarts <- computeRestarts(cond)
[13:19:07.100]                           for (restart in restarts) {
[13:19:07.100]                             name <- restart$name
[13:19:07.100]                             if (is.null(name)) 
[13:19:07.100]                               next
[13:19:07.100]                             if (!grepl(pattern, name)) 
[13:19:07.100]                               next
[13:19:07.100]                             invokeRestart(restart)
[13:19:07.100]                             muffled <- TRUE
[13:19:07.100]                             break
[13:19:07.100]                           }
[13:19:07.100]                         }
[13:19:07.100]                       }
[13:19:07.100]                       invisible(muffled)
[13:19:07.100]                     }
[13:19:07.100]                     muffleCondition(cond, pattern = "^muffle")
[13:19:07.100]                   }
[13:19:07.100]                 }
[13:19:07.100]             }
[13:19:07.100]         }))
[13:19:07.100]     }, error = function(ex) {
[13:19:07.100]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:07.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:07.100]                 ...future.rng), started = ...future.startTime, 
[13:19:07.100]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:07.100]             version = "1.8"), class = "FutureResult")
[13:19:07.100]     }, finally = {
[13:19:07.100]         if (!identical(...future.workdir, getwd())) 
[13:19:07.100]             setwd(...future.workdir)
[13:19:07.100]         {
[13:19:07.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:07.100]                 ...future.oldOptions$nwarnings <- NULL
[13:19:07.100]             }
[13:19:07.100]             base::options(...future.oldOptions)
[13:19:07.100]             if (.Platform$OS.type == "windows") {
[13:19:07.100]                 old_names <- names(...future.oldEnvVars)
[13:19:07.100]                 envs <- base::Sys.getenv()
[13:19:07.100]                 names <- names(envs)
[13:19:07.100]                 common <- intersect(names, old_names)
[13:19:07.100]                 added <- setdiff(names, old_names)
[13:19:07.100]                 removed <- setdiff(old_names, names)
[13:19:07.100]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:07.100]                   envs[common]]
[13:19:07.100]                 NAMES <- toupper(changed)
[13:19:07.100]                 args <- list()
[13:19:07.100]                 for (kk in seq_along(NAMES)) {
[13:19:07.100]                   name <- changed[[kk]]
[13:19:07.100]                   NAME <- NAMES[[kk]]
[13:19:07.100]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:07.100]                     next
[13:19:07.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:07.100]                 }
[13:19:07.100]                 NAMES <- toupper(added)
[13:19:07.100]                 for (kk in seq_along(NAMES)) {
[13:19:07.100]                   name <- added[[kk]]
[13:19:07.100]                   NAME <- NAMES[[kk]]
[13:19:07.100]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:07.100]                     next
[13:19:07.100]                   args[[name]] <- ""
[13:19:07.100]                 }
[13:19:07.100]                 NAMES <- toupper(removed)
[13:19:07.100]                 for (kk in seq_along(NAMES)) {
[13:19:07.100]                   name <- removed[[kk]]
[13:19:07.100]                   NAME <- NAMES[[kk]]
[13:19:07.100]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:07.100]                     next
[13:19:07.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:07.100]                 }
[13:19:07.100]                 if (length(args) > 0) 
[13:19:07.100]                   base::do.call(base::Sys.setenv, args = args)
[13:19:07.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:07.100]             }
[13:19:07.100]             else {
[13:19:07.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:07.100]             }
[13:19:07.100]             {
[13:19:07.100]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:07.100]                   0L) {
[13:19:07.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:07.100]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:07.100]                   base::options(opts)
[13:19:07.100]                 }
[13:19:07.100]                 {
[13:19:07.100]                   {
[13:19:07.100]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:07.100]                     NULL
[13:19:07.100]                   }
[13:19:07.100]                   options(future.plan = NULL)
[13:19:07.100]                   if (is.na(NA_character_)) 
[13:19:07.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:07.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:07.100]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:07.100]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:07.100]                     envir = parent.frame()) 
[13:19:07.100]                   {
[13:19:07.100]                     if (is.function(workers)) 
[13:19:07.100]                       workers <- workers()
[13:19:07.100]                     workers <- structure(as.integer(workers), 
[13:19:07.100]                       class = class(workers))
[13:19:07.100]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:07.100]                       workers >= 1)
[13:19:07.100]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:07.100]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:07.100]                     }
[13:19:07.100]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:07.100]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:07.100]                       envir = envir)
[13:19:07.100]                     if (!future$lazy) 
[13:19:07.100]                       future <- run(future)
[13:19:07.100]                     invisible(future)
[13:19:07.100]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:07.100]                 }
[13:19:07.100]             }
[13:19:07.100]         }
[13:19:07.100]     })
[13:19:07.100]     if (TRUE) {
[13:19:07.100]         base::sink(type = "output", split = FALSE)
[13:19:07.100]         if (TRUE) {
[13:19:07.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:07.100]         }
[13:19:07.100]         else {
[13:19:07.100]             ...future.result["stdout"] <- base::list(NULL)
[13:19:07.100]         }
[13:19:07.100]         base::close(...future.stdout)
[13:19:07.100]         ...future.stdout <- NULL
[13:19:07.100]     }
[13:19:07.100]     ...future.result$conditions <- ...future.conditions
[13:19:07.100]     ...future.result$finished <- base::Sys.time()
[13:19:07.100]     ...future.result
[13:19:07.100] }
[13:19:07.103] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[13:19:07.103] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:19:07.145] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:19:07.145] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[13:19:07.145] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[13:19:07.146] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:19:07.146] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:19:07.146] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:19:07.189] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:19:07.189] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:19:07.233] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:19:07.233] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:19:07.234] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:19:07.234] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:19:07.234] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:19:07.235] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:07.235] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:07.235] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:19:07.236] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:07.236] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:07.237] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:07.237] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:07.237] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:07.237] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[13:19:07.238] MultisessionFuture started
[13:19:07.238] - Launch lazy future ... done
[13:19:07.238] run() for ‘MultisessionFuture’ ... done
[13:19:07.239] Created future:
[13:19:07.239] MultisessionFuture:
[13:19:07.239] Label: ‘future_vapply-1’
[13:19:07.239] Expression:
[13:19:07.239] {
[13:19:07.239]     do.call(function(...) {
[13:19:07.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:07.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.239]             on.exit(options(oopts), add = TRUE)
[13:19:07.239]         }
[13:19:07.239]         {
[13:19:07.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:07.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.239]                 ...future.FUN(...future.X_jj, ...)
[13:19:07.239]             })
[13:19:07.239]         }
[13:19:07.239]     }, args = future.call.arguments)
[13:19:07.239] }
[13:19:07.239] Lazy evaluation: FALSE
[13:19:07.239] Asynchronous evaluation: TRUE
[13:19:07.239] Local evaluation: TRUE
[13:19:07.239] Environment: R_GlobalEnv
[13:19:07.239] Capture standard output: TRUE
[13:19:07.239] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:07.239] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:07.239] Packages: 1 packages (‘future.apply’)
[13:19:07.239] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:07.239] Resolved: FALSE
[13:19:07.239] Value: <not collected>
[13:19:07.239] Conditions captured: <none>
[13:19:07.239] Early signaling: FALSE
[13:19:07.239] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:07.239] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:07.251] Chunk #1 of 2 ... DONE
[13:19:07.252] Chunk #2 of 2 ...
[13:19:07.252]  - Finding globals in 'X' for chunk #2 ...
[13:19:07.252] getGlobalsAndPackages() ...
[13:19:07.252] Searching for globals...
[13:19:07.253] 
[13:19:07.253] Searching for globals ... DONE
[13:19:07.253] - globals: [0] <none>
[13:19:07.253] getGlobalsAndPackages() ... DONE
[13:19:07.253]    + additional globals found: [n=0] 
[13:19:07.253]    + additional namespaces needed: [n=0] 
[13:19:07.254]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:07.254]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:07.254]  - seeds: <none>
[13:19:07.254] getGlobalsAndPackages() ...
[13:19:07.254] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:07.255] Resolving globals: FALSE
[13:19:07.255] Tweak future expression to call with '...' arguments ...
[13:19:07.255] {
[13:19:07.255]     do.call(function(...) {
[13:19:07.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:07.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.255]             on.exit(options(oopts), add = TRUE)
[13:19:07.255]         }
[13:19:07.255]         {
[13:19:07.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:07.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.255]                 ...future.FUN(...future.X_jj, ...)
[13:19:07.255]             })
[13:19:07.255]         }
[13:19:07.255]     }, args = future.call.arguments)
[13:19:07.255] }
[13:19:07.255] Tweak future expression to call with '...' arguments ... DONE
[13:19:07.256] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:07.257] - packages: [1] ‘future.apply’
[13:19:07.257] getGlobalsAndPackages() ... DONE
[13:19:07.257] run() for ‘Future’ ...
[13:19:07.258] - state: ‘created’
[13:19:07.258] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:07.275] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:07.275] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:07.275]   - Field: ‘node’
[13:19:07.276]   - Field: ‘label’
[13:19:07.276]   - Field: ‘local’
[13:19:07.276]   - Field: ‘owner’
[13:19:07.276]   - Field: ‘envir’
[13:19:07.276]   - Field: ‘workers’
[13:19:07.276]   - Field: ‘packages’
[13:19:07.276]   - Field: ‘gc’
[13:19:07.276]   - Field: ‘conditions’
[13:19:07.277]   - Field: ‘persistent’
[13:19:07.277]   - Field: ‘expr’
[13:19:07.277]   - Field: ‘uuid’
[13:19:07.277]   - Field: ‘seed’
[13:19:07.277]   - Field: ‘version’
[13:19:07.277]   - Field: ‘result’
[13:19:07.278]   - Field: ‘asynchronous’
[13:19:07.278]   - Field: ‘calls’
[13:19:07.278]   - Field: ‘globals’
[13:19:07.278]   - Field: ‘stdout’
[13:19:07.278]   - Field: ‘earlySignal’
[13:19:07.278]   - Field: ‘lazy’
[13:19:07.278]   - Field: ‘state’
[13:19:07.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:07.279] - Launch lazy future ...
[13:19:07.279] Packages needed by the future expression (n = 1): ‘future.apply’
[13:19:07.279] Packages needed by future strategies (n = 0): <none>
[13:19:07.280] {
[13:19:07.280]     {
[13:19:07.280]         {
[13:19:07.280]             ...future.startTime <- base::Sys.time()
[13:19:07.280]             {
[13:19:07.280]                 {
[13:19:07.280]                   {
[13:19:07.280]                     {
[13:19:07.280]                       {
[13:19:07.280]                         base::local({
[13:19:07.280]                           has_future <- base::requireNamespace("future", 
[13:19:07.280]                             quietly = TRUE)
[13:19:07.280]                           if (has_future) {
[13:19:07.280]                             ns <- base::getNamespace("future")
[13:19:07.280]                             version <- ns[[".package"]][["version"]]
[13:19:07.280]                             if (is.null(version)) 
[13:19:07.280]                               version <- utils::packageVersion("future")
[13:19:07.280]                           }
[13:19:07.280]                           else {
[13:19:07.280]                             version <- NULL
[13:19:07.280]                           }
[13:19:07.280]                           if (!has_future || version < "1.8.0") {
[13:19:07.280]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:07.280]                               "", base::R.version$version.string), 
[13:19:07.280]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:07.280]                                 base::R.version$platform, 8 * 
[13:19:07.280]                                   base::.Machine$sizeof.pointer), 
[13:19:07.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:07.280]                                 "release", "version")], collapse = " "), 
[13:19:07.280]                               hostname = base::Sys.info()[["nodename"]])
[13:19:07.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:07.280]                               info)
[13:19:07.280]                             info <- base::paste(info, collapse = "; ")
[13:19:07.280]                             if (!has_future) {
[13:19:07.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:07.280]                                 info)
[13:19:07.280]                             }
[13:19:07.280]                             else {
[13:19:07.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:07.280]                                 info, version)
[13:19:07.280]                             }
[13:19:07.280]                             base::stop(msg)
[13:19:07.280]                           }
[13:19:07.280]                         })
[13:19:07.280]                       }
[13:19:07.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:07.280]                       base::options(mc.cores = 1L)
[13:19:07.280]                     }
[13:19:07.280]                     base::local({
[13:19:07.280]                       for (pkg in "future.apply") {
[13:19:07.280]                         base::loadNamespace(pkg)
[13:19:07.280]                         base::library(pkg, character.only = TRUE)
[13:19:07.280]                       }
[13:19:07.280]                     })
[13:19:07.280]                   }
[13:19:07.280]                   options(future.plan = NULL)
[13:19:07.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:07.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:07.280]                 }
[13:19:07.280]                 ...future.workdir <- getwd()
[13:19:07.280]             }
[13:19:07.280]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:07.280]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:07.280]         }
[13:19:07.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:07.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:07.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:07.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:07.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:07.280]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:07.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:07.280]             base::names(...future.oldOptions))
[13:19:07.280]     }
[13:19:07.280]     if (FALSE) {
[13:19:07.280]     }
[13:19:07.280]     else {
[13:19:07.280]         if (TRUE) {
[13:19:07.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:07.280]                 open = "w")
[13:19:07.280]         }
[13:19:07.280]         else {
[13:19:07.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:07.280]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:07.280]         }
[13:19:07.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:07.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:07.280]             base::sink(type = "output", split = FALSE)
[13:19:07.280]             base::close(...future.stdout)
[13:19:07.280]         }, add = TRUE)
[13:19:07.280]     }
[13:19:07.280]     ...future.frame <- base::sys.nframe()
[13:19:07.280]     ...future.conditions <- base::list()
[13:19:07.280]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:07.280]     if (FALSE) {
[13:19:07.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:07.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:07.280]     }
[13:19:07.280]     ...future.result <- base::tryCatch({
[13:19:07.280]         base::withCallingHandlers({
[13:19:07.280]             ...future.value <- base::withVisible(base::local({
[13:19:07.280]                 ...future.makeSendCondition <- local({
[13:19:07.280]                   sendCondition <- NULL
[13:19:07.280]                   function(frame = 1L) {
[13:19:07.280]                     if (is.function(sendCondition)) 
[13:19:07.280]                       return(sendCondition)
[13:19:07.280]                     ns <- getNamespace("parallel")
[13:19:07.280]                     if (exists("sendData", mode = "function", 
[13:19:07.280]                       envir = ns)) {
[13:19:07.280]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:07.280]                         envir = ns)
[13:19:07.280]                       envir <- sys.frame(frame)
[13:19:07.280]                       master <- NULL
[13:19:07.280]                       while (!identical(envir, .GlobalEnv) && 
[13:19:07.280]                         !identical(envir, emptyenv())) {
[13:19:07.280]                         if (exists("master", mode = "list", envir = envir, 
[13:19:07.280]                           inherits = FALSE)) {
[13:19:07.280]                           master <- get("master", mode = "list", 
[13:19:07.280]                             envir = envir, inherits = FALSE)
[13:19:07.280]                           if (inherits(master, c("SOCKnode", 
[13:19:07.280]                             "SOCK0node"))) {
[13:19:07.280]                             sendCondition <<- function(cond) {
[13:19:07.280]                               data <- list(type = "VALUE", value = cond, 
[13:19:07.280]                                 success = TRUE)
[13:19:07.280]                               parallel_sendData(master, data)
[13:19:07.280]                             }
[13:19:07.280]                             return(sendCondition)
[13:19:07.280]                           }
[13:19:07.280]                         }
[13:19:07.280]                         frame <- frame + 1L
[13:19:07.280]                         envir <- sys.frame(frame)
[13:19:07.280]                       }
[13:19:07.280]                     }
[13:19:07.280]                     sendCondition <<- function(cond) NULL
[13:19:07.280]                   }
[13:19:07.280]                 })
[13:19:07.280]                 withCallingHandlers({
[13:19:07.280]                   {
[13:19:07.280]                     do.call(function(...) {
[13:19:07.280]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.280]                       if (!identical(...future.globals.maxSize.org, 
[13:19:07.280]                         ...future.globals.maxSize)) {
[13:19:07.280]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.280]                         on.exit(options(oopts), add = TRUE)
[13:19:07.280]                       }
[13:19:07.280]                       {
[13:19:07.280]                         lapply(seq_along(...future.elements_ii), 
[13:19:07.280]                           FUN = function(jj) {
[13:19:07.280]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.280]                             ...future.FUN(...future.X_jj, ...)
[13:19:07.280]                           })
[13:19:07.280]                       }
[13:19:07.280]                     }, args = future.call.arguments)
[13:19:07.280]                   }
[13:19:07.280]                 }, immediateCondition = function(cond) {
[13:19:07.280]                   sendCondition <- ...future.makeSendCondition()
[13:19:07.280]                   sendCondition(cond)
[13:19:07.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:07.280]                   {
[13:19:07.280]                     inherits <- base::inherits
[13:19:07.280]                     invokeRestart <- base::invokeRestart
[13:19:07.280]                     is.null <- base::is.null
[13:19:07.280]                     muffled <- FALSE
[13:19:07.280]                     if (inherits(cond, "message")) {
[13:19:07.280]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:07.280]                       if (muffled) 
[13:19:07.280]                         invokeRestart("muffleMessage")
[13:19:07.280]                     }
[13:19:07.280]                     else if (inherits(cond, "warning")) {
[13:19:07.280]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:07.280]                       if (muffled) 
[13:19:07.280]                         invokeRestart("muffleWarning")
[13:19:07.280]                     }
[13:19:07.280]                     else if (inherits(cond, "condition")) {
[13:19:07.280]                       if (!is.null(pattern)) {
[13:19:07.280]                         computeRestarts <- base::computeRestarts
[13:19:07.280]                         grepl <- base::grepl
[13:19:07.280]                         restarts <- computeRestarts(cond)
[13:19:07.280]                         for (restart in restarts) {
[13:19:07.280]                           name <- restart$name
[13:19:07.280]                           if (is.null(name)) 
[13:19:07.280]                             next
[13:19:07.280]                           if (!grepl(pattern, name)) 
[13:19:07.280]                             next
[13:19:07.280]                           invokeRestart(restart)
[13:19:07.280]                           muffled <- TRUE
[13:19:07.280]                           break
[13:19:07.280]                         }
[13:19:07.280]                       }
[13:19:07.280]                     }
[13:19:07.280]                     invisible(muffled)
[13:19:07.280]                   }
[13:19:07.280]                   muffleCondition(cond)
[13:19:07.280]                 })
[13:19:07.280]             }))
[13:19:07.280]             future::FutureResult(value = ...future.value$value, 
[13:19:07.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:07.280]                   ...future.rng), globalenv = if (FALSE) 
[13:19:07.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:07.280]                     ...future.globalenv.names))
[13:19:07.280]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:07.280]         }, condition = base::local({
[13:19:07.280]             c <- base::c
[13:19:07.280]             inherits <- base::inherits
[13:19:07.280]             invokeRestart <- base::invokeRestart
[13:19:07.280]             length <- base::length
[13:19:07.280]             list <- base::list
[13:19:07.280]             seq.int <- base::seq.int
[13:19:07.280]             signalCondition <- base::signalCondition
[13:19:07.280]             sys.calls <- base::sys.calls
[13:19:07.280]             `[[` <- base::`[[`
[13:19:07.280]             `+` <- base::`+`
[13:19:07.280]             `<<-` <- base::`<<-`
[13:19:07.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:07.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:07.280]                   3L)]
[13:19:07.280]             }
[13:19:07.280]             function(cond) {
[13:19:07.280]                 is_error <- inherits(cond, "error")
[13:19:07.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:07.280]                   NULL)
[13:19:07.280]                 if (is_error) {
[13:19:07.280]                   sessionInformation <- function() {
[13:19:07.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:07.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:07.280]                       search = base::search(), system = base::Sys.info())
[13:19:07.280]                   }
[13:19:07.280]                   ...future.conditions[[length(...future.conditions) + 
[13:19:07.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:07.280]                     cond$call), session = sessionInformation(), 
[13:19:07.280]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:07.280]                   signalCondition(cond)
[13:19:07.280]                 }
[13:19:07.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:07.280]                 "immediateCondition"))) {
[13:19:07.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:07.280]                   ...future.conditions[[length(...future.conditions) + 
[13:19:07.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:07.280]                   if (TRUE && !signal) {
[13:19:07.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:07.280]                     {
[13:19:07.280]                       inherits <- base::inherits
[13:19:07.280]                       invokeRestart <- base::invokeRestart
[13:19:07.280]                       is.null <- base::is.null
[13:19:07.280]                       muffled <- FALSE
[13:19:07.280]                       if (inherits(cond, "message")) {
[13:19:07.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:07.280]                         if (muffled) 
[13:19:07.280]                           invokeRestart("muffleMessage")
[13:19:07.280]                       }
[13:19:07.280]                       else if (inherits(cond, "warning")) {
[13:19:07.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:07.280]                         if (muffled) 
[13:19:07.280]                           invokeRestart("muffleWarning")
[13:19:07.280]                       }
[13:19:07.280]                       else if (inherits(cond, "condition")) {
[13:19:07.280]                         if (!is.null(pattern)) {
[13:19:07.280]                           computeRestarts <- base::computeRestarts
[13:19:07.280]                           grepl <- base::grepl
[13:19:07.280]                           restarts <- computeRestarts(cond)
[13:19:07.280]                           for (restart in restarts) {
[13:19:07.280]                             name <- restart$name
[13:19:07.280]                             if (is.null(name)) 
[13:19:07.280]                               next
[13:19:07.280]                             if (!grepl(pattern, name)) 
[13:19:07.280]                               next
[13:19:07.280]                             invokeRestart(restart)
[13:19:07.280]                             muffled <- TRUE
[13:19:07.280]                             break
[13:19:07.280]                           }
[13:19:07.280]                         }
[13:19:07.280]                       }
[13:19:07.280]                       invisible(muffled)
[13:19:07.280]                     }
[13:19:07.280]                     muffleCondition(cond, pattern = "^muffle")
[13:19:07.280]                   }
[13:19:07.280]                 }
[13:19:07.280]                 else {
[13:19:07.280]                   if (TRUE) {
[13:19:07.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:07.280]                     {
[13:19:07.280]                       inherits <- base::inherits
[13:19:07.280]                       invokeRestart <- base::invokeRestart
[13:19:07.280]                       is.null <- base::is.null
[13:19:07.280]                       muffled <- FALSE
[13:19:07.280]                       if (inherits(cond, "message")) {
[13:19:07.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:07.280]                         if (muffled) 
[13:19:07.280]                           invokeRestart("muffleMessage")
[13:19:07.280]                       }
[13:19:07.280]                       else if (inherits(cond, "warning")) {
[13:19:07.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:07.280]                         if (muffled) 
[13:19:07.280]                           invokeRestart("muffleWarning")
[13:19:07.280]                       }
[13:19:07.280]                       else if (inherits(cond, "condition")) {
[13:19:07.280]                         if (!is.null(pattern)) {
[13:19:07.280]                           computeRestarts <- base::computeRestarts
[13:19:07.280]                           grepl <- base::grepl
[13:19:07.280]                           restarts <- computeRestarts(cond)
[13:19:07.280]                           for (restart in restarts) {
[13:19:07.280]                             name <- restart$name
[13:19:07.280]                             if (is.null(name)) 
[13:19:07.280]                               next
[13:19:07.280]                             if (!grepl(pattern, name)) 
[13:19:07.280]                               next
[13:19:07.280]                             invokeRestart(restart)
[13:19:07.280]                             muffled <- TRUE
[13:19:07.280]                             break
[13:19:07.280]                           }
[13:19:07.280]                         }
[13:19:07.280]                       }
[13:19:07.280]                       invisible(muffled)
[13:19:07.280]                     }
[13:19:07.280]                     muffleCondition(cond, pattern = "^muffle")
[13:19:07.280]                   }
[13:19:07.280]                 }
[13:19:07.280]             }
[13:19:07.280]         }))
[13:19:07.280]     }, error = function(ex) {
[13:19:07.280]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:07.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:07.280]                 ...future.rng), started = ...future.startTime, 
[13:19:07.280]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:07.280]             version = "1.8"), class = "FutureResult")
[13:19:07.280]     }, finally = {
[13:19:07.280]         if (!identical(...future.workdir, getwd())) 
[13:19:07.280]             setwd(...future.workdir)
[13:19:07.280]         {
[13:19:07.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:07.280]                 ...future.oldOptions$nwarnings <- NULL
[13:19:07.280]             }
[13:19:07.280]             base::options(...future.oldOptions)
[13:19:07.280]             if (.Platform$OS.type == "windows") {
[13:19:07.280]                 old_names <- names(...future.oldEnvVars)
[13:19:07.280]                 envs <- base::Sys.getenv()
[13:19:07.280]                 names <- names(envs)
[13:19:07.280]                 common <- intersect(names, old_names)
[13:19:07.280]                 added <- setdiff(names, old_names)
[13:19:07.280]                 removed <- setdiff(old_names, names)
[13:19:07.280]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:07.280]                   envs[common]]
[13:19:07.280]                 NAMES <- toupper(changed)
[13:19:07.280]                 args <- list()
[13:19:07.280]                 for (kk in seq_along(NAMES)) {
[13:19:07.280]                   name <- changed[[kk]]
[13:19:07.280]                   NAME <- NAMES[[kk]]
[13:19:07.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:07.280]                     next
[13:19:07.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:07.280]                 }
[13:19:07.280]                 NAMES <- toupper(added)
[13:19:07.280]                 for (kk in seq_along(NAMES)) {
[13:19:07.280]                   name <- added[[kk]]
[13:19:07.280]                   NAME <- NAMES[[kk]]
[13:19:07.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:07.280]                     next
[13:19:07.280]                   args[[name]] <- ""
[13:19:07.280]                 }
[13:19:07.280]                 NAMES <- toupper(removed)
[13:19:07.280]                 for (kk in seq_along(NAMES)) {
[13:19:07.280]                   name <- removed[[kk]]
[13:19:07.280]                   NAME <- NAMES[[kk]]
[13:19:07.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:07.280]                     next
[13:19:07.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:07.280]                 }
[13:19:07.280]                 if (length(args) > 0) 
[13:19:07.280]                   base::do.call(base::Sys.setenv, args = args)
[13:19:07.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:07.280]             }
[13:19:07.280]             else {
[13:19:07.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:07.280]             }
[13:19:07.280]             {
[13:19:07.280]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:07.280]                   0L) {
[13:19:07.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:07.280]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:07.280]                   base::options(opts)
[13:19:07.280]                 }
[13:19:07.280]                 {
[13:19:07.280]                   {
[13:19:07.280]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:07.280]                     NULL
[13:19:07.280]                   }
[13:19:07.280]                   options(future.plan = NULL)
[13:19:07.280]                   if (is.na(NA_character_)) 
[13:19:07.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:07.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:07.280]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:07.280]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:07.280]                     envir = parent.frame()) 
[13:19:07.280]                   {
[13:19:07.280]                     if (is.function(workers)) 
[13:19:07.280]                       workers <- workers()
[13:19:07.280]                     workers <- structure(as.integer(workers), 
[13:19:07.280]                       class = class(workers))
[13:19:07.280]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:07.280]                       workers >= 1)
[13:19:07.280]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:07.280]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:07.280]                     }
[13:19:07.280]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:07.280]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:07.280]                       envir = envir)
[13:19:07.280]                     if (!future$lazy) 
[13:19:07.280]                       future <- run(future)
[13:19:07.280]                     invisible(future)
[13:19:07.280]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:07.280]                 }
[13:19:07.280]             }
[13:19:07.280]         }
[13:19:07.280]     })
[13:19:07.280]     if (TRUE) {
[13:19:07.280]         base::sink(type = "output", split = FALSE)
[13:19:07.280]         if (TRUE) {
[13:19:07.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:07.280]         }
[13:19:07.280]         else {
[13:19:07.280]             ...future.result["stdout"] <- base::list(NULL)
[13:19:07.280]         }
[13:19:07.280]         base::close(...future.stdout)
[13:19:07.280]         ...future.stdout <- NULL
[13:19:07.280]     }
[13:19:07.280]     ...future.result$conditions <- ...future.conditions
[13:19:07.280]     ...future.result$finished <- base::Sys.time()
[13:19:07.280]     ...future.result
[13:19:07.280] }
[13:19:07.283] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[13:19:07.283] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:19:07.325] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:19:07.325] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[13:19:07.326] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[13:19:07.326] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:19:07.326] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:19:07.326] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:19:07.369] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:19:07.369] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:19:07.413] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:19:07.413] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:19:07.414] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:19:07.414] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:19:07.414] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:19:07.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:07.415] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:07.415] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:07.415] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:07.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:07.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:07.416] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:07.416] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:07.416] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[13:19:07.417] MultisessionFuture started
[13:19:07.417] - Launch lazy future ... done
[13:19:07.417] run() for ‘MultisessionFuture’ ... done
[13:19:07.417] Created future:
[13:19:07.417] MultisessionFuture:
[13:19:07.417] Label: ‘future_vapply-2’
[13:19:07.417] Expression:
[13:19:07.417] {
[13:19:07.417]     do.call(function(...) {
[13:19:07.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:07.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:07.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:07.417]             on.exit(options(oopts), add = TRUE)
[13:19:07.417]         }
[13:19:07.417]         {
[13:19:07.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:07.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:07.417]                 ...future.FUN(...future.X_jj, ...)
[13:19:07.417]             })
[13:19:07.417]         }
[13:19:07.417]     }, args = future.call.arguments)
[13:19:07.417] }
[13:19:07.417] Lazy evaluation: FALSE
[13:19:07.417] Asynchronous evaluation: TRUE
[13:19:07.417] Local evaluation: TRUE
[13:19:07.417] Environment: R_GlobalEnv
[13:19:07.417] Capture standard output: TRUE
[13:19:07.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:07.417] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:19:07.417] Packages: 1 packages (‘future.apply’)
[13:19:07.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:07.417] Resolved: FALSE
[13:19:07.417] Value: <not collected>
[13:19:07.417] Conditions captured: <none>
[13:19:07.417] Early signaling: FALSE
[13:19:07.417] Owner process: 6164ea14-cf98-2201-f112-77bbfcb17ea9
[13:19:07.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:07.429] Chunk #2 of 2 ... DONE
[13:19:07.429] Launching 2 futures (chunks) ... DONE
[13:19:07.429] Resolving 2 futures (chunks) ...
[13:19:07.429] resolve() on list ...
[13:19:07.429]  recursive: 0
[13:19:07.429]  length: 2
[13:19:07.429] 
[13:19:07.430] receiveMessageFromWorker() for ClusterFuture ...
[13:19:07.430] - Validating connection of MultisessionFuture
[13:19:07.430] - received message: FutureResult
[13:19:07.431] - Received FutureResult
[13:19:07.431] - Erased future from FutureRegistry
[13:19:07.431] result() for ClusterFuture ...
[13:19:07.431] - result already collected: FutureResult
[13:19:07.431] result() for ClusterFuture ... done
[13:19:07.431] signalConditions() ...
[13:19:07.431]  - include = ‘immediateCondition’
[13:19:07.431]  - exclude = 
[13:19:07.431]  - resignal = FALSE
[13:19:07.431]  - Number of conditions: 1
[13:19:07.431] signalConditions() ... done
[13:19:07.432] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:07.432] Future #1
[13:19:07.432] result() for ClusterFuture ...
[13:19:07.432] - result already collected: FutureResult
[13:19:07.432] result() for ClusterFuture ... done
[13:19:07.432] result() for ClusterFuture ...
[13:19:07.432] - result already collected: FutureResult
[13:19:07.432] result() for ClusterFuture ... done
[13:19:07.432] signalConditions() ...
[13:19:07.432]  - include = ‘immediateCondition’
[13:19:07.432]  - exclude = 
[13:19:07.433]  - resignal = FALSE
[13:19:07.433]  - Number of conditions: 1
[13:19:07.433] signalConditions() ... done
[13:19:07.433] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:07.433] - nx: 2
[13:19:07.433] - relay: TRUE
[13:19:07.433] - stdout: TRUE
[13:19:07.433] - signal: TRUE
[13:19:07.433] - resignal: FALSE
[13:19:07.433] - force: TRUE
[13:19:07.433] - relayed: [n=2] FALSE, FALSE
[13:19:07.434] - queued futures: [n=2] FALSE, FALSE
[13:19:07.434]  - until=1
[13:19:07.434]  - relaying element #1
[13:19:07.434] result() for ClusterFuture ...
[13:19:07.434] - result already collected: FutureResult
[13:19:07.434] result() for ClusterFuture ... done
[13:19:07.434] result() for ClusterFuture ...
[13:19:07.434] - result already collected: FutureResult
[13:19:07.434] result() for ClusterFuture ... done
[13:19:07.434] signalConditions() ...
[13:19:07.434]  - include = ‘immediateCondition’
[13:19:07.434]  - exclude = 
[13:19:07.435]  - resignal = FALSE
[13:19:07.435]  - Number of conditions: 1
[13:19:07.435] signalConditions() ... done
[13:19:07.435] result() for ClusterFuture ...
[13:19:07.435] - result already collected: FutureResult
[13:19:07.435] result() for ClusterFuture ... done
[13:19:07.435] signalConditions() ...
[13:19:07.435]  - include = ‘immediateCondition’
[13:19:07.435]  - exclude = 
[13:19:07.435]  - resignal = FALSE
[13:19:07.435]  - Number of conditions: 1
[13:19:07.436] signalConditions() ... done
[13:19:07.436] result() for ClusterFuture ...
[13:19:07.436] - result already collected: FutureResult
[13:19:07.436] result() for ClusterFuture ... done
[13:19:07.436] signalConditions() ...
[13:19:07.436]  - include = ‘condition’
[13:19:07.436]  - exclude = ‘immediateCondition’
[13:19:07.436]  - resignal = TRUE
[13:19:07.436]  - Number of conditions: 1
[13:19:07.436]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:19:07.436] signalConditions() ... done
[13:19:07.437] - relayed: [n=2] FALSE, FALSE
[13:19:07.437] - queued futures: [n=2] TRUE, FALSE
[13:19:07.437] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:07.437] plan(): Setting new future strategy stack:
[13:19:07.437] List of future strategies:
[13:19:07.437] 1. sequential:
[13:19:07.437]    - args: function (..., envir = parent.frame())
[13:19:07.437]    - tweaked: FALSE
[13:19:07.437]    - call: plan(sequential)
[13:19:07.438] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[13:19:07.439] plan(): Setting new future strategy stack:
[13:19:07.439] List of future strategies:
[13:19:07.439] 1. FutureStrategy:
[13:19:07.439]    - args: function (..., envir = parent.frame())
[13:19:07.439]    - tweaked: FALSE
[13:19:07.439]    - call: future::plan(oplan)
[13:19:07.439] plan(): nbrOfWorkers() = 1
> 
