
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:40:53.441] plan(): Setting new future strategy stack:
[17:40:53.442] List of future strategies:
[17:40:53.442] 1. sequential:
[17:40:53.442]    - args: function (..., envir = parent.frame())
[17:40:53.442]    - tweaked: FALSE
[17:40:53.442]    - call: future::plan("sequential")
[17:40:53.452] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:40:53.557] plan(): Setting new future strategy stack:
[17:40:53.557] List of future strategies:
[17:40:53.557] 1. sequential:
[17:40:53.557]    - args: function (..., envir = parent.frame())
[17:40:53.557]    - tweaked: FALSE
[17:40:53.557]    - call: plan(strategy)
[17:40:53.569] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:40:53.575] future_lapply() ...
[17:40:53.581] Number of chunks: 1
[17:40:53.581] getGlobalsAndPackagesXApply() ...
[17:40:53.581]  - future.globals: TRUE
[17:40:53.582] getGlobalsAndPackages() ...
[17:40:53.582] Searching for globals...
[17:40:53.586] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:53.586] Searching for globals ... DONE
[17:40:53.586] Resolving globals: FALSE
[17:40:53.588] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:40:53.589] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.589] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.589] - packages: [1] ‘future.apply’
[17:40:53.589] getGlobalsAndPackages() ... DONE
[17:40:53.589]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.589]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.589] Finding globals ... DONE
[17:40:53.589]  - use_args: TRUE
[17:40:53.589]  - Getting '...' globals ...
[17:40:53.590] resolve() on list ...
[17:40:53.590]  recursive: 0
[17:40:53.591]  length: 1
[17:40:53.591]  elements: ‘...’
[17:40:53.591]  length: 0 (resolved future 1)
[17:40:53.591] resolve() on list ... DONE
[17:40:53.591]    - '...' content: [n=0] 
[17:40:53.591] List of 1
[17:40:53.591]  $ ...: list()
[17:40:53.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.591]  - attr(*, "where")=List of 1
[17:40:53.591]   ..$ ...:<environment: 0x564f30171100> 
[17:40:53.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.591]  - attr(*, "resolved")= logi TRUE
[17:40:53.591]  - attr(*, "total_size")= num NA
[17:40:53.596]  - Getting '...' globals ... DONE
[17:40:53.596] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.596] List of 8
[17:40:53.596]  $ ...future.FUN:function (x, ...)  
[17:40:53.596]  $ x_FUN        :function (x)  
[17:40:53.596]  $ times        : int 1
[17:40:53.596]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.596]  $ stop_if_not  :function (...)  
[17:40:53.596]  $ dim          : NULL
[17:40:53.596]  $ valid_types  : chr "character"
[17:40:53.596]  $ ...          : list()
[17:40:53.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.596]  - attr(*, "where")=List of 8
[17:40:53.596]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.596]   ..$ ...          :<environment: 0x564f30171100> 
[17:40:53.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.596]  - attr(*, "resolved")= logi FALSE
[17:40:53.596]  - attr(*, "total_size")= num 94208
[17:40:53.602] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.602] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.602] Number of futures (= number of chunks): 1
[17:40:53.602] Launching 1 futures (chunks) ...
[17:40:53.602] Chunk #1 of 1 ...
[17:40:53.602]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.603] getGlobalsAndPackages() ...
[17:40:53.603] Searching for globals...
[17:40:53.603] 
[17:40:53.603] Searching for globals ... DONE
[17:40:53.603] - globals: [0] <none>
[17:40:53.603] getGlobalsAndPackages() ... DONE
[17:40:53.603]    + additional globals found: [n=0] 
[17:40:53.603]    + additional namespaces needed: [n=0] 
[17:40:53.604]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.604]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:53.604]  - seeds: <none>
[17:40:53.604] getGlobalsAndPackages() ...
[17:40:53.604] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.604] Resolving globals: FALSE
[17:40:53.604] Tweak future expression to call with '...' arguments ...
[17:40:53.604] {
[17:40:53.604]     do.call(function(...) {
[17:40:53.604]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.604]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.604]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.604]             on.exit(options(oopts), add = TRUE)
[17:40:53.604]         }
[17:40:53.604]         {
[17:40:53.604]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.604]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.604]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.604]             })
[17:40:53.604]         }
[17:40:53.604]     }, args = future.call.arguments)
[17:40:53.604] }
[17:40:53.605] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.605] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.605] - packages: [1] ‘future.apply’
[17:40:53.605] getGlobalsAndPackages() ... DONE
[17:40:53.606] run() for ‘Future’ ...
[17:40:53.606] - state: ‘created’
[17:40:53.607] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.607] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.607]   - Field: ‘label’
[17:40:53.607]   - Field: ‘local’
[17:40:53.607]   - Field: ‘owner’
[17:40:53.607]   - Field: ‘envir’
[17:40:53.608]   - Field: ‘packages’
[17:40:53.608]   - Field: ‘gc’
[17:40:53.608]   - Field: ‘conditions’
[17:40:53.608]   - Field: ‘expr’
[17:40:53.608]   - Field: ‘uuid’
[17:40:53.608]   - Field: ‘seed’
[17:40:53.608]   - Field: ‘version’
[17:40:53.608]   - Field: ‘result’
[17:40:53.608]   - Field: ‘asynchronous’
[17:40:53.608]   - Field: ‘calls’
[17:40:53.608]   - Field: ‘globals’
[17:40:53.609]   - Field: ‘stdout’
[17:40:53.609]   - Field: ‘earlySignal’
[17:40:53.609]   - Field: ‘lazy’
[17:40:53.609]   - Field: ‘state’
[17:40:53.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.609] - Launch lazy future ...
[17:40:53.610] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.610] Packages needed by future strategies (n = 0): <none>
[17:40:53.611] {
[17:40:53.611]     {
[17:40:53.611]         {
[17:40:53.611]             ...future.startTime <- base::Sys.time()
[17:40:53.611]             {
[17:40:53.611]                 {
[17:40:53.611]                   {
[17:40:53.611]                     {
[17:40:53.611]                       base::local({
[17:40:53.611]                         has_future <- base::requireNamespace("future", 
[17:40:53.611]                           quietly = TRUE)
[17:40:53.611]                         if (has_future) {
[17:40:53.611]                           ns <- base::getNamespace("future")
[17:40:53.611]                           version <- ns[[".package"]][["version"]]
[17:40:53.611]                           if (is.null(version)) 
[17:40:53.611]                             version <- utils::packageVersion("future")
[17:40:53.611]                         }
[17:40:53.611]                         else {
[17:40:53.611]                           version <- NULL
[17:40:53.611]                         }
[17:40:53.611]                         if (!has_future || version < "1.8.0") {
[17:40:53.611]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.611]                             "", base::R.version$version.string), 
[17:40:53.611]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.611]                               "release", "version")], collapse = " "), 
[17:40:53.611]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.611]                             info)
[17:40:53.611]                           info <- base::paste(info, collapse = "; ")
[17:40:53.611]                           if (!has_future) {
[17:40:53.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.611]                               info)
[17:40:53.611]                           }
[17:40:53.611]                           else {
[17:40:53.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.611]                               info, version)
[17:40:53.611]                           }
[17:40:53.611]                           base::stop(msg)
[17:40:53.611]                         }
[17:40:53.611]                       })
[17:40:53.611]                     }
[17:40:53.611]                     base::local({
[17:40:53.611]                       for (pkg in "future.apply") {
[17:40:53.611]                         base::loadNamespace(pkg)
[17:40:53.611]                         base::library(pkg, character.only = TRUE)
[17:40:53.611]                       }
[17:40:53.611]                     })
[17:40:53.611]                   }
[17:40:53.611]                   options(future.plan = NULL)
[17:40:53.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.611]                 }
[17:40:53.611]                 ...future.workdir <- getwd()
[17:40:53.611]             }
[17:40:53.611]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.611]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.611]         }
[17:40:53.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.611]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:53.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.611]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.611]             base::names(...future.oldOptions))
[17:40:53.611]     }
[17:40:53.611]     if (FALSE) {
[17:40:53.611]     }
[17:40:53.611]     else {
[17:40:53.611]         if (TRUE) {
[17:40:53.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.611]                 open = "w")
[17:40:53.611]         }
[17:40:53.611]         else {
[17:40:53.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.611]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.611]         }
[17:40:53.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.611]             base::sink(type = "output", split = FALSE)
[17:40:53.611]             base::close(...future.stdout)
[17:40:53.611]         }, add = TRUE)
[17:40:53.611]     }
[17:40:53.611]     ...future.frame <- base::sys.nframe()
[17:40:53.611]     ...future.conditions <- base::list()
[17:40:53.611]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.611]     if (FALSE) {
[17:40:53.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.611]     }
[17:40:53.611]     ...future.result <- base::tryCatch({
[17:40:53.611]         base::withCallingHandlers({
[17:40:53.611]             ...future.value <- base::withVisible(base::local({
[17:40:53.611]                 do.call(function(...) {
[17:40:53.611]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.611]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.611]                     ...future.globals.maxSize)) {
[17:40:53.611]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.611]                     on.exit(options(oopts), add = TRUE)
[17:40:53.611]                   }
[17:40:53.611]                   {
[17:40:53.611]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.611]                       FUN = function(jj) {
[17:40:53.611]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.611]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.611]                       })
[17:40:53.611]                   }
[17:40:53.611]                 }, args = future.call.arguments)
[17:40:53.611]             }))
[17:40:53.611]             future::FutureResult(value = ...future.value$value, 
[17:40:53.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.611]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.611]                     ...future.globalenv.names))
[17:40:53.611]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.611]         }, condition = base::local({
[17:40:53.611]             c <- base::c
[17:40:53.611]             inherits <- base::inherits
[17:40:53.611]             invokeRestart <- base::invokeRestart
[17:40:53.611]             length <- base::length
[17:40:53.611]             list <- base::list
[17:40:53.611]             seq.int <- base::seq.int
[17:40:53.611]             signalCondition <- base::signalCondition
[17:40:53.611]             sys.calls <- base::sys.calls
[17:40:53.611]             `[[` <- base::`[[`
[17:40:53.611]             `+` <- base::`+`
[17:40:53.611]             `<<-` <- base::`<<-`
[17:40:53.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.611]                   3L)]
[17:40:53.611]             }
[17:40:53.611]             function(cond) {
[17:40:53.611]                 is_error <- inherits(cond, "error")
[17:40:53.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.611]                   NULL)
[17:40:53.611]                 if (is_error) {
[17:40:53.611]                   sessionInformation <- function() {
[17:40:53.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.611]                       search = base::search(), system = base::Sys.info())
[17:40:53.611]                   }
[17:40:53.611]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.611]                     cond$call), session = sessionInformation(), 
[17:40:53.611]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.611]                   signalCondition(cond)
[17:40:53.611]                 }
[17:40:53.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.611]                 "immediateCondition"))) {
[17:40:53.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.611]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.611]                   if (TRUE && !signal) {
[17:40:53.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.611]                     {
[17:40:53.611]                       inherits <- base::inherits
[17:40:53.611]                       invokeRestart <- base::invokeRestart
[17:40:53.611]                       is.null <- base::is.null
[17:40:53.611]                       muffled <- FALSE
[17:40:53.611]                       if (inherits(cond, "message")) {
[17:40:53.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.611]                         if (muffled) 
[17:40:53.611]                           invokeRestart("muffleMessage")
[17:40:53.611]                       }
[17:40:53.611]                       else if (inherits(cond, "warning")) {
[17:40:53.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.611]                         if (muffled) 
[17:40:53.611]                           invokeRestart("muffleWarning")
[17:40:53.611]                       }
[17:40:53.611]                       else if (inherits(cond, "condition")) {
[17:40:53.611]                         if (!is.null(pattern)) {
[17:40:53.611]                           computeRestarts <- base::computeRestarts
[17:40:53.611]                           grepl <- base::grepl
[17:40:53.611]                           restarts <- computeRestarts(cond)
[17:40:53.611]                           for (restart in restarts) {
[17:40:53.611]                             name <- restart$name
[17:40:53.611]                             if (is.null(name)) 
[17:40:53.611]                               next
[17:40:53.611]                             if (!grepl(pattern, name)) 
[17:40:53.611]                               next
[17:40:53.611]                             invokeRestart(restart)
[17:40:53.611]                             muffled <- TRUE
[17:40:53.611]                             break
[17:40:53.611]                           }
[17:40:53.611]                         }
[17:40:53.611]                       }
[17:40:53.611]                       invisible(muffled)
[17:40:53.611]                     }
[17:40:53.611]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.611]                   }
[17:40:53.611]                 }
[17:40:53.611]                 else {
[17:40:53.611]                   if (TRUE) {
[17:40:53.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.611]                     {
[17:40:53.611]                       inherits <- base::inherits
[17:40:53.611]                       invokeRestart <- base::invokeRestart
[17:40:53.611]                       is.null <- base::is.null
[17:40:53.611]                       muffled <- FALSE
[17:40:53.611]                       if (inherits(cond, "message")) {
[17:40:53.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.611]                         if (muffled) 
[17:40:53.611]                           invokeRestart("muffleMessage")
[17:40:53.611]                       }
[17:40:53.611]                       else if (inherits(cond, "warning")) {
[17:40:53.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.611]                         if (muffled) 
[17:40:53.611]                           invokeRestart("muffleWarning")
[17:40:53.611]                       }
[17:40:53.611]                       else if (inherits(cond, "condition")) {
[17:40:53.611]                         if (!is.null(pattern)) {
[17:40:53.611]                           computeRestarts <- base::computeRestarts
[17:40:53.611]                           grepl <- base::grepl
[17:40:53.611]                           restarts <- computeRestarts(cond)
[17:40:53.611]                           for (restart in restarts) {
[17:40:53.611]                             name <- restart$name
[17:40:53.611]                             if (is.null(name)) 
[17:40:53.611]                               next
[17:40:53.611]                             if (!grepl(pattern, name)) 
[17:40:53.611]                               next
[17:40:53.611]                             invokeRestart(restart)
[17:40:53.611]                             muffled <- TRUE
[17:40:53.611]                             break
[17:40:53.611]                           }
[17:40:53.611]                         }
[17:40:53.611]                       }
[17:40:53.611]                       invisible(muffled)
[17:40:53.611]                     }
[17:40:53.611]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.611]                   }
[17:40:53.611]                 }
[17:40:53.611]             }
[17:40:53.611]         }))
[17:40:53.611]     }, error = function(ex) {
[17:40:53.611]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.611]                 ...future.rng), started = ...future.startTime, 
[17:40:53.611]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.611]             version = "1.8"), class = "FutureResult")
[17:40:53.611]     }, finally = {
[17:40:53.611]         if (!identical(...future.workdir, getwd())) 
[17:40:53.611]             setwd(...future.workdir)
[17:40:53.611]         {
[17:40:53.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.611]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.611]             }
[17:40:53.611]             base::options(...future.oldOptions)
[17:40:53.611]             if (.Platform$OS.type == "windows") {
[17:40:53.611]                 old_names <- names(...future.oldEnvVars)
[17:40:53.611]                 envs <- base::Sys.getenv()
[17:40:53.611]                 names <- names(envs)
[17:40:53.611]                 common <- intersect(names, old_names)
[17:40:53.611]                 added <- setdiff(names, old_names)
[17:40:53.611]                 removed <- setdiff(old_names, names)
[17:40:53.611]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.611]                   envs[common]]
[17:40:53.611]                 NAMES <- toupper(changed)
[17:40:53.611]                 args <- list()
[17:40:53.611]                 for (kk in seq_along(NAMES)) {
[17:40:53.611]                   name <- changed[[kk]]
[17:40:53.611]                   NAME <- NAMES[[kk]]
[17:40:53.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.611]                     next
[17:40:53.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.611]                 }
[17:40:53.611]                 NAMES <- toupper(added)
[17:40:53.611]                 for (kk in seq_along(NAMES)) {
[17:40:53.611]                   name <- added[[kk]]
[17:40:53.611]                   NAME <- NAMES[[kk]]
[17:40:53.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.611]                     next
[17:40:53.611]                   args[[name]] <- ""
[17:40:53.611]                 }
[17:40:53.611]                 NAMES <- toupper(removed)
[17:40:53.611]                 for (kk in seq_along(NAMES)) {
[17:40:53.611]                   name <- removed[[kk]]
[17:40:53.611]                   NAME <- NAMES[[kk]]
[17:40:53.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.611]                     next
[17:40:53.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.611]                 }
[17:40:53.611]                 if (length(args) > 0) 
[17:40:53.611]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.611]             }
[17:40:53.611]             else {
[17:40:53.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.611]             }
[17:40:53.611]             {
[17:40:53.611]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.611]                   0L) {
[17:40:53.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.611]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.611]                   base::options(opts)
[17:40:53.611]                 }
[17:40:53.611]                 {
[17:40:53.611]                   {
[17:40:53.611]                     NULL
[17:40:53.611]                     RNGkind("Mersenne-Twister")
[17:40:53.611]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.611]                       inherits = FALSE)
[17:40:53.611]                   }
[17:40:53.611]                   options(future.plan = NULL)
[17:40:53.611]                   if (is.na(NA_character_)) 
[17:40:53.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.611]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.611]                   {
[17:40:53.611]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.611]                     if (!future$lazy) 
[17:40:53.611]                       future <- run(future)
[17:40:53.611]                     invisible(future)
[17:40:53.611]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.611]                 }
[17:40:53.611]             }
[17:40:53.611]         }
[17:40:53.611]     })
[17:40:53.611]     if (TRUE) {
[17:40:53.611]         base::sink(type = "output", split = FALSE)
[17:40:53.611]         if (TRUE) {
[17:40:53.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.611]         }
[17:40:53.611]         else {
[17:40:53.611]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.611]         }
[17:40:53.611]         base::close(...future.stdout)
[17:40:53.611]         ...future.stdout <- NULL
[17:40:53.611]     }
[17:40:53.611]     ...future.result$conditions <- ...future.conditions
[17:40:53.611]     ...future.result$finished <- base::Sys.time()
[17:40:53.611]     ...future.result
[17:40:53.611] }
[17:40:53.613] assign_globals() ...
[17:40:53.613] List of 11
[17:40:53.613]  $ ...future.FUN            :function (x, ...)  
[17:40:53.613]  $ x_FUN                    :function (x)  
[17:40:53.613]  $ times                    : int 1
[17:40:53.613]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.613]  $ stop_if_not              :function (...)  
[17:40:53.613]  $ dim                      : NULL
[17:40:53.613]  $ valid_types              : chr "character"
[17:40:53.613]  $ future.call.arguments    : list()
[17:40:53.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.613]  $ ...future.elements_ii    :List of 2
[17:40:53.613]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:40:53.613]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:40:53.613]  $ ...future.seeds_ii       : NULL
[17:40:53.613]  $ ...future.globals.maxSize: NULL
[17:40:53.613]  - attr(*, "resolved")= logi FALSE
[17:40:53.613]  - attr(*, "total_size")= num 94208
[17:40:53.613]  - attr(*, "where")=List of 11
[17:40:53.613]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.613]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.613]  - attr(*, "already-done")= logi TRUE
[17:40:53.622] - copied ‘...future.FUN’ to environment
[17:40:53.622] - copied ‘x_FUN’ to environment
[17:40:53.622] - copied ‘times’ to environment
[17:40:53.622] - copied ‘stopf’ to environment
[17:40:53.622] - copied ‘stop_if_not’ to environment
[17:40:53.622] - copied ‘dim’ to environment
[17:40:53.622] - copied ‘valid_types’ to environment
[17:40:53.623] - copied ‘future.call.arguments’ to environment
[17:40:53.623] - copied ‘...future.elements_ii’ to environment
[17:40:53.623] - copied ‘...future.seeds_ii’ to environment
[17:40:53.623] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.623] assign_globals() ... done
[17:40:53.623] plan(): Setting new future strategy stack:
[17:40:53.623] List of future strategies:
[17:40:53.623] 1. sequential:
[17:40:53.623]    - args: function (..., envir = parent.frame())
[17:40:53.623]    - tweaked: FALSE
[17:40:53.623]    - call: NULL
[17:40:53.624] plan(): nbrOfWorkers() = 1
[17:40:53.625] plan(): Setting new future strategy stack:
[17:40:53.625] List of future strategies:
[17:40:53.625] 1. sequential:
[17:40:53.625]    - args: function (..., envir = parent.frame())
[17:40:53.625]    - tweaked: FALSE
[17:40:53.625]    - call: plan(strategy)
[17:40:53.625] plan(): nbrOfWorkers() = 1
[17:40:53.626] SequentialFuture started (and completed)
[17:40:53.626] - Launch lazy future ... done
[17:40:53.626] run() for ‘SequentialFuture’ ... done
[17:40:53.626] Created future:
[17:40:53.626] SequentialFuture:
[17:40:53.626] Label: ‘future_vapply-1’
[17:40:53.626] Expression:
[17:40:53.626] {
[17:40:53.626]     do.call(function(...) {
[17:40:53.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.626]             on.exit(options(oopts), add = TRUE)
[17:40:53.626]         }
[17:40:53.626]         {
[17:40:53.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.626]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.626]             })
[17:40:53.626]         }
[17:40:53.626]     }, args = future.call.arguments)
[17:40:53.626] }
[17:40:53.626] Lazy evaluation: FALSE
[17:40:53.626] Asynchronous evaluation: FALSE
[17:40:53.626] Local evaluation: TRUE
[17:40:53.626] Environment: R_GlobalEnv
[17:40:53.626] Capture standard output: TRUE
[17:40:53.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.626] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.626] Packages: 1 packages (‘future.apply’)
[17:40:53.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.626] Resolved: TRUE
[17:40:53.626] Value: 232 bytes of class ‘list’
[17:40:53.626] Early signaling: FALSE
[17:40:53.626] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.626] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.628] Chunk #1 of 1 ... DONE
[17:40:53.628] Launching 1 futures (chunks) ... DONE
[17:40:53.628] Resolving 1 futures (chunks) ...
[17:40:53.628] resolve() on list ...
[17:40:53.628]  recursive: 0
[17:40:53.629]  length: 1
[17:40:53.629] 
[17:40:53.629] resolved() for ‘SequentialFuture’ ...
[17:40:53.629] - state: ‘finished’
[17:40:53.629] - run: TRUE
[17:40:53.629] - result: ‘FutureResult’
[17:40:53.629] resolved() for ‘SequentialFuture’ ... done
[17:40:53.629] Future #1
[17:40:53.630] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.630] - nx: 1
[17:40:53.630] - relay: TRUE
[17:40:53.630] - stdout: TRUE
[17:40:53.630] - signal: TRUE
[17:40:53.630] - resignal: FALSE
[17:40:53.630] - force: TRUE
[17:40:53.630] - relayed: [n=1] FALSE
[17:40:53.630] - queued futures: [n=1] FALSE
[17:40:53.630]  - until=1
[17:40:53.631]  - relaying element #1
[17:40:53.631] - relayed: [n=1] TRUE
[17:40:53.631] - queued futures: [n=1] TRUE
[17:40:53.631] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.631]  length: 0 (resolved future 1)
[17:40:53.631] Relaying remaining futures
[17:40:53.631] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.631] - nx: 1
[17:40:53.632] - relay: TRUE
[17:40:53.632] - stdout: TRUE
[17:40:53.632] - signal: TRUE
[17:40:53.632] - resignal: FALSE
[17:40:53.632] - force: TRUE
[17:40:53.632] - relayed: [n=1] TRUE
[17:40:53.632] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.632] - relayed: [n=1] TRUE
[17:40:53.632] - queued futures: [n=1] TRUE
[17:40:53.632] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.632] resolve() on list ... DONE
[17:40:53.633]  - Number of value chunks collected: 1
[17:40:53.633] Resolving 1 futures (chunks) ... DONE
[17:40:53.633] Reducing values from 1 chunks ...
[17:40:53.633]  - Number of values collected after concatenation: 2
[17:40:53.633]  - Number of values expected: 2
[17:40:53.633] Reducing values from 1 chunks ... DONE
[17:40:53.633] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:40:53.634] future_lapply() ...
[17:40:53.636] Number of chunks: 1
[17:40:53.636] getGlobalsAndPackagesXApply() ...
[17:40:53.636]  - future.globals: TRUE
[17:40:53.636] getGlobalsAndPackages() ...
[17:40:53.636] Searching for globals...
[17:40:53.640] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:40:53.640] Searching for globals ... DONE
[17:40:53.640] Resolving globals: FALSE
[17:40:53.641] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:40:53.641] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.641] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.641] - packages: [1] ‘future.apply’
[17:40:53.641] getGlobalsAndPackages() ... DONE
[17:40:53.641]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.642]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.642] Finding globals ... DONE
[17:40:53.642]  - use_args: TRUE
[17:40:53.642]  - Getting '...' globals ...
[17:40:53.642] resolve() on list ...
[17:40:53.642]  recursive: 0
[17:40:53.642]  length: 1
[17:40:53.642]  elements: ‘...’
[17:40:53.642]  length: 0 (resolved future 1)
[17:40:53.643] resolve() on list ... DONE
[17:40:53.643]    - '...' content: [n=0] 
[17:40:53.643] List of 1
[17:40:53.643]  $ ...: list()
[17:40:53.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.643]  - attr(*, "where")=List of 1
[17:40:53.643]   ..$ ...:<environment: 0x564f2ffffef8> 
[17:40:53.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.643]  - attr(*, "resolved")= logi TRUE
[17:40:53.643]  - attr(*, "total_size")= num NA
[17:40:53.647]  - Getting '...' globals ... DONE
[17:40:53.647] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.647] List of 8
[17:40:53.647]  $ ...future.FUN:function (x, ...)  
[17:40:53.647]  $ x_FUN        :function (x)  
[17:40:53.647]  $ times        : int 0
[17:40:53.647]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.647]  $ stop_if_not  :function (...)  
[17:40:53.647]  $ dim          : NULL
[17:40:53.647]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:53.647]  $ ...          : list()
[17:40:53.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.647]  - attr(*, "where")=List of 8
[17:40:53.647]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.647]   ..$ ...          :<environment: 0x564f2ffffef8> 
[17:40:53.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.647]  - attr(*, "resolved")= logi FALSE
[17:40:53.647]  - attr(*, "total_size")= num 95472
[17:40:53.652] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.652] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.652] Number of futures (= number of chunks): 1
[17:40:53.652] Launching 1 futures (chunks) ...
[17:40:53.653] Chunk #1 of 1 ...
[17:40:53.653]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.653] getGlobalsAndPackages() ...
[17:40:53.653] Searching for globals...
[17:40:53.653] 
[17:40:53.653] Searching for globals ... DONE
[17:40:53.653] - globals: [0] <none>
[17:40:53.653] getGlobalsAndPackages() ... DONE
[17:40:53.653]    + additional globals found: [n=0] 
[17:40:53.654]    + additional namespaces needed: [n=0] 
[17:40:53.654]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.654]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.654]  - seeds: <none>
[17:40:53.654] getGlobalsAndPackages() ...
[17:40:53.654] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.654] Resolving globals: FALSE
[17:40:53.654] Tweak future expression to call with '...' arguments ...
[17:40:53.654] {
[17:40:53.654]     do.call(function(...) {
[17:40:53.654]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.654]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.654]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.654]             on.exit(options(oopts), add = TRUE)
[17:40:53.654]         }
[17:40:53.654]         {
[17:40:53.654]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.654]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.654]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.654]             })
[17:40:53.654]         }
[17:40:53.654]     }, args = future.call.arguments)
[17:40:53.654] }
[17:40:53.655] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.655] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.655] - packages: [1] ‘future.apply’
[17:40:53.655] getGlobalsAndPackages() ... DONE
[17:40:53.656] run() for ‘Future’ ...
[17:40:53.656] - state: ‘created’
[17:40:53.656] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.656] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.656]   - Field: ‘label’
[17:40:53.656]   - Field: ‘local’
[17:40:53.657]   - Field: ‘owner’
[17:40:53.657]   - Field: ‘envir’
[17:40:53.657]   - Field: ‘packages’
[17:40:53.657]   - Field: ‘gc’
[17:40:53.657]   - Field: ‘conditions’
[17:40:53.657]   - Field: ‘expr’
[17:40:53.657]   - Field: ‘uuid’
[17:40:53.657]   - Field: ‘seed’
[17:40:53.657]   - Field: ‘version’
[17:40:53.657]   - Field: ‘result’
[17:40:53.657]   - Field: ‘asynchronous’
[17:40:53.658]   - Field: ‘calls’
[17:40:53.658]   - Field: ‘globals’
[17:40:53.658]   - Field: ‘stdout’
[17:40:53.658]   - Field: ‘earlySignal’
[17:40:53.658]   - Field: ‘lazy’
[17:40:53.658]   - Field: ‘state’
[17:40:53.658] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.658] - Launch lazy future ...
[17:40:53.658] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.659] Packages needed by future strategies (n = 0): <none>
[17:40:53.659] {
[17:40:53.659]     {
[17:40:53.659]         {
[17:40:53.659]             ...future.startTime <- base::Sys.time()
[17:40:53.659]             {
[17:40:53.659]                 {
[17:40:53.659]                   {
[17:40:53.659]                     {
[17:40:53.659]                       base::local({
[17:40:53.659]                         has_future <- base::requireNamespace("future", 
[17:40:53.659]                           quietly = TRUE)
[17:40:53.659]                         if (has_future) {
[17:40:53.659]                           ns <- base::getNamespace("future")
[17:40:53.659]                           version <- ns[[".package"]][["version"]]
[17:40:53.659]                           if (is.null(version)) 
[17:40:53.659]                             version <- utils::packageVersion("future")
[17:40:53.659]                         }
[17:40:53.659]                         else {
[17:40:53.659]                           version <- NULL
[17:40:53.659]                         }
[17:40:53.659]                         if (!has_future || version < "1.8.0") {
[17:40:53.659]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.659]                             "", base::R.version$version.string), 
[17:40:53.659]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.659]                               "release", "version")], collapse = " "), 
[17:40:53.659]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.659]                             info)
[17:40:53.659]                           info <- base::paste(info, collapse = "; ")
[17:40:53.659]                           if (!has_future) {
[17:40:53.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.659]                               info)
[17:40:53.659]                           }
[17:40:53.659]                           else {
[17:40:53.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.659]                               info, version)
[17:40:53.659]                           }
[17:40:53.659]                           base::stop(msg)
[17:40:53.659]                         }
[17:40:53.659]                       })
[17:40:53.659]                     }
[17:40:53.659]                     base::local({
[17:40:53.659]                       for (pkg in "future.apply") {
[17:40:53.659]                         base::loadNamespace(pkg)
[17:40:53.659]                         base::library(pkg, character.only = TRUE)
[17:40:53.659]                       }
[17:40:53.659]                     })
[17:40:53.659]                   }
[17:40:53.659]                   options(future.plan = NULL)
[17:40:53.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.659]                 }
[17:40:53.659]                 ...future.workdir <- getwd()
[17:40:53.659]             }
[17:40:53.659]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.659]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.659]         }
[17:40:53.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.659]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.659]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.659]             base::names(...future.oldOptions))
[17:40:53.659]     }
[17:40:53.659]     if (FALSE) {
[17:40:53.659]     }
[17:40:53.659]     else {
[17:40:53.659]         if (TRUE) {
[17:40:53.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.659]                 open = "w")
[17:40:53.659]         }
[17:40:53.659]         else {
[17:40:53.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.659]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.659]         }
[17:40:53.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.659]             base::sink(type = "output", split = FALSE)
[17:40:53.659]             base::close(...future.stdout)
[17:40:53.659]         }, add = TRUE)
[17:40:53.659]     }
[17:40:53.659]     ...future.frame <- base::sys.nframe()
[17:40:53.659]     ...future.conditions <- base::list()
[17:40:53.659]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.659]     if (FALSE) {
[17:40:53.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.659]     }
[17:40:53.659]     ...future.result <- base::tryCatch({
[17:40:53.659]         base::withCallingHandlers({
[17:40:53.659]             ...future.value <- base::withVisible(base::local({
[17:40:53.659]                 do.call(function(...) {
[17:40:53.659]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.659]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.659]                     ...future.globals.maxSize)) {
[17:40:53.659]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.659]                     on.exit(options(oopts), add = TRUE)
[17:40:53.659]                   }
[17:40:53.659]                   {
[17:40:53.659]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.659]                       FUN = function(jj) {
[17:40:53.659]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.659]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.659]                       })
[17:40:53.659]                   }
[17:40:53.659]                 }, args = future.call.arguments)
[17:40:53.659]             }))
[17:40:53.659]             future::FutureResult(value = ...future.value$value, 
[17:40:53.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.659]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.659]                     ...future.globalenv.names))
[17:40:53.659]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.659]         }, condition = base::local({
[17:40:53.659]             c <- base::c
[17:40:53.659]             inherits <- base::inherits
[17:40:53.659]             invokeRestart <- base::invokeRestart
[17:40:53.659]             length <- base::length
[17:40:53.659]             list <- base::list
[17:40:53.659]             seq.int <- base::seq.int
[17:40:53.659]             signalCondition <- base::signalCondition
[17:40:53.659]             sys.calls <- base::sys.calls
[17:40:53.659]             `[[` <- base::`[[`
[17:40:53.659]             `+` <- base::`+`
[17:40:53.659]             `<<-` <- base::`<<-`
[17:40:53.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.659]                   3L)]
[17:40:53.659]             }
[17:40:53.659]             function(cond) {
[17:40:53.659]                 is_error <- inherits(cond, "error")
[17:40:53.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.659]                   NULL)
[17:40:53.659]                 if (is_error) {
[17:40:53.659]                   sessionInformation <- function() {
[17:40:53.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.659]                       search = base::search(), system = base::Sys.info())
[17:40:53.659]                   }
[17:40:53.659]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.659]                     cond$call), session = sessionInformation(), 
[17:40:53.659]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.659]                   signalCondition(cond)
[17:40:53.659]                 }
[17:40:53.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.659]                 "immediateCondition"))) {
[17:40:53.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.659]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.659]                   if (TRUE && !signal) {
[17:40:53.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.659]                     {
[17:40:53.659]                       inherits <- base::inherits
[17:40:53.659]                       invokeRestart <- base::invokeRestart
[17:40:53.659]                       is.null <- base::is.null
[17:40:53.659]                       muffled <- FALSE
[17:40:53.659]                       if (inherits(cond, "message")) {
[17:40:53.659]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.659]                         if (muffled) 
[17:40:53.659]                           invokeRestart("muffleMessage")
[17:40:53.659]                       }
[17:40:53.659]                       else if (inherits(cond, "warning")) {
[17:40:53.659]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.659]                         if (muffled) 
[17:40:53.659]                           invokeRestart("muffleWarning")
[17:40:53.659]                       }
[17:40:53.659]                       else if (inherits(cond, "condition")) {
[17:40:53.659]                         if (!is.null(pattern)) {
[17:40:53.659]                           computeRestarts <- base::computeRestarts
[17:40:53.659]                           grepl <- base::grepl
[17:40:53.659]                           restarts <- computeRestarts(cond)
[17:40:53.659]                           for (restart in restarts) {
[17:40:53.659]                             name <- restart$name
[17:40:53.659]                             if (is.null(name)) 
[17:40:53.659]                               next
[17:40:53.659]                             if (!grepl(pattern, name)) 
[17:40:53.659]                               next
[17:40:53.659]                             invokeRestart(restart)
[17:40:53.659]                             muffled <- TRUE
[17:40:53.659]                             break
[17:40:53.659]                           }
[17:40:53.659]                         }
[17:40:53.659]                       }
[17:40:53.659]                       invisible(muffled)
[17:40:53.659]                     }
[17:40:53.659]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.659]                   }
[17:40:53.659]                 }
[17:40:53.659]                 else {
[17:40:53.659]                   if (TRUE) {
[17:40:53.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.659]                     {
[17:40:53.659]                       inherits <- base::inherits
[17:40:53.659]                       invokeRestart <- base::invokeRestart
[17:40:53.659]                       is.null <- base::is.null
[17:40:53.659]                       muffled <- FALSE
[17:40:53.659]                       if (inherits(cond, "message")) {
[17:40:53.659]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.659]                         if (muffled) 
[17:40:53.659]                           invokeRestart("muffleMessage")
[17:40:53.659]                       }
[17:40:53.659]                       else if (inherits(cond, "warning")) {
[17:40:53.659]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.659]                         if (muffled) 
[17:40:53.659]                           invokeRestart("muffleWarning")
[17:40:53.659]                       }
[17:40:53.659]                       else if (inherits(cond, "condition")) {
[17:40:53.659]                         if (!is.null(pattern)) {
[17:40:53.659]                           computeRestarts <- base::computeRestarts
[17:40:53.659]                           grepl <- base::grepl
[17:40:53.659]                           restarts <- computeRestarts(cond)
[17:40:53.659]                           for (restart in restarts) {
[17:40:53.659]                             name <- restart$name
[17:40:53.659]                             if (is.null(name)) 
[17:40:53.659]                               next
[17:40:53.659]                             if (!grepl(pattern, name)) 
[17:40:53.659]                               next
[17:40:53.659]                             invokeRestart(restart)
[17:40:53.659]                             muffled <- TRUE
[17:40:53.659]                             break
[17:40:53.659]                           }
[17:40:53.659]                         }
[17:40:53.659]                       }
[17:40:53.659]                       invisible(muffled)
[17:40:53.659]                     }
[17:40:53.659]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.659]                   }
[17:40:53.659]                 }
[17:40:53.659]             }
[17:40:53.659]         }))
[17:40:53.659]     }, error = function(ex) {
[17:40:53.659]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.659]                 ...future.rng), started = ...future.startTime, 
[17:40:53.659]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.659]             version = "1.8"), class = "FutureResult")
[17:40:53.659]     }, finally = {
[17:40:53.659]         if (!identical(...future.workdir, getwd())) 
[17:40:53.659]             setwd(...future.workdir)
[17:40:53.659]         {
[17:40:53.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.659]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.659]             }
[17:40:53.659]             base::options(...future.oldOptions)
[17:40:53.659]             if (.Platform$OS.type == "windows") {
[17:40:53.659]                 old_names <- names(...future.oldEnvVars)
[17:40:53.659]                 envs <- base::Sys.getenv()
[17:40:53.659]                 names <- names(envs)
[17:40:53.659]                 common <- intersect(names, old_names)
[17:40:53.659]                 added <- setdiff(names, old_names)
[17:40:53.659]                 removed <- setdiff(old_names, names)
[17:40:53.659]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.659]                   envs[common]]
[17:40:53.659]                 NAMES <- toupper(changed)
[17:40:53.659]                 args <- list()
[17:40:53.659]                 for (kk in seq_along(NAMES)) {
[17:40:53.659]                   name <- changed[[kk]]
[17:40:53.659]                   NAME <- NAMES[[kk]]
[17:40:53.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.659]                     next
[17:40:53.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.659]                 }
[17:40:53.659]                 NAMES <- toupper(added)
[17:40:53.659]                 for (kk in seq_along(NAMES)) {
[17:40:53.659]                   name <- added[[kk]]
[17:40:53.659]                   NAME <- NAMES[[kk]]
[17:40:53.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.659]                     next
[17:40:53.659]                   args[[name]] <- ""
[17:40:53.659]                 }
[17:40:53.659]                 NAMES <- toupper(removed)
[17:40:53.659]                 for (kk in seq_along(NAMES)) {
[17:40:53.659]                   name <- removed[[kk]]
[17:40:53.659]                   NAME <- NAMES[[kk]]
[17:40:53.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.659]                     next
[17:40:53.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.659]                 }
[17:40:53.659]                 if (length(args) > 0) 
[17:40:53.659]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.659]             }
[17:40:53.659]             else {
[17:40:53.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.659]             }
[17:40:53.659]             {
[17:40:53.659]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.659]                   0L) {
[17:40:53.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.659]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.659]                   base::options(opts)
[17:40:53.659]                 }
[17:40:53.659]                 {
[17:40:53.659]                   {
[17:40:53.659]                     NULL
[17:40:53.659]                     RNGkind("Mersenne-Twister")
[17:40:53.659]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.659]                       inherits = FALSE)
[17:40:53.659]                   }
[17:40:53.659]                   options(future.plan = NULL)
[17:40:53.659]                   if (is.na(NA_character_)) 
[17:40:53.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.659]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.659]                   {
[17:40:53.659]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.659]                     if (!future$lazy) 
[17:40:53.659]                       future <- run(future)
[17:40:53.659]                     invisible(future)
[17:40:53.659]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.659]                 }
[17:40:53.659]             }
[17:40:53.659]         }
[17:40:53.659]     })
[17:40:53.659]     if (TRUE) {
[17:40:53.659]         base::sink(type = "output", split = FALSE)
[17:40:53.659]         if (TRUE) {
[17:40:53.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.659]         }
[17:40:53.659]         else {
[17:40:53.659]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.659]         }
[17:40:53.659]         base::close(...future.stdout)
[17:40:53.659]         ...future.stdout <- NULL
[17:40:53.659]     }
[17:40:53.659]     ...future.result$conditions <- ...future.conditions
[17:40:53.659]     ...future.result$finished <- base::Sys.time()
[17:40:53.659]     ...future.result
[17:40:53.659] }
[17:40:53.661] assign_globals() ...
[17:40:53.661] List of 11
[17:40:53.661]  $ ...future.FUN            :function (x, ...)  
[17:40:53.661]  $ x_FUN                    :function (x)  
[17:40:53.661]  $ times                    : int 0
[17:40:53.661]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.661]  $ stop_if_not              :function (...)  
[17:40:53.661]  $ dim                      : NULL
[17:40:53.661]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:53.661]  $ future.call.arguments    : list()
[17:40:53.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.661]  $ ...future.elements_ii    :List of 10
[17:40:53.661]   ..$ : int 1
[17:40:53.661]   ..$ : int 2
[17:40:53.661]   ..$ : int 3
[17:40:53.661]   ..$ : int 4
[17:40:53.661]   ..$ : int 5
[17:40:53.661]   ..$ : int 6
[17:40:53.661]   ..$ : int 7
[17:40:53.661]   ..$ : int 8
[17:40:53.661]   ..$ : int 9
[17:40:53.661]   ..$ : int 10
[17:40:53.661]  $ ...future.seeds_ii       : NULL
[17:40:53.661]  $ ...future.globals.maxSize: NULL
[17:40:53.661]  - attr(*, "resolved")= logi FALSE
[17:40:53.661]  - attr(*, "total_size")= num 95472
[17:40:53.661]  - attr(*, "where")=List of 11
[17:40:53.661]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.661]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.661]  - attr(*, "already-done")= logi TRUE
[17:40:53.672] - copied ‘...future.FUN’ to environment
[17:40:53.672] - reassign environment for ‘x_FUN’
[17:40:53.672] - copied ‘x_FUN’ to environment
[17:40:53.672] - copied ‘times’ to environment
[17:40:53.672] - copied ‘stopf’ to environment
[17:40:53.672] - copied ‘stop_if_not’ to environment
[17:40:53.673] - copied ‘dim’ to environment
[17:40:53.673] - copied ‘valid_types’ to environment
[17:40:53.673] - copied ‘future.call.arguments’ to environment
[17:40:53.673] - copied ‘...future.elements_ii’ to environment
[17:40:53.673] - copied ‘...future.seeds_ii’ to environment
[17:40:53.673] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.673] assign_globals() ... done
[17:40:53.673] plan(): Setting new future strategy stack:
[17:40:53.674] List of future strategies:
[17:40:53.674] 1. sequential:
[17:40:53.674]    - args: function (..., envir = parent.frame())
[17:40:53.674]    - tweaked: FALSE
[17:40:53.674]    - call: NULL
[17:40:53.674] plan(): nbrOfWorkers() = 1
[17:40:53.675] plan(): Setting new future strategy stack:
[17:40:53.675] List of future strategies:
[17:40:53.675] 1. sequential:
[17:40:53.675]    - args: function (..., envir = parent.frame())
[17:40:53.675]    - tweaked: FALSE
[17:40:53.675]    - call: plan(strategy)
[17:40:53.675] plan(): nbrOfWorkers() = 1
[17:40:53.675] SequentialFuture started (and completed)
[17:40:53.675] - Launch lazy future ... done
[17:40:53.676] run() for ‘SequentialFuture’ ... done
[17:40:53.676] Created future:
[17:40:53.676] SequentialFuture:
[17:40:53.676] Label: ‘future_vapply-1’
[17:40:53.676] Expression:
[17:40:53.676] {
[17:40:53.676]     do.call(function(...) {
[17:40:53.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.676]             on.exit(options(oopts), add = TRUE)
[17:40:53.676]         }
[17:40:53.676]         {
[17:40:53.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.676]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.676]             })
[17:40:53.676]         }
[17:40:53.676]     }, args = future.call.arguments)
[17:40:53.676] }
[17:40:53.676] Lazy evaluation: FALSE
[17:40:53.676] Asynchronous evaluation: FALSE
[17:40:53.676] Local evaluation: TRUE
[17:40:53.676] Environment: R_GlobalEnv
[17:40:53.676] Capture standard output: TRUE
[17:40:53.676] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.676] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.676] Packages: 1 packages (‘future.apply’)
[17:40:53.676] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.676] Resolved: TRUE
[17:40:53.676] Value: 480 bytes of class ‘list’
[17:40:53.676] Early signaling: FALSE
[17:40:53.676] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.676] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.677] Chunk #1 of 1 ... DONE
[17:40:53.677] Launching 1 futures (chunks) ... DONE
[17:40:53.677] Resolving 1 futures (chunks) ...
[17:40:53.677] resolve() on list ...
[17:40:53.677]  recursive: 0
[17:40:53.677]  length: 1
[17:40:53.677] 
[17:40:53.678] resolved() for ‘SequentialFuture’ ...
[17:40:53.678] - state: ‘finished’
[17:40:53.678] - run: TRUE
[17:40:53.678] - result: ‘FutureResult’
[17:40:53.678] resolved() for ‘SequentialFuture’ ... done
[17:40:53.678] Future #1
[17:40:53.678] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.678] - nx: 1
[17:40:53.678] - relay: TRUE
[17:40:53.678] - stdout: TRUE
[17:40:53.678] - signal: TRUE
[17:40:53.679] - resignal: FALSE
[17:40:53.679] - force: TRUE
[17:40:53.679] - relayed: [n=1] FALSE
[17:40:53.679] - queued futures: [n=1] FALSE
[17:40:53.679]  - until=1
[17:40:53.679]  - relaying element #1
[17:40:53.679] - relayed: [n=1] TRUE
[17:40:53.679] - queued futures: [n=1] TRUE
[17:40:53.679] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.680]  length: 0 (resolved future 1)
[17:40:53.680] Relaying remaining futures
[17:40:53.680] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.680] - nx: 1
[17:40:53.680] - relay: TRUE
[17:40:53.680] - stdout: TRUE
[17:40:53.680] - signal: TRUE
[17:40:53.680] - resignal: FALSE
[17:40:53.680] - force: TRUE
[17:40:53.680] - relayed: [n=1] TRUE
[17:40:53.680] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.680] - relayed: [n=1] TRUE
[17:40:53.681] - queued futures: [n=1] TRUE
[17:40:53.681] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.681] resolve() on list ... DONE
[17:40:53.681]  - Number of value chunks collected: 1
[17:40:53.681] Resolving 1 futures (chunks) ... DONE
[17:40:53.681] Reducing values from 1 chunks ...
[17:40:53.681]  - Number of values collected after concatenation: 10
[17:40:53.681]  - Number of values expected: 10
[17:40:53.681] Reducing values from 1 chunks ... DONE
[17:40:53.681] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:40:53.682] future_lapply() ...
[17:40:53.684] Number of chunks: 1
[17:40:53.684] getGlobalsAndPackagesXApply() ...
[17:40:53.684]  - future.globals: TRUE
[17:40:53.684] getGlobalsAndPackages() ...
[17:40:53.684] Searching for globals...
[17:40:53.688] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:40:53.689] Searching for globals ... DONE
[17:40:53.689] Resolving globals: FALSE
[17:40:53.690] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:40:53.690] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.691] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.691] - packages: [1] ‘future.apply’
[17:40:53.691] getGlobalsAndPackages() ... DONE
[17:40:53.691]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.691]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.691] Finding globals ... DONE
[17:40:53.691]  - use_args: TRUE
[17:40:53.691]  - Getting '...' globals ...
[17:40:53.692] resolve() on list ...
[17:40:53.692]  recursive: 0
[17:40:53.692]  length: 1
[17:40:53.692]  elements: ‘...’
[17:40:53.692]  length: 0 (resolved future 1)
[17:40:53.692] resolve() on list ... DONE
[17:40:53.692]    - '...' content: [n=0] 
[17:40:53.692] List of 1
[17:40:53.692]  $ ...: list()
[17:40:53.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.692]  - attr(*, "where")=List of 1
[17:40:53.692]   ..$ ...:<environment: 0x564f303f3eb0> 
[17:40:53.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.692]  - attr(*, "resolved")= logi TRUE
[17:40:53.692]  - attr(*, "total_size")= num NA
[17:40:53.695]  - Getting '...' globals ... DONE
[17:40:53.695] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.695] List of 8
[17:40:53.695]  $ ...future.FUN:function (x, ...)  
[17:40:53.695]  $ x_FUN        :function (x)  
[17:40:53.695]  $ times        : int 0
[17:40:53.695]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.695]  $ stop_if_not  :function (...)  
[17:40:53.695]  $ dim          : NULL
[17:40:53.695]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:53.695]  $ ...          : list()
[17:40:53.695]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.695]  - attr(*, "where")=List of 8
[17:40:53.695]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.695]   ..$ ...          :<environment: 0x564f303f3eb0> 
[17:40:53.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.695]  - attr(*, "resolved")= logi FALSE
[17:40:53.695]  - attr(*, "total_size")= num 95400
[17:40:53.700] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.700] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.700] Number of futures (= number of chunks): 1
[17:40:53.700] Launching 1 futures (chunks) ...
[17:40:53.701] Chunk #1 of 1 ...
[17:40:53.701]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.701] getGlobalsAndPackages() ...
[17:40:53.701] Searching for globals...
[17:40:53.701] 
[17:40:53.701] Searching for globals ... DONE
[17:40:53.701] - globals: [0] <none>
[17:40:53.701] getGlobalsAndPackages() ... DONE
[17:40:53.701]    + additional globals found: [n=0] 
[17:40:53.701]    + additional namespaces needed: [n=0] 
[17:40:53.702]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.702]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.702]  - seeds: <none>
[17:40:53.702] getGlobalsAndPackages() ...
[17:40:53.702] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.702] Resolving globals: FALSE
[17:40:53.702] Tweak future expression to call with '...' arguments ...
[17:40:53.702] {
[17:40:53.702]     do.call(function(...) {
[17:40:53.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.702]             on.exit(options(oopts), add = TRUE)
[17:40:53.702]         }
[17:40:53.702]         {
[17:40:53.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.702]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.702]             })
[17:40:53.702]         }
[17:40:53.702]     }, args = future.call.arguments)
[17:40:53.702] }
[17:40:53.703] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.703] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.703] - packages: [1] ‘future.apply’
[17:40:53.703] getGlobalsAndPackages() ... DONE
[17:40:53.704] run() for ‘Future’ ...
[17:40:53.704] - state: ‘created’
[17:40:53.704] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.704] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.704]   - Field: ‘label’
[17:40:53.704]   - Field: ‘local’
[17:40:53.705]   - Field: ‘owner’
[17:40:53.705]   - Field: ‘envir’
[17:40:53.705]   - Field: ‘packages’
[17:40:53.705]   - Field: ‘gc’
[17:40:53.705]   - Field: ‘conditions’
[17:40:53.705]   - Field: ‘expr’
[17:40:53.705]   - Field: ‘uuid’
[17:40:53.705]   - Field: ‘seed’
[17:40:53.705]   - Field: ‘version’
[17:40:53.705]   - Field: ‘result’
[17:40:53.705]   - Field: ‘asynchronous’
[17:40:53.706]   - Field: ‘calls’
[17:40:53.706]   - Field: ‘globals’
[17:40:53.706]   - Field: ‘stdout’
[17:40:53.706]   - Field: ‘earlySignal’
[17:40:53.706]   - Field: ‘lazy’
[17:40:53.706]   - Field: ‘state’
[17:40:53.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.706] - Launch lazy future ...
[17:40:53.706] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.706] Packages needed by future strategies (n = 0): <none>
[17:40:53.707] {
[17:40:53.707]     {
[17:40:53.707]         {
[17:40:53.707]             ...future.startTime <- base::Sys.time()
[17:40:53.707]             {
[17:40:53.707]                 {
[17:40:53.707]                   {
[17:40:53.707]                     {
[17:40:53.707]                       base::local({
[17:40:53.707]                         has_future <- base::requireNamespace("future", 
[17:40:53.707]                           quietly = TRUE)
[17:40:53.707]                         if (has_future) {
[17:40:53.707]                           ns <- base::getNamespace("future")
[17:40:53.707]                           version <- ns[[".package"]][["version"]]
[17:40:53.707]                           if (is.null(version)) 
[17:40:53.707]                             version <- utils::packageVersion("future")
[17:40:53.707]                         }
[17:40:53.707]                         else {
[17:40:53.707]                           version <- NULL
[17:40:53.707]                         }
[17:40:53.707]                         if (!has_future || version < "1.8.0") {
[17:40:53.707]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.707]                             "", base::R.version$version.string), 
[17:40:53.707]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.707]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.707]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.707]                               "release", "version")], collapse = " "), 
[17:40:53.707]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.707]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.707]                             info)
[17:40:53.707]                           info <- base::paste(info, collapse = "; ")
[17:40:53.707]                           if (!has_future) {
[17:40:53.707]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.707]                               info)
[17:40:53.707]                           }
[17:40:53.707]                           else {
[17:40:53.707]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.707]                               info, version)
[17:40:53.707]                           }
[17:40:53.707]                           base::stop(msg)
[17:40:53.707]                         }
[17:40:53.707]                       })
[17:40:53.707]                     }
[17:40:53.707]                     base::local({
[17:40:53.707]                       for (pkg in "future.apply") {
[17:40:53.707]                         base::loadNamespace(pkg)
[17:40:53.707]                         base::library(pkg, character.only = TRUE)
[17:40:53.707]                       }
[17:40:53.707]                     })
[17:40:53.707]                   }
[17:40:53.707]                   options(future.plan = NULL)
[17:40:53.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.707]                 }
[17:40:53.707]                 ...future.workdir <- getwd()
[17:40:53.707]             }
[17:40:53.707]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.707]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.707]         }
[17:40:53.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.707]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.707]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.707]             base::names(...future.oldOptions))
[17:40:53.707]     }
[17:40:53.707]     if (FALSE) {
[17:40:53.707]     }
[17:40:53.707]     else {
[17:40:53.707]         if (TRUE) {
[17:40:53.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.707]                 open = "w")
[17:40:53.707]         }
[17:40:53.707]         else {
[17:40:53.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.707]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.707]         }
[17:40:53.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.707]             base::sink(type = "output", split = FALSE)
[17:40:53.707]             base::close(...future.stdout)
[17:40:53.707]         }, add = TRUE)
[17:40:53.707]     }
[17:40:53.707]     ...future.frame <- base::sys.nframe()
[17:40:53.707]     ...future.conditions <- base::list()
[17:40:53.707]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.707]     if (FALSE) {
[17:40:53.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.707]     }
[17:40:53.707]     ...future.result <- base::tryCatch({
[17:40:53.707]         base::withCallingHandlers({
[17:40:53.707]             ...future.value <- base::withVisible(base::local({
[17:40:53.707]                 do.call(function(...) {
[17:40:53.707]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.707]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.707]                     ...future.globals.maxSize)) {
[17:40:53.707]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.707]                     on.exit(options(oopts), add = TRUE)
[17:40:53.707]                   }
[17:40:53.707]                   {
[17:40:53.707]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.707]                       FUN = function(jj) {
[17:40:53.707]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.707]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.707]                       })
[17:40:53.707]                   }
[17:40:53.707]                 }, args = future.call.arguments)
[17:40:53.707]             }))
[17:40:53.707]             future::FutureResult(value = ...future.value$value, 
[17:40:53.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.707]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.707]                     ...future.globalenv.names))
[17:40:53.707]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.707]         }, condition = base::local({
[17:40:53.707]             c <- base::c
[17:40:53.707]             inherits <- base::inherits
[17:40:53.707]             invokeRestart <- base::invokeRestart
[17:40:53.707]             length <- base::length
[17:40:53.707]             list <- base::list
[17:40:53.707]             seq.int <- base::seq.int
[17:40:53.707]             signalCondition <- base::signalCondition
[17:40:53.707]             sys.calls <- base::sys.calls
[17:40:53.707]             `[[` <- base::`[[`
[17:40:53.707]             `+` <- base::`+`
[17:40:53.707]             `<<-` <- base::`<<-`
[17:40:53.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.707]                   3L)]
[17:40:53.707]             }
[17:40:53.707]             function(cond) {
[17:40:53.707]                 is_error <- inherits(cond, "error")
[17:40:53.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.707]                   NULL)
[17:40:53.707]                 if (is_error) {
[17:40:53.707]                   sessionInformation <- function() {
[17:40:53.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.707]                       search = base::search(), system = base::Sys.info())
[17:40:53.707]                   }
[17:40:53.707]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.707]                     cond$call), session = sessionInformation(), 
[17:40:53.707]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.707]                   signalCondition(cond)
[17:40:53.707]                 }
[17:40:53.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.707]                 "immediateCondition"))) {
[17:40:53.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.707]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.707]                   if (TRUE && !signal) {
[17:40:53.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.707]                     {
[17:40:53.707]                       inherits <- base::inherits
[17:40:53.707]                       invokeRestart <- base::invokeRestart
[17:40:53.707]                       is.null <- base::is.null
[17:40:53.707]                       muffled <- FALSE
[17:40:53.707]                       if (inherits(cond, "message")) {
[17:40:53.707]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.707]                         if (muffled) 
[17:40:53.707]                           invokeRestart("muffleMessage")
[17:40:53.707]                       }
[17:40:53.707]                       else if (inherits(cond, "warning")) {
[17:40:53.707]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.707]                         if (muffled) 
[17:40:53.707]                           invokeRestart("muffleWarning")
[17:40:53.707]                       }
[17:40:53.707]                       else if (inherits(cond, "condition")) {
[17:40:53.707]                         if (!is.null(pattern)) {
[17:40:53.707]                           computeRestarts <- base::computeRestarts
[17:40:53.707]                           grepl <- base::grepl
[17:40:53.707]                           restarts <- computeRestarts(cond)
[17:40:53.707]                           for (restart in restarts) {
[17:40:53.707]                             name <- restart$name
[17:40:53.707]                             if (is.null(name)) 
[17:40:53.707]                               next
[17:40:53.707]                             if (!grepl(pattern, name)) 
[17:40:53.707]                               next
[17:40:53.707]                             invokeRestart(restart)
[17:40:53.707]                             muffled <- TRUE
[17:40:53.707]                             break
[17:40:53.707]                           }
[17:40:53.707]                         }
[17:40:53.707]                       }
[17:40:53.707]                       invisible(muffled)
[17:40:53.707]                     }
[17:40:53.707]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.707]                   }
[17:40:53.707]                 }
[17:40:53.707]                 else {
[17:40:53.707]                   if (TRUE) {
[17:40:53.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.707]                     {
[17:40:53.707]                       inherits <- base::inherits
[17:40:53.707]                       invokeRestart <- base::invokeRestart
[17:40:53.707]                       is.null <- base::is.null
[17:40:53.707]                       muffled <- FALSE
[17:40:53.707]                       if (inherits(cond, "message")) {
[17:40:53.707]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.707]                         if (muffled) 
[17:40:53.707]                           invokeRestart("muffleMessage")
[17:40:53.707]                       }
[17:40:53.707]                       else if (inherits(cond, "warning")) {
[17:40:53.707]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.707]                         if (muffled) 
[17:40:53.707]                           invokeRestart("muffleWarning")
[17:40:53.707]                       }
[17:40:53.707]                       else if (inherits(cond, "condition")) {
[17:40:53.707]                         if (!is.null(pattern)) {
[17:40:53.707]                           computeRestarts <- base::computeRestarts
[17:40:53.707]                           grepl <- base::grepl
[17:40:53.707]                           restarts <- computeRestarts(cond)
[17:40:53.707]                           for (restart in restarts) {
[17:40:53.707]                             name <- restart$name
[17:40:53.707]                             if (is.null(name)) 
[17:40:53.707]                               next
[17:40:53.707]                             if (!grepl(pattern, name)) 
[17:40:53.707]                               next
[17:40:53.707]                             invokeRestart(restart)
[17:40:53.707]                             muffled <- TRUE
[17:40:53.707]                             break
[17:40:53.707]                           }
[17:40:53.707]                         }
[17:40:53.707]                       }
[17:40:53.707]                       invisible(muffled)
[17:40:53.707]                     }
[17:40:53.707]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.707]                   }
[17:40:53.707]                 }
[17:40:53.707]             }
[17:40:53.707]         }))
[17:40:53.707]     }, error = function(ex) {
[17:40:53.707]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.707]                 ...future.rng), started = ...future.startTime, 
[17:40:53.707]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.707]             version = "1.8"), class = "FutureResult")
[17:40:53.707]     }, finally = {
[17:40:53.707]         if (!identical(...future.workdir, getwd())) 
[17:40:53.707]             setwd(...future.workdir)
[17:40:53.707]         {
[17:40:53.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.707]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.707]             }
[17:40:53.707]             base::options(...future.oldOptions)
[17:40:53.707]             if (.Platform$OS.type == "windows") {
[17:40:53.707]                 old_names <- names(...future.oldEnvVars)
[17:40:53.707]                 envs <- base::Sys.getenv()
[17:40:53.707]                 names <- names(envs)
[17:40:53.707]                 common <- intersect(names, old_names)
[17:40:53.707]                 added <- setdiff(names, old_names)
[17:40:53.707]                 removed <- setdiff(old_names, names)
[17:40:53.707]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.707]                   envs[common]]
[17:40:53.707]                 NAMES <- toupper(changed)
[17:40:53.707]                 args <- list()
[17:40:53.707]                 for (kk in seq_along(NAMES)) {
[17:40:53.707]                   name <- changed[[kk]]
[17:40:53.707]                   NAME <- NAMES[[kk]]
[17:40:53.707]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.707]                     next
[17:40:53.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.707]                 }
[17:40:53.707]                 NAMES <- toupper(added)
[17:40:53.707]                 for (kk in seq_along(NAMES)) {
[17:40:53.707]                   name <- added[[kk]]
[17:40:53.707]                   NAME <- NAMES[[kk]]
[17:40:53.707]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.707]                     next
[17:40:53.707]                   args[[name]] <- ""
[17:40:53.707]                 }
[17:40:53.707]                 NAMES <- toupper(removed)
[17:40:53.707]                 for (kk in seq_along(NAMES)) {
[17:40:53.707]                   name <- removed[[kk]]
[17:40:53.707]                   NAME <- NAMES[[kk]]
[17:40:53.707]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.707]                     next
[17:40:53.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.707]                 }
[17:40:53.707]                 if (length(args) > 0) 
[17:40:53.707]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.707]             }
[17:40:53.707]             else {
[17:40:53.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.707]             }
[17:40:53.707]             {
[17:40:53.707]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.707]                   0L) {
[17:40:53.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.707]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.707]                   base::options(opts)
[17:40:53.707]                 }
[17:40:53.707]                 {
[17:40:53.707]                   {
[17:40:53.707]                     NULL
[17:40:53.707]                     RNGkind("Mersenne-Twister")
[17:40:53.707]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.707]                       inherits = FALSE)
[17:40:53.707]                   }
[17:40:53.707]                   options(future.plan = NULL)
[17:40:53.707]                   if (is.na(NA_character_)) 
[17:40:53.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.707]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.707]                   {
[17:40:53.707]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.707]                     if (!future$lazy) 
[17:40:53.707]                       future <- run(future)
[17:40:53.707]                     invisible(future)
[17:40:53.707]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.707]                 }
[17:40:53.707]             }
[17:40:53.707]         }
[17:40:53.707]     })
[17:40:53.707]     if (TRUE) {
[17:40:53.707]         base::sink(type = "output", split = FALSE)
[17:40:53.707]         if (TRUE) {
[17:40:53.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.707]         }
[17:40:53.707]         else {
[17:40:53.707]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.707]         }
[17:40:53.707]         base::close(...future.stdout)
[17:40:53.707]         ...future.stdout <- NULL
[17:40:53.707]     }
[17:40:53.707]     ...future.result$conditions <- ...future.conditions
[17:40:53.707]     ...future.result$finished <- base::Sys.time()
[17:40:53.707]     ...future.result
[17:40:53.707] }
[17:40:53.709] assign_globals() ...
[17:40:53.709] List of 11
[17:40:53.709]  $ ...future.FUN            :function (x, ...)  
[17:40:53.709]  $ x_FUN                    :function (x)  
[17:40:53.709]  $ times                    : int 0
[17:40:53.709]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.709]  $ stop_if_not              :function (...)  
[17:40:53.709]  $ dim                      : NULL
[17:40:53.709]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:53.709]  $ future.call.arguments    : list()
[17:40:53.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.709]  $ ...future.elements_ii    :List of 10
[17:40:53.709]   ..$ : int 1
[17:40:53.709]   ..$ : int 2
[17:40:53.709]   ..$ : int 3
[17:40:53.709]   ..$ : int 4
[17:40:53.709]   ..$ : int 5
[17:40:53.709]   ..$ : int 6
[17:40:53.709]   ..$ : int 7
[17:40:53.709]   ..$ : int 8
[17:40:53.709]   ..$ : int 9
[17:40:53.709]   ..$ : int 10
[17:40:53.709]  $ ...future.seeds_ii       : NULL
[17:40:53.709]  $ ...future.globals.maxSize: NULL
[17:40:53.709]  - attr(*, "resolved")= logi FALSE
[17:40:53.709]  - attr(*, "total_size")= num 95400
[17:40:53.709]  - attr(*, "where")=List of 11
[17:40:53.709]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.709]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.709]  - attr(*, "already-done")= logi TRUE
[17:40:53.720] - copied ‘...future.FUN’ to environment
[17:40:53.720] - reassign environment for ‘x_FUN’
[17:40:53.720] - copied ‘x_FUN’ to environment
[17:40:53.720] - copied ‘times’ to environment
[17:40:53.720] - copied ‘stopf’ to environment
[17:40:53.720] - copied ‘stop_if_not’ to environment
[17:40:53.720] - copied ‘dim’ to environment
[17:40:53.720] - copied ‘valid_types’ to environment
[17:40:53.720] - copied ‘future.call.arguments’ to environment
[17:40:53.721] - copied ‘...future.elements_ii’ to environment
[17:40:53.721] - copied ‘...future.seeds_ii’ to environment
[17:40:53.721] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.721] assign_globals() ... done
[17:40:53.721] plan(): Setting new future strategy stack:
[17:40:53.721] List of future strategies:
[17:40:53.721] 1. sequential:
[17:40:53.721]    - args: function (..., envir = parent.frame())
[17:40:53.721]    - tweaked: FALSE
[17:40:53.721]    - call: NULL
[17:40:53.722] plan(): nbrOfWorkers() = 1
[17:40:53.722] plan(): Setting new future strategy stack:
[17:40:53.722] List of future strategies:
[17:40:53.722] 1. sequential:
[17:40:53.722]    - args: function (..., envir = parent.frame())
[17:40:53.722]    - tweaked: FALSE
[17:40:53.722]    - call: plan(strategy)
[17:40:53.723] plan(): nbrOfWorkers() = 1
[17:40:53.723] SequentialFuture started (and completed)
[17:40:53.723] - Launch lazy future ... done
[17:40:53.723] run() for ‘SequentialFuture’ ... done
[17:40:53.723] Created future:
[17:40:53.723] SequentialFuture:
[17:40:53.723] Label: ‘future_vapply-1’
[17:40:53.723] Expression:
[17:40:53.723] {
[17:40:53.723]     do.call(function(...) {
[17:40:53.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.723]             on.exit(options(oopts), add = TRUE)
[17:40:53.723]         }
[17:40:53.723]         {
[17:40:53.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.723]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.723]             })
[17:40:53.723]         }
[17:40:53.723]     }, args = future.call.arguments)
[17:40:53.723] }
[17:40:53.723] Lazy evaluation: FALSE
[17:40:53.723] Asynchronous evaluation: FALSE
[17:40:53.723] Local evaluation: TRUE
[17:40:53.723] Environment: R_GlobalEnv
[17:40:53.723] Capture standard output: TRUE
[17:40:53.723] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.723] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.723] Packages: 1 packages (‘future.apply’)
[17:40:53.723] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.723] Resolved: TRUE
[17:40:53.723] Value: 480 bytes of class ‘list’
[17:40:53.723] Early signaling: FALSE
[17:40:53.723] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.723] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.725] Chunk #1 of 1 ... DONE
[17:40:53.725] Launching 1 futures (chunks) ... DONE
[17:40:53.725] Resolving 1 futures (chunks) ...
[17:40:53.725] resolve() on list ...
[17:40:53.725]  recursive: 0
[17:40:53.725]  length: 1
[17:40:53.725] 
[17:40:53.725] resolved() for ‘SequentialFuture’ ...
[17:40:53.725] - state: ‘finished’
[17:40:53.725] - run: TRUE
[17:40:53.726] - result: ‘FutureResult’
[17:40:53.726] resolved() for ‘SequentialFuture’ ... done
[17:40:53.726] Future #1
[17:40:53.726] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.726] - nx: 1
[17:40:53.726] - relay: TRUE
[17:40:53.726] - stdout: TRUE
[17:40:53.726] - signal: TRUE
[17:40:53.726] - resignal: FALSE
[17:40:53.726] - force: TRUE
[17:40:53.726] - relayed: [n=1] FALSE
[17:40:53.727] - queued futures: [n=1] FALSE
[17:40:53.727]  - until=1
[17:40:53.727]  - relaying element #1
[17:40:53.727] - relayed: [n=1] TRUE
[17:40:53.727] - queued futures: [n=1] TRUE
[17:40:53.727] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.727]  length: 0 (resolved future 1)
[17:40:53.727] Relaying remaining futures
[17:40:53.727] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.727] - nx: 1
[17:40:53.728] - relay: TRUE
[17:40:53.728] - stdout: TRUE
[17:40:53.728] - signal: TRUE
[17:40:53.728] - resignal: FALSE
[17:40:53.728] - force: TRUE
[17:40:53.728] - relayed: [n=1] TRUE
[17:40:53.728] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.728] - relayed: [n=1] TRUE
[17:40:53.728] - queued futures: [n=1] TRUE
[17:40:53.728] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.728] resolve() on list ... DONE
[17:40:53.729]  - Number of value chunks collected: 1
[17:40:53.729] Resolving 1 futures (chunks) ... DONE
[17:40:53.729] Reducing values from 1 chunks ...
[17:40:53.729]  - Number of values collected after concatenation: 10
[17:40:53.729]  - Number of values expected: 10
[17:40:53.729] Reducing values from 1 chunks ... DONE
[17:40:53.729] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:40:53.730] future_lapply() ...
[17:40:53.731] Number of chunks: 1
[17:40:53.732] getGlobalsAndPackagesXApply() ...
[17:40:53.732]  - future.globals: TRUE
[17:40:53.733] getGlobalsAndPackages() ...
[17:40:53.733] Searching for globals...
[17:40:53.736] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:53.736] Searching for globals ... DONE
[17:40:53.736] Resolving globals: FALSE
[17:40:53.737] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:40:53.737] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.737] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.737] - packages: [1] ‘future.apply’
[17:40:53.738] getGlobalsAndPackages() ... DONE
[17:40:53.738]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.738]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.738] Finding globals ... DONE
[17:40:53.738]  - use_args: TRUE
[17:40:53.738]  - Getting '...' globals ...
[17:40:53.738] resolve() on list ...
[17:40:53.738]  recursive: 0
[17:40:53.738]  length: 1
[17:40:53.739]  elements: ‘...’
[17:40:53.739]  length: 0 (resolved future 1)
[17:40:53.739] resolve() on list ... DONE
[17:40:53.739]    - '...' content: [n=0] 
[17:40:53.739] List of 1
[17:40:53.739]  $ ...: list()
[17:40:53.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.739]  - attr(*, "where")=List of 1
[17:40:53.739]   ..$ ...:<environment: 0x564f3070c3d8> 
[17:40:53.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.739]  - attr(*, "resolved")= logi TRUE
[17:40:53.739]  - attr(*, "total_size")= num NA
[17:40:53.741]  - Getting '...' globals ... DONE
[17:40:53.741] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.742] List of 8
[17:40:53.742]  $ ...future.FUN:function (x, ...)  
[17:40:53.742]  $ x_FUN        :function (x)  
[17:40:53.742]  $ times        : int 1
[17:40:53.742]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.742]  $ stop_if_not  :function (...)  
[17:40:53.742]  $ dim          : NULL
[17:40:53.742]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:53.742]  $ ...          : list()
[17:40:53.742]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.742]  - attr(*, "where")=List of 8
[17:40:53.742]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.742]   ..$ ...          :<environment: 0x564f3070c3d8> 
[17:40:53.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.742]  - attr(*, "resolved")= logi FALSE
[17:40:53.742]  - attr(*, "total_size")= num 94336
[17:40:53.747] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.747] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.747] Number of futures (= number of chunks): 1
[17:40:53.747] Launching 1 futures (chunks) ...
[17:40:53.748] Chunk #1 of 1 ...
[17:40:53.748]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.748] getGlobalsAndPackages() ...
[17:40:53.748] Searching for globals...
[17:40:53.748] 
[17:40:53.749] Searching for globals ... DONE
[17:40:53.749] - globals: [0] <none>
[17:40:53.749] getGlobalsAndPackages() ... DONE
[17:40:53.749]    + additional globals found: [n=0] 
[17:40:53.749]    + additional namespaces needed: [n=0] 
[17:40:53.749]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.749]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.749]  - seeds: <none>
[17:40:53.749] getGlobalsAndPackages() ...
[17:40:53.749] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.749] Resolving globals: FALSE
[17:40:53.750] Tweak future expression to call with '...' arguments ...
[17:40:53.750] {
[17:40:53.750]     do.call(function(...) {
[17:40:53.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.750]             on.exit(options(oopts), add = TRUE)
[17:40:53.750]         }
[17:40:53.750]         {
[17:40:53.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.750]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.750]             })
[17:40:53.750]         }
[17:40:53.750]     }, args = future.call.arguments)
[17:40:53.750] }
[17:40:53.750] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.750] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.751] - packages: [1] ‘future.apply’
[17:40:53.751] getGlobalsAndPackages() ... DONE
[17:40:53.751] run() for ‘Future’ ...
[17:40:53.751] - state: ‘created’
[17:40:53.751] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.752] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.752]   - Field: ‘label’
[17:40:53.752]   - Field: ‘local’
[17:40:53.752]   - Field: ‘owner’
[17:40:53.752]   - Field: ‘envir’
[17:40:53.752]   - Field: ‘packages’
[17:40:53.752]   - Field: ‘gc’
[17:40:53.752]   - Field: ‘conditions’
[17:40:53.752]   - Field: ‘expr’
[17:40:53.752]   - Field: ‘uuid’
[17:40:53.753]   - Field: ‘seed’
[17:40:53.753]   - Field: ‘version’
[17:40:53.753]   - Field: ‘result’
[17:40:53.753]   - Field: ‘asynchronous’
[17:40:53.753]   - Field: ‘calls’
[17:40:53.753]   - Field: ‘globals’
[17:40:53.754]   - Field: ‘stdout’
[17:40:53.755]   - Field: ‘earlySignal’
[17:40:53.755]   - Field: ‘lazy’
[17:40:53.755]   - Field: ‘state’
[17:40:53.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.755] - Launch lazy future ...
[17:40:53.755] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.755] Packages needed by future strategies (n = 0): <none>
[17:40:53.756] {
[17:40:53.756]     {
[17:40:53.756]         {
[17:40:53.756]             ...future.startTime <- base::Sys.time()
[17:40:53.756]             {
[17:40:53.756]                 {
[17:40:53.756]                   {
[17:40:53.756]                     {
[17:40:53.756]                       base::local({
[17:40:53.756]                         has_future <- base::requireNamespace("future", 
[17:40:53.756]                           quietly = TRUE)
[17:40:53.756]                         if (has_future) {
[17:40:53.756]                           ns <- base::getNamespace("future")
[17:40:53.756]                           version <- ns[[".package"]][["version"]]
[17:40:53.756]                           if (is.null(version)) 
[17:40:53.756]                             version <- utils::packageVersion("future")
[17:40:53.756]                         }
[17:40:53.756]                         else {
[17:40:53.756]                           version <- NULL
[17:40:53.756]                         }
[17:40:53.756]                         if (!has_future || version < "1.8.0") {
[17:40:53.756]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.756]                             "", base::R.version$version.string), 
[17:40:53.756]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.756]                               "release", "version")], collapse = " "), 
[17:40:53.756]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.756]                             info)
[17:40:53.756]                           info <- base::paste(info, collapse = "; ")
[17:40:53.756]                           if (!has_future) {
[17:40:53.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.756]                               info)
[17:40:53.756]                           }
[17:40:53.756]                           else {
[17:40:53.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.756]                               info, version)
[17:40:53.756]                           }
[17:40:53.756]                           base::stop(msg)
[17:40:53.756]                         }
[17:40:53.756]                       })
[17:40:53.756]                     }
[17:40:53.756]                     base::local({
[17:40:53.756]                       for (pkg in "future.apply") {
[17:40:53.756]                         base::loadNamespace(pkg)
[17:40:53.756]                         base::library(pkg, character.only = TRUE)
[17:40:53.756]                       }
[17:40:53.756]                     })
[17:40:53.756]                   }
[17:40:53.756]                   options(future.plan = NULL)
[17:40:53.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.756]                 }
[17:40:53.756]                 ...future.workdir <- getwd()
[17:40:53.756]             }
[17:40:53.756]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.756]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.756]         }
[17:40:53.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.756]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.756]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.756]             base::names(...future.oldOptions))
[17:40:53.756]     }
[17:40:53.756]     if (FALSE) {
[17:40:53.756]     }
[17:40:53.756]     else {
[17:40:53.756]         if (TRUE) {
[17:40:53.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.756]                 open = "w")
[17:40:53.756]         }
[17:40:53.756]         else {
[17:40:53.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.756]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.756]         }
[17:40:53.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.756]             base::sink(type = "output", split = FALSE)
[17:40:53.756]             base::close(...future.stdout)
[17:40:53.756]         }, add = TRUE)
[17:40:53.756]     }
[17:40:53.756]     ...future.frame <- base::sys.nframe()
[17:40:53.756]     ...future.conditions <- base::list()
[17:40:53.756]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.756]     if (FALSE) {
[17:40:53.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.756]     }
[17:40:53.756]     ...future.result <- base::tryCatch({
[17:40:53.756]         base::withCallingHandlers({
[17:40:53.756]             ...future.value <- base::withVisible(base::local({
[17:40:53.756]                 do.call(function(...) {
[17:40:53.756]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.756]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.756]                     ...future.globals.maxSize)) {
[17:40:53.756]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.756]                     on.exit(options(oopts), add = TRUE)
[17:40:53.756]                   }
[17:40:53.756]                   {
[17:40:53.756]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.756]                       FUN = function(jj) {
[17:40:53.756]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.756]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.756]                       })
[17:40:53.756]                   }
[17:40:53.756]                 }, args = future.call.arguments)
[17:40:53.756]             }))
[17:40:53.756]             future::FutureResult(value = ...future.value$value, 
[17:40:53.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.756]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.756]                     ...future.globalenv.names))
[17:40:53.756]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.756]         }, condition = base::local({
[17:40:53.756]             c <- base::c
[17:40:53.756]             inherits <- base::inherits
[17:40:53.756]             invokeRestart <- base::invokeRestart
[17:40:53.756]             length <- base::length
[17:40:53.756]             list <- base::list
[17:40:53.756]             seq.int <- base::seq.int
[17:40:53.756]             signalCondition <- base::signalCondition
[17:40:53.756]             sys.calls <- base::sys.calls
[17:40:53.756]             `[[` <- base::`[[`
[17:40:53.756]             `+` <- base::`+`
[17:40:53.756]             `<<-` <- base::`<<-`
[17:40:53.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.756]                   3L)]
[17:40:53.756]             }
[17:40:53.756]             function(cond) {
[17:40:53.756]                 is_error <- inherits(cond, "error")
[17:40:53.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.756]                   NULL)
[17:40:53.756]                 if (is_error) {
[17:40:53.756]                   sessionInformation <- function() {
[17:40:53.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.756]                       search = base::search(), system = base::Sys.info())
[17:40:53.756]                   }
[17:40:53.756]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.756]                     cond$call), session = sessionInformation(), 
[17:40:53.756]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.756]                   signalCondition(cond)
[17:40:53.756]                 }
[17:40:53.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.756]                 "immediateCondition"))) {
[17:40:53.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.756]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.756]                   if (TRUE && !signal) {
[17:40:53.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.756]                     {
[17:40:53.756]                       inherits <- base::inherits
[17:40:53.756]                       invokeRestart <- base::invokeRestart
[17:40:53.756]                       is.null <- base::is.null
[17:40:53.756]                       muffled <- FALSE
[17:40:53.756]                       if (inherits(cond, "message")) {
[17:40:53.756]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.756]                         if (muffled) 
[17:40:53.756]                           invokeRestart("muffleMessage")
[17:40:53.756]                       }
[17:40:53.756]                       else if (inherits(cond, "warning")) {
[17:40:53.756]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.756]                         if (muffled) 
[17:40:53.756]                           invokeRestart("muffleWarning")
[17:40:53.756]                       }
[17:40:53.756]                       else if (inherits(cond, "condition")) {
[17:40:53.756]                         if (!is.null(pattern)) {
[17:40:53.756]                           computeRestarts <- base::computeRestarts
[17:40:53.756]                           grepl <- base::grepl
[17:40:53.756]                           restarts <- computeRestarts(cond)
[17:40:53.756]                           for (restart in restarts) {
[17:40:53.756]                             name <- restart$name
[17:40:53.756]                             if (is.null(name)) 
[17:40:53.756]                               next
[17:40:53.756]                             if (!grepl(pattern, name)) 
[17:40:53.756]                               next
[17:40:53.756]                             invokeRestart(restart)
[17:40:53.756]                             muffled <- TRUE
[17:40:53.756]                             break
[17:40:53.756]                           }
[17:40:53.756]                         }
[17:40:53.756]                       }
[17:40:53.756]                       invisible(muffled)
[17:40:53.756]                     }
[17:40:53.756]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.756]                   }
[17:40:53.756]                 }
[17:40:53.756]                 else {
[17:40:53.756]                   if (TRUE) {
[17:40:53.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.756]                     {
[17:40:53.756]                       inherits <- base::inherits
[17:40:53.756]                       invokeRestart <- base::invokeRestart
[17:40:53.756]                       is.null <- base::is.null
[17:40:53.756]                       muffled <- FALSE
[17:40:53.756]                       if (inherits(cond, "message")) {
[17:40:53.756]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.756]                         if (muffled) 
[17:40:53.756]                           invokeRestart("muffleMessage")
[17:40:53.756]                       }
[17:40:53.756]                       else if (inherits(cond, "warning")) {
[17:40:53.756]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.756]                         if (muffled) 
[17:40:53.756]                           invokeRestart("muffleWarning")
[17:40:53.756]                       }
[17:40:53.756]                       else if (inherits(cond, "condition")) {
[17:40:53.756]                         if (!is.null(pattern)) {
[17:40:53.756]                           computeRestarts <- base::computeRestarts
[17:40:53.756]                           grepl <- base::grepl
[17:40:53.756]                           restarts <- computeRestarts(cond)
[17:40:53.756]                           for (restart in restarts) {
[17:40:53.756]                             name <- restart$name
[17:40:53.756]                             if (is.null(name)) 
[17:40:53.756]                               next
[17:40:53.756]                             if (!grepl(pattern, name)) 
[17:40:53.756]                               next
[17:40:53.756]                             invokeRestart(restart)
[17:40:53.756]                             muffled <- TRUE
[17:40:53.756]                             break
[17:40:53.756]                           }
[17:40:53.756]                         }
[17:40:53.756]                       }
[17:40:53.756]                       invisible(muffled)
[17:40:53.756]                     }
[17:40:53.756]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.756]                   }
[17:40:53.756]                 }
[17:40:53.756]             }
[17:40:53.756]         }))
[17:40:53.756]     }, error = function(ex) {
[17:40:53.756]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.756]                 ...future.rng), started = ...future.startTime, 
[17:40:53.756]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.756]             version = "1.8"), class = "FutureResult")
[17:40:53.756]     }, finally = {
[17:40:53.756]         if (!identical(...future.workdir, getwd())) 
[17:40:53.756]             setwd(...future.workdir)
[17:40:53.756]         {
[17:40:53.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.756]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.756]             }
[17:40:53.756]             base::options(...future.oldOptions)
[17:40:53.756]             if (.Platform$OS.type == "windows") {
[17:40:53.756]                 old_names <- names(...future.oldEnvVars)
[17:40:53.756]                 envs <- base::Sys.getenv()
[17:40:53.756]                 names <- names(envs)
[17:40:53.756]                 common <- intersect(names, old_names)
[17:40:53.756]                 added <- setdiff(names, old_names)
[17:40:53.756]                 removed <- setdiff(old_names, names)
[17:40:53.756]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.756]                   envs[common]]
[17:40:53.756]                 NAMES <- toupper(changed)
[17:40:53.756]                 args <- list()
[17:40:53.756]                 for (kk in seq_along(NAMES)) {
[17:40:53.756]                   name <- changed[[kk]]
[17:40:53.756]                   NAME <- NAMES[[kk]]
[17:40:53.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.756]                     next
[17:40:53.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.756]                 }
[17:40:53.756]                 NAMES <- toupper(added)
[17:40:53.756]                 for (kk in seq_along(NAMES)) {
[17:40:53.756]                   name <- added[[kk]]
[17:40:53.756]                   NAME <- NAMES[[kk]]
[17:40:53.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.756]                     next
[17:40:53.756]                   args[[name]] <- ""
[17:40:53.756]                 }
[17:40:53.756]                 NAMES <- toupper(removed)
[17:40:53.756]                 for (kk in seq_along(NAMES)) {
[17:40:53.756]                   name <- removed[[kk]]
[17:40:53.756]                   NAME <- NAMES[[kk]]
[17:40:53.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.756]                     next
[17:40:53.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.756]                 }
[17:40:53.756]                 if (length(args) > 0) 
[17:40:53.756]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.756]             }
[17:40:53.756]             else {
[17:40:53.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.756]             }
[17:40:53.756]             {
[17:40:53.756]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.756]                   0L) {
[17:40:53.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.756]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.756]                   base::options(opts)
[17:40:53.756]                 }
[17:40:53.756]                 {
[17:40:53.756]                   {
[17:40:53.756]                     NULL
[17:40:53.756]                     RNGkind("Mersenne-Twister")
[17:40:53.756]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.756]                       inherits = FALSE)
[17:40:53.756]                   }
[17:40:53.756]                   options(future.plan = NULL)
[17:40:53.756]                   if (is.na(NA_character_)) 
[17:40:53.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.756]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.756]                   {
[17:40:53.756]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.756]                     if (!future$lazy) 
[17:40:53.756]                       future <- run(future)
[17:40:53.756]                     invisible(future)
[17:40:53.756]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.756]                 }
[17:40:53.756]             }
[17:40:53.756]         }
[17:40:53.756]     })
[17:40:53.756]     if (TRUE) {
[17:40:53.756]         base::sink(type = "output", split = FALSE)
[17:40:53.756]         if (TRUE) {
[17:40:53.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.756]         }
[17:40:53.756]         else {
[17:40:53.756]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.756]         }
[17:40:53.756]         base::close(...future.stdout)
[17:40:53.756]         ...future.stdout <- NULL
[17:40:53.756]     }
[17:40:53.756]     ...future.result$conditions <- ...future.conditions
[17:40:53.756]     ...future.result$finished <- base::Sys.time()
[17:40:53.756]     ...future.result
[17:40:53.756] }
[17:40:53.758] assign_globals() ...
[17:40:53.758] List of 11
[17:40:53.758]  $ ...future.FUN            :function (x, ...)  
[17:40:53.758]  $ x_FUN                    :function (x)  
[17:40:53.758]  $ times                    : int 1
[17:40:53.758]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.758]  $ stop_if_not              :function (...)  
[17:40:53.758]  $ dim                      : NULL
[17:40:53.758]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:53.758]  $ future.call.arguments    : list()
[17:40:53.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.758]  $ ...future.elements_ii    :List of 10
[17:40:53.758]   ..$ : int 1
[17:40:53.758]   ..$ : int 2
[17:40:53.758]   ..$ : int 3
[17:40:53.758]   ..$ : int 4
[17:40:53.758]   ..$ : int 5
[17:40:53.758]   ..$ : int 6
[17:40:53.758]   ..$ : int 7
[17:40:53.758]   ..$ : int 8
[17:40:53.758]   ..$ : int 9
[17:40:53.758]   ..$ : int 10
[17:40:53.758]  $ ...future.seeds_ii       : NULL
[17:40:53.758]  $ ...future.globals.maxSize: NULL
[17:40:53.758]  - attr(*, "resolved")= logi FALSE
[17:40:53.758]  - attr(*, "total_size")= num 94336
[17:40:53.758]  - attr(*, "where")=List of 11
[17:40:53.758]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.758]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.758]  - attr(*, "already-done")= logi TRUE
[17:40:53.768] - copied ‘...future.FUN’ to environment
[17:40:53.768] - copied ‘x_FUN’ to environment
[17:40:53.768] - copied ‘times’ to environment
[17:40:53.768] - copied ‘stopf’ to environment
[17:40:53.769] - copied ‘stop_if_not’ to environment
[17:40:53.769] - copied ‘dim’ to environment
[17:40:53.769] - copied ‘valid_types’ to environment
[17:40:53.769] - copied ‘future.call.arguments’ to environment
[17:40:53.769] - copied ‘...future.elements_ii’ to environment
[17:40:53.769] - copied ‘...future.seeds_ii’ to environment
[17:40:53.769] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.769] assign_globals() ... done
[17:40:53.770] plan(): Setting new future strategy stack:
[17:40:53.770] List of future strategies:
[17:40:53.770] 1. sequential:
[17:40:53.770]    - args: function (..., envir = parent.frame())
[17:40:53.770]    - tweaked: FALSE
[17:40:53.770]    - call: NULL
[17:40:53.770] plan(): nbrOfWorkers() = 1
[17:40:53.771] plan(): Setting new future strategy stack:
[17:40:53.771] List of future strategies:
[17:40:53.771] 1. sequential:
[17:40:53.771]    - args: function (..., envir = parent.frame())
[17:40:53.771]    - tweaked: FALSE
[17:40:53.771]    - call: plan(strategy)
[17:40:53.772] plan(): nbrOfWorkers() = 1
[17:40:53.772] SequentialFuture started (and completed)
[17:40:53.772] - Launch lazy future ... done
[17:40:53.772] run() for ‘SequentialFuture’ ... done
[17:40:53.772] Created future:
[17:40:53.772] SequentialFuture:
[17:40:53.772] Label: ‘future_vapply-1’
[17:40:53.772] Expression:
[17:40:53.772] {
[17:40:53.772]     do.call(function(...) {
[17:40:53.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.772]             on.exit(options(oopts), add = TRUE)
[17:40:53.772]         }
[17:40:53.772]         {
[17:40:53.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.772]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.772]             })
[17:40:53.772]         }
[17:40:53.772]     }, args = future.call.arguments)
[17:40:53.772] }
[17:40:53.772] Lazy evaluation: FALSE
[17:40:53.772] Asynchronous evaluation: FALSE
[17:40:53.772] Local evaluation: TRUE
[17:40:53.772] Environment: R_GlobalEnv
[17:40:53.772] Capture standard output: TRUE
[17:40:53.772] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.772] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.772] Packages: 1 packages (‘future.apply’)
[17:40:53.772] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.772] Resolved: TRUE
[17:40:53.772] Value: 560 bytes of class ‘list’
[17:40:53.772] Early signaling: FALSE
[17:40:53.772] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.772] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.774] Chunk #1 of 1 ... DONE
[17:40:53.774] Launching 1 futures (chunks) ... DONE
[17:40:53.774] Resolving 1 futures (chunks) ...
[17:40:53.774] resolve() on list ...
[17:40:53.774]  recursive: 0
[17:40:53.774]  length: 1
[17:40:53.774] 
[17:40:53.774] resolved() for ‘SequentialFuture’ ...
[17:40:53.774] - state: ‘finished’
[17:40:53.774] - run: TRUE
[17:40:53.774] - result: ‘FutureResult’
[17:40:53.775] resolved() for ‘SequentialFuture’ ... done
[17:40:53.775] Future #1
[17:40:53.775] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.775] - nx: 1
[17:40:53.775] - relay: TRUE
[17:40:53.775] - stdout: TRUE
[17:40:53.775] - signal: TRUE
[17:40:53.775] - resignal: FALSE
[17:40:53.775] - force: TRUE
[17:40:53.775] - relayed: [n=1] FALSE
[17:40:53.776] - queued futures: [n=1] FALSE
[17:40:53.776]  - until=1
[17:40:53.776]  - relaying element #1
[17:40:53.776] - relayed: [n=1] TRUE
[17:40:53.776] - queued futures: [n=1] TRUE
[17:40:53.776] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.776]  length: 0 (resolved future 1)
[17:40:53.776] Relaying remaining futures
[17:40:53.776] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.776] - nx: 1
[17:40:53.777] - relay: TRUE
[17:40:53.777] - stdout: TRUE
[17:40:53.777] - signal: TRUE
[17:40:53.777] - resignal: FALSE
[17:40:53.777] - force: TRUE
[17:40:53.777] - relayed: [n=1] TRUE
[17:40:53.777] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.779] - relayed: [n=1] TRUE
[17:40:53.779] - queued futures: [n=1] TRUE
[17:40:53.779] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.779] resolve() on list ... DONE
[17:40:53.779]  - Number of value chunks collected: 1
[17:40:53.779] Resolving 1 futures (chunks) ... DONE
[17:40:53.779] Reducing values from 1 chunks ...
[17:40:53.780]  - Number of values collected after concatenation: 10
[17:40:53.780]  - Number of values expected: 10
[17:40:53.780] Reducing values from 1 chunks ... DONE
[17:40:53.780] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:40:53.781] future_lapply() ...
[17:40:53.782] Number of chunks: 1
[17:40:53.782] getGlobalsAndPackagesXApply() ...
[17:40:53.783]  - future.globals: TRUE
[17:40:53.783] getGlobalsAndPackages() ...
[17:40:53.783] Searching for globals...
[17:40:53.786] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:40:53.786] Searching for globals ... DONE
[17:40:53.787] Resolving globals: FALSE
[17:40:53.787] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:40:53.788] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.788] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.788] - packages: [1] ‘future.apply’
[17:40:53.788] getGlobalsAndPackages() ... DONE
[17:40:53.788]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.788]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.788] Finding globals ... DONE
[17:40:53.789]  - use_args: TRUE
[17:40:53.789]  - Getting '...' globals ...
[17:40:53.789] resolve() on list ...
[17:40:53.789]  recursive: 0
[17:40:53.789]  length: 1
[17:40:53.789]  elements: ‘...’
[17:40:53.789]  length: 0 (resolved future 1)
[17:40:53.789] resolve() on list ... DONE
[17:40:53.790]    - '...' content: [n=0] 
[17:40:53.790] List of 1
[17:40:53.790]  $ ...: list()
[17:40:53.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.790]  - attr(*, "where")=List of 1
[17:40:53.790]   ..$ ...:<environment: 0x564f2eed7040> 
[17:40:53.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.790]  - attr(*, "resolved")= logi TRUE
[17:40:53.790]  - attr(*, "total_size")= num NA
[17:40:53.792]  - Getting '...' globals ... DONE
[17:40:53.792] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.792] List of 8
[17:40:53.792]  $ ...future.FUN:function (x, ...)  
[17:40:53.792]  $ x_FUN        :function (x)  
[17:40:53.792]  $ times        : int 2
[17:40:53.792]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.792]  $ stop_if_not  :function (...)  
[17:40:53.792]  $ dim          : NULL
[17:40:53.792]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:53.792]  $ ...          : list()
[17:40:53.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.792]  - attr(*, "where")=List of 8
[17:40:53.792]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.792]   ..$ ...          :<environment: 0x564f2eed7040> 
[17:40:53.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.792]  - attr(*, "resolved")= logi FALSE
[17:40:53.792]  - attr(*, "total_size")= num 96456
[17:40:53.798] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.798] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.798] Number of futures (= number of chunks): 1
[17:40:53.798] Launching 1 futures (chunks) ...
[17:40:53.798] Chunk #1 of 1 ...
[17:40:53.798]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.800] getGlobalsAndPackages() ...
[17:40:53.800] Searching for globals...
[17:40:53.801] 
[17:40:53.801] Searching for globals ... DONE
[17:40:53.801] - globals: [0] <none>
[17:40:53.801] getGlobalsAndPackages() ... DONE
[17:40:53.801]    + additional globals found: [n=0] 
[17:40:53.801]    + additional namespaces needed: [n=0] 
[17:40:53.801]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.801]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.801]  - seeds: <none>
[17:40:53.802] getGlobalsAndPackages() ...
[17:40:53.802] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.802] Resolving globals: FALSE
[17:40:53.802] Tweak future expression to call with '...' arguments ...
[17:40:53.802] {
[17:40:53.802]     do.call(function(...) {
[17:40:53.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.802]             on.exit(options(oopts), add = TRUE)
[17:40:53.802]         }
[17:40:53.802]         {
[17:40:53.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.802]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.802]             })
[17:40:53.802]         }
[17:40:53.802]     }, args = future.call.arguments)
[17:40:53.802] }
[17:40:53.802] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.803] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.803] - packages: [1] ‘future.apply’
[17:40:53.803] getGlobalsAndPackages() ... DONE
[17:40:53.803] run() for ‘Future’ ...
[17:40:53.803] - state: ‘created’
[17:40:53.804] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.804] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.804]   - Field: ‘label’
[17:40:53.804]   - Field: ‘local’
[17:40:53.804]   - Field: ‘owner’
[17:40:53.804]   - Field: ‘envir’
[17:40:53.805]   - Field: ‘packages’
[17:40:53.805]   - Field: ‘gc’
[17:40:53.805]   - Field: ‘conditions’
[17:40:53.805]   - Field: ‘expr’
[17:40:53.805]   - Field: ‘uuid’
[17:40:53.805]   - Field: ‘seed’
[17:40:53.805]   - Field: ‘version’
[17:40:53.805]   - Field: ‘result’
[17:40:53.805]   - Field: ‘asynchronous’
[17:40:53.805]   - Field: ‘calls’
[17:40:53.806]   - Field: ‘globals’
[17:40:53.806]   - Field: ‘stdout’
[17:40:53.806]   - Field: ‘earlySignal’
[17:40:53.806]   - Field: ‘lazy’
[17:40:53.806]   - Field: ‘state’
[17:40:53.806] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.806] - Launch lazy future ...
[17:40:53.806] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.806] Packages needed by future strategies (n = 0): <none>
[17:40:53.807] {
[17:40:53.807]     {
[17:40:53.807]         {
[17:40:53.807]             ...future.startTime <- base::Sys.time()
[17:40:53.807]             {
[17:40:53.807]                 {
[17:40:53.807]                   {
[17:40:53.807]                     {
[17:40:53.807]                       base::local({
[17:40:53.807]                         has_future <- base::requireNamespace("future", 
[17:40:53.807]                           quietly = TRUE)
[17:40:53.807]                         if (has_future) {
[17:40:53.807]                           ns <- base::getNamespace("future")
[17:40:53.807]                           version <- ns[[".package"]][["version"]]
[17:40:53.807]                           if (is.null(version)) 
[17:40:53.807]                             version <- utils::packageVersion("future")
[17:40:53.807]                         }
[17:40:53.807]                         else {
[17:40:53.807]                           version <- NULL
[17:40:53.807]                         }
[17:40:53.807]                         if (!has_future || version < "1.8.0") {
[17:40:53.807]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.807]                             "", base::R.version$version.string), 
[17:40:53.807]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.807]                               "release", "version")], collapse = " "), 
[17:40:53.807]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.807]                             info)
[17:40:53.807]                           info <- base::paste(info, collapse = "; ")
[17:40:53.807]                           if (!has_future) {
[17:40:53.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.807]                               info)
[17:40:53.807]                           }
[17:40:53.807]                           else {
[17:40:53.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.807]                               info, version)
[17:40:53.807]                           }
[17:40:53.807]                           base::stop(msg)
[17:40:53.807]                         }
[17:40:53.807]                       })
[17:40:53.807]                     }
[17:40:53.807]                     base::local({
[17:40:53.807]                       for (pkg in "future.apply") {
[17:40:53.807]                         base::loadNamespace(pkg)
[17:40:53.807]                         base::library(pkg, character.only = TRUE)
[17:40:53.807]                       }
[17:40:53.807]                     })
[17:40:53.807]                   }
[17:40:53.807]                   options(future.plan = NULL)
[17:40:53.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.807]                 }
[17:40:53.807]                 ...future.workdir <- getwd()
[17:40:53.807]             }
[17:40:53.807]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.807]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.807]         }
[17:40:53.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.807]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.807]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.807]             base::names(...future.oldOptions))
[17:40:53.807]     }
[17:40:53.807]     if (FALSE) {
[17:40:53.807]     }
[17:40:53.807]     else {
[17:40:53.807]         if (TRUE) {
[17:40:53.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.807]                 open = "w")
[17:40:53.807]         }
[17:40:53.807]         else {
[17:40:53.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.807]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.807]         }
[17:40:53.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.807]             base::sink(type = "output", split = FALSE)
[17:40:53.807]             base::close(...future.stdout)
[17:40:53.807]         }, add = TRUE)
[17:40:53.807]     }
[17:40:53.807]     ...future.frame <- base::sys.nframe()
[17:40:53.807]     ...future.conditions <- base::list()
[17:40:53.807]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.807]     if (FALSE) {
[17:40:53.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.807]     }
[17:40:53.807]     ...future.result <- base::tryCatch({
[17:40:53.807]         base::withCallingHandlers({
[17:40:53.807]             ...future.value <- base::withVisible(base::local({
[17:40:53.807]                 do.call(function(...) {
[17:40:53.807]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.807]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.807]                     ...future.globals.maxSize)) {
[17:40:53.807]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.807]                     on.exit(options(oopts), add = TRUE)
[17:40:53.807]                   }
[17:40:53.807]                   {
[17:40:53.807]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.807]                       FUN = function(jj) {
[17:40:53.807]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.807]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.807]                       })
[17:40:53.807]                   }
[17:40:53.807]                 }, args = future.call.arguments)
[17:40:53.807]             }))
[17:40:53.807]             future::FutureResult(value = ...future.value$value, 
[17:40:53.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.807]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.807]                     ...future.globalenv.names))
[17:40:53.807]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.807]         }, condition = base::local({
[17:40:53.807]             c <- base::c
[17:40:53.807]             inherits <- base::inherits
[17:40:53.807]             invokeRestart <- base::invokeRestart
[17:40:53.807]             length <- base::length
[17:40:53.807]             list <- base::list
[17:40:53.807]             seq.int <- base::seq.int
[17:40:53.807]             signalCondition <- base::signalCondition
[17:40:53.807]             sys.calls <- base::sys.calls
[17:40:53.807]             `[[` <- base::`[[`
[17:40:53.807]             `+` <- base::`+`
[17:40:53.807]             `<<-` <- base::`<<-`
[17:40:53.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.807]                   3L)]
[17:40:53.807]             }
[17:40:53.807]             function(cond) {
[17:40:53.807]                 is_error <- inherits(cond, "error")
[17:40:53.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.807]                   NULL)
[17:40:53.807]                 if (is_error) {
[17:40:53.807]                   sessionInformation <- function() {
[17:40:53.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.807]                       search = base::search(), system = base::Sys.info())
[17:40:53.807]                   }
[17:40:53.807]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.807]                     cond$call), session = sessionInformation(), 
[17:40:53.807]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.807]                   signalCondition(cond)
[17:40:53.807]                 }
[17:40:53.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.807]                 "immediateCondition"))) {
[17:40:53.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.807]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.807]                   if (TRUE && !signal) {
[17:40:53.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.807]                     {
[17:40:53.807]                       inherits <- base::inherits
[17:40:53.807]                       invokeRestart <- base::invokeRestart
[17:40:53.807]                       is.null <- base::is.null
[17:40:53.807]                       muffled <- FALSE
[17:40:53.807]                       if (inherits(cond, "message")) {
[17:40:53.807]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.807]                         if (muffled) 
[17:40:53.807]                           invokeRestart("muffleMessage")
[17:40:53.807]                       }
[17:40:53.807]                       else if (inherits(cond, "warning")) {
[17:40:53.807]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.807]                         if (muffled) 
[17:40:53.807]                           invokeRestart("muffleWarning")
[17:40:53.807]                       }
[17:40:53.807]                       else if (inherits(cond, "condition")) {
[17:40:53.807]                         if (!is.null(pattern)) {
[17:40:53.807]                           computeRestarts <- base::computeRestarts
[17:40:53.807]                           grepl <- base::grepl
[17:40:53.807]                           restarts <- computeRestarts(cond)
[17:40:53.807]                           for (restart in restarts) {
[17:40:53.807]                             name <- restart$name
[17:40:53.807]                             if (is.null(name)) 
[17:40:53.807]                               next
[17:40:53.807]                             if (!grepl(pattern, name)) 
[17:40:53.807]                               next
[17:40:53.807]                             invokeRestart(restart)
[17:40:53.807]                             muffled <- TRUE
[17:40:53.807]                             break
[17:40:53.807]                           }
[17:40:53.807]                         }
[17:40:53.807]                       }
[17:40:53.807]                       invisible(muffled)
[17:40:53.807]                     }
[17:40:53.807]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.807]                   }
[17:40:53.807]                 }
[17:40:53.807]                 else {
[17:40:53.807]                   if (TRUE) {
[17:40:53.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.807]                     {
[17:40:53.807]                       inherits <- base::inherits
[17:40:53.807]                       invokeRestart <- base::invokeRestart
[17:40:53.807]                       is.null <- base::is.null
[17:40:53.807]                       muffled <- FALSE
[17:40:53.807]                       if (inherits(cond, "message")) {
[17:40:53.807]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.807]                         if (muffled) 
[17:40:53.807]                           invokeRestart("muffleMessage")
[17:40:53.807]                       }
[17:40:53.807]                       else if (inherits(cond, "warning")) {
[17:40:53.807]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.807]                         if (muffled) 
[17:40:53.807]                           invokeRestart("muffleWarning")
[17:40:53.807]                       }
[17:40:53.807]                       else if (inherits(cond, "condition")) {
[17:40:53.807]                         if (!is.null(pattern)) {
[17:40:53.807]                           computeRestarts <- base::computeRestarts
[17:40:53.807]                           grepl <- base::grepl
[17:40:53.807]                           restarts <- computeRestarts(cond)
[17:40:53.807]                           for (restart in restarts) {
[17:40:53.807]                             name <- restart$name
[17:40:53.807]                             if (is.null(name)) 
[17:40:53.807]                               next
[17:40:53.807]                             if (!grepl(pattern, name)) 
[17:40:53.807]                               next
[17:40:53.807]                             invokeRestart(restart)
[17:40:53.807]                             muffled <- TRUE
[17:40:53.807]                             break
[17:40:53.807]                           }
[17:40:53.807]                         }
[17:40:53.807]                       }
[17:40:53.807]                       invisible(muffled)
[17:40:53.807]                     }
[17:40:53.807]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.807]                   }
[17:40:53.807]                 }
[17:40:53.807]             }
[17:40:53.807]         }))
[17:40:53.807]     }, error = function(ex) {
[17:40:53.807]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.807]                 ...future.rng), started = ...future.startTime, 
[17:40:53.807]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.807]             version = "1.8"), class = "FutureResult")
[17:40:53.807]     }, finally = {
[17:40:53.807]         if (!identical(...future.workdir, getwd())) 
[17:40:53.807]             setwd(...future.workdir)
[17:40:53.807]         {
[17:40:53.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.807]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.807]             }
[17:40:53.807]             base::options(...future.oldOptions)
[17:40:53.807]             if (.Platform$OS.type == "windows") {
[17:40:53.807]                 old_names <- names(...future.oldEnvVars)
[17:40:53.807]                 envs <- base::Sys.getenv()
[17:40:53.807]                 names <- names(envs)
[17:40:53.807]                 common <- intersect(names, old_names)
[17:40:53.807]                 added <- setdiff(names, old_names)
[17:40:53.807]                 removed <- setdiff(old_names, names)
[17:40:53.807]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.807]                   envs[common]]
[17:40:53.807]                 NAMES <- toupper(changed)
[17:40:53.807]                 args <- list()
[17:40:53.807]                 for (kk in seq_along(NAMES)) {
[17:40:53.807]                   name <- changed[[kk]]
[17:40:53.807]                   NAME <- NAMES[[kk]]
[17:40:53.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.807]                     next
[17:40:53.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.807]                 }
[17:40:53.807]                 NAMES <- toupper(added)
[17:40:53.807]                 for (kk in seq_along(NAMES)) {
[17:40:53.807]                   name <- added[[kk]]
[17:40:53.807]                   NAME <- NAMES[[kk]]
[17:40:53.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.807]                     next
[17:40:53.807]                   args[[name]] <- ""
[17:40:53.807]                 }
[17:40:53.807]                 NAMES <- toupper(removed)
[17:40:53.807]                 for (kk in seq_along(NAMES)) {
[17:40:53.807]                   name <- removed[[kk]]
[17:40:53.807]                   NAME <- NAMES[[kk]]
[17:40:53.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.807]                     next
[17:40:53.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.807]                 }
[17:40:53.807]                 if (length(args) > 0) 
[17:40:53.807]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.807]             }
[17:40:53.807]             else {
[17:40:53.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.807]             }
[17:40:53.807]             {
[17:40:53.807]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.807]                   0L) {
[17:40:53.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.807]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.807]                   base::options(opts)
[17:40:53.807]                 }
[17:40:53.807]                 {
[17:40:53.807]                   {
[17:40:53.807]                     NULL
[17:40:53.807]                     RNGkind("Mersenne-Twister")
[17:40:53.807]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.807]                       inherits = FALSE)
[17:40:53.807]                   }
[17:40:53.807]                   options(future.plan = NULL)
[17:40:53.807]                   if (is.na(NA_character_)) 
[17:40:53.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.807]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.807]                   {
[17:40:53.807]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.807]                     if (!future$lazy) 
[17:40:53.807]                       future <- run(future)
[17:40:53.807]                     invisible(future)
[17:40:53.807]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.807]                 }
[17:40:53.807]             }
[17:40:53.807]         }
[17:40:53.807]     })
[17:40:53.807]     if (TRUE) {
[17:40:53.807]         base::sink(type = "output", split = FALSE)
[17:40:53.807]         if (TRUE) {
[17:40:53.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.807]         }
[17:40:53.807]         else {
[17:40:53.807]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.807]         }
[17:40:53.807]         base::close(...future.stdout)
[17:40:53.807]         ...future.stdout <- NULL
[17:40:53.807]     }
[17:40:53.807]     ...future.result$conditions <- ...future.conditions
[17:40:53.807]     ...future.result$finished <- base::Sys.time()
[17:40:53.807]     ...future.result
[17:40:53.807] }
[17:40:53.809] assign_globals() ...
[17:40:53.809] List of 11
[17:40:53.809]  $ ...future.FUN            :function (x, ...)  
[17:40:53.809]  $ x_FUN                    :function (x)  
[17:40:53.809]  $ times                    : int 2
[17:40:53.809]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.809]  $ stop_if_not              :function (...)  
[17:40:53.809]  $ dim                      : NULL
[17:40:53.809]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:53.809]  $ future.call.arguments    : list()
[17:40:53.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.809]  $ ...future.elements_ii    :List of 10
[17:40:53.809]   ..$ : int 1
[17:40:53.809]   ..$ : int 2
[17:40:53.809]   ..$ : int 3
[17:40:53.809]   ..$ : int 4
[17:40:53.809]   ..$ : int 5
[17:40:53.809]   ..$ : int 6
[17:40:53.809]   ..$ : int 7
[17:40:53.809]   ..$ : int 8
[17:40:53.809]   ..$ : int 9
[17:40:53.809]   ..$ : int 10
[17:40:53.809]  $ ...future.seeds_ii       : NULL
[17:40:53.809]  $ ...future.globals.maxSize: NULL
[17:40:53.809]  - attr(*, "resolved")= logi FALSE
[17:40:53.809]  - attr(*, "total_size")= num 96456
[17:40:53.809]  - attr(*, "where")=List of 11
[17:40:53.809]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.809]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.809]  - attr(*, "already-done")= logi TRUE
[17:40:53.819] - copied ‘...future.FUN’ to environment
[17:40:53.819] - reassign environment for ‘x_FUN’
[17:40:53.819] - copied ‘x_FUN’ to environment
[17:40:53.819] - copied ‘times’ to environment
[17:40:53.819] - copied ‘stopf’ to environment
[17:40:53.819] - copied ‘stop_if_not’ to environment
[17:40:53.819] - copied ‘dim’ to environment
[17:40:53.819] - copied ‘valid_types’ to environment
[17:40:53.819] - copied ‘future.call.arguments’ to environment
[17:40:53.819] - copied ‘...future.elements_ii’ to environment
[17:40:53.820] - copied ‘...future.seeds_ii’ to environment
[17:40:53.820] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.820] assign_globals() ... done
[17:40:53.820] plan(): Setting new future strategy stack:
[17:40:53.820] List of future strategies:
[17:40:53.820] 1. sequential:
[17:40:53.820]    - args: function (..., envir = parent.frame())
[17:40:53.820]    - tweaked: FALSE
[17:40:53.820]    - call: NULL
[17:40:53.821] plan(): nbrOfWorkers() = 1
[17:40:53.821] plan(): Setting new future strategy stack:
[17:40:53.821] List of future strategies:
[17:40:53.821] 1. sequential:
[17:40:53.821]    - args: function (..., envir = parent.frame())
[17:40:53.821]    - tweaked: FALSE
[17:40:53.821]    - call: plan(strategy)
[17:40:53.822] plan(): nbrOfWorkers() = 1
[17:40:53.823] SequentialFuture started (and completed)
[17:40:53.823] - Launch lazy future ... done
[17:40:53.823] run() for ‘SequentialFuture’ ... done
[17:40:53.824] Created future:
[17:40:53.824] SequentialFuture:
[17:40:53.824] Label: ‘future_vapply-1’
[17:40:53.824] Expression:
[17:40:53.824] {
[17:40:53.824]     do.call(function(...) {
[17:40:53.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.824]             on.exit(options(oopts), add = TRUE)
[17:40:53.824]         }
[17:40:53.824]         {
[17:40:53.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.824]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.824]             })
[17:40:53.824]         }
[17:40:53.824]     }, args = future.call.arguments)
[17:40:53.824] }
[17:40:53.824] Lazy evaluation: FALSE
[17:40:53.824] Asynchronous evaluation: FALSE
[17:40:53.824] Local evaluation: TRUE
[17:40:53.824] Environment: R_GlobalEnv
[17:40:53.824] Capture standard output: TRUE
[17:40:53.824] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.824] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.824] Packages: 1 packages (‘future.apply’)
[17:40:53.824] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.824] Resolved: TRUE
[17:40:53.824] Value: 640 bytes of class ‘list’
[17:40:53.824] Early signaling: FALSE
[17:40:53.824] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.824] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.825] Chunk #1 of 1 ... DONE
[17:40:53.825] Launching 1 futures (chunks) ... DONE
[17:40:53.825] Resolving 1 futures (chunks) ...
[17:40:53.825] resolve() on list ...
[17:40:53.825]  recursive: 0
[17:40:53.825]  length: 1
[17:40:53.825] 
[17:40:53.826] resolved() for ‘SequentialFuture’ ...
[17:40:53.826] - state: ‘finished’
[17:40:53.826] - run: TRUE
[17:40:53.826] - result: ‘FutureResult’
[17:40:53.826] resolved() for ‘SequentialFuture’ ... done
[17:40:53.826] Future #1
[17:40:53.826] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.826] - nx: 1
[17:40:53.826] - relay: TRUE
[17:40:53.826] - stdout: TRUE
[17:40:53.826] - signal: TRUE
[17:40:53.827] - resignal: FALSE
[17:40:53.827] - force: TRUE
[17:40:53.827] - relayed: [n=1] FALSE
[17:40:53.827] - queued futures: [n=1] FALSE
[17:40:53.827]  - until=1
[17:40:53.827]  - relaying element #1
[17:40:53.827] - relayed: [n=1] TRUE
[17:40:53.827] - queued futures: [n=1] TRUE
[17:40:53.827] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.827]  length: 0 (resolved future 1)
[17:40:53.828] Relaying remaining futures
[17:40:53.828] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.828] - nx: 1
[17:40:53.828] - relay: TRUE
[17:40:53.828] - stdout: TRUE
[17:40:53.828] - signal: TRUE
[17:40:53.828] - resignal: FALSE
[17:40:53.828] - force: TRUE
[17:40:53.828] - relayed: [n=1] TRUE
[17:40:53.828] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.828] - relayed: [n=1] TRUE
[17:40:53.829] - queued futures: [n=1] TRUE
[17:40:53.829] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.829] resolve() on list ... DONE
[17:40:53.829]  - Number of value chunks collected: 1
[17:40:53.829] Resolving 1 futures (chunks) ... DONE
[17:40:53.829] Reducing values from 1 chunks ...
[17:40:53.829]  - Number of values collected after concatenation: 10
[17:40:53.829]  - Number of values expected: 10
[17:40:53.829] Reducing values from 1 chunks ... DONE
[17:40:53.829] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:40:53.830] future_lapply() ...
[17:40:53.832] Number of chunks: 1
[17:40:53.832] getGlobalsAndPackagesXApply() ...
[17:40:53.832]  - future.globals: TRUE
[17:40:53.832] getGlobalsAndPackages() ...
[17:40:53.832] Searching for globals...
[17:40:53.836] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:40:53.836] Searching for globals ... DONE
[17:40:53.836] Resolving globals: FALSE
[17:40:53.837] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:40:53.837] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.837] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.837] - packages: [1] ‘future.apply’
[17:40:53.837] getGlobalsAndPackages() ... DONE
[17:40:53.838]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.838]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.838] Finding globals ... DONE
[17:40:53.838]  - use_args: TRUE
[17:40:53.838]  - Getting '...' globals ...
[17:40:53.838] resolve() on list ...
[17:40:53.838]  recursive: 0
[17:40:53.838]  length: 1
[17:40:53.838]  elements: ‘...’
[17:40:53.839]  length: 0 (resolved future 1)
[17:40:53.839] resolve() on list ... DONE
[17:40:53.839]    - '...' content: [n=0] 
[17:40:53.839] List of 1
[17:40:53.839]  $ ...: list()
[17:40:53.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.839]  - attr(*, "where")=List of 1
[17:40:53.839]   ..$ ...:<environment: 0x564f2f6b1530> 
[17:40:53.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.839]  - attr(*, "resolved")= logi TRUE
[17:40:53.839]  - attr(*, "total_size")= num NA
[17:40:53.841]  - Getting '...' globals ... DONE
[17:40:53.841] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.842] List of 8
[17:40:53.842]  $ ...future.FUN:function (x, ...)  
[17:40:53.842]  $ x_FUN        :function (x)  
[17:40:53.842]  $ times        : int 4
[17:40:53.842]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.842]  $ stop_if_not  :function (...)  
[17:40:53.842]  $ dim          : int [1:2] 2 2
[17:40:53.842]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:53.842]  $ ...          : list()
[17:40:53.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.842]  - attr(*, "where")=List of 8
[17:40:53.842]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.842]   ..$ ...          :<environment: 0x564f2f6b1530> 
[17:40:53.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.842]  - attr(*, "resolved")= logi FALSE
[17:40:53.842]  - attr(*, "total_size")= num 97232
[17:40:53.848] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.848] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.848] Number of futures (= number of chunks): 1
[17:40:53.849] Launching 1 futures (chunks) ...
[17:40:53.849] Chunk #1 of 1 ...
[17:40:53.849]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.849] getGlobalsAndPackages() ...
[17:40:53.849] Searching for globals...
[17:40:53.849] 
[17:40:53.849] Searching for globals ... DONE
[17:40:53.849] - globals: [0] <none>
[17:40:53.849] getGlobalsAndPackages() ... DONE
[17:40:53.850]    + additional globals found: [n=0] 
[17:40:53.850]    + additional namespaces needed: [n=0] 
[17:40:53.850]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.850]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.850]  - seeds: <none>
[17:40:53.850] getGlobalsAndPackages() ...
[17:40:53.850] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.850] Resolving globals: FALSE
[17:40:53.850] Tweak future expression to call with '...' arguments ...
[17:40:53.850] {
[17:40:53.850]     do.call(function(...) {
[17:40:53.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.850]             on.exit(options(oopts), add = TRUE)
[17:40:53.850]         }
[17:40:53.850]         {
[17:40:53.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.850]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.850]             })
[17:40:53.850]         }
[17:40:53.850]     }, args = future.call.arguments)
[17:40:53.850] }
[17:40:53.851] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.851] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.851] - packages: [1] ‘future.apply’
[17:40:53.851] getGlobalsAndPackages() ... DONE
[17:40:53.852] run() for ‘Future’ ...
[17:40:53.852] - state: ‘created’
[17:40:53.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.852]   - Field: ‘label’
[17:40:53.853]   - Field: ‘local’
[17:40:53.853]   - Field: ‘owner’
[17:40:53.853]   - Field: ‘envir’
[17:40:53.853]   - Field: ‘packages’
[17:40:53.853]   - Field: ‘gc’
[17:40:53.853]   - Field: ‘conditions’
[17:40:53.853]   - Field: ‘expr’
[17:40:53.853]   - Field: ‘uuid’
[17:40:53.853]   - Field: ‘seed’
[17:40:53.853]   - Field: ‘version’
[17:40:53.853]   - Field: ‘result’
[17:40:53.854]   - Field: ‘asynchronous’
[17:40:53.854]   - Field: ‘calls’
[17:40:53.854]   - Field: ‘globals’
[17:40:53.854]   - Field: ‘stdout’
[17:40:53.854]   - Field: ‘earlySignal’
[17:40:53.854]   - Field: ‘lazy’
[17:40:53.854]   - Field: ‘state’
[17:40:53.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.854] - Launch lazy future ...
[17:40:53.854] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.855] Packages needed by future strategies (n = 0): <none>
[17:40:53.855] {
[17:40:53.855]     {
[17:40:53.855]         {
[17:40:53.855]             ...future.startTime <- base::Sys.time()
[17:40:53.855]             {
[17:40:53.855]                 {
[17:40:53.855]                   {
[17:40:53.855]                     {
[17:40:53.855]                       base::local({
[17:40:53.855]                         has_future <- base::requireNamespace("future", 
[17:40:53.855]                           quietly = TRUE)
[17:40:53.855]                         if (has_future) {
[17:40:53.855]                           ns <- base::getNamespace("future")
[17:40:53.855]                           version <- ns[[".package"]][["version"]]
[17:40:53.855]                           if (is.null(version)) 
[17:40:53.855]                             version <- utils::packageVersion("future")
[17:40:53.855]                         }
[17:40:53.855]                         else {
[17:40:53.855]                           version <- NULL
[17:40:53.855]                         }
[17:40:53.855]                         if (!has_future || version < "1.8.0") {
[17:40:53.855]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.855]                             "", base::R.version$version.string), 
[17:40:53.855]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.855]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.855]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.855]                               "release", "version")], collapse = " "), 
[17:40:53.855]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.855]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.855]                             info)
[17:40:53.855]                           info <- base::paste(info, collapse = "; ")
[17:40:53.855]                           if (!has_future) {
[17:40:53.855]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.855]                               info)
[17:40:53.855]                           }
[17:40:53.855]                           else {
[17:40:53.855]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.855]                               info, version)
[17:40:53.855]                           }
[17:40:53.855]                           base::stop(msg)
[17:40:53.855]                         }
[17:40:53.855]                       })
[17:40:53.855]                     }
[17:40:53.855]                     base::local({
[17:40:53.855]                       for (pkg in "future.apply") {
[17:40:53.855]                         base::loadNamespace(pkg)
[17:40:53.855]                         base::library(pkg, character.only = TRUE)
[17:40:53.855]                       }
[17:40:53.855]                     })
[17:40:53.855]                   }
[17:40:53.855]                   options(future.plan = NULL)
[17:40:53.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.855]                 }
[17:40:53.855]                 ...future.workdir <- getwd()
[17:40:53.855]             }
[17:40:53.855]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.855]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.855]         }
[17:40:53.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.855]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.855]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.855]             base::names(...future.oldOptions))
[17:40:53.855]     }
[17:40:53.855]     if (FALSE) {
[17:40:53.855]     }
[17:40:53.855]     else {
[17:40:53.855]         if (TRUE) {
[17:40:53.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.855]                 open = "w")
[17:40:53.855]         }
[17:40:53.855]         else {
[17:40:53.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.855]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.855]         }
[17:40:53.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.855]             base::sink(type = "output", split = FALSE)
[17:40:53.855]             base::close(...future.stdout)
[17:40:53.855]         }, add = TRUE)
[17:40:53.855]     }
[17:40:53.855]     ...future.frame <- base::sys.nframe()
[17:40:53.855]     ...future.conditions <- base::list()
[17:40:53.855]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.855]     if (FALSE) {
[17:40:53.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.855]     }
[17:40:53.855]     ...future.result <- base::tryCatch({
[17:40:53.855]         base::withCallingHandlers({
[17:40:53.855]             ...future.value <- base::withVisible(base::local({
[17:40:53.855]                 do.call(function(...) {
[17:40:53.855]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.855]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.855]                     ...future.globals.maxSize)) {
[17:40:53.855]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.855]                     on.exit(options(oopts), add = TRUE)
[17:40:53.855]                   }
[17:40:53.855]                   {
[17:40:53.855]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.855]                       FUN = function(jj) {
[17:40:53.855]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.855]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.855]                       })
[17:40:53.855]                   }
[17:40:53.855]                 }, args = future.call.arguments)
[17:40:53.855]             }))
[17:40:53.855]             future::FutureResult(value = ...future.value$value, 
[17:40:53.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.855]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.855]                     ...future.globalenv.names))
[17:40:53.855]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.855]         }, condition = base::local({
[17:40:53.855]             c <- base::c
[17:40:53.855]             inherits <- base::inherits
[17:40:53.855]             invokeRestart <- base::invokeRestart
[17:40:53.855]             length <- base::length
[17:40:53.855]             list <- base::list
[17:40:53.855]             seq.int <- base::seq.int
[17:40:53.855]             signalCondition <- base::signalCondition
[17:40:53.855]             sys.calls <- base::sys.calls
[17:40:53.855]             `[[` <- base::`[[`
[17:40:53.855]             `+` <- base::`+`
[17:40:53.855]             `<<-` <- base::`<<-`
[17:40:53.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.855]                   3L)]
[17:40:53.855]             }
[17:40:53.855]             function(cond) {
[17:40:53.855]                 is_error <- inherits(cond, "error")
[17:40:53.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.855]                   NULL)
[17:40:53.855]                 if (is_error) {
[17:40:53.855]                   sessionInformation <- function() {
[17:40:53.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.855]                       search = base::search(), system = base::Sys.info())
[17:40:53.855]                   }
[17:40:53.855]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.855]                     cond$call), session = sessionInformation(), 
[17:40:53.855]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.855]                   signalCondition(cond)
[17:40:53.855]                 }
[17:40:53.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.855]                 "immediateCondition"))) {
[17:40:53.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.855]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.855]                   if (TRUE && !signal) {
[17:40:53.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.855]                     {
[17:40:53.855]                       inherits <- base::inherits
[17:40:53.855]                       invokeRestart <- base::invokeRestart
[17:40:53.855]                       is.null <- base::is.null
[17:40:53.855]                       muffled <- FALSE
[17:40:53.855]                       if (inherits(cond, "message")) {
[17:40:53.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.855]                         if (muffled) 
[17:40:53.855]                           invokeRestart("muffleMessage")
[17:40:53.855]                       }
[17:40:53.855]                       else if (inherits(cond, "warning")) {
[17:40:53.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.855]                         if (muffled) 
[17:40:53.855]                           invokeRestart("muffleWarning")
[17:40:53.855]                       }
[17:40:53.855]                       else if (inherits(cond, "condition")) {
[17:40:53.855]                         if (!is.null(pattern)) {
[17:40:53.855]                           computeRestarts <- base::computeRestarts
[17:40:53.855]                           grepl <- base::grepl
[17:40:53.855]                           restarts <- computeRestarts(cond)
[17:40:53.855]                           for (restart in restarts) {
[17:40:53.855]                             name <- restart$name
[17:40:53.855]                             if (is.null(name)) 
[17:40:53.855]                               next
[17:40:53.855]                             if (!grepl(pattern, name)) 
[17:40:53.855]                               next
[17:40:53.855]                             invokeRestart(restart)
[17:40:53.855]                             muffled <- TRUE
[17:40:53.855]                             break
[17:40:53.855]                           }
[17:40:53.855]                         }
[17:40:53.855]                       }
[17:40:53.855]                       invisible(muffled)
[17:40:53.855]                     }
[17:40:53.855]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.855]                   }
[17:40:53.855]                 }
[17:40:53.855]                 else {
[17:40:53.855]                   if (TRUE) {
[17:40:53.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.855]                     {
[17:40:53.855]                       inherits <- base::inherits
[17:40:53.855]                       invokeRestart <- base::invokeRestart
[17:40:53.855]                       is.null <- base::is.null
[17:40:53.855]                       muffled <- FALSE
[17:40:53.855]                       if (inherits(cond, "message")) {
[17:40:53.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.855]                         if (muffled) 
[17:40:53.855]                           invokeRestart("muffleMessage")
[17:40:53.855]                       }
[17:40:53.855]                       else if (inherits(cond, "warning")) {
[17:40:53.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.855]                         if (muffled) 
[17:40:53.855]                           invokeRestart("muffleWarning")
[17:40:53.855]                       }
[17:40:53.855]                       else if (inherits(cond, "condition")) {
[17:40:53.855]                         if (!is.null(pattern)) {
[17:40:53.855]                           computeRestarts <- base::computeRestarts
[17:40:53.855]                           grepl <- base::grepl
[17:40:53.855]                           restarts <- computeRestarts(cond)
[17:40:53.855]                           for (restart in restarts) {
[17:40:53.855]                             name <- restart$name
[17:40:53.855]                             if (is.null(name)) 
[17:40:53.855]                               next
[17:40:53.855]                             if (!grepl(pattern, name)) 
[17:40:53.855]                               next
[17:40:53.855]                             invokeRestart(restart)
[17:40:53.855]                             muffled <- TRUE
[17:40:53.855]                             break
[17:40:53.855]                           }
[17:40:53.855]                         }
[17:40:53.855]                       }
[17:40:53.855]                       invisible(muffled)
[17:40:53.855]                     }
[17:40:53.855]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.855]                   }
[17:40:53.855]                 }
[17:40:53.855]             }
[17:40:53.855]         }))
[17:40:53.855]     }, error = function(ex) {
[17:40:53.855]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.855]                 ...future.rng), started = ...future.startTime, 
[17:40:53.855]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.855]             version = "1.8"), class = "FutureResult")
[17:40:53.855]     }, finally = {
[17:40:53.855]         if (!identical(...future.workdir, getwd())) 
[17:40:53.855]             setwd(...future.workdir)
[17:40:53.855]         {
[17:40:53.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.855]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.855]             }
[17:40:53.855]             base::options(...future.oldOptions)
[17:40:53.855]             if (.Platform$OS.type == "windows") {
[17:40:53.855]                 old_names <- names(...future.oldEnvVars)
[17:40:53.855]                 envs <- base::Sys.getenv()
[17:40:53.855]                 names <- names(envs)
[17:40:53.855]                 common <- intersect(names, old_names)
[17:40:53.855]                 added <- setdiff(names, old_names)
[17:40:53.855]                 removed <- setdiff(old_names, names)
[17:40:53.855]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.855]                   envs[common]]
[17:40:53.855]                 NAMES <- toupper(changed)
[17:40:53.855]                 args <- list()
[17:40:53.855]                 for (kk in seq_along(NAMES)) {
[17:40:53.855]                   name <- changed[[kk]]
[17:40:53.855]                   NAME <- NAMES[[kk]]
[17:40:53.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.855]                     next
[17:40:53.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.855]                 }
[17:40:53.855]                 NAMES <- toupper(added)
[17:40:53.855]                 for (kk in seq_along(NAMES)) {
[17:40:53.855]                   name <- added[[kk]]
[17:40:53.855]                   NAME <- NAMES[[kk]]
[17:40:53.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.855]                     next
[17:40:53.855]                   args[[name]] <- ""
[17:40:53.855]                 }
[17:40:53.855]                 NAMES <- toupper(removed)
[17:40:53.855]                 for (kk in seq_along(NAMES)) {
[17:40:53.855]                   name <- removed[[kk]]
[17:40:53.855]                   NAME <- NAMES[[kk]]
[17:40:53.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.855]                     next
[17:40:53.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.855]                 }
[17:40:53.855]                 if (length(args) > 0) 
[17:40:53.855]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.855]             }
[17:40:53.855]             else {
[17:40:53.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.855]             }
[17:40:53.855]             {
[17:40:53.855]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.855]                   0L) {
[17:40:53.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.855]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.855]                   base::options(opts)
[17:40:53.855]                 }
[17:40:53.855]                 {
[17:40:53.855]                   {
[17:40:53.855]                     NULL
[17:40:53.855]                     RNGkind("Mersenne-Twister")
[17:40:53.855]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.855]                       inherits = FALSE)
[17:40:53.855]                   }
[17:40:53.855]                   options(future.plan = NULL)
[17:40:53.855]                   if (is.na(NA_character_)) 
[17:40:53.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.855]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.855]                   {
[17:40:53.855]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.855]                     if (!future$lazy) 
[17:40:53.855]                       future <- run(future)
[17:40:53.855]                     invisible(future)
[17:40:53.855]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.855]                 }
[17:40:53.855]             }
[17:40:53.855]         }
[17:40:53.855]     })
[17:40:53.855]     if (TRUE) {
[17:40:53.855]         base::sink(type = "output", split = FALSE)
[17:40:53.855]         if (TRUE) {
[17:40:53.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.855]         }
[17:40:53.855]         else {
[17:40:53.855]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.855]         }
[17:40:53.855]         base::close(...future.stdout)
[17:40:53.855]         ...future.stdout <- NULL
[17:40:53.855]     }
[17:40:53.855]     ...future.result$conditions <- ...future.conditions
[17:40:53.855]     ...future.result$finished <- base::Sys.time()
[17:40:53.855]     ...future.result
[17:40:53.855] }
[17:40:53.857] assign_globals() ...
[17:40:53.857] List of 11
[17:40:53.857]  $ ...future.FUN            :function (x, ...)  
[17:40:53.857]  $ x_FUN                    :function (x)  
[17:40:53.857]  $ times                    : int 4
[17:40:53.857]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.857]  $ stop_if_not              :function (...)  
[17:40:53.857]  $ dim                      : int [1:2] 2 2
[17:40:53.857]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:53.857]  $ future.call.arguments    : list()
[17:40:53.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.857]  $ ...future.elements_ii    :List of 10
[17:40:53.857]   ..$ : int 1
[17:40:53.857]   ..$ : int 2
[17:40:53.857]   ..$ : int 3
[17:40:53.857]   ..$ : int 4
[17:40:53.857]   ..$ : int 5
[17:40:53.857]   ..$ : int 6
[17:40:53.857]   ..$ : int 7
[17:40:53.857]   ..$ : int 8
[17:40:53.857]   ..$ : int 9
[17:40:53.857]   ..$ : int 10
[17:40:53.857]  $ ...future.seeds_ii       : NULL
[17:40:53.857]  $ ...future.globals.maxSize: NULL
[17:40:53.857]  - attr(*, "resolved")= logi FALSE
[17:40:53.857]  - attr(*, "total_size")= num 97232
[17:40:53.857]  - attr(*, "where")=List of 11
[17:40:53.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.857]  - attr(*, "already-done")= logi TRUE
[17:40:53.868] - copied ‘...future.FUN’ to environment
[17:40:53.868] - reassign environment for ‘x_FUN’
[17:40:53.868] - copied ‘x_FUN’ to environment
[17:40:53.868] - copied ‘times’ to environment
[17:40:53.868] - copied ‘stopf’ to environment
[17:40:53.869] - copied ‘stop_if_not’ to environment
[17:40:53.869] - copied ‘dim’ to environment
[17:40:53.869] - copied ‘valid_types’ to environment
[17:40:53.869] - copied ‘future.call.arguments’ to environment
[17:40:53.869] - copied ‘...future.elements_ii’ to environment
[17:40:53.869] - copied ‘...future.seeds_ii’ to environment
[17:40:53.869] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.869] assign_globals() ... done
[17:40:53.870] plan(): Setting new future strategy stack:
[17:40:53.870] List of future strategies:
[17:40:53.870] 1. sequential:
[17:40:53.870]    - args: function (..., envir = parent.frame())
[17:40:53.870]    - tweaked: FALSE
[17:40:53.870]    - call: NULL
[17:40:53.870] plan(): nbrOfWorkers() = 1
[17:40:53.871] plan(): Setting new future strategy stack:
[17:40:53.871] List of future strategies:
[17:40:53.871] 1. sequential:
[17:40:53.871]    - args: function (..., envir = parent.frame())
[17:40:53.871]    - tweaked: FALSE
[17:40:53.871]    - call: plan(strategy)
[17:40:53.871] plan(): nbrOfWorkers() = 1
[17:40:53.871] SequentialFuture started (and completed)
[17:40:53.872] - Launch lazy future ... done
[17:40:53.872] run() for ‘SequentialFuture’ ... done
[17:40:53.872] Created future:
[17:40:53.872] SequentialFuture:
[17:40:53.872] Label: ‘future_vapply-1’
[17:40:53.872] Expression:
[17:40:53.872] {
[17:40:53.872]     do.call(function(...) {
[17:40:53.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.872]             on.exit(options(oopts), add = TRUE)
[17:40:53.872]         }
[17:40:53.872]         {
[17:40:53.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.872]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.872]             })
[17:40:53.872]         }
[17:40:53.872]     }, args = future.call.arguments)
[17:40:53.872] }
[17:40:53.872] Lazy evaluation: FALSE
[17:40:53.872] Asynchronous evaluation: FALSE
[17:40:53.872] Local evaluation: TRUE
[17:40:53.872] Environment: R_GlobalEnv
[17:40:53.872] Capture standard output: TRUE
[17:40:53.872] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.872] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.872] Packages: 1 packages (‘future.apply’)
[17:40:53.872] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.872] Resolved: TRUE
[17:40:53.872] Value: 2.27 KiB of class ‘list’
[17:40:53.872] Early signaling: FALSE
[17:40:53.872] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.872] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.873] Chunk #1 of 1 ... DONE
[17:40:53.873] Launching 1 futures (chunks) ... DONE
[17:40:53.873] Resolving 1 futures (chunks) ...
[17:40:53.873] resolve() on list ...
[17:40:53.873]  recursive: 0
[17:40:53.874]  length: 1
[17:40:53.874] 
[17:40:53.874] resolved() for ‘SequentialFuture’ ...
[17:40:53.874] - state: ‘finished’
[17:40:53.874] - run: TRUE
[17:40:53.874] - result: ‘FutureResult’
[17:40:53.874] resolved() for ‘SequentialFuture’ ... done
[17:40:53.874] Future #1
[17:40:53.874] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.874] - nx: 1
[17:40:53.875] - relay: TRUE
[17:40:53.875] - stdout: TRUE
[17:40:53.875] - signal: TRUE
[17:40:53.875] - resignal: FALSE
[17:40:53.875] - force: TRUE
[17:40:53.875] - relayed: [n=1] FALSE
[17:40:53.875] - queued futures: [n=1] FALSE
[17:40:53.875]  - until=1
[17:40:53.875]  - relaying element #1
[17:40:53.875] - relayed: [n=1] TRUE
[17:40:53.875] - queued futures: [n=1] TRUE
[17:40:53.876] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.876]  length: 0 (resolved future 1)
[17:40:53.876] Relaying remaining futures
[17:40:53.876] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.876] - nx: 1
[17:40:53.876] - relay: TRUE
[17:40:53.876] - stdout: TRUE
[17:40:53.876] - signal: TRUE
[17:40:53.876] - resignal: FALSE
[17:40:53.876] - force: TRUE
[17:40:53.876] - relayed: [n=1] TRUE
[17:40:53.876] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.877] - relayed: [n=1] TRUE
[17:40:53.877] - queued futures: [n=1] TRUE
[17:40:53.877] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.877] resolve() on list ... DONE
[17:40:53.877]  - Number of value chunks collected: 1
[17:40:53.877] Resolving 1 futures (chunks) ... DONE
[17:40:53.877] Reducing values from 1 chunks ...
[17:40:53.877]  - Number of values collected after concatenation: 10
[17:40:53.877]  - Number of values expected: 10
[17:40:53.878] Reducing values from 1 chunks ... DONE
[17:40:53.878] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:40:53.878] future_lapply() ...
[17:40:53.880] Number of chunks: 1
[17:40:53.880] getGlobalsAndPackagesXApply() ...
[17:40:53.880]  - future.globals: TRUE
[17:40:53.880] getGlobalsAndPackages() ...
[17:40:53.881] Searching for globals...
[17:40:53.884] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:40:53.884] Searching for globals ... DONE
[17:40:53.884] Resolving globals: FALSE
[17:40:53.885] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:40:53.886] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.887] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.887] - packages: [1] ‘future.apply’
[17:40:53.887] getGlobalsAndPackages() ... DONE
[17:40:53.887]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.887]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.887] Finding globals ... DONE
[17:40:53.887]  - use_args: TRUE
[17:40:53.887]  - Getting '...' globals ...
[17:40:53.888] resolve() on list ...
[17:40:53.888]  recursive: 0
[17:40:53.888]  length: 1
[17:40:53.888]  elements: ‘...’
[17:40:53.888]  length: 0 (resolved future 1)
[17:40:53.888] resolve() on list ... DONE
[17:40:53.888]    - '...' content: [n=0] 
[17:40:53.888] List of 1
[17:40:53.888]  $ ...: list()
[17:40:53.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.888]  - attr(*, "where")=List of 1
[17:40:53.888]   ..$ ...:<environment: 0x564f30166488> 
[17:40:53.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.888]  - attr(*, "resolved")= logi TRUE
[17:40:53.888]  - attr(*, "total_size")= num NA
[17:40:53.891]  - Getting '...' globals ... DONE
[17:40:53.891] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.891] List of 8
[17:40:53.891]  $ ...future.FUN:function (x, ...)  
[17:40:53.891]  $ x_FUN        :function (x)  
[17:40:53.891]  $ times        : int 4
[17:40:53.891]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.891]  $ stop_if_not  :function (...)  
[17:40:53.891]  $ dim          : int [1:2] 2 2
[17:40:53.891]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:53.891]  $ ...          : list()
[17:40:53.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.891]  - attr(*, "where")=List of 8
[17:40:53.891]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.891]   ..$ ...          :<environment: 0x564f30166488> 
[17:40:53.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.891]  - attr(*, "resolved")= logi FALSE
[17:40:53.891]  - attr(*, "total_size")= num 97304
[17:40:53.897] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.897] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.897] Number of futures (= number of chunks): 1
[17:40:53.897] Launching 1 futures (chunks) ...
[17:40:53.897] Chunk #1 of 1 ...
[17:40:53.897]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.898] getGlobalsAndPackages() ...
[17:40:53.898] Searching for globals...
[17:40:53.898] 
[17:40:53.898] Searching for globals ... DONE
[17:40:53.898] - globals: [0] <none>
[17:40:53.898] getGlobalsAndPackages() ... DONE
[17:40:53.898]    + additional globals found: [n=0] 
[17:40:53.898]    + additional namespaces needed: [n=0] 
[17:40:53.898]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.899]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.899]  - seeds: <none>
[17:40:53.899] getGlobalsAndPackages() ...
[17:40:53.899] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.899] Resolving globals: FALSE
[17:40:53.899] Tweak future expression to call with '...' arguments ...
[17:40:53.899] {
[17:40:53.899]     do.call(function(...) {
[17:40:53.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.899]             on.exit(options(oopts), add = TRUE)
[17:40:53.899]         }
[17:40:53.899]         {
[17:40:53.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.899]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.899]             })
[17:40:53.899]         }
[17:40:53.899]     }, args = future.call.arguments)
[17:40:53.899] }
[17:40:53.900] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.900] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.900] - packages: [1] ‘future.apply’
[17:40:53.900] getGlobalsAndPackages() ... DONE
[17:40:53.901] run() for ‘Future’ ...
[17:40:53.901] - state: ‘created’
[17:40:53.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.901]   - Field: ‘label’
[17:40:53.901]   - Field: ‘local’
[17:40:53.902]   - Field: ‘owner’
[17:40:53.902]   - Field: ‘envir’
[17:40:53.902]   - Field: ‘packages’
[17:40:53.902]   - Field: ‘gc’
[17:40:53.902]   - Field: ‘conditions’
[17:40:53.902]   - Field: ‘expr’
[17:40:53.902]   - Field: ‘uuid’
[17:40:53.902]   - Field: ‘seed’
[17:40:53.902]   - Field: ‘version’
[17:40:53.902]   - Field: ‘result’
[17:40:53.902]   - Field: ‘asynchronous’
[17:40:53.903]   - Field: ‘calls’
[17:40:53.903]   - Field: ‘globals’
[17:40:53.903]   - Field: ‘stdout’
[17:40:53.903]   - Field: ‘earlySignal’
[17:40:53.903]   - Field: ‘lazy’
[17:40:53.903]   - Field: ‘state’
[17:40:53.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.903] - Launch lazy future ...
[17:40:53.903] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.904] Packages needed by future strategies (n = 0): <none>
[17:40:53.904] {
[17:40:53.904]     {
[17:40:53.904]         {
[17:40:53.904]             ...future.startTime <- base::Sys.time()
[17:40:53.904]             {
[17:40:53.904]                 {
[17:40:53.904]                   {
[17:40:53.904]                     {
[17:40:53.904]                       base::local({
[17:40:53.904]                         has_future <- base::requireNamespace("future", 
[17:40:53.904]                           quietly = TRUE)
[17:40:53.904]                         if (has_future) {
[17:40:53.904]                           ns <- base::getNamespace("future")
[17:40:53.904]                           version <- ns[[".package"]][["version"]]
[17:40:53.904]                           if (is.null(version)) 
[17:40:53.904]                             version <- utils::packageVersion("future")
[17:40:53.904]                         }
[17:40:53.904]                         else {
[17:40:53.904]                           version <- NULL
[17:40:53.904]                         }
[17:40:53.904]                         if (!has_future || version < "1.8.0") {
[17:40:53.904]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.904]                             "", base::R.version$version.string), 
[17:40:53.904]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.904]                               "release", "version")], collapse = " "), 
[17:40:53.904]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.904]                             info)
[17:40:53.904]                           info <- base::paste(info, collapse = "; ")
[17:40:53.904]                           if (!has_future) {
[17:40:53.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.904]                               info)
[17:40:53.904]                           }
[17:40:53.904]                           else {
[17:40:53.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.904]                               info, version)
[17:40:53.904]                           }
[17:40:53.904]                           base::stop(msg)
[17:40:53.904]                         }
[17:40:53.904]                       })
[17:40:53.904]                     }
[17:40:53.904]                     base::local({
[17:40:53.904]                       for (pkg in "future.apply") {
[17:40:53.904]                         base::loadNamespace(pkg)
[17:40:53.904]                         base::library(pkg, character.only = TRUE)
[17:40:53.904]                       }
[17:40:53.904]                     })
[17:40:53.904]                   }
[17:40:53.904]                   options(future.plan = NULL)
[17:40:53.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.904]                 }
[17:40:53.904]                 ...future.workdir <- getwd()
[17:40:53.904]             }
[17:40:53.904]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.904]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.904]         }
[17:40:53.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.904]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.904]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.904]             base::names(...future.oldOptions))
[17:40:53.904]     }
[17:40:53.904]     if (FALSE) {
[17:40:53.904]     }
[17:40:53.904]     else {
[17:40:53.904]         if (TRUE) {
[17:40:53.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.904]                 open = "w")
[17:40:53.904]         }
[17:40:53.904]         else {
[17:40:53.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.904]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.904]         }
[17:40:53.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.904]             base::sink(type = "output", split = FALSE)
[17:40:53.904]             base::close(...future.stdout)
[17:40:53.904]         }, add = TRUE)
[17:40:53.904]     }
[17:40:53.904]     ...future.frame <- base::sys.nframe()
[17:40:53.904]     ...future.conditions <- base::list()
[17:40:53.904]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.904]     if (FALSE) {
[17:40:53.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.904]     }
[17:40:53.904]     ...future.result <- base::tryCatch({
[17:40:53.904]         base::withCallingHandlers({
[17:40:53.904]             ...future.value <- base::withVisible(base::local({
[17:40:53.904]                 do.call(function(...) {
[17:40:53.904]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.904]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.904]                     ...future.globals.maxSize)) {
[17:40:53.904]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.904]                     on.exit(options(oopts), add = TRUE)
[17:40:53.904]                   }
[17:40:53.904]                   {
[17:40:53.904]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.904]                       FUN = function(jj) {
[17:40:53.904]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.904]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.904]                       })
[17:40:53.904]                   }
[17:40:53.904]                 }, args = future.call.arguments)
[17:40:53.904]             }))
[17:40:53.904]             future::FutureResult(value = ...future.value$value, 
[17:40:53.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.904]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.904]                     ...future.globalenv.names))
[17:40:53.904]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.904]         }, condition = base::local({
[17:40:53.904]             c <- base::c
[17:40:53.904]             inherits <- base::inherits
[17:40:53.904]             invokeRestart <- base::invokeRestart
[17:40:53.904]             length <- base::length
[17:40:53.904]             list <- base::list
[17:40:53.904]             seq.int <- base::seq.int
[17:40:53.904]             signalCondition <- base::signalCondition
[17:40:53.904]             sys.calls <- base::sys.calls
[17:40:53.904]             `[[` <- base::`[[`
[17:40:53.904]             `+` <- base::`+`
[17:40:53.904]             `<<-` <- base::`<<-`
[17:40:53.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.904]                   3L)]
[17:40:53.904]             }
[17:40:53.904]             function(cond) {
[17:40:53.904]                 is_error <- inherits(cond, "error")
[17:40:53.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.904]                   NULL)
[17:40:53.904]                 if (is_error) {
[17:40:53.904]                   sessionInformation <- function() {
[17:40:53.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.904]                       search = base::search(), system = base::Sys.info())
[17:40:53.904]                   }
[17:40:53.904]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.904]                     cond$call), session = sessionInformation(), 
[17:40:53.904]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.904]                   signalCondition(cond)
[17:40:53.904]                 }
[17:40:53.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.904]                 "immediateCondition"))) {
[17:40:53.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.904]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.904]                   if (TRUE && !signal) {
[17:40:53.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.904]                     {
[17:40:53.904]                       inherits <- base::inherits
[17:40:53.904]                       invokeRestart <- base::invokeRestart
[17:40:53.904]                       is.null <- base::is.null
[17:40:53.904]                       muffled <- FALSE
[17:40:53.904]                       if (inherits(cond, "message")) {
[17:40:53.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.904]                         if (muffled) 
[17:40:53.904]                           invokeRestart("muffleMessage")
[17:40:53.904]                       }
[17:40:53.904]                       else if (inherits(cond, "warning")) {
[17:40:53.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.904]                         if (muffled) 
[17:40:53.904]                           invokeRestart("muffleWarning")
[17:40:53.904]                       }
[17:40:53.904]                       else if (inherits(cond, "condition")) {
[17:40:53.904]                         if (!is.null(pattern)) {
[17:40:53.904]                           computeRestarts <- base::computeRestarts
[17:40:53.904]                           grepl <- base::grepl
[17:40:53.904]                           restarts <- computeRestarts(cond)
[17:40:53.904]                           for (restart in restarts) {
[17:40:53.904]                             name <- restart$name
[17:40:53.904]                             if (is.null(name)) 
[17:40:53.904]                               next
[17:40:53.904]                             if (!grepl(pattern, name)) 
[17:40:53.904]                               next
[17:40:53.904]                             invokeRestart(restart)
[17:40:53.904]                             muffled <- TRUE
[17:40:53.904]                             break
[17:40:53.904]                           }
[17:40:53.904]                         }
[17:40:53.904]                       }
[17:40:53.904]                       invisible(muffled)
[17:40:53.904]                     }
[17:40:53.904]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.904]                   }
[17:40:53.904]                 }
[17:40:53.904]                 else {
[17:40:53.904]                   if (TRUE) {
[17:40:53.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.904]                     {
[17:40:53.904]                       inherits <- base::inherits
[17:40:53.904]                       invokeRestart <- base::invokeRestart
[17:40:53.904]                       is.null <- base::is.null
[17:40:53.904]                       muffled <- FALSE
[17:40:53.904]                       if (inherits(cond, "message")) {
[17:40:53.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.904]                         if (muffled) 
[17:40:53.904]                           invokeRestart("muffleMessage")
[17:40:53.904]                       }
[17:40:53.904]                       else if (inherits(cond, "warning")) {
[17:40:53.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.904]                         if (muffled) 
[17:40:53.904]                           invokeRestart("muffleWarning")
[17:40:53.904]                       }
[17:40:53.904]                       else if (inherits(cond, "condition")) {
[17:40:53.904]                         if (!is.null(pattern)) {
[17:40:53.904]                           computeRestarts <- base::computeRestarts
[17:40:53.904]                           grepl <- base::grepl
[17:40:53.904]                           restarts <- computeRestarts(cond)
[17:40:53.904]                           for (restart in restarts) {
[17:40:53.904]                             name <- restart$name
[17:40:53.904]                             if (is.null(name)) 
[17:40:53.904]                               next
[17:40:53.904]                             if (!grepl(pattern, name)) 
[17:40:53.904]                               next
[17:40:53.904]                             invokeRestart(restart)
[17:40:53.904]                             muffled <- TRUE
[17:40:53.904]                             break
[17:40:53.904]                           }
[17:40:53.904]                         }
[17:40:53.904]                       }
[17:40:53.904]                       invisible(muffled)
[17:40:53.904]                     }
[17:40:53.904]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.904]                   }
[17:40:53.904]                 }
[17:40:53.904]             }
[17:40:53.904]         }))
[17:40:53.904]     }, error = function(ex) {
[17:40:53.904]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.904]                 ...future.rng), started = ...future.startTime, 
[17:40:53.904]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.904]             version = "1.8"), class = "FutureResult")
[17:40:53.904]     }, finally = {
[17:40:53.904]         if (!identical(...future.workdir, getwd())) 
[17:40:53.904]             setwd(...future.workdir)
[17:40:53.904]         {
[17:40:53.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.904]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.904]             }
[17:40:53.904]             base::options(...future.oldOptions)
[17:40:53.904]             if (.Platform$OS.type == "windows") {
[17:40:53.904]                 old_names <- names(...future.oldEnvVars)
[17:40:53.904]                 envs <- base::Sys.getenv()
[17:40:53.904]                 names <- names(envs)
[17:40:53.904]                 common <- intersect(names, old_names)
[17:40:53.904]                 added <- setdiff(names, old_names)
[17:40:53.904]                 removed <- setdiff(old_names, names)
[17:40:53.904]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.904]                   envs[common]]
[17:40:53.904]                 NAMES <- toupper(changed)
[17:40:53.904]                 args <- list()
[17:40:53.904]                 for (kk in seq_along(NAMES)) {
[17:40:53.904]                   name <- changed[[kk]]
[17:40:53.904]                   NAME <- NAMES[[kk]]
[17:40:53.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.904]                     next
[17:40:53.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.904]                 }
[17:40:53.904]                 NAMES <- toupper(added)
[17:40:53.904]                 for (kk in seq_along(NAMES)) {
[17:40:53.904]                   name <- added[[kk]]
[17:40:53.904]                   NAME <- NAMES[[kk]]
[17:40:53.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.904]                     next
[17:40:53.904]                   args[[name]] <- ""
[17:40:53.904]                 }
[17:40:53.904]                 NAMES <- toupper(removed)
[17:40:53.904]                 for (kk in seq_along(NAMES)) {
[17:40:53.904]                   name <- removed[[kk]]
[17:40:53.904]                   NAME <- NAMES[[kk]]
[17:40:53.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.904]                     next
[17:40:53.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.904]                 }
[17:40:53.904]                 if (length(args) > 0) 
[17:40:53.904]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.904]             }
[17:40:53.904]             else {
[17:40:53.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.904]             }
[17:40:53.904]             {
[17:40:53.904]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.904]                   0L) {
[17:40:53.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.904]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.904]                   base::options(opts)
[17:40:53.904]                 }
[17:40:53.904]                 {
[17:40:53.904]                   {
[17:40:53.904]                     NULL
[17:40:53.904]                     RNGkind("Mersenne-Twister")
[17:40:53.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.904]                       inherits = FALSE)
[17:40:53.904]                   }
[17:40:53.904]                   options(future.plan = NULL)
[17:40:53.904]                   if (is.na(NA_character_)) 
[17:40:53.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.904]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.904]                   {
[17:40:53.904]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.904]                     if (!future$lazy) 
[17:40:53.904]                       future <- run(future)
[17:40:53.904]                     invisible(future)
[17:40:53.904]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.904]                 }
[17:40:53.904]             }
[17:40:53.904]         }
[17:40:53.904]     })
[17:40:53.904]     if (TRUE) {
[17:40:53.904]         base::sink(type = "output", split = FALSE)
[17:40:53.904]         if (TRUE) {
[17:40:53.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.904]         }
[17:40:53.904]         else {
[17:40:53.904]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.904]         }
[17:40:53.904]         base::close(...future.stdout)
[17:40:53.904]         ...future.stdout <- NULL
[17:40:53.904]     }
[17:40:53.904]     ...future.result$conditions <- ...future.conditions
[17:40:53.904]     ...future.result$finished <- base::Sys.time()
[17:40:53.904]     ...future.result
[17:40:53.904] }
[17:40:53.906] assign_globals() ...
[17:40:53.906] List of 11
[17:40:53.906]  $ ...future.FUN            :function (x, ...)  
[17:40:53.906]  $ x_FUN                    :function (x)  
[17:40:53.906]  $ times                    : int 4
[17:40:53.906]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.906]  $ stop_if_not              :function (...)  
[17:40:53.906]  $ dim                      : int [1:2] 2 2
[17:40:53.906]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:53.906]  $ future.call.arguments    : list()
[17:40:53.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.906]  $ ...future.elements_ii    :List of 10
[17:40:53.906]   ..$ : int 1
[17:40:53.906]   ..$ : int 2
[17:40:53.906]   ..$ : int 3
[17:40:53.906]   ..$ : int 4
[17:40:53.906]   ..$ : int 5
[17:40:53.906]   ..$ : int 6
[17:40:53.906]   ..$ : int 7
[17:40:53.906]   ..$ : int 8
[17:40:53.906]   ..$ : int 9
[17:40:53.906]   ..$ : int 10
[17:40:53.906]  $ ...future.seeds_ii       : NULL
[17:40:53.906]  $ ...future.globals.maxSize: NULL
[17:40:53.906]  - attr(*, "resolved")= logi FALSE
[17:40:53.906]  - attr(*, "total_size")= num 97304
[17:40:53.906]  - attr(*, "where")=List of 11
[17:40:53.906]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.906]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.906]  - attr(*, "already-done")= logi TRUE
[17:40:53.942] - copied ‘...future.FUN’ to environment
[17:40:53.942] - reassign environment for ‘x_FUN’
[17:40:53.942] - copied ‘x_FUN’ to environment
[17:40:53.942] - copied ‘times’ to environment
[17:40:53.943] - copied ‘stopf’ to environment
[17:40:53.943] - copied ‘stop_if_not’ to environment
[17:40:53.943] - copied ‘dim’ to environment
[17:40:53.943] - copied ‘valid_types’ to environment
[17:40:53.943] - copied ‘future.call.arguments’ to environment
[17:40:53.943] - copied ‘...future.elements_ii’ to environment
[17:40:53.943] - copied ‘...future.seeds_ii’ to environment
[17:40:53.943] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.943] assign_globals() ... done
[17:40:53.944] plan(): Setting new future strategy stack:
[17:40:53.944] List of future strategies:
[17:40:53.944] 1. sequential:
[17:40:53.944]    - args: function (..., envir = parent.frame())
[17:40:53.944]    - tweaked: FALSE
[17:40:53.944]    - call: NULL
[17:40:53.944] plan(): nbrOfWorkers() = 1
[17:40:53.945] plan(): Setting new future strategy stack:
[17:40:53.945] List of future strategies:
[17:40:53.945] 1. sequential:
[17:40:53.945]    - args: function (..., envir = parent.frame())
[17:40:53.945]    - tweaked: FALSE
[17:40:53.945]    - call: plan(strategy)
[17:40:53.946] plan(): nbrOfWorkers() = 1
[17:40:53.946] SequentialFuture started (and completed)
[17:40:53.946] - Launch lazy future ... done
[17:40:53.946] run() for ‘SequentialFuture’ ... done
[17:40:53.946] Created future:
[17:40:53.946] SequentialFuture:
[17:40:53.946] Label: ‘future_vapply-1’
[17:40:53.946] Expression:
[17:40:53.946] {
[17:40:53.946]     do.call(function(...) {
[17:40:53.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.946]             on.exit(options(oopts), add = TRUE)
[17:40:53.946]         }
[17:40:53.946]         {
[17:40:53.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.946]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.946]             })
[17:40:53.946]         }
[17:40:53.946]     }, args = future.call.arguments)
[17:40:53.946] }
[17:40:53.946] Lazy evaluation: FALSE
[17:40:53.946] Asynchronous evaluation: FALSE
[17:40:53.946] Local evaluation: TRUE
[17:40:53.946] Environment: R_GlobalEnv
[17:40:53.946] Capture standard output: TRUE
[17:40:53.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.946] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.946] Packages: 1 packages (‘future.apply’)
[17:40:53.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.946] Resolved: TRUE
[17:40:53.946] Value: 2.27 KiB of class ‘list’
[17:40:53.946] Early signaling: FALSE
[17:40:53.946] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.946] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.948] Chunk #1 of 1 ... DONE
[17:40:53.948] Launching 1 futures (chunks) ... DONE
[17:40:53.948] Resolving 1 futures (chunks) ...
[17:40:53.948] resolve() on list ...
[17:40:53.948]  recursive: 0
[17:40:53.948]  length: 1
[17:40:53.948] 
[17:40:53.948] resolved() for ‘SequentialFuture’ ...
[17:40:53.948] - state: ‘finished’
[17:40:53.948] - run: TRUE
[17:40:53.949] - result: ‘FutureResult’
[17:40:53.949] resolved() for ‘SequentialFuture’ ... done
[17:40:53.949] Future #1
[17:40:53.949] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.949] - nx: 1
[17:40:53.949] - relay: TRUE
[17:40:53.949] - stdout: TRUE
[17:40:53.949] - signal: TRUE
[17:40:53.949] - resignal: FALSE
[17:40:53.949] - force: TRUE
[17:40:53.949] - relayed: [n=1] FALSE
[17:40:53.950] - queued futures: [n=1] FALSE
[17:40:53.950]  - until=1
[17:40:53.950]  - relaying element #1
[17:40:53.950] - relayed: [n=1] TRUE
[17:40:53.950] - queued futures: [n=1] TRUE
[17:40:53.950] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:53.950]  length: 0 (resolved future 1)
[17:40:53.950] Relaying remaining futures
[17:40:53.950] signalConditionsASAP(NULL, pos=0) ...
[17:40:53.951] - nx: 1
[17:40:53.951] - relay: TRUE
[17:40:53.951] - stdout: TRUE
[17:40:53.951] - signal: TRUE
[17:40:53.951] - resignal: FALSE
[17:40:53.951] - force: TRUE
[17:40:53.951] - relayed: [n=1] TRUE
[17:40:53.951] - queued futures: [n=1] TRUE
 - flush all
[17:40:53.951] - relayed: [n=1] TRUE
[17:40:53.951] - queued futures: [n=1] TRUE
[17:40:53.951] signalConditionsASAP(NULL, pos=0) ... done
[17:40:53.952] resolve() on list ... DONE
[17:40:53.952]  - Number of value chunks collected: 1
[17:40:53.952] Resolving 1 futures (chunks) ... DONE
[17:40:53.952] Reducing values from 1 chunks ...
[17:40:53.952]  - Number of values collected after concatenation: 10
[17:40:53.952]  - Number of values expected: 10
[17:40:53.952] Reducing values from 1 chunks ... DONE
[17:40:53.952] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:40:53.954] future_lapply() ...
[17:40:53.956] Number of chunks: 1
[17:40:53.956] getGlobalsAndPackagesXApply() ...
[17:40:53.956]  - future.globals: TRUE
[17:40:53.956] getGlobalsAndPackages() ...
[17:40:53.957] Searching for globals...
[17:40:53.961] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:40:53.961] Searching for globals ... DONE
[17:40:53.961] Resolving globals: FALSE
[17:40:53.962] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:40:53.963] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:53.963] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.963] - packages: [1] ‘future.apply’
[17:40:53.963] getGlobalsAndPackages() ... DONE
[17:40:53.963]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:53.963]  - needed namespaces: [n=1] ‘future.apply’
[17:40:53.963] Finding globals ... DONE
[17:40:53.963]  - use_args: TRUE
[17:40:53.963]  - Getting '...' globals ...
[17:40:53.964] resolve() on list ...
[17:40:53.964]  recursive: 0
[17:40:53.964]  length: 1
[17:40:53.964]  elements: ‘...’
[17:40:53.964]  length: 0 (resolved future 1)
[17:40:53.964] resolve() on list ... DONE
[17:40:53.964]    - '...' content: [n=0] 
[17:40:53.964] List of 1
[17:40:53.964]  $ ...: list()
[17:40:53.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.964]  - attr(*, "where")=List of 1
[17:40:53.964]   ..$ ...:<environment: 0x564f3073f808> 
[17:40:53.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.964]  - attr(*, "resolved")= logi TRUE
[17:40:53.964]  - attr(*, "total_size")= num NA
[17:40:53.967]  - Getting '...' globals ... DONE
[17:40:53.967] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:53.967] List of 8
[17:40:53.967]  $ ...future.FUN:function (x, ...)  
[17:40:53.967]  $ x_FUN        :function (x)  
[17:40:53.967]  $ times        : int 4
[17:40:53.967]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.967]  $ stop_if_not  :function (...)  
[17:40:53.967]  $ dim          : int [1:2] 2 2
[17:40:53.967]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:53.967]  $ ...          : list()
[17:40:53.967]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.967]  - attr(*, "where")=List of 8
[17:40:53.967]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:53.967]   ..$ ...          :<environment: 0x564f3073f808> 
[17:40:53.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.967]  - attr(*, "resolved")= logi FALSE
[17:40:53.967]  - attr(*, "total_size")= num 105552
[17:40:53.972] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:53.972] getGlobalsAndPackagesXApply() ... DONE
[17:40:53.973] Number of futures (= number of chunks): 1
[17:40:53.973] Launching 1 futures (chunks) ...
[17:40:53.973] Chunk #1 of 1 ...
[17:40:53.973]  - Finding globals in 'X' for chunk #1 ...
[17:40:53.973] getGlobalsAndPackages() ...
[17:40:53.973] Searching for globals...
[17:40:53.973] 
[17:40:53.973] Searching for globals ... DONE
[17:40:53.974] - globals: [0] <none>
[17:40:53.974] getGlobalsAndPackages() ... DONE
[17:40:53.974]    + additional globals found: [n=0] 
[17:40:53.974]    + additional namespaces needed: [n=0] 
[17:40:53.974]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:53.974]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[17:40:53.974]  - seeds: <none>
[17:40:53.974] getGlobalsAndPackages() ...
[17:40:53.974] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.974] Resolving globals: FALSE
[17:40:53.975] Tweak future expression to call with '...' arguments ...
[17:40:53.975] {
[17:40:53.975]     do.call(function(...) {
[17:40:53.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.975]             on.exit(options(oopts), add = TRUE)
[17:40:53.975]         }
[17:40:53.975]         {
[17:40:53.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.975]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.975]             })
[17:40:53.975]         }
[17:40:53.975]     }, args = future.call.arguments)
[17:40:53.975] }
[17:40:53.975] Tweak future expression to call with '...' arguments ... DONE
[17:40:53.975] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:53.976] - packages: [1] ‘future.apply’
[17:40:53.976] getGlobalsAndPackages() ... DONE
[17:40:53.976] run() for ‘Future’ ...
[17:40:53.976] - state: ‘created’
[17:40:53.976] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:53.976] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:53.977]   - Field: ‘label’
[17:40:53.977]   - Field: ‘local’
[17:40:53.977]   - Field: ‘owner’
[17:40:53.977]   - Field: ‘envir’
[17:40:53.977]   - Field: ‘packages’
[17:40:53.977]   - Field: ‘gc’
[17:40:53.977]   - Field: ‘conditions’
[17:40:53.977]   - Field: ‘expr’
[17:40:53.977]   - Field: ‘uuid’
[17:40:53.977]   - Field: ‘seed’
[17:40:53.978]   - Field: ‘version’
[17:40:53.978]   - Field: ‘result’
[17:40:53.978]   - Field: ‘asynchronous’
[17:40:53.978]   - Field: ‘calls’
[17:40:53.978]   - Field: ‘globals’
[17:40:53.978]   - Field: ‘stdout’
[17:40:53.978]   - Field: ‘earlySignal’
[17:40:53.978]   - Field: ‘lazy’
[17:40:53.978]   - Field: ‘state’
[17:40:53.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:53.980] - Launch lazy future ...
[17:40:53.980] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:53.980] Packages needed by future strategies (n = 0): <none>
[17:40:53.980] {
[17:40:53.980]     {
[17:40:53.980]         {
[17:40:53.980]             ...future.startTime <- base::Sys.time()
[17:40:53.980]             {
[17:40:53.980]                 {
[17:40:53.980]                   {
[17:40:53.980]                     {
[17:40:53.980]                       base::local({
[17:40:53.980]                         has_future <- base::requireNamespace("future", 
[17:40:53.980]                           quietly = TRUE)
[17:40:53.980]                         if (has_future) {
[17:40:53.980]                           ns <- base::getNamespace("future")
[17:40:53.980]                           version <- ns[[".package"]][["version"]]
[17:40:53.980]                           if (is.null(version)) 
[17:40:53.980]                             version <- utils::packageVersion("future")
[17:40:53.980]                         }
[17:40:53.980]                         else {
[17:40:53.980]                           version <- NULL
[17:40:53.980]                         }
[17:40:53.980]                         if (!has_future || version < "1.8.0") {
[17:40:53.980]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.980]                             "", base::R.version$version.string), 
[17:40:53.980]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.980]                               "release", "version")], collapse = " "), 
[17:40:53.980]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.980]                             info)
[17:40:53.980]                           info <- base::paste(info, collapse = "; ")
[17:40:53.980]                           if (!has_future) {
[17:40:53.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.980]                               info)
[17:40:53.980]                           }
[17:40:53.980]                           else {
[17:40:53.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.980]                               info, version)
[17:40:53.980]                           }
[17:40:53.980]                           base::stop(msg)
[17:40:53.980]                         }
[17:40:53.980]                       })
[17:40:53.980]                     }
[17:40:53.980]                     base::local({
[17:40:53.980]                       for (pkg in "future.apply") {
[17:40:53.980]                         base::loadNamespace(pkg)
[17:40:53.980]                         base::library(pkg, character.only = TRUE)
[17:40:53.980]                       }
[17:40:53.980]                     })
[17:40:53.980]                   }
[17:40:53.980]                   options(future.plan = NULL)
[17:40:53.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.980]                 }
[17:40:53.980]                 ...future.workdir <- getwd()
[17:40:53.980]             }
[17:40:53.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.980]         }
[17:40:53.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.980]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[17:40:53.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.980]             base::names(...future.oldOptions))
[17:40:53.980]     }
[17:40:53.980]     if (FALSE) {
[17:40:53.980]     }
[17:40:53.980]     else {
[17:40:53.980]         if (TRUE) {
[17:40:53.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.980]                 open = "w")
[17:40:53.980]         }
[17:40:53.980]         else {
[17:40:53.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.980]         }
[17:40:53.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.980]             base::sink(type = "output", split = FALSE)
[17:40:53.980]             base::close(...future.stdout)
[17:40:53.980]         }, add = TRUE)
[17:40:53.980]     }
[17:40:53.980]     ...future.frame <- base::sys.nframe()
[17:40:53.980]     ...future.conditions <- base::list()
[17:40:53.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.980]     if (FALSE) {
[17:40:53.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.980]     }
[17:40:53.980]     ...future.result <- base::tryCatch({
[17:40:53.980]         base::withCallingHandlers({
[17:40:53.980]             ...future.value <- base::withVisible(base::local({
[17:40:53.980]                 do.call(function(...) {
[17:40:53.980]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.980]                   if (!identical(...future.globals.maxSize.org, 
[17:40:53.980]                     ...future.globals.maxSize)) {
[17:40:53.980]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.980]                     on.exit(options(oopts), add = TRUE)
[17:40:53.980]                   }
[17:40:53.980]                   {
[17:40:53.980]                     lapply(seq_along(...future.elements_ii), 
[17:40:53.980]                       FUN = function(jj) {
[17:40:53.980]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.980]                         ...future.FUN(...future.X_jj, ...)
[17:40:53.980]                       })
[17:40:53.980]                   }
[17:40:53.980]                 }, args = future.call.arguments)
[17:40:53.980]             }))
[17:40:53.980]             future::FutureResult(value = ...future.value$value, 
[17:40:53.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.980]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.980]                     ...future.globalenv.names))
[17:40:53.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.980]         }, condition = base::local({
[17:40:53.980]             c <- base::c
[17:40:53.980]             inherits <- base::inherits
[17:40:53.980]             invokeRestart <- base::invokeRestart
[17:40:53.980]             length <- base::length
[17:40:53.980]             list <- base::list
[17:40:53.980]             seq.int <- base::seq.int
[17:40:53.980]             signalCondition <- base::signalCondition
[17:40:53.980]             sys.calls <- base::sys.calls
[17:40:53.980]             `[[` <- base::`[[`
[17:40:53.980]             `+` <- base::`+`
[17:40:53.980]             `<<-` <- base::`<<-`
[17:40:53.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.980]                   3L)]
[17:40:53.980]             }
[17:40:53.980]             function(cond) {
[17:40:53.980]                 is_error <- inherits(cond, "error")
[17:40:53.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.980]                   NULL)
[17:40:53.980]                 if (is_error) {
[17:40:53.980]                   sessionInformation <- function() {
[17:40:53.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.980]                       search = base::search(), system = base::Sys.info())
[17:40:53.980]                   }
[17:40:53.980]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.980]                     cond$call), session = sessionInformation(), 
[17:40:53.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.980]                   signalCondition(cond)
[17:40:53.980]                 }
[17:40:53.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.980]                 "immediateCondition"))) {
[17:40:53.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.980]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.980]                   if (TRUE && !signal) {
[17:40:53.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.980]                     {
[17:40:53.980]                       inherits <- base::inherits
[17:40:53.980]                       invokeRestart <- base::invokeRestart
[17:40:53.980]                       is.null <- base::is.null
[17:40:53.980]                       muffled <- FALSE
[17:40:53.980]                       if (inherits(cond, "message")) {
[17:40:53.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.980]                         if (muffled) 
[17:40:53.980]                           invokeRestart("muffleMessage")
[17:40:53.980]                       }
[17:40:53.980]                       else if (inherits(cond, "warning")) {
[17:40:53.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.980]                         if (muffled) 
[17:40:53.980]                           invokeRestart("muffleWarning")
[17:40:53.980]                       }
[17:40:53.980]                       else if (inherits(cond, "condition")) {
[17:40:53.980]                         if (!is.null(pattern)) {
[17:40:53.980]                           computeRestarts <- base::computeRestarts
[17:40:53.980]                           grepl <- base::grepl
[17:40:53.980]                           restarts <- computeRestarts(cond)
[17:40:53.980]                           for (restart in restarts) {
[17:40:53.980]                             name <- restart$name
[17:40:53.980]                             if (is.null(name)) 
[17:40:53.980]                               next
[17:40:53.980]                             if (!grepl(pattern, name)) 
[17:40:53.980]                               next
[17:40:53.980]                             invokeRestart(restart)
[17:40:53.980]                             muffled <- TRUE
[17:40:53.980]                             break
[17:40:53.980]                           }
[17:40:53.980]                         }
[17:40:53.980]                       }
[17:40:53.980]                       invisible(muffled)
[17:40:53.980]                     }
[17:40:53.980]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.980]                   }
[17:40:53.980]                 }
[17:40:53.980]                 else {
[17:40:53.980]                   if (TRUE) {
[17:40:53.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.980]                     {
[17:40:53.980]                       inherits <- base::inherits
[17:40:53.980]                       invokeRestart <- base::invokeRestart
[17:40:53.980]                       is.null <- base::is.null
[17:40:53.980]                       muffled <- FALSE
[17:40:53.980]                       if (inherits(cond, "message")) {
[17:40:53.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.980]                         if (muffled) 
[17:40:53.980]                           invokeRestart("muffleMessage")
[17:40:53.980]                       }
[17:40:53.980]                       else if (inherits(cond, "warning")) {
[17:40:53.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.980]                         if (muffled) 
[17:40:53.980]                           invokeRestart("muffleWarning")
[17:40:53.980]                       }
[17:40:53.980]                       else if (inherits(cond, "condition")) {
[17:40:53.980]                         if (!is.null(pattern)) {
[17:40:53.980]                           computeRestarts <- base::computeRestarts
[17:40:53.980]                           grepl <- base::grepl
[17:40:53.980]                           restarts <- computeRestarts(cond)
[17:40:53.980]                           for (restart in restarts) {
[17:40:53.980]                             name <- restart$name
[17:40:53.980]                             if (is.null(name)) 
[17:40:53.980]                               next
[17:40:53.980]                             if (!grepl(pattern, name)) 
[17:40:53.980]                               next
[17:40:53.980]                             invokeRestart(restart)
[17:40:53.980]                             muffled <- TRUE
[17:40:53.980]                             break
[17:40:53.980]                           }
[17:40:53.980]                         }
[17:40:53.980]                       }
[17:40:53.980]                       invisible(muffled)
[17:40:53.980]                     }
[17:40:53.980]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.980]                   }
[17:40:53.980]                 }
[17:40:53.980]             }
[17:40:53.980]         }))
[17:40:53.980]     }, error = function(ex) {
[17:40:53.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.980]                 ...future.rng), started = ...future.startTime, 
[17:40:53.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.980]             version = "1.8"), class = "FutureResult")
[17:40:53.980]     }, finally = {
[17:40:53.980]         if (!identical(...future.workdir, getwd())) 
[17:40:53.980]             setwd(...future.workdir)
[17:40:53.980]         {
[17:40:53.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.980]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.980]             }
[17:40:53.980]             base::options(...future.oldOptions)
[17:40:53.980]             if (.Platform$OS.type == "windows") {
[17:40:53.980]                 old_names <- names(...future.oldEnvVars)
[17:40:53.980]                 envs <- base::Sys.getenv()
[17:40:53.980]                 names <- names(envs)
[17:40:53.980]                 common <- intersect(names, old_names)
[17:40:53.980]                 added <- setdiff(names, old_names)
[17:40:53.980]                 removed <- setdiff(old_names, names)
[17:40:53.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.980]                   envs[common]]
[17:40:53.980]                 NAMES <- toupper(changed)
[17:40:53.980]                 args <- list()
[17:40:53.980]                 for (kk in seq_along(NAMES)) {
[17:40:53.980]                   name <- changed[[kk]]
[17:40:53.980]                   NAME <- NAMES[[kk]]
[17:40:53.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.980]                     next
[17:40:53.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.980]                 }
[17:40:53.980]                 NAMES <- toupper(added)
[17:40:53.980]                 for (kk in seq_along(NAMES)) {
[17:40:53.980]                   name <- added[[kk]]
[17:40:53.980]                   NAME <- NAMES[[kk]]
[17:40:53.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.980]                     next
[17:40:53.980]                   args[[name]] <- ""
[17:40:53.980]                 }
[17:40:53.980]                 NAMES <- toupper(removed)
[17:40:53.980]                 for (kk in seq_along(NAMES)) {
[17:40:53.980]                   name <- removed[[kk]]
[17:40:53.980]                   NAME <- NAMES[[kk]]
[17:40:53.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.980]                     next
[17:40:53.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.980]                 }
[17:40:53.980]                 if (length(args) > 0) 
[17:40:53.980]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.980]             }
[17:40:53.980]             else {
[17:40:53.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.980]             }
[17:40:53.980]             {
[17:40:53.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.980]                   0L) {
[17:40:53.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.980]                   base::options(opts)
[17:40:53.980]                 }
[17:40:53.980]                 {
[17:40:53.980]                   {
[17:40:53.980]                     NULL
[17:40:53.980]                     RNGkind("Mersenne-Twister")
[17:40:53.980]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:53.980]                       inherits = FALSE)
[17:40:53.980]                   }
[17:40:53.980]                   options(future.plan = NULL)
[17:40:53.980]                   if (is.na(NA_character_)) 
[17:40:53.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.980]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:53.980]                   {
[17:40:53.980]                     future <- SequentialFuture(..., envir = envir)
[17:40:53.980]                     if (!future$lazy) 
[17:40:53.980]                       future <- run(future)
[17:40:53.980]                     invisible(future)
[17:40:53.980]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:53.980]                 }
[17:40:53.980]             }
[17:40:53.980]         }
[17:40:53.980]     })
[17:40:53.980]     if (TRUE) {
[17:40:53.980]         base::sink(type = "output", split = FALSE)
[17:40:53.980]         if (TRUE) {
[17:40:53.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.980]         }
[17:40:53.980]         else {
[17:40:53.980]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.980]         }
[17:40:53.980]         base::close(...future.stdout)
[17:40:53.980]         ...future.stdout <- NULL
[17:40:53.980]     }
[17:40:53.980]     ...future.result$conditions <- ...future.conditions
[17:40:53.980]     ...future.result$finished <- base::Sys.time()
[17:40:53.980]     ...future.result
[17:40:53.980] }
[17:40:53.982] assign_globals() ...
[17:40:53.982] List of 11
[17:40:53.982]  $ ...future.FUN            :function (x, ...)  
[17:40:53.982]  $ x_FUN                    :function (x)  
[17:40:53.982]  $ times                    : int 4
[17:40:53.982]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:53.982]  $ stop_if_not              :function (...)  
[17:40:53.982]  $ dim                      : int [1:2] 2 2
[17:40:53.982]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:53.982]  $ future.call.arguments    : list()
[17:40:53.982]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:53.982]  $ ...future.elements_ii    :List of 10
[17:40:53.982]   ..$ : int 1
[17:40:53.982]   ..$ : int 2
[17:40:53.982]   ..$ : int 3
[17:40:53.982]   ..$ : int 4
[17:40:53.982]   ..$ : int 5
[17:40:53.982]   ..$ : int 6
[17:40:53.982]   ..$ : int 7
[17:40:53.982]   ..$ : int 8
[17:40:53.982]   ..$ : int 9
[17:40:53.982]   ..$ : int 10
[17:40:53.982]  $ ...future.seeds_ii       : NULL
[17:40:53.982]  $ ...future.globals.maxSize: NULL
[17:40:53.982]  - attr(*, "resolved")= logi FALSE
[17:40:53.982]  - attr(*, "total_size")= num 105552
[17:40:53.982]  - attr(*, "where")=List of 11
[17:40:53.982]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:53.982]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:53.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:53.982]  - attr(*, "already-done")= logi TRUE
[17:40:53.992] - copied ‘...future.FUN’ to environment
[17:40:53.992] - reassign environment for ‘x_FUN’
[17:40:53.993] - copied ‘x_FUN’ to environment
[17:40:53.993] - copied ‘times’ to environment
[17:40:53.993] - copied ‘stopf’ to environment
[17:40:53.993] - copied ‘stop_if_not’ to environment
[17:40:53.993] - copied ‘dim’ to environment
[17:40:53.993] - copied ‘valid_types’ to environment
[17:40:53.993] - copied ‘future.call.arguments’ to environment
[17:40:53.993] - copied ‘...future.elements_ii’ to environment
[17:40:53.993] - copied ‘...future.seeds_ii’ to environment
[17:40:53.993] - copied ‘...future.globals.maxSize’ to environment
[17:40:53.994] assign_globals() ... done
[17:40:53.994] plan(): Setting new future strategy stack:
[17:40:53.994] List of future strategies:
[17:40:53.994] 1. sequential:
[17:40:53.994]    - args: function (..., envir = parent.frame())
[17:40:53.994]    - tweaked: FALSE
[17:40:53.994]    - call: NULL
[17:40:53.994] plan(): nbrOfWorkers() = 1
[17:40:53.995] plan(): Setting new future strategy stack:
[17:40:53.995] List of future strategies:
[17:40:53.995] 1. sequential:
[17:40:53.995]    - args: function (..., envir = parent.frame())
[17:40:53.995]    - tweaked: FALSE
[17:40:53.995]    - call: plan(strategy)
[17:40:53.996] plan(): nbrOfWorkers() = 1
[17:40:53.996] SequentialFuture started (and completed)
[17:40:53.996] - Launch lazy future ... done
[17:40:53.996] run() for ‘SequentialFuture’ ... done
[17:40:53.996] Created future:
[17:40:53.996] SequentialFuture:
[17:40:53.996] Label: ‘future_vapply-1’
[17:40:53.996] Expression:
[17:40:53.996] {
[17:40:53.996]     do.call(function(...) {
[17:40:53.996]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:53.996]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:53.996]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:53.996]             on.exit(options(oopts), add = TRUE)
[17:40:53.996]         }
[17:40:53.996]         {
[17:40:53.996]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:53.996]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:53.996]                 ...future.FUN(...future.X_jj, ...)
[17:40:53.996]             })
[17:40:53.996]         }
[17:40:53.996]     }, args = future.call.arguments)
[17:40:53.996] }
[17:40:53.996] Lazy evaluation: FALSE
[17:40:53.996] Asynchronous evaluation: FALSE
[17:40:53.996] Local evaluation: TRUE
[17:40:53.996] Environment: R_GlobalEnv
[17:40:53.996] Capture standard output: TRUE
[17:40:53.996] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:53.996] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:53.996] Packages: 1 packages (‘future.apply’)
[17:40:53.996] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:53.996] Resolved: TRUE
[17:40:53.996] Value: 7.42 KiB of class ‘list’
[17:40:53.996] Early signaling: FALSE
[17:40:53.996] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:53.996] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:53.997] Chunk #1 of 1 ... DONE
[17:40:53.997] Launching 1 futures (chunks) ... DONE
[17:40:53.998] Resolving 1 futures (chunks) ...
[17:40:53.998] resolve() on list ...
[17:40:53.998]  recursive: 0
[17:40:53.998]  length: 1
[17:40:53.998] 
[17:40:53.998] resolved() for ‘SequentialFuture’ ...
[17:40:53.998] - state: ‘finished’
[17:40:53.998] - run: TRUE
[17:40:53.998] - result: ‘FutureResult’
[17:40:53.998] resolved() for ‘SequentialFuture’ ... done
[17:40:53.999] Future #1
[17:40:53.999] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:53.999] - nx: 1
[17:40:53.999] - relay: TRUE
[17:40:53.999] - stdout: TRUE
[17:40:53.999] - signal: TRUE
[17:40:53.999] - resignal: FALSE
[17:40:53.999] - force: TRUE
[17:40:53.999] - relayed: [n=1] FALSE
[17:40:53.999] - queued futures: [n=1] FALSE
[17:40:53.999]  - until=1
[17:40:54.000]  - relaying element #1
[17:40:54.000] - relayed: [n=1] TRUE
[17:40:54.000] - queued futures: [n=1] TRUE
[17:40:54.000] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.000]  length: 0 (resolved future 1)
[17:40:54.000] Relaying remaining futures
[17:40:54.000] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.000] - nx: 1
[17:40:54.000] - relay: TRUE
[17:40:54.000] - stdout: TRUE
[17:40:54.000] - signal: TRUE
[17:40:54.001] - resignal: FALSE
[17:40:54.001] - force: TRUE
[17:40:54.001] - relayed: [n=1] TRUE
[17:40:54.001] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.001] - relayed: [n=1] TRUE
[17:40:54.001] - queued futures: [n=1] TRUE
[17:40:54.001] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.001] resolve() on list ... DONE
[17:40:54.001]  - Number of value chunks collected: 1
[17:40:54.001] Resolving 1 futures (chunks) ... DONE
[17:40:54.002] Reducing values from 1 chunks ...
[17:40:54.002]  - Number of values collected after concatenation: 10
[17:40:54.002]  - Number of values expected: 10
[17:40:54.002] Reducing values from 1 chunks ... DONE
[17:40:54.002] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:40:54.007] future_lapply() ...
[17:40:54.009] Number of chunks: 1
[17:40:54.009] getGlobalsAndPackagesXApply() ...
[17:40:54.009]  - future.globals: TRUE
[17:40:54.009] getGlobalsAndPackages() ...
[17:40:54.009] Searching for globals...
[17:40:54.013] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:40:54.013] Searching for globals ... DONE
[17:40:54.013] Resolving globals: FALSE
[17:40:54.014] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:40:54.014] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.014] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.014] - packages: [2] ‘stats’, ‘future.apply’
[17:40:54.014] getGlobalsAndPackages() ... DONE
[17:40:54.015]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.015]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:40:54.015] Finding globals ... DONE
[17:40:54.015]  - use_args: TRUE
[17:40:54.015]  - Getting '...' globals ...
[17:40:54.015] resolve() on list ...
[17:40:54.015]  recursive: 0
[17:40:54.015]  length: 1
[17:40:54.016]  elements: ‘...’
[17:40:54.016]  length: 0 (resolved future 1)
[17:40:54.016] resolve() on list ... DONE
[17:40:54.016]    - '...' content: [n=0] 
[17:40:54.016] List of 1
[17:40:54.016]  $ ...: list()
[17:40:54.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.016]  - attr(*, "where")=List of 1
[17:40:54.016]   ..$ ...:<environment: 0x564f2f782ac0> 
[17:40:54.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.016]  - attr(*, "resolved")= logi TRUE
[17:40:54.016]  - attr(*, "total_size")= num NA
[17:40:54.018]  - Getting '...' globals ... DONE
[17:40:54.018] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.019] List of 8
[17:40:54.019]  $ ...future.FUN:function (x, ...)  
[17:40:54.019]  $ x_FUN        :function (x, ...)  
[17:40:54.019]  $ times        : int 5
[17:40:54.019]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.019]  $ stop_if_not  :function (...)  
[17:40:54.019]  $ dim          : NULL
[17:40:54.019]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:54.019]  $ ...          : list()
[17:40:54.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.019]  - attr(*, "where")=List of 8
[17:40:54.019]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.019]   ..$ ...          :<environment: 0x564f2f782ac0> 
[17:40:54.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.019]  - attr(*, "resolved")= logi FALSE
[17:40:54.019]  - attr(*, "total_size")= num 95528
[17:40:54.024] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:40:54.024] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.024] Number of futures (= number of chunks): 1
[17:40:54.024] Launching 1 futures (chunks) ...
[17:40:54.024] Chunk #1 of 1 ...
[17:40:54.024]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.025] getGlobalsAndPackages() ...
[17:40:54.025] Searching for globals...
[17:40:54.025] 
[17:40:54.025] Searching for globals ... DONE
[17:40:54.025] - globals: [0] <none>
[17:40:54.025] getGlobalsAndPackages() ... DONE
[17:40:54.025]    + additional globals found: [n=0] 
[17:40:54.025]    + additional namespaces needed: [n=0] 
[17:40:54.025]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.027]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:40:54.027]  - seeds: <none>
[17:40:54.027] getGlobalsAndPackages() ...
[17:40:54.027] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.027] Resolving globals: FALSE
[17:40:54.027] Tweak future expression to call with '...' arguments ...
[17:40:54.027] {
[17:40:54.027]     do.call(function(...) {
[17:40:54.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.027]             on.exit(options(oopts), add = TRUE)
[17:40:54.027]         }
[17:40:54.027]         {
[17:40:54.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.027]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.027]             })
[17:40:54.027]         }
[17:40:54.027]     }, args = future.call.arguments)
[17:40:54.027] }
[17:40:54.028] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.028] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.028] - packages: [2] ‘stats’, ‘future.apply’
[17:40:54.028] getGlobalsAndPackages() ... DONE
[17:40:54.029] run() for ‘Future’ ...
[17:40:54.029] - state: ‘created’
[17:40:54.029] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.029] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.029]   - Field: ‘label’
[17:40:54.029]   - Field: ‘local’
[17:40:54.030]   - Field: ‘owner’
[17:40:54.030]   - Field: ‘envir’
[17:40:54.030]   - Field: ‘packages’
[17:40:54.030]   - Field: ‘gc’
[17:40:54.030]   - Field: ‘conditions’
[17:40:54.030]   - Field: ‘expr’
[17:40:54.030]   - Field: ‘uuid’
[17:40:54.030]   - Field: ‘seed’
[17:40:54.030]   - Field: ‘version’
[17:40:54.030]   - Field: ‘result’
[17:40:54.030]   - Field: ‘asynchronous’
[17:40:54.031]   - Field: ‘calls’
[17:40:54.031]   - Field: ‘globals’
[17:40:54.031]   - Field: ‘stdout’
[17:40:54.031]   - Field: ‘earlySignal’
[17:40:54.031]   - Field: ‘lazy’
[17:40:54.031]   - Field: ‘state’
[17:40:54.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.031] - Launch lazy future ...
[17:40:54.031] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:40:54.032] Packages needed by future strategies (n = 0): <none>
[17:40:54.032] {
[17:40:54.032]     {
[17:40:54.032]         {
[17:40:54.032]             ...future.startTime <- base::Sys.time()
[17:40:54.032]             {
[17:40:54.032]                 {
[17:40:54.032]                   {
[17:40:54.032]                     {
[17:40:54.032]                       base::local({
[17:40:54.032]                         has_future <- base::requireNamespace("future", 
[17:40:54.032]                           quietly = TRUE)
[17:40:54.032]                         if (has_future) {
[17:40:54.032]                           ns <- base::getNamespace("future")
[17:40:54.032]                           version <- ns[[".package"]][["version"]]
[17:40:54.032]                           if (is.null(version)) 
[17:40:54.032]                             version <- utils::packageVersion("future")
[17:40:54.032]                         }
[17:40:54.032]                         else {
[17:40:54.032]                           version <- NULL
[17:40:54.032]                         }
[17:40:54.032]                         if (!has_future || version < "1.8.0") {
[17:40:54.032]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.032]                             "", base::R.version$version.string), 
[17:40:54.032]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.032]                               "release", "version")], collapse = " "), 
[17:40:54.032]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.032]                             info)
[17:40:54.032]                           info <- base::paste(info, collapse = "; ")
[17:40:54.032]                           if (!has_future) {
[17:40:54.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.032]                               info)
[17:40:54.032]                           }
[17:40:54.032]                           else {
[17:40:54.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.032]                               info, version)
[17:40:54.032]                           }
[17:40:54.032]                           base::stop(msg)
[17:40:54.032]                         }
[17:40:54.032]                       })
[17:40:54.032]                     }
[17:40:54.032]                     base::local({
[17:40:54.032]                       for (pkg in c("stats", "future.apply")) {
[17:40:54.032]                         base::loadNamespace(pkg)
[17:40:54.032]                         base::library(pkg, character.only = TRUE)
[17:40:54.032]                       }
[17:40:54.032]                     })
[17:40:54.032]                   }
[17:40:54.032]                   options(future.plan = NULL)
[17:40:54.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.032]                 }
[17:40:54.032]                 ...future.workdir <- getwd()
[17:40:54.032]             }
[17:40:54.032]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.032]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.032]         }
[17:40:54.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.032]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:40:54.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.032]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.032]             base::names(...future.oldOptions))
[17:40:54.032]     }
[17:40:54.032]     if (FALSE) {
[17:40:54.032]     }
[17:40:54.032]     else {
[17:40:54.032]         if (TRUE) {
[17:40:54.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.032]                 open = "w")
[17:40:54.032]         }
[17:40:54.032]         else {
[17:40:54.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.032]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.032]         }
[17:40:54.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.032]             base::sink(type = "output", split = FALSE)
[17:40:54.032]             base::close(...future.stdout)
[17:40:54.032]         }, add = TRUE)
[17:40:54.032]     }
[17:40:54.032]     ...future.frame <- base::sys.nframe()
[17:40:54.032]     ...future.conditions <- base::list()
[17:40:54.032]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.032]     if (FALSE) {
[17:40:54.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.032]     }
[17:40:54.032]     ...future.result <- base::tryCatch({
[17:40:54.032]         base::withCallingHandlers({
[17:40:54.032]             ...future.value <- base::withVisible(base::local({
[17:40:54.032]                 do.call(function(...) {
[17:40:54.032]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.032]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.032]                     ...future.globals.maxSize)) {
[17:40:54.032]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.032]                     on.exit(options(oopts), add = TRUE)
[17:40:54.032]                   }
[17:40:54.032]                   {
[17:40:54.032]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.032]                       FUN = function(jj) {
[17:40:54.032]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.032]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.032]                       })
[17:40:54.032]                   }
[17:40:54.032]                 }, args = future.call.arguments)
[17:40:54.032]             }))
[17:40:54.032]             future::FutureResult(value = ...future.value$value, 
[17:40:54.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.032]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.032]                     ...future.globalenv.names))
[17:40:54.032]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.032]         }, condition = base::local({
[17:40:54.032]             c <- base::c
[17:40:54.032]             inherits <- base::inherits
[17:40:54.032]             invokeRestart <- base::invokeRestart
[17:40:54.032]             length <- base::length
[17:40:54.032]             list <- base::list
[17:40:54.032]             seq.int <- base::seq.int
[17:40:54.032]             signalCondition <- base::signalCondition
[17:40:54.032]             sys.calls <- base::sys.calls
[17:40:54.032]             `[[` <- base::`[[`
[17:40:54.032]             `+` <- base::`+`
[17:40:54.032]             `<<-` <- base::`<<-`
[17:40:54.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.032]                   3L)]
[17:40:54.032]             }
[17:40:54.032]             function(cond) {
[17:40:54.032]                 is_error <- inherits(cond, "error")
[17:40:54.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.032]                   NULL)
[17:40:54.032]                 if (is_error) {
[17:40:54.032]                   sessionInformation <- function() {
[17:40:54.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.032]                       search = base::search(), system = base::Sys.info())
[17:40:54.032]                   }
[17:40:54.032]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.032]                     cond$call), session = sessionInformation(), 
[17:40:54.032]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.032]                   signalCondition(cond)
[17:40:54.032]                 }
[17:40:54.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.032]                 "immediateCondition"))) {
[17:40:54.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.032]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.032]                   if (TRUE && !signal) {
[17:40:54.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.032]                     {
[17:40:54.032]                       inherits <- base::inherits
[17:40:54.032]                       invokeRestart <- base::invokeRestart
[17:40:54.032]                       is.null <- base::is.null
[17:40:54.032]                       muffled <- FALSE
[17:40:54.032]                       if (inherits(cond, "message")) {
[17:40:54.032]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.032]                         if (muffled) 
[17:40:54.032]                           invokeRestart("muffleMessage")
[17:40:54.032]                       }
[17:40:54.032]                       else if (inherits(cond, "warning")) {
[17:40:54.032]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.032]                         if (muffled) 
[17:40:54.032]                           invokeRestart("muffleWarning")
[17:40:54.032]                       }
[17:40:54.032]                       else if (inherits(cond, "condition")) {
[17:40:54.032]                         if (!is.null(pattern)) {
[17:40:54.032]                           computeRestarts <- base::computeRestarts
[17:40:54.032]                           grepl <- base::grepl
[17:40:54.032]                           restarts <- computeRestarts(cond)
[17:40:54.032]                           for (restart in restarts) {
[17:40:54.032]                             name <- restart$name
[17:40:54.032]                             if (is.null(name)) 
[17:40:54.032]                               next
[17:40:54.032]                             if (!grepl(pattern, name)) 
[17:40:54.032]                               next
[17:40:54.032]                             invokeRestart(restart)
[17:40:54.032]                             muffled <- TRUE
[17:40:54.032]                             break
[17:40:54.032]                           }
[17:40:54.032]                         }
[17:40:54.032]                       }
[17:40:54.032]                       invisible(muffled)
[17:40:54.032]                     }
[17:40:54.032]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.032]                   }
[17:40:54.032]                 }
[17:40:54.032]                 else {
[17:40:54.032]                   if (TRUE) {
[17:40:54.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.032]                     {
[17:40:54.032]                       inherits <- base::inherits
[17:40:54.032]                       invokeRestart <- base::invokeRestart
[17:40:54.032]                       is.null <- base::is.null
[17:40:54.032]                       muffled <- FALSE
[17:40:54.032]                       if (inherits(cond, "message")) {
[17:40:54.032]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.032]                         if (muffled) 
[17:40:54.032]                           invokeRestart("muffleMessage")
[17:40:54.032]                       }
[17:40:54.032]                       else if (inherits(cond, "warning")) {
[17:40:54.032]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.032]                         if (muffled) 
[17:40:54.032]                           invokeRestart("muffleWarning")
[17:40:54.032]                       }
[17:40:54.032]                       else if (inherits(cond, "condition")) {
[17:40:54.032]                         if (!is.null(pattern)) {
[17:40:54.032]                           computeRestarts <- base::computeRestarts
[17:40:54.032]                           grepl <- base::grepl
[17:40:54.032]                           restarts <- computeRestarts(cond)
[17:40:54.032]                           for (restart in restarts) {
[17:40:54.032]                             name <- restart$name
[17:40:54.032]                             if (is.null(name)) 
[17:40:54.032]                               next
[17:40:54.032]                             if (!grepl(pattern, name)) 
[17:40:54.032]                               next
[17:40:54.032]                             invokeRestart(restart)
[17:40:54.032]                             muffled <- TRUE
[17:40:54.032]                             break
[17:40:54.032]                           }
[17:40:54.032]                         }
[17:40:54.032]                       }
[17:40:54.032]                       invisible(muffled)
[17:40:54.032]                     }
[17:40:54.032]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.032]                   }
[17:40:54.032]                 }
[17:40:54.032]             }
[17:40:54.032]         }))
[17:40:54.032]     }, error = function(ex) {
[17:40:54.032]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.032]                 ...future.rng), started = ...future.startTime, 
[17:40:54.032]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.032]             version = "1.8"), class = "FutureResult")
[17:40:54.032]     }, finally = {
[17:40:54.032]         if (!identical(...future.workdir, getwd())) 
[17:40:54.032]             setwd(...future.workdir)
[17:40:54.032]         {
[17:40:54.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.032]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.032]             }
[17:40:54.032]             base::options(...future.oldOptions)
[17:40:54.032]             if (.Platform$OS.type == "windows") {
[17:40:54.032]                 old_names <- names(...future.oldEnvVars)
[17:40:54.032]                 envs <- base::Sys.getenv()
[17:40:54.032]                 names <- names(envs)
[17:40:54.032]                 common <- intersect(names, old_names)
[17:40:54.032]                 added <- setdiff(names, old_names)
[17:40:54.032]                 removed <- setdiff(old_names, names)
[17:40:54.032]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.032]                   envs[common]]
[17:40:54.032]                 NAMES <- toupper(changed)
[17:40:54.032]                 args <- list()
[17:40:54.032]                 for (kk in seq_along(NAMES)) {
[17:40:54.032]                   name <- changed[[kk]]
[17:40:54.032]                   NAME <- NAMES[[kk]]
[17:40:54.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.032]                     next
[17:40:54.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.032]                 }
[17:40:54.032]                 NAMES <- toupper(added)
[17:40:54.032]                 for (kk in seq_along(NAMES)) {
[17:40:54.032]                   name <- added[[kk]]
[17:40:54.032]                   NAME <- NAMES[[kk]]
[17:40:54.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.032]                     next
[17:40:54.032]                   args[[name]] <- ""
[17:40:54.032]                 }
[17:40:54.032]                 NAMES <- toupper(removed)
[17:40:54.032]                 for (kk in seq_along(NAMES)) {
[17:40:54.032]                   name <- removed[[kk]]
[17:40:54.032]                   NAME <- NAMES[[kk]]
[17:40:54.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.032]                     next
[17:40:54.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.032]                 }
[17:40:54.032]                 if (length(args) > 0) 
[17:40:54.032]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.032]             }
[17:40:54.032]             else {
[17:40:54.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.032]             }
[17:40:54.032]             {
[17:40:54.032]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.032]                   0L) {
[17:40:54.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.032]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.032]                   base::options(opts)
[17:40:54.032]                 }
[17:40:54.032]                 {
[17:40:54.032]                   {
[17:40:54.032]                     NULL
[17:40:54.032]                     RNGkind("Mersenne-Twister")
[17:40:54.032]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.032]                       inherits = FALSE)
[17:40:54.032]                   }
[17:40:54.032]                   options(future.plan = NULL)
[17:40:54.032]                   if (is.na(NA_character_)) 
[17:40:54.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.032]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.032]                   {
[17:40:54.032]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.032]                     if (!future$lazy) 
[17:40:54.032]                       future <- run(future)
[17:40:54.032]                     invisible(future)
[17:40:54.032]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.032]                 }
[17:40:54.032]             }
[17:40:54.032]         }
[17:40:54.032]     })
[17:40:54.032]     if (TRUE) {
[17:40:54.032]         base::sink(type = "output", split = FALSE)
[17:40:54.032]         if (TRUE) {
[17:40:54.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.032]         }
[17:40:54.032]         else {
[17:40:54.032]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.032]         }
[17:40:54.032]         base::close(...future.stdout)
[17:40:54.032]         ...future.stdout <- NULL
[17:40:54.032]     }
[17:40:54.032]     ...future.result$conditions <- ...future.conditions
[17:40:54.032]     ...future.result$finished <- base::Sys.time()
[17:40:54.032]     ...future.result
[17:40:54.032] }
[17:40:54.034] assign_globals() ...
[17:40:54.034] List of 11
[17:40:54.034]  $ ...future.FUN            :function (x, ...)  
[17:40:54.034]  $ x_FUN                    :function (x, ...)  
[17:40:54.034]  $ times                    : int 5
[17:40:54.034]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.034]  $ stop_if_not              :function (...)  
[17:40:54.034]  $ dim                      : NULL
[17:40:54.034]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.034]  $ future.call.arguments    : list()
[17:40:54.034]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.034]  $ ...future.elements_ii    :List of 3
[17:40:54.034]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:40:54.034]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:40:54.034]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:40:54.034]  $ ...future.seeds_ii       : NULL
[17:40:54.034]  $ ...future.globals.maxSize: NULL
[17:40:54.034]  - attr(*, "resolved")= logi FALSE
[17:40:54.034]  - attr(*, "total_size")= num 95528
[17:40:54.034]  - attr(*, "where")=List of 11
[17:40:54.034]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.034]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.034]  - attr(*, "already-done")= logi TRUE
[17:40:54.042] - copied ‘...future.FUN’ to environment
[17:40:54.042] - copied ‘x_FUN’ to environment
[17:40:54.042] - copied ‘times’ to environment
[17:40:54.042] - copied ‘stopf’ to environment
[17:40:54.042] - copied ‘stop_if_not’ to environment
[17:40:54.042] - copied ‘dim’ to environment
[17:40:54.042] - copied ‘valid_types’ to environment
[17:40:54.042] - copied ‘future.call.arguments’ to environment
[17:40:54.042] - copied ‘...future.elements_ii’ to environment
[17:40:54.043] - copied ‘...future.seeds_ii’ to environment
[17:40:54.043] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.043] assign_globals() ... done
[17:40:54.043] plan(): Setting new future strategy stack:
[17:40:54.043] List of future strategies:
[17:40:54.043] 1. sequential:
[17:40:54.043]    - args: function (..., envir = parent.frame())
[17:40:54.043]    - tweaked: FALSE
[17:40:54.043]    - call: NULL
[17:40:54.044] plan(): nbrOfWorkers() = 1
[17:40:54.045] plan(): Setting new future strategy stack:
[17:40:54.046] List of future strategies:
[17:40:54.046] 1. sequential:
[17:40:54.046]    - args: function (..., envir = parent.frame())
[17:40:54.046]    - tweaked: FALSE
[17:40:54.046]    - call: plan(strategy)
[17:40:54.046] plan(): nbrOfWorkers() = 1
[17:40:54.046] SequentialFuture started (and completed)
[17:40:54.046] - Launch lazy future ... done
[17:40:54.046] run() for ‘SequentialFuture’ ... done
[17:40:54.046] Created future:
[17:40:54.047] SequentialFuture:
[17:40:54.047] Label: ‘future_vapply-1’
[17:40:54.047] Expression:
[17:40:54.047] {
[17:40:54.047]     do.call(function(...) {
[17:40:54.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.047]             on.exit(options(oopts), add = TRUE)
[17:40:54.047]         }
[17:40:54.047]         {
[17:40:54.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.047]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.047]             })
[17:40:54.047]         }
[17:40:54.047]     }, args = future.call.arguments)
[17:40:54.047] }
[17:40:54.047] Lazy evaluation: FALSE
[17:40:54.047] Asynchronous evaluation: FALSE
[17:40:54.047] Local evaluation: TRUE
[17:40:54.047] Environment: R_GlobalEnv
[17:40:54.047] Capture standard output: TRUE
[17:40:54.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.047] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.047] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:40:54.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.047] Resolved: TRUE
[17:40:54.047] Value: 1.71 KiB of class ‘list’
[17:40:54.047] Early signaling: FALSE
[17:40:54.047] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.047] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.048] Chunk #1 of 1 ... DONE
[17:40:54.048] Launching 1 futures (chunks) ... DONE
[17:40:54.048] Resolving 1 futures (chunks) ...
[17:40:54.048] resolve() on list ...
[17:40:54.048]  recursive: 0
[17:40:54.048]  length: 1
[17:40:54.048] 
[17:40:54.048] resolved() for ‘SequentialFuture’ ...
[17:40:54.049] - state: ‘finished’
[17:40:54.049] - run: TRUE
[17:40:54.049] - result: ‘FutureResult’
[17:40:54.049] resolved() for ‘SequentialFuture’ ... done
[17:40:54.049] Future #1
[17:40:54.049] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.049] - nx: 1
[17:40:54.049] - relay: TRUE
[17:40:54.049] - stdout: TRUE
[17:40:54.049] - signal: TRUE
[17:40:54.050] - resignal: FALSE
[17:40:54.050] - force: TRUE
[17:40:54.050] - relayed: [n=1] FALSE
[17:40:54.050] - queued futures: [n=1] FALSE
[17:40:54.050]  - until=1
[17:40:54.051]  - relaying element #1
[17:40:54.052] - relayed: [n=1] TRUE
[17:40:54.052] - queued futures: [n=1] TRUE
[17:40:54.052] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.052]  length: 0 (resolved future 1)
[17:40:54.052] Relaying remaining futures
[17:40:54.052] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.052] - nx: 1
[17:40:54.052] - relay: TRUE
[17:40:54.053] - stdout: TRUE
[17:40:54.053] - signal: TRUE
[17:40:54.053] - resignal: FALSE
[17:40:54.053] - force: TRUE
[17:40:54.053] - relayed: [n=1] TRUE
[17:40:54.053] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.053] - relayed: [n=1] TRUE
[17:40:54.053] - queued futures: [n=1] TRUE
[17:40:54.053] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.053] resolve() on list ... DONE
[17:40:54.054]  - Number of value chunks collected: 1
[17:40:54.054] Resolving 1 futures (chunks) ... DONE
[17:40:54.054] Reducing values from 1 chunks ...
[17:40:54.054]  - Number of values collected after concatenation: 3
[17:40:54.054]  - Number of values expected: 3
[17:40:54.054] Reducing values from 1 chunks ... DONE
[17:40:54.054] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:40:54.056] future_lapply() ...
[17:40:54.060] Number of chunks: 1
[17:40:54.060] getGlobalsAndPackagesXApply() ...
[17:40:54.060]  - future.globals: TRUE
[17:40:54.060] getGlobalsAndPackages() ...
[17:40:54.060] Searching for globals...
[17:40:54.065] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:40:54.065] Searching for globals ... DONE
[17:40:54.065] Resolving globals: FALSE
[17:40:54.066] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:40:54.067] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:40:54.067] - globals: [1] ‘FUN’
[17:40:54.067] - packages: [1] ‘stats’
[17:40:54.067] getGlobalsAndPackages() ... DONE
[17:40:54.067]  - globals found/used: [n=1] ‘FUN’
[17:40:54.067]  - needed namespaces: [n=1] ‘stats’
[17:40:54.067] Finding globals ... DONE
[17:40:54.067]  - use_args: TRUE
[17:40:54.067]  - Getting '...' globals ...
[17:40:54.068] resolve() on list ...
[17:40:54.068]  recursive: 0
[17:40:54.068]  length: 1
[17:40:54.068]  elements: ‘...’
[17:40:54.068]  length: 0 (resolved future 1)
[17:40:54.068] resolve() on list ... DONE
[17:40:54.068]    - '...' content: [n=0] 
[17:40:54.068] List of 1
[17:40:54.068]  $ ...: list()
[17:40:54.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.068]  - attr(*, "where")=List of 1
[17:40:54.068]   ..$ ...:<environment: 0x564f2ea676f0> 
[17:40:54.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.068]  - attr(*, "resolved")= logi TRUE
[17:40:54.068]  - attr(*, "total_size")= num NA
[17:40:54.071]  - Getting '...' globals ... DONE
[17:40:54.071] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:40:54.071] List of 2
[17:40:54.071]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:40:54.071]  $ ...          : list()
[17:40:54.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.071]  - attr(*, "where")=List of 2
[17:40:54.071]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.071]   ..$ ...          :<environment: 0x564f2ea676f0> 
[17:40:54.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.071]  - attr(*, "resolved")= logi FALSE
[17:40:54.071]  - attr(*, "total_size")= num 46960
[17:40:54.076] Packages to be attached in all futures: [n=1] ‘stats’
[17:40:54.076] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.077] Number of futures (= number of chunks): 1
[17:40:54.077] Launching 1 futures (chunks) ...
[17:40:54.077] Chunk #1 of 1 ...
[17:40:54.077]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.077] getGlobalsAndPackages() ...
[17:40:54.077] Searching for globals...
[17:40:54.077] 
[17:40:54.078] Searching for globals ... DONE
[17:40:54.078] - globals: [0] <none>
[17:40:54.078] getGlobalsAndPackages() ... DONE
[17:40:54.078]    + additional globals found: [n=0] 
[17:40:54.078]    + additional namespaces needed: [n=0] 
[17:40:54.078]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 7 * 524288000 = 3670016000 (bytes)
[17:40:54.078]  - seeds: <none>
[17:40:54.078] getGlobalsAndPackages() ...
[17:40:54.078] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.079] Resolving globals: FALSE
[17:40:54.079] Tweak future expression to call with '...' arguments ...
[17:40:54.079] {
[17:40:54.079]     do.call(function(...) {
[17:40:54.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.079]             on.exit(options(oopts), add = TRUE)
[17:40:54.079]         }
[17:40:54.079]         {
[17:40:54.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.079]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.079]             })
[17:40:54.079]         }
[17:40:54.079]     }, args = future.call.arguments)
[17:40:54.079] }
[17:40:54.079] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.079] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.080] - packages: [1] ‘stats’
[17:40:54.080] getGlobalsAndPackages() ... DONE
[17:40:54.080] run() for ‘Future’ ...
[17:40:54.080] - state: ‘created’
[17:40:54.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.081] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.081]   - Field: ‘label’
[17:40:54.081]   - Field: ‘local’
[17:40:54.081]   - Field: ‘owner’
[17:40:54.081]   - Field: ‘envir’
[17:40:54.081]   - Field: ‘packages’
[17:40:54.081]   - Field: ‘gc’
[17:40:54.081]   - Field: ‘conditions’
[17:40:54.081]   - Field: ‘expr’
[17:40:54.082]   - Field: ‘uuid’
[17:40:54.082]   - Field: ‘seed’
[17:40:54.082]   - Field: ‘version’
[17:40:54.082]   - Field: ‘result’
[17:40:54.082]   - Field: ‘asynchronous’
[17:40:54.082]   - Field: ‘calls’
[17:40:54.082]   - Field: ‘globals’
[17:40:54.082]   - Field: ‘stdout’
[17:40:54.082]   - Field: ‘earlySignal’
[17:40:54.082]   - Field: ‘lazy’
[17:40:54.082]   - Field: ‘state’
[17:40:54.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.083] - Launch lazy future ...
[17:40:54.083] Packages needed by the future expression (n = 1): ‘stats’
[17:40:54.083] Packages needed by future strategies (n = 0): <none>
[17:40:54.084] {
[17:40:54.084]     {
[17:40:54.084]         {
[17:40:54.084]             ...future.startTime <- base::Sys.time()
[17:40:54.084]             {
[17:40:54.084]                 {
[17:40:54.084]                   {
[17:40:54.084]                     {
[17:40:54.084]                       base::local({
[17:40:54.084]                         has_future <- base::requireNamespace("future", 
[17:40:54.084]                           quietly = TRUE)
[17:40:54.084]                         if (has_future) {
[17:40:54.084]                           ns <- base::getNamespace("future")
[17:40:54.084]                           version <- ns[[".package"]][["version"]]
[17:40:54.084]                           if (is.null(version)) 
[17:40:54.084]                             version <- utils::packageVersion("future")
[17:40:54.084]                         }
[17:40:54.084]                         else {
[17:40:54.084]                           version <- NULL
[17:40:54.084]                         }
[17:40:54.084]                         if (!has_future || version < "1.8.0") {
[17:40:54.084]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.084]                             "", base::R.version$version.string), 
[17:40:54.084]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.084]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.084]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.084]                               "release", "version")], collapse = " "), 
[17:40:54.084]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.084]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.084]                             info)
[17:40:54.084]                           info <- base::paste(info, collapse = "; ")
[17:40:54.084]                           if (!has_future) {
[17:40:54.084]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.084]                               info)
[17:40:54.084]                           }
[17:40:54.084]                           else {
[17:40:54.084]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.084]                               info, version)
[17:40:54.084]                           }
[17:40:54.084]                           base::stop(msg)
[17:40:54.084]                         }
[17:40:54.084]                       })
[17:40:54.084]                     }
[17:40:54.084]                     base::local({
[17:40:54.084]                       for (pkg in "stats") {
[17:40:54.084]                         base::loadNamespace(pkg)
[17:40:54.084]                         base::library(pkg, character.only = TRUE)
[17:40:54.084]                       }
[17:40:54.084]                     })
[17:40:54.084]                   }
[17:40:54.084]                   options(future.plan = NULL)
[17:40:54.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.084]                 }
[17:40:54.084]                 ...future.workdir <- getwd()
[17:40:54.084]             }
[17:40:54.084]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.084]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.084]         }
[17:40:54.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.084]             future.globals.maxSize = 3670016000, future.globals.method = NULL, 
[17:40:54.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.084]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.084]             base::names(...future.oldOptions))
[17:40:54.084]     }
[17:40:54.084]     if (FALSE) {
[17:40:54.084]     }
[17:40:54.084]     else {
[17:40:54.084]         if (TRUE) {
[17:40:54.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.084]                 open = "w")
[17:40:54.084]         }
[17:40:54.084]         else {
[17:40:54.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.084]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.084]         }
[17:40:54.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.084]             base::sink(type = "output", split = FALSE)
[17:40:54.084]             base::close(...future.stdout)
[17:40:54.084]         }, add = TRUE)
[17:40:54.084]     }
[17:40:54.084]     ...future.frame <- base::sys.nframe()
[17:40:54.084]     ...future.conditions <- base::list()
[17:40:54.084]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.084]     if (FALSE) {
[17:40:54.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.084]     }
[17:40:54.084]     ...future.result <- base::tryCatch({
[17:40:54.084]         base::withCallingHandlers({
[17:40:54.084]             ...future.value <- base::withVisible(base::local({
[17:40:54.084]                 do.call(function(...) {
[17:40:54.084]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.084]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.084]                     ...future.globals.maxSize)) {
[17:40:54.084]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.084]                     on.exit(options(oopts), add = TRUE)
[17:40:54.084]                   }
[17:40:54.084]                   {
[17:40:54.084]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.084]                       FUN = function(jj) {
[17:40:54.084]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.084]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.084]                       })
[17:40:54.084]                   }
[17:40:54.084]                 }, args = future.call.arguments)
[17:40:54.084]             }))
[17:40:54.084]             future::FutureResult(value = ...future.value$value, 
[17:40:54.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.084]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.084]                     ...future.globalenv.names))
[17:40:54.084]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.084]         }, condition = base::local({
[17:40:54.084]             c <- base::c
[17:40:54.084]             inherits <- base::inherits
[17:40:54.084]             invokeRestart <- base::invokeRestart
[17:40:54.084]             length <- base::length
[17:40:54.084]             list <- base::list
[17:40:54.084]             seq.int <- base::seq.int
[17:40:54.084]             signalCondition <- base::signalCondition
[17:40:54.084]             sys.calls <- base::sys.calls
[17:40:54.084]             `[[` <- base::`[[`
[17:40:54.084]             `+` <- base::`+`
[17:40:54.084]             `<<-` <- base::`<<-`
[17:40:54.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.084]                   3L)]
[17:40:54.084]             }
[17:40:54.084]             function(cond) {
[17:40:54.084]                 is_error <- inherits(cond, "error")
[17:40:54.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.084]                   NULL)
[17:40:54.084]                 if (is_error) {
[17:40:54.084]                   sessionInformation <- function() {
[17:40:54.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.084]                       search = base::search(), system = base::Sys.info())
[17:40:54.084]                   }
[17:40:54.084]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.084]                     cond$call), session = sessionInformation(), 
[17:40:54.084]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.084]                   signalCondition(cond)
[17:40:54.084]                 }
[17:40:54.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.084]                 "immediateCondition"))) {
[17:40:54.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.084]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.084]                   if (TRUE && !signal) {
[17:40:54.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.084]                     {
[17:40:54.084]                       inherits <- base::inherits
[17:40:54.084]                       invokeRestart <- base::invokeRestart
[17:40:54.084]                       is.null <- base::is.null
[17:40:54.084]                       muffled <- FALSE
[17:40:54.084]                       if (inherits(cond, "message")) {
[17:40:54.084]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.084]                         if (muffled) 
[17:40:54.084]                           invokeRestart("muffleMessage")
[17:40:54.084]                       }
[17:40:54.084]                       else if (inherits(cond, "warning")) {
[17:40:54.084]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.084]                         if (muffled) 
[17:40:54.084]                           invokeRestart("muffleWarning")
[17:40:54.084]                       }
[17:40:54.084]                       else if (inherits(cond, "condition")) {
[17:40:54.084]                         if (!is.null(pattern)) {
[17:40:54.084]                           computeRestarts <- base::computeRestarts
[17:40:54.084]                           grepl <- base::grepl
[17:40:54.084]                           restarts <- computeRestarts(cond)
[17:40:54.084]                           for (restart in restarts) {
[17:40:54.084]                             name <- restart$name
[17:40:54.084]                             if (is.null(name)) 
[17:40:54.084]                               next
[17:40:54.084]                             if (!grepl(pattern, name)) 
[17:40:54.084]                               next
[17:40:54.084]                             invokeRestart(restart)
[17:40:54.084]                             muffled <- TRUE
[17:40:54.084]                             break
[17:40:54.084]                           }
[17:40:54.084]                         }
[17:40:54.084]                       }
[17:40:54.084]                       invisible(muffled)
[17:40:54.084]                     }
[17:40:54.084]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.084]                   }
[17:40:54.084]                 }
[17:40:54.084]                 else {
[17:40:54.084]                   if (TRUE) {
[17:40:54.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.084]                     {
[17:40:54.084]                       inherits <- base::inherits
[17:40:54.084]                       invokeRestart <- base::invokeRestart
[17:40:54.084]                       is.null <- base::is.null
[17:40:54.084]                       muffled <- FALSE
[17:40:54.084]                       if (inherits(cond, "message")) {
[17:40:54.084]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.084]                         if (muffled) 
[17:40:54.084]                           invokeRestart("muffleMessage")
[17:40:54.084]                       }
[17:40:54.084]                       else if (inherits(cond, "warning")) {
[17:40:54.084]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.084]                         if (muffled) 
[17:40:54.084]                           invokeRestart("muffleWarning")
[17:40:54.084]                       }
[17:40:54.084]                       else if (inherits(cond, "condition")) {
[17:40:54.084]                         if (!is.null(pattern)) {
[17:40:54.084]                           computeRestarts <- base::computeRestarts
[17:40:54.084]                           grepl <- base::grepl
[17:40:54.084]                           restarts <- computeRestarts(cond)
[17:40:54.084]                           for (restart in restarts) {
[17:40:54.084]                             name <- restart$name
[17:40:54.084]                             if (is.null(name)) 
[17:40:54.084]                               next
[17:40:54.084]                             if (!grepl(pattern, name)) 
[17:40:54.084]                               next
[17:40:54.084]                             invokeRestart(restart)
[17:40:54.084]                             muffled <- TRUE
[17:40:54.084]                             break
[17:40:54.084]                           }
[17:40:54.084]                         }
[17:40:54.084]                       }
[17:40:54.084]                       invisible(muffled)
[17:40:54.084]                     }
[17:40:54.084]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.084]                   }
[17:40:54.084]                 }
[17:40:54.084]             }
[17:40:54.084]         }))
[17:40:54.084]     }, error = function(ex) {
[17:40:54.084]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.084]                 ...future.rng), started = ...future.startTime, 
[17:40:54.084]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.084]             version = "1.8"), class = "FutureResult")
[17:40:54.084]     }, finally = {
[17:40:54.084]         if (!identical(...future.workdir, getwd())) 
[17:40:54.084]             setwd(...future.workdir)
[17:40:54.084]         {
[17:40:54.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.084]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.084]             }
[17:40:54.084]             base::options(...future.oldOptions)
[17:40:54.084]             if (.Platform$OS.type == "windows") {
[17:40:54.084]                 old_names <- names(...future.oldEnvVars)
[17:40:54.084]                 envs <- base::Sys.getenv()
[17:40:54.084]                 names <- names(envs)
[17:40:54.084]                 common <- intersect(names, old_names)
[17:40:54.084]                 added <- setdiff(names, old_names)
[17:40:54.084]                 removed <- setdiff(old_names, names)
[17:40:54.084]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.084]                   envs[common]]
[17:40:54.084]                 NAMES <- toupper(changed)
[17:40:54.084]                 args <- list()
[17:40:54.084]                 for (kk in seq_along(NAMES)) {
[17:40:54.084]                   name <- changed[[kk]]
[17:40:54.084]                   NAME <- NAMES[[kk]]
[17:40:54.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.084]                     next
[17:40:54.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.084]                 }
[17:40:54.084]                 NAMES <- toupper(added)
[17:40:54.084]                 for (kk in seq_along(NAMES)) {
[17:40:54.084]                   name <- added[[kk]]
[17:40:54.084]                   NAME <- NAMES[[kk]]
[17:40:54.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.084]                     next
[17:40:54.084]                   args[[name]] <- ""
[17:40:54.084]                 }
[17:40:54.084]                 NAMES <- toupper(removed)
[17:40:54.084]                 for (kk in seq_along(NAMES)) {
[17:40:54.084]                   name <- removed[[kk]]
[17:40:54.084]                   NAME <- NAMES[[kk]]
[17:40:54.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.084]                     next
[17:40:54.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.084]                 }
[17:40:54.084]                 if (length(args) > 0) 
[17:40:54.084]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.084]             }
[17:40:54.084]             else {
[17:40:54.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.084]             }
[17:40:54.084]             {
[17:40:54.084]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.084]                   0L) {
[17:40:54.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.084]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.084]                   base::options(opts)
[17:40:54.084]                 }
[17:40:54.084]                 {
[17:40:54.084]                   {
[17:40:54.084]                     NULL
[17:40:54.084]                     RNGkind("Mersenne-Twister")
[17:40:54.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.084]                       inherits = FALSE)
[17:40:54.084]                   }
[17:40:54.084]                   options(future.plan = NULL)
[17:40:54.084]                   if (is.na(NA_character_)) 
[17:40:54.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.084]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.084]                   {
[17:40:54.084]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.084]                     if (!future$lazy) 
[17:40:54.084]                       future <- run(future)
[17:40:54.084]                     invisible(future)
[17:40:54.084]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.084]                 }
[17:40:54.084]             }
[17:40:54.084]         }
[17:40:54.084]     })
[17:40:54.084]     if (TRUE) {
[17:40:54.084]         base::sink(type = "output", split = FALSE)
[17:40:54.084]         if (TRUE) {
[17:40:54.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.084]         }
[17:40:54.084]         else {
[17:40:54.084]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.084]         }
[17:40:54.084]         base::close(...future.stdout)
[17:40:54.084]         ...future.stdout <- NULL
[17:40:54.084]     }
[17:40:54.084]     ...future.result$conditions <- ...future.conditions
[17:40:54.084]     ...future.result$finished <- base::Sys.time()
[17:40:54.084]     ...future.result
[17:40:54.084] }
[17:40:54.085] assign_globals() ...
[17:40:54.085] List of 5
[17:40:54.085]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:40:54.085]  $ future.call.arguments    : list()
[17:40:54.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.085]  $ ...future.elements_ii    :List of 7
[17:40:54.085]   ..$ : int [1:3] 1 2 3
[17:40:54.085]   ..$ : int [1:4] 1 2 3 4
[17:40:54.085]   ..$ : int [1:5] 1 2 3 4 5
[17:40:54.085]   ..$ : int [1:6] 1 2 3 4 5 6
[17:40:54.085]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:40:54.085]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:40:54.085]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:40:54.085]  $ ...future.seeds_ii       : NULL
[17:40:54.085]  $ ...future.globals.maxSize: NULL
[17:40:54.085]  - attr(*, "resolved")= logi FALSE
[17:40:54.085]  - attr(*, "total_size")= num 46960
[17:40:54.085]  - attr(*, "where")=List of 5
[17:40:54.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.085]  - attr(*, "already-done")= logi TRUE
[17:40:54.092] - copied ‘...future.FUN’ to environment
[17:40:54.092] - copied ‘future.call.arguments’ to environment
[17:40:54.092] - copied ‘...future.elements_ii’ to environment
[17:40:54.092] - copied ‘...future.seeds_ii’ to environment
[17:40:54.092] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.092] assign_globals() ... done
[17:40:54.093] plan(): Setting new future strategy stack:
[17:40:54.093] List of future strategies:
[17:40:54.093] 1. sequential:
[17:40:54.093]    - args: function (..., envir = parent.frame())
[17:40:54.093]    - tweaked: FALSE
[17:40:54.093]    - call: NULL
[17:40:54.093] plan(): nbrOfWorkers() = 1
[17:40:54.094] plan(): Setting new future strategy stack:
[17:40:54.094] List of future strategies:
[17:40:54.094] 1. sequential:
[17:40:54.094]    - args: function (..., envir = parent.frame())
[17:40:54.094]    - tweaked: FALSE
[17:40:54.094]    - call: plan(strategy)
[17:40:54.095] plan(): nbrOfWorkers() = 1
[17:40:54.095] SequentialFuture started (and completed)
[17:40:54.095] - Launch lazy future ... done
[17:40:54.095] run() for ‘SequentialFuture’ ... done
[17:40:54.095] Created future:
[17:40:54.095] SequentialFuture:
[17:40:54.095] Label: ‘future_sapply-1’
[17:40:54.095] Expression:
[17:40:54.095] {
[17:40:54.095]     do.call(function(...) {
[17:40:54.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.095]             on.exit(options(oopts), add = TRUE)
[17:40:54.095]         }
[17:40:54.095]         {
[17:40:54.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.095]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.095]             })
[17:40:54.095]         }
[17:40:54.095]     }, args = future.call.arguments)
[17:40:54.095] }
[17:40:54.095] Lazy evaluation: FALSE
[17:40:54.095] Asynchronous evaluation: FALSE
[17:40:54.095] Local evaluation: TRUE
[17:40:54.095] Environment: R_GlobalEnv
[17:40:54.095] Capture standard output: TRUE
[17:40:54.095] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.095] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:40:54.095] Packages: 1 packages (‘stats’)
[17:40:54.095] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.095] Resolved: TRUE
[17:40:54.095] Value: 672 bytes of class ‘list’
[17:40:54.095] Early signaling: FALSE
[17:40:54.095] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.095] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.096] Chunk #1 of 1 ... DONE
[17:40:54.096] Launching 1 futures (chunks) ... DONE
[17:40:54.097] Resolving 1 futures (chunks) ...
[17:40:54.097] resolve() on list ...
[17:40:54.097]  recursive: 0
[17:40:54.097]  length: 1
[17:40:54.097] 
[17:40:54.097] resolved() for ‘SequentialFuture’ ...
[17:40:54.097] - state: ‘finished’
[17:40:54.099] - run: TRUE
[17:40:54.099] - result: ‘FutureResult’
[17:40:54.099] resolved() for ‘SequentialFuture’ ... done
[17:40:54.099] Future #1
[17:40:54.099] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.100] - nx: 1
[17:40:54.100] - relay: TRUE
[17:40:54.100] - stdout: TRUE
[17:40:54.100] - signal: TRUE
[17:40:54.100] - resignal: FALSE
[17:40:54.100] - force: TRUE
[17:40:54.100] - relayed: [n=1] FALSE
[17:40:54.100] - queued futures: [n=1] FALSE
[17:40:54.100]  - until=1
[17:40:54.100]  - relaying element #1
[17:40:54.101] - relayed: [n=1] TRUE
[17:40:54.101] - queued futures: [n=1] TRUE
[17:40:54.101] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.101]  length: 0 (resolved future 1)
[17:40:54.101] Relaying remaining futures
[17:40:54.101] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.101] - nx: 1
[17:40:54.101] - relay: TRUE
[17:40:54.101] - stdout: TRUE
[17:40:54.102] - signal: TRUE
[17:40:54.102] - resignal: FALSE
[17:40:54.102] - force: TRUE
[17:40:54.102] - relayed: [n=1] TRUE
[17:40:54.102] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.102] - relayed: [n=1] TRUE
[17:40:54.102] - queued futures: [n=1] TRUE
[17:40:54.102] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.102] resolve() on list ... DONE
[17:40:54.102]  - Number of value chunks collected: 1
[17:40:54.103] Resolving 1 futures (chunks) ... DONE
[17:40:54.103] Reducing values from 1 chunks ...
[17:40:54.103]  - Number of values collected after concatenation: 7
[17:40:54.103]  - Number of values expected: 7
[17:40:54.103] Reducing values from 1 chunks ... DONE
[17:40:54.103] future_lapply() ... DONE
[17:40:54.103] future_lapply() ...
[17:40:54.105] Number of chunks: 1
[17:40:54.105] getGlobalsAndPackagesXApply() ...
[17:40:54.105]  - future.globals: TRUE
[17:40:54.105] getGlobalsAndPackages() ...
[17:40:54.106] Searching for globals...
[17:40:54.113] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:40:54.113] Searching for globals ... DONE
[17:40:54.114] Resolving globals: FALSE
[17:40:54.115] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:40:54.115] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:40:54.115] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.116] - packages: [2] ‘stats’, ‘future.apply’
[17:40:54.116] getGlobalsAndPackages() ... DONE
[17:40:54.116]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.116]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:40:54.116] Finding globals ... DONE
[17:40:54.116]  - use_args: TRUE
[17:40:54.116]  - Getting '...' globals ...
[17:40:54.117] resolve() on list ...
[17:40:54.117]  recursive: 0
[17:40:54.117]  length: 1
[17:40:54.117]  elements: ‘...’
[17:40:54.117]  length: 0 (resolved future 1)
[17:40:54.117] resolve() on list ... DONE
[17:40:54.117]    - '...' content: [n=0] 
[17:40:54.117] List of 1
[17:40:54.117]  $ ...: list()
[17:40:54.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.117]  - attr(*, "where")=List of 1
[17:40:54.117]   ..$ ...:<environment: 0x564f2ea31578> 
[17:40:54.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.117]  - attr(*, "resolved")= logi TRUE
[17:40:54.117]  - attr(*, "total_size")= num NA
[17:40:54.121]  - Getting '...' globals ... DONE
[17:40:54.121] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.121] List of 8
[17:40:54.121]  $ ...future.FUN:function (x, ...)  
[17:40:54.121]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:40:54.121]  $ times        : int 5
[17:40:54.121]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.121]  $ stop_if_not  :function (...)  
[17:40:54.121]  $ dim          : NULL
[17:40:54.121]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:54.121]  $ ...          : list()
[17:40:54.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.121]  - attr(*, "where")=List of 8
[17:40:54.121]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.121]   ..$ ...          :<environment: 0x564f2ea31578> 
[17:40:54.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.121]  - attr(*, "resolved")= logi FALSE
[17:40:54.121]  - attr(*, "total_size")= num 141240
[17:40:54.127] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:40:54.127] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.127] Number of futures (= number of chunks): 1
[17:40:54.127] Launching 1 futures (chunks) ...
[17:40:54.127] Chunk #1 of 1 ...
[17:40:54.127]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.128] getGlobalsAndPackages() ...
[17:40:54.128] Searching for globals...
[17:40:54.128] 
[17:40:54.128] Searching for globals ... DONE
[17:40:54.128] - globals: [0] <none>
[17:40:54.128] getGlobalsAndPackages() ... DONE
[17:40:54.128]    + additional globals found: [n=0] 
[17:40:54.128]    + additional namespaces needed: [n=0] 
[17:40:54.128]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.129]  - Adjusted option 'future.globals.maxSize': 524288000 -> 7 * 524288000 = 3670016000 (bytes)
[17:40:54.129]  - seeds: <none>
[17:40:54.129] getGlobalsAndPackages() ...
[17:40:54.129] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.129] Resolving globals: FALSE
[17:40:54.129] Tweak future expression to call with '...' arguments ...
[17:40:54.129] {
[17:40:54.129]     do.call(function(...) {
[17:40:54.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.129]             on.exit(options(oopts), add = TRUE)
[17:40:54.129]         }
[17:40:54.129]         {
[17:40:54.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.129]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.129]             })
[17:40:54.129]         }
[17:40:54.129]     }, args = future.call.arguments)
[17:40:54.129] }
[17:40:54.130] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.130] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.130] - packages: [2] ‘stats’, ‘future.apply’
[17:40:54.130] getGlobalsAndPackages() ... DONE
[17:40:54.131] run() for ‘Future’ ...
[17:40:54.131] - state: ‘created’
[17:40:54.131] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.131] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.131] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.131]   - Field: ‘label’
[17:40:54.132]   - Field: ‘local’
[17:40:54.132]   - Field: ‘owner’
[17:40:54.132]   - Field: ‘envir’
[17:40:54.132]   - Field: ‘packages’
[17:40:54.132]   - Field: ‘gc’
[17:40:54.132]   - Field: ‘conditions’
[17:40:54.132]   - Field: ‘expr’
[17:40:54.132]   - Field: ‘uuid’
[17:40:54.132]   - Field: ‘seed’
[17:40:54.132]   - Field: ‘version’
[17:40:54.133]   - Field: ‘result’
[17:40:54.133]   - Field: ‘asynchronous’
[17:40:54.133]   - Field: ‘calls’
[17:40:54.133]   - Field: ‘globals’
[17:40:54.133]   - Field: ‘stdout’
[17:40:54.133]   - Field: ‘earlySignal’
[17:40:54.133]   - Field: ‘lazy’
[17:40:54.133]   - Field: ‘state’
[17:40:54.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.133] - Launch lazy future ...
[17:40:54.134] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:40:54.134] Packages needed by future strategies (n = 0): <none>
[17:40:54.134] {
[17:40:54.134]     {
[17:40:54.134]         {
[17:40:54.134]             ...future.startTime <- base::Sys.time()
[17:40:54.134]             {
[17:40:54.134]                 {
[17:40:54.134]                   {
[17:40:54.134]                     {
[17:40:54.134]                       base::local({
[17:40:54.134]                         has_future <- base::requireNamespace("future", 
[17:40:54.134]                           quietly = TRUE)
[17:40:54.134]                         if (has_future) {
[17:40:54.134]                           ns <- base::getNamespace("future")
[17:40:54.134]                           version <- ns[[".package"]][["version"]]
[17:40:54.134]                           if (is.null(version)) 
[17:40:54.134]                             version <- utils::packageVersion("future")
[17:40:54.134]                         }
[17:40:54.134]                         else {
[17:40:54.134]                           version <- NULL
[17:40:54.134]                         }
[17:40:54.134]                         if (!has_future || version < "1.8.0") {
[17:40:54.134]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.134]                             "", base::R.version$version.string), 
[17:40:54.134]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.134]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.134]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.134]                               "release", "version")], collapse = " "), 
[17:40:54.134]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.134]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.134]                             info)
[17:40:54.134]                           info <- base::paste(info, collapse = "; ")
[17:40:54.134]                           if (!has_future) {
[17:40:54.134]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.134]                               info)
[17:40:54.134]                           }
[17:40:54.134]                           else {
[17:40:54.134]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.134]                               info, version)
[17:40:54.134]                           }
[17:40:54.134]                           base::stop(msg)
[17:40:54.134]                         }
[17:40:54.134]                       })
[17:40:54.134]                     }
[17:40:54.134]                     base::local({
[17:40:54.134]                       for (pkg in c("stats", "future.apply")) {
[17:40:54.134]                         base::loadNamespace(pkg)
[17:40:54.134]                         base::library(pkg, character.only = TRUE)
[17:40:54.134]                       }
[17:40:54.134]                     })
[17:40:54.134]                   }
[17:40:54.134]                   options(future.plan = NULL)
[17:40:54.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.134]                 }
[17:40:54.134]                 ...future.workdir <- getwd()
[17:40:54.134]             }
[17:40:54.134]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.134]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.134]         }
[17:40:54.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.134]             future.globals.maxSize = 3670016000, future.globals.method = NULL, 
[17:40:54.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.134]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.134]             base::names(...future.oldOptions))
[17:40:54.134]     }
[17:40:54.134]     if (FALSE) {
[17:40:54.134]     }
[17:40:54.134]     else {
[17:40:54.134]         if (TRUE) {
[17:40:54.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.134]                 open = "w")
[17:40:54.134]         }
[17:40:54.134]         else {
[17:40:54.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.134]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.134]         }
[17:40:54.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.134]             base::sink(type = "output", split = FALSE)
[17:40:54.134]             base::close(...future.stdout)
[17:40:54.134]         }, add = TRUE)
[17:40:54.134]     }
[17:40:54.134]     ...future.frame <- base::sys.nframe()
[17:40:54.134]     ...future.conditions <- base::list()
[17:40:54.134]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.134]     if (FALSE) {
[17:40:54.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.134]     }
[17:40:54.134]     ...future.result <- base::tryCatch({
[17:40:54.134]         base::withCallingHandlers({
[17:40:54.134]             ...future.value <- base::withVisible(base::local({
[17:40:54.134]                 do.call(function(...) {
[17:40:54.134]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.134]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.134]                     ...future.globals.maxSize)) {
[17:40:54.134]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.134]                     on.exit(options(oopts), add = TRUE)
[17:40:54.134]                   }
[17:40:54.134]                   {
[17:40:54.134]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.134]                       FUN = function(jj) {
[17:40:54.134]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.134]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.134]                       })
[17:40:54.134]                   }
[17:40:54.134]                 }, args = future.call.arguments)
[17:40:54.134]             }))
[17:40:54.134]             future::FutureResult(value = ...future.value$value, 
[17:40:54.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.134]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.134]                     ...future.globalenv.names))
[17:40:54.134]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.134]         }, condition = base::local({
[17:40:54.134]             c <- base::c
[17:40:54.134]             inherits <- base::inherits
[17:40:54.134]             invokeRestart <- base::invokeRestart
[17:40:54.134]             length <- base::length
[17:40:54.134]             list <- base::list
[17:40:54.134]             seq.int <- base::seq.int
[17:40:54.134]             signalCondition <- base::signalCondition
[17:40:54.134]             sys.calls <- base::sys.calls
[17:40:54.134]             `[[` <- base::`[[`
[17:40:54.134]             `+` <- base::`+`
[17:40:54.134]             `<<-` <- base::`<<-`
[17:40:54.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.134]                   3L)]
[17:40:54.134]             }
[17:40:54.134]             function(cond) {
[17:40:54.134]                 is_error <- inherits(cond, "error")
[17:40:54.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.134]                   NULL)
[17:40:54.134]                 if (is_error) {
[17:40:54.134]                   sessionInformation <- function() {
[17:40:54.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.134]                       search = base::search(), system = base::Sys.info())
[17:40:54.134]                   }
[17:40:54.134]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.134]                     cond$call), session = sessionInformation(), 
[17:40:54.134]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.134]                   signalCondition(cond)
[17:40:54.134]                 }
[17:40:54.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.134]                 "immediateCondition"))) {
[17:40:54.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.134]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.134]                   if (TRUE && !signal) {
[17:40:54.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.134]                     {
[17:40:54.134]                       inherits <- base::inherits
[17:40:54.134]                       invokeRestart <- base::invokeRestart
[17:40:54.134]                       is.null <- base::is.null
[17:40:54.134]                       muffled <- FALSE
[17:40:54.134]                       if (inherits(cond, "message")) {
[17:40:54.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.134]                         if (muffled) 
[17:40:54.134]                           invokeRestart("muffleMessage")
[17:40:54.134]                       }
[17:40:54.134]                       else if (inherits(cond, "warning")) {
[17:40:54.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.134]                         if (muffled) 
[17:40:54.134]                           invokeRestart("muffleWarning")
[17:40:54.134]                       }
[17:40:54.134]                       else if (inherits(cond, "condition")) {
[17:40:54.134]                         if (!is.null(pattern)) {
[17:40:54.134]                           computeRestarts <- base::computeRestarts
[17:40:54.134]                           grepl <- base::grepl
[17:40:54.134]                           restarts <- computeRestarts(cond)
[17:40:54.134]                           for (restart in restarts) {
[17:40:54.134]                             name <- restart$name
[17:40:54.134]                             if (is.null(name)) 
[17:40:54.134]                               next
[17:40:54.134]                             if (!grepl(pattern, name)) 
[17:40:54.134]                               next
[17:40:54.134]                             invokeRestart(restart)
[17:40:54.134]                             muffled <- TRUE
[17:40:54.134]                             break
[17:40:54.134]                           }
[17:40:54.134]                         }
[17:40:54.134]                       }
[17:40:54.134]                       invisible(muffled)
[17:40:54.134]                     }
[17:40:54.134]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.134]                   }
[17:40:54.134]                 }
[17:40:54.134]                 else {
[17:40:54.134]                   if (TRUE) {
[17:40:54.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.134]                     {
[17:40:54.134]                       inherits <- base::inherits
[17:40:54.134]                       invokeRestart <- base::invokeRestart
[17:40:54.134]                       is.null <- base::is.null
[17:40:54.134]                       muffled <- FALSE
[17:40:54.134]                       if (inherits(cond, "message")) {
[17:40:54.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.134]                         if (muffled) 
[17:40:54.134]                           invokeRestart("muffleMessage")
[17:40:54.134]                       }
[17:40:54.134]                       else if (inherits(cond, "warning")) {
[17:40:54.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.134]                         if (muffled) 
[17:40:54.134]                           invokeRestart("muffleWarning")
[17:40:54.134]                       }
[17:40:54.134]                       else if (inherits(cond, "condition")) {
[17:40:54.134]                         if (!is.null(pattern)) {
[17:40:54.134]                           computeRestarts <- base::computeRestarts
[17:40:54.134]                           grepl <- base::grepl
[17:40:54.134]                           restarts <- computeRestarts(cond)
[17:40:54.134]                           for (restart in restarts) {
[17:40:54.134]                             name <- restart$name
[17:40:54.134]                             if (is.null(name)) 
[17:40:54.134]                               next
[17:40:54.134]                             if (!grepl(pattern, name)) 
[17:40:54.134]                               next
[17:40:54.134]                             invokeRestart(restart)
[17:40:54.134]                             muffled <- TRUE
[17:40:54.134]                             break
[17:40:54.134]                           }
[17:40:54.134]                         }
[17:40:54.134]                       }
[17:40:54.134]                       invisible(muffled)
[17:40:54.134]                     }
[17:40:54.134]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.134]                   }
[17:40:54.134]                 }
[17:40:54.134]             }
[17:40:54.134]         }))
[17:40:54.134]     }, error = function(ex) {
[17:40:54.134]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.134]                 ...future.rng), started = ...future.startTime, 
[17:40:54.134]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.134]             version = "1.8"), class = "FutureResult")
[17:40:54.134]     }, finally = {
[17:40:54.134]         if (!identical(...future.workdir, getwd())) 
[17:40:54.134]             setwd(...future.workdir)
[17:40:54.134]         {
[17:40:54.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.134]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.134]             }
[17:40:54.134]             base::options(...future.oldOptions)
[17:40:54.134]             if (.Platform$OS.type == "windows") {
[17:40:54.134]                 old_names <- names(...future.oldEnvVars)
[17:40:54.134]                 envs <- base::Sys.getenv()
[17:40:54.134]                 names <- names(envs)
[17:40:54.134]                 common <- intersect(names, old_names)
[17:40:54.134]                 added <- setdiff(names, old_names)
[17:40:54.134]                 removed <- setdiff(old_names, names)
[17:40:54.134]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.134]                   envs[common]]
[17:40:54.134]                 NAMES <- toupper(changed)
[17:40:54.134]                 args <- list()
[17:40:54.134]                 for (kk in seq_along(NAMES)) {
[17:40:54.134]                   name <- changed[[kk]]
[17:40:54.134]                   NAME <- NAMES[[kk]]
[17:40:54.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.134]                     next
[17:40:54.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.134]                 }
[17:40:54.134]                 NAMES <- toupper(added)
[17:40:54.134]                 for (kk in seq_along(NAMES)) {
[17:40:54.134]                   name <- added[[kk]]
[17:40:54.134]                   NAME <- NAMES[[kk]]
[17:40:54.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.134]                     next
[17:40:54.134]                   args[[name]] <- ""
[17:40:54.134]                 }
[17:40:54.134]                 NAMES <- toupper(removed)
[17:40:54.134]                 for (kk in seq_along(NAMES)) {
[17:40:54.134]                   name <- removed[[kk]]
[17:40:54.134]                   NAME <- NAMES[[kk]]
[17:40:54.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.134]                     next
[17:40:54.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.134]                 }
[17:40:54.134]                 if (length(args) > 0) 
[17:40:54.134]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.134]             }
[17:40:54.134]             else {
[17:40:54.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.134]             }
[17:40:54.134]             {
[17:40:54.134]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.134]                   0L) {
[17:40:54.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.134]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.134]                   base::options(opts)
[17:40:54.134]                 }
[17:40:54.134]                 {
[17:40:54.134]                   {
[17:40:54.134]                     NULL
[17:40:54.134]                     RNGkind("Mersenne-Twister")
[17:40:54.134]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.134]                       inherits = FALSE)
[17:40:54.134]                   }
[17:40:54.134]                   options(future.plan = NULL)
[17:40:54.134]                   if (is.na(NA_character_)) 
[17:40:54.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.134]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.134]                   {
[17:40:54.134]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.134]                     if (!future$lazy) 
[17:40:54.134]                       future <- run(future)
[17:40:54.134]                     invisible(future)
[17:40:54.134]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.134]                 }
[17:40:54.134]             }
[17:40:54.134]         }
[17:40:54.134]     })
[17:40:54.134]     if (TRUE) {
[17:40:54.134]         base::sink(type = "output", split = FALSE)
[17:40:54.134]         if (TRUE) {
[17:40:54.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.134]         }
[17:40:54.134]         else {
[17:40:54.134]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.134]         }
[17:40:54.134]         base::close(...future.stdout)
[17:40:54.134]         ...future.stdout <- NULL
[17:40:54.134]     }
[17:40:54.134]     ...future.result$conditions <- ...future.conditions
[17:40:54.134]     ...future.result$finished <- base::Sys.time()
[17:40:54.134]     ...future.result
[17:40:54.134] }
[17:40:54.136] assign_globals() ...
[17:40:54.136] List of 11
[17:40:54.136]  $ ...future.FUN            :function (x, ...)  
[17:40:54.136]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:40:54.136]  $ times                    : int 5
[17:40:54.136]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.136]  $ stop_if_not              :function (...)  
[17:40:54.136]  $ dim                      : NULL
[17:40:54.136]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.136]  $ future.call.arguments    : list()
[17:40:54.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.136]  $ ...future.elements_ii    :List of 7
[17:40:54.136]   ..$ : int [1:3] 1 2 3
[17:40:54.136]   ..$ : int [1:4] 1 2 3 4
[17:40:54.136]   ..$ : int [1:5] 1 2 3 4 5
[17:40:54.136]   ..$ : int [1:6] 1 2 3 4 5 6
[17:40:54.136]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:40:54.136]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:40:54.136]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:40:54.136]  $ ...future.seeds_ii       : NULL
[17:40:54.136]  $ ...future.globals.maxSize: NULL
[17:40:54.136]  - attr(*, "resolved")= logi FALSE
[17:40:54.136]  - attr(*, "total_size")= num 141240
[17:40:54.136]  - attr(*, "where")=List of 11
[17:40:54.136]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.136]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.136]  - attr(*, "already-done")= logi TRUE
[17:40:54.148] - copied ‘...future.FUN’ to environment
[17:40:54.148] - copied ‘x_FUN’ to environment
[17:40:54.148] - copied ‘times’ to environment
[17:40:54.148] - copied ‘stopf’ to environment
[17:40:54.149] - copied ‘stop_if_not’ to environment
[17:40:54.149] - copied ‘dim’ to environment
[17:40:54.149] - copied ‘valid_types’ to environment
[17:40:54.149] - copied ‘future.call.arguments’ to environment
[17:40:54.149] - copied ‘...future.elements_ii’ to environment
[17:40:54.149] - copied ‘...future.seeds_ii’ to environment
[17:40:54.149] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.149] assign_globals() ... done
[17:40:54.150] plan(): Setting new future strategy stack:
[17:40:54.150] List of future strategies:
[17:40:54.150] 1. sequential:
[17:40:54.150]    - args: function (..., envir = parent.frame())
[17:40:54.150]    - tweaked: FALSE
[17:40:54.150]    - call: NULL
[17:40:54.150] plan(): nbrOfWorkers() = 1
[17:40:54.151] plan(): Setting new future strategy stack:
[17:40:54.151] List of future strategies:
[17:40:54.151] 1. sequential:
[17:40:54.151]    - args: function (..., envir = parent.frame())
[17:40:54.151]    - tweaked: FALSE
[17:40:54.151]    - call: plan(strategy)
[17:40:54.152] plan(): nbrOfWorkers() = 1
[17:40:54.152] SequentialFuture started (and completed)
[17:40:54.152] - Launch lazy future ... done
[17:40:54.152] run() for ‘SequentialFuture’ ... done
[17:40:54.152] Created future:
[17:40:54.152] SequentialFuture:
[17:40:54.152] Label: ‘future_vapply-1’
[17:40:54.152] Expression:
[17:40:54.152] {
[17:40:54.152]     do.call(function(...) {
[17:40:54.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.152]             on.exit(options(oopts), add = TRUE)
[17:40:54.152]         }
[17:40:54.152]         {
[17:40:54.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.152]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.152]             })
[17:40:54.152]         }
[17:40:54.152]     }, args = future.call.arguments)
[17:40:54.152] }
[17:40:54.152] Lazy evaluation: FALSE
[17:40:54.152] Asynchronous evaluation: FALSE
[17:40:54.152] Local evaluation: TRUE
[17:40:54.152] Environment: R_GlobalEnv
[17:40:54.152] Capture standard output: TRUE
[17:40:54.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.152] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.152] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:40:54.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.152] Resolved: TRUE
[17:40:54.152] Value: 672 bytes of class ‘list’
[17:40:54.152] Early signaling: FALSE
[17:40:54.152] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.152] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.153] Chunk #1 of 1 ... DONE
[17:40:54.153] Launching 1 futures (chunks) ... DONE
[17:40:54.154] Resolving 1 futures (chunks) ...
[17:40:54.154] resolve() on list ...
[17:40:54.154]  recursive: 0
[17:40:54.154]  length: 1
[17:40:54.154] 
[17:40:54.154] resolved() for ‘SequentialFuture’ ...
[17:40:54.154] - state: ‘finished’
[17:40:54.154] - run: TRUE
[17:40:54.154] - result: ‘FutureResult’
[17:40:54.154] resolved() for ‘SequentialFuture’ ... done
[17:40:54.155] Future #1
[17:40:54.155] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.155] - nx: 1
[17:40:54.155] - relay: TRUE
[17:40:54.155] - stdout: TRUE
[17:40:54.155] - signal: TRUE
[17:40:54.155] - resignal: FALSE
[17:40:54.155] - force: TRUE
[17:40:54.155] - relayed: [n=1] FALSE
[17:40:54.155] - queued futures: [n=1] FALSE
[17:40:54.155]  - until=1
[17:40:54.156]  - relaying element #1
[17:40:54.156] - relayed: [n=1] TRUE
[17:40:54.156] - queued futures: [n=1] TRUE
[17:40:54.156] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.156]  length: 0 (resolved future 1)
[17:40:54.156] Relaying remaining futures
[17:40:54.156] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.156] - nx: 1
[17:40:54.156] - relay: TRUE
[17:40:54.156] - stdout: TRUE
[17:40:54.157] - signal: TRUE
[17:40:54.157] - resignal: FALSE
[17:40:54.157] - force: TRUE
[17:40:54.157] - relayed: [n=1] TRUE
[17:40:54.157] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.157] - relayed: [n=1] TRUE
[17:40:54.157] - queued futures: [n=1] TRUE
[17:40:54.157] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.157] resolve() on list ... DONE
[17:40:54.157]  - Number of value chunks collected: 1
[17:40:54.158] Resolving 1 futures (chunks) ... DONE
[17:40:54.158] Reducing values from 1 chunks ...
[17:40:54.158]  - Number of values collected after concatenation: 7
[17:40:54.158]  - Number of values expected: 7
[17:40:54.158] Reducing values from 1 chunks ... DONE
[17:40:54.158] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:40:54.160] future_lapply() ...
[17:40:54.160] Number of chunks: 1
[17:40:54.161] getGlobalsAndPackagesXApply() ...
[17:40:54.161]  - future.globals: TRUE
[17:40:54.161] getGlobalsAndPackages() ...
[17:40:54.161] Searching for globals...
[17:40:54.162] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:40:54.162] Searching for globals ... DONE
[17:40:54.162] Resolving globals: FALSE
[17:40:54.163] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:40:54.163] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:40:54.163] - globals: [1] ‘FUN’
[17:40:54.163] 
[17:40:54.163] getGlobalsAndPackages() ... DONE
[17:40:54.163]  - globals found/used: [n=1] ‘FUN’
[17:40:54.164]  - needed namespaces: [n=0] 
[17:40:54.164] Finding globals ... DONE
[17:40:54.164]  - use_args: TRUE
[17:40:54.164]  - Getting '...' globals ...
[17:40:54.164] resolve() on list ...
[17:40:54.164]  recursive: 0
[17:40:54.164]  length: 1
[17:40:54.164]  elements: ‘...’
[17:40:54.165]  length: 0 (resolved future 1)
[17:40:54.165] resolve() on list ... DONE
[17:40:54.165]    - '...' content: [n=1] ‘y’
[17:40:54.165] List of 1
[17:40:54.165]  $ ...:List of 1
[17:40:54.165]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:54.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.165]  - attr(*, "where")=List of 1
[17:40:54.165]   ..$ ...:<environment: 0x564f30209008> 
[17:40:54.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.165]  - attr(*, "resolved")= logi TRUE
[17:40:54.165]  - attr(*, "total_size")= num NA
[17:40:54.170]  - Getting '...' globals ... DONE
[17:40:54.170] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:40:54.170] List of 2
[17:40:54.170]  $ ...future.FUN:function (x, y)  
[17:40:54.170]  $ ...          :List of 1
[17:40:54.170]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:54.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.170]  - attr(*, "where")=List of 2
[17:40:54.170]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.170]   ..$ ...          :<environment: 0x564f30209008> 
[17:40:54.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.170]  - attr(*, "resolved")= logi FALSE
[17:40:54.170]  - attr(*, "total_size")= num 4264
[17:40:54.173] Packages to be attached in all futures: [n=0] 
[17:40:54.173] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.173] Number of futures (= number of chunks): 1
[17:40:54.174] Launching 1 futures (chunks) ...
[17:40:54.174] Chunk #1 of 1 ...
[17:40:54.174]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.174] getGlobalsAndPackages() ...
[17:40:54.174] Searching for globals...
[17:40:54.174] 
[17:40:54.174] Searching for globals ... DONE
[17:40:54.174] - globals: [0] <none>
[17:40:54.175] getGlobalsAndPackages() ... DONE
[17:40:54.175]    + additional globals found: [n=0] 
[17:40:54.175]    + additional namespaces needed: [n=0] 
[17:40:54.175]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.175]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[17:40:54.175]  - seeds: <none>
[17:40:54.175] getGlobalsAndPackages() ...
[17:40:54.175] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.175] Resolving globals: FALSE
[17:40:54.176] Tweak future expression to call with '...' arguments ...
[17:40:54.176] {
[17:40:54.176]     do.call(function(...) {
[17:40:54.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.176]             on.exit(options(oopts), add = TRUE)
[17:40:54.176]         }
[17:40:54.176]         {
[17:40:54.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.176]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.176]             })
[17:40:54.176]         }
[17:40:54.176]     }, args = future.call.arguments)
[17:40:54.176] }
[17:40:54.176] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.176] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.177] 
[17:40:54.177] getGlobalsAndPackages() ... DONE
[17:40:54.177] run() for ‘Future’ ...
[17:40:54.177] - state: ‘created’
[17:40:54.178] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.178]   - Field: ‘label’
[17:40:54.178]   - Field: ‘local’
[17:40:54.178]   - Field: ‘owner’
[17:40:54.178]   - Field: ‘envir’
[17:40:54.178]   - Field: ‘packages’
[17:40:54.179]   - Field: ‘gc’
[17:40:54.179]   - Field: ‘conditions’
[17:40:54.179]   - Field: ‘expr’
[17:40:54.179]   - Field: ‘uuid’
[17:40:54.179]   - Field: ‘seed’
[17:40:54.179]   - Field: ‘version’
[17:40:54.179]   - Field: ‘result’
[17:40:54.179]   - Field: ‘asynchronous’
[17:40:54.179]   - Field: ‘calls’
[17:40:54.179]   - Field: ‘globals’
[17:40:54.179]   - Field: ‘stdout’
[17:40:54.180]   - Field: ‘earlySignal’
[17:40:54.180]   - Field: ‘lazy’
[17:40:54.180]   - Field: ‘state’
[17:40:54.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.180] - Launch lazy future ...
[17:40:54.180] Packages needed by the future expression (n = 0): <none>
[17:40:54.180] Packages needed by future strategies (n = 0): <none>
[17:40:54.181] {
[17:40:54.181]     {
[17:40:54.181]         {
[17:40:54.181]             ...future.startTime <- base::Sys.time()
[17:40:54.181]             {
[17:40:54.181]                 {
[17:40:54.181]                   {
[17:40:54.181]                     base::local({
[17:40:54.181]                       has_future <- base::requireNamespace("future", 
[17:40:54.181]                         quietly = TRUE)
[17:40:54.181]                       if (has_future) {
[17:40:54.181]                         ns <- base::getNamespace("future")
[17:40:54.181]                         version <- ns[[".package"]][["version"]]
[17:40:54.181]                         if (is.null(version)) 
[17:40:54.181]                           version <- utils::packageVersion("future")
[17:40:54.181]                       }
[17:40:54.181]                       else {
[17:40:54.181]                         version <- NULL
[17:40:54.181]                       }
[17:40:54.181]                       if (!has_future || version < "1.8.0") {
[17:40:54.181]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.181]                           "", base::R.version$version.string), 
[17:40:54.181]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:54.181]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.181]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.181]                             "release", "version")], collapse = " "), 
[17:40:54.181]                           hostname = base::Sys.info()[["nodename"]])
[17:40:54.181]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.181]                           info)
[17:40:54.181]                         info <- base::paste(info, collapse = "; ")
[17:40:54.181]                         if (!has_future) {
[17:40:54.181]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.181]                             info)
[17:40:54.181]                         }
[17:40:54.181]                         else {
[17:40:54.181]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.181]                             info, version)
[17:40:54.181]                         }
[17:40:54.181]                         base::stop(msg)
[17:40:54.181]                       }
[17:40:54.181]                     })
[17:40:54.181]                   }
[17:40:54.181]                   options(future.plan = NULL)
[17:40:54.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.181]                 }
[17:40:54.181]                 ...future.workdir <- getwd()
[17:40:54.181]             }
[17:40:54.181]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.181]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.181]         }
[17:40:54.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.181]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[17:40:54.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.181]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.181]             base::names(...future.oldOptions))
[17:40:54.181]     }
[17:40:54.181]     if (FALSE) {
[17:40:54.181]     }
[17:40:54.181]     else {
[17:40:54.181]         if (TRUE) {
[17:40:54.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.181]                 open = "w")
[17:40:54.181]         }
[17:40:54.181]         else {
[17:40:54.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.181]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.181]         }
[17:40:54.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.181]             base::sink(type = "output", split = FALSE)
[17:40:54.181]             base::close(...future.stdout)
[17:40:54.181]         }, add = TRUE)
[17:40:54.181]     }
[17:40:54.181]     ...future.frame <- base::sys.nframe()
[17:40:54.181]     ...future.conditions <- base::list()
[17:40:54.181]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.181]     if (FALSE) {
[17:40:54.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.181]     }
[17:40:54.181]     ...future.result <- base::tryCatch({
[17:40:54.181]         base::withCallingHandlers({
[17:40:54.181]             ...future.value <- base::withVisible(base::local({
[17:40:54.181]                 do.call(function(...) {
[17:40:54.181]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.181]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.181]                     ...future.globals.maxSize)) {
[17:40:54.181]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.181]                     on.exit(options(oopts), add = TRUE)
[17:40:54.181]                   }
[17:40:54.181]                   {
[17:40:54.181]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.181]                       FUN = function(jj) {
[17:40:54.181]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.181]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.181]                       })
[17:40:54.181]                   }
[17:40:54.181]                 }, args = future.call.arguments)
[17:40:54.181]             }))
[17:40:54.181]             future::FutureResult(value = ...future.value$value, 
[17:40:54.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.181]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.181]                     ...future.globalenv.names))
[17:40:54.181]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.181]         }, condition = base::local({
[17:40:54.181]             c <- base::c
[17:40:54.181]             inherits <- base::inherits
[17:40:54.181]             invokeRestart <- base::invokeRestart
[17:40:54.181]             length <- base::length
[17:40:54.181]             list <- base::list
[17:40:54.181]             seq.int <- base::seq.int
[17:40:54.181]             signalCondition <- base::signalCondition
[17:40:54.181]             sys.calls <- base::sys.calls
[17:40:54.181]             `[[` <- base::`[[`
[17:40:54.181]             `+` <- base::`+`
[17:40:54.181]             `<<-` <- base::`<<-`
[17:40:54.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.181]                   3L)]
[17:40:54.181]             }
[17:40:54.181]             function(cond) {
[17:40:54.181]                 is_error <- inherits(cond, "error")
[17:40:54.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.181]                   NULL)
[17:40:54.181]                 if (is_error) {
[17:40:54.181]                   sessionInformation <- function() {
[17:40:54.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.181]                       search = base::search(), system = base::Sys.info())
[17:40:54.181]                   }
[17:40:54.181]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.181]                     cond$call), session = sessionInformation(), 
[17:40:54.181]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.181]                   signalCondition(cond)
[17:40:54.181]                 }
[17:40:54.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.181]                 "immediateCondition"))) {
[17:40:54.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.181]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.181]                   if (TRUE && !signal) {
[17:40:54.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.181]                     {
[17:40:54.181]                       inherits <- base::inherits
[17:40:54.181]                       invokeRestart <- base::invokeRestart
[17:40:54.181]                       is.null <- base::is.null
[17:40:54.181]                       muffled <- FALSE
[17:40:54.181]                       if (inherits(cond, "message")) {
[17:40:54.181]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.181]                         if (muffled) 
[17:40:54.181]                           invokeRestart("muffleMessage")
[17:40:54.181]                       }
[17:40:54.181]                       else if (inherits(cond, "warning")) {
[17:40:54.181]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.181]                         if (muffled) 
[17:40:54.181]                           invokeRestart("muffleWarning")
[17:40:54.181]                       }
[17:40:54.181]                       else if (inherits(cond, "condition")) {
[17:40:54.181]                         if (!is.null(pattern)) {
[17:40:54.181]                           computeRestarts <- base::computeRestarts
[17:40:54.181]                           grepl <- base::grepl
[17:40:54.181]                           restarts <- computeRestarts(cond)
[17:40:54.181]                           for (restart in restarts) {
[17:40:54.181]                             name <- restart$name
[17:40:54.181]                             if (is.null(name)) 
[17:40:54.181]                               next
[17:40:54.181]                             if (!grepl(pattern, name)) 
[17:40:54.181]                               next
[17:40:54.181]                             invokeRestart(restart)
[17:40:54.181]                             muffled <- TRUE
[17:40:54.181]                             break
[17:40:54.181]                           }
[17:40:54.181]                         }
[17:40:54.181]                       }
[17:40:54.181]                       invisible(muffled)
[17:40:54.181]                     }
[17:40:54.181]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.181]                   }
[17:40:54.181]                 }
[17:40:54.181]                 else {
[17:40:54.181]                   if (TRUE) {
[17:40:54.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.181]                     {
[17:40:54.181]                       inherits <- base::inherits
[17:40:54.181]                       invokeRestart <- base::invokeRestart
[17:40:54.181]                       is.null <- base::is.null
[17:40:54.181]                       muffled <- FALSE
[17:40:54.181]                       if (inherits(cond, "message")) {
[17:40:54.181]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.181]                         if (muffled) 
[17:40:54.181]                           invokeRestart("muffleMessage")
[17:40:54.181]                       }
[17:40:54.181]                       else if (inherits(cond, "warning")) {
[17:40:54.181]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.181]                         if (muffled) 
[17:40:54.181]                           invokeRestart("muffleWarning")
[17:40:54.181]                       }
[17:40:54.181]                       else if (inherits(cond, "condition")) {
[17:40:54.181]                         if (!is.null(pattern)) {
[17:40:54.181]                           computeRestarts <- base::computeRestarts
[17:40:54.181]                           grepl <- base::grepl
[17:40:54.181]                           restarts <- computeRestarts(cond)
[17:40:54.181]                           for (restart in restarts) {
[17:40:54.181]                             name <- restart$name
[17:40:54.181]                             if (is.null(name)) 
[17:40:54.181]                               next
[17:40:54.181]                             if (!grepl(pattern, name)) 
[17:40:54.181]                               next
[17:40:54.181]                             invokeRestart(restart)
[17:40:54.181]                             muffled <- TRUE
[17:40:54.181]                             break
[17:40:54.181]                           }
[17:40:54.181]                         }
[17:40:54.181]                       }
[17:40:54.181]                       invisible(muffled)
[17:40:54.181]                     }
[17:40:54.181]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.181]                   }
[17:40:54.181]                 }
[17:40:54.181]             }
[17:40:54.181]         }))
[17:40:54.181]     }, error = function(ex) {
[17:40:54.181]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.181]                 ...future.rng), started = ...future.startTime, 
[17:40:54.181]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.181]             version = "1.8"), class = "FutureResult")
[17:40:54.181]     }, finally = {
[17:40:54.181]         if (!identical(...future.workdir, getwd())) 
[17:40:54.181]             setwd(...future.workdir)
[17:40:54.181]         {
[17:40:54.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.181]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.181]             }
[17:40:54.181]             base::options(...future.oldOptions)
[17:40:54.181]             if (.Platform$OS.type == "windows") {
[17:40:54.181]                 old_names <- names(...future.oldEnvVars)
[17:40:54.181]                 envs <- base::Sys.getenv()
[17:40:54.181]                 names <- names(envs)
[17:40:54.181]                 common <- intersect(names, old_names)
[17:40:54.181]                 added <- setdiff(names, old_names)
[17:40:54.181]                 removed <- setdiff(old_names, names)
[17:40:54.181]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.181]                   envs[common]]
[17:40:54.181]                 NAMES <- toupper(changed)
[17:40:54.181]                 args <- list()
[17:40:54.181]                 for (kk in seq_along(NAMES)) {
[17:40:54.181]                   name <- changed[[kk]]
[17:40:54.181]                   NAME <- NAMES[[kk]]
[17:40:54.181]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.181]                     next
[17:40:54.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.181]                 }
[17:40:54.181]                 NAMES <- toupper(added)
[17:40:54.181]                 for (kk in seq_along(NAMES)) {
[17:40:54.181]                   name <- added[[kk]]
[17:40:54.181]                   NAME <- NAMES[[kk]]
[17:40:54.181]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.181]                     next
[17:40:54.181]                   args[[name]] <- ""
[17:40:54.181]                 }
[17:40:54.181]                 NAMES <- toupper(removed)
[17:40:54.181]                 for (kk in seq_along(NAMES)) {
[17:40:54.181]                   name <- removed[[kk]]
[17:40:54.181]                   NAME <- NAMES[[kk]]
[17:40:54.181]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.181]                     next
[17:40:54.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.181]                 }
[17:40:54.181]                 if (length(args) > 0) 
[17:40:54.181]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.181]             }
[17:40:54.181]             else {
[17:40:54.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.181]             }
[17:40:54.181]             {
[17:40:54.181]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.181]                   0L) {
[17:40:54.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.181]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.181]                   base::options(opts)
[17:40:54.181]                 }
[17:40:54.181]                 {
[17:40:54.181]                   {
[17:40:54.181]                     NULL
[17:40:54.181]                     RNGkind("Mersenne-Twister")
[17:40:54.181]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.181]                       inherits = FALSE)
[17:40:54.181]                   }
[17:40:54.181]                   options(future.plan = NULL)
[17:40:54.181]                   if (is.na(NA_character_)) 
[17:40:54.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.181]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.181]                   {
[17:40:54.181]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.181]                     if (!future$lazy) 
[17:40:54.181]                       future <- run(future)
[17:40:54.181]                     invisible(future)
[17:40:54.181]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.181]                 }
[17:40:54.181]             }
[17:40:54.181]         }
[17:40:54.181]     })
[17:40:54.181]     if (TRUE) {
[17:40:54.181]         base::sink(type = "output", split = FALSE)
[17:40:54.181]         if (TRUE) {
[17:40:54.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.181]         }
[17:40:54.181]         else {
[17:40:54.181]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.181]         }
[17:40:54.181]         base::close(...future.stdout)
[17:40:54.181]         ...future.stdout <- NULL
[17:40:54.181]     }
[17:40:54.181]     ...future.result$conditions <- ...future.conditions
[17:40:54.181]     ...future.result$finished <- base::Sys.time()
[17:40:54.181]     ...future.result
[17:40:54.181] }
[17:40:54.182] assign_globals() ...
[17:40:54.183] List of 5
[17:40:54.183]  $ ...future.FUN            :function (x, y)  
[17:40:54.183]  $ future.call.arguments    :List of 1
[17:40:54.183]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:54.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.183]  $ ...future.elements_ii    :List of 4
[17:40:54.183]   ..$ A: num 50
[17:40:54.183]   ..$ B: num 60
[17:40:54.183]   ..$ C: num 70
[17:40:54.183]   ..$ D: num 80
[17:40:54.183]  $ ...future.seeds_ii       : NULL
[17:40:54.183]  $ ...future.globals.maxSize: NULL
[17:40:54.183]  - attr(*, "resolved")= logi FALSE
[17:40:54.183]  - attr(*, "total_size")= num 4264
[17:40:54.183]  - attr(*, "where")=List of 5
[17:40:54.183]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.183]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.183]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.183]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.183]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.183]  - attr(*, "already-done")= logi TRUE
[17:40:54.189] - reassign environment for ‘...future.FUN’
[17:40:54.189] - copied ‘...future.FUN’ to environment
[17:40:54.189] - copied ‘future.call.arguments’ to environment
[17:40:54.189] - copied ‘...future.elements_ii’ to environment
[17:40:54.189] - copied ‘...future.seeds_ii’ to environment
[17:40:54.189] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.189] assign_globals() ... done
[17:40:54.189] plan(): Setting new future strategy stack:
[17:40:54.189] List of future strategies:
[17:40:54.189] 1. sequential:
[17:40:54.189]    - args: function (..., envir = parent.frame())
[17:40:54.189]    - tweaked: FALSE
[17:40:54.189]    - call: NULL
[17:40:54.190] plan(): nbrOfWorkers() = 1
[17:40:54.191] plan(): Setting new future strategy stack:
[17:40:54.191] List of future strategies:
[17:40:54.191] 1. sequential:
[17:40:54.191]    - args: function (..., envir = parent.frame())
[17:40:54.191]    - tweaked: FALSE
[17:40:54.191]    - call: plan(strategy)
[17:40:54.191] plan(): nbrOfWorkers() = 1
[17:40:54.191] SequentialFuture started (and completed)
[17:40:54.191] - Launch lazy future ... done
[17:40:54.192] run() for ‘SequentialFuture’ ... done
[17:40:54.192] Created future:
[17:40:54.193] SequentialFuture:
[17:40:54.193] Label: ‘future_sapply-1’
[17:40:54.193] Expression:
[17:40:54.193] {
[17:40:54.193]     do.call(function(...) {
[17:40:54.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.193]             on.exit(options(oopts), add = TRUE)
[17:40:54.193]         }
[17:40:54.193]         {
[17:40:54.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.193]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.193]             })
[17:40:54.193]         }
[17:40:54.193]     }, args = future.call.arguments)
[17:40:54.193] }
[17:40:54.193] Lazy evaluation: FALSE
[17:40:54.193] Asynchronous evaluation: FALSE
[17:40:54.193] Local evaluation: TRUE
[17:40:54.193] Environment: R_GlobalEnv
[17:40:54.193] Capture standard output: TRUE
[17:40:54.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.193] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:40:54.193] Packages: <none>
[17:40:54.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.193] Resolved: TRUE
[17:40:54.193] Value: 1.34 KiB of class ‘list’
[17:40:54.193] Early signaling: FALSE
[17:40:54.193] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.193] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.194] Chunk #1 of 1 ... DONE
[17:40:54.194] Launching 1 futures (chunks) ... DONE
[17:40:54.194] Resolving 1 futures (chunks) ...
[17:40:54.195] resolve() on list ...
[17:40:54.195]  recursive: 0
[17:40:54.195]  length: 1
[17:40:54.195] 
[17:40:54.195] resolved() for ‘SequentialFuture’ ...
[17:40:54.195] - state: ‘finished’
[17:40:54.195] - run: TRUE
[17:40:54.195] - result: ‘FutureResult’
[17:40:54.195] resolved() for ‘SequentialFuture’ ... done
[17:40:54.196] Future #1
[17:40:54.196] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.196] - nx: 1
[17:40:54.196] - relay: TRUE
[17:40:54.196] - stdout: TRUE
[17:40:54.196] - signal: TRUE
[17:40:54.196] - resignal: FALSE
[17:40:54.196] - force: TRUE
[17:40:54.196] - relayed: [n=1] FALSE
[17:40:54.196] - queued futures: [n=1] FALSE
[17:40:54.196]  - until=1
[17:40:54.197]  - relaying element #1
[17:40:54.197] - relayed: [n=1] TRUE
[17:40:54.197] - queued futures: [n=1] TRUE
[17:40:54.197] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.197]  length: 0 (resolved future 1)
[17:40:54.197] Relaying remaining futures
[17:40:54.197] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.197] - nx: 1
[17:40:54.197] - relay: TRUE
[17:40:54.198] - stdout: TRUE
[17:40:54.198] - signal: TRUE
[17:40:54.198] - resignal: FALSE
[17:40:54.198] - force: TRUE
[17:40:54.198] - relayed: [n=1] TRUE
[17:40:54.198] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.198] - relayed: [n=1] TRUE
[17:40:54.198] - queued futures: [n=1] TRUE
[17:40:54.198] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.198] resolve() on list ... DONE
[17:40:54.199]  - Number of value chunks collected: 1
[17:40:54.199] Resolving 1 futures (chunks) ... DONE
[17:40:54.199] Reducing values from 1 chunks ...
[17:40:54.199]  - Number of values collected after concatenation: 4
[17:40:54.199]  - Number of values expected: 4
[17:40:54.199] Reducing values from 1 chunks ... DONE
[17:40:54.199] future_lapply() ... DONE
[17:40:54.200] future_lapply() ...
[17:40:54.201] Number of chunks: 1
[17:40:54.202] getGlobalsAndPackagesXApply() ...
[17:40:54.202]  - future.globals: TRUE
[17:40:54.202] getGlobalsAndPackages() ...
[17:40:54.202] Searching for globals...
[17:40:54.205] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:40:54.206] Searching for globals ... DONE
[17:40:54.206] Resolving globals: FALSE
[17:40:54.207] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:40:54.207] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.207] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.207] - packages: [1] ‘future.apply’
[17:40:54.207] getGlobalsAndPackages() ... DONE
[17:40:54.208]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.208]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.208] Finding globals ... DONE
[17:40:54.208]  - use_args: TRUE
[17:40:54.208]  - Getting '...' globals ...
[17:40:54.208] resolve() on list ...
[17:40:54.208]  recursive: 0
[17:40:54.208]  length: 1
[17:40:54.209]  elements: ‘...’
[17:40:54.209]  length: 0 (resolved future 1)
[17:40:54.209] resolve() on list ... DONE
[17:40:54.209]    - '...' content: [n=1] ‘y’
[17:40:54.209] List of 1
[17:40:54.209]  $ ...:List of 1
[17:40:54.209]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:54.209]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.209]  - attr(*, "where")=List of 1
[17:40:54.209]   ..$ ...:<environment: 0x564f2e16d230> 
[17:40:54.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.209]  - attr(*, "resolved")= logi TRUE
[17:40:54.209]  - attr(*, "total_size")= num NA
[17:40:54.212]  - Getting '...' globals ... DONE
[17:40:54.213] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.213] List of 8
[17:40:54.213]  $ ...future.FUN:function (x, ...)  
[17:40:54.213]  $ x_FUN        :function (x, y)  
[17:40:54.213]  $ times        : int 15
[17:40:54.213]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.213]  $ stop_if_not  :function (...)  
[17:40:54.213]  $ dim          : int [1:2] 3 5
[17:40:54.213]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:54.213]  $ ...          :List of 1
[17:40:54.213]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:54.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.213]  - attr(*, "where")=List of 8
[17:40:54.213]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.213]   ..$ ...          :<environment: 0x564f2e16d230> 
[17:40:54.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.213]  - attr(*, "resolved")= logi FALSE
[17:40:54.213]  - attr(*, "total_size")= num 98600
[17:40:54.221] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.221] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.221] Number of futures (= number of chunks): 1
[17:40:54.221] Launching 1 futures (chunks) ...
[17:40:54.221] Chunk #1 of 1 ...
[17:40:54.221]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.221] getGlobalsAndPackages() ...
[17:40:54.221] Searching for globals...
[17:40:54.222] 
[17:40:54.222] Searching for globals ... DONE
[17:40:54.222] - globals: [0] <none>
[17:40:54.222] getGlobalsAndPackages() ... DONE
[17:40:54.222]    + additional globals found: [n=0] 
[17:40:54.222]    + additional namespaces needed: [n=0] 
[17:40:54.222]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.222]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[17:40:54.222]  - seeds: <none>
[17:40:54.222] getGlobalsAndPackages() ...
[17:40:54.223] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.223] Resolving globals: FALSE
[17:40:54.223] Tweak future expression to call with '...' arguments ...
[17:40:54.223] {
[17:40:54.223]     do.call(function(...) {
[17:40:54.223]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.223]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.223]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.223]             on.exit(options(oopts), add = TRUE)
[17:40:54.223]         }
[17:40:54.223]         {
[17:40:54.223]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.223]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.223]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.223]             })
[17:40:54.223]         }
[17:40:54.223]     }, args = future.call.arguments)
[17:40:54.223] }
[17:40:54.223] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.224] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.224] - packages: [1] ‘future.apply’
[17:40:54.224] getGlobalsAndPackages() ... DONE
[17:40:54.224] run() for ‘Future’ ...
[17:40:54.224] - state: ‘created’
[17:40:54.224] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.225] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.225] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.225]   - Field: ‘label’
[17:40:54.225]   - Field: ‘local’
[17:40:54.225]   - Field: ‘owner’
[17:40:54.225]   - Field: ‘envir’
[17:40:54.225]   - Field: ‘packages’
[17:40:54.225]   - Field: ‘gc’
[17:40:54.225]   - Field: ‘conditions’
[17:40:54.226]   - Field: ‘expr’
[17:40:54.226]   - Field: ‘uuid’
[17:40:54.226]   - Field: ‘seed’
[17:40:54.226]   - Field: ‘version’
[17:40:54.226]   - Field: ‘result’
[17:40:54.226]   - Field: ‘asynchronous’
[17:40:54.226]   - Field: ‘calls’
[17:40:54.226]   - Field: ‘globals’
[17:40:54.226]   - Field: ‘stdout’
[17:40:54.226]   - Field: ‘earlySignal’
[17:40:54.226]   - Field: ‘lazy’
[17:40:54.227]   - Field: ‘state’
[17:40:54.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.227] - Launch lazy future ...
[17:40:54.227] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.227] Packages needed by future strategies (n = 0): <none>
[17:40:54.228] {
[17:40:54.228]     {
[17:40:54.228]         {
[17:40:54.228]             ...future.startTime <- base::Sys.time()
[17:40:54.228]             {
[17:40:54.228]                 {
[17:40:54.228]                   {
[17:40:54.228]                     {
[17:40:54.228]                       base::local({
[17:40:54.228]                         has_future <- base::requireNamespace("future", 
[17:40:54.228]                           quietly = TRUE)
[17:40:54.228]                         if (has_future) {
[17:40:54.228]                           ns <- base::getNamespace("future")
[17:40:54.228]                           version <- ns[[".package"]][["version"]]
[17:40:54.228]                           if (is.null(version)) 
[17:40:54.228]                             version <- utils::packageVersion("future")
[17:40:54.228]                         }
[17:40:54.228]                         else {
[17:40:54.228]                           version <- NULL
[17:40:54.228]                         }
[17:40:54.228]                         if (!has_future || version < "1.8.0") {
[17:40:54.228]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.228]                             "", base::R.version$version.string), 
[17:40:54.228]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.228]                               "release", "version")], collapse = " "), 
[17:40:54.228]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.228]                             info)
[17:40:54.228]                           info <- base::paste(info, collapse = "; ")
[17:40:54.228]                           if (!has_future) {
[17:40:54.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.228]                               info)
[17:40:54.228]                           }
[17:40:54.228]                           else {
[17:40:54.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.228]                               info, version)
[17:40:54.228]                           }
[17:40:54.228]                           base::stop(msg)
[17:40:54.228]                         }
[17:40:54.228]                       })
[17:40:54.228]                     }
[17:40:54.228]                     base::local({
[17:40:54.228]                       for (pkg in "future.apply") {
[17:40:54.228]                         base::loadNamespace(pkg)
[17:40:54.228]                         base::library(pkg, character.only = TRUE)
[17:40:54.228]                       }
[17:40:54.228]                     })
[17:40:54.228]                   }
[17:40:54.228]                   options(future.plan = NULL)
[17:40:54.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.228]                 }
[17:40:54.228]                 ...future.workdir <- getwd()
[17:40:54.228]             }
[17:40:54.228]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.228]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.228]         }
[17:40:54.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.228]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[17:40:54.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.228]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.228]             base::names(...future.oldOptions))
[17:40:54.228]     }
[17:40:54.228]     if (FALSE) {
[17:40:54.228]     }
[17:40:54.228]     else {
[17:40:54.228]         if (TRUE) {
[17:40:54.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.228]                 open = "w")
[17:40:54.228]         }
[17:40:54.228]         else {
[17:40:54.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.228]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.228]         }
[17:40:54.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.228]             base::sink(type = "output", split = FALSE)
[17:40:54.228]             base::close(...future.stdout)
[17:40:54.228]         }, add = TRUE)
[17:40:54.228]     }
[17:40:54.228]     ...future.frame <- base::sys.nframe()
[17:40:54.228]     ...future.conditions <- base::list()
[17:40:54.228]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.228]     if (FALSE) {
[17:40:54.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.228]     }
[17:40:54.228]     ...future.result <- base::tryCatch({
[17:40:54.228]         base::withCallingHandlers({
[17:40:54.228]             ...future.value <- base::withVisible(base::local({
[17:40:54.228]                 do.call(function(...) {
[17:40:54.228]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.228]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.228]                     ...future.globals.maxSize)) {
[17:40:54.228]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.228]                     on.exit(options(oopts), add = TRUE)
[17:40:54.228]                   }
[17:40:54.228]                   {
[17:40:54.228]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.228]                       FUN = function(jj) {
[17:40:54.228]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.228]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.228]                       })
[17:40:54.228]                   }
[17:40:54.228]                 }, args = future.call.arguments)
[17:40:54.228]             }))
[17:40:54.228]             future::FutureResult(value = ...future.value$value, 
[17:40:54.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.228]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.228]                     ...future.globalenv.names))
[17:40:54.228]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.228]         }, condition = base::local({
[17:40:54.228]             c <- base::c
[17:40:54.228]             inherits <- base::inherits
[17:40:54.228]             invokeRestart <- base::invokeRestart
[17:40:54.228]             length <- base::length
[17:40:54.228]             list <- base::list
[17:40:54.228]             seq.int <- base::seq.int
[17:40:54.228]             signalCondition <- base::signalCondition
[17:40:54.228]             sys.calls <- base::sys.calls
[17:40:54.228]             `[[` <- base::`[[`
[17:40:54.228]             `+` <- base::`+`
[17:40:54.228]             `<<-` <- base::`<<-`
[17:40:54.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.228]                   3L)]
[17:40:54.228]             }
[17:40:54.228]             function(cond) {
[17:40:54.228]                 is_error <- inherits(cond, "error")
[17:40:54.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.228]                   NULL)
[17:40:54.228]                 if (is_error) {
[17:40:54.228]                   sessionInformation <- function() {
[17:40:54.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.228]                       search = base::search(), system = base::Sys.info())
[17:40:54.228]                   }
[17:40:54.228]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.228]                     cond$call), session = sessionInformation(), 
[17:40:54.228]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.228]                   signalCondition(cond)
[17:40:54.228]                 }
[17:40:54.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.228]                 "immediateCondition"))) {
[17:40:54.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.228]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.228]                   if (TRUE && !signal) {
[17:40:54.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.228]                     {
[17:40:54.228]                       inherits <- base::inherits
[17:40:54.228]                       invokeRestart <- base::invokeRestart
[17:40:54.228]                       is.null <- base::is.null
[17:40:54.228]                       muffled <- FALSE
[17:40:54.228]                       if (inherits(cond, "message")) {
[17:40:54.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.228]                         if (muffled) 
[17:40:54.228]                           invokeRestart("muffleMessage")
[17:40:54.228]                       }
[17:40:54.228]                       else if (inherits(cond, "warning")) {
[17:40:54.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.228]                         if (muffled) 
[17:40:54.228]                           invokeRestart("muffleWarning")
[17:40:54.228]                       }
[17:40:54.228]                       else if (inherits(cond, "condition")) {
[17:40:54.228]                         if (!is.null(pattern)) {
[17:40:54.228]                           computeRestarts <- base::computeRestarts
[17:40:54.228]                           grepl <- base::grepl
[17:40:54.228]                           restarts <- computeRestarts(cond)
[17:40:54.228]                           for (restart in restarts) {
[17:40:54.228]                             name <- restart$name
[17:40:54.228]                             if (is.null(name)) 
[17:40:54.228]                               next
[17:40:54.228]                             if (!grepl(pattern, name)) 
[17:40:54.228]                               next
[17:40:54.228]                             invokeRestart(restart)
[17:40:54.228]                             muffled <- TRUE
[17:40:54.228]                             break
[17:40:54.228]                           }
[17:40:54.228]                         }
[17:40:54.228]                       }
[17:40:54.228]                       invisible(muffled)
[17:40:54.228]                     }
[17:40:54.228]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.228]                   }
[17:40:54.228]                 }
[17:40:54.228]                 else {
[17:40:54.228]                   if (TRUE) {
[17:40:54.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.228]                     {
[17:40:54.228]                       inherits <- base::inherits
[17:40:54.228]                       invokeRestart <- base::invokeRestart
[17:40:54.228]                       is.null <- base::is.null
[17:40:54.228]                       muffled <- FALSE
[17:40:54.228]                       if (inherits(cond, "message")) {
[17:40:54.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.228]                         if (muffled) 
[17:40:54.228]                           invokeRestart("muffleMessage")
[17:40:54.228]                       }
[17:40:54.228]                       else if (inherits(cond, "warning")) {
[17:40:54.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.228]                         if (muffled) 
[17:40:54.228]                           invokeRestart("muffleWarning")
[17:40:54.228]                       }
[17:40:54.228]                       else if (inherits(cond, "condition")) {
[17:40:54.228]                         if (!is.null(pattern)) {
[17:40:54.228]                           computeRestarts <- base::computeRestarts
[17:40:54.228]                           grepl <- base::grepl
[17:40:54.228]                           restarts <- computeRestarts(cond)
[17:40:54.228]                           for (restart in restarts) {
[17:40:54.228]                             name <- restart$name
[17:40:54.228]                             if (is.null(name)) 
[17:40:54.228]                               next
[17:40:54.228]                             if (!grepl(pattern, name)) 
[17:40:54.228]                               next
[17:40:54.228]                             invokeRestart(restart)
[17:40:54.228]                             muffled <- TRUE
[17:40:54.228]                             break
[17:40:54.228]                           }
[17:40:54.228]                         }
[17:40:54.228]                       }
[17:40:54.228]                       invisible(muffled)
[17:40:54.228]                     }
[17:40:54.228]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.228]                   }
[17:40:54.228]                 }
[17:40:54.228]             }
[17:40:54.228]         }))
[17:40:54.228]     }, error = function(ex) {
[17:40:54.228]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.228]                 ...future.rng), started = ...future.startTime, 
[17:40:54.228]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.228]             version = "1.8"), class = "FutureResult")
[17:40:54.228]     }, finally = {
[17:40:54.228]         if (!identical(...future.workdir, getwd())) 
[17:40:54.228]             setwd(...future.workdir)
[17:40:54.228]         {
[17:40:54.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.228]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.228]             }
[17:40:54.228]             base::options(...future.oldOptions)
[17:40:54.228]             if (.Platform$OS.type == "windows") {
[17:40:54.228]                 old_names <- names(...future.oldEnvVars)
[17:40:54.228]                 envs <- base::Sys.getenv()
[17:40:54.228]                 names <- names(envs)
[17:40:54.228]                 common <- intersect(names, old_names)
[17:40:54.228]                 added <- setdiff(names, old_names)
[17:40:54.228]                 removed <- setdiff(old_names, names)
[17:40:54.228]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.228]                   envs[common]]
[17:40:54.228]                 NAMES <- toupper(changed)
[17:40:54.228]                 args <- list()
[17:40:54.228]                 for (kk in seq_along(NAMES)) {
[17:40:54.228]                   name <- changed[[kk]]
[17:40:54.228]                   NAME <- NAMES[[kk]]
[17:40:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.228]                     next
[17:40:54.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.228]                 }
[17:40:54.228]                 NAMES <- toupper(added)
[17:40:54.228]                 for (kk in seq_along(NAMES)) {
[17:40:54.228]                   name <- added[[kk]]
[17:40:54.228]                   NAME <- NAMES[[kk]]
[17:40:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.228]                     next
[17:40:54.228]                   args[[name]] <- ""
[17:40:54.228]                 }
[17:40:54.228]                 NAMES <- toupper(removed)
[17:40:54.228]                 for (kk in seq_along(NAMES)) {
[17:40:54.228]                   name <- removed[[kk]]
[17:40:54.228]                   NAME <- NAMES[[kk]]
[17:40:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.228]                     next
[17:40:54.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.228]                 }
[17:40:54.228]                 if (length(args) > 0) 
[17:40:54.228]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.228]             }
[17:40:54.228]             else {
[17:40:54.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.228]             }
[17:40:54.228]             {
[17:40:54.228]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.228]                   0L) {
[17:40:54.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.228]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.228]                   base::options(opts)
[17:40:54.228]                 }
[17:40:54.228]                 {
[17:40:54.228]                   {
[17:40:54.228]                     NULL
[17:40:54.228]                     RNGkind("Mersenne-Twister")
[17:40:54.228]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.228]                       inherits = FALSE)
[17:40:54.228]                   }
[17:40:54.228]                   options(future.plan = NULL)
[17:40:54.228]                   if (is.na(NA_character_)) 
[17:40:54.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.228]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.228]                   {
[17:40:54.228]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.228]                     if (!future$lazy) 
[17:40:54.228]                       future <- run(future)
[17:40:54.228]                     invisible(future)
[17:40:54.228]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.228]                 }
[17:40:54.228]             }
[17:40:54.228]         }
[17:40:54.228]     })
[17:40:54.228]     if (TRUE) {
[17:40:54.228]         base::sink(type = "output", split = FALSE)
[17:40:54.228]         if (TRUE) {
[17:40:54.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.228]         }
[17:40:54.228]         else {
[17:40:54.228]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.228]         }
[17:40:54.228]         base::close(...future.stdout)
[17:40:54.228]         ...future.stdout <- NULL
[17:40:54.228]     }
[17:40:54.228]     ...future.result$conditions <- ...future.conditions
[17:40:54.228]     ...future.result$finished <- base::Sys.time()
[17:40:54.228]     ...future.result
[17:40:54.228] }
[17:40:54.229] assign_globals() ...
[17:40:54.230] List of 11
[17:40:54.230]  $ ...future.FUN            :function (x, ...)  
[17:40:54.230]  $ x_FUN                    :function (x, y)  
[17:40:54.230]  $ times                    : int 15
[17:40:54.230]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.230]  $ stop_if_not              :function (...)  
[17:40:54.230]  $ dim                      : int [1:2] 3 5
[17:40:54.230]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.230]  $ future.call.arguments    :List of 1
[17:40:54.230]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:54.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.230]  $ ...future.elements_ii    :List of 4
[17:40:54.230]   ..$ A: num 50
[17:40:54.230]   ..$ B: num 60
[17:40:54.230]   ..$ C: num 70
[17:40:54.230]   ..$ D: num 80
[17:40:54.230]  $ ...future.seeds_ii       : NULL
[17:40:54.230]  $ ...future.globals.maxSize: NULL
[17:40:54.230]  - attr(*, "resolved")= logi FALSE
[17:40:54.230]  - attr(*, "total_size")= num 98600
[17:40:54.230]  - attr(*, "where")=List of 11
[17:40:54.230]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.230]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.230]  - attr(*, "already-done")= logi TRUE
[17:40:54.241] - copied ‘...future.FUN’ to environment
[17:40:54.241] - reassign environment for ‘x_FUN’
[17:40:54.241] - copied ‘x_FUN’ to environment
[17:40:54.241] - copied ‘times’ to environment
[17:40:54.241] - copied ‘stopf’ to environment
[17:40:54.241] - copied ‘stop_if_not’ to environment
[17:40:54.241] - copied ‘dim’ to environment
[17:40:54.241] - copied ‘valid_types’ to environment
[17:40:54.241] - copied ‘future.call.arguments’ to environment
[17:40:54.242] - copied ‘...future.elements_ii’ to environment
[17:40:54.242] - copied ‘...future.seeds_ii’ to environment
[17:40:54.242] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.242] assign_globals() ... done
[17:40:54.242] plan(): Setting new future strategy stack:
[17:40:54.242] List of future strategies:
[17:40:54.242] 1. sequential:
[17:40:54.242]    - args: function (..., envir = parent.frame())
[17:40:54.242]    - tweaked: FALSE
[17:40:54.242]    - call: NULL
[17:40:54.243] plan(): nbrOfWorkers() = 1
[17:40:54.244] plan(): Setting new future strategy stack:
[17:40:54.244] List of future strategies:
[17:40:54.244] 1. sequential:
[17:40:54.244]    - args: function (..., envir = parent.frame())
[17:40:54.244]    - tweaked: FALSE
[17:40:54.244]    - call: plan(strategy)
[17:40:54.245] plan(): nbrOfWorkers() = 1
[17:40:54.245] SequentialFuture started (and completed)
[17:40:54.245] - Launch lazy future ... done
[17:40:54.245] run() for ‘SequentialFuture’ ... done
[17:40:54.245] Created future:
[17:40:54.245] SequentialFuture:
[17:40:54.245] Label: ‘future_vapply-1’
[17:40:54.245] Expression:
[17:40:54.245] {
[17:40:54.245]     do.call(function(...) {
[17:40:54.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.245]             on.exit(options(oopts), add = TRUE)
[17:40:54.245]         }
[17:40:54.245]         {
[17:40:54.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.245]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.245]             })
[17:40:54.245]         }
[17:40:54.245]     }, args = future.call.arguments)
[17:40:54.245] }
[17:40:54.245] Lazy evaluation: FALSE
[17:40:54.245] Asynchronous evaluation: FALSE
[17:40:54.245] Local evaluation: TRUE
[17:40:54.245] Environment: R_GlobalEnv
[17:40:54.245] Capture standard output: TRUE
[17:40:54.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.245] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.245] Packages: 1 packages (‘future.apply’)
[17:40:54.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.245] Resolved: TRUE
[17:40:54.245] Value: 1.34 KiB of class ‘list’
[17:40:54.245] Early signaling: FALSE
[17:40:54.245] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.245] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.246] Chunk #1 of 1 ... DONE
[17:40:54.247] Launching 1 futures (chunks) ... DONE
[17:40:54.247] Resolving 1 futures (chunks) ...
[17:40:54.247] resolve() on list ...
[17:40:54.247]  recursive: 0
[17:40:54.247]  length: 1
[17:40:54.247] 
[17:40:54.247] resolved() for ‘SequentialFuture’ ...
[17:40:54.247] - state: ‘finished’
[17:40:54.247] - run: TRUE
[17:40:54.247] - result: ‘FutureResult’
[17:40:54.248] resolved() for ‘SequentialFuture’ ... done
[17:40:54.248] Future #1
[17:40:54.248] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.248] - nx: 1
[17:40:54.248] - relay: TRUE
[17:40:54.248] - stdout: TRUE
[17:40:54.248] - signal: TRUE
[17:40:54.248] - resignal: FALSE
[17:40:54.248] - force: TRUE
[17:40:54.248] - relayed: [n=1] FALSE
[17:40:54.248] - queued futures: [n=1] FALSE
[17:40:54.249]  - until=1
[17:40:54.249]  - relaying element #1
[17:40:54.249] - relayed: [n=1] TRUE
[17:40:54.249] - queued futures: [n=1] TRUE
[17:40:54.249] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.249]  length: 0 (resolved future 1)
[17:40:54.249] Relaying remaining futures
[17:40:54.249] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.249] - nx: 1
[17:40:54.249] - relay: TRUE
[17:40:54.250] - stdout: TRUE
[17:40:54.250] - signal: TRUE
[17:40:54.250] - resignal: FALSE
[17:40:54.250] - force: TRUE
[17:40:54.250] - relayed: [n=1] TRUE
[17:40:54.250] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.250] - relayed: [n=1] TRUE
[17:40:54.250] - queued futures: [n=1] TRUE
[17:40:54.250] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.250] resolve() on list ... DONE
[17:40:54.251]  - Number of value chunks collected: 1
[17:40:54.251] Resolving 1 futures (chunks) ... DONE
[17:40:54.251] Reducing values from 1 chunks ...
[17:40:54.251]  - Number of values collected after concatenation: 4
[17:40:54.251]  - Number of values expected: 4
[17:40:54.251] Reducing values from 1 chunks ... DONE
[17:40:54.251] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:40:54.253] future_lapply() ...
[17:40:54.255] Number of chunks: 1
[17:40:54.255] getGlobalsAndPackagesXApply() ...
[17:40:54.255]  - future.globals: TRUE
[17:40:54.255] getGlobalsAndPackages() ...
[17:40:54.255] Searching for globals...
[17:40:54.258] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:54.258] Searching for globals ... DONE
[17:40:54.258] Resolving globals: FALSE
[17:40:54.259] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:40:54.260] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.260] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.260] - packages: [1] ‘future.apply’
[17:40:54.260] getGlobalsAndPackages() ... DONE
[17:40:54.260]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.260]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.260] Finding globals ... DONE
[17:40:54.260]  - use_args: TRUE
[17:40:54.260]  - Getting '...' globals ...
[17:40:54.262] resolve() on list ...
[17:40:54.263]  recursive: 0
[17:40:54.263]  length: 1
[17:40:54.263]  elements: ‘...’
[17:40:54.263]  length: 0 (resolved future 1)
[17:40:54.263] resolve() on list ... DONE
[17:40:54.263]    - '...' content: [n=0] 
[17:40:54.263] List of 1
[17:40:54.263]  $ ...: list()
[17:40:54.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.263]  - attr(*, "where")=List of 1
[17:40:54.263]   ..$ ...:<environment: 0x564f30077f20> 
[17:40:54.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.263]  - attr(*, "resolved")= logi TRUE
[17:40:54.263]  - attr(*, "total_size")= num NA
[17:40:54.266]  - Getting '...' globals ... DONE
[17:40:54.266] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.266] List of 8
[17:40:54.266]  $ ...future.FUN:function (x, ...)  
[17:40:54.266]  $ x_FUN        :function (x)  
[17:40:54.266]  $ times        : int 1
[17:40:54.266]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.266]  $ stop_if_not  :function (...)  
[17:40:54.266]  $ dim          : NULL
[17:40:54.266]  $ valid_types  : chr "logical"
[17:40:54.266]  $ ...          : list()
[17:40:54.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.266]  - attr(*, "where")=List of 8
[17:40:54.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.266]   ..$ ...          :<environment: 0x564f30077f20> 
[17:40:54.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.266]  - attr(*, "resolved")= logi FALSE
[17:40:54.266]  - attr(*, "total_size")= num 94200
[17:40:54.272] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.272] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.272] Number of futures (= number of chunks): 1
[17:40:54.272] Launching 1 futures (chunks) ...
[17:40:54.272] Chunk #1 of 1 ...
[17:40:54.273]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.273] getGlobalsAndPackages() ...
[17:40:54.273] Searching for globals...
[17:40:54.273] 
[17:40:54.273] Searching for globals ... DONE
[17:40:54.273] - globals: [0] <none>
[17:40:54.273] getGlobalsAndPackages() ... DONE
[17:40:54.273]    + additional globals found: [n=0] 
[17:40:54.273]    + additional namespaces needed: [n=0] 
[17:40:54.273]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.274]  - Adjusted option 'future.globals.maxSize': 524288000 -> 11 * 524288000 = 5767168000 (bytes)
[17:40:54.274]  - seeds: <none>
[17:40:54.274] getGlobalsAndPackages() ...
[17:40:54.274] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.274] Resolving globals: FALSE
[17:40:54.274] Tweak future expression to call with '...' arguments ...
[17:40:54.274] {
[17:40:54.274]     do.call(function(...) {
[17:40:54.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.274]             on.exit(options(oopts), add = TRUE)
[17:40:54.274]         }
[17:40:54.274]         {
[17:40:54.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.274]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.274]             })
[17:40:54.274]         }
[17:40:54.274]     }, args = future.call.arguments)
[17:40:54.274] }
[17:40:54.275] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.275] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.275] - packages: [1] ‘future.apply’
[17:40:54.275] getGlobalsAndPackages() ... DONE
[17:40:54.276] run() for ‘Future’ ...
[17:40:54.276] - state: ‘created’
[17:40:54.276] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.277]   - Field: ‘label’
[17:40:54.277]   - Field: ‘local’
[17:40:54.277]   - Field: ‘owner’
[17:40:54.277]   - Field: ‘envir’
[17:40:54.277]   - Field: ‘packages’
[17:40:54.277]   - Field: ‘gc’
[17:40:54.278]   - Field: ‘conditions’
[17:40:54.278]   - Field: ‘expr’
[17:40:54.278]   - Field: ‘uuid’
[17:40:54.278]   - Field: ‘seed’
[17:40:54.278]   - Field: ‘version’
[17:40:54.278]   - Field: ‘result’
[17:40:54.278]   - Field: ‘asynchronous’
[17:40:54.278]   - Field: ‘calls’
[17:40:54.278]   - Field: ‘globals’
[17:40:54.278]   - Field: ‘stdout’
[17:40:54.279]   - Field: ‘earlySignal’
[17:40:54.279]   - Field: ‘lazy’
[17:40:54.279]   - Field: ‘state’
[17:40:54.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.279] - Launch lazy future ...
[17:40:54.279] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.279] Packages needed by future strategies (n = 0): <none>
[17:40:54.280] {
[17:40:54.280]     {
[17:40:54.280]         {
[17:40:54.280]             ...future.startTime <- base::Sys.time()
[17:40:54.280]             {
[17:40:54.280]                 {
[17:40:54.280]                   {
[17:40:54.280]                     {
[17:40:54.280]                       base::local({
[17:40:54.280]                         has_future <- base::requireNamespace("future", 
[17:40:54.280]                           quietly = TRUE)
[17:40:54.280]                         if (has_future) {
[17:40:54.280]                           ns <- base::getNamespace("future")
[17:40:54.280]                           version <- ns[[".package"]][["version"]]
[17:40:54.280]                           if (is.null(version)) 
[17:40:54.280]                             version <- utils::packageVersion("future")
[17:40:54.280]                         }
[17:40:54.280]                         else {
[17:40:54.280]                           version <- NULL
[17:40:54.280]                         }
[17:40:54.280]                         if (!has_future || version < "1.8.0") {
[17:40:54.280]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.280]                             "", base::R.version$version.string), 
[17:40:54.280]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.280]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.280]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.280]                               "release", "version")], collapse = " "), 
[17:40:54.280]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.280]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.280]                             info)
[17:40:54.280]                           info <- base::paste(info, collapse = "; ")
[17:40:54.280]                           if (!has_future) {
[17:40:54.280]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.280]                               info)
[17:40:54.280]                           }
[17:40:54.280]                           else {
[17:40:54.280]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.280]                               info, version)
[17:40:54.280]                           }
[17:40:54.280]                           base::stop(msg)
[17:40:54.280]                         }
[17:40:54.280]                       })
[17:40:54.280]                     }
[17:40:54.280]                     base::local({
[17:40:54.280]                       for (pkg in "future.apply") {
[17:40:54.280]                         base::loadNamespace(pkg)
[17:40:54.280]                         base::library(pkg, character.only = TRUE)
[17:40:54.280]                       }
[17:40:54.280]                     })
[17:40:54.280]                   }
[17:40:54.280]                   options(future.plan = NULL)
[17:40:54.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.280]                 }
[17:40:54.280]                 ...future.workdir <- getwd()
[17:40:54.280]             }
[17:40:54.280]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.280]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.280]         }
[17:40:54.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.280]             future.globals.maxSize = 5767168000, future.globals.method = NULL, 
[17:40:54.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.280]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.280]             base::names(...future.oldOptions))
[17:40:54.280]     }
[17:40:54.280]     if (FALSE) {
[17:40:54.280]     }
[17:40:54.280]     else {
[17:40:54.280]         if (TRUE) {
[17:40:54.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.280]                 open = "w")
[17:40:54.280]         }
[17:40:54.280]         else {
[17:40:54.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.280]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.280]         }
[17:40:54.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.280]             base::sink(type = "output", split = FALSE)
[17:40:54.280]             base::close(...future.stdout)
[17:40:54.280]         }, add = TRUE)
[17:40:54.280]     }
[17:40:54.280]     ...future.frame <- base::sys.nframe()
[17:40:54.280]     ...future.conditions <- base::list()
[17:40:54.280]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.280]     if (FALSE) {
[17:40:54.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.280]     }
[17:40:54.280]     ...future.result <- base::tryCatch({
[17:40:54.280]         base::withCallingHandlers({
[17:40:54.280]             ...future.value <- base::withVisible(base::local({
[17:40:54.280]                 do.call(function(...) {
[17:40:54.280]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.280]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.280]                     ...future.globals.maxSize)) {
[17:40:54.280]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.280]                     on.exit(options(oopts), add = TRUE)
[17:40:54.280]                   }
[17:40:54.280]                   {
[17:40:54.280]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.280]                       FUN = function(jj) {
[17:40:54.280]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.280]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.280]                       })
[17:40:54.280]                   }
[17:40:54.280]                 }, args = future.call.arguments)
[17:40:54.280]             }))
[17:40:54.280]             future::FutureResult(value = ...future.value$value, 
[17:40:54.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.280]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.280]                     ...future.globalenv.names))
[17:40:54.280]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.280]         }, condition = base::local({
[17:40:54.280]             c <- base::c
[17:40:54.280]             inherits <- base::inherits
[17:40:54.280]             invokeRestart <- base::invokeRestart
[17:40:54.280]             length <- base::length
[17:40:54.280]             list <- base::list
[17:40:54.280]             seq.int <- base::seq.int
[17:40:54.280]             signalCondition <- base::signalCondition
[17:40:54.280]             sys.calls <- base::sys.calls
[17:40:54.280]             `[[` <- base::`[[`
[17:40:54.280]             `+` <- base::`+`
[17:40:54.280]             `<<-` <- base::`<<-`
[17:40:54.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.280]                   3L)]
[17:40:54.280]             }
[17:40:54.280]             function(cond) {
[17:40:54.280]                 is_error <- inherits(cond, "error")
[17:40:54.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.280]                   NULL)
[17:40:54.280]                 if (is_error) {
[17:40:54.280]                   sessionInformation <- function() {
[17:40:54.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.280]                       search = base::search(), system = base::Sys.info())
[17:40:54.280]                   }
[17:40:54.280]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.280]                     cond$call), session = sessionInformation(), 
[17:40:54.280]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.280]                   signalCondition(cond)
[17:40:54.280]                 }
[17:40:54.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.280]                 "immediateCondition"))) {
[17:40:54.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.280]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.280]                   if (TRUE && !signal) {
[17:40:54.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.280]                     {
[17:40:54.280]                       inherits <- base::inherits
[17:40:54.280]                       invokeRestart <- base::invokeRestart
[17:40:54.280]                       is.null <- base::is.null
[17:40:54.280]                       muffled <- FALSE
[17:40:54.280]                       if (inherits(cond, "message")) {
[17:40:54.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.280]                         if (muffled) 
[17:40:54.280]                           invokeRestart("muffleMessage")
[17:40:54.280]                       }
[17:40:54.280]                       else if (inherits(cond, "warning")) {
[17:40:54.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.280]                         if (muffled) 
[17:40:54.280]                           invokeRestart("muffleWarning")
[17:40:54.280]                       }
[17:40:54.280]                       else if (inherits(cond, "condition")) {
[17:40:54.280]                         if (!is.null(pattern)) {
[17:40:54.280]                           computeRestarts <- base::computeRestarts
[17:40:54.280]                           grepl <- base::grepl
[17:40:54.280]                           restarts <- computeRestarts(cond)
[17:40:54.280]                           for (restart in restarts) {
[17:40:54.280]                             name <- restart$name
[17:40:54.280]                             if (is.null(name)) 
[17:40:54.280]                               next
[17:40:54.280]                             if (!grepl(pattern, name)) 
[17:40:54.280]                               next
[17:40:54.280]                             invokeRestart(restart)
[17:40:54.280]                             muffled <- TRUE
[17:40:54.280]                             break
[17:40:54.280]                           }
[17:40:54.280]                         }
[17:40:54.280]                       }
[17:40:54.280]                       invisible(muffled)
[17:40:54.280]                     }
[17:40:54.280]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.280]                   }
[17:40:54.280]                 }
[17:40:54.280]                 else {
[17:40:54.280]                   if (TRUE) {
[17:40:54.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.280]                     {
[17:40:54.280]                       inherits <- base::inherits
[17:40:54.280]                       invokeRestart <- base::invokeRestart
[17:40:54.280]                       is.null <- base::is.null
[17:40:54.280]                       muffled <- FALSE
[17:40:54.280]                       if (inherits(cond, "message")) {
[17:40:54.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.280]                         if (muffled) 
[17:40:54.280]                           invokeRestart("muffleMessage")
[17:40:54.280]                       }
[17:40:54.280]                       else if (inherits(cond, "warning")) {
[17:40:54.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.280]                         if (muffled) 
[17:40:54.280]                           invokeRestart("muffleWarning")
[17:40:54.280]                       }
[17:40:54.280]                       else if (inherits(cond, "condition")) {
[17:40:54.280]                         if (!is.null(pattern)) {
[17:40:54.280]                           computeRestarts <- base::computeRestarts
[17:40:54.280]                           grepl <- base::grepl
[17:40:54.280]                           restarts <- computeRestarts(cond)
[17:40:54.280]                           for (restart in restarts) {
[17:40:54.280]                             name <- restart$name
[17:40:54.280]                             if (is.null(name)) 
[17:40:54.280]                               next
[17:40:54.280]                             if (!grepl(pattern, name)) 
[17:40:54.280]                               next
[17:40:54.280]                             invokeRestart(restart)
[17:40:54.280]                             muffled <- TRUE
[17:40:54.280]                             break
[17:40:54.280]                           }
[17:40:54.280]                         }
[17:40:54.280]                       }
[17:40:54.280]                       invisible(muffled)
[17:40:54.280]                     }
[17:40:54.280]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.280]                   }
[17:40:54.280]                 }
[17:40:54.280]             }
[17:40:54.280]         }))
[17:40:54.280]     }, error = function(ex) {
[17:40:54.280]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.280]                 ...future.rng), started = ...future.startTime, 
[17:40:54.280]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.280]             version = "1.8"), class = "FutureResult")
[17:40:54.280]     }, finally = {
[17:40:54.280]         if (!identical(...future.workdir, getwd())) 
[17:40:54.280]             setwd(...future.workdir)
[17:40:54.280]         {
[17:40:54.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.280]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.280]             }
[17:40:54.280]             base::options(...future.oldOptions)
[17:40:54.280]             if (.Platform$OS.type == "windows") {
[17:40:54.280]                 old_names <- names(...future.oldEnvVars)
[17:40:54.280]                 envs <- base::Sys.getenv()
[17:40:54.280]                 names <- names(envs)
[17:40:54.280]                 common <- intersect(names, old_names)
[17:40:54.280]                 added <- setdiff(names, old_names)
[17:40:54.280]                 removed <- setdiff(old_names, names)
[17:40:54.280]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.280]                   envs[common]]
[17:40:54.280]                 NAMES <- toupper(changed)
[17:40:54.280]                 args <- list()
[17:40:54.280]                 for (kk in seq_along(NAMES)) {
[17:40:54.280]                   name <- changed[[kk]]
[17:40:54.280]                   NAME <- NAMES[[kk]]
[17:40:54.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.280]                     next
[17:40:54.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.280]                 }
[17:40:54.280]                 NAMES <- toupper(added)
[17:40:54.280]                 for (kk in seq_along(NAMES)) {
[17:40:54.280]                   name <- added[[kk]]
[17:40:54.280]                   NAME <- NAMES[[kk]]
[17:40:54.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.280]                     next
[17:40:54.280]                   args[[name]] <- ""
[17:40:54.280]                 }
[17:40:54.280]                 NAMES <- toupper(removed)
[17:40:54.280]                 for (kk in seq_along(NAMES)) {
[17:40:54.280]                   name <- removed[[kk]]
[17:40:54.280]                   NAME <- NAMES[[kk]]
[17:40:54.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.280]                     next
[17:40:54.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.280]                 }
[17:40:54.280]                 if (length(args) > 0) 
[17:40:54.280]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.280]             }
[17:40:54.280]             else {
[17:40:54.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.280]             }
[17:40:54.280]             {
[17:40:54.280]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.280]                   0L) {
[17:40:54.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.280]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.280]                   base::options(opts)
[17:40:54.280]                 }
[17:40:54.280]                 {
[17:40:54.280]                   {
[17:40:54.280]                     NULL
[17:40:54.280]                     RNGkind("Mersenne-Twister")
[17:40:54.280]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.280]                       inherits = FALSE)
[17:40:54.280]                   }
[17:40:54.280]                   options(future.plan = NULL)
[17:40:54.280]                   if (is.na(NA_character_)) 
[17:40:54.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.280]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.280]                   {
[17:40:54.280]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.280]                     if (!future$lazy) 
[17:40:54.280]                       future <- run(future)
[17:40:54.280]                     invisible(future)
[17:40:54.280]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.280]                 }
[17:40:54.280]             }
[17:40:54.280]         }
[17:40:54.280]     })
[17:40:54.280]     if (TRUE) {
[17:40:54.280]         base::sink(type = "output", split = FALSE)
[17:40:54.280]         if (TRUE) {
[17:40:54.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.280]         }
[17:40:54.280]         else {
[17:40:54.280]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.280]         }
[17:40:54.280]         base::close(...future.stdout)
[17:40:54.280]         ...future.stdout <- NULL
[17:40:54.280]     }
[17:40:54.280]     ...future.result$conditions <- ...future.conditions
[17:40:54.280]     ...future.result$finished <- base::Sys.time()
[17:40:54.280]     ...future.result
[17:40:54.280] }
[17:40:54.282] assign_globals() ...
[17:40:54.282] List of 11
[17:40:54.282]  $ ...future.FUN            :function (x, ...)  
[17:40:54.282]  $ x_FUN                    :function (x)  
[17:40:54.282]  $ times                    : int 1
[17:40:54.282]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.282]  $ stop_if_not              :function (...)  
[17:40:54.282]  $ dim                      : NULL
[17:40:54.282]  $ valid_types              : chr "logical"
[17:40:54.282]  $ future.call.arguments    : list()
[17:40:54.282]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.282]  $ ...future.elements_ii    :List of 11
[17:40:54.282]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:40:54.282]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:40:54.282]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:40:54.282]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:40:54.282]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:40:54.282]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:40:54.282]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:40:54.282]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:40:54.282]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:40:54.282]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:40:54.282]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:40:54.282]  $ ...future.seeds_ii       : NULL
[17:40:54.282]  $ ...future.globals.maxSize: NULL
[17:40:54.282]  - attr(*, "resolved")= logi FALSE
[17:40:54.282]  - attr(*, "total_size")= num 94200
[17:40:54.282]  - attr(*, "where")=List of 11
[17:40:54.282]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.282]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.282]  - attr(*, "already-done")= logi TRUE
[17:40:54.295] - copied ‘...future.FUN’ to environment
[17:40:54.295] - copied ‘x_FUN’ to environment
[17:40:54.295] - copied ‘times’ to environment
[17:40:54.295] - copied ‘stopf’ to environment
[17:40:54.295] - copied ‘stop_if_not’ to environment
[17:40:54.295] - copied ‘dim’ to environment
[17:40:54.295] - copied ‘valid_types’ to environment
[17:40:54.295] - copied ‘future.call.arguments’ to environment
[17:40:54.296] - copied ‘...future.elements_ii’ to environment
[17:40:54.296] - copied ‘...future.seeds_ii’ to environment
[17:40:54.296] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.296] assign_globals() ... done
[17:40:54.296] plan(): Setting new future strategy stack:
[17:40:54.296] List of future strategies:
[17:40:54.296] 1. sequential:
[17:40:54.296]    - args: function (..., envir = parent.frame())
[17:40:54.296]    - tweaked: FALSE
[17:40:54.296]    - call: NULL
[17:40:54.297] plan(): nbrOfWorkers() = 1
[17:40:54.298] plan(): Setting new future strategy stack:
[17:40:54.298] List of future strategies:
[17:40:54.298] 1. sequential:
[17:40:54.298]    - args: function (..., envir = parent.frame())
[17:40:54.298]    - tweaked: FALSE
[17:40:54.298]    - call: plan(strategy)
[17:40:54.298] plan(): nbrOfWorkers() = 1
[17:40:54.298] SequentialFuture started (and completed)
[17:40:54.298] - Launch lazy future ... done
[17:40:54.299] run() for ‘SequentialFuture’ ... done
[17:40:54.299] Created future:
[17:40:54.299] SequentialFuture:
[17:40:54.299] Label: ‘future_vapply-1’
[17:40:54.299] Expression:
[17:40:54.299] {
[17:40:54.299]     do.call(function(...) {
[17:40:54.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.299]             on.exit(options(oopts), add = TRUE)
[17:40:54.299]         }
[17:40:54.299]         {
[17:40:54.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.299]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.299]             })
[17:40:54.299]         }
[17:40:54.299]     }, args = future.call.arguments)
[17:40:54.299] }
[17:40:54.299] Lazy evaluation: FALSE
[17:40:54.299] Asynchronous evaluation: FALSE
[17:40:54.299] Local evaluation: TRUE
[17:40:54.299] Environment: R_GlobalEnv
[17:40:54.299] Capture standard output: TRUE
[17:40:54.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.299] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.299] Packages: 1 packages (‘future.apply’)
[17:40:54.299] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.299] Resolved: TRUE
[17:40:54.299] Value: 616 bytes of class ‘list’
[17:40:54.299] Early signaling: FALSE
[17:40:54.299] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.299] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.300] Chunk #1 of 1 ... DONE
[17:40:54.300] Launching 1 futures (chunks) ... DONE
[17:40:54.300] Resolving 1 futures (chunks) ...
[17:40:54.300] resolve() on list ...
[17:40:54.301]  recursive: 0
[17:40:54.301]  length: 1
[17:40:54.301] 
[17:40:54.301] resolved() for ‘SequentialFuture’ ...
[17:40:54.301] - state: ‘finished’
[17:40:54.301] - run: TRUE
[17:40:54.301] - result: ‘FutureResult’
[17:40:54.301] resolved() for ‘SequentialFuture’ ... done
[17:40:54.301] Future #1
[17:40:54.301] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.302] - nx: 1
[17:40:54.302] - relay: TRUE
[17:40:54.302] - stdout: TRUE
[17:40:54.302] - signal: TRUE
[17:40:54.302] - resignal: FALSE
[17:40:54.302] - force: TRUE
[17:40:54.302] - relayed: [n=1] FALSE
[17:40:54.302] - queued futures: [n=1] FALSE
[17:40:54.302]  - until=1
[17:40:54.302]  - relaying element #1
[17:40:54.303] - relayed: [n=1] TRUE
[17:40:54.303] - queued futures: [n=1] TRUE
[17:40:54.303] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.303]  length: 0 (resolved future 1)
[17:40:54.303] Relaying remaining futures
[17:40:54.303] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.303] - nx: 1
[17:40:54.303] - relay: TRUE
[17:40:54.303] - stdout: TRUE
[17:40:54.303] - signal: TRUE
[17:40:54.303] - resignal: FALSE
[17:40:54.304] - force: TRUE
[17:40:54.304] - relayed: [n=1] TRUE
[17:40:54.304] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.304] - relayed: [n=1] TRUE
[17:40:54.304] - queued futures: [n=1] TRUE
[17:40:54.304] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.304] resolve() on list ... DONE
[17:40:54.304]  - Number of value chunks collected: 1
[17:40:54.304] Resolving 1 futures (chunks) ... DONE
[17:40:54.304] Reducing values from 1 chunks ...
[17:40:54.305]  - Number of values collected after concatenation: 11
[17:40:54.305]  - Number of values expected: 11
[17:40:54.305] Reducing values from 1 chunks ... DONE
[17:40:54.305] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:40:54.306] future_lapply() ...
[17:40:54.309] Number of chunks: 1
[17:40:54.309] getGlobalsAndPackagesXApply() ...
[17:40:54.309]  - future.globals: TRUE
[17:40:54.310] getGlobalsAndPackages() ...
[17:40:54.310] Searching for globals...
[17:40:54.313] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:54.313] Searching for globals ... DONE
[17:40:54.313] Resolving globals: FALSE
[17:40:54.314] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:40:54.314] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.315] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.315] - packages: [1] ‘future.apply’
[17:40:54.315] getGlobalsAndPackages() ... DONE
[17:40:54.315]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.315]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.315] Finding globals ... DONE
[17:40:54.315]  - use_args: TRUE
[17:40:54.315]  - Getting '...' globals ...
[17:40:54.316] resolve() on list ...
[17:40:54.316]  recursive: 0
[17:40:54.316]  length: 1
[17:40:54.316]  elements: ‘...’
[17:40:54.316]  length: 0 (resolved future 1)
[17:40:54.316] resolve() on list ... DONE
[17:40:54.316]    - '...' content: [n=0] 
[17:40:54.316] List of 1
[17:40:54.316]  $ ...: list()
[17:40:54.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.316]  - attr(*, "where")=List of 1
[17:40:54.316]   ..$ ...:<environment: 0x564f306fe598> 
[17:40:54.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.316]  - attr(*, "resolved")= logi TRUE
[17:40:54.316]  - attr(*, "total_size")= num NA
[17:40:54.319]  - Getting '...' globals ... DONE
[17:40:54.319] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.319] List of 8
[17:40:54.319]  $ ...future.FUN:function (x, ...)  
[17:40:54.319]  $ x_FUN        :function (x)  
[17:40:54.319]  $ times        : int 1
[17:40:54.319]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.319]  $ stop_if_not  :function (...)  
[17:40:54.319]  $ dim          : NULL
[17:40:54.319]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:54.319]  $ ...          : list()
[17:40:54.319]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.319]  - attr(*, "where")=List of 8
[17:40:54.319]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.319]   ..$ ...          :<environment: 0x564f306fe598> 
[17:40:54.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.319]  - attr(*, "resolved")= logi FALSE
[17:40:54.319]  - attr(*, "total_size")= num 94264
[17:40:54.325] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.325] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.325] Number of futures (= number of chunks): 1
[17:40:54.325] Launching 1 futures (chunks) ...
[17:40:54.325] Chunk #1 of 1 ...
[17:40:54.325]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.325] getGlobalsAndPackages() ...
[17:40:54.325] Searching for globals...
[17:40:54.326] 
[17:40:54.326] Searching for globals ... DONE
[17:40:54.326] - globals: [0] <none>
[17:40:54.326] getGlobalsAndPackages() ... DONE
[17:40:54.326]    + additional globals found: [n=0] 
[17:40:54.326]    + additional namespaces needed: [n=0] 
[17:40:54.326]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.326]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:40:54.326]  - seeds: <none>
[17:40:54.327] getGlobalsAndPackages() ...
[17:40:54.327] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.327] Resolving globals: FALSE
[17:40:54.327] Tweak future expression to call with '...' arguments ...
[17:40:54.327] {
[17:40:54.327]     do.call(function(...) {
[17:40:54.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.327]             on.exit(options(oopts), add = TRUE)
[17:40:54.327]         }
[17:40:54.327]         {
[17:40:54.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.327]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.327]             })
[17:40:54.327]         }
[17:40:54.327]     }, args = future.call.arguments)
[17:40:54.327] }
[17:40:54.327] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.328] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.328] - packages: [1] ‘future.apply’
[17:40:54.328] getGlobalsAndPackages() ... DONE
[17:40:54.330] run() for ‘Future’ ...
[17:40:54.330] - state: ‘created’
[17:40:54.331] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.331] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.331]   - Field: ‘label’
[17:40:54.332]   - Field: ‘local’
[17:40:54.332]   - Field: ‘owner’
[17:40:54.332]   - Field: ‘envir’
[17:40:54.332]   - Field: ‘packages’
[17:40:54.332]   - Field: ‘gc’
[17:40:54.332]   - Field: ‘conditions’
[17:40:54.332]   - Field: ‘expr’
[17:40:54.332]   - Field: ‘uuid’
[17:40:54.332]   - Field: ‘seed’
[17:40:54.332]   - Field: ‘version’
[17:40:54.333]   - Field: ‘result’
[17:40:54.333]   - Field: ‘asynchronous’
[17:40:54.333]   - Field: ‘calls’
[17:40:54.333]   - Field: ‘globals’
[17:40:54.333]   - Field: ‘stdout’
[17:40:54.333]   - Field: ‘earlySignal’
[17:40:54.333]   - Field: ‘lazy’
[17:40:54.333]   - Field: ‘state’
[17:40:54.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.333] - Launch lazy future ...
[17:40:54.334] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.334] Packages needed by future strategies (n = 0): <none>
[17:40:54.334] {
[17:40:54.334]     {
[17:40:54.334]         {
[17:40:54.334]             ...future.startTime <- base::Sys.time()
[17:40:54.334]             {
[17:40:54.334]                 {
[17:40:54.334]                   {
[17:40:54.334]                     {
[17:40:54.334]                       base::local({
[17:40:54.334]                         has_future <- base::requireNamespace("future", 
[17:40:54.334]                           quietly = TRUE)
[17:40:54.334]                         if (has_future) {
[17:40:54.334]                           ns <- base::getNamespace("future")
[17:40:54.334]                           version <- ns[[".package"]][["version"]]
[17:40:54.334]                           if (is.null(version)) 
[17:40:54.334]                             version <- utils::packageVersion("future")
[17:40:54.334]                         }
[17:40:54.334]                         else {
[17:40:54.334]                           version <- NULL
[17:40:54.334]                         }
[17:40:54.334]                         if (!has_future || version < "1.8.0") {
[17:40:54.334]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.334]                             "", base::R.version$version.string), 
[17:40:54.334]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.334]                               "release", "version")], collapse = " "), 
[17:40:54.334]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.334]                             info)
[17:40:54.334]                           info <- base::paste(info, collapse = "; ")
[17:40:54.334]                           if (!has_future) {
[17:40:54.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.334]                               info)
[17:40:54.334]                           }
[17:40:54.334]                           else {
[17:40:54.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.334]                               info, version)
[17:40:54.334]                           }
[17:40:54.334]                           base::stop(msg)
[17:40:54.334]                         }
[17:40:54.334]                       })
[17:40:54.334]                     }
[17:40:54.334]                     base::local({
[17:40:54.334]                       for (pkg in "future.apply") {
[17:40:54.334]                         base::loadNamespace(pkg)
[17:40:54.334]                         base::library(pkg, character.only = TRUE)
[17:40:54.334]                       }
[17:40:54.334]                     })
[17:40:54.334]                   }
[17:40:54.334]                   options(future.plan = NULL)
[17:40:54.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.334]                 }
[17:40:54.334]                 ...future.workdir <- getwd()
[17:40:54.334]             }
[17:40:54.334]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.334]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.334]         }
[17:40:54.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.334]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:40:54.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.334]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.334]             base::names(...future.oldOptions))
[17:40:54.334]     }
[17:40:54.334]     if (FALSE) {
[17:40:54.334]     }
[17:40:54.334]     else {
[17:40:54.334]         if (TRUE) {
[17:40:54.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.334]                 open = "w")
[17:40:54.334]         }
[17:40:54.334]         else {
[17:40:54.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.334]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.334]         }
[17:40:54.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.334]             base::sink(type = "output", split = FALSE)
[17:40:54.334]             base::close(...future.stdout)
[17:40:54.334]         }, add = TRUE)
[17:40:54.334]     }
[17:40:54.334]     ...future.frame <- base::sys.nframe()
[17:40:54.334]     ...future.conditions <- base::list()
[17:40:54.334]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.334]     if (FALSE) {
[17:40:54.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.334]     }
[17:40:54.334]     ...future.result <- base::tryCatch({
[17:40:54.334]         base::withCallingHandlers({
[17:40:54.334]             ...future.value <- base::withVisible(base::local({
[17:40:54.334]                 do.call(function(...) {
[17:40:54.334]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.334]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.334]                     ...future.globals.maxSize)) {
[17:40:54.334]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.334]                     on.exit(options(oopts), add = TRUE)
[17:40:54.334]                   }
[17:40:54.334]                   {
[17:40:54.334]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.334]                       FUN = function(jj) {
[17:40:54.334]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.334]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.334]                       })
[17:40:54.334]                   }
[17:40:54.334]                 }, args = future.call.arguments)
[17:40:54.334]             }))
[17:40:54.334]             future::FutureResult(value = ...future.value$value, 
[17:40:54.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.334]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.334]                     ...future.globalenv.names))
[17:40:54.334]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.334]         }, condition = base::local({
[17:40:54.334]             c <- base::c
[17:40:54.334]             inherits <- base::inherits
[17:40:54.334]             invokeRestart <- base::invokeRestart
[17:40:54.334]             length <- base::length
[17:40:54.334]             list <- base::list
[17:40:54.334]             seq.int <- base::seq.int
[17:40:54.334]             signalCondition <- base::signalCondition
[17:40:54.334]             sys.calls <- base::sys.calls
[17:40:54.334]             `[[` <- base::`[[`
[17:40:54.334]             `+` <- base::`+`
[17:40:54.334]             `<<-` <- base::`<<-`
[17:40:54.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.334]                   3L)]
[17:40:54.334]             }
[17:40:54.334]             function(cond) {
[17:40:54.334]                 is_error <- inherits(cond, "error")
[17:40:54.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.334]                   NULL)
[17:40:54.334]                 if (is_error) {
[17:40:54.334]                   sessionInformation <- function() {
[17:40:54.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.334]                       search = base::search(), system = base::Sys.info())
[17:40:54.334]                   }
[17:40:54.334]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.334]                     cond$call), session = sessionInformation(), 
[17:40:54.334]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.334]                   signalCondition(cond)
[17:40:54.334]                 }
[17:40:54.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.334]                 "immediateCondition"))) {
[17:40:54.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.334]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.334]                   if (TRUE && !signal) {
[17:40:54.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.334]                     {
[17:40:54.334]                       inherits <- base::inherits
[17:40:54.334]                       invokeRestart <- base::invokeRestart
[17:40:54.334]                       is.null <- base::is.null
[17:40:54.334]                       muffled <- FALSE
[17:40:54.334]                       if (inherits(cond, "message")) {
[17:40:54.334]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.334]                         if (muffled) 
[17:40:54.334]                           invokeRestart("muffleMessage")
[17:40:54.334]                       }
[17:40:54.334]                       else if (inherits(cond, "warning")) {
[17:40:54.334]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.334]                         if (muffled) 
[17:40:54.334]                           invokeRestart("muffleWarning")
[17:40:54.334]                       }
[17:40:54.334]                       else if (inherits(cond, "condition")) {
[17:40:54.334]                         if (!is.null(pattern)) {
[17:40:54.334]                           computeRestarts <- base::computeRestarts
[17:40:54.334]                           grepl <- base::grepl
[17:40:54.334]                           restarts <- computeRestarts(cond)
[17:40:54.334]                           for (restart in restarts) {
[17:40:54.334]                             name <- restart$name
[17:40:54.334]                             if (is.null(name)) 
[17:40:54.334]                               next
[17:40:54.334]                             if (!grepl(pattern, name)) 
[17:40:54.334]                               next
[17:40:54.334]                             invokeRestart(restart)
[17:40:54.334]                             muffled <- TRUE
[17:40:54.334]                             break
[17:40:54.334]                           }
[17:40:54.334]                         }
[17:40:54.334]                       }
[17:40:54.334]                       invisible(muffled)
[17:40:54.334]                     }
[17:40:54.334]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.334]                   }
[17:40:54.334]                 }
[17:40:54.334]                 else {
[17:40:54.334]                   if (TRUE) {
[17:40:54.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.334]                     {
[17:40:54.334]                       inherits <- base::inherits
[17:40:54.334]                       invokeRestart <- base::invokeRestart
[17:40:54.334]                       is.null <- base::is.null
[17:40:54.334]                       muffled <- FALSE
[17:40:54.334]                       if (inherits(cond, "message")) {
[17:40:54.334]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.334]                         if (muffled) 
[17:40:54.334]                           invokeRestart("muffleMessage")
[17:40:54.334]                       }
[17:40:54.334]                       else if (inherits(cond, "warning")) {
[17:40:54.334]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.334]                         if (muffled) 
[17:40:54.334]                           invokeRestart("muffleWarning")
[17:40:54.334]                       }
[17:40:54.334]                       else if (inherits(cond, "condition")) {
[17:40:54.334]                         if (!is.null(pattern)) {
[17:40:54.334]                           computeRestarts <- base::computeRestarts
[17:40:54.334]                           grepl <- base::grepl
[17:40:54.334]                           restarts <- computeRestarts(cond)
[17:40:54.334]                           for (restart in restarts) {
[17:40:54.334]                             name <- restart$name
[17:40:54.334]                             if (is.null(name)) 
[17:40:54.334]                               next
[17:40:54.334]                             if (!grepl(pattern, name)) 
[17:40:54.334]                               next
[17:40:54.334]                             invokeRestart(restart)
[17:40:54.334]                             muffled <- TRUE
[17:40:54.334]                             break
[17:40:54.334]                           }
[17:40:54.334]                         }
[17:40:54.334]                       }
[17:40:54.334]                       invisible(muffled)
[17:40:54.334]                     }
[17:40:54.334]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.334]                   }
[17:40:54.334]                 }
[17:40:54.334]             }
[17:40:54.334]         }))
[17:40:54.334]     }, error = function(ex) {
[17:40:54.334]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.334]                 ...future.rng), started = ...future.startTime, 
[17:40:54.334]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.334]             version = "1.8"), class = "FutureResult")
[17:40:54.334]     }, finally = {
[17:40:54.334]         if (!identical(...future.workdir, getwd())) 
[17:40:54.334]             setwd(...future.workdir)
[17:40:54.334]         {
[17:40:54.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.334]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.334]             }
[17:40:54.334]             base::options(...future.oldOptions)
[17:40:54.334]             if (.Platform$OS.type == "windows") {
[17:40:54.334]                 old_names <- names(...future.oldEnvVars)
[17:40:54.334]                 envs <- base::Sys.getenv()
[17:40:54.334]                 names <- names(envs)
[17:40:54.334]                 common <- intersect(names, old_names)
[17:40:54.334]                 added <- setdiff(names, old_names)
[17:40:54.334]                 removed <- setdiff(old_names, names)
[17:40:54.334]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.334]                   envs[common]]
[17:40:54.334]                 NAMES <- toupper(changed)
[17:40:54.334]                 args <- list()
[17:40:54.334]                 for (kk in seq_along(NAMES)) {
[17:40:54.334]                   name <- changed[[kk]]
[17:40:54.334]                   NAME <- NAMES[[kk]]
[17:40:54.334]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.334]                     next
[17:40:54.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.334]                 }
[17:40:54.334]                 NAMES <- toupper(added)
[17:40:54.334]                 for (kk in seq_along(NAMES)) {
[17:40:54.334]                   name <- added[[kk]]
[17:40:54.334]                   NAME <- NAMES[[kk]]
[17:40:54.334]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.334]                     next
[17:40:54.334]                   args[[name]] <- ""
[17:40:54.334]                 }
[17:40:54.334]                 NAMES <- toupper(removed)
[17:40:54.334]                 for (kk in seq_along(NAMES)) {
[17:40:54.334]                   name <- removed[[kk]]
[17:40:54.334]                   NAME <- NAMES[[kk]]
[17:40:54.334]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.334]                     next
[17:40:54.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.334]                 }
[17:40:54.334]                 if (length(args) > 0) 
[17:40:54.334]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.334]             }
[17:40:54.334]             else {
[17:40:54.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.334]             }
[17:40:54.334]             {
[17:40:54.334]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.334]                   0L) {
[17:40:54.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.334]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.334]                   base::options(opts)
[17:40:54.334]                 }
[17:40:54.334]                 {
[17:40:54.334]                   {
[17:40:54.334]                     NULL
[17:40:54.334]                     RNGkind("Mersenne-Twister")
[17:40:54.334]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.334]                       inherits = FALSE)
[17:40:54.334]                   }
[17:40:54.334]                   options(future.plan = NULL)
[17:40:54.334]                   if (is.na(NA_character_)) 
[17:40:54.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.334]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.334]                   {
[17:40:54.334]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.334]                     if (!future$lazy) 
[17:40:54.334]                       future <- run(future)
[17:40:54.334]                     invisible(future)
[17:40:54.334]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.334]                 }
[17:40:54.334]             }
[17:40:54.334]         }
[17:40:54.334]     })
[17:40:54.334]     if (TRUE) {
[17:40:54.334]         base::sink(type = "output", split = FALSE)
[17:40:54.334]         if (TRUE) {
[17:40:54.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.334]         }
[17:40:54.334]         else {
[17:40:54.334]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.334]         }
[17:40:54.334]         base::close(...future.stdout)
[17:40:54.334]         ...future.stdout <- NULL
[17:40:54.334]     }
[17:40:54.334]     ...future.result$conditions <- ...future.conditions
[17:40:54.334]     ...future.result$finished <- base::Sys.time()
[17:40:54.334]     ...future.result
[17:40:54.334] }
[17:40:54.336] assign_globals() ...
[17:40:54.336] List of 11
[17:40:54.336]  $ ...future.FUN            :function (x, ...)  
[17:40:54.336]  $ x_FUN                    :function (x)  
[17:40:54.336]  $ times                    : int 1
[17:40:54.336]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.336]  $ stop_if_not              :function (...)  
[17:40:54.336]  $ dim                      : NULL
[17:40:54.336]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:54.336]  $ future.call.arguments    : list()
[17:40:54.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.336]  $ ...future.elements_ii    :List of 3
[17:40:54.336]   ..$ a: num 1
[17:40:54.336]   ..$ b: num 2
[17:40:54.336]   ..$ c: num 3
[17:40:54.336]  $ ...future.seeds_ii       : NULL
[17:40:54.336]  $ ...future.globals.maxSize: NULL
[17:40:54.336]  - attr(*, "resolved")= logi FALSE
[17:40:54.336]  - attr(*, "total_size")= num 94264
[17:40:54.336]  - attr(*, "where")=List of 11
[17:40:54.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.336]  - attr(*, "already-done")= logi TRUE
[17:40:54.345] - copied ‘...future.FUN’ to environment
[17:40:54.345] - copied ‘x_FUN’ to environment
[17:40:54.345] - copied ‘times’ to environment
[17:40:54.345] - copied ‘stopf’ to environment
[17:40:54.346] - copied ‘stop_if_not’ to environment
[17:40:54.346] - copied ‘dim’ to environment
[17:40:54.346] - copied ‘valid_types’ to environment
[17:40:54.346] - copied ‘future.call.arguments’ to environment
[17:40:54.346] - copied ‘...future.elements_ii’ to environment
[17:40:54.346] - copied ‘...future.seeds_ii’ to environment
[17:40:54.346] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.346] assign_globals() ... done
[17:40:54.347] plan(): Setting new future strategy stack:
[17:40:54.347] List of future strategies:
[17:40:54.347] 1. sequential:
[17:40:54.347]    - args: function (..., envir = parent.frame())
[17:40:54.347]    - tweaked: FALSE
[17:40:54.347]    - call: NULL
[17:40:54.347] plan(): nbrOfWorkers() = 1
[17:40:54.348] plan(): Setting new future strategy stack:
[17:40:54.348] List of future strategies:
[17:40:54.348] 1. sequential:
[17:40:54.348]    - args: function (..., envir = parent.frame())
[17:40:54.348]    - tweaked: FALSE
[17:40:54.348]    - call: plan(strategy)
[17:40:54.348] plan(): nbrOfWorkers() = 1
[17:40:54.349] SequentialFuture started (and completed)
[17:40:54.349] - Launch lazy future ... done
[17:40:54.349] run() for ‘SequentialFuture’ ... done
[17:40:54.349] Created future:
[17:40:54.349] SequentialFuture:
[17:40:54.349] Label: ‘future_vapply-1’
[17:40:54.349] Expression:
[17:40:54.349] {
[17:40:54.349]     do.call(function(...) {
[17:40:54.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.349]             on.exit(options(oopts), add = TRUE)
[17:40:54.349]         }
[17:40:54.349]         {
[17:40:54.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.349]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.349]             })
[17:40:54.349]         }
[17:40:54.349]     }, args = future.call.arguments)
[17:40:54.349] }
[17:40:54.349] Lazy evaluation: FALSE
[17:40:54.349] Asynchronous evaluation: FALSE
[17:40:54.349] Local evaluation: TRUE
[17:40:54.349] Environment: R_GlobalEnv
[17:40:54.349] Capture standard output: TRUE
[17:40:54.349] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.349] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.349] Packages: 1 packages (‘future.apply’)
[17:40:54.349] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.349] Resolved: TRUE
[17:40:54.349] Value: 168 bytes of class ‘list’
[17:40:54.349] Early signaling: FALSE
[17:40:54.349] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.349] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.350] Chunk #1 of 1 ... DONE
[17:40:54.350] Launching 1 futures (chunks) ... DONE
[17:40:54.350] Resolving 1 futures (chunks) ...
[17:40:54.351] resolve() on list ...
[17:40:54.351]  recursive: 0
[17:40:54.351]  length: 1
[17:40:54.351] 
[17:40:54.351] resolved() for ‘SequentialFuture’ ...
[17:40:54.351] - state: ‘finished’
[17:40:54.351] - run: TRUE
[17:40:54.351] - result: ‘FutureResult’
[17:40:54.351] resolved() for ‘SequentialFuture’ ... done
[17:40:54.351] Future #1
[17:40:54.352] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.352] - nx: 1
[17:40:54.352] - relay: TRUE
[17:40:54.352] - stdout: TRUE
[17:40:54.352] - signal: TRUE
[17:40:54.352] - resignal: FALSE
[17:40:54.352] - force: TRUE
[17:40:54.352] - relayed: [n=1] FALSE
[17:40:54.352] - queued futures: [n=1] FALSE
[17:40:54.352]  - until=1
[17:40:54.353]  - relaying element #1
[17:40:54.353] - relayed: [n=1] TRUE
[17:40:54.353] - queued futures: [n=1] TRUE
[17:40:54.355] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.355]  length: 0 (resolved future 1)
[17:40:54.355] Relaying remaining futures
[17:40:54.355] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.355] - nx: 1
[17:40:54.355] - relay: TRUE
[17:40:54.356] - stdout: TRUE
[17:40:54.356] - signal: TRUE
[17:40:54.356] - resignal: FALSE
[17:40:54.356] - force: TRUE
[17:40:54.356] - relayed: [n=1] TRUE
[17:40:54.356] - queued futures: [n=1] TRUE
 - flush all
[17:40:54.356] - relayed: [n=1] TRUE
[17:40:54.356] - queued futures: [n=1] TRUE
[17:40:54.356] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.356] resolve() on list ... DONE
[17:40:54.357]  - Number of value chunks collected: 1
[17:40:54.357] Resolving 1 futures (chunks) ... DONE
[17:40:54.357] Reducing values from 1 chunks ...
[17:40:54.357]  - Number of values collected after concatenation: 3
[17:40:54.357]  - Number of values expected: 3
[17:40:54.357] Reducing values from 1 chunks ... DONE
[17:40:54.357] future_lapply() ... DONE
- exceptions ...
[17:40:54.357] future_lapply() ...
[17:40:54.359] Number of chunks: 1
[17:40:54.359] getGlobalsAndPackagesXApply() ...
[17:40:54.360]  - future.globals: TRUE
[17:40:54.360] getGlobalsAndPackages() ...
[17:40:54.360] Searching for globals...
[17:40:54.363] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:54.363] Searching for globals ... DONE
[17:40:54.363] Resolving globals: FALSE
[17:40:54.364] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:40:54.365] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.365] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.365] - packages: [1] ‘future.apply’
[17:40:54.365] getGlobalsAndPackages() ... DONE
[17:40:54.365]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.365]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.365] Finding globals ... DONE
[17:40:54.365]  - use_args: TRUE
[17:40:54.365]  - Getting '...' globals ...
[17:40:54.366] resolve() on list ...
[17:40:54.366]  recursive: 0
[17:40:54.366]  length: 1
[17:40:54.366]  elements: ‘...’
[17:40:54.366]  length: 0 (resolved future 1)
[17:40:54.366] resolve() on list ... DONE
[17:40:54.366]    - '...' content: [n=0] 
[17:40:54.366] List of 1
[17:40:54.366]  $ ...: list()
[17:40:54.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.366]  - attr(*, "where")=List of 1
[17:40:54.366]   ..$ ...:<environment: 0x564f2eef2220> 
[17:40:54.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.366]  - attr(*, "resolved")= logi TRUE
[17:40:54.366]  - attr(*, "total_size")= num NA
[17:40:54.369]  - Getting '...' globals ... DONE
[17:40:54.369] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.369] List of 8
[17:40:54.369]  $ ...future.FUN:function (x, ...)  
[17:40:54.369]  $ x_FUN        :function (x)  
[17:40:54.369]  $ times        : int 2
[17:40:54.369]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.369]  $ stop_if_not  :function (...)  
[17:40:54.369]  $ dim          : NULL
[17:40:54.369]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:54.369]  $ ...          : list()
[17:40:54.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.369]  - attr(*, "where")=List of 8
[17:40:54.369]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.369]   ..$ ...          :<environment: 0x564f2eef2220> 
[17:40:54.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.369]  - attr(*, "resolved")= logi FALSE
[17:40:54.369]  - attr(*, "total_size")= num 95128
[17:40:54.376] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.376] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.376] Number of futures (= number of chunks): 1
[17:40:54.376] Launching 1 futures (chunks) ...
[17:40:54.377] Chunk #1 of 1 ...
[17:40:54.377]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.377] getGlobalsAndPackages() ...
[17:40:54.377] Searching for globals...
[17:40:54.377] 
[17:40:54.377] Searching for globals ... DONE
[17:40:54.377] - globals: [0] <none>
[17:40:54.377] getGlobalsAndPackages() ... DONE
[17:40:54.377]    + additional globals found: [n=0] 
[17:40:54.378]    + additional namespaces needed: [n=0] 
[17:40:54.378]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.378]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:40:54.378]  - seeds: <none>
[17:40:54.378] getGlobalsAndPackages() ...
[17:40:54.378] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.378] Resolving globals: FALSE
[17:40:54.378] Tweak future expression to call with '...' arguments ...
[17:40:54.378] {
[17:40:54.378]     do.call(function(...) {
[17:40:54.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.378]             on.exit(options(oopts), add = TRUE)
[17:40:54.378]         }
[17:40:54.378]         {
[17:40:54.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.378]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.378]             })
[17:40:54.378]         }
[17:40:54.378]     }, args = future.call.arguments)
[17:40:54.378] }
[17:40:54.379] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.379] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.379] - packages: [1] ‘future.apply’
[17:40:54.379] getGlobalsAndPackages() ... DONE
[17:40:54.380] run() for ‘Future’ ...
[17:40:54.380] - state: ‘created’
[17:40:54.380] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:54.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:54.380]   - Field: ‘label’
[17:40:54.381]   - Field: ‘local’
[17:40:54.381]   - Field: ‘owner’
[17:40:54.381]   - Field: ‘envir’
[17:40:54.381]   - Field: ‘packages’
[17:40:54.381]   - Field: ‘gc’
[17:40:54.381]   - Field: ‘conditions’
[17:40:54.381]   - Field: ‘expr’
[17:40:54.381]   - Field: ‘uuid’
[17:40:54.381]   - Field: ‘seed’
[17:40:54.381]   - Field: ‘version’
[17:40:54.381]   - Field: ‘result’
[17:40:54.382]   - Field: ‘asynchronous’
[17:40:54.382]   - Field: ‘calls’
[17:40:54.382]   - Field: ‘globals’
[17:40:54.382]   - Field: ‘stdout’
[17:40:54.382]   - Field: ‘earlySignal’
[17:40:54.382]   - Field: ‘lazy’
[17:40:54.382]   - Field: ‘state’
[17:40:54.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:54.382] - Launch lazy future ...
[17:40:54.382] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.383] Packages needed by future strategies (n = 0): <none>
[17:40:54.383] {
[17:40:54.383]     {
[17:40:54.383]         {
[17:40:54.383]             ...future.startTime <- base::Sys.time()
[17:40:54.383]             {
[17:40:54.383]                 {
[17:40:54.383]                   {
[17:40:54.383]                     {
[17:40:54.383]                       base::local({
[17:40:54.383]                         has_future <- base::requireNamespace("future", 
[17:40:54.383]                           quietly = TRUE)
[17:40:54.383]                         if (has_future) {
[17:40:54.383]                           ns <- base::getNamespace("future")
[17:40:54.383]                           version <- ns[[".package"]][["version"]]
[17:40:54.383]                           if (is.null(version)) 
[17:40:54.383]                             version <- utils::packageVersion("future")
[17:40:54.383]                         }
[17:40:54.383]                         else {
[17:40:54.383]                           version <- NULL
[17:40:54.383]                         }
[17:40:54.383]                         if (!has_future || version < "1.8.0") {
[17:40:54.383]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.383]                             "", base::R.version$version.string), 
[17:40:54.383]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.383]                               "release", "version")], collapse = " "), 
[17:40:54.383]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.383]                             info)
[17:40:54.383]                           info <- base::paste(info, collapse = "; ")
[17:40:54.383]                           if (!has_future) {
[17:40:54.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.383]                               info)
[17:40:54.383]                           }
[17:40:54.383]                           else {
[17:40:54.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.383]                               info, version)
[17:40:54.383]                           }
[17:40:54.383]                           base::stop(msg)
[17:40:54.383]                         }
[17:40:54.383]                       })
[17:40:54.383]                     }
[17:40:54.383]                     base::local({
[17:40:54.383]                       for (pkg in "future.apply") {
[17:40:54.383]                         base::loadNamespace(pkg)
[17:40:54.383]                         base::library(pkg, character.only = TRUE)
[17:40:54.383]                       }
[17:40:54.383]                     })
[17:40:54.383]                   }
[17:40:54.383]                   options(future.plan = NULL)
[17:40:54.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.383]                 }
[17:40:54.383]                 ...future.workdir <- getwd()
[17:40:54.383]             }
[17:40:54.383]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.383]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.383]         }
[17:40:54.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.383]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:40:54.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.383]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.383]             base::names(...future.oldOptions))
[17:40:54.383]     }
[17:40:54.383]     if (FALSE) {
[17:40:54.383]     }
[17:40:54.383]     else {
[17:40:54.383]         if (TRUE) {
[17:40:54.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.383]                 open = "w")
[17:40:54.383]         }
[17:40:54.383]         else {
[17:40:54.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.383]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.383]         }
[17:40:54.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.383]             base::sink(type = "output", split = FALSE)
[17:40:54.383]             base::close(...future.stdout)
[17:40:54.383]         }, add = TRUE)
[17:40:54.383]     }
[17:40:54.383]     ...future.frame <- base::sys.nframe()
[17:40:54.383]     ...future.conditions <- base::list()
[17:40:54.383]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.383]     if (FALSE) {
[17:40:54.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.383]     }
[17:40:54.383]     ...future.result <- base::tryCatch({
[17:40:54.383]         base::withCallingHandlers({
[17:40:54.383]             ...future.value <- base::withVisible(base::local({
[17:40:54.383]                 do.call(function(...) {
[17:40:54.383]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.383]                   if (!identical(...future.globals.maxSize.org, 
[17:40:54.383]                     ...future.globals.maxSize)) {
[17:40:54.383]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.383]                     on.exit(options(oopts), add = TRUE)
[17:40:54.383]                   }
[17:40:54.383]                   {
[17:40:54.383]                     lapply(seq_along(...future.elements_ii), 
[17:40:54.383]                       FUN = function(jj) {
[17:40:54.383]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.383]                         ...future.FUN(...future.X_jj, ...)
[17:40:54.383]                       })
[17:40:54.383]                   }
[17:40:54.383]                 }, args = future.call.arguments)
[17:40:54.383]             }))
[17:40:54.383]             future::FutureResult(value = ...future.value$value, 
[17:40:54.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.383]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.383]                     ...future.globalenv.names))
[17:40:54.383]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.383]         }, condition = base::local({
[17:40:54.383]             c <- base::c
[17:40:54.383]             inherits <- base::inherits
[17:40:54.383]             invokeRestart <- base::invokeRestart
[17:40:54.383]             length <- base::length
[17:40:54.383]             list <- base::list
[17:40:54.383]             seq.int <- base::seq.int
[17:40:54.383]             signalCondition <- base::signalCondition
[17:40:54.383]             sys.calls <- base::sys.calls
[17:40:54.383]             `[[` <- base::`[[`
[17:40:54.383]             `+` <- base::`+`
[17:40:54.383]             `<<-` <- base::`<<-`
[17:40:54.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.383]                   3L)]
[17:40:54.383]             }
[17:40:54.383]             function(cond) {
[17:40:54.383]                 is_error <- inherits(cond, "error")
[17:40:54.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.383]                   NULL)
[17:40:54.383]                 if (is_error) {
[17:40:54.383]                   sessionInformation <- function() {
[17:40:54.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.383]                       search = base::search(), system = base::Sys.info())
[17:40:54.383]                   }
[17:40:54.383]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.383]                     cond$call), session = sessionInformation(), 
[17:40:54.383]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.383]                   signalCondition(cond)
[17:40:54.383]                 }
[17:40:54.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.383]                 "immediateCondition"))) {
[17:40:54.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.383]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.383]                   if (TRUE && !signal) {
[17:40:54.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.383]                     {
[17:40:54.383]                       inherits <- base::inherits
[17:40:54.383]                       invokeRestart <- base::invokeRestart
[17:40:54.383]                       is.null <- base::is.null
[17:40:54.383]                       muffled <- FALSE
[17:40:54.383]                       if (inherits(cond, "message")) {
[17:40:54.383]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.383]                         if (muffled) 
[17:40:54.383]                           invokeRestart("muffleMessage")
[17:40:54.383]                       }
[17:40:54.383]                       else if (inherits(cond, "warning")) {
[17:40:54.383]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.383]                         if (muffled) 
[17:40:54.383]                           invokeRestart("muffleWarning")
[17:40:54.383]                       }
[17:40:54.383]                       else if (inherits(cond, "condition")) {
[17:40:54.383]                         if (!is.null(pattern)) {
[17:40:54.383]                           computeRestarts <- base::computeRestarts
[17:40:54.383]                           grepl <- base::grepl
[17:40:54.383]                           restarts <- computeRestarts(cond)
[17:40:54.383]                           for (restart in restarts) {
[17:40:54.383]                             name <- restart$name
[17:40:54.383]                             if (is.null(name)) 
[17:40:54.383]                               next
[17:40:54.383]                             if (!grepl(pattern, name)) 
[17:40:54.383]                               next
[17:40:54.383]                             invokeRestart(restart)
[17:40:54.383]                             muffled <- TRUE
[17:40:54.383]                             break
[17:40:54.383]                           }
[17:40:54.383]                         }
[17:40:54.383]                       }
[17:40:54.383]                       invisible(muffled)
[17:40:54.383]                     }
[17:40:54.383]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.383]                   }
[17:40:54.383]                 }
[17:40:54.383]                 else {
[17:40:54.383]                   if (TRUE) {
[17:40:54.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.383]                     {
[17:40:54.383]                       inherits <- base::inherits
[17:40:54.383]                       invokeRestart <- base::invokeRestart
[17:40:54.383]                       is.null <- base::is.null
[17:40:54.383]                       muffled <- FALSE
[17:40:54.383]                       if (inherits(cond, "message")) {
[17:40:54.383]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.383]                         if (muffled) 
[17:40:54.383]                           invokeRestart("muffleMessage")
[17:40:54.383]                       }
[17:40:54.383]                       else if (inherits(cond, "warning")) {
[17:40:54.383]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.383]                         if (muffled) 
[17:40:54.383]                           invokeRestart("muffleWarning")
[17:40:54.383]                       }
[17:40:54.383]                       else if (inherits(cond, "condition")) {
[17:40:54.383]                         if (!is.null(pattern)) {
[17:40:54.383]                           computeRestarts <- base::computeRestarts
[17:40:54.383]                           grepl <- base::grepl
[17:40:54.383]                           restarts <- computeRestarts(cond)
[17:40:54.383]                           for (restart in restarts) {
[17:40:54.383]                             name <- restart$name
[17:40:54.383]                             if (is.null(name)) 
[17:40:54.383]                               next
[17:40:54.383]                             if (!grepl(pattern, name)) 
[17:40:54.383]                               next
[17:40:54.383]                             invokeRestart(restart)
[17:40:54.383]                             muffled <- TRUE
[17:40:54.383]                             break
[17:40:54.383]                           }
[17:40:54.383]                         }
[17:40:54.383]                       }
[17:40:54.383]                       invisible(muffled)
[17:40:54.383]                     }
[17:40:54.383]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.383]                   }
[17:40:54.383]                 }
[17:40:54.383]             }
[17:40:54.383]         }))
[17:40:54.383]     }, error = function(ex) {
[17:40:54.383]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.383]                 ...future.rng), started = ...future.startTime, 
[17:40:54.383]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.383]             version = "1.8"), class = "FutureResult")
[17:40:54.383]     }, finally = {
[17:40:54.383]         if (!identical(...future.workdir, getwd())) 
[17:40:54.383]             setwd(...future.workdir)
[17:40:54.383]         {
[17:40:54.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.383]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.383]             }
[17:40:54.383]             base::options(...future.oldOptions)
[17:40:54.383]             if (.Platform$OS.type == "windows") {
[17:40:54.383]                 old_names <- names(...future.oldEnvVars)
[17:40:54.383]                 envs <- base::Sys.getenv()
[17:40:54.383]                 names <- names(envs)
[17:40:54.383]                 common <- intersect(names, old_names)
[17:40:54.383]                 added <- setdiff(names, old_names)
[17:40:54.383]                 removed <- setdiff(old_names, names)
[17:40:54.383]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.383]                   envs[common]]
[17:40:54.383]                 NAMES <- toupper(changed)
[17:40:54.383]                 args <- list()
[17:40:54.383]                 for (kk in seq_along(NAMES)) {
[17:40:54.383]                   name <- changed[[kk]]
[17:40:54.383]                   NAME <- NAMES[[kk]]
[17:40:54.383]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.383]                     next
[17:40:54.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.383]                 }
[17:40:54.383]                 NAMES <- toupper(added)
[17:40:54.383]                 for (kk in seq_along(NAMES)) {
[17:40:54.383]                   name <- added[[kk]]
[17:40:54.383]                   NAME <- NAMES[[kk]]
[17:40:54.383]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.383]                     next
[17:40:54.383]                   args[[name]] <- ""
[17:40:54.383]                 }
[17:40:54.383]                 NAMES <- toupper(removed)
[17:40:54.383]                 for (kk in seq_along(NAMES)) {
[17:40:54.383]                   name <- removed[[kk]]
[17:40:54.383]                   NAME <- NAMES[[kk]]
[17:40:54.383]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.383]                     next
[17:40:54.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.383]                 }
[17:40:54.383]                 if (length(args) > 0) 
[17:40:54.383]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.383]             }
[17:40:54.383]             else {
[17:40:54.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.383]             }
[17:40:54.383]             {
[17:40:54.383]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.383]                   0L) {
[17:40:54.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.383]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.383]                   base::options(opts)
[17:40:54.383]                 }
[17:40:54.383]                 {
[17:40:54.383]                   {
[17:40:54.383]                     NULL
[17:40:54.383]                     RNGkind("Mersenne-Twister")
[17:40:54.383]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:54.383]                       inherits = FALSE)
[17:40:54.383]                   }
[17:40:54.383]                   options(future.plan = NULL)
[17:40:54.383]                   if (is.na(NA_character_)) 
[17:40:54.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.383]                   future::plan(list(function (..., envir = parent.frame()) 
[17:40:54.383]                   {
[17:40:54.383]                     future <- SequentialFuture(..., envir = envir)
[17:40:54.383]                     if (!future$lazy) 
[17:40:54.383]                       future <- run(future)
[17:40:54.383]                     invisible(future)
[17:40:54.383]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.383]                 }
[17:40:54.383]             }
[17:40:54.383]         }
[17:40:54.383]     })
[17:40:54.383]     if (TRUE) {
[17:40:54.383]         base::sink(type = "output", split = FALSE)
[17:40:54.383]         if (TRUE) {
[17:40:54.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.383]         }
[17:40:54.383]         else {
[17:40:54.383]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.383]         }
[17:40:54.383]         base::close(...future.stdout)
[17:40:54.383]         ...future.stdout <- NULL
[17:40:54.383]     }
[17:40:54.383]     ...future.result$conditions <- ...future.conditions
[17:40:54.383]     ...future.result$finished <- base::Sys.time()
[17:40:54.383]     ...future.result
[17:40:54.383] }
[17:40:54.385] assign_globals() ...
[17:40:54.385] List of 11
[17:40:54.385]  $ ...future.FUN            :function (x, ...)  
[17:40:54.385]  $ x_FUN                    :function (x)  
[17:40:54.385]  $ times                    : int 2
[17:40:54.385]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.385]  $ stop_if_not              :function (...)  
[17:40:54.385]  $ dim                      : NULL
[17:40:54.385]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.385]  $ future.call.arguments    : list()
[17:40:54.385]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.385]  $ ...future.elements_ii    :List of 3
[17:40:54.385]   ..$ : int 1
[17:40:54.385]   ..$ : int 2
[17:40:54.385]   ..$ : int 3
[17:40:54.385]  $ ...future.seeds_ii       : NULL
[17:40:54.385]  $ ...future.globals.maxSize: NULL
[17:40:54.385]  - attr(*, "resolved")= logi FALSE
[17:40:54.385]  - attr(*, "total_size")= num 95128
[17:40:54.385]  - attr(*, "where")=List of 11
[17:40:54.385]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.385]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.385]  - attr(*, "already-done")= logi TRUE
[17:40:54.393] - copied ‘...future.FUN’ to environment
[17:40:54.393] - copied ‘x_FUN’ to environment
[17:40:54.393] - copied ‘times’ to environment
[17:40:54.393] - copied ‘stopf’ to environment
[17:40:54.393] - copied ‘stop_if_not’ to environment
[17:40:54.393] - copied ‘dim’ to environment
[17:40:54.393] - copied ‘valid_types’ to environment
[17:40:54.393] - copied ‘future.call.arguments’ to environment
[17:40:54.393] - copied ‘...future.elements_ii’ to environment
[17:40:54.393] - copied ‘...future.seeds_ii’ to environment
[17:40:54.393] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.394] assign_globals() ... done
[17:40:54.394] plan(): Setting new future strategy stack:
[17:40:54.394] List of future strategies:
[17:40:54.394] 1. sequential:
[17:40:54.394]    - args: function (..., envir = parent.frame())
[17:40:54.394]    - tweaked: FALSE
[17:40:54.394]    - call: NULL
[17:40:54.394] plan(): nbrOfWorkers() = 1
[17:40:54.397] plan(): Setting new future strategy stack:
[17:40:54.397] List of future strategies:
[17:40:54.397] 1. sequential:
[17:40:54.397]    - args: function (..., envir = parent.frame())
[17:40:54.397]    - tweaked: FALSE
[17:40:54.397]    - call: plan(strategy)
[17:40:54.397] plan(): nbrOfWorkers() = 1
[17:40:54.397] SequentialFuture started (and completed)
[17:40:54.398] signalConditions() ...
[17:40:54.398]  - include = ‘immediateCondition’
[17:40:54.398]  - exclude = 
[17:40:54.398]  - resignal = FALSE
[17:40:54.398]  - Number of conditions: 1
[17:40:54.398] signalConditions() ... done
[17:40:54.398] - Launch lazy future ... done
[17:40:54.398] run() for ‘SequentialFuture’ ... done
[17:40:54.398] Created future:
[17:40:54.398] SequentialFuture:
[17:40:54.398] Label: ‘future_vapply-1’
[17:40:54.398] Expression:
[17:40:54.398] {
[17:40:54.398]     do.call(function(...) {
[17:40:54.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.398]             on.exit(options(oopts), add = TRUE)
[17:40:54.398]         }
[17:40:54.398]         {
[17:40:54.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.398]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.398]             })
[17:40:54.398]         }
[17:40:54.398]     }, args = future.call.arguments)
[17:40:54.398] }
[17:40:54.398] Lazy evaluation: FALSE
[17:40:54.398] Asynchronous evaluation: FALSE
[17:40:54.398] Local evaluation: TRUE
[17:40:54.398] Environment: R_GlobalEnv
[17:40:54.398] Capture standard output: TRUE
[17:40:54.398] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.398] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.398] Packages: 1 packages (‘future.apply’)
[17:40:54.398] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.398] Resolved: TRUE
[17:40:54.398] Value: 0 bytes of class ‘NULL’
[17:40:54.398] Conditions captured: [n=1] ‘simpleError’
[17:40:54.398] Early signaling: FALSE
[17:40:54.398] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.398] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:54.400] Chunk #1 of 1 ... DONE
[17:40:54.400] Launching 1 futures (chunks) ... DONE
[17:40:54.400] Resolving 1 futures (chunks) ...
[17:40:54.400] resolve() on list ...
[17:40:54.400]  recursive: 0
[17:40:54.400]  length: 1
[17:40:54.400] 
[17:40:54.400] resolved() for ‘SequentialFuture’ ...
[17:40:54.400] - state: ‘finished’
[17:40:54.400] - run: TRUE
[17:40:54.401] - result: ‘FutureResult’
[17:40:54.401] resolved() for ‘SequentialFuture’ ... done
[17:40:54.401] Future #1
[17:40:54.401] signalConditions() ...
[17:40:54.401]  - include = ‘immediateCondition’
[17:40:54.401]  - exclude = 
[17:40:54.401]  - resignal = FALSE
[17:40:54.401]  - Number of conditions: 1
[17:40:54.401] signalConditions() ... done
[17:40:54.401] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:40:54.402] - nx: 1
[17:40:54.402] - relay: TRUE
[17:40:54.402] - stdout: TRUE
[17:40:54.402] - signal: TRUE
[17:40:54.402] - resignal: FALSE
[17:40:54.402] - force: TRUE
[17:40:54.402] - relayed: [n=1] FALSE
[17:40:54.402] - queued futures: [n=1] FALSE
[17:40:54.402]  - until=1
[17:40:54.402]  - relaying element #1
[17:40:54.402] signalConditions() ...
[17:40:54.403]  - include = ‘immediateCondition’
[17:40:54.403]  - exclude = 
[17:40:54.403]  - resignal = FALSE
[17:40:54.403]  - Number of conditions: 1
[17:40:54.403] signalConditions() ... done
[17:40:54.403] signalConditions() ...
[17:40:54.403]  - include = ‘immediateCondition’
[17:40:54.403]  - exclude = 
[17:40:54.403]  - resignal = FALSE
[17:40:54.403]  - Number of conditions: 1
[17:40:54.403] signalConditions() ... done
[17:40:54.404] signalConditions() ...
[17:40:54.404]  - include = ‘condition’
[17:40:54.404]  - exclude = ‘immediateCondition’
[17:40:54.404]  - resignal = TRUE
[17:40:54.404]  - Number of conditions: 1
[17:40:54.404]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:40:54.404] signalConditions() ... done
[17:40:54.405] - relayed: [n=1] FALSE
[17:40:54.405] - queued futures: [n=1] TRUE
[17:40:54.405] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:40:54.405] plan(): Setting new future strategy stack:
[17:40:54.405] List of future strategies:
[17:40:54.405] 1. sequential:
[17:40:54.405]    - args: function (..., envir = parent.frame())
[17:40:54.405]    - tweaked: FALSE
[17:40:54.405]    - call: plan(sequential)
[17:40:54.406] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:40:54.406] plan(): Setting new future strategy stack:
[17:40:54.406] List of future strategies:
[17:40:54.406] 1. multicore:
[17:40:54.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.406]    - tweaked: FALSE
[17:40:54.406]    - call: plan(strategy)
[17:40:54.410] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:40:54.413] future_lapply() ...
[17:40:54.418] Number of chunks: 2
[17:40:54.418] getGlobalsAndPackagesXApply() ...
[17:40:54.418]  - future.globals: TRUE
[17:40:54.418] getGlobalsAndPackages() ...
[17:40:54.418] Searching for globals...
[17:40:54.425] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:54.425] Searching for globals ... DONE
[17:40:54.425] Resolving globals: FALSE
[17:40:54.426] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:40:54.426] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.426] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.427] - packages: [1] ‘future.apply’
[17:40:54.427] getGlobalsAndPackages() ... DONE
[17:40:54.427]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.427]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.427] Finding globals ... DONE
[17:40:54.427]  - use_args: TRUE
[17:40:54.427]  - Getting '...' globals ...
[17:40:54.428] resolve() on list ...
[17:40:54.428]  recursive: 0
[17:40:54.428]  length: 1
[17:40:54.428]  elements: ‘...’
[17:40:54.428]  length: 0 (resolved future 1)
[17:40:54.428] resolve() on list ... DONE
[17:40:54.428]    - '...' content: [n=0] 
[17:40:54.428] List of 1
[17:40:54.428]  $ ...: list()
[17:40:54.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.428]  - attr(*, "where")=List of 1
[17:40:54.428]   ..$ ...:<environment: 0x564f300714d8> 
[17:40:54.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.428]  - attr(*, "resolved")= logi TRUE
[17:40:54.428]  - attr(*, "total_size")= num NA
[17:40:54.431]  - Getting '...' globals ... DONE
[17:40:54.431] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.431] List of 8
[17:40:54.431]  $ ...future.FUN:function (x, ...)  
[17:40:54.431]  $ x_FUN        :function (x)  
[17:40:54.431]  $ times        : int 1
[17:40:54.431]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.431]  $ stop_if_not  :function (...)  
[17:40:54.431]  $ dim          : NULL
[17:40:54.431]  $ valid_types  : chr "character"
[17:40:54.431]  $ ...          : list()
[17:40:54.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.431]  - attr(*, "where")=List of 8
[17:40:54.431]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.431]   ..$ ...          :<environment: 0x564f300714d8> 
[17:40:54.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.431]  - attr(*, "resolved")= logi FALSE
[17:40:54.431]  - attr(*, "total_size")= num 94208
[17:40:54.437] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.437] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.437] Number of futures (= number of chunks): 2
[17:40:54.437] Launching 2 futures (chunks) ...
[17:40:54.438] Chunk #1 of 2 ...
[17:40:54.438]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.438] getGlobalsAndPackages() ...
[17:40:54.438] Searching for globals...
[17:40:54.438] 
[17:40:54.438] Searching for globals ... DONE
[17:40:54.438] - globals: [0] <none>
[17:40:54.438] getGlobalsAndPackages() ... DONE
[17:40:54.439]    + additional globals found: [n=0] 
[17:40:54.439]    + additional namespaces needed: [n=0] 
[17:40:54.439]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.439]  - seeds: <none>
[17:40:54.439] getGlobalsAndPackages() ...
[17:40:54.439] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.439] Resolving globals: FALSE
[17:40:54.439] Tweak future expression to call with '...' arguments ...
[17:40:54.439] {
[17:40:54.439]     do.call(function(...) {
[17:40:54.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.439]             on.exit(options(oopts), add = TRUE)
[17:40:54.439]         }
[17:40:54.439]         {
[17:40:54.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.439]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.439]             })
[17:40:54.439]         }
[17:40:54.439]     }, args = future.call.arguments)
[17:40:54.439] }
[17:40:54.440] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.440] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.440] - packages: [1] ‘future.apply’
[17:40:54.440] getGlobalsAndPackages() ... DONE
[17:40:54.441] run() for ‘Future’ ...
[17:40:54.441] - state: ‘created’
[17:40:54.441] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.445] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.445] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.445]   - Field: ‘label’
[17:40:54.445]   - Field: ‘local’
[17:40:54.445]   - Field: ‘owner’
[17:40:54.445]   - Field: ‘envir’
[17:40:54.446]   - Field: ‘workers’
[17:40:54.446]   - Field: ‘packages’
[17:40:54.446]   - Field: ‘gc’
[17:40:54.446]   - Field: ‘job’
[17:40:54.446]   - Field: ‘conditions’
[17:40:54.446]   - Field: ‘expr’
[17:40:54.446]   - Field: ‘uuid’
[17:40:54.446]   - Field: ‘seed’
[17:40:54.446]   - Field: ‘version’
[17:40:54.446]   - Field: ‘result’
[17:40:54.447]   - Field: ‘asynchronous’
[17:40:54.447]   - Field: ‘calls’
[17:40:54.447]   - Field: ‘globals’
[17:40:54.447]   - Field: ‘stdout’
[17:40:54.447]   - Field: ‘earlySignal’
[17:40:54.447]   - Field: ‘lazy’
[17:40:54.447]   - Field: ‘state’
[17:40:54.447] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.447] - Launch lazy future ...
[17:40:54.448] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.449] Packages needed by future strategies (n = 0): <none>
[17:40:54.449] {
[17:40:54.449]     {
[17:40:54.449]         {
[17:40:54.449]             ...future.startTime <- base::Sys.time()
[17:40:54.449]             {
[17:40:54.449]                 {
[17:40:54.449]                   {
[17:40:54.449]                     {
[17:40:54.449]                       {
[17:40:54.449]                         base::local({
[17:40:54.449]                           has_future <- base::requireNamespace("future", 
[17:40:54.449]                             quietly = TRUE)
[17:40:54.449]                           if (has_future) {
[17:40:54.449]                             ns <- base::getNamespace("future")
[17:40:54.449]                             version <- ns[[".package"]][["version"]]
[17:40:54.449]                             if (is.null(version)) 
[17:40:54.449]                               version <- utils::packageVersion("future")
[17:40:54.449]                           }
[17:40:54.449]                           else {
[17:40:54.449]                             version <- NULL
[17:40:54.449]                           }
[17:40:54.449]                           if (!has_future || version < "1.8.0") {
[17:40:54.449]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.449]                               "", base::R.version$version.string), 
[17:40:54.449]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.449]                                 base::R.version$platform, 8 * 
[17:40:54.449]                                   base::.Machine$sizeof.pointer), 
[17:40:54.449]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.449]                                 "release", "version")], collapse = " "), 
[17:40:54.449]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.449]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.449]                               info)
[17:40:54.449]                             info <- base::paste(info, collapse = "; ")
[17:40:54.449]                             if (!has_future) {
[17:40:54.449]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.449]                                 info)
[17:40:54.449]                             }
[17:40:54.449]                             else {
[17:40:54.449]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.449]                                 info, version)
[17:40:54.449]                             }
[17:40:54.449]                             base::stop(msg)
[17:40:54.449]                           }
[17:40:54.449]                         })
[17:40:54.449]                       }
[17:40:54.449]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.449]                       base::options(mc.cores = 1L)
[17:40:54.449]                     }
[17:40:54.449]                     base::local({
[17:40:54.449]                       for (pkg in "future.apply") {
[17:40:54.449]                         base::loadNamespace(pkg)
[17:40:54.449]                         base::library(pkg, character.only = TRUE)
[17:40:54.449]                       }
[17:40:54.449]                     })
[17:40:54.449]                   }
[17:40:54.449]                   options(future.plan = NULL)
[17:40:54.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.449]                 }
[17:40:54.449]                 ...future.workdir <- getwd()
[17:40:54.449]             }
[17:40:54.449]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.449]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.449]         }
[17:40:54.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.449]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.449]             base::names(...future.oldOptions))
[17:40:54.449]     }
[17:40:54.449]     if (FALSE) {
[17:40:54.449]     }
[17:40:54.449]     else {
[17:40:54.449]         if (TRUE) {
[17:40:54.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.449]                 open = "w")
[17:40:54.449]         }
[17:40:54.449]         else {
[17:40:54.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.449]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.449]         }
[17:40:54.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.449]             base::sink(type = "output", split = FALSE)
[17:40:54.449]             base::close(...future.stdout)
[17:40:54.449]         }, add = TRUE)
[17:40:54.449]     }
[17:40:54.449]     ...future.frame <- base::sys.nframe()
[17:40:54.449]     ...future.conditions <- base::list()
[17:40:54.449]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.449]     if (FALSE) {
[17:40:54.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.449]     }
[17:40:54.449]     ...future.result <- base::tryCatch({
[17:40:54.449]         base::withCallingHandlers({
[17:40:54.449]             ...future.value <- base::withVisible(base::local({
[17:40:54.449]                 withCallingHandlers({
[17:40:54.449]                   {
[17:40:54.449]                     do.call(function(...) {
[17:40:54.449]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.449]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.449]                         ...future.globals.maxSize)) {
[17:40:54.449]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.449]                         on.exit(options(oopts), add = TRUE)
[17:40:54.449]                       }
[17:40:54.449]                       {
[17:40:54.449]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.449]                           FUN = function(jj) {
[17:40:54.449]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.449]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.449]                           })
[17:40:54.449]                       }
[17:40:54.449]                     }, args = future.call.arguments)
[17:40:54.449]                   }
[17:40:54.449]                 }, immediateCondition = function(cond) {
[17:40:54.449]                   save_rds <- function (object, pathname, ...) 
[17:40:54.449]                   {
[17:40:54.449]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.449]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.449]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.449]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.449]                         fi_tmp[["mtime"]])
[17:40:54.449]                     }
[17:40:54.449]                     tryCatch({
[17:40:54.449]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.449]                     }, error = function(ex) {
[17:40:54.449]                       msg <- conditionMessage(ex)
[17:40:54.449]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.449]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.449]                         fi_tmp[["mtime"]], msg)
[17:40:54.449]                       ex$message <- msg
[17:40:54.449]                       stop(ex)
[17:40:54.449]                     })
[17:40:54.449]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.449]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.449]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.449]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.449]                       fi <- file.info(pathname)
[17:40:54.449]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.449]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.449]                         fi[["size"]], fi[["mtime"]])
[17:40:54.449]                       stop(msg)
[17:40:54.449]                     }
[17:40:54.449]                     invisible(pathname)
[17:40:54.449]                   }
[17:40:54.449]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.449]                     rootPath = tempdir()) 
[17:40:54.449]                   {
[17:40:54.449]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.449]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.449]                       tmpdir = path, fileext = ".rds")
[17:40:54.449]                     save_rds(obj, file)
[17:40:54.449]                   }
[17:40:54.449]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.449]                   {
[17:40:54.449]                     inherits <- base::inherits
[17:40:54.449]                     invokeRestart <- base::invokeRestart
[17:40:54.449]                     is.null <- base::is.null
[17:40:54.449]                     muffled <- FALSE
[17:40:54.449]                     if (inherits(cond, "message")) {
[17:40:54.449]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.449]                       if (muffled) 
[17:40:54.449]                         invokeRestart("muffleMessage")
[17:40:54.449]                     }
[17:40:54.449]                     else if (inherits(cond, "warning")) {
[17:40:54.449]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.449]                       if (muffled) 
[17:40:54.449]                         invokeRestart("muffleWarning")
[17:40:54.449]                     }
[17:40:54.449]                     else if (inherits(cond, "condition")) {
[17:40:54.449]                       if (!is.null(pattern)) {
[17:40:54.449]                         computeRestarts <- base::computeRestarts
[17:40:54.449]                         grepl <- base::grepl
[17:40:54.449]                         restarts <- computeRestarts(cond)
[17:40:54.449]                         for (restart in restarts) {
[17:40:54.449]                           name <- restart$name
[17:40:54.449]                           if (is.null(name)) 
[17:40:54.449]                             next
[17:40:54.449]                           if (!grepl(pattern, name)) 
[17:40:54.449]                             next
[17:40:54.449]                           invokeRestart(restart)
[17:40:54.449]                           muffled <- TRUE
[17:40:54.449]                           break
[17:40:54.449]                         }
[17:40:54.449]                       }
[17:40:54.449]                     }
[17:40:54.449]                     invisible(muffled)
[17:40:54.449]                   }
[17:40:54.449]                   muffleCondition(cond)
[17:40:54.449]                 })
[17:40:54.449]             }))
[17:40:54.449]             future::FutureResult(value = ...future.value$value, 
[17:40:54.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.449]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.449]                     ...future.globalenv.names))
[17:40:54.449]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.449]         }, condition = base::local({
[17:40:54.449]             c <- base::c
[17:40:54.449]             inherits <- base::inherits
[17:40:54.449]             invokeRestart <- base::invokeRestart
[17:40:54.449]             length <- base::length
[17:40:54.449]             list <- base::list
[17:40:54.449]             seq.int <- base::seq.int
[17:40:54.449]             signalCondition <- base::signalCondition
[17:40:54.449]             sys.calls <- base::sys.calls
[17:40:54.449]             `[[` <- base::`[[`
[17:40:54.449]             `+` <- base::`+`
[17:40:54.449]             `<<-` <- base::`<<-`
[17:40:54.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.449]                   3L)]
[17:40:54.449]             }
[17:40:54.449]             function(cond) {
[17:40:54.449]                 is_error <- inherits(cond, "error")
[17:40:54.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.449]                   NULL)
[17:40:54.449]                 if (is_error) {
[17:40:54.449]                   sessionInformation <- function() {
[17:40:54.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.449]                       search = base::search(), system = base::Sys.info())
[17:40:54.449]                   }
[17:40:54.449]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.449]                     cond$call), session = sessionInformation(), 
[17:40:54.449]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.449]                   signalCondition(cond)
[17:40:54.449]                 }
[17:40:54.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.449]                 "immediateCondition"))) {
[17:40:54.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.449]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.449]                   if (TRUE && !signal) {
[17:40:54.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.449]                     {
[17:40:54.449]                       inherits <- base::inherits
[17:40:54.449]                       invokeRestart <- base::invokeRestart
[17:40:54.449]                       is.null <- base::is.null
[17:40:54.449]                       muffled <- FALSE
[17:40:54.449]                       if (inherits(cond, "message")) {
[17:40:54.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.449]                         if (muffled) 
[17:40:54.449]                           invokeRestart("muffleMessage")
[17:40:54.449]                       }
[17:40:54.449]                       else if (inherits(cond, "warning")) {
[17:40:54.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.449]                         if (muffled) 
[17:40:54.449]                           invokeRestart("muffleWarning")
[17:40:54.449]                       }
[17:40:54.449]                       else if (inherits(cond, "condition")) {
[17:40:54.449]                         if (!is.null(pattern)) {
[17:40:54.449]                           computeRestarts <- base::computeRestarts
[17:40:54.449]                           grepl <- base::grepl
[17:40:54.449]                           restarts <- computeRestarts(cond)
[17:40:54.449]                           for (restart in restarts) {
[17:40:54.449]                             name <- restart$name
[17:40:54.449]                             if (is.null(name)) 
[17:40:54.449]                               next
[17:40:54.449]                             if (!grepl(pattern, name)) 
[17:40:54.449]                               next
[17:40:54.449]                             invokeRestart(restart)
[17:40:54.449]                             muffled <- TRUE
[17:40:54.449]                             break
[17:40:54.449]                           }
[17:40:54.449]                         }
[17:40:54.449]                       }
[17:40:54.449]                       invisible(muffled)
[17:40:54.449]                     }
[17:40:54.449]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.449]                   }
[17:40:54.449]                 }
[17:40:54.449]                 else {
[17:40:54.449]                   if (TRUE) {
[17:40:54.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.449]                     {
[17:40:54.449]                       inherits <- base::inherits
[17:40:54.449]                       invokeRestart <- base::invokeRestart
[17:40:54.449]                       is.null <- base::is.null
[17:40:54.449]                       muffled <- FALSE
[17:40:54.449]                       if (inherits(cond, "message")) {
[17:40:54.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.449]                         if (muffled) 
[17:40:54.449]                           invokeRestart("muffleMessage")
[17:40:54.449]                       }
[17:40:54.449]                       else if (inherits(cond, "warning")) {
[17:40:54.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.449]                         if (muffled) 
[17:40:54.449]                           invokeRestart("muffleWarning")
[17:40:54.449]                       }
[17:40:54.449]                       else if (inherits(cond, "condition")) {
[17:40:54.449]                         if (!is.null(pattern)) {
[17:40:54.449]                           computeRestarts <- base::computeRestarts
[17:40:54.449]                           grepl <- base::grepl
[17:40:54.449]                           restarts <- computeRestarts(cond)
[17:40:54.449]                           for (restart in restarts) {
[17:40:54.449]                             name <- restart$name
[17:40:54.449]                             if (is.null(name)) 
[17:40:54.449]                               next
[17:40:54.449]                             if (!grepl(pattern, name)) 
[17:40:54.449]                               next
[17:40:54.449]                             invokeRestart(restart)
[17:40:54.449]                             muffled <- TRUE
[17:40:54.449]                             break
[17:40:54.449]                           }
[17:40:54.449]                         }
[17:40:54.449]                       }
[17:40:54.449]                       invisible(muffled)
[17:40:54.449]                     }
[17:40:54.449]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.449]                   }
[17:40:54.449]                 }
[17:40:54.449]             }
[17:40:54.449]         }))
[17:40:54.449]     }, error = function(ex) {
[17:40:54.449]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.449]                 ...future.rng), started = ...future.startTime, 
[17:40:54.449]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.449]             version = "1.8"), class = "FutureResult")
[17:40:54.449]     }, finally = {
[17:40:54.449]         if (!identical(...future.workdir, getwd())) 
[17:40:54.449]             setwd(...future.workdir)
[17:40:54.449]         {
[17:40:54.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.449]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.449]             }
[17:40:54.449]             base::options(...future.oldOptions)
[17:40:54.449]             if (.Platform$OS.type == "windows") {
[17:40:54.449]                 old_names <- names(...future.oldEnvVars)
[17:40:54.449]                 envs <- base::Sys.getenv()
[17:40:54.449]                 names <- names(envs)
[17:40:54.449]                 common <- intersect(names, old_names)
[17:40:54.449]                 added <- setdiff(names, old_names)
[17:40:54.449]                 removed <- setdiff(old_names, names)
[17:40:54.449]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.449]                   envs[common]]
[17:40:54.449]                 NAMES <- toupper(changed)
[17:40:54.449]                 args <- list()
[17:40:54.449]                 for (kk in seq_along(NAMES)) {
[17:40:54.449]                   name <- changed[[kk]]
[17:40:54.449]                   NAME <- NAMES[[kk]]
[17:40:54.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.449]                     next
[17:40:54.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.449]                 }
[17:40:54.449]                 NAMES <- toupper(added)
[17:40:54.449]                 for (kk in seq_along(NAMES)) {
[17:40:54.449]                   name <- added[[kk]]
[17:40:54.449]                   NAME <- NAMES[[kk]]
[17:40:54.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.449]                     next
[17:40:54.449]                   args[[name]] <- ""
[17:40:54.449]                 }
[17:40:54.449]                 NAMES <- toupper(removed)
[17:40:54.449]                 for (kk in seq_along(NAMES)) {
[17:40:54.449]                   name <- removed[[kk]]
[17:40:54.449]                   NAME <- NAMES[[kk]]
[17:40:54.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.449]                     next
[17:40:54.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.449]                 }
[17:40:54.449]                 if (length(args) > 0) 
[17:40:54.449]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.449]             }
[17:40:54.449]             else {
[17:40:54.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.449]             }
[17:40:54.449]             {
[17:40:54.449]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.449]                   0L) {
[17:40:54.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.449]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.449]                   base::options(opts)
[17:40:54.449]                 }
[17:40:54.449]                 {
[17:40:54.449]                   {
[17:40:54.449]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.449]                     NULL
[17:40:54.449]                   }
[17:40:54.449]                   options(future.plan = NULL)
[17:40:54.449]                   if (is.na(NA_character_)) 
[17:40:54.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.449]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.449]                     envir = parent.frame()) 
[17:40:54.449]                   {
[17:40:54.449]                     default_workers <- missing(workers)
[17:40:54.449]                     if (is.function(workers)) 
[17:40:54.449]                       workers <- workers()
[17:40:54.449]                     workers <- structure(as.integer(workers), 
[17:40:54.449]                       class = class(workers))
[17:40:54.449]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.449]                       1L)
[17:40:54.449]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.449]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.449]                       if (default_workers) 
[17:40:54.449]                         supportsMulticore(warn = TRUE)
[17:40:54.449]                       return(sequential(..., envir = envir))
[17:40:54.449]                     }
[17:40:54.449]                     oopts <- options(mc.cores = workers)
[17:40:54.449]                     on.exit(options(oopts))
[17:40:54.449]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.449]                       envir = envir)
[17:40:54.449]                     if (!future$lazy) 
[17:40:54.449]                       future <- run(future)
[17:40:54.449]                     invisible(future)
[17:40:54.449]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.449]                 }
[17:40:54.449]             }
[17:40:54.449]         }
[17:40:54.449]     })
[17:40:54.449]     if (TRUE) {
[17:40:54.449]         base::sink(type = "output", split = FALSE)
[17:40:54.449]         if (TRUE) {
[17:40:54.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.449]         }
[17:40:54.449]         else {
[17:40:54.449]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.449]         }
[17:40:54.449]         base::close(...future.stdout)
[17:40:54.449]         ...future.stdout <- NULL
[17:40:54.449]     }
[17:40:54.449]     ...future.result$conditions <- ...future.conditions
[17:40:54.449]     ...future.result$finished <- base::Sys.time()
[17:40:54.449]     ...future.result
[17:40:54.449] }
[17:40:54.452] assign_globals() ...
[17:40:54.452] List of 11
[17:40:54.452]  $ ...future.FUN            :function (x, ...)  
[17:40:54.452]  $ x_FUN                    :function (x)  
[17:40:54.452]  $ times                    : int 1
[17:40:54.452]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.452]  $ stop_if_not              :function (...)  
[17:40:54.452]  $ dim                      : NULL
[17:40:54.452]  $ valid_types              : chr "character"
[17:40:54.452]  $ future.call.arguments    : list()
[17:40:54.452]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.452]  $ ...future.elements_ii    :List of 1
[17:40:54.452]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:40:54.452]  $ ...future.seeds_ii       : NULL
[17:40:54.452]  $ ...future.globals.maxSize: NULL
[17:40:54.452]  - attr(*, "where")=List of 11
[17:40:54.452]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.452]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.452]  - attr(*, "resolved")= logi FALSE
[17:40:54.452]  - attr(*, "total_size")= num 94208
[17:40:54.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.452]  - attr(*, "already-done")= logi TRUE
[17:40:54.462] - copied ‘...future.FUN’ to environment
[17:40:54.463] - copied ‘x_FUN’ to environment
[17:40:54.463] - copied ‘times’ to environment
[17:40:54.463] - copied ‘stopf’ to environment
[17:40:54.463] - copied ‘stop_if_not’ to environment
[17:40:54.463] - copied ‘dim’ to environment
[17:40:54.463] - copied ‘valid_types’ to environment
[17:40:54.463] - copied ‘future.call.arguments’ to environment
[17:40:54.463] - copied ‘...future.elements_ii’ to environment
[17:40:54.463] - copied ‘...future.seeds_ii’ to environment
[17:40:54.464] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.464] assign_globals() ... done
[17:40:54.464] requestCore(): workers = 2
[17:40:54.467] MulticoreFuture started
[17:40:54.468] - Launch lazy future ... done
[17:40:54.468] run() for ‘MulticoreFuture’ ... done
[17:40:54.469] Created future:
[17:40:54.469] plan(): Setting new future strategy stack:
[17:40:54.469] List of future strategies:
[17:40:54.469] 1. sequential:
[17:40:54.469]    - args: function (..., envir = parent.frame())
[17:40:54.469]    - tweaked: FALSE
[17:40:54.469]    - call: NULL
[17:40:54.470] plan(): nbrOfWorkers() = 1
[17:40:54.472] plan(): Setting new future strategy stack:
[17:40:54.472] List of future strategies:
[17:40:54.472] 1. multicore:
[17:40:54.472]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.472]    - tweaked: FALSE
[17:40:54.472]    - call: plan(strategy)
[17:40:54.478] plan(): nbrOfWorkers() = 2
[17:40:54.469] MulticoreFuture:
[17:40:54.469] Label: ‘future_vapply-1’
[17:40:54.469] Expression:
[17:40:54.469] {
[17:40:54.469]     do.call(function(...) {
[17:40:54.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.469]             on.exit(options(oopts), add = TRUE)
[17:40:54.469]         }
[17:40:54.469]         {
[17:40:54.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.469]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.469]             })
[17:40:54.469]         }
[17:40:54.469]     }, args = future.call.arguments)
[17:40:54.469] }
[17:40:54.469] Lazy evaluation: FALSE
[17:40:54.469] Asynchronous evaluation: TRUE
[17:40:54.469] Local evaluation: TRUE
[17:40:54.469] Environment: R_GlobalEnv
[17:40:54.469] Capture standard output: TRUE
[17:40:54.469] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.469] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.469] Packages: 1 packages (‘future.apply’)
[17:40:54.469] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.469] Resolved: TRUE
[17:40:54.469] Value: <not collected>
[17:40:54.469] Conditions captured: <none>
[17:40:54.469] Early signaling: FALSE
[17:40:54.469] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.469] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.480] Chunk #1 of 2 ... DONE
[17:40:54.480] Chunk #2 of 2 ...
[17:40:54.480]  - Finding globals in 'X' for chunk #2 ...
[17:40:54.481] getGlobalsAndPackages() ...
[17:40:54.481] Searching for globals...
[17:40:54.481] 
[17:40:54.481] Searching for globals ... DONE
[17:40:54.481] - globals: [0] <none>
[17:40:54.482] getGlobalsAndPackages() ... DONE
[17:40:54.482]    + additional globals found: [n=0] 
[17:40:54.482]    + additional namespaces needed: [n=0] 
[17:40:54.482]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:54.482]  - seeds: <none>
[17:40:54.482] getGlobalsAndPackages() ...
[17:40:54.482] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.483] Resolving globals: FALSE
[17:40:54.483] Tweak future expression to call with '...' arguments ...
[17:40:54.483] {
[17:40:54.483]     do.call(function(...) {
[17:40:54.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.483]             on.exit(options(oopts), add = TRUE)
[17:40:54.483]         }
[17:40:54.483]         {
[17:40:54.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.483]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.483]             })
[17:40:54.483]         }
[17:40:54.483]     }, args = future.call.arguments)
[17:40:54.483] }
[17:40:54.484] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.485] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.485] - packages: [1] ‘future.apply’
[17:40:54.485] getGlobalsAndPackages() ... DONE
[17:40:54.485] run() for ‘Future’ ...
[17:40:54.486] - state: ‘created’
[17:40:54.486] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.491] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.491]   - Field: ‘label’
[17:40:54.491]   - Field: ‘local’
[17:40:54.491]   - Field: ‘owner’
[17:40:54.491]   - Field: ‘envir’
[17:40:54.492]   - Field: ‘workers’
[17:40:54.492]   - Field: ‘packages’
[17:40:54.492]   - Field: ‘gc’
[17:40:54.492]   - Field: ‘job’
[17:40:54.492]   - Field: ‘conditions’
[17:40:54.492]   - Field: ‘expr’
[17:40:54.492]   - Field: ‘uuid’
[17:40:54.493]   - Field: ‘seed’
[17:40:54.493]   - Field: ‘version’
[17:40:54.493]   - Field: ‘result’
[17:40:54.493]   - Field: ‘asynchronous’
[17:40:54.493]   - Field: ‘calls’
[17:40:54.493]   - Field: ‘globals’
[17:40:54.493]   - Field: ‘stdout’
[17:40:54.494]   - Field: ‘earlySignal’
[17:40:54.494]   - Field: ‘lazy’
[17:40:54.494]   - Field: ‘state’
[17:40:54.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.494] - Launch lazy future ...
[17:40:54.495] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.495] Packages needed by future strategies (n = 0): <none>
[17:40:54.496] {
[17:40:54.496]     {
[17:40:54.496]         {
[17:40:54.496]             ...future.startTime <- base::Sys.time()
[17:40:54.496]             {
[17:40:54.496]                 {
[17:40:54.496]                   {
[17:40:54.496]                     {
[17:40:54.496]                       {
[17:40:54.496]                         base::local({
[17:40:54.496]                           has_future <- base::requireNamespace("future", 
[17:40:54.496]                             quietly = TRUE)
[17:40:54.496]                           if (has_future) {
[17:40:54.496]                             ns <- base::getNamespace("future")
[17:40:54.496]                             version <- ns[[".package"]][["version"]]
[17:40:54.496]                             if (is.null(version)) 
[17:40:54.496]                               version <- utils::packageVersion("future")
[17:40:54.496]                           }
[17:40:54.496]                           else {
[17:40:54.496]                             version <- NULL
[17:40:54.496]                           }
[17:40:54.496]                           if (!has_future || version < "1.8.0") {
[17:40:54.496]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.496]                               "", base::R.version$version.string), 
[17:40:54.496]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.496]                                 base::R.version$platform, 8 * 
[17:40:54.496]                                   base::.Machine$sizeof.pointer), 
[17:40:54.496]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.496]                                 "release", "version")], collapse = " "), 
[17:40:54.496]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.496]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.496]                               info)
[17:40:54.496]                             info <- base::paste(info, collapse = "; ")
[17:40:54.496]                             if (!has_future) {
[17:40:54.496]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.496]                                 info)
[17:40:54.496]                             }
[17:40:54.496]                             else {
[17:40:54.496]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.496]                                 info, version)
[17:40:54.496]                             }
[17:40:54.496]                             base::stop(msg)
[17:40:54.496]                           }
[17:40:54.496]                         })
[17:40:54.496]                       }
[17:40:54.496]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.496]                       base::options(mc.cores = 1L)
[17:40:54.496]                     }
[17:40:54.496]                     base::local({
[17:40:54.496]                       for (pkg in "future.apply") {
[17:40:54.496]                         base::loadNamespace(pkg)
[17:40:54.496]                         base::library(pkg, character.only = TRUE)
[17:40:54.496]                       }
[17:40:54.496]                     })
[17:40:54.496]                   }
[17:40:54.496]                   options(future.plan = NULL)
[17:40:54.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.496]                 }
[17:40:54.496]                 ...future.workdir <- getwd()
[17:40:54.496]             }
[17:40:54.496]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.496]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.496]         }
[17:40:54.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.496]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.496]             base::names(...future.oldOptions))
[17:40:54.496]     }
[17:40:54.496]     if (FALSE) {
[17:40:54.496]     }
[17:40:54.496]     else {
[17:40:54.496]         if (TRUE) {
[17:40:54.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.496]                 open = "w")
[17:40:54.496]         }
[17:40:54.496]         else {
[17:40:54.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.496]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.496]         }
[17:40:54.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.496]             base::sink(type = "output", split = FALSE)
[17:40:54.496]             base::close(...future.stdout)
[17:40:54.496]         }, add = TRUE)
[17:40:54.496]     }
[17:40:54.496]     ...future.frame <- base::sys.nframe()
[17:40:54.496]     ...future.conditions <- base::list()
[17:40:54.496]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.496]     if (FALSE) {
[17:40:54.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.496]     }
[17:40:54.496]     ...future.result <- base::tryCatch({
[17:40:54.496]         base::withCallingHandlers({
[17:40:54.496]             ...future.value <- base::withVisible(base::local({
[17:40:54.496]                 withCallingHandlers({
[17:40:54.496]                   {
[17:40:54.496]                     do.call(function(...) {
[17:40:54.496]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.496]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.496]                         ...future.globals.maxSize)) {
[17:40:54.496]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.496]                         on.exit(options(oopts), add = TRUE)
[17:40:54.496]                       }
[17:40:54.496]                       {
[17:40:54.496]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.496]                           FUN = function(jj) {
[17:40:54.496]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.496]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.496]                           })
[17:40:54.496]                       }
[17:40:54.496]                     }, args = future.call.arguments)
[17:40:54.496]                   }
[17:40:54.496]                 }, immediateCondition = function(cond) {
[17:40:54.496]                   save_rds <- function (object, pathname, ...) 
[17:40:54.496]                   {
[17:40:54.496]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.496]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.496]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.496]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.496]                         fi_tmp[["mtime"]])
[17:40:54.496]                     }
[17:40:54.496]                     tryCatch({
[17:40:54.496]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.496]                     }, error = function(ex) {
[17:40:54.496]                       msg <- conditionMessage(ex)
[17:40:54.496]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.496]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.496]                         fi_tmp[["mtime"]], msg)
[17:40:54.496]                       ex$message <- msg
[17:40:54.496]                       stop(ex)
[17:40:54.496]                     })
[17:40:54.496]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.496]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.496]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.496]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.496]                       fi <- file.info(pathname)
[17:40:54.496]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.496]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.496]                         fi[["size"]], fi[["mtime"]])
[17:40:54.496]                       stop(msg)
[17:40:54.496]                     }
[17:40:54.496]                     invisible(pathname)
[17:40:54.496]                   }
[17:40:54.496]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.496]                     rootPath = tempdir()) 
[17:40:54.496]                   {
[17:40:54.496]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.496]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.496]                       tmpdir = path, fileext = ".rds")
[17:40:54.496]                     save_rds(obj, file)
[17:40:54.496]                   }
[17:40:54.496]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.496]                   {
[17:40:54.496]                     inherits <- base::inherits
[17:40:54.496]                     invokeRestart <- base::invokeRestart
[17:40:54.496]                     is.null <- base::is.null
[17:40:54.496]                     muffled <- FALSE
[17:40:54.496]                     if (inherits(cond, "message")) {
[17:40:54.496]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.496]                       if (muffled) 
[17:40:54.496]                         invokeRestart("muffleMessage")
[17:40:54.496]                     }
[17:40:54.496]                     else if (inherits(cond, "warning")) {
[17:40:54.496]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.496]                       if (muffled) 
[17:40:54.496]                         invokeRestart("muffleWarning")
[17:40:54.496]                     }
[17:40:54.496]                     else if (inherits(cond, "condition")) {
[17:40:54.496]                       if (!is.null(pattern)) {
[17:40:54.496]                         computeRestarts <- base::computeRestarts
[17:40:54.496]                         grepl <- base::grepl
[17:40:54.496]                         restarts <- computeRestarts(cond)
[17:40:54.496]                         for (restart in restarts) {
[17:40:54.496]                           name <- restart$name
[17:40:54.496]                           if (is.null(name)) 
[17:40:54.496]                             next
[17:40:54.496]                           if (!grepl(pattern, name)) 
[17:40:54.496]                             next
[17:40:54.496]                           invokeRestart(restart)
[17:40:54.496]                           muffled <- TRUE
[17:40:54.496]                           break
[17:40:54.496]                         }
[17:40:54.496]                       }
[17:40:54.496]                     }
[17:40:54.496]                     invisible(muffled)
[17:40:54.496]                   }
[17:40:54.496]                   muffleCondition(cond)
[17:40:54.496]                 })
[17:40:54.496]             }))
[17:40:54.496]             future::FutureResult(value = ...future.value$value, 
[17:40:54.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.496]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.496]                     ...future.globalenv.names))
[17:40:54.496]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.496]         }, condition = base::local({
[17:40:54.496]             c <- base::c
[17:40:54.496]             inherits <- base::inherits
[17:40:54.496]             invokeRestart <- base::invokeRestart
[17:40:54.496]             length <- base::length
[17:40:54.496]             list <- base::list
[17:40:54.496]             seq.int <- base::seq.int
[17:40:54.496]             signalCondition <- base::signalCondition
[17:40:54.496]             sys.calls <- base::sys.calls
[17:40:54.496]             `[[` <- base::`[[`
[17:40:54.496]             `+` <- base::`+`
[17:40:54.496]             `<<-` <- base::`<<-`
[17:40:54.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.496]                   3L)]
[17:40:54.496]             }
[17:40:54.496]             function(cond) {
[17:40:54.496]                 is_error <- inherits(cond, "error")
[17:40:54.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.496]                   NULL)
[17:40:54.496]                 if (is_error) {
[17:40:54.496]                   sessionInformation <- function() {
[17:40:54.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.496]                       search = base::search(), system = base::Sys.info())
[17:40:54.496]                   }
[17:40:54.496]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.496]                     cond$call), session = sessionInformation(), 
[17:40:54.496]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.496]                   signalCondition(cond)
[17:40:54.496]                 }
[17:40:54.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.496]                 "immediateCondition"))) {
[17:40:54.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.496]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.496]                   if (TRUE && !signal) {
[17:40:54.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.496]                     {
[17:40:54.496]                       inherits <- base::inherits
[17:40:54.496]                       invokeRestart <- base::invokeRestart
[17:40:54.496]                       is.null <- base::is.null
[17:40:54.496]                       muffled <- FALSE
[17:40:54.496]                       if (inherits(cond, "message")) {
[17:40:54.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.496]                         if (muffled) 
[17:40:54.496]                           invokeRestart("muffleMessage")
[17:40:54.496]                       }
[17:40:54.496]                       else if (inherits(cond, "warning")) {
[17:40:54.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.496]                         if (muffled) 
[17:40:54.496]                           invokeRestart("muffleWarning")
[17:40:54.496]                       }
[17:40:54.496]                       else if (inherits(cond, "condition")) {
[17:40:54.496]                         if (!is.null(pattern)) {
[17:40:54.496]                           computeRestarts <- base::computeRestarts
[17:40:54.496]                           grepl <- base::grepl
[17:40:54.496]                           restarts <- computeRestarts(cond)
[17:40:54.496]                           for (restart in restarts) {
[17:40:54.496]                             name <- restart$name
[17:40:54.496]                             if (is.null(name)) 
[17:40:54.496]                               next
[17:40:54.496]                             if (!grepl(pattern, name)) 
[17:40:54.496]                               next
[17:40:54.496]                             invokeRestart(restart)
[17:40:54.496]                             muffled <- TRUE
[17:40:54.496]                             break
[17:40:54.496]                           }
[17:40:54.496]                         }
[17:40:54.496]                       }
[17:40:54.496]                       invisible(muffled)
[17:40:54.496]                     }
[17:40:54.496]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.496]                   }
[17:40:54.496]                 }
[17:40:54.496]                 else {
[17:40:54.496]                   if (TRUE) {
[17:40:54.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.496]                     {
[17:40:54.496]                       inherits <- base::inherits
[17:40:54.496]                       invokeRestart <- base::invokeRestart
[17:40:54.496]                       is.null <- base::is.null
[17:40:54.496]                       muffled <- FALSE
[17:40:54.496]                       if (inherits(cond, "message")) {
[17:40:54.496]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.496]                         if (muffled) 
[17:40:54.496]                           invokeRestart("muffleMessage")
[17:40:54.496]                       }
[17:40:54.496]                       else if (inherits(cond, "warning")) {
[17:40:54.496]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.496]                         if (muffled) 
[17:40:54.496]                           invokeRestart("muffleWarning")
[17:40:54.496]                       }
[17:40:54.496]                       else if (inherits(cond, "condition")) {
[17:40:54.496]                         if (!is.null(pattern)) {
[17:40:54.496]                           computeRestarts <- base::computeRestarts
[17:40:54.496]                           grepl <- base::grepl
[17:40:54.496]                           restarts <- computeRestarts(cond)
[17:40:54.496]                           for (restart in restarts) {
[17:40:54.496]                             name <- restart$name
[17:40:54.496]                             if (is.null(name)) 
[17:40:54.496]                               next
[17:40:54.496]                             if (!grepl(pattern, name)) 
[17:40:54.496]                               next
[17:40:54.496]                             invokeRestart(restart)
[17:40:54.496]                             muffled <- TRUE
[17:40:54.496]                             break
[17:40:54.496]                           }
[17:40:54.496]                         }
[17:40:54.496]                       }
[17:40:54.496]                       invisible(muffled)
[17:40:54.496]                     }
[17:40:54.496]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.496]                   }
[17:40:54.496]                 }
[17:40:54.496]             }
[17:40:54.496]         }))
[17:40:54.496]     }, error = function(ex) {
[17:40:54.496]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.496]                 ...future.rng), started = ...future.startTime, 
[17:40:54.496]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.496]             version = "1.8"), class = "FutureResult")
[17:40:54.496]     }, finally = {
[17:40:54.496]         if (!identical(...future.workdir, getwd())) 
[17:40:54.496]             setwd(...future.workdir)
[17:40:54.496]         {
[17:40:54.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.496]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.496]             }
[17:40:54.496]             base::options(...future.oldOptions)
[17:40:54.496]             if (.Platform$OS.type == "windows") {
[17:40:54.496]                 old_names <- names(...future.oldEnvVars)
[17:40:54.496]                 envs <- base::Sys.getenv()
[17:40:54.496]                 names <- names(envs)
[17:40:54.496]                 common <- intersect(names, old_names)
[17:40:54.496]                 added <- setdiff(names, old_names)
[17:40:54.496]                 removed <- setdiff(old_names, names)
[17:40:54.496]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.496]                   envs[common]]
[17:40:54.496]                 NAMES <- toupper(changed)
[17:40:54.496]                 args <- list()
[17:40:54.496]                 for (kk in seq_along(NAMES)) {
[17:40:54.496]                   name <- changed[[kk]]
[17:40:54.496]                   NAME <- NAMES[[kk]]
[17:40:54.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.496]                     next
[17:40:54.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.496]                 }
[17:40:54.496]                 NAMES <- toupper(added)
[17:40:54.496]                 for (kk in seq_along(NAMES)) {
[17:40:54.496]                   name <- added[[kk]]
[17:40:54.496]                   NAME <- NAMES[[kk]]
[17:40:54.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.496]                     next
[17:40:54.496]                   args[[name]] <- ""
[17:40:54.496]                 }
[17:40:54.496]                 NAMES <- toupper(removed)
[17:40:54.496]                 for (kk in seq_along(NAMES)) {
[17:40:54.496]                   name <- removed[[kk]]
[17:40:54.496]                   NAME <- NAMES[[kk]]
[17:40:54.496]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.496]                     next
[17:40:54.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.496]                 }
[17:40:54.496]                 if (length(args) > 0) 
[17:40:54.496]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.496]             }
[17:40:54.496]             else {
[17:40:54.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.496]             }
[17:40:54.496]             {
[17:40:54.496]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.496]                   0L) {
[17:40:54.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.496]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.496]                   base::options(opts)
[17:40:54.496]                 }
[17:40:54.496]                 {
[17:40:54.496]                   {
[17:40:54.496]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.496]                     NULL
[17:40:54.496]                   }
[17:40:54.496]                   options(future.plan = NULL)
[17:40:54.496]                   if (is.na(NA_character_)) 
[17:40:54.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.496]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.496]                     envir = parent.frame()) 
[17:40:54.496]                   {
[17:40:54.496]                     default_workers <- missing(workers)
[17:40:54.496]                     if (is.function(workers)) 
[17:40:54.496]                       workers <- workers()
[17:40:54.496]                     workers <- structure(as.integer(workers), 
[17:40:54.496]                       class = class(workers))
[17:40:54.496]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.496]                       1L)
[17:40:54.496]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.496]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.496]                       if (default_workers) 
[17:40:54.496]                         supportsMulticore(warn = TRUE)
[17:40:54.496]                       return(sequential(..., envir = envir))
[17:40:54.496]                     }
[17:40:54.496]                     oopts <- options(mc.cores = workers)
[17:40:54.496]                     on.exit(options(oopts))
[17:40:54.496]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.496]                       envir = envir)
[17:40:54.496]                     if (!future$lazy) 
[17:40:54.496]                       future <- run(future)
[17:40:54.496]                     invisible(future)
[17:40:54.496]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.496]                 }
[17:40:54.496]             }
[17:40:54.496]         }
[17:40:54.496]     })
[17:40:54.496]     if (TRUE) {
[17:40:54.496]         base::sink(type = "output", split = FALSE)
[17:40:54.496]         if (TRUE) {
[17:40:54.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.496]         }
[17:40:54.496]         else {
[17:40:54.496]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.496]         }
[17:40:54.496]         base::close(...future.stdout)
[17:40:54.496]         ...future.stdout <- NULL
[17:40:54.496]     }
[17:40:54.496]     ...future.result$conditions <- ...future.conditions
[17:40:54.496]     ...future.result$finished <- base::Sys.time()
[17:40:54.496]     ...future.result
[17:40:54.496] }
[17:40:54.500] assign_globals() ...
[17:40:54.500] List of 11
[17:40:54.500]  $ ...future.FUN            :function (x, ...)  
[17:40:54.500]  $ x_FUN                    :function (x)  
[17:40:54.500]  $ times                    : int 1
[17:40:54.500]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.500]  $ stop_if_not              :function (...)  
[17:40:54.500]  $ dim                      : NULL
[17:40:54.500]  $ valid_types              : chr "character"
[17:40:54.500]  $ future.call.arguments    : list()
[17:40:54.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.500]  $ ...future.elements_ii    :List of 1
[17:40:54.500]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:40:54.500]  $ ...future.seeds_ii       : NULL
[17:40:54.500]  $ ...future.globals.maxSize: NULL
[17:40:54.500]  - attr(*, "where")=List of 11
[17:40:54.500]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.500]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.500]  - attr(*, "resolved")= logi FALSE
[17:40:54.500]  - attr(*, "total_size")= num 94208
[17:40:54.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.500]  - attr(*, "already-done")= logi TRUE
[17:40:54.516] - copied ‘...future.FUN’ to environment
[17:40:54.516] - copied ‘x_FUN’ to environment
[17:40:54.517] - copied ‘times’ to environment
[17:40:54.517] - copied ‘stopf’ to environment
[17:40:54.517] - copied ‘stop_if_not’ to environment
[17:40:54.517] - copied ‘dim’ to environment
[17:40:54.517] - copied ‘valid_types’ to environment
[17:40:54.517] - copied ‘future.call.arguments’ to environment
[17:40:54.517] - copied ‘...future.elements_ii’ to environment
[17:40:54.518] - copied ‘...future.seeds_ii’ to environment
[17:40:54.518] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.518] assign_globals() ... done
[17:40:54.518] requestCore(): workers = 2
[17:40:54.523] MulticoreFuture started
[17:40:54.523] - Launch lazy future ... done
[17:40:54.524] run() for ‘MulticoreFuture’ ... done
[17:40:54.524] Created future:
[17:40:54.525] plan(): Setting new future strategy stack:
[17:40:54.525] List of future strategies:
[17:40:54.525] 1. sequential:
[17:40:54.525]    - args: function (..., envir = parent.frame())
[17:40:54.525]    - tweaked: FALSE
[17:40:54.525]    - call: NULL
[17:40:54.526] plan(): nbrOfWorkers() = 1
[17:40:54.528] plan(): Setting new future strategy stack:
[17:40:54.528] List of future strategies:
[17:40:54.528] 1. multicore:
[17:40:54.528]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.528]    - tweaked: FALSE
[17:40:54.528]    - call: plan(strategy)
[17:40:54.534] plan(): nbrOfWorkers() = 2
[17:40:54.524] MulticoreFuture:
[17:40:54.524] Label: ‘future_vapply-2’
[17:40:54.524] Expression:
[17:40:54.524] {
[17:40:54.524]     do.call(function(...) {
[17:40:54.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.524]             on.exit(options(oopts), add = TRUE)
[17:40:54.524]         }
[17:40:54.524]         {
[17:40:54.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.524]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.524]             })
[17:40:54.524]         }
[17:40:54.524]     }, args = future.call.arguments)
[17:40:54.524] }
[17:40:54.524] Lazy evaluation: FALSE
[17:40:54.524] Asynchronous evaluation: TRUE
[17:40:54.524] Local evaluation: TRUE
[17:40:54.524] Environment: R_GlobalEnv
[17:40:54.524] Capture standard output: TRUE
[17:40:54.524] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.524] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.524] Packages: 1 packages (‘future.apply’)
[17:40:54.524] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.524] Resolved: TRUE
[17:40:54.524] Value: <not collected>
[17:40:54.524] Conditions captured: <none>
[17:40:54.524] Early signaling: FALSE
[17:40:54.524] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.524] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.535] Chunk #2 of 2 ... DONE
[17:40:54.535] Launching 2 futures (chunks) ... DONE
[17:40:54.535] Resolving 2 futures (chunks) ...
[17:40:54.536] resolve() on list ...
[17:40:54.536]  recursive: 0
[17:40:54.536]  length: 2
[17:40:54.536] 
[17:40:54.536] Future #1
[17:40:54.539] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:54.539] - nx: 2
[17:40:54.539] - relay: TRUE
[17:40:54.539] - stdout: TRUE
[17:40:54.540] - signal: TRUE
[17:40:54.540] - resignal: FALSE
[17:40:54.540] - force: TRUE
[17:40:54.540] - relayed: [n=2] FALSE, FALSE
[17:40:54.540] - queued futures: [n=2] FALSE, FALSE
[17:40:54.541]  - until=1
[17:40:54.541]  - relaying element #1
[17:40:54.541] - relayed: [n=2] TRUE, FALSE
[17:40:54.541] - queued futures: [n=2] TRUE, FALSE
[17:40:54.542] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:54.542]  length: 1 (resolved future 1)
[17:40:54.542] Future #2
[17:40:54.543] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:54.544] - nx: 2
[17:40:54.544] - relay: TRUE
[17:40:54.544] - stdout: TRUE
[17:40:54.544] - signal: TRUE
[17:40:54.544] - resignal: FALSE
[17:40:54.544] - force: TRUE
[17:40:54.544] - relayed: [n=2] TRUE, FALSE
[17:40:54.545] - queued futures: [n=2] TRUE, FALSE
[17:40:54.545]  - until=2
[17:40:54.545]  - relaying element #2
[17:40:54.545] - relayed: [n=2] TRUE, TRUE
[17:40:54.545] - queued futures: [n=2] TRUE, TRUE
[17:40:54.545] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:54.546]  length: 0 (resolved future 2)
[17:40:54.546] Relaying remaining futures
[17:40:54.546] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.546] - nx: 2
[17:40:54.546] - relay: TRUE
[17:40:54.546] - stdout: TRUE
[17:40:54.546] - signal: TRUE
[17:40:54.546] - resignal: FALSE
[17:40:54.546] - force: TRUE
[17:40:54.546] - relayed: [n=2] TRUE, TRUE
[17:40:54.547] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:54.547] - relayed: [n=2] TRUE, TRUE
[17:40:54.547] - queued futures: [n=2] TRUE, TRUE
[17:40:54.547] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.547] resolve() on list ... DONE
[17:40:54.547]  - Number of value chunks collected: 2
[17:40:54.548] Resolving 2 futures (chunks) ... DONE
[17:40:54.548] Reducing values from 2 chunks ...
[17:40:54.548]  - Number of values collected after concatenation: 2
[17:40:54.548]  - Number of values expected: 2
[17:40:54.548] Reducing values from 2 chunks ... DONE
[17:40:54.550] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:40:54.552] future_lapply() ...
[17:40:54.559] Number of chunks: 2
[17:40:54.559] getGlobalsAndPackagesXApply() ...
[17:40:54.559]  - future.globals: TRUE
[17:40:54.559] getGlobalsAndPackages() ...
[17:40:54.559] Searching for globals...
[17:40:54.564] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:40:54.564] Searching for globals ... DONE
[17:40:54.564] Resolving globals: FALSE
[17:40:54.565] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:40:54.566] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.566] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.566] - packages: [1] ‘future.apply’
[17:40:54.566] getGlobalsAndPackages() ... DONE
[17:40:54.566]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.567]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.567] Finding globals ... DONE
[17:40:54.567]  - use_args: TRUE
[17:40:54.567]  - Getting '...' globals ...
[17:40:54.567] resolve() on list ...
[17:40:54.567]  recursive: 0
[17:40:54.568]  length: 1
[17:40:54.568]  elements: ‘...’
[17:40:54.568]  length: 0 (resolved future 1)
[17:40:54.568] resolve() on list ... DONE
[17:40:54.568]    - '...' content: [n=0] 
[17:40:54.568] List of 1
[17:40:54.568]  $ ...: list()
[17:40:54.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.568]  - attr(*, "where")=List of 1
[17:40:54.568]   ..$ ...:<environment: 0x564f308bbb40> 
[17:40:54.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.568]  - attr(*, "resolved")= logi TRUE
[17:40:54.568]  - attr(*, "total_size")= num NA
[17:40:54.571]  - Getting '...' globals ... DONE
[17:40:54.571] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.571] List of 8
[17:40:54.571]  $ ...future.FUN:function (x, ...)  
[17:40:54.571]  $ x_FUN        :function (x)  
[17:40:54.571]  $ times        : int 0
[17:40:54.571]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.571]  $ stop_if_not  :function (...)  
[17:40:54.571]  $ dim          : NULL
[17:40:54.571]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:54.571]  $ ...          : list()
[17:40:54.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.571]  - attr(*, "where")=List of 8
[17:40:54.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.571]   ..$ ...          :<environment: 0x564f308bbb40> 
[17:40:54.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.571]  - attr(*, "resolved")= logi FALSE
[17:40:54.571]  - attr(*, "total_size")= num 95472
[17:40:54.579] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.579] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.579] Number of futures (= number of chunks): 2
[17:40:54.579] Launching 2 futures (chunks) ...
[17:40:54.579] Chunk #1 of 2 ...
[17:40:54.579]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.580] getGlobalsAndPackages() ...
[17:40:54.580] Searching for globals...
[17:40:54.580] 
[17:40:54.580] Searching for globals ... DONE
[17:40:54.580] - globals: [0] <none>
[17:40:54.580] getGlobalsAndPackages() ... DONE
[17:40:54.580]    + additional globals found: [n=0] 
[17:40:54.580]    + additional namespaces needed: [n=0] 
[17:40:54.581]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.581]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:54.581]  - seeds: <none>
[17:40:54.581] getGlobalsAndPackages() ...
[17:40:54.581] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.581] Resolving globals: FALSE
[17:40:54.581] Tweak future expression to call with '...' arguments ...
[17:40:54.581] {
[17:40:54.581]     do.call(function(...) {
[17:40:54.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.581]             on.exit(options(oopts), add = TRUE)
[17:40:54.581]         }
[17:40:54.581]         {
[17:40:54.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.581]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.581]             })
[17:40:54.581]         }
[17:40:54.581]     }, args = future.call.arguments)
[17:40:54.581] }
[17:40:54.582] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.582] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.582] - packages: [1] ‘future.apply’
[17:40:54.582] getGlobalsAndPackages() ... DONE
[17:40:54.583] run() for ‘Future’ ...
[17:40:54.583] - state: ‘created’
[17:40:54.583] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.587] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.587] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.587]   - Field: ‘label’
[17:40:54.587]   - Field: ‘local’
[17:40:54.587]   - Field: ‘owner’
[17:40:54.587]   - Field: ‘envir’
[17:40:54.587]   - Field: ‘workers’
[17:40:54.587]   - Field: ‘packages’
[17:40:54.588]   - Field: ‘gc’
[17:40:54.588]   - Field: ‘job’
[17:40:54.588]   - Field: ‘conditions’
[17:40:54.588]   - Field: ‘expr’
[17:40:54.588]   - Field: ‘uuid’
[17:40:54.588]   - Field: ‘seed’
[17:40:54.588]   - Field: ‘version’
[17:40:54.588]   - Field: ‘result’
[17:40:54.588]   - Field: ‘asynchronous’
[17:40:54.588]   - Field: ‘calls’
[17:40:54.588]   - Field: ‘globals’
[17:40:54.589]   - Field: ‘stdout’
[17:40:54.589]   - Field: ‘earlySignal’
[17:40:54.589]   - Field: ‘lazy’
[17:40:54.589]   - Field: ‘state’
[17:40:54.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.589] - Launch lazy future ...
[17:40:54.589] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.589] Packages needed by future strategies (n = 0): <none>
[17:40:54.590] {
[17:40:54.590]     {
[17:40:54.590]         {
[17:40:54.590]             ...future.startTime <- base::Sys.time()
[17:40:54.590]             {
[17:40:54.590]                 {
[17:40:54.590]                   {
[17:40:54.590]                     {
[17:40:54.590]                       {
[17:40:54.590]                         base::local({
[17:40:54.590]                           has_future <- base::requireNamespace("future", 
[17:40:54.590]                             quietly = TRUE)
[17:40:54.590]                           if (has_future) {
[17:40:54.590]                             ns <- base::getNamespace("future")
[17:40:54.590]                             version <- ns[[".package"]][["version"]]
[17:40:54.590]                             if (is.null(version)) 
[17:40:54.590]                               version <- utils::packageVersion("future")
[17:40:54.590]                           }
[17:40:54.590]                           else {
[17:40:54.590]                             version <- NULL
[17:40:54.590]                           }
[17:40:54.590]                           if (!has_future || version < "1.8.0") {
[17:40:54.590]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.590]                               "", base::R.version$version.string), 
[17:40:54.590]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.590]                                 base::R.version$platform, 8 * 
[17:40:54.590]                                   base::.Machine$sizeof.pointer), 
[17:40:54.590]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.590]                                 "release", "version")], collapse = " "), 
[17:40:54.590]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.590]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.590]                               info)
[17:40:54.590]                             info <- base::paste(info, collapse = "; ")
[17:40:54.590]                             if (!has_future) {
[17:40:54.590]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.590]                                 info)
[17:40:54.590]                             }
[17:40:54.590]                             else {
[17:40:54.590]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.590]                                 info, version)
[17:40:54.590]                             }
[17:40:54.590]                             base::stop(msg)
[17:40:54.590]                           }
[17:40:54.590]                         })
[17:40:54.590]                       }
[17:40:54.590]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.590]                       base::options(mc.cores = 1L)
[17:40:54.590]                     }
[17:40:54.590]                     base::local({
[17:40:54.590]                       for (pkg in "future.apply") {
[17:40:54.590]                         base::loadNamespace(pkg)
[17:40:54.590]                         base::library(pkg, character.only = TRUE)
[17:40:54.590]                       }
[17:40:54.590]                     })
[17:40:54.590]                   }
[17:40:54.590]                   options(future.plan = NULL)
[17:40:54.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.590]                 }
[17:40:54.590]                 ...future.workdir <- getwd()
[17:40:54.590]             }
[17:40:54.590]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.590]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.590]         }
[17:40:54.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.590]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:54.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.590]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.590]             base::names(...future.oldOptions))
[17:40:54.590]     }
[17:40:54.590]     if (FALSE) {
[17:40:54.590]     }
[17:40:54.590]     else {
[17:40:54.590]         if (TRUE) {
[17:40:54.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.590]                 open = "w")
[17:40:54.590]         }
[17:40:54.590]         else {
[17:40:54.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.590]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.590]         }
[17:40:54.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.590]             base::sink(type = "output", split = FALSE)
[17:40:54.590]             base::close(...future.stdout)
[17:40:54.590]         }, add = TRUE)
[17:40:54.590]     }
[17:40:54.590]     ...future.frame <- base::sys.nframe()
[17:40:54.590]     ...future.conditions <- base::list()
[17:40:54.590]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.590]     if (FALSE) {
[17:40:54.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.590]     }
[17:40:54.590]     ...future.result <- base::tryCatch({
[17:40:54.590]         base::withCallingHandlers({
[17:40:54.590]             ...future.value <- base::withVisible(base::local({
[17:40:54.590]                 withCallingHandlers({
[17:40:54.590]                   {
[17:40:54.590]                     do.call(function(...) {
[17:40:54.590]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.590]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.590]                         ...future.globals.maxSize)) {
[17:40:54.590]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.590]                         on.exit(options(oopts), add = TRUE)
[17:40:54.590]                       }
[17:40:54.590]                       {
[17:40:54.590]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.590]                           FUN = function(jj) {
[17:40:54.590]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.590]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.590]                           })
[17:40:54.590]                       }
[17:40:54.590]                     }, args = future.call.arguments)
[17:40:54.590]                   }
[17:40:54.590]                 }, immediateCondition = function(cond) {
[17:40:54.590]                   save_rds <- function (object, pathname, ...) 
[17:40:54.590]                   {
[17:40:54.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.590]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.590]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.590]                         fi_tmp[["mtime"]])
[17:40:54.590]                     }
[17:40:54.590]                     tryCatch({
[17:40:54.590]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.590]                     }, error = function(ex) {
[17:40:54.590]                       msg <- conditionMessage(ex)
[17:40:54.590]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.590]                         fi_tmp[["mtime"]], msg)
[17:40:54.590]                       ex$message <- msg
[17:40:54.590]                       stop(ex)
[17:40:54.590]                     })
[17:40:54.590]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.590]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.590]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.590]                       fi <- file.info(pathname)
[17:40:54.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.590]                         fi[["size"]], fi[["mtime"]])
[17:40:54.590]                       stop(msg)
[17:40:54.590]                     }
[17:40:54.590]                     invisible(pathname)
[17:40:54.590]                   }
[17:40:54.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.590]                     rootPath = tempdir()) 
[17:40:54.590]                   {
[17:40:54.590]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.590]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.590]                       tmpdir = path, fileext = ".rds")
[17:40:54.590]                     save_rds(obj, file)
[17:40:54.590]                   }
[17:40:54.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.590]                   {
[17:40:54.590]                     inherits <- base::inherits
[17:40:54.590]                     invokeRestart <- base::invokeRestart
[17:40:54.590]                     is.null <- base::is.null
[17:40:54.590]                     muffled <- FALSE
[17:40:54.590]                     if (inherits(cond, "message")) {
[17:40:54.590]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.590]                       if (muffled) 
[17:40:54.590]                         invokeRestart("muffleMessage")
[17:40:54.590]                     }
[17:40:54.590]                     else if (inherits(cond, "warning")) {
[17:40:54.590]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.590]                       if (muffled) 
[17:40:54.590]                         invokeRestart("muffleWarning")
[17:40:54.590]                     }
[17:40:54.590]                     else if (inherits(cond, "condition")) {
[17:40:54.590]                       if (!is.null(pattern)) {
[17:40:54.590]                         computeRestarts <- base::computeRestarts
[17:40:54.590]                         grepl <- base::grepl
[17:40:54.590]                         restarts <- computeRestarts(cond)
[17:40:54.590]                         for (restart in restarts) {
[17:40:54.590]                           name <- restart$name
[17:40:54.590]                           if (is.null(name)) 
[17:40:54.590]                             next
[17:40:54.590]                           if (!grepl(pattern, name)) 
[17:40:54.590]                             next
[17:40:54.590]                           invokeRestart(restart)
[17:40:54.590]                           muffled <- TRUE
[17:40:54.590]                           break
[17:40:54.590]                         }
[17:40:54.590]                       }
[17:40:54.590]                     }
[17:40:54.590]                     invisible(muffled)
[17:40:54.590]                   }
[17:40:54.590]                   muffleCondition(cond)
[17:40:54.590]                 })
[17:40:54.590]             }))
[17:40:54.590]             future::FutureResult(value = ...future.value$value, 
[17:40:54.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.590]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.590]                     ...future.globalenv.names))
[17:40:54.590]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.590]         }, condition = base::local({
[17:40:54.590]             c <- base::c
[17:40:54.590]             inherits <- base::inherits
[17:40:54.590]             invokeRestart <- base::invokeRestart
[17:40:54.590]             length <- base::length
[17:40:54.590]             list <- base::list
[17:40:54.590]             seq.int <- base::seq.int
[17:40:54.590]             signalCondition <- base::signalCondition
[17:40:54.590]             sys.calls <- base::sys.calls
[17:40:54.590]             `[[` <- base::`[[`
[17:40:54.590]             `+` <- base::`+`
[17:40:54.590]             `<<-` <- base::`<<-`
[17:40:54.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.590]                   3L)]
[17:40:54.590]             }
[17:40:54.590]             function(cond) {
[17:40:54.590]                 is_error <- inherits(cond, "error")
[17:40:54.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.590]                   NULL)
[17:40:54.590]                 if (is_error) {
[17:40:54.590]                   sessionInformation <- function() {
[17:40:54.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.590]                       search = base::search(), system = base::Sys.info())
[17:40:54.590]                   }
[17:40:54.590]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.590]                     cond$call), session = sessionInformation(), 
[17:40:54.590]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.590]                   signalCondition(cond)
[17:40:54.590]                 }
[17:40:54.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.590]                 "immediateCondition"))) {
[17:40:54.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.590]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.590]                   if (TRUE && !signal) {
[17:40:54.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.590]                     {
[17:40:54.590]                       inherits <- base::inherits
[17:40:54.590]                       invokeRestart <- base::invokeRestart
[17:40:54.590]                       is.null <- base::is.null
[17:40:54.590]                       muffled <- FALSE
[17:40:54.590]                       if (inherits(cond, "message")) {
[17:40:54.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.590]                         if (muffled) 
[17:40:54.590]                           invokeRestart("muffleMessage")
[17:40:54.590]                       }
[17:40:54.590]                       else if (inherits(cond, "warning")) {
[17:40:54.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.590]                         if (muffled) 
[17:40:54.590]                           invokeRestart("muffleWarning")
[17:40:54.590]                       }
[17:40:54.590]                       else if (inherits(cond, "condition")) {
[17:40:54.590]                         if (!is.null(pattern)) {
[17:40:54.590]                           computeRestarts <- base::computeRestarts
[17:40:54.590]                           grepl <- base::grepl
[17:40:54.590]                           restarts <- computeRestarts(cond)
[17:40:54.590]                           for (restart in restarts) {
[17:40:54.590]                             name <- restart$name
[17:40:54.590]                             if (is.null(name)) 
[17:40:54.590]                               next
[17:40:54.590]                             if (!grepl(pattern, name)) 
[17:40:54.590]                               next
[17:40:54.590]                             invokeRestart(restart)
[17:40:54.590]                             muffled <- TRUE
[17:40:54.590]                             break
[17:40:54.590]                           }
[17:40:54.590]                         }
[17:40:54.590]                       }
[17:40:54.590]                       invisible(muffled)
[17:40:54.590]                     }
[17:40:54.590]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.590]                   }
[17:40:54.590]                 }
[17:40:54.590]                 else {
[17:40:54.590]                   if (TRUE) {
[17:40:54.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.590]                     {
[17:40:54.590]                       inherits <- base::inherits
[17:40:54.590]                       invokeRestart <- base::invokeRestart
[17:40:54.590]                       is.null <- base::is.null
[17:40:54.590]                       muffled <- FALSE
[17:40:54.590]                       if (inherits(cond, "message")) {
[17:40:54.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.590]                         if (muffled) 
[17:40:54.590]                           invokeRestart("muffleMessage")
[17:40:54.590]                       }
[17:40:54.590]                       else if (inherits(cond, "warning")) {
[17:40:54.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.590]                         if (muffled) 
[17:40:54.590]                           invokeRestart("muffleWarning")
[17:40:54.590]                       }
[17:40:54.590]                       else if (inherits(cond, "condition")) {
[17:40:54.590]                         if (!is.null(pattern)) {
[17:40:54.590]                           computeRestarts <- base::computeRestarts
[17:40:54.590]                           grepl <- base::grepl
[17:40:54.590]                           restarts <- computeRestarts(cond)
[17:40:54.590]                           for (restart in restarts) {
[17:40:54.590]                             name <- restart$name
[17:40:54.590]                             if (is.null(name)) 
[17:40:54.590]                               next
[17:40:54.590]                             if (!grepl(pattern, name)) 
[17:40:54.590]                               next
[17:40:54.590]                             invokeRestart(restart)
[17:40:54.590]                             muffled <- TRUE
[17:40:54.590]                             break
[17:40:54.590]                           }
[17:40:54.590]                         }
[17:40:54.590]                       }
[17:40:54.590]                       invisible(muffled)
[17:40:54.590]                     }
[17:40:54.590]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.590]                   }
[17:40:54.590]                 }
[17:40:54.590]             }
[17:40:54.590]         }))
[17:40:54.590]     }, error = function(ex) {
[17:40:54.590]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.590]                 ...future.rng), started = ...future.startTime, 
[17:40:54.590]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.590]             version = "1.8"), class = "FutureResult")
[17:40:54.590]     }, finally = {
[17:40:54.590]         if (!identical(...future.workdir, getwd())) 
[17:40:54.590]             setwd(...future.workdir)
[17:40:54.590]         {
[17:40:54.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.590]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.590]             }
[17:40:54.590]             base::options(...future.oldOptions)
[17:40:54.590]             if (.Platform$OS.type == "windows") {
[17:40:54.590]                 old_names <- names(...future.oldEnvVars)
[17:40:54.590]                 envs <- base::Sys.getenv()
[17:40:54.590]                 names <- names(envs)
[17:40:54.590]                 common <- intersect(names, old_names)
[17:40:54.590]                 added <- setdiff(names, old_names)
[17:40:54.590]                 removed <- setdiff(old_names, names)
[17:40:54.590]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.590]                   envs[common]]
[17:40:54.590]                 NAMES <- toupper(changed)
[17:40:54.590]                 args <- list()
[17:40:54.590]                 for (kk in seq_along(NAMES)) {
[17:40:54.590]                   name <- changed[[kk]]
[17:40:54.590]                   NAME <- NAMES[[kk]]
[17:40:54.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.590]                     next
[17:40:54.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.590]                 }
[17:40:54.590]                 NAMES <- toupper(added)
[17:40:54.590]                 for (kk in seq_along(NAMES)) {
[17:40:54.590]                   name <- added[[kk]]
[17:40:54.590]                   NAME <- NAMES[[kk]]
[17:40:54.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.590]                     next
[17:40:54.590]                   args[[name]] <- ""
[17:40:54.590]                 }
[17:40:54.590]                 NAMES <- toupper(removed)
[17:40:54.590]                 for (kk in seq_along(NAMES)) {
[17:40:54.590]                   name <- removed[[kk]]
[17:40:54.590]                   NAME <- NAMES[[kk]]
[17:40:54.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.590]                     next
[17:40:54.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.590]                 }
[17:40:54.590]                 if (length(args) > 0) 
[17:40:54.590]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.590]             }
[17:40:54.590]             else {
[17:40:54.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.590]             }
[17:40:54.590]             {
[17:40:54.590]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.590]                   0L) {
[17:40:54.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.590]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.590]                   base::options(opts)
[17:40:54.590]                 }
[17:40:54.590]                 {
[17:40:54.590]                   {
[17:40:54.590]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.590]                     NULL
[17:40:54.590]                   }
[17:40:54.590]                   options(future.plan = NULL)
[17:40:54.590]                   if (is.na(NA_character_)) 
[17:40:54.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.590]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.590]                     envir = parent.frame()) 
[17:40:54.590]                   {
[17:40:54.590]                     default_workers <- missing(workers)
[17:40:54.590]                     if (is.function(workers)) 
[17:40:54.590]                       workers <- workers()
[17:40:54.590]                     workers <- structure(as.integer(workers), 
[17:40:54.590]                       class = class(workers))
[17:40:54.590]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.590]                       1L)
[17:40:54.590]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.590]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.590]                       if (default_workers) 
[17:40:54.590]                         supportsMulticore(warn = TRUE)
[17:40:54.590]                       return(sequential(..., envir = envir))
[17:40:54.590]                     }
[17:40:54.590]                     oopts <- options(mc.cores = workers)
[17:40:54.590]                     on.exit(options(oopts))
[17:40:54.590]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.590]                       envir = envir)
[17:40:54.590]                     if (!future$lazy) 
[17:40:54.590]                       future <- run(future)
[17:40:54.590]                     invisible(future)
[17:40:54.590]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.590]                 }
[17:40:54.590]             }
[17:40:54.590]         }
[17:40:54.590]     })
[17:40:54.590]     if (TRUE) {
[17:40:54.590]         base::sink(type = "output", split = FALSE)
[17:40:54.590]         if (TRUE) {
[17:40:54.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.590]         }
[17:40:54.590]         else {
[17:40:54.590]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.590]         }
[17:40:54.590]         base::close(...future.stdout)
[17:40:54.590]         ...future.stdout <- NULL
[17:40:54.590]     }
[17:40:54.590]     ...future.result$conditions <- ...future.conditions
[17:40:54.590]     ...future.result$finished <- base::Sys.time()
[17:40:54.590]     ...future.result
[17:40:54.590] }
[17:40:54.593] assign_globals() ...
[17:40:54.593] List of 11
[17:40:54.593]  $ ...future.FUN            :function (x, ...)  
[17:40:54.593]  $ x_FUN                    :function (x)  
[17:40:54.593]  $ times                    : int 0
[17:40:54.593]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.593]  $ stop_if_not              :function (...)  
[17:40:54.593]  $ dim                      : NULL
[17:40:54.593]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.593]  $ future.call.arguments    : list()
[17:40:54.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.593]  $ ...future.elements_ii    :List of 5
[17:40:54.593]   ..$ : int 1
[17:40:54.593]   ..$ : int 2
[17:40:54.593]   ..$ : int 3
[17:40:54.593]   ..$ : int 4
[17:40:54.593]   ..$ : int 5
[17:40:54.593]  $ ...future.seeds_ii       : NULL
[17:40:54.593]  $ ...future.globals.maxSize: NULL
[17:40:54.593]  - attr(*, "resolved")= logi FALSE
[17:40:54.593]  - attr(*, "total_size")= num 95472
[17:40:54.593]  - attr(*, "where")=List of 11
[17:40:54.593]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.593]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.593]  - attr(*, "already-done")= logi TRUE
[17:40:54.602] - copied ‘...future.FUN’ to environment
[17:40:54.602] - reassign environment for ‘x_FUN’
[17:40:54.602] - copied ‘x_FUN’ to environment
[17:40:54.602] - copied ‘times’ to environment
[17:40:54.602] - copied ‘stopf’ to environment
[17:40:54.602] - copied ‘stop_if_not’ to environment
[17:40:54.604] - copied ‘dim’ to environment
[17:40:54.604] - copied ‘valid_types’ to environment
[17:40:54.604] - copied ‘future.call.arguments’ to environment
[17:40:54.605] - copied ‘...future.elements_ii’ to environment
[17:40:54.605] - copied ‘...future.seeds_ii’ to environment
[17:40:54.605] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.605] assign_globals() ... done
[17:40:54.605] requestCore(): workers = 2
[17:40:54.608] MulticoreFuture started
[17:40:54.608] - Launch lazy future ... done
[17:40:54.609] run() for ‘MulticoreFuture’ ... done
[17:40:54.609] Created future:
[17:40:54.609] plan(): Setting new future strategy stack:
[17:40:54.610] List of future strategies:
[17:40:54.610] 1. sequential:
[17:40:54.610]    - args: function (..., envir = parent.frame())
[17:40:54.610]    - tweaked: FALSE
[17:40:54.610]    - call: NULL
[17:40:54.611] plan(): nbrOfWorkers() = 1
[17:40:54.614] plan(): Setting new future strategy stack:
[17:40:54.614] List of future strategies:
[17:40:54.614] 1. multicore:
[17:40:54.614]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.614]    - tweaked: FALSE
[17:40:54.614]    - call: plan(strategy)
[17:40:54.620] plan(): nbrOfWorkers() = 2
[17:40:54.610] MulticoreFuture:
[17:40:54.610] Label: ‘future_vapply-1’
[17:40:54.610] Expression:
[17:40:54.610] {
[17:40:54.610]     do.call(function(...) {
[17:40:54.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.610]             on.exit(options(oopts), add = TRUE)
[17:40:54.610]         }
[17:40:54.610]         {
[17:40:54.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.610]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.610]             })
[17:40:54.610]         }
[17:40:54.610]     }, args = future.call.arguments)
[17:40:54.610] }
[17:40:54.610] Lazy evaluation: FALSE
[17:40:54.610] Asynchronous evaluation: TRUE
[17:40:54.610] Local evaluation: TRUE
[17:40:54.610] Environment: R_GlobalEnv
[17:40:54.610] Capture standard output: TRUE
[17:40:54.610] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.610] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.610] Packages: 1 packages (‘future.apply’)
[17:40:54.610] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.610] Resolved: TRUE
[17:40:54.610] Value: <not collected>
[17:40:54.610] Conditions captured: <none>
[17:40:54.610] Early signaling: FALSE
[17:40:54.610] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.610] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.622] Chunk #1 of 2 ... DONE
[17:40:54.622] Chunk #2 of 2 ...
[17:40:54.622]  - Finding globals in 'X' for chunk #2 ...
[17:40:54.622] getGlobalsAndPackages() ...
[17:40:54.623] Searching for globals...
[17:40:54.623] 
[17:40:54.623] Searching for globals ... DONE
[17:40:54.623] - globals: [0] <none>
[17:40:54.624] getGlobalsAndPackages() ... DONE
[17:40:54.624]    + additional globals found: [n=0] 
[17:40:54.624]    + additional namespaces needed: [n=0] 
[17:40:54.624]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:54.624]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:54.624]  - seeds: <none>
[17:40:54.625] getGlobalsAndPackages() ...
[17:40:54.625] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.625] Resolving globals: FALSE
[17:40:54.625] Tweak future expression to call with '...' arguments ...
[17:40:54.625] {
[17:40:54.625]     do.call(function(...) {
[17:40:54.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.625]             on.exit(options(oopts), add = TRUE)
[17:40:54.625]         }
[17:40:54.625]         {
[17:40:54.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.625]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.625]             })
[17:40:54.625]         }
[17:40:54.625]     }, args = future.call.arguments)
[17:40:54.625] }
[17:40:54.626] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.627] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.627] - packages: [1] ‘future.apply’
[17:40:54.628] getGlobalsAndPackages() ... DONE
[17:40:54.628] run() for ‘Future’ ...
[17:40:54.628] - state: ‘created’
[17:40:54.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.634]   - Field: ‘label’
[17:40:54.635]   - Field: ‘local’
[17:40:54.635]   - Field: ‘owner’
[17:40:54.635]   - Field: ‘envir’
[17:40:54.635]   - Field: ‘workers’
[17:40:54.635]   - Field: ‘packages’
[17:40:54.635]   - Field: ‘gc’
[17:40:54.636]   - Field: ‘job’
[17:40:54.636]   - Field: ‘conditions’
[17:40:54.636]   - Field: ‘expr’
[17:40:54.636]   - Field: ‘uuid’
[17:40:54.636]   - Field: ‘seed’
[17:40:54.636]   - Field: ‘version’
[17:40:54.636]   - Field: ‘result’
[17:40:54.636]   - Field: ‘asynchronous’
[17:40:54.637]   - Field: ‘calls’
[17:40:54.637]   - Field: ‘globals’
[17:40:54.637]   - Field: ‘stdout’
[17:40:54.637]   - Field: ‘earlySignal’
[17:40:54.637]   - Field: ‘lazy’
[17:40:54.637]   - Field: ‘state’
[17:40:54.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.638] - Launch lazy future ...
[17:40:54.638] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.638] Packages needed by future strategies (n = 0): <none>
[17:40:54.639] {
[17:40:54.639]     {
[17:40:54.639]         {
[17:40:54.639]             ...future.startTime <- base::Sys.time()
[17:40:54.639]             {
[17:40:54.639]                 {
[17:40:54.639]                   {
[17:40:54.639]                     {
[17:40:54.639]                       {
[17:40:54.639]                         base::local({
[17:40:54.639]                           has_future <- base::requireNamespace("future", 
[17:40:54.639]                             quietly = TRUE)
[17:40:54.639]                           if (has_future) {
[17:40:54.639]                             ns <- base::getNamespace("future")
[17:40:54.639]                             version <- ns[[".package"]][["version"]]
[17:40:54.639]                             if (is.null(version)) 
[17:40:54.639]                               version <- utils::packageVersion("future")
[17:40:54.639]                           }
[17:40:54.639]                           else {
[17:40:54.639]                             version <- NULL
[17:40:54.639]                           }
[17:40:54.639]                           if (!has_future || version < "1.8.0") {
[17:40:54.639]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.639]                               "", base::R.version$version.string), 
[17:40:54.639]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.639]                                 base::R.version$platform, 8 * 
[17:40:54.639]                                   base::.Machine$sizeof.pointer), 
[17:40:54.639]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.639]                                 "release", "version")], collapse = " "), 
[17:40:54.639]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.639]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.639]                               info)
[17:40:54.639]                             info <- base::paste(info, collapse = "; ")
[17:40:54.639]                             if (!has_future) {
[17:40:54.639]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.639]                                 info)
[17:40:54.639]                             }
[17:40:54.639]                             else {
[17:40:54.639]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.639]                                 info, version)
[17:40:54.639]                             }
[17:40:54.639]                             base::stop(msg)
[17:40:54.639]                           }
[17:40:54.639]                         })
[17:40:54.639]                       }
[17:40:54.639]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.639]                       base::options(mc.cores = 1L)
[17:40:54.639]                     }
[17:40:54.639]                     base::local({
[17:40:54.639]                       for (pkg in "future.apply") {
[17:40:54.639]                         base::loadNamespace(pkg)
[17:40:54.639]                         base::library(pkg, character.only = TRUE)
[17:40:54.639]                       }
[17:40:54.639]                     })
[17:40:54.639]                   }
[17:40:54.639]                   options(future.plan = NULL)
[17:40:54.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.639]                 }
[17:40:54.639]                 ...future.workdir <- getwd()
[17:40:54.639]             }
[17:40:54.639]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.639]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.639]         }
[17:40:54.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.639]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:54.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.639]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.639]             base::names(...future.oldOptions))
[17:40:54.639]     }
[17:40:54.639]     if (FALSE) {
[17:40:54.639]     }
[17:40:54.639]     else {
[17:40:54.639]         if (TRUE) {
[17:40:54.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.639]                 open = "w")
[17:40:54.639]         }
[17:40:54.639]         else {
[17:40:54.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.639]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.639]         }
[17:40:54.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.639]             base::sink(type = "output", split = FALSE)
[17:40:54.639]             base::close(...future.stdout)
[17:40:54.639]         }, add = TRUE)
[17:40:54.639]     }
[17:40:54.639]     ...future.frame <- base::sys.nframe()
[17:40:54.639]     ...future.conditions <- base::list()
[17:40:54.639]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.639]     if (FALSE) {
[17:40:54.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.639]     }
[17:40:54.639]     ...future.result <- base::tryCatch({
[17:40:54.639]         base::withCallingHandlers({
[17:40:54.639]             ...future.value <- base::withVisible(base::local({
[17:40:54.639]                 withCallingHandlers({
[17:40:54.639]                   {
[17:40:54.639]                     do.call(function(...) {
[17:40:54.639]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.639]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.639]                         ...future.globals.maxSize)) {
[17:40:54.639]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.639]                         on.exit(options(oopts), add = TRUE)
[17:40:54.639]                       }
[17:40:54.639]                       {
[17:40:54.639]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.639]                           FUN = function(jj) {
[17:40:54.639]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.639]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.639]                           })
[17:40:54.639]                       }
[17:40:54.639]                     }, args = future.call.arguments)
[17:40:54.639]                   }
[17:40:54.639]                 }, immediateCondition = function(cond) {
[17:40:54.639]                   save_rds <- function (object, pathname, ...) 
[17:40:54.639]                   {
[17:40:54.639]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.639]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.639]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.639]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.639]                         fi_tmp[["mtime"]])
[17:40:54.639]                     }
[17:40:54.639]                     tryCatch({
[17:40:54.639]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.639]                     }, error = function(ex) {
[17:40:54.639]                       msg <- conditionMessage(ex)
[17:40:54.639]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.639]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.639]                         fi_tmp[["mtime"]], msg)
[17:40:54.639]                       ex$message <- msg
[17:40:54.639]                       stop(ex)
[17:40:54.639]                     })
[17:40:54.639]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.639]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.639]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.639]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.639]                       fi <- file.info(pathname)
[17:40:54.639]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.639]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.639]                         fi[["size"]], fi[["mtime"]])
[17:40:54.639]                       stop(msg)
[17:40:54.639]                     }
[17:40:54.639]                     invisible(pathname)
[17:40:54.639]                   }
[17:40:54.639]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.639]                     rootPath = tempdir()) 
[17:40:54.639]                   {
[17:40:54.639]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.639]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.639]                       tmpdir = path, fileext = ".rds")
[17:40:54.639]                     save_rds(obj, file)
[17:40:54.639]                   }
[17:40:54.639]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.639]                   {
[17:40:54.639]                     inherits <- base::inherits
[17:40:54.639]                     invokeRestart <- base::invokeRestart
[17:40:54.639]                     is.null <- base::is.null
[17:40:54.639]                     muffled <- FALSE
[17:40:54.639]                     if (inherits(cond, "message")) {
[17:40:54.639]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.639]                       if (muffled) 
[17:40:54.639]                         invokeRestart("muffleMessage")
[17:40:54.639]                     }
[17:40:54.639]                     else if (inherits(cond, "warning")) {
[17:40:54.639]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.639]                       if (muffled) 
[17:40:54.639]                         invokeRestart("muffleWarning")
[17:40:54.639]                     }
[17:40:54.639]                     else if (inherits(cond, "condition")) {
[17:40:54.639]                       if (!is.null(pattern)) {
[17:40:54.639]                         computeRestarts <- base::computeRestarts
[17:40:54.639]                         grepl <- base::grepl
[17:40:54.639]                         restarts <- computeRestarts(cond)
[17:40:54.639]                         for (restart in restarts) {
[17:40:54.639]                           name <- restart$name
[17:40:54.639]                           if (is.null(name)) 
[17:40:54.639]                             next
[17:40:54.639]                           if (!grepl(pattern, name)) 
[17:40:54.639]                             next
[17:40:54.639]                           invokeRestart(restart)
[17:40:54.639]                           muffled <- TRUE
[17:40:54.639]                           break
[17:40:54.639]                         }
[17:40:54.639]                       }
[17:40:54.639]                     }
[17:40:54.639]                     invisible(muffled)
[17:40:54.639]                   }
[17:40:54.639]                   muffleCondition(cond)
[17:40:54.639]                 })
[17:40:54.639]             }))
[17:40:54.639]             future::FutureResult(value = ...future.value$value, 
[17:40:54.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.639]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.639]                     ...future.globalenv.names))
[17:40:54.639]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.639]         }, condition = base::local({
[17:40:54.639]             c <- base::c
[17:40:54.639]             inherits <- base::inherits
[17:40:54.639]             invokeRestart <- base::invokeRestart
[17:40:54.639]             length <- base::length
[17:40:54.639]             list <- base::list
[17:40:54.639]             seq.int <- base::seq.int
[17:40:54.639]             signalCondition <- base::signalCondition
[17:40:54.639]             sys.calls <- base::sys.calls
[17:40:54.639]             `[[` <- base::`[[`
[17:40:54.639]             `+` <- base::`+`
[17:40:54.639]             `<<-` <- base::`<<-`
[17:40:54.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.639]                   3L)]
[17:40:54.639]             }
[17:40:54.639]             function(cond) {
[17:40:54.639]                 is_error <- inherits(cond, "error")
[17:40:54.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.639]                   NULL)
[17:40:54.639]                 if (is_error) {
[17:40:54.639]                   sessionInformation <- function() {
[17:40:54.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.639]                       search = base::search(), system = base::Sys.info())
[17:40:54.639]                   }
[17:40:54.639]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.639]                     cond$call), session = sessionInformation(), 
[17:40:54.639]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.639]                   signalCondition(cond)
[17:40:54.639]                 }
[17:40:54.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.639]                 "immediateCondition"))) {
[17:40:54.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.639]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.639]                   if (TRUE && !signal) {
[17:40:54.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.639]                     {
[17:40:54.639]                       inherits <- base::inherits
[17:40:54.639]                       invokeRestart <- base::invokeRestart
[17:40:54.639]                       is.null <- base::is.null
[17:40:54.639]                       muffled <- FALSE
[17:40:54.639]                       if (inherits(cond, "message")) {
[17:40:54.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.639]                         if (muffled) 
[17:40:54.639]                           invokeRestart("muffleMessage")
[17:40:54.639]                       }
[17:40:54.639]                       else if (inherits(cond, "warning")) {
[17:40:54.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.639]                         if (muffled) 
[17:40:54.639]                           invokeRestart("muffleWarning")
[17:40:54.639]                       }
[17:40:54.639]                       else if (inherits(cond, "condition")) {
[17:40:54.639]                         if (!is.null(pattern)) {
[17:40:54.639]                           computeRestarts <- base::computeRestarts
[17:40:54.639]                           grepl <- base::grepl
[17:40:54.639]                           restarts <- computeRestarts(cond)
[17:40:54.639]                           for (restart in restarts) {
[17:40:54.639]                             name <- restart$name
[17:40:54.639]                             if (is.null(name)) 
[17:40:54.639]                               next
[17:40:54.639]                             if (!grepl(pattern, name)) 
[17:40:54.639]                               next
[17:40:54.639]                             invokeRestart(restart)
[17:40:54.639]                             muffled <- TRUE
[17:40:54.639]                             break
[17:40:54.639]                           }
[17:40:54.639]                         }
[17:40:54.639]                       }
[17:40:54.639]                       invisible(muffled)
[17:40:54.639]                     }
[17:40:54.639]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.639]                   }
[17:40:54.639]                 }
[17:40:54.639]                 else {
[17:40:54.639]                   if (TRUE) {
[17:40:54.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.639]                     {
[17:40:54.639]                       inherits <- base::inherits
[17:40:54.639]                       invokeRestart <- base::invokeRestart
[17:40:54.639]                       is.null <- base::is.null
[17:40:54.639]                       muffled <- FALSE
[17:40:54.639]                       if (inherits(cond, "message")) {
[17:40:54.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.639]                         if (muffled) 
[17:40:54.639]                           invokeRestart("muffleMessage")
[17:40:54.639]                       }
[17:40:54.639]                       else if (inherits(cond, "warning")) {
[17:40:54.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.639]                         if (muffled) 
[17:40:54.639]                           invokeRestart("muffleWarning")
[17:40:54.639]                       }
[17:40:54.639]                       else if (inherits(cond, "condition")) {
[17:40:54.639]                         if (!is.null(pattern)) {
[17:40:54.639]                           computeRestarts <- base::computeRestarts
[17:40:54.639]                           grepl <- base::grepl
[17:40:54.639]                           restarts <- computeRestarts(cond)
[17:40:54.639]                           for (restart in restarts) {
[17:40:54.639]                             name <- restart$name
[17:40:54.639]                             if (is.null(name)) 
[17:40:54.639]                               next
[17:40:54.639]                             if (!grepl(pattern, name)) 
[17:40:54.639]                               next
[17:40:54.639]                             invokeRestart(restart)
[17:40:54.639]                             muffled <- TRUE
[17:40:54.639]                             break
[17:40:54.639]                           }
[17:40:54.639]                         }
[17:40:54.639]                       }
[17:40:54.639]                       invisible(muffled)
[17:40:54.639]                     }
[17:40:54.639]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.639]                   }
[17:40:54.639]                 }
[17:40:54.639]             }
[17:40:54.639]         }))
[17:40:54.639]     }, error = function(ex) {
[17:40:54.639]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.639]                 ...future.rng), started = ...future.startTime, 
[17:40:54.639]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.639]             version = "1.8"), class = "FutureResult")
[17:40:54.639]     }, finally = {
[17:40:54.639]         if (!identical(...future.workdir, getwd())) 
[17:40:54.639]             setwd(...future.workdir)
[17:40:54.639]         {
[17:40:54.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.639]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.639]             }
[17:40:54.639]             base::options(...future.oldOptions)
[17:40:54.639]             if (.Platform$OS.type == "windows") {
[17:40:54.639]                 old_names <- names(...future.oldEnvVars)
[17:40:54.639]                 envs <- base::Sys.getenv()
[17:40:54.639]                 names <- names(envs)
[17:40:54.639]                 common <- intersect(names, old_names)
[17:40:54.639]                 added <- setdiff(names, old_names)
[17:40:54.639]                 removed <- setdiff(old_names, names)
[17:40:54.639]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.639]                   envs[common]]
[17:40:54.639]                 NAMES <- toupper(changed)
[17:40:54.639]                 args <- list()
[17:40:54.639]                 for (kk in seq_along(NAMES)) {
[17:40:54.639]                   name <- changed[[kk]]
[17:40:54.639]                   NAME <- NAMES[[kk]]
[17:40:54.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.639]                     next
[17:40:54.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.639]                 }
[17:40:54.639]                 NAMES <- toupper(added)
[17:40:54.639]                 for (kk in seq_along(NAMES)) {
[17:40:54.639]                   name <- added[[kk]]
[17:40:54.639]                   NAME <- NAMES[[kk]]
[17:40:54.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.639]                     next
[17:40:54.639]                   args[[name]] <- ""
[17:40:54.639]                 }
[17:40:54.639]                 NAMES <- toupper(removed)
[17:40:54.639]                 for (kk in seq_along(NAMES)) {
[17:40:54.639]                   name <- removed[[kk]]
[17:40:54.639]                   NAME <- NAMES[[kk]]
[17:40:54.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.639]                     next
[17:40:54.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.639]                 }
[17:40:54.639]                 if (length(args) > 0) 
[17:40:54.639]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.639]             }
[17:40:54.639]             else {
[17:40:54.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.639]             }
[17:40:54.639]             {
[17:40:54.639]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.639]                   0L) {
[17:40:54.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.639]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.639]                   base::options(opts)
[17:40:54.639]                 }
[17:40:54.639]                 {
[17:40:54.639]                   {
[17:40:54.639]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.639]                     NULL
[17:40:54.639]                   }
[17:40:54.639]                   options(future.plan = NULL)
[17:40:54.639]                   if (is.na(NA_character_)) 
[17:40:54.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.639]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.639]                     envir = parent.frame()) 
[17:40:54.639]                   {
[17:40:54.639]                     default_workers <- missing(workers)
[17:40:54.639]                     if (is.function(workers)) 
[17:40:54.639]                       workers <- workers()
[17:40:54.639]                     workers <- structure(as.integer(workers), 
[17:40:54.639]                       class = class(workers))
[17:40:54.639]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.639]                       1L)
[17:40:54.639]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.639]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.639]                       if (default_workers) 
[17:40:54.639]                         supportsMulticore(warn = TRUE)
[17:40:54.639]                       return(sequential(..., envir = envir))
[17:40:54.639]                     }
[17:40:54.639]                     oopts <- options(mc.cores = workers)
[17:40:54.639]                     on.exit(options(oopts))
[17:40:54.639]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.639]                       envir = envir)
[17:40:54.639]                     if (!future$lazy) 
[17:40:54.639]                       future <- run(future)
[17:40:54.639]                     invisible(future)
[17:40:54.639]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.639]                 }
[17:40:54.639]             }
[17:40:54.639]         }
[17:40:54.639]     })
[17:40:54.639]     if (TRUE) {
[17:40:54.639]         base::sink(type = "output", split = FALSE)
[17:40:54.639]         if (TRUE) {
[17:40:54.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.639]         }
[17:40:54.639]         else {
[17:40:54.639]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.639]         }
[17:40:54.639]         base::close(...future.stdout)
[17:40:54.639]         ...future.stdout <- NULL
[17:40:54.639]     }
[17:40:54.639]     ...future.result$conditions <- ...future.conditions
[17:40:54.639]     ...future.result$finished <- base::Sys.time()
[17:40:54.639]     ...future.result
[17:40:54.639] }
[17:40:54.642] assign_globals() ...
[17:40:54.643] List of 11
[17:40:54.643]  $ ...future.FUN            :function (x, ...)  
[17:40:54.643]  $ x_FUN                    :function (x)  
[17:40:54.643]  $ times                    : int 0
[17:40:54.643]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.643]  $ stop_if_not              :function (...)  
[17:40:54.643]  $ dim                      : NULL
[17:40:54.643]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.643]  $ future.call.arguments    : list()
[17:40:54.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.643]  $ ...future.elements_ii    :List of 5
[17:40:54.643]   ..$ : int 6
[17:40:54.643]   ..$ : int 7
[17:40:54.643]   ..$ : int 8
[17:40:54.643]   ..$ : int 9
[17:40:54.643]   ..$ : int 10
[17:40:54.643]  $ ...future.seeds_ii       : NULL
[17:40:54.643]  $ ...future.globals.maxSize: NULL
[17:40:54.643]  - attr(*, "resolved")= logi FALSE
[17:40:54.643]  - attr(*, "total_size")= num 95472
[17:40:54.643]  - attr(*, "where")=List of 11
[17:40:54.643]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.643]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.643]  - attr(*, "already-done")= logi TRUE
[17:40:54.656] - copied ‘...future.FUN’ to environment
[17:40:54.656] - reassign environment for ‘x_FUN’
[17:40:54.656] - copied ‘x_FUN’ to environment
[17:40:54.656] - copied ‘times’ to environment
[17:40:54.657] - copied ‘stopf’ to environment
[17:40:54.657] - copied ‘stop_if_not’ to environment
[17:40:54.657] - copied ‘dim’ to environment
[17:40:54.657] - copied ‘valid_types’ to environment
[17:40:54.657] - copied ‘future.call.arguments’ to environment
[17:40:54.657] - copied ‘...future.elements_ii’ to environment
[17:40:54.657] - copied ‘...future.seeds_ii’ to environment
[17:40:54.657] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.657] assign_globals() ... done
[17:40:54.658] requestCore(): workers = 2
[17:40:54.660] MulticoreFuture started
[17:40:54.661] - Launch lazy future ... done
[17:40:54.661] run() for ‘MulticoreFuture’ ... done
[17:40:54.662] Created future:
[17:40:54.662] plan(): Setting new future strategy stack:
[17:40:54.663] List of future strategies:
[17:40:54.663] 1. sequential:
[17:40:54.663]    - args: function (..., envir = parent.frame())
[17:40:54.663]    - tweaked: FALSE
[17:40:54.663]    - call: NULL
[17:40:54.664] plan(): nbrOfWorkers() = 1
[17:40:54.667] plan(): Setting new future strategy stack:
[17:40:54.667] List of future strategies:
[17:40:54.667] 1. multicore:
[17:40:54.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.667]    - tweaked: FALSE
[17:40:54.667]    - call: plan(strategy)
[17:40:54.673] plan(): nbrOfWorkers() = 2
[17:40:54.663] MulticoreFuture:
[17:40:54.663] Label: ‘future_vapply-2’
[17:40:54.663] Expression:
[17:40:54.663] {
[17:40:54.663]     do.call(function(...) {
[17:40:54.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.663]             on.exit(options(oopts), add = TRUE)
[17:40:54.663]         }
[17:40:54.663]         {
[17:40:54.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.663]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.663]             })
[17:40:54.663]         }
[17:40:54.663]     }, args = future.call.arguments)
[17:40:54.663] }
[17:40:54.663] Lazy evaluation: FALSE
[17:40:54.663] Asynchronous evaluation: TRUE
[17:40:54.663] Local evaluation: TRUE
[17:40:54.663] Environment: R_GlobalEnv
[17:40:54.663] Capture standard output: TRUE
[17:40:54.663] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.663] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.663] Packages: 1 packages (‘future.apply’)
[17:40:54.663] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.663] Resolved: TRUE
[17:40:54.663] Value: <not collected>
[17:40:54.663] Conditions captured: <none>
[17:40:54.663] Early signaling: FALSE
[17:40:54.663] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.663] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.674] Chunk #2 of 2 ... DONE
[17:40:54.674] Launching 2 futures (chunks) ... DONE
[17:40:54.674] Resolving 2 futures (chunks) ...
[17:40:54.674] resolve() on list ...
[17:40:54.674]  recursive: 0
[17:40:54.675]  length: 2
[17:40:54.675] 
[17:40:54.675] Future #1
[17:40:54.676] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:54.676] - nx: 2
[17:40:54.677] - relay: TRUE
[17:40:54.677] - stdout: TRUE
[17:40:54.677] - signal: TRUE
[17:40:54.677] - resignal: FALSE
[17:40:54.677] - force: TRUE
[17:40:54.677] - relayed: [n=2] FALSE, FALSE
[17:40:54.678] - queued futures: [n=2] FALSE, FALSE
[17:40:54.678]  - until=1
[17:40:54.678]  - relaying element #1
[17:40:54.678] - relayed: [n=2] TRUE, FALSE
[17:40:54.678] - queued futures: [n=2] TRUE, FALSE
[17:40:54.679] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:54.679]  length: 1 (resolved future 1)
[17:40:54.679] Future #2
[17:40:54.680] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:54.680] - nx: 2
[17:40:54.680] - relay: TRUE
[17:40:54.681] - stdout: TRUE
[17:40:54.681] - signal: TRUE
[17:40:54.681] - resignal: FALSE
[17:40:54.681] - force: TRUE
[17:40:54.681] - relayed: [n=2] TRUE, FALSE
[17:40:54.681] - queued futures: [n=2] TRUE, FALSE
[17:40:54.681]  - until=2
[17:40:54.681]  - relaying element #2
[17:40:54.682] - relayed: [n=2] TRUE, TRUE
[17:40:54.682] - queued futures: [n=2] TRUE, TRUE
[17:40:54.682] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:54.682]  length: 0 (resolved future 2)
[17:40:54.682] Relaying remaining futures
[17:40:54.682] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.683] - nx: 2
[17:40:54.683] - relay: TRUE
[17:40:54.683] - stdout: TRUE
[17:40:54.683] - signal: TRUE
[17:40:54.683] - resignal: FALSE
[17:40:54.683] - force: TRUE
[17:40:54.683] - relayed: [n=2] TRUE, TRUE
[17:40:54.683] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:54.683] - relayed: [n=2] TRUE, TRUE
[17:40:54.684] - queued futures: [n=2] TRUE, TRUE
[17:40:54.684] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.684] resolve() on list ... DONE
[17:40:54.684]  - Number of value chunks collected: 2
[17:40:54.684] Resolving 2 futures (chunks) ... DONE
[17:40:54.684] Reducing values from 2 chunks ...
[17:40:54.684]  - Number of values collected after concatenation: 10
[17:40:54.685]  - Number of values expected: 10
[17:40:54.685] Reducing values from 2 chunks ... DONE
[17:40:54.685] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:40:54.686] future_lapply() ...
[17:40:54.692] Number of chunks: 2
[17:40:54.692] getGlobalsAndPackagesXApply() ...
[17:40:54.692]  - future.globals: TRUE
[17:40:54.693] getGlobalsAndPackages() ...
[17:40:54.693] Searching for globals...
[17:40:54.697] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:40:54.698] Searching for globals ... DONE
[17:40:54.698] Resolving globals: FALSE
[17:40:54.701] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:40:54.701] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.702] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.702] - packages: [1] ‘future.apply’
[17:40:54.702] getGlobalsAndPackages() ... DONE
[17:40:54.702]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.702]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.702] Finding globals ... DONE
[17:40:54.702]  - use_args: TRUE
[17:40:54.703]  - Getting '...' globals ...
[17:40:54.703] resolve() on list ...
[17:40:54.703]  recursive: 0
[17:40:54.703]  length: 1
[17:40:54.703]  elements: ‘...’
[17:40:54.704]  length: 0 (resolved future 1)
[17:40:54.704] resolve() on list ... DONE
[17:40:54.704]    - '...' content: [n=0] 
[17:40:54.704] List of 1
[17:40:54.704]  $ ...: list()
[17:40:54.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.704]  - attr(*, "where")=List of 1
[17:40:54.704]   ..$ ...:<environment: 0x564f2fc58328> 
[17:40:54.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.704]  - attr(*, "resolved")= logi TRUE
[17:40:54.704]  - attr(*, "total_size")= num NA
[17:40:54.707]  - Getting '...' globals ... DONE
[17:40:54.707] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.707] List of 8
[17:40:54.707]  $ ...future.FUN:function (x, ...)  
[17:40:54.707]  $ x_FUN        :function (x)  
[17:40:54.707]  $ times        : int 0
[17:40:54.707]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.707]  $ stop_if_not  :function (...)  
[17:40:54.707]  $ dim          : NULL
[17:40:54.707]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:54.707]  $ ...          : list()
[17:40:54.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.707]  - attr(*, "where")=List of 8
[17:40:54.707]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.707]   ..$ ...          :<environment: 0x564f2fc58328> 
[17:40:54.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.707]  - attr(*, "resolved")= logi FALSE
[17:40:54.707]  - attr(*, "total_size")= num 95400
[17:40:54.712] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.713] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.713] Number of futures (= number of chunks): 2
[17:40:54.713] Launching 2 futures (chunks) ...
[17:40:54.713] Chunk #1 of 2 ...
[17:40:54.713]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.713] getGlobalsAndPackages() ...
[17:40:54.713] Searching for globals...
[17:40:54.714] 
[17:40:54.714] Searching for globals ... DONE
[17:40:54.714] - globals: [0] <none>
[17:40:54.714] getGlobalsAndPackages() ... DONE
[17:40:54.714]    + additional globals found: [n=0] 
[17:40:54.714]    + additional namespaces needed: [n=0] 
[17:40:54.714]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.714]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:54.714]  - seeds: <none>
[17:40:54.714] getGlobalsAndPackages() ...
[17:40:54.715] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.715] Resolving globals: FALSE
[17:40:54.715] Tweak future expression to call with '...' arguments ...
[17:40:54.715] {
[17:40:54.715]     do.call(function(...) {
[17:40:54.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.715]             on.exit(options(oopts), add = TRUE)
[17:40:54.715]         }
[17:40:54.715]         {
[17:40:54.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.715]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.715]             })
[17:40:54.715]         }
[17:40:54.715]     }, args = future.call.arguments)
[17:40:54.715] }
[17:40:54.715] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.716] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.716] - packages: [1] ‘future.apply’
[17:40:54.716] getGlobalsAndPackages() ... DONE
[17:40:54.716] run() for ‘Future’ ...
[17:40:54.716] - state: ‘created’
[17:40:54.717] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.721]   - Field: ‘label’
[17:40:54.721]   - Field: ‘local’
[17:40:54.721]   - Field: ‘owner’
[17:40:54.721]   - Field: ‘envir’
[17:40:54.721]   - Field: ‘workers’
[17:40:54.722]   - Field: ‘packages’
[17:40:54.722]   - Field: ‘gc’
[17:40:54.722]   - Field: ‘job’
[17:40:54.722]   - Field: ‘conditions’
[17:40:54.722]   - Field: ‘expr’
[17:40:54.722]   - Field: ‘uuid’
[17:40:54.722]   - Field: ‘seed’
[17:40:54.722]   - Field: ‘version’
[17:40:54.722]   - Field: ‘result’
[17:40:54.722]   - Field: ‘asynchronous’
[17:40:54.723]   - Field: ‘calls’
[17:40:54.723]   - Field: ‘globals’
[17:40:54.723]   - Field: ‘stdout’
[17:40:54.723]   - Field: ‘earlySignal’
[17:40:54.723]   - Field: ‘lazy’
[17:40:54.723]   - Field: ‘state’
[17:40:54.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.723] - Launch lazy future ...
[17:40:54.725] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.725] Packages needed by future strategies (n = 0): <none>
[17:40:54.726] {
[17:40:54.726]     {
[17:40:54.726]         {
[17:40:54.726]             ...future.startTime <- base::Sys.time()
[17:40:54.726]             {
[17:40:54.726]                 {
[17:40:54.726]                   {
[17:40:54.726]                     {
[17:40:54.726]                       {
[17:40:54.726]                         base::local({
[17:40:54.726]                           has_future <- base::requireNamespace("future", 
[17:40:54.726]                             quietly = TRUE)
[17:40:54.726]                           if (has_future) {
[17:40:54.726]                             ns <- base::getNamespace("future")
[17:40:54.726]                             version <- ns[[".package"]][["version"]]
[17:40:54.726]                             if (is.null(version)) 
[17:40:54.726]                               version <- utils::packageVersion("future")
[17:40:54.726]                           }
[17:40:54.726]                           else {
[17:40:54.726]                             version <- NULL
[17:40:54.726]                           }
[17:40:54.726]                           if (!has_future || version < "1.8.0") {
[17:40:54.726]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.726]                               "", base::R.version$version.string), 
[17:40:54.726]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.726]                                 base::R.version$platform, 8 * 
[17:40:54.726]                                   base::.Machine$sizeof.pointer), 
[17:40:54.726]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.726]                                 "release", "version")], collapse = " "), 
[17:40:54.726]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.726]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.726]                               info)
[17:40:54.726]                             info <- base::paste(info, collapse = "; ")
[17:40:54.726]                             if (!has_future) {
[17:40:54.726]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.726]                                 info)
[17:40:54.726]                             }
[17:40:54.726]                             else {
[17:40:54.726]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.726]                                 info, version)
[17:40:54.726]                             }
[17:40:54.726]                             base::stop(msg)
[17:40:54.726]                           }
[17:40:54.726]                         })
[17:40:54.726]                       }
[17:40:54.726]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.726]                       base::options(mc.cores = 1L)
[17:40:54.726]                     }
[17:40:54.726]                     base::local({
[17:40:54.726]                       for (pkg in "future.apply") {
[17:40:54.726]                         base::loadNamespace(pkg)
[17:40:54.726]                         base::library(pkg, character.only = TRUE)
[17:40:54.726]                       }
[17:40:54.726]                     })
[17:40:54.726]                   }
[17:40:54.726]                   options(future.plan = NULL)
[17:40:54.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.726]                 }
[17:40:54.726]                 ...future.workdir <- getwd()
[17:40:54.726]             }
[17:40:54.726]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.726]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.726]         }
[17:40:54.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.726]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:54.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.726]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.726]             base::names(...future.oldOptions))
[17:40:54.726]     }
[17:40:54.726]     if (FALSE) {
[17:40:54.726]     }
[17:40:54.726]     else {
[17:40:54.726]         if (TRUE) {
[17:40:54.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.726]                 open = "w")
[17:40:54.726]         }
[17:40:54.726]         else {
[17:40:54.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.726]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.726]         }
[17:40:54.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.726]             base::sink(type = "output", split = FALSE)
[17:40:54.726]             base::close(...future.stdout)
[17:40:54.726]         }, add = TRUE)
[17:40:54.726]     }
[17:40:54.726]     ...future.frame <- base::sys.nframe()
[17:40:54.726]     ...future.conditions <- base::list()
[17:40:54.726]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.726]     if (FALSE) {
[17:40:54.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.726]     }
[17:40:54.726]     ...future.result <- base::tryCatch({
[17:40:54.726]         base::withCallingHandlers({
[17:40:54.726]             ...future.value <- base::withVisible(base::local({
[17:40:54.726]                 withCallingHandlers({
[17:40:54.726]                   {
[17:40:54.726]                     do.call(function(...) {
[17:40:54.726]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.726]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.726]                         ...future.globals.maxSize)) {
[17:40:54.726]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.726]                         on.exit(options(oopts), add = TRUE)
[17:40:54.726]                       }
[17:40:54.726]                       {
[17:40:54.726]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.726]                           FUN = function(jj) {
[17:40:54.726]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.726]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.726]                           })
[17:40:54.726]                       }
[17:40:54.726]                     }, args = future.call.arguments)
[17:40:54.726]                   }
[17:40:54.726]                 }, immediateCondition = function(cond) {
[17:40:54.726]                   save_rds <- function (object, pathname, ...) 
[17:40:54.726]                   {
[17:40:54.726]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.726]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.726]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.726]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.726]                         fi_tmp[["mtime"]])
[17:40:54.726]                     }
[17:40:54.726]                     tryCatch({
[17:40:54.726]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.726]                     }, error = function(ex) {
[17:40:54.726]                       msg <- conditionMessage(ex)
[17:40:54.726]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.726]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.726]                         fi_tmp[["mtime"]], msg)
[17:40:54.726]                       ex$message <- msg
[17:40:54.726]                       stop(ex)
[17:40:54.726]                     })
[17:40:54.726]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.726]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.726]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.726]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.726]                       fi <- file.info(pathname)
[17:40:54.726]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.726]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.726]                         fi[["size"]], fi[["mtime"]])
[17:40:54.726]                       stop(msg)
[17:40:54.726]                     }
[17:40:54.726]                     invisible(pathname)
[17:40:54.726]                   }
[17:40:54.726]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.726]                     rootPath = tempdir()) 
[17:40:54.726]                   {
[17:40:54.726]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.726]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.726]                       tmpdir = path, fileext = ".rds")
[17:40:54.726]                     save_rds(obj, file)
[17:40:54.726]                   }
[17:40:54.726]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.726]                   {
[17:40:54.726]                     inherits <- base::inherits
[17:40:54.726]                     invokeRestart <- base::invokeRestart
[17:40:54.726]                     is.null <- base::is.null
[17:40:54.726]                     muffled <- FALSE
[17:40:54.726]                     if (inherits(cond, "message")) {
[17:40:54.726]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.726]                       if (muffled) 
[17:40:54.726]                         invokeRestart("muffleMessage")
[17:40:54.726]                     }
[17:40:54.726]                     else if (inherits(cond, "warning")) {
[17:40:54.726]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.726]                       if (muffled) 
[17:40:54.726]                         invokeRestart("muffleWarning")
[17:40:54.726]                     }
[17:40:54.726]                     else if (inherits(cond, "condition")) {
[17:40:54.726]                       if (!is.null(pattern)) {
[17:40:54.726]                         computeRestarts <- base::computeRestarts
[17:40:54.726]                         grepl <- base::grepl
[17:40:54.726]                         restarts <- computeRestarts(cond)
[17:40:54.726]                         for (restart in restarts) {
[17:40:54.726]                           name <- restart$name
[17:40:54.726]                           if (is.null(name)) 
[17:40:54.726]                             next
[17:40:54.726]                           if (!grepl(pattern, name)) 
[17:40:54.726]                             next
[17:40:54.726]                           invokeRestart(restart)
[17:40:54.726]                           muffled <- TRUE
[17:40:54.726]                           break
[17:40:54.726]                         }
[17:40:54.726]                       }
[17:40:54.726]                     }
[17:40:54.726]                     invisible(muffled)
[17:40:54.726]                   }
[17:40:54.726]                   muffleCondition(cond)
[17:40:54.726]                 })
[17:40:54.726]             }))
[17:40:54.726]             future::FutureResult(value = ...future.value$value, 
[17:40:54.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.726]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.726]                     ...future.globalenv.names))
[17:40:54.726]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.726]         }, condition = base::local({
[17:40:54.726]             c <- base::c
[17:40:54.726]             inherits <- base::inherits
[17:40:54.726]             invokeRestart <- base::invokeRestart
[17:40:54.726]             length <- base::length
[17:40:54.726]             list <- base::list
[17:40:54.726]             seq.int <- base::seq.int
[17:40:54.726]             signalCondition <- base::signalCondition
[17:40:54.726]             sys.calls <- base::sys.calls
[17:40:54.726]             `[[` <- base::`[[`
[17:40:54.726]             `+` <- base::`+`
[17:40:54.726]             `<<-` <- base::`<<-`
[17:40:54.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.726]                   3L)]
[17:40:54.726]             }
[17:40:54.726]             function(cond) {
[17:40:54.726]                 is_error <- inherits(cond, "error")
[17:40:54.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.726]                   NULL)
[17:40:54.726]                 if (is_error) {
[17:40:54.726]                   sessionInformation <- function() {
[17:40:54.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.726]                       search = base::search(), system = base::Sys.info())
[17:40:54.726]                   }
[17:40:54.726]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.726]                     cond$call), session = sessionInformation(), 
[17:40:54.726]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.726]                   signalCondition(cond)
[17:40:54.726]                 }
[17:40:54.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.726]                 "immediateCondition"))) {
[17:40:54.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.726]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.726]                   if (TRUE && !signal) {
[17:40:54.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.726]                     {
[17:40:54.726]                       inherits <- base::inherits
[17:40:54.726]                       invokeRestart <- base::invokeRestart
[17:40:54.726]                       is.null <- base::is.null
[17:40:54.726]                       muffled <- FALSE
[17:40:54.726]                       if (inherits(cond, "message")) {
[17:40:54.726]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.726]                         if (muffled) 
[17:40:54.726]                           invokeRestart("muffleMessage")
[17:40:54.726]                       }
[17:40:54.726]                       else if (inherits(cond, "warning")) {
[17:40:54.726]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.726]                         if (muffled) 
[17:40:54.726]                           invokeRestart("muffleWarning")
[17:40:54.726]                       }
[17:40:54.726]                       else if (inherits(cond, "condition")) {
[17:40:54.726]                         if (!is.null(pattern)) {
[17:40:54.726]                           computeRestarts <- base::computeRestarts
[17:40:54.726]                           grepl <- base::grepl
[17:40:54.726]                           restarts <- computeRestarts(cond)
[17:40:54.726]                           for (restart in restarts) {
[17:40:54.726]                             name <- restart$name
[17:40:54.726]                             if (is.null(name)) 
[17:40:54.726]                               next
[17:40:54.726]                             if (!grepl(pattern, name)) 
[17:40:54.726]                               next
[17:40:54.726]                             invokeRestart(restart)
[17:40:54.726]                             muffled <- TRUE
[17:40:54.726]                             break
[17:40:54.726]                           }
[17:40:54.726]                         }
[17:40:54.726]                       }
[17:40:54.726]                       invisible(muffled)
[17:40:54.726]                     }
[17:40:54.726]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.726]                   }
[17:40:54.726]                 }
[17:40:54.726]                 else {
[17:40:54.726]                   if (TRUE) {
[17:40:54.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.726]                     {
[17:40:54.726]                       inherits <- base::inherits
[17:40:54.726]                       invokeRestart <- base::invokeRestart
[17:40:54.726]                       is.null <- base::is.null
[17:40:54.726]                       muffled <- FALSE
[17:40:54.726]                       if (inherits(cond, "message")) {
[17:40:54.726]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.726]                         if (muffled) 
[17:40:54.726]                           invokeRestart("muffleMessage")
[17:40:54.726]                       }
[17:40:54.726]                       else if (inherits(cond, "warning")) {
[17:40:54.726]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.726]                         if (muffled) 
[17:40:54.726]                           invokeRestart("muffleWarning")
[17:40:54.726]                       }
[17:40:54.726]                       else if (inherits(cond, "condition")) {
[17:40:54.726]                         if (!is.null(pattern)) {
[17:40:54.726]                           computeRestarts <- base::computeRestarts
[17:40:54.726]                           grepl <- base::grepl
[17:40:54.726]                           restarts <- computeRestarts(cond)
[17:40:54.726]                           for (restart in restarts) {
[17:40:54.726]                             name <- restart$name
[17:40:54.726]                             if (is.null(name)) 
[17:40:54.726]                               next
[17:40:54.726]                             if (!grepl(pattern, name)) 
[17:40:54.726]                               next
[17:40:54.726]                             invokeRestart(restart)
[17:40:54.726]                             muffled <- TRUE
[17:40:54.726]                             break
[17:40:54.726]                           }
[17:40:54.726]                         }
[17:40:54.726]                       }
[17:40:54.726]                       invisible(muffled)
[17:40:54.726]                     }
[17:40:54.726]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.726]                   }
[17:40:54.726]                 }
[17:40:54.726]             }
[17:40:54.726]         }))
[17:40:54.726]     }, error = function(ex) {
[17:40:54.726]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.726]                 ...future.rng), started = ...future.startTime, 
[17:40:54.726]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.726]             version = "1.8"), class = "FutureResult")
[17:40:54.726]     }, finally = {
[17:40:54.726]         if (!identical(...future.workdir, getwd())) 
[17:40:54.726]             setwd(...future.workdir)
[17:40:54.726]         {
[17:40:54.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.726]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.726]             }
[17:40:54.726]             base::options(...future.oldOptions)
[17:40:54.726]             if (.Platform$OS.type == "windows") {
[17:40:54.726]                 old_names <- names(...future.oldEnvVars)
[17:40:54.726]                 envs <- base::Sys.getenv()
[17:40:54.726]                 names <- names(envs)
[17:40:54.726]                 common <- intersect(names, old_names)
[17:40:54.726]                 added <- setdiff(names, old_names)
[17:40:54.726]                 removed <- setdiff(old_names, names)
[17:40:54.726]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.726]                   envs[common]]
[17:40:54.726]                 NAMES <- toupper(changed)
[17:40:54.726]                 args <- list()
[17:40:54.726]                 for (kk in seq_along(NAMES)) {
[17:40:54.726]                   name <- changed[[kk]]
[17:40:54.726]                   NAME <- NAMES[[kk]]
[17:40:54.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.726]                     next
[17:40:54.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.726]                 }
[17:40:54.726]                 NAMES <- toupper(added)
[17:40:54.726]                 for (kk in seq_along(NAMES)) {
[17:40:54.726]                   name <- added[[kk]]
[17:40:54.726]                   NAME <- NAMES[[kk]]
[17:40:54.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.726]                     next
[17:40:54.726]                   args[[name]] <- ""
[17:40:54.726]                 }
[17:40:54.726]                 NAMES <- toupper(removed)
[17:40:54.726]                 for (kk in seq_along(NAMES)) {
[17:40:54.726]                   name <- removed[[kk]]
[17:40:54.726]                   NAME <- NAMES[[kk]]
[17:40:54.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.726]                     next
[17:40:54.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.726]                 }
[17:40:54.726]                 if (length(args) > 0) 
[17:40:54.726]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.726]             }
[17:40:54.726]             else {
[17:40:54.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.726]             }
[17:40:54.726]             {
[17:40:54.726]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.726]                   0L) {
[17:40:54.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.726]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.726]                   base::options(opts)
[17:40:54.726]                 }
[17:40:54.726]                 {
[17:40:54.726]                   {
[17:40:54.726]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.726]                     NULL
[17:40:54.726]                   }
[17:40:54.726]                   options(future.plan = NULL)
[17:40:54.726]                   if (is.na(NA_character_)) 
[17:40:54.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.726]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.726]                     envir = parent.frame()) 
[17:40:54.726]                   {
[17:40:54.726]                     default_workers <- missing(workers)
[17:40:54.726]                     if (is.function(workers)) 
[17:40:54.726]                       workers <- workers()
[17:40:54.726]                     workers <- structure(as.integer(workers), 
[17:40:54.726]                       class = class(workers))
[17:40:54.726]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.726]                       1L)
[17:40:54.726]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.726]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.726]                       if (default_workers) 
[17:40:54.726]                         supportsMulticore(warn = TRUE)
[17:40:54.726]                       return(sequential(..., envir = envir))
[17:40:54.726]                     }
[17:40:54.726]                     oopts <- options(mc.cores = workers)
[17:40:54.726]                     on.exit(options(oopts))
[17:40:54.726]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.726]                       envir = envir)
[17:40:54.726]                     if (!future$lazy) 
[17:40:54.726]                       future <- run(future)
[17:40:54.726]                     invisible(future)
[17:40:54.726]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.726]                 }
[17:40:54.726]             }
[17:40:54.726]         }
[17:40:54.726]     })
[17:40:54.726]     if (TRUE) {
[17:40:54.726]         base::sink(type = "output", split = FALSE)
[17:40:54.726]         if (TRUE) {
[17:40:54.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.726]         }
[17:40:54.726]         else {
[17:40:54.726]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.726]         }
[17:40:54.726]         base::close(...future.stdout)
[17:40:54.726]         ...future.stdout <- NULL
[17:40:54.726]     }
[17:40:54.726]     ...future.result$conditions <- ...future.conditions
[17:40:54.726]     ...future.result$finished <- base::Sys.time()
[17:40:54.726]     ...future.result
[17:40:54.726] }
[17:40:54.729] assign_globals() ...
[17:40:54.729] List of 11
[17:40:54.729]  $ ...future.FUN            :function (x, ...)  
[17:40:54.729]  $ x_FUN                    :function (x)  
[17:40:54.729]  $ times                    : int 0
[17:40:54.729]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.729]  $ stop_if_not              :function (...)  
[17:40:54.729]  $ dim                      : NULL
[17:40:54.729]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:54.729]  $ future.call.arguments    : list()
[17:40:54.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.729]  $ ...future.elements_ii    :List of 5
[17:40:54.729]   ..$ : int 1
[17:40:54.729]   ..$ : int 2
[17:40:54.729]   ..$ : int 3
[17:40:54.729]   ..$ : int 4
[17:40:54.729]   ..$ : int 5
[17:40:54.729]  $ ...future.seeds_ii       : NULL
[17:40:54.729]  $ ...future.globals.maxSize: NULL
[17:40:54.729]  - attr(*, "resolved")= logi FALSE
[17:40:54.729]  - attr(*, "total_size")= num 95400
[17:40:54.729]  - attr(*, "where")=List of 11
[17:40:54.729]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.729]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.729]  - attr(*, "already-done")= logi TRUE
[17:40:54.738] - copied ‘...future.FUN’ to environment
[17:40:54.739] - reassign environment for ‘x_FUN’
[17:40:54.739] - copied ‘x_FUN’ to environment
[17:40:54.739] - copied ‘times’ to environment
[17:40:54.739] - copied ‘stopf’ to environment
[17:40:54.739] - copied ‘stop_if_not’ to environment
[17:40:54.739] - copied ‘dim’ to environment
[17:40:54.739] - copied ‘valid_types’ to environment
[17:40:54.739] - copied ‘future.call.arguments’ to environment
[17:40:54.739] - copied ‘...future.elements_ii’ to environment
[17:40:54.740] - copied ‘...future.seeds_ii’ to environment
[17:40:54.740] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.740] assign_globals() ... done
[17:40:54.740] requestCore(): workers = 2
[17:40:54.742] MulticoreFuture started
[17:40:54.742] - Launch lazy future ... done
[17:40:54.743] run() for ‘MulticoreFuture’ ... done
[17:40:54.743] Created future:
[17:40:54.744] plan(): Setting new future strategy stack:
[17:40:54.744] List of future strategies:
[17:40:54.744] 1. sequential:
[17:40:54.744]    - args: function (..., envir = parent.frame())
[17:40:54.744]    - tweaked: FALSE
[17:40:54.744]    - call: NULL
[17:40:54.745] plan(): nbrOfWorkers() = 1
[17:40:54.747] plan(): Setting new future strategy stack:
[17:40:54.747] List of future strategies:
[17:40:54.747] 1. multicore:
[17:40:54.747]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.747]    - tweaked: FALSE
[17:40:54.747]    - call: plan(strategy)
[17:40:54.752] plan(): nbrOfWorkers() = 2
[17:40:54.743] MulticoreFuture:
[17:40:54.743] Label: ‘future_vapply-1’
[17:40:54.743] Expression:
[17:40:54.743] {
[17:40:54.743]     do.call(function(...) {
[17:40:54.743]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.743]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.743]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.743]             on.exit(options(oopts), add = TRUE)
[17:40:54.743]         }
[17:40:54.743]         {
[17:40:54.743]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.743]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.743]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.743]             })
[17:40:54.743]         }
[17:40:54.743]     }, args = future.call.arguments)
[17:40:54.743] }
[17:40:54.743] Lazy evaluation: FALSE
[17:40:54.743] Asynchronous evaluation: TRUE
[17:40:54.743] Local evaluation: TRUE
[17:40:54.743] Environment: R_GlobalEnv
[17:40:54.743] Capture standard output: TRUE
[17:40:54.743] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.743] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.743] Packages: 1 packages (‘future.apply’)
[17:40:54.743] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.743] Resolved: TRUE
[17:40:54.743] Value: <not collected>
[17:40:54.743] Conditions captured: <none>
[17:40:54.743] Early signaling: FALSE
[17:40:54.743] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.743] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.753] Chunk #1 of 2 ... DONE
[17:40:54.754] Chunk #2 of 2 ...
[17:40:54.754]  - Finding globals in 'X' for chunk #2 ...
[17:40:54.754] getGlobalsAndPackages() ...
[17:40:54.754] Searching for globals...
[17:40:54.755] 
[17:40:54.755] Searching for globals ... DONE
[17:40:54.755] - globals: [0] <none>
[17:40:54.755] getGlobalsAndPackages() ... DONE
[17:40:54.755]    + additional globals found: [n=0] 
[17:40:54.755]    + additional namespaces needed: [n=0] 
[17:40:54.755]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:54.756]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:54.756]  - seeds: <none>
[17:40:54.756] getGlobalsAndPackages() ...
[17:40:54.756] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.756] Resolving globals: FALSE
[17:40:54.757] Tweak future expression to call with '...' arguments ...
[17:40:54.757] {
[17:40:54.757]     do.call(function(...) {
[17:40:54.757]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.757]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.757]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.757]             on.exit(options(oopts), add = TRUE)
[17:40:54.757]         }
[17:40:54.757]         {
[17:40:54.757]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.757]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.757]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.757]             })
[17:40:54.757]         }
[17:40:54.757]     }, args = future.call.arguments)
[17:40:54.757] }
[17:40:54.757] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.758] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.758] - packages: [1] ‘future.apply’
[17:40:54.758] getGlobalsAndPackages() ... DONE
[17:40:54.759] run() for ‘Future’ ...
[17:40:54.759] - state: ‘created’
[17:40:54.759] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.764] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.765]   - Field: ‘label’
[17:40:54.765]   - Field: ‘local’
[17:40:54.765]   - Field: ‘owner’
[17:40:54.765]   - Field: ‘envir’
[17:40:54.765]   - Field: ‘workers’
[17:40:54.766]   - Field: ‘packages’
[17:40:54.769]   - Field: ‘gc’
[17:40:54.769]   - Field: ‘job’
[17:40:54.770]   - Field: ‘conditions’
[17:40:54.770]   - Field: ‘expr’
[17:40:54.770]   - Field: ‘uuid’
[17:40:54.771]   - Field: ‘seed’
[17:40:54.771]   - Field: ‘version’
[17:40:54.771]   - Field: ‘result’
[17:40:54.771]   - Field: ‘asynchronous’
[17:40:54.772]   - Field: ‘calls’
[17:40:54.772]   - Field: ‘globals’
[17:40:54.772]   - Field: ‘stdout’
[17:40:54.772]   - Field: ‘earlySignal’
[17:40:54.773]   - Field: ‘lazy’
[17:40:54.773]   - Field: ‘state’
[17:40:54.773] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.773] - Launch lazy future ...
[17:40:54.774] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.774] Packages needed by future strategies (n = 0): <none>
[17:40:54.776] {
[17:40:54.776]     {
[17:40:54.776]         {
[17:40:54.776]             ...future.startTime <- base::Sys.time()
[17:40:54.776]             {
[17:40:54.776]                 {
[17:40:54.776]                   {
[17:40:54.776]                     {
[17:40:54.776]                       {
[17:40:54.776]                         base::local({
[17:40:54.776]                           has_future <- base::requireNamespace("future", 
[17:40:54.776]                             quietly = TRUE)
[17:40:54.776]                           if (has_future) {
[17:40:54.776]                             ns <- base::getNamespace("future")
[17:40:54.776]                             version <- ns[[".package"]][["version"]]
[17:40:54.776]                             if (is.null(version)) 
[17:40:54.776]                               version <- utils::packageVersion("future")
[17:40:54.776]                           }
[17:40:54.776]                           else {
[17:40:54.776]                             version <- NULL
[17:40:54.776]                           }
[17:40:54.776]                           if (!has_future || version < "1.8.0") {
[17:40:54.776]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.776]                               "", base::R.version$version.string), 
[17:40:54.776]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.776]                                 base::R.version$platform, 8 * 
[17:40:54.776]                                   base::.Machine$sizeof.pointer), 
[17:40:54.776]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.776]                                 "release", "version")], collapse = " "), 
[17:40:54.776]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.776]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.776]                               info)
[17:40:54.776]                             info <- base::paste(info, collapse = "; ")
[17:40:54.776]                             if (!has_future) {
[17:40:54.776]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.776]                                 info)
[17:40:54.776]                             }
[17:40:54.776]                             else {
[17:40:54.776]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.776]                                 info, version)
[17:40:54.776]                             }
[17:40:54.776]                             base::stop(msg)
[17:40:54.776]                           }
[17:40:54.776]                         })
[17:40:54.776]                       }
[17:40:54.776]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.776]                       base::options(mc.cores = 1L)
[17:40:54.776]                     }
[17:40:54.776]                     base::local({
[17:40:54.776]                       for (pkg in "future.apply") {
[17:40:54.776]                         base::loadNamespace(pkg)
[17:40:54.776]                         base::library(pkg, character.only = TRUE)
[17:40:54.776]                       }
[17:40:54.776]                     })
[17:40:54.776]                   }
[17:40:54.776]                   options(future.plan = NULL)
[17:40:54.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.776]                 }
[17:40:54.776]                 ...future.workdir <- getwd()
[17:40:54.776]             }
[17:40:54.776]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.776]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.776]         }
[17:40:54.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.776]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:54.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.776]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.776]             base::names(...future.oldOptions))
[17:40:54.776]     }
[17:40:54.776]     if (FALSE) {
[17:40:54.776]     }
[17:40:54.776]     else {
[17:40:54.776]         if (TRUE) {
[17:40:54.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.776]                 open = "w")
[17:40:54.776]         }
[17:40:54.776]         else {
[17:40:54.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.776]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.776]         }
[17:40:54.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.776]             base::sink(type = "output", split = FALSE)
[17:40:54.776]             base::close(...future.stdout)
[17:40:54.776]         }, add = TRUE)
[17:40:54.776]     }
[17:40:54.776]     ...future.frame <- base::sys.nframe()
[17:40:54.776]     ...future.conditions <- base::list()
[17:40:54.776]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.776]     if (FALSE) {
[17:40:54.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.776]     }
[17:40:54.776]     ...future.result <- base::tryCatch({
[17:40:54.776]         base::withCallingHandlers({
[17:40:54.776]             ...future.value <- base::withVisible(base::local({
[17:40:54.776]                 withCallingHandlers({
[17:40:54.776]                   {
[17:40:54.776]                     do.call(function(...) {
[17:40:54.776]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.776]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.776]                         ...future.globals.maxSize)) {
[17:40:54.776]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.776]                         on.exit(options(oopts), add = TRUE)
[17:40:54.776]                       }
[17:40:54.776]                       {
[17:40:54.776]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.776]                           FUN = function(jj) {
[17:40:54.776]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.776]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.776]                           })
[17:40:54.776]                       }
[17:40:54.776]                     }, args = future.call.arguments)
[17:40:54.776]                   }
[17:40:54.776]                 }, immediateCondition = function(cond) {
[17:40:54.776]                   save_rds <- function (object, pathname, ...) 
[17:40:54.776]                   {
[17:40:54.776]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.776]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.776]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.776]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.776]                         fi_tmp[["mtime"]])
[17:40:54.776]                     }
[17:40:54.776]                     tryCatch({
[17:40:54.776]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.776]                     }, error = function(ex) {
[17:40:54.776]                       msg <- conditionMessage(ex)
[17:40:54.776]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.776]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.776]                         fi_tmp[["mtime"]], msg)
[17:40:54.776]                       ex$message <- msg
[17:40:54.776]                       stop(ex)
[17:40:54.776]                     })
[17:40:54.776]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.776]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.776]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.776]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.776]                       fi <- file.info(pathname)
[17:40:54.776]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.776]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.776]                         fi[["size"]], fi[["mtime"]])
[17:40:54.776]                       stop(msg)
[17:40:54.776]                     }
[17:40:54.776]                     invisible(pathname)
[17:40:54.776]                   }
[17:40:54.776]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.776]                     rootPath = tempdir()) 
[17:40:54.776]                   {
[17:40:54.776]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.776]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.776]                       tmpdir = path, fileext = ".rds")
[17:40:54.776]                     save_rds(obj, file)
[17:40:54.776]                   }
[17:40:54.776]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.776]                   {
[17:40:54.776]                     inherits <- base::inherits
[17:40:54.776]                     invokeRestart <- base::invokeRestart
[17:40:54.776]                     is.null <- base::is.null
[17:40:54.776]                     muffled <- FALSE
[17:40:54.776]                     if (inherits(cond, "message")) {
[17:40:54.776]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.776]                       if (muffled) 
[17:40:54.776]                         invokeRestart("muffleMessage")
[17:40:54.776]                     }
[17:40:54.776]                     else if (inherits(cond, "warning")) {
[17:40:54.776]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.776]                       if (muffled) 
[17:40:54.776]                         invokeRestart("muffleWarning")
[17:40:54.776]                     }
[17:40:54.776]                     else if (inherits(cond, "condition")) {
[17:40:54.776]                       if (!is.null(pattern)) {
[17:40:54.776]                         computeRestarts <- base::computeRestarts
[17:40:54.776]                         grepl <- base::grepl
[17:40:54.776]                         restarts <- computeRestarts(cond)
[17:40:54.776]                         for (restart in restarts) {
[17:40:54.776]                           name <- restart$name
[17:40:54.776]                           if (is.null(name)) 
[17:40:54.776]                             next
[17:40:54.776]                           if (!grepl(pattern, name)) 
[17:40:54.776]                             next
[17:40:54.776]                           invokeRestart(restart)
[17:40:54.776]                           muffled <- TRUE
[17:40:54.776]                           break
[17:40:54.776]                         }
[17:40:54.776]                       }
[17:40:54.776]                     }
[17:40:54.776]                     invisible(muffled)
[17:40:54.776]                   }
[17:40:54.776]                   muffleCondition(cond)
[17:40:54.776]                 })
[17:40:54.776]             }))
[17:40:54.776]             future::FutureResult(value = ...future.value$value, 
[17:40:54.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.776]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.776]                     ...future.globalenv.names))
[17:40:54.776]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.776]         }, condition = base::local({
[17:40:54.776]             c <- base::c
[17:40:54.776]             inherits <- base::inherits
[17:40:54.776]             invokeRestart <- base::invokeRestart
[17:40:54.776]             length <- base::length
[17:40:54.776]             list <- base::list
[17:40:54.776]             seq.int <- base::seq.int
[17:40:54.776]             signalCondition <- base::signalCondition
[17:40:54.776]             sys.calls <- base::sys.calls
[17:40:54.776]             `[[` <- base::`[[`
[17:40:54.776]             `+` <- base::`+`
[17:40:54.776]             `<<-` <- base::`<<-`
[17:40:54.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.776]                   3L)]
[17:40:54.776]             }
[17:40:54.776]             function(cond) {
[17:40:54.776]                 is_error <- inherits(cond, "error")
[17:40:54.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.776]                   NULL)
[17:40:54.776]                 if (is_error) {
[17:40:54.776]                   sessionInformation <- function() {
[17:40:54.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.776]                       search = base::search(), system = base::Sys.info())
[17:40:54.776]                   }
[17:40:54.776]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.776]                     cond$call), session = sessionInformation(), 
[17:40:54.776]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.776]                   signalCondition(cond)
[17:40:54.776]                 }
[17:40:54.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.776]                 "immediateCondition"))) {
[17:40:54.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.776]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.776]                   if (TRUE && !signal) {
[17:40:54.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.776]                     {
[17:40:54.776]                       inherits <- base::inherits
[17:40:54.776]                       invokeRestart <- base::invokeRestart
[17:40:54.776]                       is.null <- base::is.null
[17:40:54.776]                       muffled <- FALSE
[17:40:54.776]                       if (inherits(cond, "message")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleMessage")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "warning")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleWarning")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "condition")) {
[17:40:54.776]                         if (!is.null(pattern)) {
[17:40:54.776]                           computeRestarts <- base::computeRestarts
[17:40:54.776]                           grepl <- base::grepl
[17:40:54.776]                           restarts <- computeRestarts(cond)
[17:40:54.776]                           for (restart in restarts) {
[17:40:54.776]                             name <- restart$name
[17:40:54.776]                             if (is.null(name)) 
[17:40:54.776]                               next
[17:40:54.776]                             if (!grepl(pattern, name)) 
[17:40:54.776]                               next
[17:40:54.776]                             invokeRestart(restart)
[17:40:54.776]                             muffled <- TRUE
[17:40:54.776]                             break
[17:40:54.776]                           }
[17:40:54.776]                         }
[17:40:54.776]                       }
[17:40:54.776]                       invisible(muffled)
[17:40:54.776]                     }
[17:40:54.776]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.776]                   }
[17:40:54.776]                 }
[17:40:54.776]                 else {
[17:40:54.776]                   if (TRUE) {
[17:40:54.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.776]                     {
[17:40:54.776]                       inherits <- base::inherits
[17:40:54.776]                       invokeRestart <- base::invokeRestart
[17:40:54.776]                       is.null <- base::is.null
[17:40:54.776]                       muffled <- FALSE
[17:40:54.776]                       if (inherits(cond, "message")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleMessage")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "warning")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleWarning")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "condition")) {
[17:40:54.776]                         if (!is.null(pattern)) {
[17:40:54.776]                           computeRestarts <- base::computeRestarts
[17:40:54.776]                           grepl <- base::grepl
[17:40:54.776]                           restarts <- computeRestarts(cond)
[17:40:54.776]                           for (restart in restarts) {
[17:40:54.776]                             name <- restart$name
[17:40:54.776]                             if (is.null(name)) 
[17:40:54.776]                               next
[17:40:54.776]                             if (!grepl(pattern, name)) 
[17:40:54.776]                               next
[17:40:54.776]                             invokeRestart(restart)
[17:40:54.776]                             muffled <- TRUE
[17:40:54.776]                             break
[17:40:54.776]                           }
[17:40:54.776]                         }
[17:40:54.776]                       }
[17:40:54.776]                       invisible(muffled)
[17:40:54.776]                     }
[17:40:54.776]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.776]                   }
[17:40:54.776]                 }
[17:40:54.776]             }
[17:40:54.776]         }))
[17:40:54.776]     }, error = function(ex) {
[17:40:54.776]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.776]                 ...future.rng), started = ...future.startTime, 
[17:40:54.776]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.776]             version = "1.8"), class = "FutureResult")
[17:40:54.776]     }, finally = {
[17:40:54.776]         if (!identical(...future.workdir, getwd())) 
[17:40:54.776]             setwd(...future.workdir)
[17:40:54.776]         {
[17:40:54.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.776]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.776]             }
[17:40:54.776]             base::options(...future.oldOptions)
[17:40:54.776]             if (.Platform$OS.type == "windows") {
[17:40:54.776]                 old_names <- names(...future.oldEnvVars)
[17:40:54.776]                 envs <- base::Sys.getenv()
[17:40:54.776]                 names <- names(envs)
[17:40:54.776]                 common <- intersect(names, old_names)
[17:40:54.776]                 added <- setdiff(names, old_names)
[17:40:54.776]                 removed <- setdiff(old_names, names)
[17:40:54.776]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.776]                   envs[common]]
[17:40:54.776]                 NAMES <- toupper(changed)
[17:40:54.776]                 args <- list()
[17:40:54.776]                 for (kk in seq_along(NAMES)) {
[17:40:54.776]                   name <- changed[[kk]]
[17:40:54.776]                   NAME <- NAMES[[kk]]
[17:40:54.776]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.776]                     next
[17:40:54.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.776]                 }
[17:40:54.776]                 NAMES <- toupper(added)
[17:40:54.776]                 for (kk in seq_along(NAMES)) {
[17:40:54.776]                   name <- added[[kk]]
[17:40:54.776]                   NAME <- NAMES[[kk]]
[17:40:54.776]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.776]                     next
[17:40:54.776]                   args[[name]] <- ""
[17:40:54.776]                 }
[17:40:54.776]                 NAMES <- toupper(removed)
[17:40:54.776]                 for (kk in seq_along(NAMES)) {
[17:40:54.776]                   name <- removed[[kk]]
[17:40:54.776]                   NAME <- NAMES[[kk]]
[17:40:54.776]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.776]                     next
[17:40:54.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.776]                 }
[17:40:54.776]                 if (length(args) > 0) 
[17:40:54.776]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.776]             }
[17:40:54.776]             else {
[17:40:54.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.776]             }
[17:40:54.776]             {
[17:40:54.776]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.776]                   0L) {
[17:40:54.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.776]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.776]                   base::options(opts)
[17:40:54.776]                 }
[17:40:54.776]                 {
[17:40:54.776]                   {
[17:40:54.776]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.776]                     NULL
[17:40:54.776]                   }
[17:40:54.776]                   options(future.plan = NULL)
[17:40:54.776]                   if (is.na(NA_character_)) 
[17:40:54.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.776]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.776]                     envir = parent.frame()) 
[17:40:54.776]                   {
[17:40:54.776]                     default_workers <- missing(workers)
[17:40:54.776]                     if (is.function(workers)) 
[17:40:54.776]                       workers <- workers()
[17:40:54.776]                     workers <- structure(as.integer(workers), 
[17:40:54.776]                       class = class(workers))
[17:40:54.776]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.776]                       1L)
[17:40:54.776]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.776]                       if (default_workers) 
[17:40:54.776]                         supportsMulticore(warn = TRUE)
[17:40:54.776]                       return(sequential(..., envir = envir))
[17:40:54.776]                     }
[17:40:54.776]                     oopts <- options(mc.cores = workers)
[17:40:54.776]                     on.exit(options(oopts))
[17:40:54.776]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.776]                       envir = envir)
[17:40:54.776]                     if (!future$lazy) 
[17:40:54.776]                       future <- run(future)
[17:40:54.776]                     invisible(future)
[17:40:54.776]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.776]                 }
[17:40:54.776]             }
[17:40:54.776]         }
[17:40:54.776]     })
[17:40:54.776]     if (TRUE) {
[17:40:54.776]         base::sink(type = "output", split = FALSE)
[17:40:54.776]         if (TRUE) {
[17:40:54.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.776]         }
[17:40:54.776]         else {
[17:40:54.776]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.776]         }
[17:40:54.776]         base::close(...future.stdout)
[17:40:54.776]         ...future.stdout <- NULL
[17:40:54.776]     }
[17:40:54.776]     ...future.result$conditions <- ...future.conditions
[17:40:54.776]     ...future.result$finished <- base::Sys.time()
[17:40:54.776]     ...future.result
[17:40:54.776] }
[17:40:54.779] assign_globals() ...
[17:40:54.779] List of 11
[17:40:54.779]  $ ...future.FUN            :function (x, ...)  
[17:40:54.779]  $ x_FUN                    :function (x)  
[17:40:54.779]  $ times                    : int 0
[17:40:54.779]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.779]  $ stop_if_not              :function (...)  
[17:40:54.779]  $ dim                      : NULL
[17:40:54.779]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:54.779]  $ future.call.arguments    : list()
[17:40:54.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.779]  $ ...future.elements_ii    :List of 5
[17:40:54.779]   ..$ : int 6
[17:40:54.779]   ..$ : int 7
[17:40:54.779]   ..$ : int 8
[17:40:54.779]   ..$ : int 9
[17:40:54.779]   ..$ : int 10
[17:40:54.779]  $ ...future.seeds_ii       : NULL
[17:40:54.779]  $ ...future.globals.maxSize: NULL
[17:40:54.779]  - attr(*, "resolved")= logi FALSE
[17:40:54.779]  - attr(*, "total_size")= num 95400
[17:40:54.779]  - attr(*, "where")=List of 11
[17:40:54.779]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.779]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.779]  - attr(*, "already-done")= logi TRUE
[17:40:54.791] - copied ‘...future.FUN’ to environment
[17:40:54.791] - reassign environment for ‘x_FUN’
[17:40:54.792] - copied ‘x_FUN’ to environment
[17:40:54.792] - copied ‘times’ to environment
[17:40:54.792] - copied ‘stopf’ to environment
[17:40:54.792] - copied ‘stop_if_not’ to environment
[17:40:54.792] - copied ‘dim’ to environment
[17:40:54.792] - copied ‘valid_types’ to environment
[17:40:54.792] - copied ‘future.call.arguments’ to environment
[17:40:54.792] - copied ‘...future.elements_ii’ to environment
[17:40:54.792] - copied ‘...future.seeds_ii’ to environment
[17:40:54.792] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.793] assign_globals() ... done
[17:40:54.793] requestCore(): workers = 2
[17:40:54.795] MulticoreFuture started
[17:40:54.795] - Launch lazy future ... done
[17:40:54.796] run() for ‘MulticoreFuture’ ... done
[17:40:54.796] Created future:
[17:40:54.797] plan(): Setting new future strategy stack:
[17:40:54.797] List of future strategies:
[17:40:54.797] 1. sequential:
[17:40:54.797]    - args: function (..., envir = parent.frame())
[17:40:54.797]    - tweaked: FALSE
[17:40:54.797]    - call: NULL
[17:40:54.798] plan(): nbrOfWorkers() = 1
[17:40:54.801] plan(): Setting new future strategy stack:
[17:40:54.802] List of future strategies:
[17:40:54.802] 1. multicore:
[17:40:54.802]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.802]    - tweaked: FALSE
[17:40:54.802]    - call: plan(strategy)
[17:40:54.809] plan(): nbrOfWorkers() = 2
[17:40:54.796] MulticoreFuture:
[17:40:54.796] Label: ‘future_vapply-2’
[17:40:54.796] Expression:
[17:40:54.796] {
[17:40:54.796]     do.call(function(...) {
[17:40:54.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.796]             on.exit(options(oopts), add = TRUE)
[17:40:54.796]         }
[17:40:54.796]         {
[17:40:54.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.796]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.796]             })
[17:40:54.796]         }
[17:40:54.796]     }, args = future.call.arguments)
[17:40:54.796] }
[17:40:54.796] Lazy evaluation: FALSE
[17:40:54.796] Asynchronous evaluation: TRUE
[17:40:54.796] Local evaluation: TRUE
[17:40:54.796] Environment: R_GlobalEnv
[17:40:54.796] Capture standard output: TRUE
[17:40:54.796] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.796] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.796] Packages: 1 packages (‘future.apply’)
[17:40:54.796] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.796] Resolved: TRUE
[17:40:54.796] Value: <not collected>
[17:40:54.796] Conditions captured: <none>
[17:40:54.796] Early signaling: FALSE
[17:40:54.796] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.796] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.810] Chunk #2 of 2 ... DONE
[17:40:54.810] Launching 2 futures (chunks) ... DONE
[17:40:54.810] Resolving 2 futures (chunks) ...
[17:40:54.810] resolve() on list ...
[17:40:54.811]  recursive: 0
[17:40:54.811]  length: 2
[17:40:54.811] 
[17:40:54.811] Future #1
[17:40:54.818] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:54.819] - nx: 2
[17:40:54.819] - relay: TRUE
[17:40:54.819] - stdout: TRUE
[17:40:54.819] - signal: TRUE
[17:40:54.819] - resignal: FALSE
[17:40:54.820] - force: TRUE
[17:40:54.820] - relayed: [n=2] FALSE, FALSE
[17:40:54.820] - queued futures: [n=2] FALSE, FALSE
[17:40:54.820]  - until=1
[17:40:54.820]  - relaying element #1
[17:40:54.821] - relayed: [n=2] TRUE, FALSE
[17:40:54.821] - queued futures: [n=2] TRUE, FALSE
[17:40:54.821] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:54.822]  length: 1 (resolved future 1)
[17:40:54.822] Future #2
[17:40:54.823] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:54.824] - nx: 2
[17:40:54.824] - relay: TRUE
[17:40:54.827] - stdout: TRUE
[17:40:54.828] - signal: TRUE
[17:40:54.828] - resignal: FALSE
[17:40:54.828] - force: TRUE
[17:40:54.828] - relayed: [n=2] TRUE, FALSE
[17:40:54.829] - queued futures: [n=2] TRUE, FALSE
[17:40:54.829]  - until=2
[17:40:54.829]  - relaying element #2
[17:40:54.830] - relayed: [n=2] TRUE, TRUE
[17:40:54.830] - queued futures: [n=2] TRUE, TRUE
[17:40:54.830] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:54.831]  length: 0 (resolved future 2)
[17:40:54.831] Relaying remaining futures
[17:40:54.832] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.832] - nx: 2
[17:40:54.832] - relay: TRUE
[17:40:54.832] - stdout: TRUE
[17:40:54.833] - signal: TRUE
[17:40:54.833] - resignal: FALSE
[17:40:54.833] - force: TRUE
[17:40:54.833] - relayed: [n=2] TRUE, TRUE
[17:40:54.834] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:54.834] - relayed: [n=2] TRUE, TRUE
[17:40:54.834] - queued futures: [n=2] TRUE, TRUE
[17:40:54.835] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.835] resolve() on list ... DONE
[17:40:54.836]  - Number of value chunks collected: 2
[17:40:54.836] Resolving 2 futures (chunks) ... DONE
[17:40:54.836] Reducing values from 2 chunks ...
[17:40:54.836]  - Number of values collected after concatenation: 10
[17:40:54.837]  - Number of values expected: 10
[17:40:54.837] Reducing values from 2 chunks ... DONE
[17:40:54.837] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:40:54.839] future_lapply() ...
[17:40:54.849] Number of chunks: 2
[17:40:54.849] getGlobalsAndPackagesXApply() ...
[17:40:54.849]  - future.globals: TRUE
[17:40:54.849] getGlobalsAndPackages() ...
[17:40:54.849] Searching for globals...
[17:40:54.854] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:54.854] Searching for globals ... DONE
[17:40:54.854] Resolving globals: FALSE
[17:40:54.855] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:40:54.856] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.856] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.856] - packages: [1] ‘future.apply’
[17:40:54.856] getGlobalsAndPackages() ... DONE
[17:40:54.856]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.856]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.857] Finding globals ... DONE
[17:40:54.857]  - use_args: TRUE
[17:40:54.857]  - Getting '...' globals ...
[17:40:54.857] resolve() on list ...
[17:40:54.857]  recursive: 0
[17:40:54.857]  length: 1
[17:40:54.857]  elements: ‘...’
[17:40:54.858]  length: 0 (resolved future 1)
[17:40:54.858] resolve() on list ... DONE
[17:40:54.858]    - '...' content: [n=0] 
[17:40:54.858] List of 1
[17:40:54.858]  $ ...: list()
[17:40:54.858]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.858]  - attr(*, "where")=List of 1
[17:40:54.858]   ..$ ...:<environment: 0x564f2eefb3e8> 
[17:40:54.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.858]  - attr(*, "resolved")= logi TRUE
[17:40:54.858]  - attr(*, "total_size")= num NA
[17:40:54.861]  - Getting '...' globals ... DONE
[17:40:54.862] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:54.862] List of 8
[17:40:54.862]  $ ...future.FUN:function (x, ...)  
[17:40:54.862]  $ x_FUN        :function (x)  
[17:40:54.862]  $ times        : int 1
[17:40:54.862]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.862]  $ stop_if_not  :function (...)  
[17:40:54.862]  $ dim          : NULL
[17:40:54.862]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:54.862]  $ ...          : list()
[17:40:54.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.862]  - attr(*, "where")=List of 8
[17:40:54.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:54.862]   ..$ ...          :<environment: 0x564f2eefb3e8> 
[17:40:54.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.862]  - attr(*, "resolved")= logi FALSE
[17:40:54.862]  - attr(*, "total_size")= num 94336
[17:40:54.870] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:54.870] getGlobalsAndPackagesXApply() ... DONE
[17:40:54.871] Number of futures (= number of chunks): 2
[17:40:54.871] Launching 2 futures (chunks) ...
[17:40:54.871] Chunk #1 of 2 ...
[17:40:54.871]  - Finding globals in 'X' for chunk #1 ...
[17:40:54.871] getGlobalsAndPackages() ...
[17:40:54.871] Searching for globals...
[17:40:54.872] 
[17:40:54.872] Searching for globals ... DONE
[17:40:54.872] - globals: [0] <none>
[17:40:54.872] getGlobalsAndPackages() ... DONE
[17:40:54.872]    + additional globals found: [n=0] 
[17:40:54.872]    + additional namespaces needed: [n=0] 
[17:40:54.872]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:54.872]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:54.872]  - seeds: <none>
[17:40:54.872] getGlobalsAndPackages() ...
[17:40:54.873] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.873] Resolving globals: FALSE
[17:40:54.873] Tweak future expression to call with '...' arguments ...
[17:40:54.873] {
[17:40:54.873]     do.call(function(...) {
[17:40:54.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.873]             on.exit(options(oopts), add = TRUE)
[17:40:54.873]         }
[17:40:54.873]         {
[17:40:54.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.873]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.873]             })
[17:40:54.873]         }
[17:40:54.873]     }, args = future.call.arguments)
[17:40:54.873] }
[17:40:54.873] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.874] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.874] - packages: [1] ‘future.apply’
[17:40:54.874] getGlobalsAndPackages() ... DONE
[17:40:54.874] run() for ‘Future’ ...
[17:40:54.874] - state: ‘created’
[17:40:54.875] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.879] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.879]   - Field: ‘label’
[17:40:54.879]   - Field: ‘local’
[17:40:54.879]   - Field: ‘owner’
[17:40:54.879]   - Field: ‘envir’
[17:40:54.880]   - Field: ‘workers’
[17:40:54.880]   - Field: ‘packages’
[17:40:54.880]   - Field: ‘gc’
[17:40:54.880]   - Field: ‘job’
[17:40:54.880]   - Field: ‘conditions’
[17:40:54.880]   - Field: ‘expr’
[17:40:54.880]   - Field: ‘uuid’
[17:40:54.880]   - Field: ‘seed’
[17:40:54.880]   - Field: ‘version’
[17:40:54.881]   - Field: ‘result’
[17:40:54.881]   - Field: ‘asynchronous’
[17:40:54.881]   - Field: ‘calls’
[17:40:54.881]   - Field: ‘globals’
[17:40:54.881]   - Field: ‘stdout’
[17:40:54.881]   - Field: ‘earlySignal’
[17:40:54.881]   - Field: ‘lazy’
[17:40:54.881]   - Field: ‘state’
[17:40:54.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.881] - Launch lazy future ...
[17:40:54.882] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.882] Packages needed by future strategies (n = 0): <none>
[17:40:54.882] {
[17:40:54.882]     {
[17:40:54.882]         {
[17:40:54.882]             ...future.startTime <- base::Sys.time()
[17:40:54.882]             {
[17:40:54.882]                 {
[17:40:54.882]                   {
[17:40:54.882]                     {
[17:40:54.882]                       {
[17:40:54.882]                         base::local({
[17:40:54.882]                           has_future <- base::requireNamespace("future", 
[17:40:54.882]                             quietly = TRUE)
[17:40:54.882]                           if (has_future) {
[17:40:54.882]                             ns <- base::getNamespace("future")
[17:40:54.882]                             version <- ns[[".package"]][["version"]]
[17:40:54.882]                             if (is.null(version)) 
[17:40:54.882]                               version <- utils::packageVersion("future")
[17:40:54.882]                           }
[17:40:54.882]                           else {
[17:40:54.882]                             version <- NULL
[17:40:54.882]                           }
[17:40:54.882]                           if (!has_future || version < "1.8.0") {
[17:40:54.882]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.882]                               "", base::R.version$version.string), 
[17:40:54.882]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.882]                                 base::R.version$platform, 8 * 
[17:40:54.882]                                   base::.Machine$sizeof.pointer), 
[17:40:54.882]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.882]                                 "release", "version")], collapse = " "), 
[17:40:54.882]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.882]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.882]                               info)
[17:40:54.882]                             info <- base::paste(info, collapse = "; ")
[17:40:54.882]                             if (!has_future) {
[17:40:54.882]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.882]                                 info)
[17:40:54.882]                             }
[17:40:54.882]                             else {
[17:40:54.882]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.882]                                 info, version)
[17:40:54.882]                             }
[17:40:54.882]                             base::stop(msg)
[17:40:54.882]                           }
[17:40:54.882]                         })
[17:40:54.882]                       }
[17:40:54.882]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.882]                       base::options(mc.cores = 1L)
[17:40:54.882]                     }
[17:40:54.882]                     base::local({
[17:40:54.882]                       for (pkg in "future.apply") {
[17:40:54.882]                         base::loadNamespace(pkg)
[17:40:54.882]                         base::library(pkg, character.only = TRUE)
[17:40:54.882]                       }
[17:40:54.882]                     })
[17:40:54.882]                   }
[17:40:54.882]                   options(future.plan = NULL)
[17:40:54.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.882]                 }
[17:40:54.882]                 ...future.workdir <- getwd()
[17:40:54.882]             }
[17:40:54.882]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.882]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.882]         }
[17:40:54.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.882]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:54.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.882]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.882]             base::names(...future.oldOptions))
[17:40:54.882]     }
[17:40:54.882]     if (FALSE) {
[17:40:54.882]     }
[17:40:54.882]     else {
[17:40:54.882]         if (TRUE) {
[17:40:54.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.882]                 open = "w")
[17:40:54.882]         }
[17:40:54.882]         else {
[17:40:54.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.882]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.882]         }
[17:40:54.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.882]             base::sink(type = "output", split = FALSE)
[17:40:54.882]             base::close(...future.stdout)
[17:40:54.882]         }, add = TRUE)
[17:40:54.882]     }
[17:40:54.882]     ...future.frame <- base::sys.nframe()
[17:40:54.882]     ...future.conditions <- base::list()
[17:40:54.882]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.882]     if (FALSE) {
[17:40:54.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.882]     }
[17:40:54.882]     ...future.result <- base::tryCatch({
[17:40:54.882]         base::withCallingHandlers({
[17:40:54.882]             ...future.value <- base::withVisible(base::local({
[17:40:54.882]                 withCallingHandlers({
[17:40:54.882]                   {
[17:40:54.882]                     do.call(function(...) {
[17:40:54.882]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.882]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.882]                         ...future.globals.maxSize)) {
[17:40:54.882]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.882]                         on.exit(options(oopts), add = TRUE)
[17:40:54.882]                       }
[17:40:54.882]                       {
[17:40:54.882]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.882]                           FUN = function(jj) {
[17:40:54.882]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.882]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.882]                           })
[17:40:54.882]                       }
[17:40:54.882]                     }, args = future.call.arguments)
[17:40:54.882]                   }
[17:40:54.882]                 }, immediateCondition = function(cond) {
[17:40:54.882]                   save_rds <- function (object, pathname, ...) 
[17:40:54.882]                   {
[17:40:54.882]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.882]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.882]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.882]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.882]                         fi_tmp[["mtime"]])
[17:40:54.882]                     }
[17:40:54.882]                     tryCatch({
[17:40:54.882]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.882]                     }, error = function(ex) {
[17:40:54.882]                       msg <- conditionMessage(ex)
[17:40:54.882]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.882]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.882]                         fi_tmp[["mtime"]], msg)
[17:40:54.882]                       ex$message <- msg
[17:40:54.882]                       stop(ex)
[17:40:54.882]                     })
[17:40:54.882]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.882]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.882]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.882]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.882]                       fi <- file.info(pathname)
[17:40:54.882]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.882]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.882]                         fi[["size"]], fi[["mtime"]])
[17:40:54.882]                       stop(msg)
[17:40:54.882]                     }
[17:40:54.882]                     invisible(pathname)
[17:40:54.882]                   }
[17:40:54.882]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.882]                     rootPath = tempdir()) 
[17:40:54.882]                   {
[17:40:54.882]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.882]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.882]                       tmpdir = path, fileext = ".rds")
[17:40:54.882]                     save_rds(obj, file)
[17:40:54.882]                   }
[17:40:54.882]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.882]                   {
[17:40:54.882]                     inherits <- base::inherits
[17:40:54.882]                     invokeRestart <- base::invokeRestart
[17:40:54.882]                     is.null <- base::is.null
[17:40:54.882]                     muffled <- FALSE
[17:40:54.882]                     if (inherits(cond, "message")) {
[17:40:54.882]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.882]                       if (muffled) 
[17:40:54.882]                         invokeRestart("muffleMessage")
[17:40:54.882]                     }
[17:40:54.882]                     else if (inherits(cond, "warning")) {
[17:40:54.882]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.882]                       if (muffled) 
[17:40:54.882]                         invokeRestart("muffleWarning")
[17:40:54.882]                     }
[17:40:54.882]                     else if (inherits(cond, "condition")) {
[17:40:54.882]                       if (!is.null(pattern)) {
[17:40:54.882]                         computeRestarts <- base::computeRestarts
[17:40:54.882]                         grepl <- base::grepl
[17:40:54.882]                         restarts <- computeRestarts(cond)
[17:40:54.882]                         for (restart in restarts) {
[17:40:54.882]                           name <- restart$name
[17:40:54.882]                           if (is.null(name)) 
[17:40:54.882]                             next
[17:40:54.882]                           if (!grepl(pattern, name)) 
[17:40:54.882]                             next
[17:40:54.882]                           invokeRestart(restart)
[17:40:54.882]                           muffled <- TRUE
[17:40:54.882]                           break
[17:40:54.882]                         }
[17:40:54.882]                       }
[17:40:54.882]                     }
[17:40:54.882]                     invisible(muffled)
[17:40:54.882]                   }
[17:40:54.882]                   muffleCondition(cond)
[17:40:54.882]                 })
[17:40:54.882]             }))
[17:40:54.882]             future::FutureResult(value = ...future.value$value, 
[17:40:54.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.882]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.882]                     ...future.globalenv.names))
[17:40:54.882]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.882]         }, condition = base::local({
[17:40:54.882]             c <- base::c
[17:40:54.882]             inherits <- base::inherits
[17:40:54.882]             invokeRestart <- base::invokeRestart
[17:40:54.882]             length <- base::length
[17:40:54.882]             list <- base::list
[17:40:54.882]             seq.int <- base::seq.int
[17:40:54.882]             signalCondition <- base::signalCondition
[17:40:54.882]             sys.calls <- base::sys.calls
[17:40:54.882]             `[[` <- base::`[[`
[17:40:54.882]             `+` <- base::`+`
[17:40:54.882]             `<<-` <- base::`<<-`
[17:40:54.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.882]                   3L)]
[17:40:54.882]             }
[17:40:54.882]             function(cond) {
[17:40:54.882]                 is_error <- inherits(cond, "error")
[17:40:54.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.882]                   NULL)
[17:40:54.882]                 if (is_error) {
[17:40:54.882]                   sessionInformation <- function() {
[17:40:54.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.882]                       search = base::search(), system = base::Sys.info())
[17:40:54.882]                   }
[17:40:54.882]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.882]                     cond$call), session = sessionInformation(), 
[17:40:54.882]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.882]                   signalCondition(cond)
[17:40:54.882]                 }
[17:40:54.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.882]                 "immediateCondition"))) {
[17:40:54.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.882]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.882]                   if (TRUE && !signal) {
[17:40:54.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.882]                     {
[17:40:54.882]                       inherits <- base::inherits
[17:40:54.882]                       invokeRestart <- base::invokeRestart
[17:40:54.882]                       is.null <- base::is.null
[17:40:54.882]                       muffled <- FALSE
[17:40:54.882]                       if (inherits(cond, "message")) {
[17:40:54.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.882]                         if (muffled) 
[17:40:54.882]                           invokeRestart("muffleMessage")
[17:40:54.882]                       }
[17:40:54.882]                       else if (inherits(cond, "warning")) {
[17:40:54.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.882]                         if (muffled) 
[17:40:54.882]                           invokeRestart("muffleWarning")
[17:40:54.882]                       }
[17:40:54.882]                       else if (inherits(cond, "condition")) {
[17:40:54.882]                         if (!is.null(pattern)) {
[17:40:54.882]                           computeRestarts <- base::computeRestarts
[17:40:54.882]                           grepl <- base::grepl
[17:40:54.882]                           restarts <- computeRestarts(cond)
[17:40:54.882]                           for (restart in restarts) {
[17:40:54.882]                             name <- restart$name
[17:40:54.882]                             if (is.null(name)) 
[17:40:54.882]                               next
[17:40:54.882]                             if (!grepl(pattern, name)) 
[17:40:54.882]                               next
[17:40:54.882]                             invokeRestart(restart)
[17:40:54.882]                             muffled <- TRUE
[17:40:54.882]                             break
[17:40:54.882]                           }
[17:40:54.882]                         }
[17:40:54.882]                       }
[17:40:54.882]                       invisible(muffled)
[17:40:54.882]                     }
[17:40:54.882]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.882]                   }
[17:40:54.882]                 }
[17:40:54.882]                 else {
[17:40:54.882]                   if (TRUE) {
[17:40:54.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.882]                     {
[17:40:54.882]                       inherits <- base::inherits
[17:40:54.882]                       invokeRestart <- base::invokeRestart
[17:40:54.882]                       is.null <- base::is.null
[17:40:54.882]                       muffled <- FALSE
[17:40:54.882]                       if (inherits(cond, "message")) {
[17:40:54.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.882]                         if (muffled) 
[17:40:54.882]                           invokeRestart("muffleMessage")
[17:40:54.882]                       }
[17:40:54.882]                       else if (inherits(cond, "warning")) {
[17:40:54.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.882]                         if (muffled) 
[17:40:54.882]                           invokeRestart("muffleWarning")
[17:40:54.882]                       }
[17:40:54.882]                       else if (inherits(cond, "condition")) {
[17:40:54.882]                         if (!is.null(pattern)) {
[17:40:54.882]                           computeRestarts <- base::computeRestarts
[17:40:54.882]                           grepl <- base::grepl
[17:40:54.882]                           restarts <- computeRestarts(cond)
[17:40:54.882]                           for (restart in restarts) {
[17:40:54.882]                             name <- restart$name
[17:40:54.882]                             if (is.null(name)) 
[17:40:54.882]                               next
[17:40:54.882]                             if (!grepl(pattern, name)) 
[17:40:54.882]                               next
[17:40:54.882]                             invokeRestart(restart)
[17:40:54.882]                             muffled <- TRUE
[17:40:54.882]                             break
[17:40:54.882]                           }
[17:40:54.882]                         }
[17:40:54.882]                       }
[17:40:54.882]                       invisible(muffled)
[17:40:54.882]                     }
[17:40:54.882]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.882]                   }
[17:40:54.882]                 }
[17:40:54.882]             }
[17:40:54.882]         }))
[17:40:54.882]     }, error = function(ex) {
[17:40:54.882]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.882]                 ...future.rng), started = ...future.startTime, 
[17:40:54.882]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.882]             version = "1.8"), class = "FutureResult")
[17:40:54.882]     }, finally = {
[17:40:54.882]         if (!identical(...future.workdir, getwd())) 
[17:40:54.882]             setwd(...future.workdir)
[17:40:54.882]         {
[17:40:54.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.882]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.882]             }
[17:40:54.882]             base::options(...future.oldOptions)
[17:40:54.882]             if (.Platform$OS.type == "windows") {
[17:40:54.882]                 old_names <- names(...future.oldEnvVars)
[17:40:54.882]                 envs <- base::Sys.getenv()
[17:40:54.882]                 names <- names(envs)
[17:40:54.882]                 common <- intersect(names, old_names)
[17:40:54.882]                 added <- setdiff(names, old_names)
[17:40:54.882]                 removed <- setdiff(old_names, names)
[17:40:54.882]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.882]                   envs[common]]
[17:40:54.882]                 NAMES <- toupper(changed)
[17:40:54.882]                 args <- list()
[17:40:54.882]                 for (kk in seq_along(NAMES)) {
[17:40:54.882]                   name <- changed[[kk]]
[17:40:54.882]                   NAME <- NAMES[[kk]]
[17:40:54.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.882]                     next
[17:40:54.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.882]                 }
[17:40:54.882]                 NAMES <- toupper(added)
[17:40:54.882]                 for (kk in seq_along(NAMES)) {
[17:40:54.882]                   name <- added[[kk]]
[17:40:54.882]                   NAME <- NAMES[[kk]]
[17:40:54.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.882]                     next
[17:40:54.882]                   args[[name]] <- ""
[17:40:54.882]                 }
[17:40:54.882]                 NAMES <- toupper(removed)
[17:40:54.882]                 for (kk in seq_along(NAMES)) {
[17:40:54.882]                   name <- removed[[kk]]
[17:40:54.882]                   NAME <- NAMES[[kk]]
[17:40:54.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.882]                     next
[17:40:54.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.882]                 }
[17:40:54.882]                 if (length(args) > 0) 
[17:40:54.882]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.882]             }
[17:40:54.882]             else {
[17:40:54.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.882]             }
[17:40:54.882]             {
[17:40:54.882]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.882]                   0L) {
[17:40:54.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.882]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.882]                   base::options(opts)
[17:40:54.882]                 }
[17:40:54.882]                 {
[17:40:54.882]                   {
[17:40:54.882]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.882]                     NULL
[17:40:54.882]                   }
[17:40:54.882]                   options(future.plan = NULL)
[17:40:54.882]                   if (is.na(NA_character_)) 
[17:40:54.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.882]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.882]                     envir = parent.frame()) 
[17:40:54.882]                   {
[17:40:54.882]                     default_workers <- missing(workers)
[17:40:54.882]                     if (is.function(workers)) 
[17:40:54.882]                       workers <- workers()
[17:40:54.882]                     workers <- structure(as.integer(workers), 
[17:40:54.882]                       class = class(workers))
[17:40:54.882]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.882]                       1L)
[17:40:54.882]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.882]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.882]                       if (default_workers) 
[17:40:54.882]                         supportsMulticore(warn = TRUE)
[17:40:54.882]                       return(sequential(..., envir = envir))
[17:40:54.882]                     }
[17:40:54.882]                     oopts <- options(mc.cores = workers)
[17:40:54.882]                     on.exit(options(oopts))
[17:40:54.882]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.882]                       envir = envir)
[17:40:54.882]                     if (!future$lazy) 
[17:40:54.882]                       future <- run(future)
[17:40:54.882]                     invisible(future)
[17:40:54.882]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.882]                 }
[17:40:54.882]             }
[17:40:54.882]         }
[17:40:54.882]     })
[17:40:54.882]     if (TRUE) {
[17:40:54.882]         base::sink(type = "output", split = FALSE)
[17:40:54.882]         if (TRUE) {
[17:40:54.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.882]         }
[17:40:54.882]         else {
[17:40:54.882]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.882]         }
[17:40:54.882]         base::close(...future.stdout)
[17:40:54.882]         ...future.stdout <- NULL
[17:40:54.882]     }
[17:40:54.882]     ...future.result$conditions <- ...future.conditions
[17:40:54.882]     ...future.result$finished <- base::Sys.time()
[17:40:54.882]     ...future.result
[17:40:54.882] }
[17:40:54.885] assign_globals() ...
[17:40:54.885] List of 11
[17:40:54.885]  $ ...future.FUN            :function (x, ...)  
[17:40:54.885]  $ x_FUN                    :function (x)  
[17:40:54.885]  $ times                    : int 1
[17:40:54.885]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.885]  $ stop_if_not              :function (...)  
[17:40:54.885]  $ dim                      : NULL
[17:40:54.885]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.885]  $ future.call.arguments    : list()
[17:40:54.885]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.885]  $ ...future.elements_ii    :List of 5
[17:40:54.885]   ..$ : int 1
[17:40:54.885]   ..$ : int 2
[17:40:54.885]   ..$ : int 3
[17:40:54.885]   ..$ : int 4
[17:40:54.885]   ..$ : int 5
[17:40:54.885]  $ ...future.seeds_ii       : NULL
[17:40:54.885]  $ ...future.globals.maxSize: NULL
[17:40:54.885]  - attr(*, "resolved")= logi FALSE
[17:40:54.885]  - attr(*, "total_size")= num 94336
[17:40:54.885]  - attr(*, "where")=List of 11
[17:40:54.885]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.885]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.885]  - attr(*, "already-done")= logi TRUE
[17:40:54.897] - copied ‘...future.FUN’ to environment
[17:40:54.897] - copied ‘x_FUN’ to environment
[17:40:54.897] - copied ‘times’ to environment
[17:40:54.897] - copied ‘stopf’ to environment
[17:40:54.897] - copied ‘stop_if_not’ to environment
[17:40:54.897] - copied ‘dim’ to environment
[17:40:54.897] - copied ‘valid_types’ to environment
[17:40:54.897] - copied ‘future.call.arguments’ to environment
[17:40:54.897] - copied ‘...future.elements_ii’ to environment
[17:40:54.898] - copied ‘...future.seeds_ii’ to environment
[17:40:54.898] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.898] assign_globals() ... done
[17:40:54.898] requestCore(): workers = 2
[17:40:54.900] MulticoreFuture started
[17:40:54.901] - Launch lazy future ... done
[17:40:54.901] run() for ‘MulticoreFuture’ ... done
[17:40:54.901] Created future:
[17:40:54.902] plan(): Setting new future strategy stack:
[17:40:54.902] List of future strategies:
[17:40:54.902] 1. sequential:
[17:40:54.902]    - args: function (..., envir = parent.frame())
[17:40:54.902]    - tweaked: FALSE
[17:40:54.902]    - call: NULL
[17:40:54.903] plan(): nbrOfWorkers() = 1
[17:40:54.906] plan(): Setting new future strategy stack:
[17:40:54.906] List of future strategies:
[17:40:54.906] 1. multicore:
[17:40:54.906]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.906]    - tweaked: FALSE
[17:40:54.906]    - call: plan(strategy)
[17:40:54.911] plan(): nbrOfWorkers() = 2
[17:40:54.901] MulticoreFuture:
[17:40:54.901] Label: ‘future_vapply-1’
[17:40:54.901] Expression:
[17:40:54.901] {
[17:40:54.901]     do.call(function(...) {
[17:40:54.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.901]             on.exit(options(oopts), add = TRUE)
[17:40:54.901]         }
[17:40:54.901]         {
[17:40:54.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.901]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.901]             })
[17:40:54.901]         }
[17:40:54.901]     }, args = future.call.arguments)
[17:40:54.901] }
[17:40:54.901] Lazy evaluation: FALSE
[17:40:54.901] Asynchronous evaluation: TRUE
[17:40:54.901] Local evaluation: TRUE
[17:40:54.901] Environment: R_GlobalEnv
[17:40:54.901] Capture standard output: TRUE
[17:40:54.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.901] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.901] Packages: 1 packages (‘future.apply’)
[17:40:54.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.901] Resolved: TRUE
[17:40:54.901] Value: <not collected>
[17:40:54.901] Conditions captured: <none>
[17:40:54.901] Early signaling: FALSE
[17:40:54.901] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.901] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.912] Chunk #1 of 2 ... DONE
[17:40:54.913] Chunk #2 of 2 ...
[17:40:54.913]  - Finding globals in 'X' for chunk #2 ...
[17:40:54.913] getGlobalsAndPackages() ...
[17:40:54.913] Searching for globals...
[17:40:54.914] 
[17:40:54.914] Searching for globals ... DONE
[17:40:54.914] - globals: [0] <none>
[17:40:54.914] getGlobalsAndPackages() ... DONE
[17:40:54.914]    + additional globals found: [n=0] 
[17:40:54.914]    + additional namespaces needed: [n=0] 
[17:40:54.914]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:54.915]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:54.915]  - seeds: <none>
[17:40:54.915] getGlobalsAndPackages() ...
[17:40:54.915] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.915] Resolving globals: FALSE
[17:40:54.916] Tweak future expression to call with '...' arguments ...
[17:40:54.916] {
[17:40:54.916]     do.call(function(...) {
[17:40:54.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.916]             on.exit(options(oopts), add = TRUE)
[17:40:54.916]         }
[17:40:54.916]         {
[17:40:54.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.916]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.916]             })
[17:40:54.916]         }
[17:40:54.916]     }, args = future.call.arguments)
[17:40:54.916] }
[17:40:54.916] Tweak future expression to call with '...' arguments ... DONE
[17:40:54.917] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:54.917] - packages: [1] ‘future.apply’
[17:40:54.918] getGlobalsAndPackages() ... DONE
[17:40:54.918] run() for ‘Future’ ...
[17:40:54.918] - state: ‘created’
[17:40:54.919] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.924] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.924] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:54.924]   - Field: ‘label’
[17:40:54.924]   - Field: ‘local’
[17:40:54.925]   - Field: ‘owner’
[17:40:54.925]   - Field: ‘envir’
[17:40:54.925]   - Field: ‘workers’
[17:40:54.925]   - Field: ‘packages’
[17:40:54.925]   - Field: ‘gc’
[17:40:54.925]   - Field: ‘job’
[17:40:54.926]   - Field: ‘conditions’
[17:40:54.926]   - Field: ‘expr’
[17:40:54.926]   - Field: ‘uuid’
[17:40:54.926]   - Field: ‘seed’
[17:40:54.926]   - Field: ‘version’
[17:40:54.926]   - Field: ‘result’
[17:40:54.926]   - Field: ‘asynchronous’
[17:40:54.927]   - Field: ‘calls’
[17:40:54.927]   - Field: ‘globals’
[17:40:54.927]   - Field: ‘stdout’
[17:40:54.927]   - Field: ‘earlySignal’
[17:40:54.927]   - Field: ‘lazy’
[17:40:54.928]   - Field: ‘state’
[17:40:54.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:54.928] - Launch lazy future ...
[17:40:54.928] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:54.929] Packages needed by future strategies (n = 0): <none>
[17:40:54.930] {
[17:40:54.930]     {
[17:40:54.930]         {
[17:40:54.930]             ...future.startTime <- base::Sys.time()
[17:40:54.930]             {
[17:40:54.930]                 {
[17:40:54.930]                   {
[17:40:54.930]                     {
[17:40:54.930]                       {
[17:40:54.930]                         base::local({
[17:40:54.930]                           has_future <- base::requireNamespace("future", 
[17:40:54.930]                             quietly = TRUE)
[17:40:54.930]                           if (has_future) {
[17:40:54.930]                             ns <- base::getNamespace("future")
[17:40:54.930]                             version <- ns[[".package"]][["version"]]
[17:40:54.930]                             if (is.null(version)) 
[17:40:54.930]                               version <- utils::packageVersion("future")
[17:40:54.930]                           }
[17:40:54.930]                           else {
[17:40:54.930]                             version <- NULL
[17:40:54.930]                           }
[17:40:54.930]                           if (!has_future || version < "1.8.0") {
[17:40:54.930]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.930]                               "", base::R.version$version.string), 
[17:40:54.930]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:54.930]                                 base::R.version$platform, 8 * 
[17:40:54.930]                                   base::.Machine$sizeof.pointer), 
[17:40:54.930]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.930]                                 "release", "version")], collapse = " "), 
[17:40:54.930]                               hostname = base::Sys.info()[["nodename"]])
[17:40:54.930]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.930]                               info)
[17:40:54.930]                             info <- base::paste(info, collapse = "; ")
[17:40:54.930]                             if (!has_future) {
[17:40:54.930]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.930]                                 info)
[17:40:54.930]                             }
[17:40:54.930]                             else {
[17:40:54.930]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.930]                                 info, version)
[17:40:54.930]                             }
[17:40:54.930]                             base::stop(msg)
[17:40:54.930]                           }
[17:40:54.930]                         })
[17:40:54.930]                       }
[17:40:54.930]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.930]                       base::options(mc.cores = 1L)
[17:40:54.930]                     }
[17:40:54.930]                     base::local({
[17:40:54.930]                       for (pkg in "future.apply") {
[17:40:54.930]                         base::loadNamespace(pkg)
[17:40:54.930]                         base::library(pkg, character.only = TRUE)
[17:40:54.930]                       }
[17:40:54.930]                     })
[17:40:54.930]                   }
[17:40:54.930]                   options(future.plan = NULL)
[17:40:54.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.930]                 }
[17:40:54.930]                 ...future.workdir <- getwd()
[17:40:54.930]             }
[17:40:54.930]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.930]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.930]         }
[17:40:54.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.930]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:54.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.930]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.930]             base::names(...future.oldOptions))
[17:40:54.930]     }
[17:40:54.930]     if (FALSE) {
[17:40:54.930]     }
[17:40:54.930]     else {
[17:40:54.930]         if (TRUE) {
[17:40:54.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.930]                 open = "w")
[17:40:54.930]         }
[17:40:54.930]         else {
[17:40:54.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.930]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.930]         }
[17:40:54.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.930]             base::sink(type = "output", split = FALSE)
[17:40:54.930]             base::close(...future.stdout)
[17:40:54.930]         }, add = TRUE)
[17:40:54.930]     }
[17:40:54.930]     ...future.frame <- base::sys.nframe()
[17:40:54.930]     ...future.conditions <- base::list()
[17:40:54.930]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.930]     if (FALSE) {
[17:40:54.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.930]     }
[17:40:54.930]     ...future.result <- base::tryCatch({
[17:40:54.930]         base::withCallingHandlers({
[17:40:54.930]             ...future.value <- base::withVisible(base::local({
[17:40:54.930]                 withCallingHandlers({
[17:40:54.930]                   {
[17:40:54.930]                     do.call(function(...) {
[17:40:54.930]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.930]                       if (!identical(...future.globals.maxSize.org, 
[17:40:54.930]                         ...future.globals.maxSize)) {
[17:40:54.930]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.930]                         on.exit(options(oopts), add = TRUE)
[17:40:54.930]                       }
[17:40:54.930]                       {
[17:40:54.930]                         lapply(seq_along(...future.elements_ii), 
[17:40:54.930]                           FUN = function(jj) {
[17:40:54.930]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.930]                             ...future.FUN(...future.X_jj, ...)
[17:40:54.930]                           })
[17:40:54.930]                       }
[17:40:54.930]                     }, args = future.call.arguments)
[17:40:54.930]                   }
[17:40:54.930]                 }, immediateCondition = function(cond) {
[17:40:54.930]                   save_rds <- function (object, pathname, ...) 
[17:40:54.930]                   {
[17:40:54.930]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:54.930]                     if (file_test("-f", pathname_tmp)) {
[17:40:54.930]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.930]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:54.930]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.930]                         fi_tmp[["mtime"]])
[17:40:54.930]                     }
[17:40:54.930]                     tryCatch({
[17:40:54.930]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:54.930]                     }, error = function(ex) {
[17:40:54.930]                       msg <- conditionMessage(ex)
[17:40:54.930]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.930]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:54.930]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.930]                         fi_tmp[["mtime"]], msg)
[17:40:54.930]                       ex$message <- msg
[17:40:54.930]                       stop(ex)
[17:40:54.930]                     })
[17:40:54.930]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:54.930]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:54.930]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:54.930]                       fi_tmp <- file.info(pathname_tmp)
[17:40:54.930]                       fi <- file.info(pathname)
[17:40:54.930]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:54.930]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:54.930]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:54.930]                         fi[["size"]], fi[["mtime"]])
[17:40:54.930]                       stop(msg)
[17:40:54.930]                     }
[17:40:54.930]                     invisible(pathname)
[17:40:54.930]                   }
[17:40:54.930]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:54.930]                     rootPath = tempdir()) 
[17:40:54.930]                   {
[17:40:54.930]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:54.930]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:54.930]                       tmpdir = path, fileext = ".rds")
[17:40:54.930]                     save_rds(obj, file)
[17:40:54.930]                   }
[17:40:54.930]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:54.930]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.930]                   {
[17:40:54.930]                     inherits <- base::inherits
[17:40:54.930]                     invokeRestart <- base::invokeRestart
[17:40:54.930]                     is.null <- base::is.null
[17:40:54.930]                     muffled <- FALSE
[17:40:54.930]                     if (inherits(cond, "message")) {
[17:40:54.930]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.930]                       if (muffled) 
[17:40:54.930]                         invokeRestart("muffleMessage")
[17:40:54.930]                     }
[17:40:54.930]                     else if (inherits(cond, "warning")) {
[17:40:54.930]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.930]                       if (muffled) 
[17:40:54.930]                         invokeRestart("muffleWarning")
[17:40:54.930]                     }
[17:40:54.930]                     else if (inherits(cond, "condition")) {
[17:40:54.930]                       if (!is.null(pattern)) {
[17:40:54.930]                         computeRestarts <- base::computeRestarts
[17:40:54.930]                         grepl <- base::grepl
[17:40:54.930]                         restarts <- computeRestarts(cond)
[17:40:54.930]                         for (restart in restarts) {
[17:40:54.930]                           name <- restart$name
[17:40:54.930]                           if (is.null(name)) 
[17:40:54.930]                             next
[17:40:54.930]                           if (!grepl(pattern, name)) 
[17:40:54.930]                             next
[17:40:54.930]                           invokeRestart(restart)
[17:40:54.930]                           muffled <- TRUE
[17:40:54.930]                           break
[17:40:54.930]                         }
[17:40:54.930]                       }
[17:40:54.930]                     }
[17:40:54.930]                     invisible(muffled)
[17:40:54.930]                   }
[17:40:54.930]                   muffleCondition(cond)
[17:40:54.930]                 })
[17:40:54.930]             }))
[17:40:54.930]             future::FutureResult(value = ...future.value$value, 
[17:40:54.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.930]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.930]                     ...future.globalenv.names))
[17:40:54.930]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.930]         }, condition = base::local({
[17:40:54.930]             c <- base::c
[17:40:54.930]             inherits <- base::inherits
[17:40:54.930]             invokeRestart <- base::invokeRestart
[17:40:54.930]             length <- base::length
[17:40:54.930]             list <- base::list
[17:40:54.930]             seq.int <- base::seq.int
[17:40:54.930]             signalCondition <- base::signalCondition
[17:40:54.930]             sys.calls <- base::sys.calls
[17:40:54.930]             `[[` <- base::`[[`
[17:40:54.930]             `+` <- base::`+`
[17:40:54.930]             `<<-` <- base::`<<-`
[17:40:54.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.930]                   3L)]
[17:40:54.930]             }
[17:40:54.930]             function(cond) {
[17:40:54.930]                 is_error <- inherits(cond, "error")
[17:40:54.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.930]                   NULL)
[17:40:54.930]                 if (is_error) {
[17:40:54.930]                   sessionInformation <- function() {
[17:40:54.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.930]                       search = base::search(), system = base::Sys.info())
[17:40:54.930]                   }
[17:40:54.930]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.930]                     cond$call), session = sessionInformation(), 
[17:40:54.930]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.930]                   signalCondition(cond)
[17:40:54.930]                 }
[17:40:54.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.930]                 "immediateCondition"))) {
[17:40:54.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.930]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.930]                   if (TRUE && !signal) {
[17:40:54.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.930]                     {
[17:40:54.930]                       inherits <- base::inherits
[17:40:54.930]                       invokeRestart <- base::invokeRestart
[17:40:54.930]                       is.null <- base::is.null
[17:40:54.930]                       muffled <- FALSE
[17:40:54.930]                       if (inherits(cond, "message")) {
[17:40:54.930]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.930]                         if (muffled) 
[17:40:54.930]                           invokeRestart("muffleMessage")
[17:40:54.930]                       }
[17:40:54.930]                       else if (inherits(cond, "warning")) {
[17:40:54.930]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.930]                         if (muffled) 
[17:40:54.930]                           invokeRestart("muffleWarning")
[17:40:54.930]                       }
[17:40:54.930]                       else if (inherits(cond, "condition")) {
[17:40:54.930]                         if (!is.null(pattern)) {
[17:40:54.930]                           computeRestarts <- base::computeRestarts
[17:40:54.930]                           grepl <- base::grepl
[17:40:54.930]                           restarts <- computeRestarts(cond)
[17:40:54.930]                           for (restart in restarts) {
[17:40:54.930]                             name <- restart$name
[17:40:54.930]                             if (is.null(name)) 
[17:40:54.930]                               next
[17:40:54.930]                             if (!grepl(pattern, name)) 
[17:40:54.930]                               next
[17:40:54.930]                             invokeRestart(restart)
[17:40:54.930]                             muffled <- TRUE
[17:40:54.930]                             break
[17:40:54.930]                           }
[17:40:54.930]                         }
[17:40:54.930]                       }
[17:40:54.930]                       invisible(muffled)
[17:40:54.930]                     }
[17:40:54.930]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.930]                   }
[17:40:54.930]                 }
[17:40:54.930]                 else {
[17:40:54.930]                   if (TRUE) {
[17:40:54.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.930]                     {
[17:40:54.930]                       inherits <- base::inherits
[17:40:54.930]                       invokeRestart <- base::invokeRestart
[17:40:54.930]                       is.null <- base::is.null
[17:40:54.930]                       muffled <- FALSE
[17:40:54.930]                       if (inherits(cond, "message")) {
[17:40:54.930]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.930]                         if (muffled) 
[17:40:54.930]                           invokeRestart("muffleMessage")
[17:40:54.930]                       }
[17:40:54.930]                       else if (inherits(cond, "warning")) {
[17:40:54.930]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.930]                         if (muffled) 
[17:40:54.930]                           invokeRestart("muffleWarning")
[17:40:54.930]                       }
[17:40:54.930]                       else if (inherits(cond, "condition")) {
[17:40:54.930]                         if (!is.null(pattern)) {
[17:40:54.930]                           computeRestarts <- base::computeRestarts
[17:40:54.930]                           grepl <- base::grepl
[17:40:54.930]                           restarts <- computeRestarts(cond)
[17:40:54.930]                           for (restart in restarts) {
[17:40:54.930]                             name <- restart$name
[17:40:54.930]                             if (is.null(name)) 
[17:40:54.930]                               next
[17:40:54.930]                             if (!grepl(pattern, name)) 
[17:40:54.930]                               next
[17:40:54.930]                             invokeRestart(restart)
[17:40:54.930]                             muffled <- TRUE
[17:40:54.930]                             break
[17:40:54.930]                           }
[17:40:54.930]                         }
[17:40:54.930]                       }
[17:40:54.930]                       invisible(muffled)
[17:40:54.930]                     }
[17:40:54.930]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.930]                   }
[17:40:54.930]                 }
[17:40:54.930]             }
[17:40:54.930]         }))
[17:40:54.930]     }, error = function(ex) {
[17:40:54.930]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.930]                 ...future.rng), started = ...future.startTime, 
[17:40:54.930]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.930]             version = "1.8"), class = "FutureResult")
[17:40:54.930]     }, finally = {
[17:40:54.930]         if (!identical(...future.workdir, getwd())) 
[17:40:54.930]             setwd(...future.workdir)
[17:40:54.930]         {
[17:40:54.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.930]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.930]             }
[17:40:54.930]             base::options(...future.oldOptions)
[17:40:54.930]             if (.Platform$OS.type == "windows") {
[17:40:54.930]                 old_names <- names(...future.oldEnvVars)
[17:40:54.930]                 envs <- base::Sys.getenv()
[17:40:54.930]                 names <- names(envs)
[17:40:54.930]                 common <- intersect(names, old_names)
[17:40:54.930]                 added <- setdiff(names, old_names)
[17:40:54.930]                 removed <- setdiff(old_names, names)
[17:40:54.930]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.930]                   envs[common]]
[17:40:54.930]                 NAMES <- toupper(changed)
[17:40:54.930]                 args <- list()
[17:40:54.930]                 for (kk in seq_along(NAMES)) {
[17:40:54.930]                   name <- changed[[kk]]
[17:40:54.930]                   NAME <- NAMES[[kk]]
[17:40:54.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.930]                     next
[17:40:54.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.930]                 }
[17:40:54.930]                 NAMES <- toupper(added)
[17:40:54.930]                 for (kk in seq_along(NAMES)) {
[17:40:54.930]                   name <- added[[kk]]
[17:40:54.930]                   NAME <- NAMES[[kk]]
[17:40:54.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.930]                     next
[17:40:54.930]                   args[[name]] <- ""
[17:40:54.930]                 }
[17:40:54.930]                 NAMES <- toupper(removed)
[17:40:54.930]                 for (kk in seq_along(NAMES)) {
[17:40:54.930]                   name <- removed[[kk]]
[17:40:54.930]                   NAME <- NAMES[[kk]]
[17:40:54.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.930]                     next
[17:40:54.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.930]                 }
[17:40:54.930]                 if (length(args) > 0) 
[17:40:54.930]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.930]             }
[17:40:54.930]             else {
[17:40:54.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.930]             }
[17:40:54.930]             {
[17:40:54.930]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.930]                   0L) {
[17:40:54.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.930]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.930]                   base::options(opts)
[17:40:54.930]                 }
[17:40:54.930]                 {
[17:40:54.930]                   {
[17:40:54.930]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.930]                     NULL
[17:40:54.930]                   }
[17:40:54.930]                   options(future.plan = NULL)
[17:40:54.930]                   if (is.na(NA_character_)) 
[17:40:54.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.930]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:54.930]                     envir = parent.frame()) 
[17:40:54.930]                   {
[17:40:54.930]                     default_workers <- missing(workers)
[17:40:54.930]                     if (is.function(workers)) 
[17:40:54.930]                       workers <- workers()
[17:40:54.930]                     workers <- structure(as.integer(workers), 
[17:40:54.930]                       class = class(workers))
[17:40:54.930]                     stop_if_not(is.finite(workers), workers >= 
[17:40:54.930]                       1L)
[17:40:54.930]                     if ((workers == 1L && !inherits(workers, 
[17:40:54.930]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:54.930]                       if (default_workers) 
[17:40:54.930]                         supportsMulticore(warn = TRUE)
[17:40:54.930]                       return(sequential(..., envir = envir))
[17:40:54.930]                     }
[17:40:54.930]                     oopts <- options(mc.cores = workers)
[17:40:54.930]                     on.exit(options(oopts))
[17:40:54.930]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:54.930]                       envir = envir)
[17:40:54.930]                     if (!future$lazy) 
[17:40:54.930]                       future <- run(future)
[17:40:54.930]                     invisible(future)
[17:40:54.930]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:54.930]                 }
[17:40:54.930]             }
[17:40:54.930]         }
[17:40:54.930]     })
[17:40:54.930]     if (TRUE) {
[17:40:54.930]         base::sink(type = "output", split = FALSE)
[17:40:54.930]         if (TRUE) {
[17:40:54.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.930]         }
[17:40:54.930]         else {
[17:40:54.930]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.930]         }
[17:40:54.930]         base::close(...future.stdout)
[17:40:54.930]         ...future.stdout <- NULL
[17:40:54.930]     }
[17:40:54.930]     ...future.result$conditions <- ...future.conditions
[17:40:54.930]     ...future.result$finished <- base::Sys.time()
[17:40:54.930]     ...future.result
[17:40:54.930] }
[17:40:54.933] assign_globals() ...
[17:40:54.934] List of 11
[17:40:54.934]  $ ...future.FUN            :function (x, ...)  
[17:40:54.934]  $ x_FUN                    :function (x)  
[17:40:54.934]  $ times                    : int 1
[17:40:54.934]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:54.934]  $ stop_if_not              :function (...)  
[17:40:54.934]  $ dim                      : NULL
[17:40:54.934]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:54.934]  $ future.call.arguments    : list()
[17:40:54.934]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:54.934]  $ ...future.elements_ii    :List of 5
[17:40:54.934]   ..$ : int 6
[17:40:54.934]   ..$ : int 7
[17:40:54.934]   ..$ : int 8
[17:40:54.934]   ..$ : int 9
[17:40:54.934]   ..$ : int 10
[17:40:54.934]  $ ...future.seeds_ii       : NULL
[17:40:54.934]  $ ...future.globals.maxSize: NULL
[17:40:54.934]  - attr(*, "resolved")= logi FALSE
[17:40:54.934]  - attr(*, "total_size")= num 94336
[17:40:54.934]  - attr(*, "where")=List of 11
[17:40:54.934]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:54.934]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:54.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:54.934]  - attr(*, "already-done")= logi TRUE
[17:40:54.951] - copied ‘...future.FUN’ to environment
[17:40:54.951] - copied ‘x_FUN’ to environment
[17:40:54.951] - copied ‘times’ to environment
[17:40:54.951] - copied ‘stopf’ to environment
[17:40:54.951] - copied ‘stop_if_not’ to environment
[17:40:54.952] - copied ‘dim’ to environment
[17:40:54.952] - copied ‘valid_types’ to environment
[17:40:54.952] - copied ‘future.call.arguments’ to environment
[17:40:54.952] - copied ‘...future.elements_ii’ to environment
[17:40:54.952] - copied ‘...future.seeds_ii’ to environment
[17:40:54.952] - copied ‘...future.globals.maxSize’ to environment
[17:40:54.952] assign_globals() ... done
[17:40:54.953] requestCore(): workers = 2
[17:40:54.955] MulticoreFuture started
[17:40:54.956] - Launch lazy future ... done
[17:40:54.956] run() for ‘MulticoreFuture’ ... done
[17:40:54.956] Created future:
[17:40:54.957] plan(): Setting new future strategy stack:
[17:40:54.957] List of future strategies:
[17:40:54.957] 1. sequential:
[17:40:54.957]    - args: function (..., envir = parent.frame())
[17:40:54.957]    - tweaked: FALSE
[17:40:54.957]    - call: NULL
[17:40:54.958] plan(): nbrOfWorkers() = 1
[17:40:54.960] plan(): Setting new future strategy stack:
[17:40:54.960] List of future strategies:
[17:40:54.960] 1. multicore:
[17:40:54.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:54.960]    - tweaked: FALSE
[17:40:54.960]    - call: plan(strategy)
[17:40:54.966] plan(): nbrOfWorkers() = 2
[17:40:54.956] MulticoreFuture:
[17:40:54.956] Label: ‘future_vapply-2’
[17:40:54.956] Expression:
[17:40:54.956] {
[17:40:54.956]     do.call(function(...) {
[17:40:54.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:54.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:54.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:54.956]             on.exit(options(oopts), add = TRUE)
[17:40:54.956]         }
[17:40:54.956]         {
[17:40:54.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:54.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:54.956]                 ...future.FUN(...future.X_jj, ...)
[17:40:54.956]             })
[17:40:54.956]         }
[17:40:54.956]     }, args = future.call.arguments)
[17:40:54.956] }
[17:40:54.956] Lazy evaluation: FALSE
[17:40:54.956] Asynchronous evaluation: TRUE
[17:40:54.956] Local evaluation: TRUE
[17:40:54.956] Environment: R_GlobalEnv
[17:40:54.956] Capture standard output: TRUE
[17:40:54.956] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:54.956] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:54.956] Packages: 1 packages (‘future.apply’)
[17:40:54.956] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:54.956] Resolved: TRUE
[17:40:54.956] Value: <not collected>
[17:40:54.956] Conditions captured: <none>
[17:40:54.956] Early signaling: FALSE
[17:40:54.956] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:54.956] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.967] Chunk #2 of 2 ... DONE
[17:40:54.967] Launching 2 futures (chunks) ... DONE
[17:40:54.967] Resolving 2 futures (chunks) ...
[17:40:54.967] resolve() on list ...
[17:40:54.967]  recursive: 0
[17:40:54.968]  length: 2
[17:40:54.968] 
[17:40:54.968] Future #1
[17:40:54.969] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:54.969] - nx: 2
[17:40:54.969] - relay: TRUE
[17:40:54.970] - stdout: TRUE
[17:40:54.970] - signal: TRUE
[17:40:54.970] - resignal: FALSE
[17:40:54.970] - force: TRUE
[17:40:54.970] - relayed: [n=2] FALSE, FALSE
[17:40:54.970] - queued futures: [n=2] FALSE, FALSE
[17:40:54.971]  - until=1
[17:40:54.971]  - relaying element #1
[17:40:54.971] - relayed: [n=2] TRUE, FALSE
[17:40:54.971] - queued futures: [n=2] TRUE, FALSE
[17:40:54.971] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:54.972]  length: 1 (resolved future 1)
[17:40:54.972] Future #2
[17:40:54.973] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:54.973] - nx: 2
[17:40:54.973] - relay: TRUE
[17:40:54.973] - stdout: TRUE
[17:40:54.973] - signal: TRUE
[17:40:54.974] - resignal: FALSE
[17:40:54.974] - force: TRUE
[17:40:54.974] - relayed: [n=2] TRUE, FALSE
[17:40:54.974] - queued futures: [n=2] TRUE, FALSE
[17:40:54.974]  - until=2
[17:40:54.974]  - relaying element #2
[17:40:54.974] - relayed: [n=2] TRUE, TRUE
[17:40:54.975] - queued futures: [n=2] TRUE, TRUE
[17:40:54.975] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:54.975]  length: 0 (resolved future 2)
[17:40:54.975] Relaying remaining futures
[17:40:54.975] signalConditionsASAP(NULL, pos=0) ...
[17:40:54.975] - nx: 2
[17:40:54.975] - relay: TRUE
[17:40:54.975] - stdout: TRUE
[17:40:54.976] - signal: TRUE
[17:40:54.976] - resignal: FALSE
[17:40:54.976] - force: TRUE
[17:40:54.976] - relayed: [n=2] TRUE, TRUE
[17:40:54.976] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:54.976] - relayed: [n=2] TRUE, TRUE
[17:40:54.976] - queued futures: [n=2] TRUE, TRUE
[17:40:54.977] signalConditionsASAP(NULL, pos=0) ... done
[17:40:54.977] resolve() on list ... DONE
[17:40:54.977]  - Number of value chunks collected: 2
[17:40:54.977] Resolving 2 futures (chunks) ... DONE
[17:40:54.977] Reducing values from 2 chunks ...
[17:40:54.977]  - Number of values collected after concatenation: 10
[17:40:54.977]  - Number of values expected: 10
[17:40:54.978] Reducing values from 2 chunks ... DONE
[17:40:54.978] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:40:54.979] future_lapply() ...
[17:40:54.989] Number of chunks: 2
[17:40:54.990] getGlobalsAndPackagesXApply() ...
[17:40:54.990]  - future.globals: TRUE
[17:40:54.990] getGlobalsAndPackages() ...
[17:40:54.990] Searching for globals...
[17:40:54.996] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:40:54.996] Searching for globals ... DONE
[17:40:54.996] Resolving globals: FALSE
[17:40:54.997] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:40:54.998] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:54.998] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.998] - packages: [1] ‘future.apply’
[17:40:54.998] getGlobalsAndPackages() ... DONE
[17:40:54.999]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:54.999]  - needed namespaces: [n=1] ‘future.apply’
[17:40:54.999] Finding globals ... DONE
[17:40:54.999]  - use_args: TRUE
[17:40:54.999]  - Getting '...' globals ...
[17:40:54.999] resolve() on list ...
[17:40:54.999]  recursive: 0
[17:40:55.000]  length: 1
[17:40:55.000]  elements: ‘...’
[17:40:55.000]  length: 0 (resolved future 1)
[17:40:55.000] resolve() on list ... DONE
[17:40:55.000]    - '...' content: [n=0] 
[17:40:55.000] List of 1
[17:40:55.000]  $ ...: list()
[17:40:55.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.000]  - attr(*, "where")=List of 1
[17:40:55.000]   ..$ ...:<environment: 0x564f30507480> 
[17:40:55.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.000]  - attr(*, "resolved")= logi TRUE
[17:40:55.000]  - attr(*, "total_size")= num NA
[17:40:55.003]  - Getting '...' globals ... DONE
[17:40:55.003] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:55.003] List of 8
[17:40:55.003]  $ ...future.FUN:function (x, ...)  
[17:40:55.003]  $ x_FUN        :function (x)  
[17:40:55.003]  $ times        : int 2
[17:40:55.003]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.003]  $ stop_if_not  :function (...)  
[17:40:55.003]  $ dim          : NULL
[17:40:55.003]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:55.003]  $ ...          : list()
[17:40:55.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.003]  - attr(*, "where")=List of 8
[17:40:55.003]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:55.003]   ..$ ...          :<environment: 0x564f30507480> 
[17:40:55.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.003]  - attr(*, "resolved")= logi FALSE
[17:40:55.003]  - attr(*, "total_size")= num 96456
[17:40:55.009] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:55.009] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.009] Number of futures (= number of chunks): 2
[17:40:55.012] Launching 2 futures (chunks) ...
[17:40:55.012] Chunk #1 of 2 ...
[17:40:55.012]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.012] getGlobalsAndPackages() ...
[17:40:55.012] Searching for globals...
[17:40:55.013] 
[17:40:55.013] Searching for globals ... DONE
[17:40:55.013] - globals: [0] <none>
[17:40:55.013] getGlobalsAndPackages() ... DONE
[17:40:55.013]    + additional globals found: [n=0] 
[17:40:55.013]    + additional namespaces needed: [n=0] 
[17:40:55.013]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.014]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.014]  - seeds: <none>
[17:40:55.014] getGlobalsAndPackages() ...
[17:40:55.014] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.014] Resolving globals: FALSE
[17:40:55.014] Tweak future expression to call with '...' arguments ...
[17:40:55.014] {
[17:40:55.014]     do.call(function(...) {
[17:40:55.014]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.014]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.014]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.014]             on.exit(options(oopts), add = TRUE)
[17:40:55.014]         }
[17:40:55.014]         {
[17:40:55.014]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.014]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.014]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.014]             })
[17:40:55.014]         }
[17:40:55.014]     }, args = future.call.arguments)
[17:40:55.014] }
[17:40:55.015] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.015] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.015] - packages: [1] ‘future.apply’
[17:40:55.016] getGlobalsAndPackages() ... DONE
[17:40:55.016] run() for ‘Future’ ...
[17:40:55.016] - state: ‘created’
[17:40:55.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.021] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.021]   - Field: ‘label’
[17:40:55.021]   - Field: ‘local’
[17:40:55.022]   - Field: ‘owner’
[17:40:55.022]   - Field: ‘envir’
[17:40:55.022]   - Field: ‘workers’
[17:40:55.022]   - Field: ‘packages’
[17:40:55.022]   - Field: ‘gc’
[17:40:55.022]   - Field: ‘job’
[17:40:55.022]   - Field: ‘conditions’
[17:40:55.022]   - Field: ‘expr’
[17:40:55.022]   - Field: ‘uuid’
[17:40:55.023]   - Field: ‘seed’
[17:40:55.023]   - Field: ‘version’
[17:40:55.023]   - Field: ‘result’
[17:40:55.023]   - Field: ‘asynchronous’
[17:40:55.023]   - Field: ‘calls’
[17:40:55.023]   - Field: ‘globals’
[17:40:55.023]   - Field: ‘stdout’
[17:40:55.023]   - Field: ‘earlySignal’
[17:40:55.023]   - Field: ‘lazy’
[17:40:55.023]   - Field: ‘state’
[17:40:55.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.024] - Launch lazy future ...
[17:40:55.024] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.024] Packages needed by future strategies (n = 0): <none>
[17:40:55.025] {
[17:40:55.025]     {
[17:40:55.025]         {
[17:40:55.025]             ...future.startTime <- base::Sys.time()
[17:40:55.025]             {
[17:40:55.025]                 {
[17:40:55.025]                   {
[17:40:55.025]                     {
[17:40:55.025]                       {
[17:40:55.025]                         base::local({
[17:40:55.025]                           has_future <- base::requireNamespace("future", 
[17:40:55.025]                             quietly = TRUE)
[17:40:55.025]                           if (has_future) {
[17:40:55.025]                             ns <- base::getNamespace("future")
[17:40:55.025]                             version <- ns[[".package"]][["version"]]
[17:40:55.025]                             if (is.null(version)) 
[17:40:55.025]                               version <- utils::packageVersion("future")
[17:40:55.025]                           }
[17:40:55.025]                           else {
[17:40:55.025]                             version <- NULL
[17:40:55.025]                           }
[17:40:55.025]                           if (!has_future || version < "1.8.0") {
[17:40:55.025]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.025]                               "", base::R.version$version.string), 
[17:40:55.025]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.025]                                 base::R.version$platform, 8 * 
[17:40:55.025]                                   base::.Machine$sizeof.pointer), 
[17:40:55.025]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.025]                                 "release", "version")], collapse = " "), 
[17:40:55.025]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.025]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.025]                               info)
[17:40:55.025]                             info <- base::paste(info, collapse = "; ")
[17:40:55.025]                             if (!has_future) {
[17:40:55.025]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.025]                                 info)
[17:40:55.025]                             }
[17:40:55.025]                             else {
[17:40:55.025]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.025]                                 info, version)
[17:40:55.025]                             }
[17:40:55.025]                             base::stop(msg)
[17:40:55.025]                           }
[17:40:55.025]                         })
[17:40:55.025]                       }
[17:40:55.025]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.025]                       base::options(mc.cores = 1L)
[17:40:55.025]                     }
[17:40:55.025]                     base::local({
[17:40:55.025]                       for (pkg in "future.apply") {
[17:40:55.025]                         base::loadNamespace(pkg)
[17:40:55.025]                         base::library(pkg, character.only = TRUE)
[17:40:55.025]                       }
[17:40:55.025]                     })
[17:40:55.025]                   }
[17:40:55.025]                   options(future.plan = NULL)
[17:40:55.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.025]                 }
[17:40:55.025]                 ...future.workdir <- getwd()
[17:40:55.025]             }
[17:40:55.025]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.025]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.025]         }
[17:40:55.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.025]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.025]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.025]             base::names(...future.oldOptions))
[17:40:55.025]     }
[17:40:55.025]     if (FALSE) {
[17:40:55.025]     }
[17:40:55.025]     else {
[17:40:55.025]         if (TRUE) {
[17:40:55.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.025]                 open = "w")
[17:40:55.025]         }
[17:40:55.025]         else {
[17:40:55.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.025]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.025]         }
[17:40:55.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.025]             base::sink(type = "output", split = FALSE)
[17:40:55.025]             base::close(...future.stdout)
[17:40:55.025]         }, add = TRUE)
[17:40:55.025]     }
[17:40:55.025]     ...future.frame <- base::sys.nframe()
[17:40:55.025]     ...future.conditions <- base::list()
[17:40:55.025]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.025]     if (FALSE) {
[17:40:55.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.025]     }
[17:40:55.025]     ...future.result <- base::tryCatch({
[17:40:55.025]         base::withCallingHandlers({
[17:40:55.025]             ...future.value <- base::withVisible(base::local({
[17:40:55.025]                 withCallingHandlers({
[17:40:55.025]                   {
[17:40:55.025]                     do.call(function(...) {
[17:40:55.025]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.025]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.025]                         ...future.globals.maxSize)) {
[17:40:55.025]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.025]                         on.exit(options(oopts), add = TRUE)
[17:40:55.025]                       }
[17:40:55.025]                       {
[17:40:55.025]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.025]                           FUN = function(jj) {
[17:40:55.025]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.025]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.025]                           })
[17:40:55.025]                       }
[17:40:55.025]                     }, args = future.call.arguments)
[17:40:55.025]                   }
[17:40:55.025]                 }, immediateCondition = function(cond) {
[17:40:55.025]                   save_rds <- function (object, pathname, ...) 
[17:40:55.025]                   {
[17:40:55.025]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.025]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.025]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.025]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.025]                         fi_tmp[["mtime"]])
[17:40:55.025]                     }
[17:40:55.025]                     tryCatch({
[17:40:55.025]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.025]                     }, error = function(ex) {
[17:40:55.025]                       msg <- conditionMessage(ex)
[17:40:55.025]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.025]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.025]                         fi_tmp[["mtime"]], msg)
[17:40:55.025]                       ex$message <- msg
[17:40:55.025]                       stop(ex)
[17:40:55.025]                     })
[17:40:55.025]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.025]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.025]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.025]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.025]                       fi <- file.info(pathname)
[17:40:55.025]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.025]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.025]                         fi[["size"]], fi[["mtime"]])
[17:40:55.025]                       stop(msg)
[17:40:55.025]                     }
[17:40:55.025]                     invisible(pathname)
[17:40:55.025]                   }
[17:40:55.025]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.025]                     rootPath = tempdir()) 
[17:40:55.025]                   {
[17:40:55.025]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.025]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.025]                       tmpdir = path, fileext = ".rds")
[17:40:55.025]                     save_rds(obj, file)
[17:40:55.025]                   }
[17:40:55.025]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.025]                   {
[17:40:55.025]                     inherits <- base::inherits
[17:40:55.025]                     invokeRestart <- base::invokeRestart
[17:40:55.025]                     is.null <- base::is.null
[17:40:55.025]                     muffled <- FALSE
[17:40:55.025]                     if (inherits(cond, "message")) {
[17:40:55.025]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.025]                       if (muffled) 
[17:40:55.025]                         invokeRestart("muffleMessage")
[17:40:55.025]                     }
[17:40:55.025]                     else if (inherits(cond, "warning")) {
[17:40:55.025]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.025]                       if (muffled) 
[17:40:55.025]                         invokeRestart("muffleWarning")
[17:40:55.025]                     }
[17:40:55.025]                     else if (inherits(cond, "condition")) {
[17:40:55.025]                       if (!is.null(pattern)) {
[17:40:55.025]                         computeRestarts <- base::computeRestarts
[17:40:55.025]                         grepl <- base::grepl
[17:40:55.025]                         restarts <- computeRestarts(cond)
[17:40:55.025]                         for (restart in restarts) {
[17:40:55.025]                           name <- restart$name
[17:40:55.025]                           if (is.null(name)) 
[17:40:55.025]                             next
[17:40:55.025]                           if (!grepl(pattern, name)) 
[17:40:55.025]                             next
[17:40:55.025]                           invokeRestart(restart)
[17:40:55.025]                           muffled <- TRUE
[17:40:55.025]                           break
[17:40:55.025]                         }
[17:40:55.025]                       }
[17:40:55.025]                     }
[17:40:55.025]                     invisible(muffled)
[17:40:55.025]                   }
[17:40:55.025]                   muffleCondition(cond)
[17:40:55.025]                 })
[17:40:55.025]             }))
[17:40:55.025]             future::FutureResult(value = ...future.value$value, 
[17:40:55.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.025]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.025]                     ...future.globalenv.names))
[17:40:55.025]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.025]         }, condition = base::local({
[17:40:55.025]             c <- base::c
[17:40:55.025]             inherits <- base::inherits
[17:40:55.025]             invokeRestart <- base::invokeRestart
[17:40:55.025]             length <- base::length
[17:40:55.025]             list <- base::list
[17:40:55.025]             seq.int <- base::seq.int
[17:40:55.025]             signalCondition <- base::signalCondition
[17:40:55.025]             sys.calls <- base::sys.calls
[17:40:55.025]             `[[` <- base::`[[`
[17:40:55.025]             `+` <- base::`+`
[17:40:55.025]             `<<-` <- base::`<<-`
[17:40:55.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.025]                   3L)]
[17:40:55.025]             }
[17:40:55.025]             function(cond) {
[17:40:55.025]                 is_error <- inherits(cond, "error")
[17:40:55.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.025]                   NULL)
[17:40:55.025]                 if (is_error) {
[17:40:55.025]                   sessionInformation <- function() {
[17:40:55.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.025]                       search = base::search(), system = base::Sys.info())
[17:40:55.025]                   }
[17:40:55.025]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.025]                     cond$call), session = sessionInformation(), 
[17:40:55.025]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.025]                   signalCondition(cond)
[17:40:55.025]                 }
[17:40:55.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.025]                 "immediateCondition"))) {
[17:40:55.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.025]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.025]                   if (TRUE && !signal) {
[17:40:55.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.025]                     {
[17:40:55.025]                       inherits <- base::inherits
[17:40:55.025]                       invokeRestart <- base::invokeRestart
[17:40:55.025]                       is.null <- base::is.null
[17:40:55.025]                       muffled <- FALSE
[17:40:55.025]                       if (inherits(cond, "message")) {
[17:40:55.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.025]                         if (muffled) 
[17:40:55.025]                           invokeRestart("muffleMessage")
[17:40:55.025]                       }
[17:40:55.025]                       else if (inherits(cond, "warning")) {
[17:40:55.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.025]                         if (muffled) 
[17:40:55.025]                           invokeRestart("muffleWarning")
[17:40:55.025]                       }
[17:40:55.025]                       else if (inherits(cond, "condition")) {
[17:40:55.025]                         if (!is.null(pattern)) {
[17:40:55.025]                           computeRestarts <- base::computeRestarts
[17:40:55.025]                           grepl <- base::grepl
[17:40:55.025]                           restarts <- computeRestarts(cond)
[17:40:55.025]                           for (restart in restarts) {
[17:40:55.025]                             name <- restart$name
[17:40:55.025]                             if (is.null(name)) 
[17:40:55.025]                               next
[17:40:55.025]                             if (!grepl(pattern, name)) 
[17:40:55.025]                               next
[17:40:55.025]                             invokeRestart(restart)
[17:40:55.025]                             muffled <- TRUE
[17:40:55.025]                             break
[17:40:55.025]                           }
[17:40:55.025]                         }
[17:40:55.025]                       }
[17:40:55.025]                       invisible(muffled)
[17:40:55.025]                     }
[17:40:55.025]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.025]                   }
[17:40:55.025]                 }
[17:40:55.025]                 else {
[17:40:55.025]                   if (TRUE) {
[17:40:55.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.025]                     {
[17:40:55.025]                       inherits <- base::inherits
[17:40:55.025]                       invokeRestart <- base::invokeRestart
[17:40:55.025]                       is.null <- base::is.null
[17:40:55.025]                       muffled <- FALSE
[17:40:55.025]                       if (inherits(cond, "message")) {
[17:40:55.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.025]                         if (muffled) 
[17:40:55.025]                           invokeRestart("muffleMessage")
[17:40:55.025]                       }
[17:40:55.025]                       else if (inherits(cond, "warning")) {
[17:40:55.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.025]                         if (muffled) 
[17:40:55.025]                           invokeRestart("muffleWarning")
[17:40:55.025]                       }
[17:40:55.025]                       else if (inherits(cond, "condition")) {
[17:40:55.025]                         if (!is.null(pattern)) {
[17:40:55.025]                           computeRestarts <- base::computeRestarts
[17:40:55.025]                           grepl <- base::grepl
[17:40:55.025]                           restarts <- computeRestarts(cond)
[17:40:55.025]                           for (restart in restarts) {
[17:40:55.025]                             name <- restart$name
[17:40:55.025]                             if (is.null(name)) 
[17:40:55.025]                               next
[17:40:55.025]                             if (!grepl(pattern, name)) 
[17:40:55.025]                               next
[17:40:55.025]                             invokeRestart(restart)
[17:40:55.025]                             muffled <- TRUE
[17:40:55.025]                             break
[17:40:55.025]                           }
[17:40:55.025]                         }
[17:40:55.025]                       }
[17:40:55.025]                       invisible(muffled)
[17:40:55.025]                     }
[17:40:55.025]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.025]                   }
[17:40:55.025]                 }
[17:40:55.025]             }
[17:40:55.025]         }))
[17:40:55.025]     }, error = function(ex) {
[17:40:55.025]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.025]                 ...future.rng), started = ...future.startTime, 
[17:40:55.025]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.025]             version = "1.8"), class = "FutureResult")
[17:40:55.025]     }, finally = {
[17:40:55.025]         if (!identical(...future.workdir, getwd())) 
[17:40:55.025]             setwd(...future.workdir)
[17:40:55.025]         {
[17:40:55.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.025]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.025]             }
[17:40:55.025]             base::options(...future.oldOptions)
[17:40:55.025]             if (.Platform$OS.type == "windows") {
[17:40:55.025]                 old_names <- names(...future.oldEnvVars)
[17:40:55.025]                 envs <- base::Sys.getenv()
[17:40:55.025]                 names <- names(envs)
[17:40:55.025]                 common <- intersect(names, old_names)
[17:40:55.025]                 added <- setdiff(names, old_names)
[17:40:55.025]                 removed <- setdiff(old_names, names)
[17:40:55.025]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.025]                   envs[common]]
[17:40:55.025]                 NAMES <- toupper(changed)
[17:40:55.025]                 args <- list()
[17:40:55.025]                 for (kk in seq_along(NAMES)) {
[17:40:55.025]                   name <- changed[[kk]]
[17:40:55.025]                   NAME <- NAMES[[kk]]
[17:40:55.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.025]                     next
[17:40:55.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.025]                 }
[17:40:55.025]                 NAMES <- toupper(added)
[17:40:55.025]                 for (kk in seq_along(NAMES)) {
[17:40:55.025]                   name <- added[[kk]]
[17:40:55.025]                   NAME <- NAMES[[kk]]
[17:40:55.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.025]                     next
[17:40:55.025]                   args[[name]] <- ""
[17:40:55.025]                 }
[17:40:55.025]                 NAMES <- toupper(removed)
[17:40:55.025]                 for (kk in seq_along(NAMES)) {
[17:40:55.025]                   name <- removed[[kk]]
[17:40:55.025]                   NAME <- NAMES[[kk]]
[17:40:55.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.025]                     next
[17:40:55.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.025]                 }
[17:40:55.025]                 if (length(args) > 0) 
[17:40:55.025]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.025]             }
[17:40:55.025]             else {
[17:40:55.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.025]             }
[17:40:55.025]             {
[17:40:55.025]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.025]                   0L) {
[17:40:55.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.025]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.025]                   base::options(opts)
[17:40:55.025]                 }
[17:40:55.025]                 {
[17:40:55.025]                   {
[17:40:55.025]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.025]                     NULL
[17:40:55.025]                   }
[17:40:55.025]                   options(future.plan = NULL)
[17:40:55.025]                   if (is.na(NA_character_)) 
[17:40:55.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.025]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.025]                     envir = parent.frame()) 
[17:40:55.025]                   {
[17:40:55.025]                     default_workers <- missing(workers)
[17:40:55.025]                     if (is.function(workers)) 
[17:40:55.025]                       workers <- workers()
[17:40:55.025]                     workers <- structure(as.integer(workers), 
[17:40:55.025]                       class = class(workers))
[17:40:55.025]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.025]                       1L)
[17:40:55.025]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.025]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.025]                       if (default_workers) 
[17:40:55.025]                         supportsMulticore(warn = TRUE)
[17:40:55.025]                       return(sequential(..., envir = envir))
[17:40:55.025]                     }
[17:40:55.025]                     oopts <- options(mc.cores = workers)
[17:40:55.025]                     on.exit(options(oopts))
[17:40:55.025]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.025]                       envir = envir)
[17:40:55.025]                     if (!future$lazy) 
[17:40:55.025]                       future <- run(future)
[17:40:55.025]                     invisible(future)
[17:40:55.025]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.025]                 }
[17:40:55.025]             }
[17:40:55.025]         }
[17:40:55.025]     })
[17:40:55.025]     if (TRUE) {
[17:40:55.025]         base::sink(type = "output", split = FALSE)
[17:40:55.025]         if (TRUE) {
[17:40:55.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.025]         }
[17:40:55.025]         else {
[17:40:55.025]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.025]         }
[17:40:55.025]         base::close(...future.stdout)
[17:40:55.025]         ...future.stdout <- NULL
[17:40:55.025]     }
[17:40:55.025]     ...future.result$conditions <- ...future.conditions
[17:40:55.025]     ...future.result$finished <- base::Sys.time()
[17:40:55.025]     ...future.result
[17:40:55.025] }
[17:40:55.028] assign_globals() ...
[17:40:55.028] List of 11
[17:40:55.028]  $ ...future.FUN            :function (x, ...)  
[17:40:55.028]  $ x_FUN                    :function (x)  
[17:40:55.028]  $ times                    : int 2
[17:40:55.028]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.028]  $ stop_if_not              :function (...)  
[17:40:55.028]  $ dim                      : NULL
[17:40:55.028]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.028]  $ future.call.arguments    : list()
[17:40:55.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.028]  $ ...future.elements_ii    :List of 5
[17:40:55.028]   ..$ : int 1
[17:40:55.028]   ..$ : int 2
[17:40:55.028]   ..$ : int 3
[17:40:55.028]   ..$ : int 4
[17:40:55.028]   ..$ : int 5
[17:40:55.028]  $ ...future.seeds_ii       : NULL
[17:40:55.028]  $ ...future.globals.maxSize: NULL
[17:40:55.028]  - attr(*, "resolved")= logi FALSE
[17:40:55.028]  - attr(*, "total_size")= num 96456
[17:40:55.028]  - attr(*, "where")=List of 11
[17:40:55.028]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.028]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.028]  - attr(*, "already-done")= logi TRUE
[17:40:55.037] - copied ‘...future.FUN’ to environment
[17:40:55.037] - reassign environment for ‘x_FUN’
[17:40:55.037] - copied ‘x_FUN’ to environment
[17:40:55.038] - copied ‘times’ to environment
[17:40:55.040] - copied ‘stopf’ to environment
[17:40:55.040] - copied ‘stop_if_not’ to environment
[17:40:55.040] - copied ‘dim’ to environment
[17:40:55.040] - copied ‘valid_types’ to environment
[17:40:55.040] - copied ‘future.call.arguments’ to environment
[17:40:55.041] - copied ‘...future.elements_ii’ to environment
[17:40:55.041] - copied ‘...future.seeds_ii’ to environment
[17:40:55.041] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.041] assign_globals() ... done
[17:40:55.041] requestCore(): workers = 2
[17:40:55.044] MulticoreFuture started
[17:40:55.044] - Launch lazy future ... done
[17:40:55.045] run() for ‘MulticoreFuture’ ... done
[17:40:55.045] Created future:
[17:40:55.046] plan(): Setting new future strategy stack:
[17:40:55.046] List of future strategies:
[17:40:55.046] 1. sequential:
[17:40:55.046]    - args: function (..., envir = parent.frame())
[17:40:55.046]    - tweaked: FALSE
[17:40:55.046]    - call: NULL
[17:40:55.048] plan(): nbrOfWorkers() = 1
[17:40:55.051] plan(): Setting new future strategy stack:
[17:40:55.051] List of future strategies:
[17:40:55.051] 1. multicore:
[17:40:55.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.051]    - tweaked: FALSE
[17:40:55.051]    - call: plan(strategy)
[17:40:55.058] plan(): nbrOfWorkers() = 2
[17:40:55.046] MulticoreFuture:
[17:40:55.046] Label: ‘future_vapply-1’
[17:40:55.046] Expression:
[17:40:55.046] {
[17:40:55.046]     do.call(function(...) {
[17:40:55.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.046]             on.exit(options(oopts), add = TRUE)
[17:40:55.046]         }
[17:40:55.046]         {
[17:40:55.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.046]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.046]             })
[17:40:55.046]         }
[17:40:55.046]     }, args = future.call.arguments)
[17:40:55.046] }
[17:40:55.046] Lazy evaluation: FALSE
[17:40:55.046] Asynchronous evaluation: TRUE
[17:40:55.046] Local evaluation: TRUE
[17:40:55.046] Environment: R_GlobalEnv
[17:40:55.046] Capture standard output: TRUE
[17:40:55.046] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.046] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.046] Packages: 1 packages (‘future.apply’)
[17:40:55.046] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.046] Resolved: TRUE
[17:40:55.046] Value: <not collected>
[17:40:55.046] Conditions captured: <none>
[17:40:55.046] Early signaling: FALSE
[17:40:55.046] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.046] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.059] Chunk #1 of 2 ... DONE
[17:40:55.059] Chunk #2 of 2 ...
[17:40:55.060]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.060] getGlobalsAndPackages() ...
[17:40:55.060] Searching for globals...
[17:40:55.060] 
[17:40:55.060] Searching for globals ... DONE
[17:40:55.061] - globals: [0] <none>
[17:40:55.061] getGlobalsAndPackages() ... DONE
[17:40:55.061]    + additional globals found: [n=0] 
[17:40:55.061]    + additional namespaces needed: [n=0] 
[17:40:55.061]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.061]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.062]  - seeds: <none>
[17:40:55.062] getGlobalsAndPackages() ...
[17:40:55.062] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.062] Resolving globals: FALSE
[17:40:55.062] Tweak future expression to call with '...' arguments ...
[17:40:55.063] {
[17:40:55.063]     do.call(function(...) {
[17:40:55.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.063]             on.exit(options(oopts), add = TRUE)
[17:40:55.063]         }
[17:40:55.063]         {
[17:40:55.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.063]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.063]             })
[17:40:55.063]         }
[17:40:55.063]     }, args = future.call.arguments)
[17:40:55.063] }
[17:40:55.063] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.064] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.065] - packages: [1] ‘future.apply’
[17:40:55.065] getGlobalsAndPackages() ... DONE
[17:40:55.065] run() for ‘Future’ ...
[17:40:55.066] - state: ‘created’
[17:40:55.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.071] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.071] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.071]   - Field: ‘label’
[17:40:55.071]   - Field: ‘local’
[17:40:55.071]   - Field: ‘owner’
[17:40:55.072]   - Field: ‘envir’
[17:40:55.072]   - Field: ‘workers’
[17:40:55.072]   - Field: ‘packages’
[17:40:55.072]   - Field: ‘gc’
[17:40:55.072]   - Field: ‘job’
[17:40:55.072]   - Field: ‘conditions’
[17:40:55.072]   - Field: ‘expr’
[17:40:55.073]   - Field: ‘uuid’
[17:40:55.073]   - Field: ‘seed’
[17:40:55.073]   - Field: ‘version’
[17:40:55.073]   - Field: ‘result’
[17:40:55.073]   - Field: ‘asynchronous’
[17:40:55.073]   - Field: ‘calls’
[17:40:55.073]   - Field: ‘globals’
[17:40:55.074]   - Field: ‘stdout’
[17:40:55.074]   - Field: ‘earlySignal’
[17:40:55.074]   - Field: ‘lazy’
[17:40:55.074]   - Field: ‘state’
[17:40:55.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.074] - Launch lazy future ...
[17:40:55.075] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.075] Packages needed by future strategies (n = 0): <none>
[17:40:55.076] {
[17:40:55.076]     {
[17:40:55.076]         {
[17:40:55.076]             ...future.startTime <- base::Sys.time()
[17:40:55.076]             {
[17:40:55.076]                 {
[17:40:55.076]                   {
[17:40:55.076]                     {
[17:40:55.076]                       {
[17:40:55.076]                         base::local({
[17:40:55.076]                           has_future <- base::requireNamespace("future", 
[17:40:55.076]                             quietly = TRUE)
[17:40:55.076]                           if (has_future) {
[17:40:55.076]                             ns <- base::getNamespace("future")
[17:40:55.076]                             version <- ns[[".package"]][["version"]]
[17:40:55.076]                             if (is.null(version)) 
[17:40:55.076]                               version <- utils::packageVersion("future")
[17:40:55.076]                           }
[17:40:55.076]                           else {
[17:40:55.076]                             version <- NULL
[17:40:55.076]                           }
[17:40:55.076]                           if (!has_future || version < "1.8.0") {
[17:40:55.076]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.076]                               "", base::R.version$version.string), 
[17:40:55.076]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.076]                                 base::R.version$platform, 8 * 
[17:40:55.076]                                   base::.Machine$sizeof.pointer), 
[17:40:55.076]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.076]                                 "release", "version")], collapse = " "), 
[17:40:55.076]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.076]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.076]                               info)
[17:40:55.076]                             info <- base::paste(info, collapse = "; ")
[17:40:55.076]                             if (!has_future) {
[17:40:55.076]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.076]                                 info)
[17:40:55.076]                             }
[17:40:55.076]                             else {
[17:40:55.076]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.076]                                 info, version)
[17:40:55.076]                             }
[17:40:55.076]                             base::stop(msg)
[17:40:55.076]                           }
[17:40:55.076]                         })
[17:40:55.076]                       }
[17:40:55.076]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.076]                       base::options(mc.cores = 1L)
[17:40:55.076]                     }
[17:40:55.076]                     base::local({
[17:40:55.076]                       for (pkg in "future.apply") {
[17:40:55.076]                         base::loadNamespace(pkg)
[17:40:55.076]                         base::library(pkg, character.only = TRUE)
[17:40:55.076]                       }
[17:40:55.076]                     })
[17:40:55.076]                   }
[17:40:55.076]                   options(future.plan = NULL)
[17:40:55.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.076]                 }
[17:40:55.076]                 ...future.workdir <- getwd()
[17:40:55.076]             }
[17:40:55.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.076]         }
[17:40:55.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.076]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.076]             base::names(...future.oldOptions))
[17:40:55.076]     }
[17:40:55.076]     if (FALSE) {
[17:40:55.076]     }
[17:40:55.076]     else {
[17:40:55.076]         if (TRUE) {
[17:40:55.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.076]                 open = "w")
[17:40:55.076]         }
[17:40:55.076]         else {
[17:40:55.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.076]         }
[17:40:55.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.076]             base::sink(type = "output", split = FALSE)
[17:40:55.076]             base::close(...future.stdout)
[17:40:55.076]         }, add = TRUE)
[17:40:55.076]     }
[17:40:55.076]     ...future.frame <- base::sys.nframe()
[17:40:55.076]     ...future.conditions <- base::list()
[17:40:55.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.076]     if (FALSE) {
[17:40:55.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.076]     }
[17:40:55.076]     ...future.result <- base::tryCatch({
[17:40:55.076]         base::withCallingHandlers({
[17:40:55.076]             ...future.value <- base::withVisible(base::local({
[17:40:55.076]                 withCallingHandlers({
[17:40:55.076]                   {
[17:40:55.076]                     do.call(function(...) {
[17:40:55.076]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.076]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.076]                         ...future.globals.maxSize)) {
[17:40:55.076]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.076]                         on.exit(options(oopts), add = TRUE)
[17:40:55.076]                       }
[17:40:55.076]                       {
[17:40:55.076]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.076]                           FUN = function(jj) {
[17:40:55.076]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.076]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.076]                           })
[17:40:55.076]                       }
[17:40:55.076]                     }, args = future.call.arguments)
[17:40:55.076]                   }
[17:40:55.076]                 }, immediateCondition = function(cond) {
[17:40:55.076]                   save_rds <- function (object, pathname, ...) 
[17:40:55.076]                   {
[17:40:55.076]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.076]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.076]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.076]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.076]                         fi_tmp[["mtime"]])
[17:40:55.076]                     }
[17:40:55.076]                     tryCatch({
[17:40:55.076]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.076]                     }, error = function(ex) {
[17:40:55.076]                       msg <- conditionMessage(ex)
[17:40:55.076]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.076]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.076]                         fi_tmp[["mtime"]], msg)
[17:40:55.076]                       ex$message <- msg
[17:40:55.076]                       stop(ex)
[17:40:55.076]                     })
[17:40:55.076]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.076]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.076]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.076]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.076]                       fi <- file.info(pathname)
[17:40:55.076]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.076]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.076]                         fi[["size"]], fi[["mtime"]])
[17:40:55.076]                       stop(msg)
[17:40:55.076]                     }
[17:40:55.076]                     invisible(pathname)
[17:40:55.076]                   }
[17:40:55.076]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.076]                     rootPath = tempdir()) 
[17:40:55.076]                   {
[17:40:55.076]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.076]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.076]                       tmpdir = path, fileext = ".rds")
[17:40:55.076]                     save_rds(obj, file)
[17:40:55.076]                   }
[17:40:55.076]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.076]                   {
[17:40:55.076]                     inherits <- base::inherits
[17:40:55.076]                     invokeRestart <- base::invokeRestart
[17:40:55.076]                     is.null <- base::is.null
[17:40:55.076]                     muffled <- FALSE
[17:40:55.076]                     if (inherits(cond, "message")) {
[17:40:55.076]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.076]                       if (muffled) 
[17:40:55.076]                         invokeRestart("muffleMessage")
[17:40:55.076]                     }
[17:40:55.076]                     else if (inherits(cond, "warning")) {
[17:40:55.076]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.076]                       if (muffled) 
[17:40:55.076]                         invokeRestart("muffleWarning")
[17:40:55.076]                     }
[17:40:55.076]                     else if (inherits(cond, "condition")) {
[17:40:55.076]                       if (!is.null(pattern)) {
[17:40:55.076]                         computeRestarts <- base::computeRestarts
[17:40:55.076]                         grepl <- base::grepl
[17:40:55.076]                         restarts <- computeRestarts(cond)
[17:40:55.076]                         for (restart in restarts) {
[17:40:55.076]                           name <- restart$name
[17:40:55.076]                           if (is.null(name)) 
[17:40:55.076]                             next
[17:40:55.076]                           if (!grepl(pattern, name)) 
[17:40:55.076]                             next
[17:40:55.076]                           invokeRestart(restart)
[17:40:55.076]                           muffled <- TRUE
[17:40:55.076]                           break
[17:40:55.076]                         }
[17:40:55.076]                       }
[17:40:55.076]                     }
[17:40:55.076]                     invisible(muffled)
[17:40:55.076]                   }
[17:40:55.076]                   muffleCondition(cond)
[17:40:55.076]                 })
[17:40:55.076]             }))
[17:40:55.076]             future::FutureResult(value = ...future.value$value, 
[17:40:55.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.076]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.076]                     ...future.globalenv.names))
[17:40:55.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.076]         }, condition = base::local({
[17:40:55.076]             c <- base::c
[17:40:55.076]             inherits <- base::inherits
[17:40:55.076]             invokeRestart <- base::invokeRestart
[17:40:55.076]             length <- base::length
[17:40:55.076]             list <- base::list
[17:40:55.076]             seq.int <- base::seq.int
[17:40:55.076]             signalCondition <- base::signalCondition
[17:40:55.076]             sys.calls <- base::sys.calls
[17:40:55.076]             `[[` <- base::`[[`
[17:40:55.076]             `+` <- base::`+`
[17:40:55.076]             `<<-` <- base::`<<-`
[17:40:55.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.076]                   3L)]
[17:40:55.076]             }
[17:40:55.076]             function(cond) {
[17:40:55.076]                 is_error <- inherits(cond, "error")
[17:40:55.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.076]                   NULL)
[17:40:55.076]                 if (is_error) {
[17:40:55.076]                   sessionInformation <- function() {
[17:40:55.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.076]                       search = base::search(), system = base::Sys.info())
[17:40:55.076]                   }
[17:40:55.076]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.076]                     cond$call), session = sessionInformation(), 
[17:40:55.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.076]                   signalCondition(cond)
[17:40:55.076]                 }
[17:40:55.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.076]                 "immediateCondition"))) {
[17:40:55.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.076]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.076]                   if (TRUE && !signal) {
[17:40:55.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.076]                     {
[17:40:55.076]                       inherits <- base::inherits
[17:40:55.076]                       invokeRestart <- base::invokeRestart
[17:40:55.076]                       is.null <- base::is.null
[17:40:55.076]                       muffled <- FALSE
[17:40:55.076]                       if (inherits(cond, "message")) {
[17:40:55.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.076]                         if (muffled) 
[17:40:55.076]                           invokeRestart("muffleMessage")
[17:40:55.076]                       }
[17:40:55.076]                       else if (inherits(cond, "warning")) {
[17:40:55.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.076]                         if (muffled) 
[17:40:55.076]                           invokeRestart("muffleWarning")
[17:40:55.076]                       }
[17:40:55.076]                       else if (inherits(cond, "condition")) {
[17:40:55.076]                         if (!is.null(pattern)) {
[17:40:55.076]                           computeRestarts <- base::computeRestarts
[17:40:55.076]                           grepl <- base::grepl
[17:40:55.076]                           restarts <- computeRestarts(cond)
[17:40:55.076]                           for (restart in restarts) {
[17:40:55.076]                             name <- restart$name
[17:40:55.076]                             if (is.null(name)) 
[17:40:55.076]                               next
[17:40:55.076]                             if (!grepl(pattern, name)) 
[17:40:55.076]                               next
[17:40:55.076]                             invokeRestart(restart)
[17:40:55.076]                             muffled <- TRUE
[17:40:55.076]                             break
[17:40:55.076]                           }
[17:40:55.076]                         }
[17:40:55.076]                       }
[17:40:55.076]                       invisible(muffled)
[17:40:55.076]                     }
[17:40:55.076]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.076]                   }
[17:40:55.076]                 }
[17:40:55.076]                 else {
[17:40:55.076]                   if (TRUE) {
[17:40:55.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.076]                     {
[17:40:55.076]                       inherits <- base::inherits
[17:40:55.076]                       invokeRestart <- base::invokeRestart
[17:40:55.076]                       is.null <- base::is.null
[17:40:55.076]                       muffled <- FALSE
[17:40:55.076]                       if (inherits(cond, "message")) {
[17:40:55.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.076]                         if (muffled) 
[17:40:55.076]                           invokeRestart("muffleMessage")
[17:40:55.076]                       }
[17:40:55.076]                       else if (inherits(cond, "warning")) {
[17:40:55.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.076]                         if (muffled) 
[17:40:55.076]                           invokeRestart("muffleWarning")
[17:40:55.076]                       }
[17:40:55.076]                       else if (inherits(cond, "condition")) {
[17:40:55.076]                         if (!is.null(pattern)) {
[17:40:55.076]                           computeRestarts <- base::computeRestarts
[17:40:55.076]                           grepl <- base::grepl
[17:40:55.076]                           restarts <- computeRestarts(cond)
[17:40:55.076]                           for (restart in restarts) {
[17:40:55.076]                             name <- restart$name
[17:40:55.076]                             if (is.null(name)) 
[17:40:55.076]                               next
[17:40:55.076]                             if (!grepl(pattern, name)) 
[17:40:55.076]                               next
[17:40:55.076]                             invokeRestart(restart)
[17:40:55.076]                             muffled <- TRUE
[17:40:55.076]                             break
[17:40:55.076]                           }
[17:40:55.076]                         }
[17:40:55.076]                       }
[17:40:55.076]                       invisible(muffled)
[17:40:55.076]                     }
[17:40:55.076]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.076]                   }
[17:40:55.076]                 }
[17:40:55.076]             }
[17:40:55.076]         }))
[17:40:55.076]     }, error = function(ex) {
[17:40:55.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.076]                 ...future.rng), started = ...future.startTime, 
[17:40:55.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.076]             version = "1.8"), class = "FutureResult")
[17:40:55.076]     }, finally = {
[17:40:55.076]         if (!identical(...future.workdir, getwd())) 
[17:40:55.076]             setwd(...future.workdir)
[17:40:55.076]         {
[17:40:55.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.076]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.076]             }
[17:40:55.076]             base::options(...future.oldOptions)
[17:40:55.076]             if (.Platform$OS.type == "windows") {
[17:40:55.076]                 old_names <- names(...future.oldEnvVars)
[17:40:55.076]                 envs <- base::Sys.getenv()
[17:40:55.076]                 names <- names(envs)
[17:40:55.076]                 common <- intersect(names, old_names)
[17:40:55.076]                 added <- setdiff(names, old_names)
[17:40:55.076]                 removed <- setdiff(old_names, names)
[17:40:55.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.076]                   envs[common]]
[17:40:55.076]                 NAMES <- toupper(changed)
[17:40:55.076]                 args <- list()
[17:40:55.076]                 for (kk in seq_along(NAMES)) {
[17:40:55.076]                   name <- changed[[kk]]
[17:40:55.076]                   NAME <- NAMES[[kk]]
[17:40:55.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.076]                     next
[17:40:55.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.076]                 }
[17:40:55.076]                 NAMES <- toupper(added)
[17:40:55.076]                 for (kk in seq_along(NAMES)) {
[17:40:55.076]                   name <- added[[kk]]
[17:40:55.076]                   NAME <- NAMES[[kk]]
[17:40:55.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.076]                     next
[17:40:55.076]                   args[[name]] <- ""
[17:40:55.076]                 }
[17:40:55.076]                 NAMES <- toupper(removed)
[17:40:55.076]                 for (kk in seq_along(NAMES)) {
[17:40:55.076]                   name <- removed[[kk]]
[17:40:55.076]                   NAME <- NAMES[[kk]]
[17:40:55.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.076]                     next
[17:40:55.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.076]                 }
[17:40:55.076]                 if (length(args) > 0) 
[17:40:55.076]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.076]             }
[17:40:55.076]             else {
[17:40:55.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.076]             }
[17:40:55.076]             {
[17:40:55.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.076]                   0L) {
[17:40:55.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.076]                   base::options(opts)
[17:40:55.076]                 }
[17:40:55.076]                 {
[17:40:55.076]                   {
[17:40:55.076]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.076]                     NULL
[17:40:55.076]                   }
[17:40:55.076]                   options(future.plan = NULL)
[17:40:55.076]                   if (is.na(NA_character_)) 
[17:40:55.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.076]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.076]                     envir = parent.frame()) 
[17:40:55.076]                   {
[17:40:55.076]                     default_workers <- missing(workers)
[17:40:55.076]                     if (is.function(workers)) 
[17:40:55.076]                       workers <- workers()
[17:40:55.076]                     workers <- structure(as.integer(workers), 
[17:40:55.076]                       class = class(workers))
[17:40:55.076]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.076]                       1L)
[17:40:55.076]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.076]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.076]                       if (default_workers) 
[17:40:55.076]                         supportsMulticore(warn = TRUE)
[17:40:55.076]                       return(sequential(..., envir = envir))
[17:40:55.076]                     }
[17:40:55.076]                     oopts <- options(mc.cores = workers)
[17:40:55.076]                     on.exit(options(oopts))
[17:40:55.076]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.076]                       envir = envir)
[17:40:55.076]                     if (!future$lazy) 
[17:40:55.076]                       future <- run(future)
[17:40:55.076]                     invisible(future)
[17:40:55.076]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.076]                 }
[17:40:55.076]             }
[17:40:55.076]         }
[17:40:55.076]     })
[17:40:55.076]     if (TRUE) {
[17:40:55.076]         base::sink(type = "output", split = FALSE)
[17:40:55.076]         if (TRUE) {
[17:40:55.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.076]         }
[17:40:55.076]         else {
[17:40:55.076]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.076]         }
[17:40:55.076]         base::close(...future.stdout)
[17:40:55.076]         ...future.stdout <- NULL
[17:40:55.076]     }
[17:40:55.076]     ...future.result$conditions <- ...future.conditions
[17:40:55.076]     ...future.result$finished <- base::Sys.time()
[17:40:55.076]     ...future.result
[17:40:55.076] }
[17:40:55.079] assign_globals() ...
[17:40:55.079] List of 11
[17:40:55.079]  $ ...future.FUN            :function (x, ...)  
[17:40:55.079]  $ x_FUN                    :function (x)  
[17:40:55.079]  $ times                    : int 2
[17:40:55.079]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.079]  $ stop_if_not              :function (...)  
[17:40:55.079]  $ dim                      : NULL
[17:40:55.079]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.079]  $ future.call.arguments    : list()
[17:40:55.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.079]  $ ...future.elements_ii    :List of 5
[17:40:55.079]   ..$ : int 6
[17:40:55.079]   ..$ : int 7
[17:40:55.079]   ..$ : int 8
[17:40:55.079]   ..$ : int 9
[17:40:55.079]   ..$ : int 10
[17:40:55.079]  $ ...future.seeds_ii       : NULL
[17:40:55.079]  $ ...future.globals.maxSize: NULL
[17:40:55.079]  - attr(*, "resolved")= logi FALSE
[17:40:55.079]  - attr(*, "total_size")= num 96456
[17:40:55.079]  - attr(*, "where")=List of 11
[17:40:55.079]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.079]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.079]  - attr(*, "already-done")= logi TRUE
[17:40:55.094] - copied ‘...future.FUN’ to environment
[17:40:55.095] - reassign environment for ‘x_FUN’
[17:40:55.095] - copied ‘x_FUN’ to environment
[17:40:55.095] - copied ‘times’ to environment
[17:40:55.095] - copied ‘stopf’ to environment
[17:40:55.095] - copied ‘stop_if_not’ to environment
[17:40:55.095] - copied ‘dim’ to environment
[17:40:55.095] - copied ‘valid_types’ to environment
[17:40:55.095] - copied ‘future.call.arguments’ to environment
[17:40:55.096] - copied ‘...future.elements_ii’ to environment
[17:40:55.096] - copied ‘...future.seeds_ii’ to environment
[17:40:55.096] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.096] assign_globals() ... done
[17:40:55.096] requestCore(): workers = 2
[17:40:55.099] MulticoreFuture started
[17:40:55.099] - Launch lazy future ... done
[17:40:55.099] run() for ‘MulticoreFuture’ ... done
[17:40:55.100] Created future:
[17:40:55.100] plan(): Setting new future strategy stack:
[17:40:55.101] List of future strategies:
[17:40:55.101] 1. sequential:
[17:40:55.101]    - args: function (..., envir = parent.frame())
[17:40:55.101]    - tweaked: FALSE
[17:40:55.101]    - call: NULL
[17:40:55.101] plan(): nbrOfWorkers() = 1
[17:40:55.104] plan(): Setting new future strategy stack:
[17:40:55.104] List of future strategies:
[17:40:55.104] 1. multicore:
[17:40:55.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.104]    - tweaked: FALSE
[17:40:55.104]    - call: plan(strategy)
[17:40:55.110] plan(): nbrOfWorkers() = 2
[17:40:55.100] MulticoreFuture:
[17:40:55.100] Label: ‘future_vapply-2’
[17:40:55.100] Expression:
[17:40:55.100] {
[17:40:55.100]     do.call(function(...) {
[17:40:55.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.100]             on.exit(options(oopts), add = TRUE)
[17:40:55.100]         }
[17:40:55.100]         {
[17:40:55.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.100]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.100]             })
[17:40:55.100]         }
[17:40:55.100]     }, args = future.call.arguments)
[17:40:55.100] }
[17:40:55.100] Lazy evaluation: FALSE
[17:40:55.100] Asynchronous evaluation: TRUE
[17:40:55.100] Local evaluation: TRUE
[17:40:55.100] Environment: R_GlobalEnv
[17:40:55.100] Capture standard output: TRUE
[17:40:55.100] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.100] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.100] Packages: 1 packages (‘future.apply’)
[17:40:55.100] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.100] Resolved: TRUE
[17:40:55.100] Value: <not collected>
[17:40:55.100] Conditions captured: <none>
[17:40:55.100] Early signaling: FALSE
[17:40:55.100] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.100] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.111] Chunk #2 of 2 ... DONE
[17:40:55.112] Launching 2 futures (chunks) ... DONE
[17:40:55.112] Resolving 2 futures (chunks) ...
[17:40:55.112] resolve() on list ...
[17:40:55.112]  recursive: 0
[17:40:55.112]  length: 2
[17:40:55.112] 
[17:40:55.113] Future #1
[17:40:55.114] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.114] - nx: 2
[17:40:55.114] - relay: TRUE
[17:40:55.114] - stdout: TRUE
[17:40:55.114] - signal: TRUE
[17:40:55.115] - resignal: FALSE
[17:40:55.115] - force: TRUE
[17:40:55.115] - relayed: [n=2] FALSE, FALSE
[17:40:55.115] - queued futures: [n=2] FALSE, FALSE
[17:40:55.115]  - until=1
[17:40:55.116]  - relaying element #1
[17:40:55.116] - relayed: [n=2] TRUE, FALSE
[17:40:55.116] - queued futures: [n=2] TRUE, FALSE
[17:40:55.116] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.117]  length: 1 (resolved future 1)
[17:40:55.117] Future #2
[17:40:55.118] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.118] - nx: 2
[17:40:55.118] - relay: TRUE
[17:40:55.119] - stdout: TRUE
[17:40:55.119] - signal: TRUE
[17:40:55.119] - resignal: FALSE
[17:40:55.119] - force: TRUE
[17:40:55.119] - relayed: [n=2] TRUE, FALSE
[17:40:55.119] - queued futures: [n=2] TRUE, FALSE
[17:40:55.119]  - until=2
[17:40:55.119]  - relaying element #2
[17:40:55.120] - relayed: [n=2] TRUE, TRUE
[17:40:55.120] - queued futures: [n=2] TRUE, TRUE
[17:40:55.120] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.120]  length: 0 (resolved future 2)
[17:40:55.120] Relaying remaining futures
[17:40:55.120] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.121] - nx: 2
[17:40:55.121] - relay: TRUE
[17:40:55.121] - stdout: TRUE
[17:40:55.121] - signal: TRUE
[17:40:55.121] - resignal: FALSE
[17:40:55.121] - force: TRUE
[17:40:55.121] - relayed: [n=2] TRUE, TRUE
[17:40:55.121] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.121] - relayed: [n=2] TRUE, TRUE
[17:40:55.122] - queued futures: [n=2] TRUE, TRUE
[17:40:55.122] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.122] resolve() on list ... DONE
[17:40:55.122]  - Number of value chunks collected: 2
[17:40:55.122] Resolving 2 futures (chunks) ... DONE
[17:40:55.122] Reducing values from 2 chunks ...
[17:40:55.122]  - Number of values collected after concatenation: 10
[17:40:55.122]  - Number of values expected: 10
[17:40:55.123] Reducing values from 2 chunks ... DONE
[17:40:55.123] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:40:55.124] future_lapply() ...
[17:40:55.132] Number of chunks: 2
[17:40:55.132] getGlobalsAndPackagesXApply() ...
[17:40:55.132]  - future.globals: TRUE
[17:40:55.132] getGlobalsAndPackages() ...
[17:40:55.132] Searching for globals...
[17:40:55.140] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:40:55.140] Searching for globals ... DONE
[17:40:55.140] Resolving globals: FALSE
[17:40:55.141] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:40:55.142] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:55.142] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.142] - packages: [1] ‘future.apply’
[17:40:55.142] getGlobalsAndPackages() ... DONE
[17:40:55.142]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.142]  - needed namespaces: [n=1] ‘future.apply’
[17:40:55.142] Finding globals ... DONE
[17:40:55.142]  - use_args: TRUE
[17:40:55.143]  - Getting '...' globals ...
[17:40:55.143] resolve() on list ...
[17:40:55.143]  recursive: 0
[17:40:55.143]  length: 1
[17:40:55.143]  elements: ‘...’
[17:40:55.143]  length: 0 (resolved future 1)
[17:40:55.143] resolve() on list ... DONE
[17:40:55.144]    - '...' content: [n=0] 
[17:40:55.144] List of 1
[17:40:55.144]  $ ...: list()
[17:40:55.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.144]  - attr(*, "where")=List of 1
[17:40:55.144]   ..$ ...:<environment: 0x564f3005d6b8> 
[17:40:55.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.144]  - attr(*, "resolved")= logi TRUE
[17:40:55.144]  - attr(*, "total_size")= num NA
[17:40:55.146]  - Getting '...' globals ... DONE
[17:40:55.146] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:55.147] List of 8
[17:40:55.147]  $ ...future.FUN:function (x, ...)  
[17:40:55.147]  $ x_FUN        :function (x)  
[17:40:55.147]  $ times        : int 4
[17:40:55.147]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.147]  $ stop_if_not  :function (...)  
[17:40:55.147]  $ dim          : int [1:2] 2 2
[17:40:55.147]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:55.147]  $ ...          : list()
[17:40:55.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.147]  - attr(*, "where")=List of 8
[17:40:55.147]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:55.147]   ..$ ...          :<environment: 0x564f3005d6b8> 
[17:40:55.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.147]  - attr(*, "resolved")= logi FALSE
[17:40:55.147]  - attr(*, "total_size")= num 97232
[17:40:55.153] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:55.153] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.153] Number of futures (= number of chunks): 2
[17:40:55.153] Launching 2 futures (chunks) ...
[17:40:55.153] Chunk #1 of 2 ...
[17:40:55.153]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.154] getGlobalsAndPackages() ...
[17:40:55.154] Searching for globals...
[17:40:55.154] 
[17:40:55.154] Searching for globals ... DONE
[17:40:55.154] - globals: [0] <none>
[17:40:55.154] getGlobalsAndPackages() ... DONE
[17:40:55.154]    + additional globals found: [n=0] 
[17:40:55.154]    + additional namespaces needed: [n=0] 
[17:40:55.154]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.155]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.155]  - seeds: <none>
[17:40:55.155] getGlobalsAndPackages() ...
[17:40:55.155] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.155] Resolving globals: FALSE
[17:40:55.155] Tweak future expression to call with '...' arguments ...
[17:40:55.155] {
[17:40:55.155]     do.call(function(...) {
[17:40:55.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.155]             on.exit(options(oopts), add = TRUE)
[17:40:55.155]         }
[17:40:55.155]         {
[17:40:55.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.155]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.155]             })
[17:40:55.155]         }
[17:40:55.155]     }, args = future.call.arguments)
[17:40:55.155] }
[17:40:55.156] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.158] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.158] - packages: [1] ‘future.apply’
[17:40:55.158] getGlobalsAndPackages() ... DONE
[17:40:55.158] run() for ‘Future’ ...
[17:40:55.159] - state: ‘created’
[17:40:55.159] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.163]   - Field: ‘label’
[17:40:55.164]   - Field: ‘local’
[17:40:55.164]   - Field: ‘owner’
[17:40:55.164]   - Field: ‘envir’
[17:40:55.164]   - Field: ‘workers’
[17:40:55.164]   - Field: ‘packages’
[17:40:55.164]   - Field: ‘gc’
[17:40:55.164]   - Field: ‘job’
[17:40:55.164]   - Field: ‘conditions’
[17:40:55.164]   - Field: ‘expr’
[17:40:55.165]   - Field: ‘uuid’
[17:40:55.165]   - Field: ‘seed’
[17:40:55.165]   - Field: ‘version’
[17:40:55.165]   - Field: ‘result’
[17:40:55.165]   - Field: ‘asynchronous’
[17:40:55.165]   - Field: ‘calls’
[17:40:55.165]   - Field: ‘globals’
[17:40:55.165]   - Field: ‘stdout’
[17:40:55.165]   - Field: ‘earlySignal’
[17:40:55.165]   - Field: ‘lazy’
[17:40:55.166]   - Field: ‘state’
[17:40:55.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.166] - Launch lazy future ...
[17:40:55.166] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.166] Packages needed by future strategies (n = 0): <none>
[17:40:55.167] {
[17:40:55.167]     {
[17:40:55.167]         {
[17:40:55.167]             ...future.startTime <- base::Sys.time()
[17:40:55.167]             {
[17:40:55.167]                 {
[17:40:55.167]                   {
[17:40:55.167]                     {
[17:40:55.167]                       {
[17:40:55.167]                         base::local({
[17:40:55.167]                           has_future <- base::requireNamespace("future", 
[17:40:55.167]                             quietly = TRUE)
[17:40:55.167]                           if (has_future) {
[17:40:55.167]                             ns <- base::getNamespace("future")
[17:40:55.167]                             version <- ns[[".package"]][["version"]]
[17:40:55.167]                             if (is.null(version)) 
[17:40:55.167]                               version <- utils::packageVersion("future")
[17:40:55.167]                           }
[17:40:55.167]                           else {
[17:40:55.167]                             version <- NULL
[17:40:55.167]                           }
[17:40:55.167]                           if (!has_future || version < "1.8.0") {
[17:40:55.167]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.167]                               "", base::R.version$version.string), 
[17:40:55.167]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.167]                                 base::R.version$platform, 8 * 
[17:40:55.167]                                   base::.Machine$sizeof.pointer), 
[17:40:55.167]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.167]                                 "release", "version")], collapse = " "), 
[17:40:55.167]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.167]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.167]                               info)
[17:40:55.167]                             info <- base::paste(info, collapse = "; ")
[17:40:55.167]                             if (!has_future) {
[17:40:55.167]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.167]                                 info)
[17:40:55.167]                             }
[17:40:55.167]                             else {
[17:40:55.167]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.167]                                 info, version)
[17:40:55.167]                             }
[17:40:55.167]                             base::stop(msg)
[17:40:55.167]                           }
[17:40:55.167]                         })
[17:40:55.167]                       }
[17:40:55.167]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.167]                       base::options(mc.cores = 1L)
[17:40:55.167]                     }
[17:40:55.167]                     base::local({
[17:40:55.167]                       for (pkg in "future.apply") {
[17:40:55.167]                         base::loadNamespace(pkg)
[17:40:55.167]                         base::library(pkg, character.only = TRUE)
[17:40:55.167]                       }
[17:40:55.167]                     })
[17:40:55.167]                   }
[17:40:55.167]                   options(future.plan = NULL)
[17:40:55.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.167]                 }
[17:40:55.167]                 ...future.workdir <- getwd()
[17:40:55.167]             }
[17:40:55.167]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.167]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.167]         }
[17:40:55.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.167]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.167]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.167]             base::names(...future.oldOptions))
[17:40:55.167]     }
[17:40:55.167]     if (FALSE) {
[17:40:55.167]     }
[17:40:55.167]     else {
[17:40:55.167]         if (TRUE) {
[17:40:55.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.167]                 open = "w")
[17:40:55.167]         }
[17:40:55.167]         else {
[17:40:55.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.167]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.167]         }
[17:40:55.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.167]             base::sink(type = "output", split = FALSE)
[17:40:55.167]             base::close(...future.stdout)
[17:40:55.167]         }, add = TRUE)
[17:40:55.167]     }
[17:40:55.167]     ...future.frame <- base::sys.nframe()
[17:40:55.167]     ...future.conditions <- base::list()
[17:40:55.167]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.167]     if (FALSE) {
[17:40:55.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.167]     }
[17:40:55.167]     ...future.result <- base::tryCatch({
[17:40:55.167]         base::withCallingHandlers({
[17:40:55.167]             ...future.value <- base::withVisible(base::local({
[17:40:55.167]                 withCallingHandlers({
[17:40:55.167]                   {
[17:40:55.167]                     do.call(function(...) {
[17:40:55.167]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.167]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.167]                         ...future.globals.maxSize)) {
[17:40:55.167]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.167]                         on.exit(options(oopts), add = TRUE)
[17:40:55.167]                       }
[17:40:55.167]                       {
[17:40:55.167]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.167]                           FUN = function(jj) {
[17:40:55.167]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.167]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.167]                           })
[17:40:55.167]                       }
[17:40:55.167]                     }, args = future.call.arguments)
[17:40:55.167]                   }
[17:40:55.167]                 }, immediateCondition = function(cond) {
[17:40:55.167]                   save_rds <- function (object, pathname, ...) 
[17:40:55.167]                   {
[17:40:55.167]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.167]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.167]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.167]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.167]                         fi_tmp[["mtime"]])
[17:40:55.167]                     }
[17:40:55.167]                     tryCatch({
[17:40:55.167]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.167]                     }, error = function(ex) {
[17:40:55.167]                       msg <- conditionMessage(ex)
[17:40:55.167]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.167]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.167]                         fi_tmp[["mtime"]], msg)
[17:40:55.167]                       ex$message <- msg
[17:40:55.167]                       stop(ex)
[17:40:55.167]                     })
[17:40:55.167]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.167]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.167]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.167]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.167]                       fi <- file.info(pathname)
[17:40:55.167]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.167]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.167]                         fi[["size"]], fi[["mtime"]])
[17:40:55.167]                       stop(msg)
[17:40:55.167]                     }
[17:40:55.167]                     invisible(pathname)
[17:40:55.167]                   }
[17:40:55.167]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.167]                     rootPath = tempdir()) 
[17:40:55.167]                   {
[17:40:55.167]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.167]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.167]                       tmpdir = path, fileext = ".rds")
[17:40:55.167]                     save_rds(obj, file)
[17:40:55.167]                   }
[17:40:55.167]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.167]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.167]                   {
[17:40:55.167]                     inherits <- base::inherits
[17:40:55.167]                     invokeRestart <- base::invokeRestart
[17:40:55.167]                     is.null <- base::is.null
[17:40:55.167]                     muffled <- FALSE
[17:40:55.167]                     if (inherits(cond, "message")) {
[17:40:55.167]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.167]                       if (muffled) 
[17:40:55.167]                         invokeRestart("muffleMessage")
[17:40:55.167]                     }
[17:40:55.167]                     else if (inherits(cond, "warning")) {
[17:40:55.167]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.167]                       if (muffled) 
[17:40:55.167]                         invokeRestart("muffleWarning")
[17:40:55.167]                     }
[17:40:55.167]                     else if (inherits(cond, "condition")) {
[17:40:55.167]                       if (!is.null(pattern)) {
[17:40:55.167]                         computeRestarts <- base::computeRestarts
[17:40:55.167]                         grepl <- base::grepl
[17:40:55.167]                         restarts <- computeRestarts(cond)
[17:40:55.167]                         for (restart in restarts) {
[17:40:55.167]                           name <- restart$name
[17:40:55.167]                           if (is.null(name)) 
[17:40:55.167]                             next
[17:40:55.167]                           if (!grepl(pattern, name)) 
[17:40:55.167]                             next
[17:40:55.167]                           invokeRestart(restart)
[17:40:55.167]                           muffled <- TRUE
[17:40:55.167]                           break
[17:40:55.167]                         }
[17:40:55.167]                       }
[17:40:55.167]                     }
[17:40:55.167]                     invisible(muffled)
[17:40:55.167]                   }
[17:40:55.167]                   muffleCondition(cond)
[17:40:55.167]                 })
[17:40:55.167]             }))
[17:40:55.167]             future::FutureResult(value = ...future.value$value, 
[17:40:55.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.167]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.167]                     ...future.globalenv.names))
[17:40:55.167]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.167]         }, condition = base::local({
[17:40:55.167]             c <- base::c
[17:40:55.167]             inherits <- base::inherits
[17:40:55.167]             invokeRestart <- base::invokeRestart
[17:40:55.167]             length <- base::length
[17:40:55.167]             list <- base::list
[17:40:55.167]             seq.int <- base::seq.int
[17:40:55.167]             signalCondition <- base::signalCondition
[17:40:55.167]             sys.calls <- base::sys.calls
[17:40:55.167]             `[[` <- base::`[[`
[17:40:55.167]             `+` <- base::`+`
[17:40:55.167]             `<<-` <- base::`<<-`
[17:40:55.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.167]                   3L)]
[17:40:55.167]             }
[17:40:55.167]             function(cond) {
[17:40:55.167]                 is_error <- inherits(cond, "error")
[17:40:55.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.167]                   NULL)
[17:40:55.167]                 if (is_error) {
[17:40:55.167]                   sessionInformation <- function() {
[17:40:55.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.167]                       search = base::search(), system = base::Sys.info())
[17:40:55.167]                   }
[17:40:55.167]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.167]                     cond$call), session = sessionInformation(), 
[17:40:55.167]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.167]                   signalCondition(cond)
[17:40:55.167]                 }
[17:40:55.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.167]                 "immediateCondition"))) {
[17:40:55.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.167]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.167]                   if (TRUE && !signal) {
[17:40:55.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.167]                     {
[17:40:55.167]                       inherits <- base::inherits
[17:40:55.167]                       invokeRestart <- base::invokeRestart
[17:40:55.167]                       is.null <- base::is.null
[17:40:55.167]                       muffled <- FALSE
[17:40:55.167]                       if (inherits(cond, "message")) {
[17:40:55.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.167]                         if (muffled) 
[17:40:55.167]                           invokeRestart("muffleMessage")
[17:40:55.167]                       }
[17:40:55.167]                       else if (inherits(cond, "warning")) {
[17:40:55.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.167]                         if (muffled) 
[17:40:55.167]                           invokeRestart("muffleWarning")
[17:40:55.167]                       }
[17:40:55.167]                       else if (inherits(cond, "condition")) {
[17:40:55.167]                         if (!is.null(pattern)) {
[17:40:55.167]                           computeRestarts <- base::computeRestarts
[17:40:55.167]                           grepl <- base::grepl
[17:40:55.167]                           restarts <- computeRestarts(cond)
[17:40:55.167]                           for (restart in restarts) {
[17:40:55.167]                             name <- restart$name
[17:40:55.167]                             if (is.null(name)) 
[17:40:55.167]                               next
[17:40:55.167]                             if (!grepl(pattern, name)) 
[17:40:55.167]                               next
[17:40:55.167]                             invokeRestart(restart)
[17:40:55.167]                             muffled <- TRUE
[17:40:55.167]                             break
[17:40:55.167]                           }
[17:40:55.167]                         }
[17:40:55.167]                       }
[17:40:55.167]                       invisible(muffled)
[17:40:55.167]                     }
[17:40:55.167]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.167]                   }
[17:40:55.167]                 }
[17:40:55.167]                 else {
[17:40:55.167]                   if (TRUE) {
[17:40:55.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.167]                     {
[17:40:55.167]                       inherits <- base::inherits
[17:40:55.167]                       invokeRestart <- base::invokeRestart
[17:40:55.167]                       is.null <- base::is.null
[17:40:55.167]                       muffled <- FALSE
[17:40:55.167]                       if (inherits(cond, "message")) {
[17:40:55.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.167]                         if (muffled) 
[17:40:55.167]                           invokeRestart("muffleMessage")
[17:40:55.167]                       }
[17:40:55.167]                       else if (inherits(cond, "warning")) {
[17:40:55.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.167]                         if (muffled) 
[17:40:55.167]                           invokeRestart("muffleWarning")
[17:40:55.167]                       }
[17:40:55.167]                       else if (inherits(cond, "condition")) {
[17:40:55.167]                         if (!is.null(pattern)) {
[17:40:55.167]                           computeRestarts <- base::computeRestarts
[17:40:55.167]                           grepl <- base::grepl
[17:40:55.167]                           restarts <- computeRestarts(cond)
[17:40:55.167]                           for (restart in restarts) {
[17:40:55.167]                             name <- restart$name
[17:40:55.167]                             if (is.null(name)) 
[17:40:55.167]                               next
[17:40:55.167]                             if (!grepl(pattern, name)) 
[17:40:55.167]                               next
[17:40:55.167]                             invokeRestart(restart)
[17:40:55.167]                             muffled <- TRUE
[17:40:55.167]                             break
[17:40:55.167]                           }
[17:40:55.167]                         }
[17:40:55.167]                       }
[17:40:55.167]                       invisible(muffled)
[17:40:55.167]                     }
[17:40:55.167]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.167]                   }
[17:40:55.167]                 }
[17:40:55.167]             }
[17:40:55.167]         }))
[17:40:55.167]     }, error = function(ex) {
[17:40:55.167]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.167]                 ...future.rng), started = ...future.startTime, 
[17:40:55.167]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.167]             version = "1.8"), class = "FutureResult")
[17:40:55.167]     }, finally = {
[17:40:55.167]         if (!identical(...future.workdir, getwd())) 
[17:40:55.167]             setwd(...future.workdir)
[17:40:55.167]         {
[17:40:55.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.167]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.167]             }
[17:40:55.167]             base::options(...future.oldOptions)
[17:40:55.167]             if (.Platform$OS.type == "windows") {
[17:40:55.167]                 old_names <- names(...future.oldEnvVars)
[17:40:55.167]                 envs <- base::Sys.getenv()
[17:40:55.167]                 names <- names(envs)
[17:40:55.167]                 common <- intersect(names, old_names)
[17:40:55.167]                 added <- setdiff(names, old_names)
[17:40:55.167]                 removed <- setdiff(old_names, names)
[17:40:55.167]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.167]                   envs[common]]
[17:40:55.167]                 NAMES <- toupper(changed)
[17:40:55.167]                 args <- list()
[17:40:55.167]                 for (kk in seq_along(NAMES)) {
[17:40:55.167]                   name <- changed[[kk]]
[17:40:55.167]                   NAME <- NAMES[[kk]]
[17:40:55.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.167]                     next
[17:40:55.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.167]                 }
[17:40:55.167]                 NAMES <- toupper(added)
[17:40:55.167]                 for (kk in seq_along(NAMES)) {
[17:40:55.167]                   name <- added[[kk]]
[17:40:55.167]                   NAME <- NAMES[[kk]]
[17:40:55.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.167]                     next
[17:40:55.167]                   args[[name]] <- ""
[17:40:55.167]                 }
[17:40:55.167]                 NAMES <- toupper(removed)
[17:40:55.167]                 for (kk in seq_along(NAMES)) {
[17:40:55.167]                   name <- removed[[kk]]
[17:40:55.167]                   NAME <- NAMES[[kk]]
[17:40:55.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.167]                     next
[17:40:55.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.167]                 }
[17:40:55.167]                 if (length(args) > 0) 
[17:40:55.167]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.167]             }
[17:40:55.167]             else {
[17:40:55.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.167]             }
[17:40:55.167]             {
[17:40:55.167]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.167]                   0L) {
[17:40:55.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.167]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.167]                   base::options(opts)
[17:40:55.167]                 }
[17:40:55.167]                 {
[17:40:55.167]                   {
[17:40:55.167]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.167]                     NULL
[17:40:55.167]                   }
[17:40:55.167]                   options(future.plan = NULL)
[17:40:55.167]                   if (is.na(NA_character_)) 
[17:40:55.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.167]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.167]                     envir = parent.frame()) 
[17:40:55.167]                   {
[17:40:55.167]                     default_workers <- missing(workers)
[17:40:55.167]                     if (is.function(workers)) 
[17:40:55.167]                       workers <- workers()
[17:40:55.167]                     workers <- structure(as.integer(workers), 
[17:40:55.167]                       class = class(workers))
[17:40:55.167]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.167]                       1L)
[17:40:55.167]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.167]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.167]                       if (default_workers) 
[17:40:55.167]                         supportsMulticore(warn = TRUE)
[17:40:55.167]                       return(sequential(..., envir = envir))
[17:40:55.167]                     }
[17:40:55.167]                     oopts <- options(mc.cores = workers)
[17:40:55.167]                     on.exit(options(oopts))
[17:40:55.167]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.167]                       envir = envir)
[17:40:55.167]                     if (!future$lazy) 
[17:40:55.167]                       future <- run(future)
[17:40:55.167]                     invisible(future)
[17:40:55.167]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.167]                 }
[17:40:55.167]             }
[17:40:55.167]         }
[17:40:55.167]     })
[17:40:55.167]     if (TRUE) {
[17:40:55.167]         base::sink(type = "output", split = FALSE)
[17:40:55.167]         if (TRUE) {
[17:40:55.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.167]         }
[17:40:55.167]         else {
[17:40:55.167]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.167]         }
[17:40:55.167]         base::close(...future.stdout)
[17:40:55.167]         ...future.stdout <- NULL
[17:40:55.167]     }
[17:40:55.167]     ...future.result$conditions <- ...future.conditions
[17:40:55.167]     ...future.result$finished <- base::Sys.time()
[17:40:55.167]     ...future.result
[17:40:55.167] }
[17:40:55.170] assign_globals() ...
[17:40:55.170] List of 11
[17:40:55.170]  $ ...future.FUN            :function (x, ...)  
[17:40:55.170]  $ x_FUN                    :function (x)  
[17:40:55.170]  $ times                    : int 4
[17:40:55.170]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.170]  $ stop_if_not              :function (...)  
[17:40:55.170]  $ dim                      : int [1:2] 2 2
[17:40:55.170]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:55.170]  $ future.call.arguments    : list()
[17:40:55.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.170]  $ ...future.elements_ii    :List of 5
[17:40:55.170]   ..$ : int 1
[17:40:55.170]   ..$ : int 2
[17:40:55.170]   ..$ : int 3
[17:40:55.170]   ..$ : int 4
[17:40:55.170]   ..$ : int 5
[17:40:55.170]  $ ...future.seeds_ii       : NULL
[17:40:55.170]  $ ...future.globals.maxSize: NULL
[17:40:55.170]  - attr(*, "resolved")= logi FALSE
[17:40:55.170]  - attr(*, "total_size")= num 97232
[17:40:55.170]  - attr(*, "where")=List of 11
[17:40:55.170]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.170]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.170]  - attr(*, "already-done")= logi TRUE
[17:40:55.179] - copied ‘...future.FUN’ to environment
[17:40:55.179] - reassign environment for ‘x_FUN’
[17:40:55.179] - copied ‘x_FUN’ to environment
[17:40:55.179] - copied ‘times’ to environment
[17:40:55.179] - copied ‘stopf’ to environment
[17:40:55.179] - copied ‘stop_if_not’ to environment
[17:40:55.180] - copied ‘dim’ to environment
[17:40:55.180] - copied ‘valid_types’ to environment
[17:40:55.180] - copied ‘future.call.arguments’ to environment
[17:40:55.180] - copied ‘...future.elements_ii’ to environment
[17:40:55.180] - copied ‘...future.seeds_ii’ to environment
[17:40:55.180] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.180] assign_globals() ... done
[17:40:55.180] requestCore(): workers = 2
[17:40:55.183] MulticoreFuture started
[17:40:55.183] - Launch lazy future ... done
[17:40:55.184] run() for ‘MulticoreFuture’ ... done
[17:40:55.184] Created future:
[17:40:55.185] plan(): Setting new future strategy stack:
[17:40:55.185] List of future strategies:
[17:40:55.185] 1. sequential:
[17:40:55.185]    - args: function (..., envir = parent.frame())
[17:40:55.185]    - tweaked: FALSE
[17:40:55.185]    - call: NULL
[17:40:55.190] plan(): nbrOfWorkers() = 1
[17:40:55.192] plan(): Setting new future strategy stack:
[17:40:55.193] List of future strategies:
[17:40:55.193] 1. multicore:
[17:40:55.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.193]    - tweaked: FALSE
[17:40:55.193]    - call: plan(strategy)
[17:40:55.200] plan(): nbrOfWorkers() = 2
[17:40:55.184] MulticoreFuture:
[17:40:55.184] Label: ‘future_vapply-1’
[17:40:55.184] Expression:
[17:40:55.184] {
[17:40:55.184]     do.call(function(...) {
[17:40:55.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.184]             on.exit(options(oopts), add = TRUE)
[17:40:55.184]         }
[17:40:55.184]         {
[17:40:55.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.184]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.184]             })
[17:40:55.184]         }
[17:40:55.184]     }, args = future.call.arguments)
[17:40:55.184] }
[17:40:55.184] Lazy evaluation: FALSE
[17:40:55.184] Asynchronous evaluation: TRUE
[17:40:55.184] Local evaluation: TRUE
[17:40:55.184] Environment: R_GlobalEnv
[17:40:55.184] Capture standard output: TRUE
[17:40:55.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.184] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.184] Packages: 1 packages (‘future.apply’)
[17:40:55.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.184] Resolved: TRUE
[17:40:55.184] Value: <not collected>
[17:40:55.184] Conditions captured: <none>
[17:40:55.184] Early signaling: FALSE
[17:40:55.184] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.184] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.201] Chunk #1 of 2 ... DONE
[17:40:55.201] Chunk #2 of 2 ...
[17:40:55.202]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.202] getGlobalsAndPackages() ...
[17:40:55.202] Searching for globals...
[17:40:55.203] 
[17:40:55.203] Searching for globals ... DONE
[17:40:55.203] - globals: [0] <none>
[17:40:55.203] getGlobalsAndPackages() ... DONE
[17:40:55.204]    + additional globals found: [n=0] 
[17:40:55.204]    + additional namespaces needed: [n=0] 
[17:40:55.204]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.204]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.204]  - seeds: <none>
[17:40:55.205] getGlobalsAndPackages() ...
[17:40:55.205] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.205] Resolving globals: FALSE
[17:40:55.206] Tweak future expression to call with '...' arguments ...
[17:40:55.206] {
[17:40:55.206]     do.call(function(...) {
[17:40:55.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.206]             on.exit(options(oopts), add = TRUE)
[17:40:55.206]         }
[17:40:55.206]         {
[17:40:55.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.206]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.206]             })
[17:40:55.206]         }
[17:40:55.206]     }, args = future.call.arguments)
[17:40:55.206] }
[17:40:55.206] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.207] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.208] - packages: [1] ‘future.apply’
[17:40:55.208] getGlobalsAndPackages() ... DONE
[17:40:55.208] run() for ‘Future’ ...
[17:40:55.208] - state: ‘created’
[17:40:55.209] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.214] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.214] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.214]   - Field: ‘label’
[17:40:55.214]   - Field: ‘local’
[17:40:55.214]   - Field: ‘owner’
[17:40:55.215]   - Field: ‘envir’
[17:40:55.215]   - Field: ‘workers’
[17:40:55.215]   - Field: ‘packages’
[17:40:55.215]   - Field: ‘gc’
[17:40:55.215]   - Field: ‘job’
[17:40:55.216]   - Field: ‘conditions’
[17:40:55.216]   - Field: ‘expr’
[17:40:55.216]   - Field: ‘uuid’
[17:40:55.216]   - Field: ‘seed’
[17:40:55.216]   - Field: ‘version’
[17:40:55.217]   - Field: ‘result’
[17:40:55.217]   - Field: ‘asynchronous’
[17:40:55.217]   - Field: ‘calls’
[17:40:55.217]   - Field: ‘globals’
[17:40:55.217]   - Field: ‘stdout’
[17:40:55.217]   - Field: ‘earlySignal’
[17:40:55.217]   - Field: ‘lazy’
[17:40:55.218]   - Field: ‘state’
[17:40:55.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.218] - Launch lazy future ...
[17:40:55.218] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.218] Packages needed by future strategies (n = 0): <none>
[17:40:55.219] {
[17:40:55.219]     {
[17:40:55.219]         {
[17:40:55.219]             ...future.startTime <- base::Sys.time()
[17:40:55.219]             {
[17:40:55.219]                 {
[17:40:55.219]                   {
[17:40:55.219]                     {
[17:40:55.219]                       {
[17:40:55.219]                         base::local({
[17:40:55.219]                           has_future <- base::requireNamespace("future", 
[17:40:55.219]                             quietly = TRUE)
[17:40:55.219]                           if (has_future) {
[17:40:55.219]                             ns <- base::getNamespace("future")
[17:40:55.219]                             version <- ns[[".package"]][["version"]]
[17:40:55.219]                             if (is.null(version)) 
[17:40:55.219]                               version <- utils::packageVersion("future")
[17:40:55.219]                           }
[17:40:55.219]                           else {
[17:40:55.219]                             version <- NULL
[17:40:55.219]                           }
[17:40:55.219]                           if (!has_future || version < "1.8.0") {
[17:40:55.219]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.219]                               "", base::R.version$version.string), 
[17:40:55.219]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.219]                                 base::R.version$platform, 8 * 
[17:40:55.219]                                   base::.Machine$sizeof.pointer), 
[17:40:55.219]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.219]                                 "release", "version")], collapse = " "), 
[17:40:55.219]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.219]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.219]                               info)
[17:40:55.219]                             info <- base::paste(info, collapse = "; ")
[17:40:55.219]                             if (!has_future) {
[17:40:55.219]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.219]                                 info)
[17:40:55.219]                             }
[17:40:55.219]                             else {
[17:40:55.219]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.219]                                 info, version)
[17:40:55.219]                             }
[17:40:55.219]                             base::stop(msg)
[17:40:55.219]                           }
[17:40:55.219]                         })
[17:40:55.219]                       }
[17:40:55.219]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.219]                       base::options(mc.cores = 1L)
[17:40:55.219]                     }
[17:40:55.219]                     base::local({
[17:40:55.219]                       for (pkg in "future.apply") {
[17:40:55.219]                         base::loadNamespace(pkg)
[17:40:55.219]                         base::library(pkg, character.only = TRUE)
[17:40:55.219]                       }
[17:40:55.219]                     })
[17:40:55.219]                   }
[17:40:55.219]                   options(future.plan = NULL)
[17:40:55.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.219]                 }
[17:40:55.219]                 ...future.workdir <- getwd()
[17:40:55.219]             }
[17:40:55.219]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.219]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.219]         }
[17:40:55.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.219]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.219]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.219]             base::names(...future.oldOptions))
[17:40:55.219]     }
[17:40:55.219]     if (FALSE) {
[17:40:55.219]     }
[17:40:55.219]     else {
[17:40:55.219]         if (TRUE) {
[17:40:55.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.219]                 open = "w")
[17:40:55.219]         }
[17:40:55.219]         else {
[17:40:55.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.219]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.219]         }
[17:40:55.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.219]             base::sink(type = "output", split = FALSE)
[17:40:55.219]             base::close(...future.stdout)
[17:40:55.219]         }, add = TRUE)
[17:40:55.219]     }
[17:40:55.219]     ...future.frame <- base::sys.nframe()
[17:40:55.219]     ...future.conditions <- base::list()
[17:40:55.219]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.219]     if (FALSE) {
[17:40:55.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.219]     }
[17:40:55.219]     ...future.result <- base::tryCatch({
[17:40:55.219]         base::withCallingHandlers({
[17:40:55.219]             ...future.value <- base::withVisible(base::local({
[17:40:55.219]                 withCallingHandlers({
[17:40:55.219]                   {
[17:40:55.219]                     do.call(function(...) {
[17:40:55.219]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.219]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.219]                         ...future.globals.maxSize)) {
[17:40:55.219]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.219]                         on.exit(options(oopts), add = TRUE)
[17:40:55.219]                       }
[17:40:55.219]                       {
[17:40:55.219]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.219]                           FUN = function(jj) {
[17:40:55.219]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.219]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.219]                           })
[17:40:55.219]                       }
[17:40:55.219]                     }, args = future.call.arguments)
[17:40:55.219]                   }
[17:40:55.219]                 }, immediateCondition = function(cond) {
[17:40:55.219]                   save_rds <- function (object, pathname, ...) 
[17:40:55.219]                   {
[17:40:55.219]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.219]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.219]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.219]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.219]                         fi_tmp[["mtime"]])
[17:40:55.219]                     }
[17:40:55.219]                     tryCatch({
[17:40:55.219]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.219]                     }, error = function(ex) {
[17:40:55.219]                       msg <- conditionMessage(ex)
[17:40:55.219]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.219]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.219]                         fi_tmp[["mtime"]], msg)
[17:40:55.219]                       ex$message <- msg
[17:40:55.219]                       stop(ex)
[17:40:55.219]                     })
[17:40:55.219]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.219]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.219]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.219]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.219]                       fi <- file.info(pathname)
[17:40:55.219]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.219]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.219]                         fi[["size"]], fi[["mtime"]])
[17:40:55.219]                       stop(msg)
[17:40:55.219]                     }
[17:40:55.219]                     invisible(pathname)
[17:40:55.219]                   }
[17:40:55.219]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.219]                     rootPath = tempdir()) 
[17:40:55.219]                   {
[17:40:55.219]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.219]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.219]                       tmpdir = path, fileext = ".rds")
[17:40:55.219]                     save_rds(obj, file)
[17:40:55.219]                   }
[17:40:55.219]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.219]                   {
[17:40:55.219]                     inherits <- base::inherits
[17:40:55.219]                     invokeRestart <- base::invokeRestart
[17:40:55.219]                     is.null <- base::is.null
[17:40:55.219]                     muffled <- FALSE
[17:40:55.219]                     if (inherits(cond, "message")) {
[17:40:55.219]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.219]                       if (muffled) 
[17:40:55.219]                         invokeRestart("muffleMessage")
[17:40:55.219]                     }
[17:40:55.219]                     else if (inherits(cond, "warning")) {
[17:40:55.219]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.219]                       if (muffled) 
[17:40:55.219]                         invokeRestart("muffleWarning")
[17:40:55.219]                     }
[17:40:55.219]                     else if (inherits(cond, "condition")) {
[17:40:55.219]                       if (!is.null(pattern)) {
[17:40:55.219]                         computeRestarts <- base::computeRestarts
[17:40:55.219]                         grepl <- base::grepl
[17:40:55.219]                         restarts <- computeRestarts(cond)
[17:40:55.219]                         for (restart in restarts) {
[17:40:55.219]                           name <- restart$name
[17:40:55.219]                           if (is.null(name)) 
[17:40:55.219]                             next
[17:40:55.219]                           if (!grepl(pattern, name)) 
[17:40:55.219]                             next
[17:40:55.219]                           invokeRestart(restart)
[17:40:55.219]                           muffled <- TRUE
[17:40:55.219]                           break
[17:40:55.219]                         }
[17:40:55.219]                       }
[17:40:55.219]                     }
[17:40:55.219]                     invisible(muffled)
[17:40:55.219]                   }
[17:40:55.219]                   muffleCondition(cond)
[17:40:55.219]                 })
[17:40:55.219]             }))
[17:40:55.219]             future::FutureResult(value = ...future.value$value, 
[17:40:55.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.219]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.219]                     ...future.globalenv.names))
[17:40:55.219]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.219]         }, condition = base::local({
[17:40:55.219]             c <- base::c
[17:40:55.219]             inherits <- base::inherits
[17:40:55.219]             invokeRestart <- base::invokeRestart
[17:40:55.219]             length <- base::length
[17:40:55.219]             list <- base::list
[17:40:55.219]             seq.int <- base::seq.int
[17:40:55.219]             signalCondition <- base::signalCondition
[17:40:55.219]             sys.calls <- base::sys.calls
[17:40:55.219]             `[[` <- base::`[[`
[17:40:55.219]             `+` <- base::`+`
[17:40:55.219]             `<<-` <- base::`<<-`
[17:40:55.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.219]                   3L)]
[17:40:55.219]             }
[17:40:55.219]             function(cond) {
[17:40:55.219]                 is_error <- inherits(cond, "error")
[17:40:55.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.219]                   NULL)
[17:40:55.219]                 if (is_error) {
[17:40:55.219]                   sessionInformation <- function() {
[17:40:55.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.219]                       search = base::search(), system = base::Sys.info())
[17:40:55.219]                   }
[17:40:55.219]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.219]                     cond$call), session = sessionInformation(), 
[17:40:55.219]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.219]                   signalCondition(cond)
[17:40:55.219]                 }
[17:40:55.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.219]                 "immediateCondition"))) {
[17:40:55.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.219]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.219]                   if (TRUE && !signal) {
[17:40:55.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.219]                     {
[17:40:55.219]                       inherits <- base::inherits
[17:40:55.219]                       invokeRestart <- base::invokeRestart
[17:40:55.219]                       is.null <- base::is.null
[17:40:55.219]                       muffled <- FALSE
[17:40:55.219]                       if (inherits(cond, "message")) {
[17:40:55.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.219]                         if (muffled) 
[17:40:55.219]                           invokeRestart("muffleMessage")
[17:40:55.219]                       }
[17:40:55.219]                       else if (inherits(cond, "warning")) {
[17:40:55.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.219]                         if (muffled) 
[17:40:55.219]                           invokeRestart("muffleWarning")
[17:40:55.219]                       }
[17:40:55.219]                       else if (inherits(cond, "condition")) {
[17:40:55.219]                         if (!is.null(pattern)) {
[17:40:55.219]                           computeRestarts <- base::computeRestarts
[17:40:55.219]                           grepl <- base::grepl
[17:40:55.219]                           restarts <- computeRestarts(cond)
[17:40:55.219]                           for (restart in restarts) {
[17:40:55.219]                             name <- restart$name
[17:40:55.219]                             if (is.null(name)) 
[17:40:55.219]                               next
[17:40:55.219]                             if (!grepl(pattern, name)) 
[17:40:55.219]                               next
[17:40:55.219]                             invokeRestart(restart)
[17:40:55.219]                             muffled <- TRUE
[17:40:55.219]                             break
[17:40:55.219]                           }
[17:40:55.219]                         }
[17:40:55.219]                       }
[17:40:55.219]                       invisible(muffled)
[17:40:55.219]                     }
[17:40:55.219]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.219]                   }
[17:40:55.219]                 }
[17:40:55.219]                 else {
[17:40:55.219]                   if (TRUE) {
[17:40:55.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.219]                     {
[17:40:55.219]                       inherits <- base::inherits
[17:40:55.219]                       invokeRestart <- base::invokeRestart
[17:40:55.219]                       is.null <- base::is.null
[17:40:55.219]                       muffled <- FALSE
[17:40:55.219]                       if (inherits(cond, "message")) {
[17:40:55.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.219]                         if (muffled) 
[17:40:55.219]                           invokeRestart("muffleMessage")
[17:40:55.219]                       }
[17:40:55.219]                       else if (inherits(cond, "warning")) {
[17:40:55.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.219]                         if (muffled) 
[17:40:55.219]                           invokeRestart("muffleWarning")
[17:40:55.219]                       }
[17:40:55.219]                       else if (inherits(cond, "condition")) {
[17:40:55.219]                         if (!is.null(pattern)) {
[17:40:55.219]                           computeRestarts <- base::computeRestarts
[17:40:55.219]                           grepl <- base::grepl
[17:40:55.219]                           restarts <- computeRestarts(cond)
[17:40:55.219]                           for (restart in restarts) {
[17:40:55.219]                             name <- restart$name
[17:40:55.219]                             if (is.null(name)) 
[17:40:55.219]                               next
[17:40:55.219]                             if (!grepl(pattern, name)) 
[17:40:55.219]                               next
[17:40:55.219]                             invokeRestart(restart)
[17:40:55.219]                             muffled <- TRUE
[17:40:55.219]                             break
[17:40:55.219]                           }
[17:40:55.219]                         }
[17:40:55.219]                       }
[17:40:55.219]                       invisible(muffled)
[17:40:55.219]                     }
[17:40:55.219]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.219]                   }
[17:40:55.219]                 }
[17:40:55.219]             }
[17:40:55.219]         }))
[17:40:55.219]     }, error = function(ex) {
[17:40:55.219]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.219]                 ...future.rng), started = ...future.startTime, 
[17:40:55.219]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.219]             version = "1.8"), class = "FutureResult")
[17:40:55.219]     }, finally = {
[17:40:55.219]         if (!identical(...future.workdir, getwd())) 
[17:40:55.219]             setwd(...future.workdir)
[17:40:55.219]         {
[17:40:55.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.219]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.219]             }
[17:40:55.219]             base::options(...future.oldOptions)
[17:40:55.219]             if (.Platform$OS.type == "windows") {
[17:40:55.219]                 old_names <- names(...future.oldEnvVars)
[17:40:55.219]                 envs <- base::Sys.getenv()
[17:40:55.219]                 names <- names(envs)
[17:40:55.219]                 common <- intersect(names, old_names)
[17:40:55.219]                 added <- setdiff(names, old_names)
[17:40:55.219]                 removed <- setdiff(old_names, names)
[17:40:55.219]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.219]                   envs[common]]
[17:40:55.219]                 NAMES <- toupper(changed)
[17:40:55.219]                 args <- list()
[17:40:55.219]                 for (kk in seq_along(NAMES)) {
[17:40:55.219]                   name <- changed[[kk]]
[17:40:55.219]                   NAME <- NAMES[[kk]]
[17:40:55.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.219]                     next
[17:40:55.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.219]                 }
[17:40:55.219]                 NAMES <- toupper(added)
[17:40:55.219]                 for (kk in seq_along(NAMES)) {
[17:40:55.219]                   name <- added[[kk]]
[17:40:55.219]                   NAME <- NAMES[[kk]]
[17:40:55.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.219]                     next
[17:40:55.219]                   args[[name]] <- ""
[17:40:55.219]                 }
[17:40:55.219]                 NAMES <- toupper(removed)
[17:40:55.219]                 for (kk in seq_along(NAMES)) {
[17:40:55.219]                   name <- removed[[kk]]
[17:40:55.219]                   NAME <- NAMES[[kk]]
[17:40:55.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.219]                     next
[17:40:55.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.219]                 }
[17:40:55.219]                 if (length(args) > 0) 
[17:40:55.219]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.219]             }
[17:40:55.219]             else {
[17:40:55.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.219]             }
[17:40:55.219]             {
[17:40:55.219]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.219]                   0L) {
[17:40:55.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.219]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.219]                   base::options(opts)
[17:40:55.219]                 }
[17:40:55.219]                 {
[17:40:55.219]                   {
[17:40:55.219]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.219]                     NULL
[17:40:55.219]                   }
[17:40:55.219]                   options(future.plan = NULL)
[17:40:55.219]                   if (is.na(NA_character_)) 
[17:40:55.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.219]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.219]                     envir = parent.frame()) 
[17:40:55.219]                   {
[17:40:55.219]                     default_workers <- missing(workers)
[17:40:55.219]                     if (is.function(workers)) 
[17:40:55.219]                       workers <- workers()
[17:40:55.219]                     workers <- structure(as.integer(workers), 
[17:40:55.219]                       class = class(workers))
[17:40:55.219]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.219]                       1L)
[17:40:55.219]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.219]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.219]                       if (default_workers) 
[17:40:55.219]                         supportsMulticore(warn = TRUE)
[17:40:55.219]                       return(sequential(..., envir = envir))
[17:40:55.219]                     }
[17:40:55.219]                     oopts <- options(mc.cores = workers)
[17:40:55.219]                     on.exit(options(oopts))
[17:40:55.219]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.219]                       envir = envir)
[17:40:55.219]                     if (!future$lazy) 
[17:40:55.219]                       future <- run(future)
[17:40:55.219]                     invisible(future)
[17:40:55.219]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.219]                 }
[17:40:55.219]             }
[17:40:55.219]         }
[17:40:55.219]     })
[17:40:55.219]     if (TRUE) {
[17:40:55.219]         base::sink(type = "output", split = FALSE)
[17:40:55.219]         if (TRUE) {
[17:40:55.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.219]         }
[17:40:55.219]         else {
[17:40:55.219]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.219]         }
[17:40:55.219]         base::close(...future.stdout)
[17:40:55.219]         ...future.stdout <- NULL
[17:40:55.219]     }
[17:40:55.219]     ...future.result$conditions <- ...future.conditions
[17:40:55.219]     ...future.result$finished <- base::Sys.time()
[17:40:55.219]     ...future.result
[17:40:55.219] }
[17:40:55.222] assign_globals() ...
[17:40:55.222] List of 11
[17:40:55.222]  $ ...future.FUN            :function (x, ...)  
[17:40:55.222]  $ x_FUN                    :function (x)  
[17:40:55.222]  $ times                    : int 4
[17:40:55.222]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.222]  $ stop_if_not              :function (...)  
[17:40:55.222]  $ dim                      : int [1:2] 2 2
[17:40:55.222]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:55.222]  $ future.call.arguments    : list()
[17:40:55.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.222]  $ ...future.elements_ii    :List of 5
[17:40:55.222]   ..$ : int 6
[17:40:55.222]   ..$ : int 7
[17:40:55.222]   ..$ : int 8
[17:40:55.222]   ..$ : int 9
[17:40:55.222]   ..$ : int 10
[17:40:55.222]  $ ...future.seeds_ii       : NULL
[17:40:55.222]  $ ...future.globals.maxSize: NULL
[17:40:55.222]  - attr(*, "resolved")= logi FALSE
[17:40:55.222]  - attr(*, "total_size")= num 97232
[17:40:55.222]  - attr(*, "where")=List of 11
[17:40:55.222]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.222]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.222]  - attr(*, "already-done")= logi TRUE
[17:40:55.239] - copied ‘...future.FUN’ to environment
[17:40:55.239] - reassign environment for ‘x_FUN’
[17:40:55.239] - copied ‘x_FUN’ to environment
[17:40:55.239] - copied ‘times’ to environment
[17:40:55.239] - copied ‘stopf’ to environment
[17:40:55.239] - copied ‘stop_if_not’ to environment
[17:40:55.239] - copied ‘dim’ to environment
[17:40:55.240] - copied ‘valid_types’ to environment
[17:40:55.240] - copied ‘future.call.arguments’ to environment
[17:40:55.240] - copied ‘...future.elements_ii’ to environment
[17:40:55.240] - copied ‘...future.seeds_ii’ to environment
[17:40:55.240] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.240] assign_globals() ... done
[17:40:55.240] requestCore(): workers = 2
[17:40:55.243] MulticoreFuture started
[17:40:55.244] - Launch lazy future ... done
[17:40:55.244] run() for ‘MulticoreFuture’ ... done
[17:40:55.245] Created future:
[17:40:55.245] plan(): Setting new future strategy stack:
[17:40:55.245] List of future strategies:
[17:40:55.245] 1. sequential:
[17:40:55.245]    - args: function (..., envir = parent.frame())
[17:40:55.245]    - tweaked: FALSE
[17:40:55.245]    - call: NULL
[17:40:55.247] plan(): nbrOfWorkers() = 1
[17:40:55.250] plan(): Setting new future strategy stack:
[17:40:55.250] List of future strategies:
[17:40:55.250] 1. multicore:
[17:40:55.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.250]    - tweaked: FALSE
[17:40:55.250]    - call: plan(strategy)
[17:40:55.256] plan(): nbrOfWorkers() = 2
[17:40:55.245] MulticoreFuture:
[17:40:55.245] Label: ‘future_vapply-2’
[17:40:55.245] Expression:
[17:40:55.245] {
[17:40:55.245]     do.call(function(...) {
[17:40:55.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.245]             on.exit(options(oopts), add = TRUE)
[17:40:55.245]         }
[17:40:55.245]         {
[17:40:55.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.245]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.245]             })
[17:40:55.245]         }
[17:40:55.245]     }, args = future.call.arguments)
[17:40:55.245] }
[17:40:55.245] Lazy evaluation: FALSE
[17:40:55.245] Asynchronous evaluation: TRUE
[17:40:55.245] Local evaluation: TRUE
[17:40:55.245] Environment: R_GlobalEnv
[17:40:55.245] Capture standard output: TRUE
[17:40:55.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.245] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.245] Packages: 1 packages (‘future.apply’)
[17:40:55.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.245] Resolved: TRUE
[17:40:55.245] Value: <not collected>
[17:40:55.245] Conditions captured: <none>
[17:40:55.245] Early signaling: FALSE
[17:40:55.245] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.245] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.257] Chunk #2 of 2 ... DONE
[17:40:55.257] Launching 2 futures (chunks) ... DONE
[17:40:55.258] Resolving 2 futures (chunks) ...
[17:40:55.258] resolve() on list ...
[17:40:55.258]  recursive: 0
[17:40:55.258]  length: 2
[17:40:55.258] 
[17:40:55.259] Future #1
[17:40:55.260] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.260] - nx: 2
[17:40:55.260] - relay: TRUE
[17:40:55.260] - stdout: TRUE
[17:40:55.260] - signal: TRUE
[17:40:55.260] - resignal: FALSE
[17:40:55.261] - force: TRUE
[17:40:55.261] - relayed: [n=2] FALSE, FALSE
[17:40:55.261] - queued futures: [n=2] FALSE, FALSE
[17:40:55.261]  - until=1
[17:40:55.262]  - relaying element #1
[17:40:55.262] - relayed: [n=2] TRUE, FALSE
[17:40:55.262] - queued futures: [n=2] TRUE, FALSE
[17:40:55.262] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.263]  length: 1 (resolved future 1)
[17:40:55.263] Future #2
[17:40:55.264] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.264] - nx: 2
[17:40:55.264] - relay: TRUE
[17:40:55.265] - stdout: TRUE
[17:40:55.265] - signal: TRUE
[17:40:55.265] - resignal: FALSE
[17:40:55.265] - force: TRUE
[17:40:55.265] - relayed: [n=2] TRUE, FALSE
[17:40:55.265] - queued futures: [n=2] TRUE, FALSE
[17:40:55.265]  - until=2
[17:40:55.266]  - relaying element #2
[17:40:55.266] - relayed: [n=2] TRUE, TRUE
[17:40:55.266] - queued futures: [n=2] TRUE, TRUE
[17:40:55.266] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.266]  length: 0 (resolved future 2)
[17:40:55.266] Relaying remaining futures
[17:40:55.266] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.267] - nx: 2
[17:40:55.267] - relay: TRUE
[17:40:55.267] - stdout: TRUE
[17:40:55.267] - signal: TRUE
[17:40:55.267] - resignal: FALSE
[17:40:55.267] - force: TRUE
[17:40:55.267] - relayed: [n=2] TRUE, TRUE
[17:40:55.267] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.268] - relayed: [n=2] TRUE, TRUE
[17:40:55.268] - queued futures: [n=2] TRUE, TRUE
[17:40:55.268] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.268] resolve() on list ... DONE
[17:40:55.268]  - Number of value chunks collected: 2
[17:40:55.268] Resolving 2 futures (chunks) ... DONE
[17:40:55.268] Reducing values from 2 chunks ...
[17:40:55.269]  - Number of values collected after concatenation: 10
[17:40:55.269]  - Number of values expected: 10
[17:40:55.269] Reducing values from 2 chunks ... DONE
[17:40:55.269] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:40:55.270] future_lapply() ...
[17:40:55.276] Number of chunks: 2
[17:40:55.277] getGlobalsAndPackagesXApply() ...
[17:40:55.277]  - future.globals: TRUE
[17:40:55.277] getGlobalsAndPackages() ...
[17:40:55.277] Searching for globals...
[17:40:55.283] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:40:55.283] Searching for globals ... DONE
[17:40:55.283] Resolving globals: FALSE
[17:40:55.285] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:40:55.285] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:55.286] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.286] - packages: [1] ‘future.apply’
[17:40:55.286] getGlobalsAndPackages() ... DONE
[17:40:55.286]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.286]  - needed namespaces: [n=1] ‘future.apply’
[17:40:55.286] Finding globals ... DONE
[17:40:55.287]  - use_args: TRUE
[17:40:55.287]  - Getting '...' globals ...
[17:40:55.287] resolve() on list ...
[17:40:55.287]  recursive: 0
[17:40:55.287]  length: 1
[17:40:55.288]  elements: ‘...’
[17:40:55.288]  length: 0 (resolved future 1)
[17:40:55.288] resolve() on list ... DONE
[17:40:55.288]    - '...' content: [n=0] 
[17:40:55.288] List of 1
[17:40:55.288]  $ ...: list()
[17:40:55.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.288]  - attr(*, "where")=List of 1
[17:40:55.288]   ..$ ...:<environment: 0x564f2fbb6a60> 
[17:40:55.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.288]  - attr(*, "resolved")= logi TRUE
[17:40:55.288]  - attr(*, "total_size")= num NA
[17:40:55.291]  - Getting '...' globals ... DONE
[17:40:55.291] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:55.291] List of 8
[17:40:55.291]  $ ...future.FUN:function (x, ...)  
[17:40:55.291]  $ x_FUN        :function (x)  
[17:40:55.291]  $ times        : int 4
[17:40:55.291]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.291]  $ stop_if_not  :function (...)  
[17:40:55.291]  $ dim          : int [1:2] 2 2
[17:40:55.291]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:55.291]  $ ...          : list()
[17:40:55.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.291]  - attr(*, "where")=List of 8
[17:40:55.291]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:55.291]   ..$ ...          :<environment: 0x564f2fbb6a60> 
[17:40:55.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.291]  - attr(*, "resolved")= logi FALSE
[17:40:55.291]  - attr(*, "total_size")= num 97304
[17:40:55.297] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:55.297] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.297] Number of futures (= number of chunks): 2
[17:40:55.297] Launching 2 futures (chunks) ...
[17:40:55.298] Chunk #1 of 2 ...
[17:40:55.298]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.298] getGlobalsAndPackages() ...
[17:40:55.298] Searching for globals...
[17:40:55.298] 
[17:40:55.298] Searching for globals ... DONE
[17:40:55.298] - globals: [0] <none>
[17:40:55.298] getGlobalsAndPackages() ... DONE
[17:40:55.299]    + additional globals found: [n=0] 
[17:40:55.299]    + additional namespaces needed: [n=0] 
[17:40:55.299]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.299]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.299]  - seeds: <none>
[17:40:55.299] getGlobalsAndPackages() ...
[17:40:55.299] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.299] Resolving globals: FALSE
[17:40:55.299] Tweak future expression to call with '...' arguments ...
[17:40:55.300] {
[17:40:55.300]     do.call(function(...) {
[17:40:55.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.300]             on.exit(options(oopts), add = TRUE)
[17:40:55.300]         }
[17:40:55.300]         {
[17:40:55.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.300]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.300]             })
[17:40:55.300]         }
[17:40:55.300]     }, args = future.call.arguments)
[17:40:55.300] }
[17:40:55.300] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.300] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.301] - packages: [1] ‘future.apply’
[17:40:55.301] getGlobalsAndPackages() ... DONE
[17:40:55.301] run() for ‘Future’ ...
[17:40:55.301] - state: ‘created’
[17:40:55.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.305] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.306]   - Field: ‘label’
[17:40:55.306]   - Field: ‘local’
[17:40:55.306]   - Field: ‘owner’
[17:40:55.306]   - Field: ‘envir’
[17:40:55.306]   - Field: ‘workers’
[17:40:55.306]   - Field: ‘packages’
[17:40:55.306]   - Field: ‘gc’
[17:40:55.306]   - Field: ‘job’
[17:40:55.306]   - Field: ‘conditions’
[17:40:55.306]   - Field: ‘expr’
[17:40:55.306]   - Field: ‘uuid’
[17:40:55.307]   - Field: ‘seed’
[17:40:55.309]   - Field: ‘version’
[17:40:55.309]   - Field: ‘result’
[17:40:55.309]   - Field: ‘asynchronous’
[17:40:55.309]   - Field: ‘calls’
[17:40:55.309]   - Field: ‘globals’
[17:40:55.309]   - Field: ‘stdout’
[17:40:55.309]   - Field: ‘earlySignal’
[17:40:55.310]   - Field: ‘lazy’
[17:40:55.310]   - Field: ‘state’
[17:40:55.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.310] - Launch lazy future ...
[17:40:55.310] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.310] Packages needed by future strategies (n = 0): <none>
[17:40:55.311] {
[17:40:55.311]     {
[17:40:55.311]         {
[17:40:55.311]             ...future.startTime <- base::Sys.time()
[17:40:55.311]             {
[17:40:55.311]                 {
[17:40:55.311]                   {
[17:40:55.311]                     {
[17:40:55.311]                       {
[17:40:55.311]                         base::local({
[17:40:55.311]                           has_future <- base::requireNamespace("future", 
[17:40:55.311]                             quietly = TRUE)
[17:40:55.311]                           if (has_future) {
[17:40:55.311]                             ns <- base::getNamespace("future")
[17:40:55.311]                             version <- ns[[".package"]][["version"]]
[17:40:55.311]                             if (is.null(version)) 
[17:40:55.311]                               version <- utils::packageVersion("future")
[17:40:55.311]                           }
[17:40:55.311]                           else {
[17:40:55.311]                             version <- NULL
[17:40:55.311]                           }
[17:40:55.311]                           if (!has_future || version < "1.8.0") {
[17:40:55.311]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.311]                               "", base::R.version$version.string), 
[17:40:55.311]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.311]                                 base::R.version$platform, 8 * 
[17:40:55.311]                                   base::.Machine$sizeof.pointer), 
[17:40:55.311]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.311]                                 "release", "version")], collapse = " "), 
[17:40:55.311]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.311]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.311]                               info)
[17:40:55.311]                             info <- base::paste(info, collapse = "; ")
[17:40:55.311]                             if (!has_future) {
[17:40:55.311]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.311]                                 info)
[17:40:55.311]                             }
[17:40:55.311]                             else {
[17:40:55.311]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.311]                                 info, version)
[17:40:55.311]                             }
[17:40:55.311]                             base::stop(msg)
[17:40:55.311]                           }
[17:40:55.311]                         })
[17:40:55.311]                       }
[17:40:55.311]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.311]                       base::options(mc.cores = 1L)
[17:40:55.311]                     }
[17:40:55.311]                     base::local({
[17:40:55.311]                       for (pkg in "future.apply") {
[17:40:55.311]                         base::loadNamespace(pkg)
[17:40:55.311]                         base::library(pkg, character.only = TRUE)
[17:40:55.311]                       }
[17:40:55.311]                     })
[17:40:55.311]                   }
[17:40:55.311]                   options(future.plan = NULL)
[17:40:55.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.311]                 }
[17:40:55.311]                 ...future.workdir <- getwd()
[17:40:55.311]             }
[17:40:55.311]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.311]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.311]         }
[17:40:55.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.311]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.311]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.311]             base::names(...future.oldOptions))
[17:40:55.311]     }
[17:40:55.311]     if (FALSE) {
[17:40:55.311]     }
[17:40:55.311]     else {
[17:40:55.311]         if (TRUE) {
[17:40:55.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.311]                 open = "w")
[17:40:55.311]         }
[17:40:55.311]         else {
[17:40:55.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.311]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.311]         }
[17:40:55.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.311]             base::sink(type = "output", split = FALSE)
[17:40:55.311]             base::close(...future.stdout)
[17:40:55.311]         }, add = TRUE)
[17:40:55.311]     }
[17:40:55.311]     ...future.frame <- base::sys.nframe()
[17:40:55.311]     ...future.conditions <- base::list()
[17:40:55.311]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.311]     if (FALSE) {
[17:40:55.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.311]     }
[17:40:55.311]     ...future.result <- base::tryCatch({
[17:40:55.311]         base::withCallingHandlers({
[17:40:55.311]             ...future.value <- base::withVisible(base::local({
[17:40:55.311]                 withCallingHandlers({
[17:40:55.311]                   {
[17:40:55.311]                     do.call(function(...) {
[17:40:55.311]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.311]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.311]                         ...future.globals.maxSize)) {
[17:40:55.311]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.311]                         on.exit(options(oopts), add = TRUE)
[17:40:55.311]                       }
[17:40:55.311]                       {
[17:40:55.311]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.311]                           FUN = function(jj) {
[17:40:55.311]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.311]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.311]                           })
[17:40:55.311]                       }
[17:40:55.311]                     }, args = future.call.arguments)
[17:40:55.311]                   }
[17:40:55.311]                 }, immediateCondition = function(cond) {
[17:40:55.311]                   save_rds <- function (object, pathname, ...) 
[17:40:55.311]                   {
[17:40:55.311]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.311]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.311]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.311]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.311]                         fi_tmp[["mtime"]])
[17:40:55.311]                     }
[17:40:55.311]                     tryCatch({
[17:40:55.311]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.311]                     }, error = function(ex) {
[17:40:55.311]                       msg <- conditionMessage(ex)
[17:40:55.311]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.311]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.311]                         fi_tmp[["mtime"]], msg)
[17:40:55.311]                       ex$message <- msg
[17:40:55.311]                       stop(ex)
[17:40:55.311]                     })
[17:40:55.311]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.311]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.311]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.311]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.311]                       fi <- file.info(pathname)
[17:40:55.311]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.311]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.311]                         fi[["size"]], fi[["mtime"]])
[17:40:55.311]                       stop(msg)
[17:40:55.311]                     }
[17:40:55.311]                     invisible(pathname)
[17:40:55.311]                   }
[17:40:55.311]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.311]                     rootPath = tempdir()) 
[17:40:55.311]                   {
[17:40:55.311]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.311]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.311]                       tmpdir = path, fileext = ".rds")
[17:40:55.311]                     save_rds(obj, file)
[17:40:55.311]                   }
[17:40:55.311]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.311]                   {
[17:40:55.311]                     inherits <- base::inherits
[17:40:55.311]                     invokeRestart <- base::invokeRestart
[17:40:55.311]                     is.null <- base::is.null
[17:40:55.311]                     muffled <- FALSE
[17:40:55.311]                     if (inherits(cond, "message")) {
[17:40:55.311]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.311]                       if (muffled) 
[17:40:55.311]                         invokeRestart("muffleMessage")
[17:40:55.311]                     }
[17:40:55.311]                     else if (inherits(cond, "warning")) {
[17:40:55.311]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.311]                       if (muffled) 
[17:40:55.311]                         invokeRestart("muffleWarning")
[17:40:55.311]                     }
[17:40:55.311]                     else if (inherits(cond, "condition")) {
[17:40:55.311]                       if (!is.null(pattern)) {
[17:40:55.311]                         computeRestarts <- base::computeRestarts
[17:40:55.311]                         grepl <- base::grepl
[17:40:55.311]                         restarts <- computeRestarts(cond)
[17:40:55.311]                         for (restart in restarts) {
[17:40:55.311]                           name <- restart$name
[17:40:55.311]                           if (is.null(name)) 
[17:40:55.311]                             next
[17:40:55.311]                           if (!grepl(pattern, name)) 
[17:40:55.311]                             next
[17:40:55.311]                           invokeRestart(restart)
[17:40:55.311]                           muffled <- TRUE
[17:40:55.311]                           break
[17:40:55.311]                         }
[17:40:55.311]                       }
[17:40:55.311]                     }
[17:40:55.311]                     invisible(muffled)
[17:40:55.311]                   }
[17:40:55.311]                   muffleCondition(cond)
[17:40:55.311]                 })
[17:40:55.311]             }))
[17:40:55.311]             future::FutureResult(value = ...future.value$value, 
[17:40:55.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.311]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.311]                     ...future.globalenv.names))
[17:40:55.311]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.311]         }, condition = base::local({
[17:40:55.311]             c <- base::c
[17:40:55.311]             inherits <- base::inherits
[17:40:55.311]             invokeRestart <- base::invokeRestart
[17:40:55.311]             length <- base::length
[17:40:55.311]             list <- base::list
[17:40:55.311]             seq.int <- base::seq.int
[17:40:55.311]             signalCondition <- base::signalCondition
[17:40:55.311]             sys.calls <- base::sys.calls
[17:40:55.311]             `[[` <- base::`[[`
[17:40:55.311]             `+` <- base::`+`
[17:40:55.311]             `<<-` <- base::`<<-`
[17:40:55.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.311]                   3L)]
[17:40:55.311]             }
[17:40:55.311]             function(cond) {
[17:40:55.311]                 is_error <- inherits(cond, "error")
[17:40:55.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.311]                   NULL)
[17:40:55.311]                 if (is_error) {
[17:40:55.311]                   sessionInformation <- function() {
[17:40:55.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.311]                       search = base::search(), system = base::Sys.info())
[17:40:55.311]                   }
[17:40:55.311]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.311]                     cond$call), session = sessionInformation(), 
[17:40:55.311]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.311]                   signalCondition(cond)
[17:40:55.311]                 }
[17:40:55.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.311]                 "immediateCondition"))) {
[17:40:55.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.311]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.311]                   if (TRUE && !signal) {
[17:40:55.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.311]                     {
[17:40:55.311]                       inherits <- base::inherits
[17:40:55.311]                       invokeRestart <- base::invokeRestart
[17:40:55.311]                       is.null <- base::is.null
[17:40:55.311]                       muffled <- FALSE
[17:40:55.311]                       if (inherits(cond, "message")) {
[17:40:55.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.311]                         if (muffled) 
[17:40:55.311]                           invokeRestart("muffleMessage")
[17:40:55.311]                       }
[17:40:55.311]                       else if (inherits(cond, "warning")) {
[17:40:55.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.311]                         if (muffled) 
[17:40:55.311]                           invokeRestart("muffleWarning")
[17:40:55.311]                       }
[17:40:55.311]                       else if (inherits(cond, "condition")) {
[17:40:55.311]                         if (!is.null(pattern)) {
[17:40:55.311]                           computeRestarts <- base::computeRestarts
[17:40:55.311]                           grepl <- base::grepl
[17:40:55.311]                           restarts <- computeRestarts(cond)
[17:40:55.311]                           for (restart in restarts) {
[17:40:55.311]                             name <- restart$name
[17:40:55.311]                             if (is.null(name)) 
[17:40:55.311]                               next
[17:40:55.311]                             if (!grepl(pattern, name)) 
[17:40:55.311]                               next
[17:40:55.311]                             invokeRestart(restart)
[17:40:55.311]                             muffled <- TRUE
[17:40:55.311]                             break
[17:40:55.311]                           }
[17:40:55.311]                         }
[17:40:55.311]                       }
[17:40:55.311]                       invisible(muffled)
[17:40:55.311]                     }
[17:40:55.311]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.311]                   }
[17:40:55.311]                 }
[17:40:55.311]                 else {
[17:40:55.311]                   if (TRUE) {
[17:40:55.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.311]                     {
[17:40:55.311]                       inherits <- base::inherits
[17:40:55.311]                       invokeRestart <- base::invokeRestart
[17:40:55.311]                       is.null <- base::is.null
[17:40:55.311]                       muffled <- FALSE
[17:40:55.311]                       if (inherits(cond, "message")) {
[17:40:55.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.311]                         if (muffled) 
[17:40:55.311]                           invokeRestart("muffleMessage")
[17:40:55.311]                       }
[17:40:55.311]                       else if (inherits(cond, "warning")) {
[17:40:55.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.311]                         if (muffled) 
[17:40:55.311]                           invokeRestart("muffleWarning")
[17:40:55.311]                       }
[17:40:55.311]                       else if (inherits(cond, "condition")) {
[17:40:55.311]                         if (!is.null(pattern)) {
[17:40:55.311]                           computeRestarts <- base::computeRestarts
[17:40:55.311]                           grepl <- base::grepl
[17:40:55.311]                           restarts <- computeRestarts(cond)
[17:40:55.311]                           for (restart in restarts) {
[17:40:55.311]                             name <- restart$name
[17:40:55.311]                             if (is.null(name)) 
[17:40:55.311]                               next
[17:40:55.311]                             if (!grepl(pattern, name)) 
[17:40:55.311]                               next
[17:40:55.311]                             invokeRestart(restart)
[17:40:55.311]                             muffled <- TRUE
[17:40:55.311]                             break
[17:40:55.311]                           }
[17:40:55.311]                         }
[17:40:55.311]                       }
[17:40:55.311]                       invisible(muffled)
[17:40:55.311]                     }
[17:40:55.311]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.311]                   }
[17:40:55.311]                 }
[17:40:55.311]             }
[17:40:55.311]         }))
[17:40:55.311]     }, error = function(ex) {
[17:40:55.311]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.311]                 ...future.rng), started = ...future.startTime, 
[17:40:55.311]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.311]             version = "1.8"), class = "FutureResult")
[17:40:55.311]     }, finally = {
[17:40:55.311]         if (!identical(...future.workdir, getwd())) 
[17:40:55.311]             setwd(...future.workdir)
[17:40:55.311]         {
[17:40:55.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.311]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.311]             }
[17:40:55.311]             base::options(...future.oldOptions)
[17:40:55.311]             if (.Platform$OS.type == "windows") {
[17:40:55.311]                 old_names <- names(...future.oldEnvVars)
[17:40:55.311]                 envs <- base::Sys.getenv()
[17:40:55.311]                 names <- names(envs)
[17:40:55.311]                 common <- intersect(names, old_names)
[17:40:55.311]                 added <- setdiff(names, old_names)
[17:40:55.311]                 removed <- setdiff(old_names, names)
[17:40:55.311]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.311]                   envs[common]]
[17:40:55.311]                 NAMES <- toupper(changed)
[17:40:55.311]                 args <- list()
[17:40:55.311]                 for (kk in seq_along(NAMES)) {
[17:40:55.311]                   name <- changed[[kk]]
[17:40:55.311]                   NAME <- NAMES[[kk]]
[17:40:55.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.311]                     next
[17:40:55.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.311]                 }
[17:40:55.311]                 NAMES <- toupper(added)
[17:40:55.311]                 for (kk in seq_along(NAMES)) {
[17:40:55.311]                   name <- added[[kk]]
[17:40:55.311]                   NAME <- NAMES[[kk]]
[17:40:55.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.311]                     next
[17:40:55.311]                   args[[name]] <- ""
[17:40:55.311]                 }
[17:40:55.311]                 NAMES <- toupper(removed)
[17:40:55.311]                 for (kk in seq_along(NAMES)) {
[17:40:55.311]                   name <- removed[[kk]]
[17:40:55.311]                   NAME <- NAMES[[kk]]
[17:40:55.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.311]                     next
[17:40:55.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.311]                 }
[17:40:55.311]                 if (length(args) > 0) 
[17:40:55.311]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.311]             }
[17:40:55.311]             else {
[17:40:55.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.311]             }
[17:40:55.311]             {
[17:40:55.311]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.311]                   0L) {
[17:40:55.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.311]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.311]                   base::options(opts)
[17:40:55.311]                 }
[17:40:55.311]                 {
[17:40:55.311]                   {
[17:40:55.311]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.311]                     NULL
[17:40:55.311]                   }
[17:40:55.311]                   options(future.plan = NULL)
[17:40:55.311]                   if (is.na(NA_character_)) 
[17:40:55.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.311]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.311]                     envir = parent.frame()) 
[17:40:55.311]                   {
[17:40:55.311]                     default_workers <- missing(workers)
[17:40:55.311]                     if (is.function(workers)) 
[17:40:55.311]                       workers <- workers()
[17:40:55.311]                     workers <- structure(as.integer(workers), 
[17:40:55.311]                       class = class(workers))
[17:40:55.311]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.311]                       1L)
[17:40:55.311]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.311]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.311]                       if (default_workers) 
[17:40:55.311]                         supportsMulticore(warn = TRUE)
[17:40:55.311]                       return(sequential(..., envir = envir))
[17:40:55.311]                     }
[17:40:55.311]                     oopts <- options(mc.cores = workers)
[17:40:55.311]                     on.exit(options(oopts))
[17:40:55.311]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.311]                       envir = envir)
[17:40:55.311]                     if (!future$lazy) 
[17:40:55.311]                       future <- run(future)
[17:40:55.311]                     invisible(future)
[17:40:55.311]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.311]                 }
[17:40:55.311]             }
[17:40:55.311]         }
[17:40:55.311]     })
[17:40:55.311]     if (TRUE) {
[17:40:55.311]         base::sink(type = "output", split = FALSE)
[17:40:55.311]         if (TRUE) {
[17:40:55.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.311]         }
[17:40:55.311]         else {
[17:40:55.311]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.311]         }
[17:40:55.311]         base::close(...future.stdout)
[17:40:55.311]         ...future.stdout <- NULL
[17:40:55.311]     }
[17:40:55.311]     ...future.result$conditions <- ...future.conditions
[17:40:55.311]     ...future.result$finished <- base::Sys.time()
[17:40:55.311]     ...future.result
[17:40:55.311] }
[17:40:55.314] assign_globals() ...
[17:40:55.314] List of 11
[17:40:55.314]  $ ...future.FUN            :function (x, ...)  
[17:40:55.314]  $ x_FUN                    :function (x)  
[17:40:55.314]  $ times                    : int 4
[17:40:55.314]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.314]  $ stop_if_not              :function (...)  
[17:40:55.314]  $ dim                      : int [1:2] 2 2
[17:40:55.314]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.314]  $ future.call.arguments    : list()
[17:40:55.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.314]  $ ...future.elements_ii    :List of 5
[17:40:55.314]   ..$ : int 1
[17:40:55.314]   ..$ : int 2
[17:40:55.314]   ..$ : int 3
[17:40:55.314]   ..$ : int 4
[17:40:55.314]   ..$ : int 5
[17:40:55.314]  $ ...future.seeds_ii       : NULL
[17:40:55.314]  $ ...future.globals.maxSize: NULL
[17:40:55.314]  - attr(*, "resolved")= logi FALSE
[17:40:55.314]  - attr(*, "total_size")= num 97304
[17:40:55.314]  - attr(*, "where")=List of 11
[17:40:55.314]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.314]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.314]  - attr(*, "already-done")= logi TRUE
[17:40:55.324] - copied ‘...future.FUN’ to environment
[17:40:55.324] - reassign environment for ‘x_FUN’
[17:40:55.324] - copied ‘x_FUN’ to environment
[17:40:55.324] - copied ‘times’ to environment
[17:40:55.324] - copied ‘stopf’ to environment
[17:40:55.324] - copied ‘stop_if_not’ to environment
[17:40:55.324] - copied ‘dim’ to environment
[17:40:55.324] - copied ‘valid_types’ to environment
[17:40:55.325] - copied ‘future.call.arguments’ to environment
[17:40:55.325] - copied ‘...future.elements_ii’ to environment
[17:40:55.325] - copied ‘...future.seeds_ii’ to environment
[17:40:55.325] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.325] assign_globals() ... done
[17:40:55.325] requestCore(): workers = 2
[17:40:55.328] MulticoreFuture started
[17:40:55.328] - Launch lazy future ... done
[17:40:55.328] run() for ‘MulticoreFuture’ ... done
[17:40:55.328] Created future:
[17:40:55.329] plan(): Setting new future strategy stack:
[17:40:55.330] List of future strategies:
[17:40:55.330] 1. sequential:
[17:40:55.330]    - args: function (..., envir = parent.frame())
[17:40:55.330]    - tweaked: FALSE
[17:40:55.330]    - call: NULL
[17:40:55.330] plan(): nbrOfWorkers() = 1
[17:40:55.333] plan(): Setting new future strategy stack:
[17:40:55.333] List of future strategies:
[17:40:55.333] 1. multicore:
[17:40:55.333]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.333]    - tweaked: FALSE
[17:40:55.333]    - call: plan(strategy)
[17:40:55.339] plan(): nbrOfWorkers() = 2
[17:40:55.329] MulticoreFuture:
[17:40:55.329] Label: ‘future_vapply-1’
[17:40:55.329] Expression:
[17:40:55.329] {
[17:40:55.329]     do.call(function(...) {
[17:40:55.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.329]             on.exit(options(oopts), add = TRUE)
[17:40:55.329]         }
[17:40:55.329]         {
[17:40:55.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.329]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.329]             })
[17:40:55.329]         }
[17:40:55.329]     }, args = future.call.arguments)
[17:40:55.329] }
[17:40:55.329] Lazy evaluation: FALSE
[17:40:55.329] Asynchronous evaluation: TRUE
[17:40:55.329] Local evaluation: TRUE
[17:40:55.329] Environment: R_GlobalEnv
[17:40:55.329] Capture standard output: TRUE
[17:40:55.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.329] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.329] Packages: 1 packages (‘future.apply’)
[17:40:55.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.329] Resolved: TRUE
[17:40:55.329] Value: <not collected>
[17:40:55.329] Conditions captured: <none>
[17:40:55.329] Early signaling: FALSE
[17:40:55.329] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.329] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.340] Chunk #1 of 2 ... DONE
[17:40:55.340] Chunk #2 of 2 ...
[17:40:55.340]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.341] getGlobalsAndPackages() ...
[17:40:55.341] Searching for globals...
[17:40:55.341] 
[17:40:55.341] Searching for globals ... DONE
[17:40:55.342] - globals: [0] <none>
[17:40:55.342] getGlobalsAndPackages() ... DONE
[17:40:55.342]    + additional globals found: [n=0] 
[17:40:55.342]    + additional namespaces needed: [n=0] 
[17:40:55.342]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.342]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.343]  - seeds: <none>
[17:40:55.343] getGlobalsAndPackages() ...
[17:40:55.343] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.343] Resolving globals: FALSE
[17:40:55.343] Tweak future expression to call with '...' arguments ...
[17:40:55.344] {
[17:40:55.344]     do.call(function(...) {
[17:40:55.344]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.344]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.344]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.344]             on.exit(options(oopts), add = TRUE)
[17:40:55.344]         }
[17:40:55.344]         {
[17:40:55.344]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.344]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.344]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.344]             })
[17:40:55.344]         }
[17:40:55.344]     }, args = future.call.arguments)
[17:40:55.344] }
[17:40:55.344] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.345] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.345] - packages: [1] ‘future.apply’
[17:40:55.345] getGlobalsAndPackages() ... DONE
[17:40:55.346] run() for ‘Future’ ...
[17:40:55.346] - state: ‘created’
[17:40:55.346] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.357]   - Field: ‘label’
[17:40:55.357]   - Field: ‘local’
[17:40:55.357]   - Field: ‘owner’
[17:40:55.358]   - Field: ‘envir’
[17:40:55.358]   - Field: ‘workers’
[17:40:55.358]   - Field: ‘packages’
[17:40:55.359]   - Field: ‘gc’
[17:40:55.359]   - Field: ‘job’
[17:40:55.359]   - Field: ‘conditions’
[17:40:55.359]   - Field: ‘expr’
[17:40:55.360]   - Field: ‘uuid’
[17:40:55.360]   - Field: ‘seed’
[17:40:55.360]   - Field: ‘version’
[17:40:55.360]   - Field: ‘result’
[17:40:55.360]   - Field: ‘asynchronous’
[17:40:55.361]   - Field: ‘calls’
[17:40:55.361]   - Field: ‘globals’
[17:40:55.361]   - Field: ‘stdout’
[17:40:55.361]   - Field: ‘earlySignal’
[17:40:55.362]   - Field: ‘lazy’
[17:40:55.362]   - Field: ‘state’
[17:40:55.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.362] - Launch lazy future ...
[17:40:55.363] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.363] Packages needed by future strategies (n = 0): <none>
[17:40:55.365] {
[17:40:55.365]     {
[17:40:55.365]         {
[17:40:55.365]             ...future.startTime <- base::Sys.time()
[17:40:55.365]             {
[17:40:55.365]                 {
[17:40:55.365]                   {
[17:40:55.365]                     {
[17:40:55.365]                       {
[17:40:55.365]                         base::local({
[17:40:55.365]                           has_future <- base::requireNamespace("future", 
[17:40:55.365]                             quietly = TRUE)
[17:40:55.365]                           if (has_future) {
[17:40:55.365]                             ns <- base::getNamespace("future")
[17:40:55.365]                             version <- ns[[".package"]][["version"]]
[17:40:55.365]                             if (is.null(version)) 
[17:40:55.365]                               version <- utils::packageVersion("future")
[17:40:55.365]                           }
[17:40:55.365]                           else {
[17:40:55.365]                             version <- NULL
[17:40:55.365]                           }
[17:40:55.365]                           if (!has_future || version < "1.8.0") {
[17:40:55.365]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.365]                               "", base::R.version$version.string), 
[17:40:55.365]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.365]                                 base::R.version$platform, 8 * 
[17:40:55.365]                                   base::.Machine$sizeof.pointer), 
[17:40:55.365]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.365]                                 "release", "version")], collapse = " "), 
[17:40:55.365]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.365]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.365]                               info)
[17:40:55.365]                             info <- base::paste(info, collapse = "; ")
[17:40:55.365]                             if (!has_future) {
[17:40:55.365]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.365]                                 info)
[17:40:55.365]                             }
[17:40:55.365]                             else {
[17:40:55.365]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.365]                                 info, version)
[17:40:55.365]                             }
[17:40:55.365]                             base::stop(msg)
[17:40:55.365]                           }
[17:40:55.365]                         })
[17:40:55.365]                       }
[17:40:55.365]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.365]                       base::options(mc.cores = 1L)
[17:40:55.365]                     }
[17:40:55.365]                     base::local({
[17:40:55.365]                       for (pkg in "future.apply") {
[17:40:55.365]                         base::loadNamespace(pkg)
[17:40:55.365]                         base::library(pkg, character.only = TRUE)
[17:40:55.365]                       }
[17:40:55.365]                     })
[17:40:55.365]                   }
[17:40:55.365]                   options(future.plan = NULL)
[17:40:55.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.365]                 }
[17:40:55.365]                 ...future.workdir <- getwd()
[17:40:55.365]             }
[17:40:55.365]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.365]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.365]         }
[17:40:55.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.365]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.365]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.365]             base::names(...future.oldOptions))
[17:40:55.365]     }
[17:40:55.365]     if (FALSE) {
[17:40:55.365]     }
[17:40:55.365]     else {
[17:40:55.365]         if (TRUE) {
[17:40:55.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.365]                 open = "w")
[17:40:55.365]         }
[17:40:55.365]         else {
[17:40:55.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.365]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.365]         }
[17:40:55.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.365]             base::sink(type = "output", split = FALSE)
[17:40:55.365]             base::close(...future.stdout)
[17:40:55.365]         }, add = TRUE)
[17:40:55.365]     }
[17:40:55.365]     ...future.frame <- base::sys.nframe()
[17:40:55.365]     ...future.conditions <- base::list()
[17:40:55.365]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.365]     if (FALSE) {
[17:40:55.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.365]     }
[17:40:55.365]     ...future.result <- base::tryCatch({
[17:40:55.365]         base::withCallingHandlers({
[17:40:55.365]             ...future.value <- base::withVisible(base::local({
[17:40:55.365]                 withCallingHandlers({
[17:40:55.365]                   {
[17:40:55.365]                     do.call(function(...) {
[17:40:55.365]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.365]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.365]                         ...future.globals.maxSize)) {
[17:40:55.365]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.365]                         on.exit(options(oopts), add = TRUE)
[17:40:55.365]                       }
[17:40:55.365]                       {
[17:40:55.365]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.365]                           FUN = function(jj) {
[17:40:55.365]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.365]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.365]                           })
[17:40:55.365]                       }
[17:40:55.365]                     }, args = future.call.arguments)
[17:40:55.365]                   }
[17:40:55.365]                 }, immediateCondition = function(cond) {
[17:40:55.365]                   save_rds <- function (object, pathname, ...) 
[17:40:55.365]                   {
[17:40:55.365]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.365]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.365]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.365]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.365]                         fi_tmp[["mtime"]])
[17:40:55.365]                     }
[17:40:55.365]                     tryCatch({
[17:40:55.365]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.365]                     }, error = function(ex) {
[17:40:55.365]                       msg <- conditionMessage(ex)
[17:40:55.365]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.365]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.365]                         fi_tmp[["mtime"]], msg)
[17:40:55.365]                       ex$message <- msg
[17:40:55.365]                       stop(ex)
[17:40:55.365]                     })
[17:40:55.365]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.365]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.365]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.365]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.365]                       fi <- file.info(pathname)
[17:40:55.365]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.365]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.365]                         fi[["size"]], fi[["mtime"]])
[17:40:55.365]                       stop(msg)
[17:40:55.365]                     }
[17:40:55.365]                     invisible(pathname)
[17:40:55.365]                   }
[17:40:55.365]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.365]                     rootPath = tempdir()) 
[17:40:55.365]                   {
[17:40:55.365]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.365]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.365]                       tmpdir = path, fileext = ".rds")
[17:40:55.365]                     save_rds(obj, file)
[17:40:55.365]                   }
[17:40:55.365]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.365]                   {
[17:40:55.365]                     inherits <- base::inherits
[17:40:55.365]                     invokeRestart <- base::invokeRestart
[17:40:55.365]                     is.null <- base::is.null
[17:40:55.365]                     muffled <- FALSE
[17:40:55.365]                     if (inherits(cond, "message")) {
[17:40:55.365]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.365]                       if (muffled) 
[17:40:55.365]                         invokeRestart("muffleMessage")
[17:40:55.365]                     }
[17:40:55.365]                     else if (inherits(cond, "warning")) {
[17:40:55.365]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.365]                       if (muffled) 
[17:40:55.365]                         invokeRestart("muffleWarning")
[17:40:55.365]                     }
[17:40:55.365]                     else if (inherits(cond, "condition")) {
[17:40:55.365]                       if (!is.null(pattern)) {
[17:40:55.365]                         computeRestarts <- base::computeRestarts
[17:40:55.365]                         grepl <- base::grepl
[17:40:55.365]                         restarts <- computeRestarts(cond)
[17:40:55.365]                         for (restart in restarts) {
[17:40:55.365]                           name <- restart$name
[17:40:55.365]                           if (is.null(name)) 
[17:40:55.365]                             next
[17:40:55.365]                           if (!grepl(pattern, name)) 
[17:40:55.365]                             next
[17:40:55.365]                           invokeRestart(restart)
[17:40:55.365]                           muffled <- TRUE
[17:40:55.365]                           break
[17:40:55.365]                         }
[17:40:55.365]                       }
[17:40:55.365]                     }
[17:40:55.365]                     invisible(muffled)
[17:40:55.365]                   }
[17:40:55.365]                   muffleCondition(cond)
[17:40:55.365]                 })
[17:40:55.365]             }))
[17:40:55.365]             future::FutureResult(value = ...future.value$value, 
[17:40:55.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.365]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.365]                     ...future.globalenv.names))
[17:40:55.365]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.365]         }, condition = base::local({
[17:40:55.365]             c <- base::c
[17:40:55.365]             inherits <- base::inherits
[17:40:55.365]             invokeRestart <- base::invokeRestart
[17:40:55.365]             length <- base::length
[17:40:55.365]             list <- base::list
[17:40:55.365]             seq.int <- base::seq.int
[17:40:55.365]             signalCondition <- base::signalCondition
[17:40:55.365]             sys.calls <- base::sys.calls
[17:40:55.365]             `[[` <- base::`[[`
[17:40:55.365]             `+` <- base::`+`
[17:40:55.365]             `<<-` <- base::`<<-`
[17:40:55.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.365]                   3L)]
[17:40:55.365]             }
[17:40:55.365]             function(cond) {
[17:40:55.365]                 is_error <- inherits(cond, "error")
[17:40:55.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.365]                   NULL)
[17:40:55.365]                 if (is_error) {
[17:40:55.365]                   sessionInformation <- function() {
[17:40:55.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.365]                       search = base::search(), system = base::Sys.info())
[17:40:55.365]                   }
[17:40:55.365]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.365]                     cond$call), session = sessionInformation(), 
[17:40:55.365]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.365]                   signalCondition(cond)
[17:40:55.365]                 }
[17:40:55.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.365]                 "immediateCondition"))) {
[17:40:55.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.365]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.365]                   if (TRUE && !signal) {
[17:40:55.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.365]                     {
[17:40:55.365]                       inherits <- base::inherits
[17:40:55.365]                       invokeRestart <- base::invokeRestart
[17:40:55.365]                       is.null <- base::is.null
[17:40:55.365]                       muffled <- FALSE
[17:40:55.365]                       if (inherits(cond, "message")) {
[17:40:55.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.365]                         if (muffled) 
[17:40:55.365]                           invokeRestart("muffleMessage")
[17:40:55.365]                       }
[17:40:55.365]                       else if (inherits(cond, "warning")) {
[17:40:55.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.365]                         if (muffled) 
[17:40:55.365]                           invokeRestart("muffleWarning")
[17:40:55.365]                       }
[17:40:55.365]                       else if (inherits(cond, "condition")) {
[17:40:55.365]                         if (!is.null(pattern)) {
[17:40:55.365]                           computeRestarts <- base::computeRestarts
[17:40:55.365]                           grepl <- base::grepl
[17:40:55.365]                           restarts <- computeRestarts(cond)
[17:40:55.365]                           for (restart in restarts) {
[17:40:55.365]                             name <- restart$name
[17:40:55.365]                             if (is.null(name)) 
[17:40:55.365]                               next
[17:40:55.365]                             if (!grepl(pattern, name)) 
[17:40:55.365]                               next
[17:40:55.365]                             invokeRestart(restart)
[17:40:55.365]                             muffled <- TRUE
[17:40:55.365]                             break
[17:40:55.365]                           }
[17:40:55.365]                         }
[17:40:55.365]                       }
[17:40:55.365]                       invisible(muffled)
[17:40:55.365]                     }
[17:40:55.365]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.365]                   }
[17:40:55.365]                 }
[17:40:55.365]                 else {
[17:40:55.365]                   if (TRUE) {
[17:40:55.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.365]                     {
[17:40:55.365]                       inherits <- base::inherits
[17:40:55.365]                       invokeRestart <- base::invokeRestart
[17:40:55.365]                       is.null <- base::is.null
[17:40:55.365]                       muffled <- FALSE
[17:40:55.365]                       if (inherits(cond, "message")) {
[17:40:55.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.365]                         if (muffled) 
[17:40:55.365]                           invokeRestart("muffleMessage")
[17:40:55.365]                       }
[17:40:55.365]                       else if (inherits(cond, "warning")) {
[17:40:55.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.365]                         if (muffled) 
[17:40:55.365]                           invokeRestart("muffleWarning")
[17:40:55.365]                       }
[17:40:55.365]                       else if (inherits(cond, "condition")) {
[17:40:55.365]                         if (!is.null(pattern)) {
[17:40:55.365]                           computeRestarts <- base::computeRestarts
[17:40:55.365]                           grepl <- base::grepl
[17:40:55.365]                           restarts <- computeRestarts(cond)
[17:40:55.365]                           for (restart in restarts) {
[17:40:55.365]                             name <- restart$name
[17:40:55.365]                             if (is.null(name)) 
[17:40:55.365]                               next
[17:40:55.365]                             if (!grepl(pattern, name)) 
[17:40:55.365]                               next
[17:40:55.365]                             invokeRestart(restart)
[17:40:55.365]                             muffled <- TRUE
[17:40:55.365]                             break
[17:40:55.365]                           }
[17:40:55.365]                         }
[17:40:55.365]                       }
[17:40:55.365]                       invisible(muffled)
[17:40:55.365]                     }
[17:40:55.365]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.365]                   }
[17:40:55.365]                 }
[17:40:55.365]             }
[17:40:55.365]         }))
[17:40:55.365]     }, error = function(ex) {
[17:40:55.365]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.365]                 ...future.rng), started = ...future.startTime, 
[17:40:55.365]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.365]             version = "1.8"), class = "FutureResult")
[17:40:55.365]     }, finally = {
[17:40:55.365]         if (!identical(...future.workdir, getwd())) 
[17:40:55.365]             setwd(...future.workdir)
[17:40:55.365]         {
[17:40:55.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.365]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.365]             }
[17:40:55.365]             base::options(...future.oldOptions)
[17:40:55.365]             if (.Platform$OS.type == "windows") {
[17:40:55.365]                 old_names <- names(...future.oldEnvVars)
[17:40:55.365]                 envs <- base::Sys.getenv()
[17:40:55.365]                 names <- names(envs)
[17:40:55.365]                 common <- intersect(names, old_names)
[17:40:55.365]                 added <- setdiff(names, old_names)
[17:40:55.365]                 removed <- setdiff(old_names, names)
[17:40:55.365]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.365]                   envs[common]]
[17:40:55.365]                 NAMES <- toupper(changed)
[17:40:55.365]                 args <- list()
[17:40:55.365]                 for (kk in seq_along(NAMES)) {
[17:40:55.365]                   name <- changed[[kk]]
[17:40:55.365]                   NAME <- NAMES[[kk]]
[17:40:55.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.365]                     next
[17:40:55.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.365]                 }
[17:40:55.365]                 NAMES <- toupper(added)
[17:40:55.365]                 for (kk in seq_along(NAMES)) {
[17:40:55.365]                   name <- added[[kk]]
[17:40:55.365]                   NAME <- NAMES[[kk]]
[17:40:55.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.365]                     next
[17:40:55.365]                   args[[name]] <- ""
[17:40:55.365]                 }
[17:40:55.365]                 NAMES <- toupper(removed)
[17:40:55.365]                 for (kk in seq_along(NAMES)) {
[17:40:55.365]                   name <- removed[[kk]]
[17:40:55.365]                   NAME <- NAMES[[kk]]
[17:40:55.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.365]                     next
[17:40:55.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.365]                 }
[17:40:55.365]                 if (length(args) > 0) 
[17:40:55.365]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.365]             }
[17:40:55.365]             else {
[17:40:55.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.365]             }
[17:40:55.365]             {
[17:40:55.365]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.365]                   0L) {
[17:40:55.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.365]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.365]                   base::options(opts)
[17:40:55.365]                 }
[17:40:55.365]                 {
[17:40:55.365]                   {
[17:40:55.365]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.365]                     NULL
[17:40:55.365]                   }
[17:40:55.365]                   options(future.plan = NULL)
[17:40:55.365]                   if (is.na(NA_character_)) 
[17:40:55.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.365]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.365]                     envir = parent.frame()) 
[17:40:55.365]                   {
[17:40:55.365]                     default_workers <- missing(workers)
[17:40:55.365]                     if (is.function(workers)) 
[17:40:55.365]                       workers <- workers()
[17:40:55.365]                     workers <- structure(as.integer(workers), 
[17:40:55.365]                       class = class(workers))
[17:40:55.365]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.365]                       1L)
[17:40:55.365]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.365]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.365]                       if (default_workers) 
[17:40:55.365]                         supportsMulticore(warn = TRUE)
[17:40:55.365]                       return(sequential(..., envir = envir))
[17:40:55.365]                     }
[17:40:55.365]                     oopts <- options(mc.cores = workers)
[17:40:55.365]                     on.exit(options(oopts))
[17:40:55.365]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.365]                       envir = envir)
[17:40:55.365]                     if (!future$lazy) 
[17:40:55.365]                       future <- run(future)
[17:40:55.365]                     invisible(future)
[17:40:55.365]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.365]                 }
[17:40:55.365]             }
[17:40:55.365]         }
[17:40:55.365]     })
[17:40:55.365]     if (TRUE) {
[17:40:55.365]         base::sink(type = "output", split = FALSE)
[17:40:55.365]         if (TRUE) {
[17:40:55.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.365]         }
[17:40:55.365]         else {
[17:40:55.365]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.365]         }
[17:40:55.365]         base::close(...future.stdout)
[17:40:55.365]         ...future.stdout <- NULL
[17:40:55.365]     }
[17:40:55.365]     ...future.result$conditions <- ...future.conditions
[17:40:55.365]     ...future.result$finished <- base::Sys.time()
[17:40:55.365]     ...future.result
[17:40:55.365] }
[17:40:55.368] assign_globals() ...
[17:40:55.368] List of 11
[17:40:55.368]  $ ...future.FUN            :function (x, ...)  
[17:40:55.368]  $ x_FUN                    :function (x)  
[17:40:55.368]  $ times                    : int 4
[17:40:55.368]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.368]  $ stop_if_not              :function (...)  
[17:40:55.368]  $ dim                      : int [1:2] 2 2
[17:40:55.368]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.368]  $ future.call.arguments    : list()
[17:40:55.368]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.368]  $ ...future.elements_ii    :List of 5
[17:40:55.368]   ..$ : int 6
[17:40:55.368]   ..$ : int 7
[17:40:55.368]   ..$ : int 8
[17:40:55.368]   ..$ : int 9
[17:40:55.368]   ..$ : int 10
[17:40:55.368]  $ ...future.seeds_ii       : NULL
[17:40:55.368]  $ ...future.globals.maxSize: NULL
[17:40:55.368]  - attr(*, "resolved")= logi FALSE
[17:40:55.368]  - attr(*, "total_size")= num 97304
[17:40:55.368]  - attr(*, "where")=List of 11
[17:40:55.368]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.368]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.368]  - attr(*, "already-done")= logi TRUE
[17:40:55.380] - copied ‘...future.FUN’ to environment
[17:40:55.380] - reassign environment for ‘x_FUN’
[17:40:55.380] - copied ‘x_FUN’ to environment
[17:40:55.380] - copied ‘times’ to environment
[17:40:55.380] - copied ‘stopf’ to environment
[17:40:55.381] - copied ‘stop_if_not’ to environment
[17:40:55.381] - copied ‘dim’ to environment
[17:40:55.381] - copied ‘valid_types’ to environment
[17:40:55.381] - copied ‘future.call.arguments’ to environment
[17:40:55.381] - copied ‘...future.elements_ii’ to environment
[17:40:55.381] - copied ‘...future.seeds_ii’ to environment
[17:40:55.381] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.381] assign_globals() ... done
[17:40:55.381] requestCore(): workers = 2
[17:40:55.384] MulticoreFuture started
[17:40:55.385] - Launch lazy future ... done
[17:40:55.385] run() for ‘MulticoreFuture’ ... done
[17:40:55.385] Created future:
[17:40:55.386] plan(): Setting new future strategy stack:
[17:40:55.386] List of future strategies:
[17:40:55.386] 1. sequential:
[17:40:55.386]    - args: function (..., envir = parent.frame())
[17:40:55.386]    - tweaked: FALSE
[17:40:55.386]    - call: NULL
[17:40:55.387] plan(): nbrOfWorkers() = 1
[17:40:55.389] plan(): Setting new future strategy stack:
[17:40:55.389] List of future strategies:
[17:40:55.389] 1. multicore:
[17:40:55.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.389]    - tweaked: FALSE
[17:40:55.389]    - call: plan(strategy)
[17:40:55.394] plan(): nbrOfWorkers() = 2
[17:40:55.385] MulticoreFuture:
[17:40:55.385] Label: ‘future_vapply-2’
[17:40:55.385] Expression:
[17:40:55.385] {
[17:40:55.385]     do.call(function(...) {
[17:40:55.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.385]             on.exit(options(oopts), add = TRUE)
[17:40:55.385]         }
[17:40:55.385]         {
[17:40:55.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.385]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.385]             })
[17:40:55.385]         }
[17:40:55.385]     }, args = future.call.arguments)
[17:40:55.385] }
[17:40:55.385] Lazy evaluation: FALSE
[17:40:55.385] Asynchronous evaluation: TRUE
[17:40:55.385] Local evaluation: TRUE
[17:40:55.385] Environment: R_GlobalEnv
[17:40:55.385] Capture standard output: TRUE
[17:40:55.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.385] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.385] Packages: 1 packages (‘future.apply’)
[17:40:55.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.385] Resolved: TRUE
[17:40:55.385] Value: <not collected>
[17:40:55.385] Conditions captured: <none>
[17:40:55.385] Early signaling: FALSE
[17:40:55.385] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.385] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.396] Chunk #2 of 2 ... DONE
[17:40:55.396] Launching 2 futures (chunks) ... DONE
[17:40:55.396] Resolving 2 futures (chunks) ...
[17:40:55.396] resolve() on list ...
[17:40:55.396]  recursive: 0
[17:40:55.396]  length: 2
[17:40:55.397] 
[17:40:55.397] Future #1
[17:40:55.398] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.398] - nx: 2
[17:40:55.398] - relay: TRUE
[17:40:55.398] - stdout: TRUE
[17:40:55.399] - signal: TRUE
[17:40:55.399] - resignal: FALSE
[17:40:55.402] - force: TRUE
[17:40:55.403] - relayed: [n=2] FALSE, FALSE
[17:40:55.403] - queued futures: [n=2] FALSE, FALSE
[17:40:55.404]  - until=1
[17:40:55.404]  - relaying element #1
[17:40:55.405] - relayed: [n=2] TRUE, FALSE
[17:40:55.405] - queued futures: [n=2] TRUE, FALSE
[17:40:55.405] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.406]  length: 1 (resolved future 1)
[17:40:55.406] Future #2
[17:40:55.408] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.408] - nx: 2
[17:40:55.408] - relay: TRUE
[17:40:55.408] - stdout: TRUE
[17:40:55.409] - signal: TRUE
[17:40:55.409] - resignal: FALSE
[17:40:55.409] - force: TRUE
[17:40:55.409] - relayed: [n=2] TRUE, FALSE
[17:40:55.410] - queued futures: [n=2] TRUE, FALSE
[17:40:55.410]  - until=2
[17:40:55.410]  - relaying element #2
[17:40:55.410] - relayed: [n=2] TRUE, TRUE
[17:40:55.411] - queued futures: [n=2] TRUE, TRUE
[17:40:55.411] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.411]  length: 0 (resolved future 2)
[17:40:55.411] Relaying remaining futures
[17:40:55.411] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.411] - nx: 2
[17:40:55.411] - relay: TRUE
[17:40:55.412] - stdout: TRUE
[17:40:55.412] - signal: TRUE
[17:40:55.412] - resignal: FALSE
[17:40:55.412] - force: TRUE
[17:40:55.412] - relayed: [n=2] TRUE, TRUE
[17:40:55.412] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.413] - relayed: [n=2] TRUE, TRUE
[17:40:55.413] - queued futures: [n=2] TRUE, TRUE
[17:40:55.413] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.413] resolve() on list ... DONE
[17:40:55.413]  - Number of value chunks collected: 2
[17:40:55.413] Resolving 2 futures (chunks) ... DONE
[17:40:55.413] Reducing values from 2 chunks ...
[17:40:55.414]  - Number of values collected after concatenation: 10
[17:40:55.414]  - Number of values expected: 10
[17:40:55.414] Reducing values from 2 chunks ... DONE
[17:40:55.414] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:40:55.417] future_lapply() ...
[17:40:55.423] Number of chunks: 2
[17:40:55.424] getGlobalsAndPackagesXApply() ...
[17:40:55.424]  - future.globals: TRUE
[17:40:55.424] getGlobalsAndPackages() ...
[17:40:55.424] Searching for globals...
[17:40:55.428] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:40:55.428] Searching for globals ... DONE
[17:40:55.429] Resolving globals: FALSE
[17:40:55.430] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:40:55.430] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:55.430] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.430] - packages: [1] ‘future.apply’
[17:40:55.431] getGlobalsAndPackages() ... DONE
[17:40:55.431]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.431]  - needed namespaces: [n=1] ‘future.apply’
[17:40:55.431] Finding globals ... DONE
[17:40:55.431]  - use_args: TRUE
[17:40:55.431]  - Getting '...' globals ...
[17:40:55.431] resolve() on list ...
[17:40:55.432]  recursive: 0
[17:40:55.432]  length: 1
[17:40:55.432]  elements: ‘...’
[17:40:55.432]  length: 0 (resolved future 1)
[17:40:55.432] resolve() on list ... DONE
[17:40:55.432]    - '...' content: [n=0] 
[17:40:55.432] List of 1
[17:40:55.432]  $ ...: list()
[17:40:55.432]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.432]  - attr(*, "where")=List of 1
[17:40:55.432]   ..$ ...:<environment: 0x564f2eb61ad8> 
[17:40:55.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.432]  - attr(*, "resolved")= logi TRUE
[17:40:55.432]  - attr(*, "total_size")= num NA
[17:40:55.438]  - Getting '...' globals ... DONE
[17:40:55.438] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:55.438] List of 8
[17:40:55.438]  $ ...future.FUN:function (x, ...)  
[17:40:55.438]  $ x_FUN        :function (x)  
[17:40:55.438]  $ times        : int 4
[17:40:55.438]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.438]  $ stop_if_not  :function (...)  
[17:40:55.438]  $ dim          : int [1:2] 2 2
[17:40:55.438]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:55.438]  $ ...          : list()
[17:40:55.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.438]  - attr(*, "where")=List of 8
[17:40:55.438]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:55.438]   ..$ ...          :<environment: 0x564f2eb61ad8> 
[17:40:55.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.438]  - attr(*, "resolved")= logi FALSE
[17:40:55.438]  - attr(*, "total_size")= num 105552
[17:40:55.444] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:55.444] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.444] Number of futures (= number of chunks): 2
[17:40:55.444] Launching 2 futures (chunks) ...
[17:40:55.445] Chunk #1 of 2 ...
[17:40:55.445]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.445] getGlobalsAndPackages() ...
[17:40:55.445] Searching for globals...
[17:40:55.445] 
[17:40:55.445] Searching for globals ... DONE
[17:40:55.445] - globals: [0] <none>
[17:40:55.445] getGlobalsAndPackages() ... DONE
[17:40:55.446]    + additional globals found: [n=0] 
[17:40:55.446]    + additional namespaces needed: [n=0] 
[17:40:55.446]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.446]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.446]  - seeds: <none>
[17:40:55.446] getGlobalsAndPackages() ...
[17:40:55.446] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.446] Resolving globals: FALSE
[17:40:55.446] Tweak future expression to call with '...' arguments ...
[17:40:55.447] {
[17:40:55.447]     do.call(function(...) {
[17:40:55.447]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.447]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.447]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.447]             on.exit(options(oopts), add = TRUE)
[17:40:55.447]         }
[17:40:55.447]         {
[17:40:55.447]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.447]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.447]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.447]             })
[17:40:55.447]         }
[17:40:55.447]     }, args = future.call.arguments)
[17:40:55.447] }
[17:40:55.447] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.447] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.448] - packages: [1] ‘future.apply’
[17:40:55.448] getGlobalsAndPackages() ... DONE
[17:40:55.448] run() for ‘Future’ ...
[17:40:55.448] - state: ‘created’
[17:40:55.448] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.453] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.453]   - Field: ‘label’
[17:40:55.453]   - Field: ‘local’
[17:40:55.453]   - Field: ‘owner’
[17:40:55.454]   - Field: ‘envir’
[17:40:55.454]   - Field: ‘workers’
[17:40:55.454]   - Field: ‘packages’
[17:40:55.454]   - Field: ‘gc’
[17:40:55.454]   - Field: ‘job’
[17:40:55.454]   - Field: ‘conditions’
[17:40:55.454]   - Field: ‘expr’
[17:40:55.454]   - Field: ‘uuid’
[17:40:55.454]   - Field: ‘seed’
[17:40:55.454]   - Field: ‘version’
[17:40:55.455]   - Field: ‘result’
[17:40:55.455]   - Field: ‘asynchronous’
[17:40:55.455]   - Field: ‘calls’
[17:40:55.455]   - Field: ‘globals’
[17:40:55.455]   - Field: ‘stdout’
[17:40:55.455]   - Field: ‘earlySignal’
[17:40:55.455]   - Field: ‘lazy’
[17:40:55.455]   - Field: ‘state’
[17:40:55.455] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.456] - Launch lazy future ...
[17:40:55.456] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.456] Packages needed by future strategies (n = 0): <none>
[17:40:55.457] {
[17:40:55.457]     {
[17:40:55.457]         {
[17:40:55.457]             ...future.startTime <- base::Sys.time()
[17:40:55.457]             {
[17:40:55.457]                 {
[17:40:55.457]                   {
[17:40:55.457]                     {
[17:40:55.457]                       {
[17:40:55.457]                         base::local({
[17:40:55.457]                           has_future <- base::requireNamespace("future", 
[17:40:55.457]                             quietly = TRUE)
[17:40:55.457]                           if (has_future) {
[17:40:55.457]                             ns <- base::getNamespace("future")
[17:40:55.457]                             version <- ns[[".package"]][["version"]]
[17:40:55.457]                             if (is.null(version)) 
[17:40:55.457]                               version <- utils::packageVersion("future")
[17:40:55.457]                           }
[17:40:55.457]                           else {
[17:40:55.457]                             version <- NULL
[17:40:55.457]                           }
[17:40:55.457]                           if (!has_future || version < "1.8.0") {
[17:40:55.457]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.457]                               "", base::R.version$version.string), 
[17:40:55.457]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.457]                                 base::R.version$platform, 8 * 
[17:40:55.457]                                   base::.Machine$sizeof.pointer), 
[17:40:55.457]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.457]                                 "release", "version")], collapse = " "), 
[17:40:55.457]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.457]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.457]                               info)
[17:40:55.457]                             info <- base::paste(info, collapse = "; ")
[17:40:55.457]                             if (!has_future) {
[17:40:55.457]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.457]                                 info)
[17:40:55.457]                             }
[17:40:55.457]                             else {
[17:40:55.457]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.457]                                 info, version)
[17:40:55.457]                             }
[17:40:55.457]                             base::stop(msg)
[17:40:55.457]                           }
[17:40:55.457]                         })
[17:40:55.457]                       }
[17:40:55.457]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.457]                       base::options(mc.cores = 1L)
[17:40:55.457]                     }
[17:40:55.457]                     base::local({
[17:40:55.457]                       for (pkg in "future.apply") {
[17:40:55.457]                         base::loadNamespace(pkg)
[17:40:55.457]                         base::library(pkg, character.only = TRUE)
[17:40:55.457]                       }
[17:40:55.457]                     })
[17:40:55.457]                   }
[17:40:55.457]                   options(future.plan = NULL)
[17:40:55.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.457]                 }
[17:40:55.457]                 ...future.workdir <- getwd()
[17:40:55.457]             }
[17:40:55.457]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.457]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.457]         }
[17:40:55.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.457]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.457]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.457]             base::names(...future.oldOptions))
[17:40:55.457]     }
[17:40:55.457]     if (FALSE) {
[17:40:55.457]     }
[17:40:55.457]     else {
[17:40:55.457]         if (TRUE) {
[17:40:55.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.457]                 open = "w")
[17:40:55.457]         }
[17:40:55.457]         else {
[17:40:55.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.457]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.457]         }
[17:40:55.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.457]             base::sink(type = "output", split = FALSE)
[17:40:55.457]             base::close(...future.stdout)
[17:40:55.457]         }, add = TRUE)
[17:40:55.457]     }
[17:40:55.457]     ...future.frame <- base::sys.nframe()
[17:40:55.457]     ...future.conditions <- base::list()
[17:40:55.457]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.457]     if (FALSE) {
[17:40:55.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.457]     }
[17:40:55.457]     ...future.result <- base::tryCatch({
[17:40:55.457]         base::withCallingHandlers({
[17:40:55.457]             ...future.value <- base::withVisible(base::local({
[17:40:55.457]                 withCallingHandlers({
[17:40:55.457]                   {
[17:40:55.457]                     do.call(function(...) {
[17:40:55.457]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.457]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.457]                         ...future.globals.maxSize)) {
[17:40:55.457]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.457]                         on.exit(options(oopts), add = TRUE)
[17:40:55.457]                       }
[17:40:55.457]                       {
[17:40:55.457]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.457]                           FUN = function(jj) {
[17:40:55.457]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.457]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.457]                           })
[17:40:55.457]                       }
[17:40:55.457]                     }, args = future.call.arguments)
[17:40:55.457]                   }
[17:40:55.457]                 }, immediateCondition = function(cond) {
[17:40:55.457]                   save_rds <- function (object, pathname, ...) 
[17:40:55.457]                   {
[17:40:55.457]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.457]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.457]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.457]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.457]                         fi_tmp[["mtime"]])
[17:40:55.457]                     }
[17:40:55.457]                     tryCatch({
[17:40:55.457]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.457]                     }, error = function(ex) {
[17:40:55.457]                       msg <- conditionMessage(ex)
[17:40:55.457]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.457]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.457]                         fi_tmp[["mtime"]], msg)
[17:40:55.457]                       ex$message <- msg
[17:40:55.457]                       stop(ex)
[17:40:55.457]                     })
[17:40:55.457]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.457]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.457]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.457]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.457]                       fi <- file.info(pathname)
[17:40:55.457]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.457]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.457]                         fi[["size"]], fi[["mtime"]])
[17:40:55.457]                       stop(msg)
[17:40:55.457]                     }
[17:40:55.457]                     invisible(pathname)
[17:40:55.457]                   }
[17:40:55.457]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.457]                     rootPath = tempdir()) 
[17:40:55.457]                   {
[17:40:55.457]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.457]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.457]                       tmpdir = path, fileext = ".rds")
[17:40:55.457]                     save_rds(obj, file)
[17:40:55.457]                   }
[17:40:55.457]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.457]                   {
[17:40:55.457]                     inherits <- base::inherits
[17:40:55.457]                     invokeRestart <- base::invokeRestart
[17:40:55.457]                     is.null <- base::is.null
[17:40:55.457]                     muffled <- FALSE
[17:40:55.457]                     if (inherits(cond, "message")) {
[17:40:55.457]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.457]                       if (muffled) 
[17:40:55.457]                         invokeRestart("muffleMessage")
[17:40:55.457]                     }
[17:40:55.457]                     else if (inherits(cond, "warning")) {
[17:40:55.457]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.457]                       if (muffled) 
[17:40:55.457]                         invokeRestart("muffleWarning")
[17:40:55.457]                     }
[17:40:55.457]                     else if (inherits(cond, "condition")) {
[17:40:55.457]                       if (!is.null(pattern)) {
[17:40:55.457]                         computeRestarts <- base::computeRestarts
[17:40:55.457]                         grepl <- base::grepl
[17:40:55.457]                         restarts <- computeRestarts(cond)
[17:40:55.457]                         for (restart in restarts) {
[17:40:55.457]                           name <- restart$name
[17:40:55.457]                           if (is.null(name)) 
[17:40:55.457]                             next
[17:40:55.457]                           if (!grepl(pattern, name)) 
[17:40:55.457]                             next
[17:40:55.457]                           invokeRestart(restart)
[17:40:55.457]                           muffled <- TRUE
[17:40:55.457]                           break
[17:40:55.457]                         }
[17:40:55.457]                       }
[17:40:55.457]                     }
[17:40:55.457]                     invisible(muffled)
[17:40:55.457]                   }
[17:40:55.457]                   muffleCondition(cond)
[17:40:55.457]                 })
[17:40:55.457]             }))
[17:40:55.457]             future::FutureResult(value = ...future.value$value, 
[17:40:55.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.457]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.457]                     ...future.globalenv.names))
[17:40:55.457]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.457]         }, condition = base::local({
[17:40:55.457]             c <- base::c
[17:40:55.457]             inherits <- base::inherits
[17:40:55.457]             invokeRestart <- base::invokeRestart
[17:40:55.457]             length <- base::length
[17:40:55.457]             list <- base::list
[17:40:55.457]             seq.int <- base::seq.int
[17:40:55.457]             signalCondition <- base::signalCondition
[17:40:55.457]             sys.calls <- base::sys.calls
[17:40:55.457]             `[[` <- base::`[[`
[17:40:55.457]             `+` <- base::`+`
[17:40:55.457]             `<<-` <- base::`<<-`
[17:40:55.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.457]                   3L)]
[17:40:55.457]             }
[17:40:55.457]             function(cond) {
[17:40:55.457]                 is_error <- inherits(cond, "error")
[17:40:55.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.457]                   NULL)
[17:40:55.457]                 if (is_error) {
[17:40:55.457]                   sessionInformation <- function() {
[17:40:55.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.457]                       search = base::search(), system = base::Sys.info())
[17:40:55.457]                   }
[17:40:55.457]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.457]                     cond$call), session = sessionInformation(), 
[17:40:55.457]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.457]                   signalCondition(cond)
[17:40:55.457]                 }
[17:40:55.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.457]                 "immediateCondition"))) {
[17:40:55.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.457]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.457]                   if (TRUE && !signal) {
[17:40:55.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.457]                     {
[17:40:55.457]                       inherits <- base::inherits
[17:40:55.457]                       invokeRestart <- base::invokeRestart
[17:40:55.457]                       is.null <- base::is.null
[17:40:55.457]                       muffled <- FALSE
[17:40:55.457]                       if (inherits(cond, "message")) {
[17:40:55.457]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.457]                         if (muffled) 
[17:40:55.457]                           invokeRestart("muffleMessage")
[17:40:55.457]                       }
[17:40:55.457]                       else if (inherits(cond, "warning")) {
[17:40:55.457]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.457]                         if (muffled) 
[17:40:55.457]                           invokeRestart("muffleWarning")
[17:40:55.457]                       }
[17:40:55.457]                       else if (inherits(cond, "condition")) {
[17:40:55.457]                         if (!is.null(pattern)) {
[17:40:55.457]                           computeRestarts <- base::computeRestarts
[17:40:55.457]                           grepl <- base::grepl
[17:40:55.457]                           restarts <- computeRestarts(cond)
[17:40:55.457]                           for (restart in restarts) {
[17:40:55.457]                             name <- restart$name
[17:40:55.457]                             if (is.null(name)) 
[17:40:55.457]                               next
[17:40:55.457]                             if (!grepl(pattern, name)) 
[17:40:55.457]                               next
[17:40:55.457]                             invokeRestart(restart)
[17:40:55.457]                             muffled <- TRUE
[17:40:55.457]                             break
[17:40:55.457]                           }
[17:40:55.457]                         }
[17:40:55.457]                       }
[17:40:55.457]                       invisible(muffled)
[17:40:55.457]                     }
[17:40:55.457]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.457]                   }
[17:40:55.457]                 }
[17:40:55.457]                 else {
[17:40:55.457]                   if (TRUE) {
[17:40:55.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.457]                     {
[17:40:55.457]                       inherits <- base::inherits
[17:40:55.457]                       invokeRestart <- base::invokeRestart
[17:40:55.457]                       is.null <- base::is.null
[17:40:55.457]                       muffled <- FALSE
[17:40:55.457]                       if (inherits(cond, "message")) {
[17:40:55.457]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.457]                         if (muffled) 
[17:40:55.457]                           invokeRestart("muffleMessage")
[17:40:55.457]                       }
[17:40:55.457]                       else if (inherits(cond, "warning")) {
[17:40:55.457]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.457]                         if (muffled) 
[17:40:55.457]                           invokeRestart("muffleWarning")
[17:40:55.457]                       }
[17:40:55.457]                       else if (inherits(cond, "condition")) {
[17:40:55.457]                         if (!is.null(pattern)) {
[17:40:55.457]                           computeRestarts <- base::computeRestarts
[17:40:55.457]                           grepl <- base::grepl
[17:40:55.457]                           restarts <- computeRestarts(cond)
[17:40:55.457]                           for (restart in restarts) {
[17:40:55.457]                             name <- restart$name
[17:40:55.457]                             if (is.null(name)) 
[17:40:55.457]                               next
[17:40:55.457]                             if (!grepl(pattern, name)) 
[17:40:55.457]                               next
[17:40:55.457]                             invokeRestart(restart)
[17:40:55.457]                             muffled <- TRUE
[17:40:55.457]                             break
[17:40:55.457]                           }
[17:40:55.457]                         }
[17:40:55.457]                       }
[17:40:55.457]                       invisible(muffled)
[17:40:55.457]                     }
[17:40:55.457]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.457]                   }
[17:40:55.457]                 }
[17:40:55.457]             }
[17:40:55.457]         }))
[17:40:55.457]     }, error = function(ex) {
[17:40:55.457]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.457]                 ...future.rng), started = ...future.startTime, 
[17:40:55.457]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.457]             version = "1.8"), class = "FutureResult")
[17:40:55.457]     }, finally = {
[17:40:55.457]         if (!identical(...future.workdir, getwd())) 
[17:40:55.457]             setwd(...future.workdir)
[17:40:55.457]         {
[17:40:55.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.457]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.457]             }
[17:40:55.457]             base::options(...future.oldOptions)
[17:40:55.457]             if (.Platform$OS.type == "windows") {
[17:40:55.457]                 old_names <- names(...future.oldEnvVars)
[17:40:55.457]                 envs <- base::Sys.getenv()
[17:40:55.457]                 names <- names(envs)
[17:40:55.457]                 common <- intersect(names, old_names)
[17:40:55.457]                 added <- setdiff(names, old_names)
[17:40:55.457]                 removed <- setdiff(old_names, names)
[17:40:55.457]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.457]                   envs[common]]
[17:40:55.457]                 NAMES <- toupper(changed)
[17:40:55.457]                 args <- list()
[17:40:55.457]                 for (kk in seq_along(NAMES)) {
[17:40:55.457]                   name <- changed[[kk]]
[17:40:55.457]                   NAME <- NAMES[[kk]]
[17:40:55.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.457]                     next
[17:40:55.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.457]                 }
[17:40:55.457]                 NAMES <- toupper(added)
[17:40:55.457]                 for (kk in seq_along(NAMES)) {
[17:40:55.457]                   name <- added[[kk]]
[17:40:55.457]                   NAME <- NAMES[[kk]]
[17:40:55.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.457]                     next
[17:40:55.457]                   args[[name]] <- ""
[17:40:55.457]                 }
[17:40:55.457]                 NAMES <- toupper(removed)
[17:40:55.457]                 for (kk in seq_along(NAMES)) {
[17:40:55.457]                   name <- removed[[kk]]
[17:40:55.457]                   NAME <- NAMES[[kk]]
[17:40:55.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.457]                     next
[17:40:55.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.457]                 }
[17:40:55.457]                 if (length(args) > 0) 
[17:40:55.457]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.457]             }
[17:40:55.457]             else {
[17:40:55.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.457]             }
[17:40:55.457]             {
[17:40:55.457]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.457]                   0L) {
[17:40:55.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.457]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.457]                   base::options(opts)
[17:40:55.457]                 }
[17:40:55.457]                 {
[17:40:55.457]                   {
[17:40:55.457]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.457]                     NULL
[17:40:55.457]                   }
[17:40:55.457]                   options(future.plan = NULL)
[17:40:55.457]                   if (is.na(NA_character_)) 
[17:40:55.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.457]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.457]                     envir = parent.frame()) 
[17:40:55.457]                   {
[17:40:55.457]                     default_workers <- missing(workers)
[17:40:55.457]                     if (is.function(workers)) 
[17:40:55.457]                       workers <- workers()
[17:40:55.457]                     workers <- structure(as.integer(workers), 
[17:40:55.457]                       class = class(workers))
[17:40:55.457]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.457]                       1L)
[17:40:55.457]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.457]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.457]                       if (default_workers) 
[17:40:55.457]                         supportsMulticore(warn = TRUE)
[17:40:55.457]                       return(sequential(..., envir = envir))
[17:40:55.457]                     }
[17:40:55.457]                     oopts <- options(mc.cores = workers)
[17:40:55.457]                     on.exit(options(oopts))
[17:40:55.457]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.457]                       envir = envir)
[17:40:55.457]                     if (!future$lazy) 
[17:40:55.457]                       future <- run(future)
[17:40:55.457]                     invisible(future)
[17:40:55.457]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.457]                 }
[17:40:55.457]             }
[17:40:55.457]         }
[17:40:55.457]     })
[17:40:55.457]     if (TRUE) {
[17:40:55.457]         base::sink(type = "output", split = FALSE)
[17:40:55.457]         if (TRUE) {
[17:40:55.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.457]         }
[17:40:55.457]         else {
[17:40:55.457]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.457]         }
[17:40:55.457]         base::close(...future.stdout)
[17:40:55.457]         ...future.stdout <- NULL
[17:40:55.457]     }
[17:40:55.457]     ...future.result$conditions <- ...future.conditions
[17:40:55.457]     ...future.result$finished <- base::Sys.time()
[17:40:55.457]     ...future.result
[17:40:55.457] }
[17:40:55.459] assign_globals() ...
[17:40:55.459] List of 11
[17:40:55.459]  $ ...future.FUN            :function (x, ...)  
[17:40:55.459]  $ x_FUN                    :function (x)  
[17:40:55.459]  $ times                    : int 4
[17:40:55.459]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.459]  $ stop_if_not              :function (...)  
[17:40:55.459]  $ dim                      : int [1:2] 2 2
[17:40:55.459]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.459]  $ future.call.arguments    : list()
[17:40:55.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.459]  $ ...future.elements_ii    :List of 5
[17:40:55.459]   ..$ : int 1
[17:40:55.459]   ..$ : int 2
[17:40:55.459]   ..$ : int 3
[17:40:55.459]   ..$ : int 4
[17:40:55.459]   ..$ : int 5
[17:40:55.459]  $ ...future.seeds_ii       : NULL
[17:40:55.459]  $ ...future.globals.maxSize: NULL
[17:40:55.459]  - attr(*, "resolved")= logi FALSE
[17:40:55.459]  - attr(*, "total_size")= num 105552
[17:40:55.459]  - attr(*, "where")=List of 11
[17:40:55.459]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.459]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.459]  - attr(*, "already-done")= logi TRUE
[17:40:55.473] - copied ‘...future.FUN’ to environment
[17:40:55.473] - reassign environment for ‘x_FUN’
[17:40:55.473] - copied ‘x_FUN’ to environment
[17:40:55.473] - copied ‘times’ to environment
[17:40:55.473] - copied ‘stopf’ to environment
[17:40:55.473] - copied ‘stop_if_not’ to environment
[17:40:55.473] - copied ‘dim’ to environment
[17:40:55.474] - copied ‘valid_types’ to environment
[17:40:55.474] - copied ‘future.call.arguments’ to environment
[17:40:55.474] - copied ‘...future.elements_ii’ to environment
[17:40:55.474] - copied ‘...future.seeds_ii’ to environment
[17:40:55.474] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.474] assign_globals() ... done
[17:40:55.474] requestCore(): workers = 2
[17:40:55.477] MulticoreFuture started
[17:40:55.477] - Launch lazy future ... done
[17:40:55.477] run() for ‘MulticoreFuture’ ... done
[17:40:55.477] Created future:
[17:40:55.478] plan(): Setting new future strategy stack:
[17:40:55.478] List of future strategies:
[17:40:55.478] 1. sequential:
[17:40:55.478]    - args: function (..., envir = parent.frame())
[17:40:55.478]    - tweaked: FALSE
[17:40:55.478]    - call: NULL
[17:40:55.479] plan(): nbrOfWorkers() = 1
[17:40:55.481] plan(): Setting new future strategy stack:
[17:40:55.482] List of future strategies:
[17:40:55.482] 1. multicore:
[17:40:55.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.482]    - tweaked: FALSE
[17:40:55.482]    - call: plan(strategy)
[17:40:55.487] plan(): nbrOfWorkers() = 2
[17:40:55.478] MulticoreFuture:
[17:40:55.478] Label: ‘future_vapply-1’
[17:40:55.478] Expression:
[17:40:55.478] {
[17:40:55.478]     do.call(function(...) {
[17:40:55.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.478]             on.exit(options(oopts), add = TRUE)
[17:40:55.478]         }
[17:40:55.478]         {
[17:40:55.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.478]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.478]             })
[17:40:55.478]         }
[17:40:55.478]     }, args = future.call.arguments)
[17:40:55.478] }
[17:40:55.478] Lazy evaluation: FALSE
[17:40:55.478] Asynchronous evaluation: TRUE
[17:40:55.478] Local evaluation: TRUE
[17:40:55.478] Environment: R_GlobalEnv
[17:40:55.478] Capture standard output: TRUE
[17:40:55.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.478] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.478] Packages: 1 packages (‘future.apply’)
[17:40:55.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.478] Resolved: TRUE
[17:40:55.478] Value: <not collected>
[17:40:55.478] Conditions captured: <none>
[17:40:55.478] Early signaling: FALSE
[17:40:55.478] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.478] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.489] Chunk #1 of 2 ... DONE
[17:40:55.489] Chunk #2 of 2 ...
[17:40:55.489]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.489] getGlobalsAndPackages() ...
[17:40:55.489] Searching for globals...
[17:40:55.490] 
[17:40:55.490] Searching for globals ... DONE
[17:40:55.490] - globals: [0] <none>
[17:40:55.490] getGlobalsAndPackages() ... DONE
[17:40:55.490]    + additional globals found: [n=0] 
[17:40:55.490]    + additional namespaces needed: [n=0] 
[17:40:55.490]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:55.491]  - seeds: <none>
[17:40:55.491] getGlobalsAndPackages() ...
[17:40:55.491] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.491] Resolving globals: FALSE
[17:40:55.492] Tweak future expression to call with '...' arguments ...
[17:40:55.492] {
[17:40:55.492]     do.call(function(...) {
[17:40:55.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.492]             on.exit(options(oopts), add = TRUE)
[17:40:55.492]         }
[17:40:55.492]         {
[17:40:55.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.492]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.492]             })
[17:40:55.492]         }
[17:40:55.492]     }, args = future.call.arguments)
[17:40:55.492] }
[17:40:55.492] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.493] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.493] - packages: [1] ‘future.apply’
[17:40:55.494] getGlobalsAndPackages() ... DONE
[17:40:55.494] run() for ‘Future’ ...
[17:40:55.494] - state: ‘created’
[17:40:55.495] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.500]   - Field: ‘label’
[17:40:55.500]   - Field: ‘local’
[17:40:55.500]   - Field: ‘owner’
[17:40:55.501]   - Field: ‘envir’
[17:40:55.501]   - Field: ‘workers’
[17:40:55.501]   - Field: ‘packages’
[17:40:55.501]   - Field: ‘gc’
[17:40:55.501]   - Field: ‘job’
[17:40:55.501]   - Field: ‘conditions’
[17:40:55.501]   - Field: ‘expr’
[17:40:55.502]   - Field: ‘uuid’
[17:40:55.502]   - Field: ‘seed’
[17:40:55.502]   - Field: ‘version’
[17:40:55.502]   - Field: ‘result’
[17:40:55.502]   - Field: ‘asynchronous’
[17:40:55.502]   - Field: ‘calls’
[17:40:55.502]   - Field: ‘globals’
[17:40:55.503]   - Field: ‘stdout’
[17:40:55.503]   - Field: ‘earlySignal’
[17:40:55.503]   - Field: ‘lazy’
[17:40:55.503]   - Field: ‘state’
[17:40:55.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.506] - Launch lazy future ...
[17:40:55.507] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:55.507] Packages needed by future strategies (n = 0): <none>
[17:40:55.509] {
[17:40:55.509]     {
[17:40:55.509]         {
[17:40:55.509]             ...future.startTime <- base::Sys.time()
[17:40:55.509]             {
[17:40:55.509]                 {
[17:40:55.509]                   {
[17:40:55.509]                     {
[17:40:55.509]                       {
[17:40:55.509]                         base::local({
[17:40:55.509]                           has_future <- base::requireNamespace("future", 
[17:40:55.509]                             quietly = TRUE)
[17:40:55.509]                           if (has_future) {
[17:40:55.509]                             ns <- base::getNamespace("future")
[17:40:55.509]                             version <- ns[[".package"]][["version"]]
[17:40:55.509]                             if (is.null(version)) 
[17:40:55.509]                               version <- utils::packageVersion("future")
[17:40:55.509]                           }
[17:40:55.509]                           else {
[17:40:55.509]                             version <- NULL
[17:40:55.509]                           }
[17:40:55.509]                           if (!has_future || version < "1.8.0") {
[17:40:55.509]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.509]                               "", base::R.version$version.string), 
[17:40:55.509]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.509]                                 base::R.version$platform, 8 * 
[17:40:55.509]                                   base::.Machine$sizeof.pointer), 
[17:40:55.509]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.509]                                 "release", "version")], collapse = " "), 
[17:40:55.509]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.509]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.509]                               info)
[17:40:55.509]                             info <- base::paste(info, collapse = "; ")
[17:40:55.509]                             if (!has_future) {
[17:40:55.509]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.509]                                 info)
[17:40:55.509]                             }
[17:40:55.509]                             else {
[17:40:55.509]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.509]                                 info, version)
[17:40:55.509]                             }
[17:40:55.509]                             base::stop(msg)
[17:40:55.509]                           }
[17:40:55.509]                         })
[17:40:55.509]                       }
[17:40:55.509]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.509]                       base::options(mc.cores = 1L)
[17:40:55.509]                     }
[17:40:55.509]                     base::local({
[17:40:55.509]                       for (pkg in "future.apply") {
[17:40:55.509]                         base::loadNamespace(pkg)
[17:40:55.509]                         base::library(pkg, character.only = TRUE)
[17:40:55.509]                       }
[17:40:55.509]                     })
[17:40:55.509]                   }
[17:40:55.509]                   options(future.plan = NULL)
[17:40:55.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.509]                 }
[17:40:55.509]                 ...future.workdir <- getwd()
[17:40:55.509]             }
[17:40:55.509]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.509]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.509]         }
[17:40:55.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.509]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:55.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.509]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.509]             base::names(...future.oldOptions))
[17:40:55.509]     }
[17:40:55.509]     if (FALSE) {
[17:40:55.509]     }
[17:40:55.509]     else {
[17:40:55.509]         if (TRUE) {
[17:40:55.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.509]                 open = "w")
[17:40:55.509]         }
[17:40:55.509]         else {
[17:40:55.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.509]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.509]         }
[17:40:55.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.509]             base::sink(type = "output", split = FALSE)
[17:40:55.509]             base::close(...future.stdout)
[17:40:55.509]         }, add = TRUE)
[17:40:55.509]     }
[17:40:55.509]     ...future.frame <- base::sys.nframe()
[17:40:55.509]     ...future.conditions <- base::list()
[17:40:55.509]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.509]     if (FALSE) {
[17:40:55.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.509]     }
[17:40:55.509]     ...future.result <- base::tryCatch({
[17:40:55.509]         base::withCallingHandlers({
[17:40:55.509]             ...future.value <- base::withVisible(base::local({
[17:40:55.509]                 withCallingHandlers({
[17:40:55.509]                   {
[17:40:55.509]                     do.call(function(...) {
[17:40:55.509]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.509]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.509]                         ...future.globals.maxSize)) {
[17:40:55.509]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.509]                         on.exit(options(oopts), add = TRUE)
[17:40:55.509]                       }
[17:40:55.509]                       {
[17:40:55.509]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.509]                           FUN = function(jj) {
[17:40:55.509]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.509]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.509]                           })
[17:40:55.509]                       }
[17:40:55.509]                     }, args = future.call.arguments)
[17:40:55.509]                   }
[17:40:55.509]                 }, immediateCondition = function(cond) {
[17:40:55.509]                   save_rds <- function (object, pathname, ...) 
[17:40:55.509]                   {
[17:40:55.509]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.509]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.509]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.509]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.509]                         fi_tmp[["mtime"]])
[17:40:55.509]                     }
[17:40:55.509]                     tryCatch({
[17:40:55.509]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.509]                     }, error = function(ex) {
[17:40:55.509]                       msg <- conditionMessage(ex)
[17:40:55.509]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.509]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.509]                         fi_tmp[["mtime"]], msg)
[17:40:55.509]                       ex$message <- msg
[17:40:55.509]                       stop(ex)
[17:40:55.509]                     })
[17:40:55.509]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.509]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.509]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.509]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.509]                       fi <- file.info(pathname)
[17:40:55.509]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.509]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.509]                         fi[["size"]], fi[["mtime"]])
[17:40:55.509]                       stop(msg)
[17:40:55.509]                     }
[17:40:55.509]                     invisible(pathname)
[17:40:55.509]                   }
[17:40:55.509]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.509]                     rootPath = tempdir()) 
[17:40:55.509]                   {
[17:40:55.509]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.509]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.509]                       tmpdir = path, fileext = ".rds")
[17:40:55.509]                     save_rds(obj, file)
[17:40:55.509]                   }
[17:40:55.509]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.509]                   {
[17:40:55.509]                     inherits <- base::inherits
[17:40:55.509]                     invokeRestart <- base::invokeRestart
[17:40:55.509]                     is.null <- base::is.null
[17:40:55.509]                     muffled <- FALSE
[17:40:55.509]                     if (inherits(cond, "message")) {
[17:40:55.509]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.509]                       if (muffled) 
[17:40:55.509]                         invokeRestart("muffleMessage")
[17:40:55.509]                     }
[17:40:55.509]                     else if (inherits(cond, "warning")) {
[17:40:55.509]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.509]                       if (muffled) 
[17:40:55.509]                         invokeRestart("muffleWarning")
[17:40:55.509]                     }
[17:40:55.509]                     else if (inherits(cond, "condition")) {
[17:40:55.509]                       if (!is.null(pattern)) {
[17:40:55.509]                         computeRestarts <- base::computeRestarts
[17:40:55.509]                         grepl <- base::grepl
[17:40:55.509]                         restarts <- computeRestarts(cond)
[17:40:55.509]                         for (restart in restarts) {
[17:40:55.509]                           name <- restart$name
[17:40:55.509]                           if (is.null(name)) 
[17:40:55.509]                             next
[17:40:55.509]                           if (!grepl(pattern, name)) 
[17:40:55.509]                             next
[17:40:55.509]                           invokeRestart(restart)
[17:40:55.509]                           muffled <- TRUE
[17:40:55.509]                           break
[17:40:55.509]                         }
[17:40:55.509]                       }
[17:40:55.509]                     }
[17:40:55.509]                     invisible(muffled)
[17:40:55.509]                   }
[17:40:55.509]                   muffleCondition(cond)
[17:40:55.509]                 })
[17:40:55.509]             }))
[17:40:55.509]             future::FutureResult(value = ...future.value$value, 
[17:40:55.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.509]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.509]                     ...future.globalenv.names))
[17:40:55.509]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.509]         }, condition = base::local({
[17:40:55.509]             c <- base::c
[17:40:55.509]             inherits <- base::inherits
[17:40:55.509]             invokeRestart <- base::invokeRestart
[17:40:55.509]             length <- base::length
[17:40:55.509]             list <- base::list
[17:40:55.509]             seq.int <- base::seq.int
[17:40:55.509]             signalCondition <- base::signalCondition
[17:40:55.509]             sys.calls <- base::sys.calls
[17:40:55.509]             `[[` <- base::`[[`
[17:40:55.509]             `+` <- base::`+`
[17:40:55.509]             `<<-` <- base::`<<-`
[17:40:55.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.509]                   3L)]
[17:40:55.509]             }
[17:40:55.509]             function(cond) {
[17:40:55.509]                 is_error <- inherits(cond, "error")
[17:40:55.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.509]                   NULL)
[17:40:55.509]                 if (is_error) {
[17:40:55.509]                   sessionInformation <- function() {
[17:40:55.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.509]                       search = base::search(), system = base::Sys.info())
[17:40:55.509]                   }
[17:40:55.509]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.509]                     cond$call), session = sessionInformation(), 
[17:40:55.509]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.509]                   signalCondition(cond)
[17:40:55.509]                 }
[17:40:55.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.509]                 "immediateCondition"))) {
[17:40:55.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.509]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.509]                   if (TRUE && !signal) {
[17:40:55.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.509]                     {
[17:40:55.509]                       inherits <- base::inherits
[17:40:55.509]                       invokeRestart <- base::invokeRestart
[17:40:55.509]                       is.null <- base::is.null
[17:40:55.509]                       muffled <- FALSE
[17:40:55.509]                       if (inherits(cond, "message")) {
[17:40:55.509]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.509]                         if (muffled) 
[17:40:55.509]                           invokeRestart("muffleMessage")
[17:40:55.509]                       }
[17:40:55.509]                       else if (inherits(cond, "warning")) {
[17:40:55.509]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.509]                         if (muffled) 
[17:40:55.509]                           invokeRestart("muffleWarning")
[17:40:55.509]                       }
[17:40:55.509]                       else if (inherits(cond, "condition")) {
[17:40:55.509]                         if (!is.null(pattern)) {
[17:40:55.509]                           computeRestarts <- base::computeRestarts
[17:40:55.509]                           grepl <- base::grepl
[17:40:55.509]                           restarts <- computeRestarts(cond)
[17:40:55.509]                           for (restart in restarts) {
[17:40:55.509]                             name <- restart$name
[17:40:55.509]                             if (is.null(name)) 
[17:40:55.509]                               next
[17:40:55.509]                             if (!grepl(pattern, name)) 
[17:40:55.509]                               next
[17:40:55.509]                             invokeRestart(restart)
[17:40:55.509]                             muffled <- TRUE
[17:40:55.509]                             break
[17:40:55.509]                           }
[17:40:55.509]                         }
[17:40:55.509]                       }
[17:40:55.509]                       invisible(muffled)
[17:40:55.509]                     }
[17:40:55.509]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.509]                   }
[17:40:55.509]                 }
[17:40:55.509]                 else {
[17:40:55.509]                   if (TRUE) {
[17:40:55.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.509]                     {
[17:40:55.509]                       inherits <- base::inherits
[17:40:55.509]                       invokeRestart <- base::invokeRestart
[17:40:55.509]                       is.null <- base::is.null
[17:40:55.509]                       muffled <- FALSE
[17:40:55.509]                       if (inherits(cond, "message")) {
[17:40:55.509]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.509]                         if (muffled) 
[17:40:55.509]                           invokeRestart("muffleMessage")
[17:40:55.509]                       }
[17:40:55.509]                       else if (inherits(cond, "warning")) {
[17:40:55.509]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.509]                         if (muffled) 
[17:40:55.509]                           invokeRestart("muffleWarning")
[17:40:55.509]                       }
[17:40:55.509]                       else if (inherits(cond, "condition")) {
[17:40:55.509]                         if (!is.null(pattern)) {
[17:40:55.509]                           computeRestarts <- base::computeRestarts
[17:40:55.509]                           grepl <- base::grepl
[17:40:55.509]                           restarts <- computeRestarts(cond)
[17:40:55.509]                           for (restart in restarts) {
[17:40:55.509]                             name <- restart$name
[17:40:55.509]                             if (is.null(name)) 
[17:40:55.509]                               next
[17:40:55.509]                             if (!grepl(pattern, name)) 
[17:40:55.509]                               next
[17:40:55.509]                             invokeRestart(restart)
[17:40:55.509]                             muffled <- TRUE
[17:40:55.509]                             break
[17:40:55.509]                           }
[17:40:55.509]                         }
[17:40:55.509]                       }
[17:40:55.509]                       invisible(muffled)
[17:40:55.509]                     }
[17:40:55.509]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.509]                   }
[17:40:55.509]                 }
[17:40:55.509]             }
[17:40:55.509]         }))
[17:40:55.509]     }, error = function(ex) {
[17:40:55.509]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.509]                 ...future.rng), started = ...future.startTime, 
[17:40:55.509]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.509]             version = "1.8"), class = "FutureResult")
[17:40:55.509]     }, finally = {
[17:40:55.509]         if (!identical(...future.workdir, getwd())) 
[17:40:55.509]             setwd(...future.workdir)
[17:40:55.509]         {
[17:40:55.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.509]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.509]             }
[17:40:55.509]             base::options(...future.oldOptions)
[17:40:55.509]             if (.Platform$OS.type == "windows") {
[17:40:55.509]                 old_names <- names(...future.oldEnvVars)
[17:40:55.509]                 envs <- base::Sys.getenv()
[17:40:55.509]                 names <- names(envs)
[17:40:55.509]                 common <- intersect(names, old_names)
[17:40:55.509]                 added <- setdiff(names, old_names)
[17:40:55.509]                 removed <- setdiff(old_names, names)
[17:40:55.509]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.509]                   envs[common]]
[17:40:55.509]                 NAMES <- toupper(changed)
[17:40:55.509]                 args <- list()
[17:40:55.509]                 for (kk in seq_along(NAMES)) {
[17:40:55.509]                   name <- changed[[kk]]
[17:40:55.509]                   NAME <- NAMES[[kk]]
[17:40:55.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.509]                     next
[17:40:55.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.509]                 }
[17:40:55.509]                 NAMES <- toupper(added)
[17:40:55.509]                 for (kk in seq_along(NAMES)) {
[17:40:55.509]                   name <- added[[kk]]
[17:40:55.509]                   NAME <- NAMES[[kk]]
[17:40:55.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.509]                     next
[17:40:55.509]                   args[[name]] <- ""
[17:40:55.509]                 }
[17:40:55.509]                 NAMES <- toupper(removed)
[17:40:55.509]                 for (kk in seq_along(NAMES)) {
[17:40:55.509]                   name <- removed[[kk]]
[17:40:55.509]                   NAME <- NAMES[[kk]]
[17:40:55.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.509]                     next
[17:40:55.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.509]                 }
[17:40:55.509]                 if (length(args) > 0) 
[17:40:55.509]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.509]             }
[17:40:55.509]             else {
[17:40:55.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.509]             }
[17:40:55.509]             {
[17:40:55.509]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.509]                   0L) {
[17:40:55.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.509]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.509]                   base::options(opts)
[17:40:55.509]                 }
[17:40:55.509]                 {
[17:40:55.509]                   {
[17:40:55.509]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.509]                     NULL
[17:40:55.509]                   }
[17:40:55.509]                   options(future.plan = NULL)
[17:40:55.509]                   if (is.na(NA_character_)) 
[17:40:55.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.509]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.509]                     envir = parent.frame()) 
[17:40:55.509]                   {
[17:40:55.509]                     default_workers <- missing(workers)
[17:40:55.509]                     if (is.function(workers)) 
[17:40:55.509]                       workers <- workers()
[17:40:55.509]                     workers <- structure(as.integer(workers), 
[17:40:55.509]                       class = class(workers))
[17:40:55.509]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.509]                       1L)
[17:40:55.509]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.509]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.509]                       if (default_workers) 
[17:40:55.509]                         supportsMulticore(warn = TRUE)
[17:40:55.509]                       return(sequential(..., envir = envir))
[17:40:55.509]                     }
[17:40:55.509]                     oopts <- options(mc.cores = workers)
[17:40:55.509]                     on.exit(options(oopts))
[17:40:55.509]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.509]                       envir = envir)
[17:40:55.509]                     if (!future$lazy) 
[17:40:55.509]                       future <- run(future)
[17:40:55.509]                     invisible(future)
[17:40:55.509]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.509]                 }
[17:40:55.509]             }
[17:40:55.509]         }
[17:40:55.509]     })
[17:40:55.509]     if (TRUE) {
[17:40:55.509]         base::sink(type = "output", split = FALSE)
[17:40:55.509]         if (TRUE) {
[17:40:55.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.509]         }
[17:40:55.509]         else {
[17:40:55.509]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.509]         }
[17:40:55.509]         base::close(...future.stdout)
[17:40:55.509]         ...future.stdout <- NULL
[17:40:55.509]     }
[17:40:55.509]     ...future.result$conditions <- ...future.conditions
[17:40:55.509]     ...future.result$finished <- base::Sys.time()
[17:40:55.509]     ...future.result
[17:40:55.509] }
[17:40:55.513] assign_globals() ...
[17:40:55.513] List of 11
[17:40:55.513]  $ ...future.FUN            :function (x, ...)  
[17:40:55.513]  $ x_FUN                    :function (x)  
[17:40:55.513]  $ times                    : int 4
[17:40:55.513]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.513]  $ stop_if_not              :function (...)  
[17:40:55.513]  $ dim                      : int [1:2] 2 2
[17:40:55.513]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.513]  $ future.call.arguments    : list()
[17:40:55.513]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.513]  $ ...future.elements_ii    :List of 5
[17:40:55.513]   ..$ : int 6
[17:40:55.513]   ..$ : int 7
[17:40:55.513]   ..$ : int 8
[17:40:55.513]   ..$ : int 9
[17:40:55.513]   ..$ : int 10
[17:40:55.513]  $ ...future.seeds_ii       : NULL
[17:40:55.513]  $ ...future.globals.maxSize: NULL
[17:40:55.513]  - attr(*, "resolved")= logi FALSE
[17:40:55.513]  - attr(*, "total_size")= num 105552
[17:40:55.513]  - attr(*, "where")=List of 11
[17:40:55.513]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.513]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.513]  - attr(*, "already-done")= logi TRUE
[17:40:55.528] - copied ‘...future.FUN’ to environment
[17:40:55.528] - reassign environment for ‘x_FUN’
[17:40:55.528] - copied ‘x_FUN’ to environment
[17:40:55.528] - copied ‘times’ to environment
[17:40:55.528] - copied ‘stopf’ to environment
[17:40:55.529] - copied ‘stop_if_not’ to environment
[17:40:55.529] - copied ‘dim’ to environment
[17:40:55.529] - copied ‘valid_types’ to environment
[17:40:55.529] - copied ‘future.call.arguments’ to environment
[17:40:55.529] - copied ‘...future.elements_ii’ to environment
[17:40:55.529] - copied ‘...future.seeds_ii’ to environment
[17:40:55.529] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.529] assign_globals() ... done
[17:40:55.529] requestCore(): workers = 2
[17:40:55.532] MulticoreFuture started
[17:40:55.532] - Launch lazy future ... done
[17:40:55.533] run() for ‘MulticoreFuture’ ... done
[17:40:55.533] Created future:
[17:40:55.533] plan(): Setting new future strategy stack:
[17:40:55.534] List of future strategies:
[17:40:55.534] 1. sequential:
[17:40:55.534]    - args: function (..., envir = parent.frame())
[17:40:55.534]    - tweaked: FALSE
[17:40:55.534]    - call: NULL
[17:40:55.534] plan(): nbrOfWorkers() = 1
[17:40:55.537] plan(): Setting new future strategy stack:
[17:40:55.537] List of future strategies:
[17:40:55.537] 1. multicore:
[17:40:55.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.537]    - tweaked: FALSE
[17:40:55.537]    - call: plan(strategy)
[17:40:55.542] plan(): nbrOfWorkers() = 2
[17:40:55.533] MulticoreFuture:
[17:40:55.533] Label: ‘future_vapply-2’
[17:40:55.533] Expression:
[17:40:55.533] {
[17:40:55.533]     do.call(function(...) {
[17:40:55.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.533]             on.exit(options(oopts), add = TRUE)
[17:40:55.533]         }
[17:40:55.533]         {
[17:40:55.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.533]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.533]             })
[17:40:55.533]         }
[17:40:55.533]     }, args = future.call.arguments)
[17:40:55.533] }
[17:40:55.533] Lazy evaluation: FALSE
[17:40:55.533] Asynchronous evaluation: TRUE
[17:40:55.533] Local evaluation: TRUE
[17:40:55.533] Environment: R_GlobalEnv
[17:40:55.533] Capture standard output: TRUE
[17:40:55.533] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.533] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.533] Packages: 1 packages (‘future.apply’)
[17:40:55.533] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.533] Resolved: TRUE
[17:40:55.533] Value: <not collected>
[17:40:55.533] Conditions captured: <none>
[17:40:55.533] Early signaling: FALSE
[17:40:55.533] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.533] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.543] Chunk #2 of 2 ... DONE
[17:40:55.543] Launching 2 futures (chunks) ... DONE
[17:40:55.544] Resolving 2 futures (chunks) ...
[17:40:55.544] resolve() on list ...
[17:40:55.544]  recursive: 0
[17:40:55.544]  length: 2
[17:40:55.544] 
[17:40:55.545] Future #1
[17:40:55.546] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.546] - nx: 2
[17:40:55.546] - relay: TRUE
[17:40:55.546] - stdout: TRUE
[17:40:55.546] - signal: TRUE
[17:40:55.546] - resignal: FALSE
[17:40:55.546] - force: TRUE
[17:40:55.547] - relayed: [n=2] FALSE, FALSE
[17:40:55.547] - queued futures: [n=2] FALSE, FALSE
[17:40:55.547]  - until=1
[17:40:55.547]  - relaying element #1
[17:40:55.547] - relayed: [n=2] TRUE, FALSE
[17:40:55.548] - queued futures: [n=2] TRUE, FALSE
[17:40:55.548] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.548]  length: 1 (resolved future 1)
[17:40:55.548] Future #2
[17:40:55.549] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.549] - nx: 2
[17:40:55.549] - relay: TRUE
[17:40:55.550] - stdout: TRUE
[17:40:55.550] - signal: TRUE
[17:40:55.550] - resignal: FALSE
[17:40:55.550] - force: TRUE
[17:40:55.550] - relayed: [n=2] TRUE, FALSE
[17:40:55.550] - queued futures: [n=2] TRUE, FALSE
[17:40:55.550]  - until=2
[17:40:55.554]  - relaying element #2
[17:40:55.555] - relayed: [n=2] TRUE, TRUE
[17:40:55.555] - queued futures: [n=2] TRUE, TRUE
[17:40:55.555] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.555]  length: 0 (resolved future 2)
[17:40:55.556] Relaying remaining futures
[17:40:55.556] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.556] - nx: 2
[17:40:55.556] - relay: TRUE
[17:40:55.556] - stdout: TRUE
[17:40:55.556] - signal: TRUE
[17:40:55.557] - resignal: FALSE
[17:40:55.557] - force: TRUE
[17:40:55.557] - relayed: [n=2] TRUE, TRUE
[17:40:55.557] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.557] - relayed: [n=2] TRUE, TRUE
[17:40:55.557] - queued futures: [n=2] TRUE, TRUE
[17:40:55.558] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.558] resolve() on list ... DONE
[17:40:55.558]  - Number of value chunks collected: 2
[17:40:55.558] Resolving 2 futures (chunks) ... DONE
[17:40:55.558] Reducing values from 2 chunks ...
[17:40:55.559]  - Number of values collected after concatenation: 10
[17:40:55.559]  - Number of values expected: 10
[17:40:55.559] Reducing values from 2 chunks ... DONE
[17:40:55.559] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:40:55.563] future_lapply() ...
[17:40:55.570] Number of chunks: 2
[17:40:55.570] getGlobalsAndPackagesXApply() ...
[17:40:55.570]  - future.globals: TRUE
[17:40:55.570] getGlobalsAndPackages() ...
[17:40:55.570] Searching for globals...
[17:40:55.574] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:40:55.575] Searching for globals ... DONE
[17:40:55.575] Resolving globals: FALSE
[17:40:55.576] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:40:55.576] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:55.576] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.576] - packages: [2] ‘stats’, ‘future.apply’
[17:40:55.577] getGlobalsAndPackages() ... DONE
[17:40:55.577]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.577]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:40:55.577] Finding globals ... DONE
[17:40:55.577]  - use_args: TRUE
[17:40:55.577]  - Getting '...' globals ...
[17:40:55.577] resolve() on list ...
[17:40:55.578]  recursive: 0
[17:40:55.578]  length: 1
[17:40:55.578]  elements: ‘...’
[17:40:55.578]  length: 0 (resolved future 1)
[17:40:55.578] resolve() on list ... DONE
[17:40:55.578]    - '...' content: [n=0] 
[17:40:55.578] List of 1
[17:40:55.578]  $ ...: list()
[17:40:55.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.578]  - attr(*, "where")=List of 1
[17:40:55.578]   ..$ ...:<environment: 0x564f2f786628> 
[17:40:55.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.578]  - attr(*, "resolved")= logi TRUE
[17:40:55.578]  - attr(*, "total_size")= num NA
[17:40:55.581]  - Getting '...' globals ... DONE
[17:40:55.583] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:55.583] List of 8
[17:40:55.583]  $ ...future.FUN:function (x, ...)  
[17:40:55.583]  $ x_FUN        :function (x, ...)  
[17:40:55.583]  $ times        : int 5
[17:40:55.583]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.583]  $ stop_if_not  :function (...)  
[17:40:55.583]  $ dim          : NULL
[17:40:55.583]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:55.583]  $ ...          : list()
[17:40:55.583]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.583]  - attr(*, "where")=List of 8
[17:40:55.583]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:55.583]   ..$ ...          :<environment: 0x564f2f786628> 
[17:40:55.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.583]  - attr(*, "resolved")= logi FALSE
[17:40:55.583]  - attr(*, "total_size")= num 95528
[17:40:55.590] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:40:55.590] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.591] Number of futures (= number of chunks): 2
[17:40:55.591] Launching 2 futures (chunks) ...
[17:40:55.591] Chunk #1 of 2 ...
[17:40:55.591]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.591] getGlobalsAndPackages() ...
[17:40:55.591] Searching for globals...
[17:40:55.591] 
[17:40:55.592] Searching for globals ... DONE
[17:40:55.592] - globals: [0] <none>
[17:40:55.592] getGlobalsAndPackages() ... DONE
[17:40:55.592]    + additional globals found: [n=0] 
[17:40:55.592]    + additional namespaces needed: [n=0] 
[17:40:55.592]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.592]  - seeds: <none>
[17:40:55.592] getGlobalsAndPackages() ...
[17:40:55.592] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.592] Resolving globals: FALSE
[17:40:55.593] Tweak future expression to call with '...' arguments ...
[17:40:55.593] {
[17:40:55.593]     do.call(function(...) {
[17:40:55.593]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.593]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.593]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.593]             on.exit(options(oopts), add = TRUE)
[17:40:55.593]         }
[17:40:55.593]         {
[17:40:55.593]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.593]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.593]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.593]             })
[17:40:55.593]         }
[17:40:55.593]     }, args = future.call.arguments)
[17:40:55.593] }
[17:40:55.593] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.593] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.594] - packages: [2] ‘stats’, ‘future.apply’
[17:40:55.594] getGlobalsAndPackages() ... DONE
[17:40:55.594] run() for ‘Future’ ...
[17:40:55.594] - state: ‘created’
[17:40:55.594] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.599]   - Field: ‘label’
[17:40:55.599]   - Field: ‘local’
[17:40:55.599]   - Field: ‘owner’
[17:40:55.599]   - Field: ‘envir’
[17:40:55.600]   - Field: ‘workers’
[17:40:55.600]   - Field: ‘packages’
[17:40:55.600]   - Field: ‘gc’
[17:40:55.600]   - Field: ‘job’
[17:40:55.600]   - Field: ‘conditions’
[17:40:55.600]   - Field: ‘expr’
[17:40:55.600]   - Field: ‘uuid’
[17:40:55.600]   - Field: ‘seed’
[17:40:55.600]   - Field: ‘version’
[17:40:55.601]   - Field: ‘result’
[17:40:55.601]   - Field: ‘asynchronous’
[17:40:55.601]   - Field: ‘calls’
[17:40:55.601]   - Field: ‘globals’
[17:40:55.601]   - Field: ‘stdout’
[17:40:55.601]   - Field: ‘earlySignal’
[17:40:55.601]   - Field: ‘lazy’
[17:40:55.601]   - Field: ‘state’
[17:40:55.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.601] - Launch lazy future ...
[17:40:55.602] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:40:55.602] Packages needed by future strategies (n = 0): <none>
[17:40:55.603] {
[17:40:55.603]     {
[17:40:55.603]         {
[17:40:55.603]             ...future.startTime <- base::Sys.time()
[17:40:55.603]             {
[17:40:55.603]                 {
[17:40:55.603]                   {
[17:40:55.603]                     {
[17:40:55.603]                       {
[17:40:55.603]                         base::local({
[17:40:55.603]                           has_future <- base::requireNamespace("future", 
[17:40:55.603]                             quietly = TRUE)
[17:40:55.603]                           if (has_future) {
[17:40:55.603]                             ns <- base::getNamespace("future")
[17:40:55.603]                             version <- ns[[".package"]][["version"]]
[17:40:55.603]                             if (is.null(version)) 
[17:40:55.603]                               version <- utils::packageVersion("future")
[17:40:55.603]                           }
[17:40:55.603]                           else {
[17:40:55.603]                             version <- NULL
[17:40:55.603]                           }
[17:40:55.603]                           if (!has_future || version < "1.8.0") {
[17:40:55.603]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.603]                               "", base::R.version$version.string), 
[17:40:55.603]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.603]                                 base::R.version$platform, 8 * 
[17:40:55.603]                                   base::.Machine$sizeof.pointer), 
[17:40:55.603]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.603]                                 "release", "version")], collapse = " "), 
[17:40:55.603]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.603]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.603]                               info)
[17:40:55.603]                             info <- base::paste(info, collapse = "; ")
[17:40:55.603]                             if (!has_future) {
[17:40:55.603]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.603]                                 info)
[17:40:55.603]                             }
[17:40:55.603]                             else {
[17:40:55.603]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.603]                                 info, version)
[17:40:55.603]                             }
[17:40:55.603]                             base::stop(msg)
[17:40:55.603]                           }
[17:40:55.603]                         })
[17:40:55.603]                       }
[17:40:55.603]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.603]                       base::options(mc.cores = 1L)
[17:40:55.603]                     }
[17:40:55.603]                     base::local({
[17:40:55.603]                       for (pkg in c("stats", "future.apply")) {
[17:40:55.603]                         base::loadNamespace(pkg)
[17:40:55.603]                         base::library(pkg, character.only = TRUE)
[17:40:55.603]                       }
[17:40:55.603]                     })
[17:40:55.603]                   }
[17:40:55.603]                   options(future.plan = NULL)
[17:40:55.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.603]                 }
[17:40:55.603]                 ...future.workdir <- getwd()
[17:40:55.603]             }
[17:40:55.603]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.603]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.603]         }
[17:40:55.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:55.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.603]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.603]             base::names(...future.oldOptions))
[17:40:55.603]     }
[17:40:55.603]     if (FALSE) {
[17:40:55.603]     }
[17:40:55.603]     else {
[17:40:55.603]         if (TRUE) {
[17:40:55.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.603]                 open = "w")
[17:40:55.603]         }
[17:40:55.603]         else {
[17:40:55.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.603]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.603]         }
[17:40:55.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.603]             base::sink(type = "output", split = FALSE)
[17:40:55.603]             base::close(...future.stdout)
[17:40:55.603]         }, add = TRUE)
[17:40:55.603]     }
[17:40:55.603]     ...future.frame <- base::sys.nframe()
[17:40:55.603]     ...future.conditions <- base::list()
[17:40:55.603]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.603]     if (FALSE) {
[17:40:55.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.603]     }
[17:40:55.603]     ...future.result <- base::tryCatch({
[17:40:55.603]         base::withCallingHandlers({
[17:40:55.603]             ...future.value <- base::withVisible(base::local({
[17:40:55.603]                 withCallingHandlers({
[17:40:55.603]                   {
[17:40:55.603]                     do.call(function(...) {
[17:40:55.603]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.603]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.603]                         ...future.globals.maxSize)) {
[17:40:55.603]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.603]                         on.exit(options(oopts), add = TRUE)
[17:40:55.603]                       }
[17:40:55.603]                       {
[17:40:55.603]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.603]                           FUN = function(jj) {
[17:40:55.603]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.603]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.603]                           })
[17:40:55.603]                       }
[17:40:55.603]                     }, args = future.call.arguments)
[17:40:55.603]                   }
[17:40:55.603]                 }, immediateCondition = function(cond) {
[17:40:55.603]                   save_rds <- function (object, pathname, ...) 
[17:40:55.603]                   {
[17:40:55.603]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.603]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.603]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.603]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.603]                         fi_tmp[["mtime"]])
[17:40:55.603]                     }
[17:40:55.603]                     tryCatch({
[17:40:55.603]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.603]                     }, error = function(ex) {
[17:40:55.603]                       msg <- conditionMessage(ex)
[17:40:55.603]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.603]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.603]                         fi_tmp[["mtime"]], msg)
[17:40:55.603]                       ex$message <- msg
[17:40:55.603]                       stop(ex)
[17:40:55.603]                     })
[17:40:55.603]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.603]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.603]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.603]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.603]                       fi <- file.info(pathname)
[17:40:55.603]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.603]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.603]                         fi[["size"]], fi[["mtime"]])
[17:40:55.603]                       stop(msg)
[17:40:55.603]                     }
[17:40:55.603]                     invisible(pathname)
[17:40:55.603]                   }
[17:40:55.603]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.603]                     rootPath = tempdir()) 
[17:40:55.603]                   {
[17:40:55.603]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.603]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.603]                       tmpdir = path, fileext = ".rds")
[17:40:55.603]                     save_rds(obj, file)
[17:40:55.603]                   }
[17:40:55.603]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.603]                   {
[17:40:55.603]                     inherits <- base::inherits
[17:40:55.603]                     invokeRestart <- base::invokeRestart
[17:40:55.603]                     is.null <- base::is.null
[17:40:55.603]                     muffled <- FALSE
[17:40:55.603]                     if (inherits(cond, "message")) {
[17:40:55.603]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.603]                       if (muffled) 
[17:40:55.603]                         invokeRestart("muffleMessage")
[17:40:55.603]                     }
[17:40:55.603]                     else if (inherits(cond, "warning")) {
[17:40:55.603]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.603]                       if (muffled) 
[17:40:55.603]                         invokeRestart("muffleWarning")
[17:40:55.603]                     }
[17:40:55.603]                     else if (inherits(cond, "condition")) {
[17:40:55.603]                       if (!is.null(pattern)) {
[17:40:55.603]                         computeRestarts <- base::computeRestarts
[17:40:55.603]                         grepl <- base::grepl
[17:40:55.603]                         restarts <- computeRestarts(cond)
[17:40:55.603]                         for (restart in restarts) {
[17:40:55.603]                           name <- restart$name
[17:40:55.603]                           if (is.null(name)) 
[17:40:55.603]                             next
[17:40:55.603]                           if (!grepl(pattern, name)) 
[17:40:55.603]                             next
[17:40:55.603]                           invokeRestart(restart)
[17:40:55.603]                           muffled <- TRUE
[17:40:55.603]                           break
[17:40:55.603]                         }
[17:40:55.603]                       }
[17:40:55.603]                     }
[17:40:55.603]                     invisible(muffled)
[17:40:55.603]                   }
[17:40:55.603]                   muffleCondition(cond)
[17:40:55.603]                 })
[17:40:55.603]             }))
[17:40:55.603]             future::FutureResult(value = ...future.value$value, 
[17:40:55.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.603]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.603]                     ...future.globalenv.names))
[17:40:55.603]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.603]         }, condition = base::local({
[17:40:55.603]             c <- base::c
[17:40:55.603]             inherits <- base::inherits
[17:40:55.603]             invokeRestart <- base::invokeRestart
[17:40:55.603]             length <- base::length
[17:40:55.603]             list <- base::list
[17:40:55.603]             seq.int <- base::seq.int
[17:40:55.603]             signalCondition <- base::signalCondition
[17:40:55.603]             sys.calls <- base::sys.calls
[17:40:55.603]             `[[` <- base::`[[`
[17:40:55.603]             `+` <- base::`+`
[17:40:55.603]             `<<-` <- base::`<<-`
[17:40:55.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.603]                   3L)]
[17:40:55.603]             }
[17:40:55.603]             function(cond) {
[17:40:55.603]                 is_error <- inherits(cond, "error")
[17:40:55.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.603]                   NULL)
[17:40:55.603]                 if (is_error) {
[17:40:55.603]                   sessionInformation <- function() {
[17:40:55.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.603]                       search = base::search(), system = base::Sys.info())
[17:40:55.603]                   }
[17:40:55.603]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.603]                     cond$call), session = sessionInformation(), 
[17:40:55.603]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.603]                   signalCondition(cond)
[17:40:55.603]                 }
[17:40:55.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.603]                 "immediateCondition"))) {
[17:40:55.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.603]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.603]                   if (TRUE && !signal) {
[17:40:55.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.603]                     {
[17:40:55.603]                       inherits <- base::inherits
[17:40:55.603]                       invokeRestart <- base::invokeRestart
[17:40:55.603]                       is.null <- base::is.null
[17:40:55.603]                       muffled <- FALSE
[17:40:55.603]                       if (inherits(cond, "message")) {
[17:40:55.603]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.603]                         if (muffled) 
[17:40:55.603]                           invokeRestart("muffleMessage")
[17:40:55.603]                       }
[17:40:55.603]                       else if (inherits(cond, "warning")) {
[17:40:55.603]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.603]                         if (muffled) 
[17:40:55.603]                           invokeRestart("muffleWarning")
[17:40:55.603]                       }
[17:40:55.603]                       else if (inherits(cond, "condition")) {
[17:40:55.603]                         if (!is.null(pattern)) {
[17:40:55.603]                           computeRestarts <- base::computeRestarts
[17:40:55.603]                           grepl <- base::grepl
[17:40:55.603]                           restarts <- computeRestarts(cond)
[17:40:55.603]                           for (restart in restarts) {
[17:40:55.603]                             name <- restart$name
[17:40:55.603]                             if (is.null(name)) 
[17:40:55.603]                               next
[17:40:55.603]                             if (!grepl(pattern, name)) 
[17:40:55.603]                               next
[17:40:55.603]                             invokeRestart(restart)
[17:40:55.603]                             muffled <- TRUE
[17:40:55.603]                             break
[17:40:55.603]                           }
[17:40:55.603]                         }
[17:40:55.603]                       }
[17:40:55.603]                       invisible(muffled)
[17:40:55.603]                     }
[17:40:55.603]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.603]                   }
[17:40:55.603]                 }
[17:40:55.603]                 else {
[17:40:55.603]                   if (TRUE) {
[17:40:55.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.603]                     {
[17:40:55.603]                       inherits <- base::inherits
[17:40:55.603]                       invokeRestart <- base::invokeRestart
[17:40:55.603]                       is.null <- base::is.null
[17:40:55.603]                       muffled <- FALSE
[17:40:55.603]                       if (inherits(cond, "message")) {
[17:40:55.603]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.603]                         if (muffled) 
[17:40:55.603]                           invokeRestart("muffleMessage")
[17:40:55.603]                       }
[17:40:55.603]                       else if (inherits(cond, "warning")) {
[17:40:55.603]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.603]                         if (muffled) 
[17:40:55.603]                           invokeRestart("muffleWarning")
[17:40:55.603]                       }
[17:40:55.603]                       else if (inherits(cond, "condition")) {
[17:40:55.603]                         if (!is.null(pattern)) {
[17:40:55.603]                           computeRestarts <- base::computeRestarts
[17:40:55.603]                           grepl <- base::grepl
[17:40:55.603]                           restarts <- computeRestarts(cond)
[17:40:55.603]                           for (restart in restarts) {
[17:40:55.603]                             name <- restart$name
[17:40:55.603]                             if (is.null(name)) 
[17:40:55.603]                               next
[17:40:55.603]                             if (!grepl(pattern, name)) 
[17:40:55.603]                               next
[17:40:55.603]                             invokeRestart(restart)
[17:40:55.603]                             muffled <- TRUE
[17:40:55.603]                             break
[17:40:55.603]                           }
[17:40:55.603]                         }
[17:40:55.603]                       }
[17:40:55.603]                       invisible(muffled)
[17:40:55.603]                     }
[17:40:55.603]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.603]                   }
[17:40:55.603]                 }
[17:40:55.603]             }
[17:40:55.603]         }))
[17:40:55.603]     }, error = function(ex) {
[17:40:55.603]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.603]                 ...future.rng), started = ...future.startTime, 
[17:40:55.603]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.603]             version = "1.8"), class = "FutureResult")
[17:40:55.603]     }, finally = {
[17:40:55.603]         if (!identical(...future.workdir, getwd())) 
[17:40:55.603]             setwd(...future.workdir)
[17:40:55.603]         {
[17:40:55.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.603]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.603]             }
[17:40:55.603]             base::options(...future.oldOptions)
[17:40:55.603]             if (.Platform$OS.type == "windows") {
[17:40:55.603]                 old_names <- names(...future.oldEnvVars)
[17:40:55.603]                 envs <- base::Sys.getenv()
[17:40:55.603]                 names <- names(envs)
[17:40:55.603]                 common <- intersect(names, old_names)
[17:40:55.603]                 added <- setdiff(names, old_names)
[17:40:55.603]                 removed <- setdiff(old_names, names)
[17:40:55.603]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.603]                   envs[common]]
[17:40:55.603]                 NAMES <- toupper(changed)
[17:40:55.603]                 args <- list()
[17:40:55.603]                 for (kk in seq_along(NAMES)) {
[17:40:55.603]                   name <- changed[[kk]]
[17:40:55.603]                   NAME <- NAMES[[kk]]
[17:40:55.603]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.603]                     next
[17:40:55.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.603]                 }
[17:40:55.603]                 NAMES <- toupper(added)
[17:40:55.603]                 for (kk in seq_along(NAMES)) {
[17:40:55.603]                   name <- added[[kk]]
[17:40:55.603]                   NAME <- NAMES[[kk]]
[17:40:55.603]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.603]                     next
[17:40:55.603]                   args[[name]] <- ""
[17:40:55.603]                 }
[17:40:55.603]                 NAMES <- toupper(removed)
[17:40:55.603]                 for (kk in seq_along(NAMES)) {
[17:40:55.603]                   name <- removed[[kk]]
[17:40:55.603]                   NAME <- NAMES[[kk]]
[17:40:55.603]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.603]                     next
[17:40:55.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.603]                 }
[17:40:55.603]                 if (length(args) > 0) 
[17:40:55.603]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.603]             }
[17:40:55.603]             else {
[17:40:55.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.603]             }
[17:40:55.603]             {
[17:40:55.603]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.603]                   0L) {
[17:40:55.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.603]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.603]                   base::options(opts)
[17:40:55.603]                 }
[17:40:55.603]                 {
[17:40:55.603]                   {
[17:40:55.603]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.603]                     NULL
[17:40:55.603]                   }
[17:40:55.603]                   options(future.plan = NULL)
[17:40:55.603]                   if (is.na(NA_character_)) 
[17:40:55.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.603]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.603]                     envir = parent.frame()) 
[17:40:55.603]                   {
[17:40:55.603]                     default_workers <- missing(workers)
[17:40:55.603]                     if (is.function(workers)) 
[17:40:55.603]                       workers <- workers()
[17:40:55.603]                     workers <- structure(as.integer(workers), 
[17:40:55.603]                       class = class(workers))
[17:40:55.603]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.603]                       1L)
[17:40:55.603]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.603]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.603]                       if (default_workers) 
[17:40:55.603]                         supportsMulticore(warn = TRUE)
[17:40:55.603]                       return(sequential(..., envir = envir))
[17:40:55.603]                     }
[17:40:55.603]                     oopts <- options(mc.cores = workers)
[17:40:55.603]                     on.exit(options(oopts))
[17:40:55.603]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.603]                       envir = envir)
[17:40:55.603]                     if (!future$lazy) 
[17:40:55.603]                       future <- run(future)
[17:40:55.603]                     invisible(future)
[17:40:55.603]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.603]                 }
[17:40:55.603]             }
[17:40:55.603]         }
[17:40:55.603]     })
[17:40:55.603]     if (TRUE) {
[17:40:55.603]         base::sink(type = "output", split = FALSE)
[17:40:55.603]         if (TRUE) {
[17:40:55.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.603]         }
[17:40:55.603]         else {
[17:40:55.603]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.603]         }
[17:40:55.603]         base::close(...future.stdout)
[17:40:55.603]         ...future.stdout <- NULL
[17:40:55.603]     }
[17:40:55.603]     ...future.result$conditions <- ...future.conditions
[17:40:55.603]     ...future.result$finished <- base::Sys.time()
[17:40:55.603]     ...future.result
[17:40:55.603] }
[17:40:55.605] assign_globals() ...
[17:40:55.605] List of 11
[17:40:55.605]  $ ...future.FUN            :function (x, ...)  
[17:40:55.605]  $ x_FUN                    :function (x, ...)  
[17:40:55.605]  $ times                    : int 5
[17:40:55.605]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.605]  $ stop_if_not              :function (...)  
[17:40:55.605]  $ dim                      : NULL
[17:40:55.605]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.605]  $ future.call.arguments    : list()
[17:40:55.605]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.605]  $ ...future.elements_ii    :List of 1
[17:40:55.605]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:40:55.605]  $ ...future.seeds_ii       : NULL
[17:40:55.605]  $ ...future.globals.maxSize: NULL
[17:40:55.605]  - attr(*, "where")=List of 11
[17:40:55.605]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.605]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.605]  - attr(*, "resolved")= logi FALSE
[17:40:55.605]  - attr(*, "total_size")= num 95528
[17:40:55.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.605]  - attr(*, "already-done")= logi TRUE
[17:40:55.616] - copied ‘...future.FUN’ to environment
[17:40:55.616] - copied ‘x_FUN’ to environment
[17:40:55.616] - copied ‘times’ to environment
[17:40:55.616] - copied ‘stopf’ to environment
[17:40:55.617] - copied ‘stop_if_not’ to environment
[17:40:55.617] - copied ‘dim’ to environment
[17:40:55.617] - copied ‘valid_types’ to environment
[17:40:55.617] - copied ‘future.call.arguments’ to environment
[17:40:55.617] - copied ‘...future.elements_ii’ to environment
[17:40:55.617] - copied ‘...future.seeds_ii’ to environment
[17:40:55.617] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.617] assign_globals() ... done
[17:40:55.617] requestCore(): workers = 2
[17:40:55.620] MulticoreFuture started
[17:40:55.621] - Launch lazy future ... done
[17:40:55.621] run() for ‘MulticoreFuture’ ... done
[17:40:55.621] Created future:
[17:40:55.622] plan(): Setting new future strategy stack:
[17:40:55.622] List of future strategies:
[17:40:55.622] 1. sequential:
[17:40:55.622]    - args: function (..., envir = parent.frame())
[17:40:55.622]    - tweaked: FALSE
[17:40:55.622]    - call: NULL
[17:40:55.623] plan(): nbrOfWorkers() = 1
[17:40:55.626] plan(): Setting new future strategy stack:
[17:40:55.626] List of future strategies:
[17:40:55.626] 1. multicore:
[17:40:55.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.626]    - tweaked: FALSE
[17:40:55.626]    - call: plan(strategy)
[17:40:55.632] plan(): nbrOfWorkers() = 2
[17:40:55.621] MulticoreFuture:
[17:40:55.621] Label: ‘future_vapply-1’
[17:40:55.621] Expression:
[17:40:55.621] {
[17:40:55.621]     do.call(function(...) {
[17:40:55.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.621]             on.exit(options(oopts), add = TRUE)
[17:40:55.621]         }
[17:40:55.621]         {
[17:40:55.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.621]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.621]             })
[17:40:55.621]         }
[17:40:55.621]     }, args = future.call.arguments)
[17:40:55.621] }
[17:40:55.621] Lazy evaluation: FALSE
[17:40:55.621] Asynchronous evaluation: TRUE
[17:40:55.621] Local evaluation: TRUE
[17:40:55.621] Environment: R_GlobalEnv
[17:40:55.621] Capture standard output: TRUE
[17:40:55.621] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.621] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.621] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:40:55.621] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.621] Resolved: TRUE
[17:40:55.621] Value: <not collected>
[17:40:55.621] Conditions captured: <none>
[17:40:55.621] Early signaling: FALSE
[17:40:55.621] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.621] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.633] Chunk #1 of 2 ... DONE
[17:40:55.634] Chunk #2 of 2 ...
[17:40:55.634]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.634] getGlobalsAndPackages() ...
[17:40:55.634] Searching for globals...
[17:40:55.635] 
[17:40:55.635] Searching for globals ... DONE
[17:40:55.635] - globals: [0] <none>
[17:40:55.635] getGlobalsAndPackages() ... DONE
[17:40:55.635]    + additional globals found: [n=0] 
[17:40:55.635]    + additional namespaces needed: [n=0] 
[17:40:55.636]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.636]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:55.636]  - seeds: <none>
[17:40:55.636] getGlobalsAndPackages() ...
[17:40:55.636] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.637] Resolving globals: FALSE
[17:40:55.637] Tweak future expression to call with '...' arguments ...
[17:40:55.637] {
[17:40:55.637]     do.call(function(...) {
[17:40:55.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.637]             on.exit(options(oopts), add = TRUE)
[17:40:55.637]         }
[17:40:55.637]         {
[17:40:55.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.637]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.637]             })
[17:40:55.637]         }
[17:40:55.637]     }, args = future.call.arguments)
[17:40:55.637] }
[17:40:55.637] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.638] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.639] - packages: [2] ‘stats’, ‘future.apply’
[17:40:55.639] getGlobalsAndPackages() ... DONE
[17:40:55.639] run() for ‘Future’ ...
[17:40:55.640] - state: ‘created’
[17:40:55.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.645]   - Field: ‘label’
[17:40:55.645]   - Field: ‘local’
[17:40:55.645]   - Field: ‘owner’
[17:40:55.645]   - Field: ‘envir’
[17:40:55.645]   - Field: ‘workers’
[17:40:55.646]   - Field: ‘packages’
[17:40:55.646]   - Field: ‘gc’
[17:40:55.646]   - Field: ‘job’
[17:40:55.646]   - Field: ‘conditions’
[17:40:55.646]   - Field: ‘expr’
[17:40:55.646]   - Field: ‘uuid’
[17:40:55.647]   - Field: ‘seed’
[17:40:55.647]   - Field: ‘version’
[17:40:55.647]   - Field: ‘result’
[17:40:55.647]   - Field: ‘asynchronous’
[17:40:55.647]   - Field: ‘calls’
[17:40:55.647]   - Field: ‘globals’
[17:40:55.648]   - Field: ‘stdout’
[17:40:55.648]   - Field: ‘earlySignal’
[17:40:55.648]   - Field: ‘lazy’
[17:40:55.648]   - Field: ‘state’
[17:40:55.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.648] - Launch lazy future ...
[17:40:55.649] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:40:55.649] Packages needed by future strategies (n = 0): <none>
[17:40:55.650] {
[17:40:55.650]     {
[17:40:55.650]         {
[17:40:55.650]             ...future.startTime <- base::Sys.time()
[17:40:55.650]             {
[17:40:55.650]                 {
[17:40:55.650]                   {
[17:40:55.650]                     {
[17:40:55.650]                       {
[17:40:55.650]                         base::local({
[17:40:55.650]                           has_future <- base::requireNamespace("future", 
[17:40:55.650]                             quietly = TRUE)
[17:40:55.650]                           if (has_future) {
[17:40:55.650]                             ns <- base::getNamespace("future")
[17:40:55.650]                             version <- ns[[".package"]][["version"]]
[17:40:55.650]                             if (is.null(version)) 
[17:40:55.650]                               version <- utils::packageVersion("future")
[17:40:55.650]                           }
[17:40:55.650]                           else {
[17:40:55.650]                             version <- NULL
[17:40:55.650]                           }
[17:40:55.650]                           if (!has_future || version < "1.8.0") {
[17:40:55.650]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.650]                               "", base::R.version$version.string), 
[17:40:55.650]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.650]                                 base::R.version$platform, 8 * 
[17:40:55.650]                                   base::.Machine$sizeof.pointer), 
[17:40:55.650]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.650]                                 "release", "version")], collapse = " "), 
[17:40:55.650]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.650]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.650]                               info)
[17:40:55.650]                             info <- base::paste(info, collapse = "; ")
[17:40:55.650]                             if (!has_future) {
[17:40:55.650]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.650]                                 info)
[17:40:55.650]                             }
[17:40:55.650]                             else {
[17:40:55.650]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.650]                                 info, version)
[17:40:55.650]                             }
[17:40:55.650]                             base::stop(msg)
[17:40:55.650]                           }
[17:40:55.650]                         })
[17:40:55.650]                       }
[17:40:55.650]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.650]                       base::options(mc.cores = 1L)
[17:40:55.650]                     }
[17:40:55.650]                     base::local({
[17:40:55.650]                       for (pkg in c("stats", "future.apply")) {
[17:40:55.650]                         base::loadNamespace(pkg)
[17:40:55.650]                         base::library(pkg, character.only = TRUE)
[17:40:55.650]                       }
[17:40:55.650]                     })
[17:40:55.650]                   }
[17:40:55.650]                   options(future.plan = NULL)
[17:40:55.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.650]                 }
[17:40:55.650]                 ...future.workdir <- getwd()
[17:40:55.650]             }
[17:40:55.650]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.650]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.650]         }
[17:40:55.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.650]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:55.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.650]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.650]             base::names(...future.oldOptions))
[17:40:55.650]     }
[17:40:55.650]     if (FALSE) {
[17:40:55.650]     }
[17:40:55.650]     else {
[17:40:55.650]         if (TRUE) {
[17:40:55.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.650]                 open = "w")
[17:40:55.650]         }
[17:40:55.650]         else {
[17:40:55.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.650]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.650]         }
[17:40:55.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.650]             base::sink(type = "output", split = FALSE)
[17:40:55.650]             base::close(...future.stdout)
[17:40:55.650]         }, add = TRUE)
[17:40:55.650]     }
[17:40:55.650]     ...future.frame <- base::sys.nframe()
[17:40:55.650]     ...future.conditions <- base::list()
[17:40:55.650]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.650]     if (FALSE) {
[17:40:55.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.650]     }
[17:40:55.650]     ...future.result <- base::tryCatch({
[17:40:55.650]         base::withCallingHandlers({
[17:40:55.650]             ...future.value <- base::withVisible(base::local({
[17:40:55.650]                 withCallingHandlers({
[17:40:55.650]                   {
[17:40:55.650]                     do.call(function(...) {
[17:40:55.650]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.650]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.650]                         ...future.globals.maxSize)) {
[17:40:55.650]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.650]                         on.exit(options(oopts), add = TRUE)
[17:40:55.650]                       }
[17:40:55.650]                       {
[17:40:55.650]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.650]                           FUN = function(jj) {
[17:40:55.650]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.650]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.650]                           })
[17:40:55.650]                       }
[17:40:55.650]                     }, args = future.call.arguments)
[17:40:55.650]                   }
[17:40:55.650]                 }, immediateCondition = function(cond) {
[17:40:55.650]                   save_rds <- function (object, pathname, ...) 
[17:40:55.650]                   {
[17:40:55.650]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.650]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.650]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.650]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.650]                         fi_tmp[["mtime"]])
[17:40:55.650]                     }
[17:40:55.650]                     tryCatch({
[17:40:55.650]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.650]                     }, error = function(ex) {
[17:40:55.650]                       msg <- conditionMessage(ex)
[17:40:55.650]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.650]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.650]                         fi_tmp[["mtime"]], msg)
[17:40:55.650]                       ex$message <- msg
[17:40:55.650]                       stop(ex)
[17:40:55.650]                     })
[17:40:55.650]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.650]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.650]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.650]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.650]                       fi <- file.info(pathname)
[17:40:55.650]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.650]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.650]                         fi[["size"]], fi[["mtime"]])
[17:40:55.650]                       stop(msg)
[17:40:55.650]                     }
[17:40:55.650]                     invisible(pathname)
[17:40:55.650]                   }
[17:40:55.650]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.650]                     rootPath = tempdir()) 
[17:40:55.650]                   {
[17:40:55.650]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.650]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.650]                       tmpdir = path, fileext = ".rds")
[17:40:55.650]                     save_rds(obj, file)
[17:40:55.650]                   }
[17:40:55.650]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.650]                   {
[17:40:55.650]                     inherits <- base::inherits
[17:40:55.650]                     invokeRestart <- base::invokeRestart
[17:40:55.650]                     is.null <- base::is.null
[17:40:55.650]                     muffled <- FALSE
[17:40:55.650]                     if (inherits(cond, "message")) {
[17:40:55.650]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.650]                       if (muffled) 
[17:40:55.650]                         invokeRestart("muffleMessage")
[17:40:55.650]                     }
[17:40:55.650]                     else if (inherits(cond, "warning")) {
[17:40:55.650]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.650]                       if (muffled) 
[17:40:55.650]                         invokeRestart("muffleWarning")
[17:40:55.650]                     }
[17:40:55.650]                     else if (inherits(cond, "condition")) {
[17:40:55.650]                       if (!is.null(pattern)) {
[17:40:55.650]                         computeRestarts <- base::computeRestarts
[17:40:55.650]                         grepl <- base::grepl
[17:40:55.650]                         restarts <- computeRestarts(cond)
[17:40:55.650]                         for (restart in restarts) {
[17:40:55.650]                           name <- restart$name
[17:40:55.650]                           if (is.null(name)) 
[17:40:55.650]                             next
[17:40:55.650]                           if (!grepl(pattern, name)) 
[17:40:55.650]                             next
[17:40:55.650]                           invokeRestart(restart)
[17:40:55.650]                           muffled <- TRUE
[17:40:55.650]                           break
[17:40:55.650]                         }
[17:40:55.650]                       }
[17:40:55.650]                     }
[17:40:55.650]                     invisible(muffled)
[17:40:55.650]                   }
[17:40:55.650]                   muffleCondition(cond)
[17:40:55.650]                 })
[17:40:55.650]             }))
[17:40:55.650]             future::FutureResult(value = ...future.value$value, 
[17:40:55.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.650]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.650]                     ...future.globalenv.names))
[17:40:55.650]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.650]         }, condition = base::local({
[17:40:55.650]             c <- base::c
[17:40:55.650]             inherits <- base::inherits
[17:40:55.650]             invokeRestart <- base::invokeRestart
[17:40:55.650]             length <- base::length
[17:40:55.650]             list <- base::list
[17:40:55.650]             seq.int <- base::seq.int
[17:40:55.650]             signalCondition <- base::signalCondition
[17:40:55.650]             sys.calls <- base::sys.calls
[17:40:55.650]             `[[` <- base::`[[`
[17:40:55.650]             `+` <- base::`+`
[17:40:55.650]             `<<-` <- base::`<<-`
[17:40:55.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.650]                   3L)]
[17:40:55.650]             }
[17:40:55.650]             function(cond) {
[17:40:55.650]                 is_error <- inherits(cond, "error")
[17:40:55.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.650]                   NULL)
[17:40:55.650]                 if (is_error) {
[17:40:55.650]                   sessionInformation <- function() {
[17:40:55.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.650]                       search = base::search(), system = base::Sys.info())
[17:40:55.650]                   }
[17:40:55.650]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.650]                     cond$call), session = sessionInformation(), 
[17:40:55.650]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.650]                   signalCondition(cond)
[17:40:55.650]                 }
[17:40:55.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.650]                 "immediateCondition"))) {
[17:40:55.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.650]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.650]                   if (TRUE && !signal) {
[17:40:55.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.650]                     {
[17:40:55.650]                       inherits <- base::inherits
[17:40:55.650]                       invokeRestart <- base::invokeRestart
[17:40:55.650]                       is.null <- base::is.null
[17:40:55.650]                       muffled <- FALSE
[17:40:55.650]                       if (inherits(cond, "message")) {
[17:40:55.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.650]                         if (muffled) 
[17:40:55.650]                           invokeRestart("muffleMessage")
[17:40:55.650]                       }
[17:40:55.650]                       else if (inherits(cond, "warning")) {
[17:40:55.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.650]                         if (muffled) 
[17:40:55.650]                           invokeRestart("muffleWarning")
[17:40:55.650]                       }
[17:40:55.650]                       else if (inherits(cond, "condition")) {
[17:40:55.650]                         if (!is.null(pattern)) {
[17:40:55.650]                           computeRestarts <- base::computeRestarts
[17:40:55.650]                           grepl <- base::grepl
[17:40:55.650]                           restarts <- computeRestarts(cond)
[17:40:55.650]                           for (restart in restarts) {
[17:40:55.650]                             name <- restart$name
[17:40:55.650]                             if (is.null(name)) 
[17:40:55.650]                               next
[17:40:55.650]                             if (!grepl(pattern, name)) 
[17:40:55.650]                               next
[17:40:55.650]                             invokeRestart(restart)
[17:40:55.650]                             muffled <- TRUE
[17:40:55.650]                             break
[17:40:55.650]                           }
[17:40:55.650]                         }
[17:40:55.650]                       }
[17:40:55.650]                       invisible(muffled)
[17:40:55.650]                     }
[17:40:55.650]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.650]                   }
[17:40:55.650]                 }
[17:40:55.650]                 else {
[17:40:55.650]                   if (TRUE) {
[17:40:55.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.650]                     {
[17:40:55.650]                       inherits <- base::inherits
[17:40:55.650]                       invokeRestart <- base::invokeRestart
[17:40:55.650]                       is.null <- base::is.null
[17:40:55.650]                       muffled <- FALSE
[17:40:55.650]                       if (inherits(cond, "message")) {
[17:40:55.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.650]                         if (muffled) 
[17:40:55.650]                           invokeRestart("muffleMessage")
[17:40:55.650]                       }
[17:40:55.650]                       else if (inherits(cond, "warning")) {
[17:40:55.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.650]                         if (muffled) 
[17:40:55.650]                           invokeRestart("muffleWarning")
[17:40:55.650]                       }
[17:40:55.650]                       else if (inherits(cond, "condition")) {
[17:40:55.650]                         if (!is.null(pattern)) {
[17:40:55.650]                           computeRestarts <- base::computeRestarts
[17:40:55.650]                           grepl <- base::grepl
[17:40:55.650]                           restarts <- computeRestarts(cond)
[17:40:55.650]                           for (restart in restarts) {
[17:40:55.650]                             name <- restart$name
[17:40:55.650]                             if (is.null(name)) 
[17:40:55.650]                               next
[17:40:55.650]                             if (!grepl(pattern, name)) 
[17:40:55.650]                               next
[17:40:55.650]                             invokeRestart(restart)
[17:40:55.650]                             muffled <- TRUE
[17:40:55.650]                             break
[17:40:55.650]                           }
[17:40:55.650]                         }
[17:40:55.650]                       }
[17:40:55.650]                       invisible(muffled)
[17:40:55.650]                     }
[17:40:55.650]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.650]                   }
[17:40:55.650]                 }
[17:40:55.650]             }
[17:40:55.650]         }))
[17:40:55.650]     }, error = function(ex) {
[17:40:55.650]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.650]                 ...future.rng), started = ...future.startTime, 
[17:40:55.650]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.650]             version = "1.8"), class = "FutureResult")
[17:40:55.650]     }, finally = {
[17:40:55.650]         if (!identical(...future.workdir, getwd())) 
[17:40:55.650]             setwd(...future.workdir)
[17:40:55.650]         {
[17:40:55.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.650]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.650]             }
[17:40:55.650]             base::options(...future.oldOptions)
[17:40:55.650]             if (.Platform$OS.type == "windows") {
[17:40:55.650]                 old_names <- names(...future.oldEnvVars)
[17:40:55.650]                 envs <- base::Sys.getenv()
[17:40:55.650]                 names <- names(envs)
[17:40:55.650]                 common <- intersect(names, old_names)
[17:40:55.650]                 added <- setdiff(names, old_names)
[17:40:55.650]                 removed <- setdiff(old_names, names)
[17:40:55.650]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.650]                   envs[common]]
[17:40:55.650]                 NAMES <- toupper(changed)
[17:40:55.650]                 args <- list()
[17:40:55.650]                 for (kk in seq_along(NAMES)) {
[17:40:55.650]                   name <- changed[[kk]]
[17:40:55.650]                   NAME <- NAMES[[kk]]
[17:40:55.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.650]                     next
[17:40:55.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.650]                 }
[17:40:55.650]                 NAMES <- toupper(added)
[17:40:55.650]                 for (kk in seq_along(NAMES)) {
[17:40:55.650]                   name <- added[[kk]]
[17:40:55.650]                   NAME <- NAMES[[kk]]
[17:40:55.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.650]                     next
[17:40:55.650]                   args[[name]] <- ""
[17:40:55.650]                 }
[17:40:55.650]                 NAMES <- toupper(removed)
[17:40:55.650]                 for (kk in seq_along(NAMES)) {
[17:40:55.650]                   name <- removed[[kk]]
[17:40:55.650]                   NAME <- NAMES[[kk]]
[17:40:55.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.650]                     next
[17:40:55.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.650]                 }
[17:40:55.650]                 if (length(args) > 0) 
[17:40:55.650]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.650]             }
[17:40:55.650]             else {
[17:40:55.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.650]             }
[17:40:55.650]             {
[17:40:55.650]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.650]                   0L) {
[17:40:55.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.650]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.650]                   base::options(opts)
[17:40:55.650]                 }
[17:40:55.650]                 {
[17:40:55.650]                   {
[17:40:55.650]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.650]                     NULL
[17:40:55.650]                   }
[17:40:55.650]                   options(future.plan = NULL)
[17:40:55.650]                   if (is.na(NA_character_)) 
[17:40:55.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.650]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.650]                     envir = parent.frame()) 
[17:40:55.650]                   {
[17:40:55.650]                     default_workers <- missing(workers)
[17:40:55.650]                     if (is.function(workers)) 
[17:40:55.650]                       workers <- workers()
[17:40:55.650]                     workers <- structure(as.integer(workers), 
[17:40:55.650]                       class = class(workers))
[17:40:55.650]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.650]                       1L)
[17:40:55.650]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.650]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.650]                       if (default_workers) 
[17:40:55.650]                         supportsMulticore(warn = TRUE)
[17:40:55.650]                       return(sequential(..., envir = envir))
[17:40:55.650]                     }
[17:40:55.650]                     oopts <- options(mc.cores = workers)
[17:40:55.650]                     on.exit(options(oopts))
[17:40:55.650]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.650]                       envir = envir)
[17:40:55.650]                     if (!future$lazy) 
[17:40:55.650]                       future <- run(future)
[17:40:55.650]                     invisible(future)
[17:40:55.650]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.650]                 }
[17:40:55.650]             }
[17:40:55.650]         }
[17:40:55.650]     })
[17:40:55.650]     if (TRUE) {
[17:40:55.650]         base::sink(type = "output", split = FALSE)
[17:40:55.650]         if (TRUE) {
[17:40:55.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.650]         }
[17:40:55.650]         else {
[17:40:55.650]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.650]         }
[17:40:55.650]         base::close(...future.stdout)
[17:40:55.650]         ...future.stdout <- NULL
[17:40:55.650]     }
[17:40:55.650]     ...future.result$conditions <- ...future.conditions
[17:40:55.650]     ...future.result$finished <- base::Sys.time()
[17:40:55.650]     ...future.result
[17:40:55.650] }
[17:40:55.654] assign_globals() ...
[17:40:55.654] List of 11
[17:40:55.654]  $ ...future.FUN            :function (x, ...)  
[17:40:55.654]  $ x_FUN                    :function (x, ...)  
[17:40:55.654]  $ times                    : int 5
[17:40:55.654]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.654]  $ stop_if_not              :function (...)  
[17:40:55.654]  $ dim                      : NULL
[17:40:55.654]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.654]  $ future.call.arguments    : list()
[17:40:55.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.654]  $ ...future.elements_ii    :List of 2
[17:40:55.654]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:40:55.654]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:40:55.654]  $ ...future.seeds_ii       : NULL
[17:40:55.654]  $ ...future.globals.maxSize: NULL
[17:40:55.654]  - attr(*, "resolved")= logi FALSE
[17:40:55.654]  - attr(*, "total_size")= num 95528
[17:40:55.654]  - attr(*, "where")=List of 11
[17:40:55.654]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.654]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.654]  - attr(*, "already-done")= logi TRUE
[17:40:55.670] - copied ‘...future.FUN’ to environment
[17:40:55.670] - copied ‘x_FUN’ to environment
[17:40:55.670] - copied ‘times’ to environment
[17:40:55.670] - copied ‘stopf’ to environment
[17:40:55.670] - copied ‘stop_if_not’ to environment
[17:40:55.670] - copied ‘dim’ to environment
[17:40:55.670] - copied ‘valid_types’ to environment
[17:40:55.671] - copied ‘future.call.arguments’ to environment
[17:40:55.671] - copied ‘...future.elements_ii’ to environment
[17:40:55.671] - copied ‘...future.seeds_ii’ to environment
[17:40:55.671] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.671] assign_globals() ... done
[17:40:55.671] requestCore(): workers = 2
[17:40:55.673] MulticoreFuture started
[17:40:55.674] - Launch lazy future ... done
[17:40:55.674] run() for ‘MulticoreFuture’ ... done
[17:40:55.674] Created future:
[17:40:55.675] plan(): Setting new future strategy stack:
[17:40:55.675] List of future strategies:
[17:40:55.675] 1. sequential:
[17:40:55.675]    - args: function (..., envir = parent.frame())
[17:40:55.675]    - tweaked: FALSE
[17:40:55.675]    - call: NULL
[17:40:55.676] plan(): nbrOfWorkers() = 1
[17:40:55.679] plan(): Setting new future strategy stack:
[17:40:55.679] List of future strategies:
[17:40:55.679] 1. multicore:
[17:40:55.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.679]    - tweaked: FALSE
[17:40:55.679]    - call: plan(strategy)
[17:40:55.685] plan(): nbrOfWorkers() = 2
[17:40:55.675] MulticoreFuture:
[17:40:55.675] Label: ‘future_vapply-2’
[17:40:55.675] Expression:
[17:40:55.675] {
[17:40:55.675]     do.call(function(...) {
[17:40:55.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.675]             on.exit(options(oopts), add = TRUE)
[17:40:55.675]         }
[17:40:55.675]         {
[17:40:55.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.675]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.675]             })
[17:40:55.675]         }
[17:40:55.675]     }, args = future.call.arguments)
[17:40:55.675] }
[17:40:55.675] Lazy evaluation: FALSE
[17:40:55.675] Asynchronous evaluation: TRUE
[17:40:55.675] Local evaluation: TRUE
[17:40:55.675] Environment: R_GlobalEnv
[17:40:55.675] Capture standard output: TRUE
[17:40:55.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.675] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.675] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:40:55.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.675] Resolved: TRUE
[17:40:55.675] Value: <not collected>
[17:40:55.675] Conditions captured: <none>
[17:40:55.675] Early signaling: FALSE
[17:40:55.675] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.675] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.686] Chunk #2 of 2 ... DONE
[17:40:55.686] Launching 2 futures (chunks) ... DONE
[17:40:55.686] Resolving 2 futures (chunks) ...
[17:40:55.686] resolve() on list ...
[17:40:55.686]  recursive: 0
[17:40:55.687]  length: 2
[17:40:55.687] 
[17:40:55.687] Future #1
[17:40:55.688] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.688] - nx: 2
[17:40:55.688] - relay: TRUE
[17:40:55.688] - stdout: TRUE
[17:40:55.689] - signal: TRUE
[17:40:55.689] - resignal: FALSE
[17:40:55.689] - force: TRUE
[17:40:55.689] - relayed: [n=2] FALSE, FALSE
[17:40:55.689] - queued futures: [n=2] FALSE, FALSE
[17:40:55.689]  - until=1
[17:40:55.689]  - relaying element #1
[17:40:55.690] - relayed: [n=2] TRUE, FALSE
[17:40:55.690] - queued futures: [n=2] TRUE, FALSE
[17:40:55.690] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.690]  length: 1 (resolved future 1)
[17:40:55.691] Future #2
[17:40:55.691] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.692] - nx: 2
[17:40:55.692] - relay: TRUE
[17:40:55.692] - stdout: TRUE
[17:40:55.692] - signal: TRUE
[17:40:55.692] - resignal: FALSE
[17:40:55.692] - force: TRUE
[17:40:55.692] - relayed: [n=2] TRUE, FALSE
[17:40:55.692] - queued futures: [n=2] TRUE, FALSE
[17:40:55.693]  - until=2
[17:40:55.693]  - relaying element #2
[17:40:55.693] - relayed: [n=2] TRUE, TRUE
[17:40:55.693] - queued futures: [n=2] TRUE, TRUE
[17:40:55.693] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.693]  length: 0 (resolved future 2)
[17:40:55.694] Relaying remaining futures
[17:40:55.694] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.694] - nx: 2
[17:40:55.694] - relay: TRUE
[17:40:55.694] - stdout: TRUE
[17:40:55.694] - signal: TRUE
[17:40:55.694] - resignal: FALSE
[17:40:55.694] - force: TRUE
[17:40:55.694] - relayed: [n=2] TRUE, TRUE
[17:40:55.695] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.695] - relayed: [n=2] TRUE, TRUE
[17:40:55.695] - queued futures: [n=2] TRUE, TRUE
[17:40:55.695] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.695] resolve() on list ... DONE
[17:40:55.695]  - Number of value chunks collected: 2
[17:40:55.696] Resolving 2 futures (chunks) ... DONE
[17:40:55.696] Reducing values from 2 chunks ...
[17:40:55.696]  - Number of values collected after concatenation: 3
[17:40:55.696]  - Number of values expected: 3
[17:40:55.696] Reducing values from 2 chunks ... DONE
[17:40:55.696] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:40:55.701] future_lapply() ...
[17:40:55.711] Number of chunks: 2
[17:40:55.711] getGlobalsAndPackagesXApply() ...
[17:40:55.712]  - future.globals: TRUE
[17:40:55.712] getGlobalsAndPackages() ...
[17:40:55.712] Searching for globals...
[17:40:55.717] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:40:55.717] Searching for globals ... DONE
[17:40:55.717] Resolving globals: FALSE
[17:40:55.718] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:40:55.719] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:40:55.719] - globals: [1] ‘FUN’
[17:40:55.719] - packages: [1] ‘stats’
[17:40:55.719] getGlobalsAndPackages() ... DONE
[17:40:55.719]  - globals found/used: [n=1] ‘FUN’
[17:40:55.719]  - needed namespaces: [n=1] ‘stats’
[17:40:55.719] Finding globals ... DONE
[17:40:55.719]  - use_args: TRUE
[17:40:55.720]  - Getting '...' globals ...
[17:40:55.720] resolve() on list ...
[17:40:55.720]  recursive: 0
[17:40:55.720]  length: 1
[17:40:55.720]  elements: ‘...’
[17:40:55.720]  length: 0 (resolved future 1)
[17:40:55.720] resolve() on list ... DONE
[17:40:55.720]    - '...' content: [n=0] 
[17:40:55.721] List of 1
[17:40:55.721]  $ ...: list()
[17:40:55.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.721]  - attr(*, "where")=List of 1
[17:40:55.721]   ..$ ...:<environment: 0x564f300213e0> 
[17:40:55.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.721]  - attr(*, "resolved")= logi TRUE
[17:40:55.721]  - attr(*, "total_size")= num NA
[17:40:55.725]  - Getting '...' globals ... DONE
[17:40:55.726] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:40:55.726] List of 2
[17:40:55.726]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:40:55.726]  $ ...          : list()
[17:40:55.726]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.726]  - attr(*, "where")=List of 2
[17:40:55.726]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.726]   ..$ ...          :<environment: 0x564f300213e0> 
[17:40:55.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.726]  - attr(*, "resolved")= logi FALSE
[17:40:55.726]  - attr(*, "total_size")= num 46960
[17:40:55.729] Packages to be attached in all futures: [n=1] ‘stats’
[17:40:55.729] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.729] Number of futures (= number of chunks): 2
[17:40:55.729] Launching 2 futures (chunks) ...
[17:40:55.729] Chunk #1 of 2 ...
[17:40:55.729]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.730] getGlobalsAndPackages() ...
[17:40:55.730] Searching for globals...
[17:40:55.730] 
[17:40:55.730] Searching for globals ... DONE
[17:40:55.730] - globals: [0] <none>
[17:40:55.730] getGlobalsAndPackages() ... DONE
[17:40:55.730]    + additional globals found: [n=0] 
[17:40:55.730]    + additional namespaces needed: [n=0] 
[17:40:55.730]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.731]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[17:40:55.731]  - seeds: <none>
[17:40:55.731] getGlobalsAndPackages() ...
[17:40:55.731] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.731] Resolving globals: FALSE
[17:40:55.731] Tweak future expression to call with '...' arguments ...
[17:40:55.731] {
[17:40:55.731]     do.call(function(...) {
[17:40:55.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.731]             on.exit(options(oopts), add = TRUE)
[17:40:55.731]         }
[17:40:55.731]         {
[17:40:55.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.731]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.731]             })
[17:40:55.731]         }
[17:40:55.731]     }, args = future.call.arguments)
[17:40:55.731] }
[17:40:55.732] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.732] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.732] - packages: [1] ‘stats’
[17:40:55.732] getGlobalsAndPackages() ... DONE
[17:40:55.732] run() for ‘Future’ ...
[17:40:55.733] - state: ‘created’
[17:40:55.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.736] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.737]   - Field: ‘label’
[17:40:55.737]   - Field: ‘local’
[17:40:55.737]   - Field: ‘owner’
[17:40:55.737]   - Field: ‘envir’
[17:40:55.737]   - Field: ‘workers’
[17:40:55.737]   - Field: ‘packages’
[17:40:55.737]   - Field: ‘gc’
[17:40:55.737]   - Field: ‘job’
[17:40:55.737]   - Field: ‘conditions’
[17:40:55.738]   - Field: ‘expr’
[17:40:55.738]   - Field: ‘uuid’
[17:40:55.738]   - Field: ‘seed’
[17:40:55.738]   - Field: ‘version’
[17:40:55.738]   - Field: ‘result’
[17:40:55.738]   - Field: ‘asynchronous’
[17:40:55.738]   - Field: ‘calls’
[17:40:55.738]   - Field: ‘globals’
[17:40:55.738]   - Field: ‘stdout’
[17:40:55.738]   - Field: ‘earlySignal’
[17:40:55.738]   - Field: ‘lazy’
[17:40:55.739]   - Field: ‘state’
[17:40:55.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.739] - Launch lazy future ...
[17:40:55.739] Packages needed by the future expression (n = 1): ‘stats’
[17:40:55.739] Packages needed by future strategies (n = 0): <none>
[17:40:55.740] {
[17:40:55.740]     {
[17:40:55.740]         {
[17:40:55.740]             ...future.startTime <- base::Sys.time()
[17:40:55.740]             {
[17:40:55.740]                 {
[17:40:55.740]                   {
[17:40:55.740]                     {
[17:40:55.740]                       {
[17:40:55.740]                         base::local({
[17:40:55.740]                           has_future <- base::requireNamespace("future", 
[17:40:55.740]                             quietly = TRUE)
[17:40:55.740]                           if (has_future) {
[17:40:55.740]                             ns <- base::getNamespace("future")
[17:40:55.740]                             version <- ns[[".package"]][["version"]]
[17:40:55.740]                             if (is.null(version)) 
[17:40:55.740]                               version <- utils::packageVersion("future")
[17:40:55.740]                           }
[17:40:55.740]                           else {
[17:40:55.740]                             version <- NULL
[17:40:55.740]                           }
[17:40:55.740]                           if (!has_future || version < "1.8.0") {
[17:40:55.740]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.740]                               "", base::R.version$version.string), 
[17:40:55.740]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.740]                                 base::R.version$platform, 8 * 
[17:40:55.740]                                   base::.Machine$sizeof.pointer), 
[17:40:55.740]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.740]                                 "release", "version")], collapse = " "), 
[17:40:55.740]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.740]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.740]                               info)
[17:40:55.740]                             info <- base::paste(info, collapse = "; ")
[17:40:55.740]                             if (!has_future) {
[17:40:55.740]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.740]                                 info)
[17:40:55.740]                             }
[17:40:55.740]                             else {
[17:40:55.740]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.740]                                 info, version)
[17:40:55.740]                             }
[17:40:55.740]                             base::stop(msg)
[17:40:55.740]                           }
[17:40:55.740]                         })
[17:40:55.740]                       }
[17:40:55.740]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.740]                       base::options(mc.cores = 1L)
[17:40:55.740]                     }
[17:40:55.740]                     base::local({
[17:40:55.740]                       for (pkg in "stats") {
[17:40:55.740]                         base::loadNamespace(pkg)
[17:40:55.740]                         base::library(pkg, character.only = TRUE)
[17:40:55.740]                       }
[17:40:55.740]                     })
[17:40:55.740]                   }
[17:40:55.740]                   options(future.plan = NULL)
[17:40:55.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.740]                 }
[17:40:55.740]                 ...future.workdir <- getwd()
[17:40:55.740]             }
[17:40:55.740]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.740]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.740]         }
[17:40:55.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.740]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[17:40:55.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.740]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.740]             base::names(...future.oldOptions))
[17:40:55.740]     }
[17:40:55.740]     if (FALSE) {
[17:40:55.740]     }
[17:40:55.740]     else {
[17:40:55.740]         if (TRUE) {
[17:40:55.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.740]                 open = "w")
[17:40:55.740]         }
[17:40:55.740]         else {
[17:40:55.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.740]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.740]         }
[17:40:55.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.740]             base::sink(type = "output", split = FALSE)
[17:40:55.740]             base::close(...future.stdout)
[17:40:55.740]         }, add = TRUE)
[17:40:55.740]     }
[17:40:55.740]     ...future.frame <- base::sys.nframe()
[17:40:55.740]     ...future.conditions <- base::list()
[17:40:55.740]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.740]     if (FALSE) {
[17:40:55.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.740]     }
[17:40:55.740]     ...future.result <- base::tryCatch({
[17:40:55.740]         base::withCallingHandlers({
[17:40:55.740]             ...future.value <- base::withVisible(base::local({
[17:40:55.740]                 withCallingHandlers({
[17:40:55.740]                   {
[17:40:55.740]                     do.call(function(...) {
[17:40:55.740]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.740]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.740]                         ...future.globals.maxSize)) {
[17:40:55.740]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.740]                         on.exit(options(oopts), add = TRUE)
[17:40:55.740]                       }
[17:40:55.740]                       {
[17:40:55.740]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.740]                           FUN = function(jj) {
[17:40:55.740]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.740]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.740]                           })
[17:40:55.740]                       }
[17:40:55.740]                     }, args = future.call.arguments)
[17:40:55.740]                   }
[17:40:55.740]                 }, immediateCondition = function(cond) {
[17:40:55.740]                   save_rds <- function (object, pathname, ...) 
[17:40:55.740]                   {
[17:40:55.740]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.740]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.740]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.740]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.740]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.740]                         fi_tmp[["mtime"]])
[17:40:55.740]                     }
[17:40:55.740]                     tryCatch({
[17:40:55.740]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.740]                     }, error = function(ex) {
[17:40:55.740]                       msg <- conditionMessage(ex)
[17:40:55.740]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.740]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.740]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.740]                         fi_tmp[["mtime"]], msg)
[17:40:55.740]                       ex$message <- msg
[17:40:55.740]                       stop(ex)
[17:40:55.740]                     })
[17:40:55.740]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.740]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.740]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.740]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.740]                       fi <- file.info(pathname)
[17:40:55.740]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.740]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.740]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.740]                         fi[["size"]], fi[["mtime"]])
[17:40:55.740]                       stop(msg)
[17:40:55.740]                     }
[17:40:55.740]                     invisible(pathname)
[17:40:55.740]                   }
[17:40:55.740]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.740]                     rootPath = tempdir()) 
[17:40:55.740]                   {
[17:40:55.740]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.740]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.740]                       tmpdir = path, fileext = ".rds")
[17:40:55.740]                     save_rds(obj, file)
[17:40:55.740]                   }
[17:40:55.740]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.740]                   {
[17:40:55.740]                     inherits <- base::inherits
[17:40:55.740]                     invokeRestart <- base::invokeRestart
[17:40:55.740]                     is.null <- base::is.null
[17:40:55.740]                     muffled <- FALSE
[17:40:55.740]                     if (inherits(cond, "message")) {
[17:40:55.740]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.740]                       if (muffled) 
[17:40:55.740]                         invokeRestart("muffleMessage")
[17:40:55.740]                     }
[17:40:55.740]                     else if (inherits(cond, "warning")) {
[17:40:55.740]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.740]                       if (muffled) 
[17:40:55.740]                         invokeRestart("muffleWarning")
[17:40:55.740]                     }
[17:40:55.740]                     else if (inherits(cond, "condition")) {
[17:40:55.740]                       if (!is.null(pattern)) {
[17:40:55.740]                         computeRestarts <- base::computeRestarts
[17:40:55.740]                         grepl <- base::grepl
[17:40:55.740]                         restarts <- computeRestarts(cond)
[17:40:55.740]                         for (restart in restarts) {
[17:40:55.740]                           name <- restart$name
[17:40:55.740]                           if (is.null(name)) 
[17:40:55.740]                             next
[17:40:55.740]                           if (!grepl(pattern, name)) 
[17:40:55.740]                             next
[17:40:55.740]                           invokeRestart(restart)
[17:40:55.740]                           muffled <- TRUE
[17:40:55.740]                           break
[17:40:55.740]                         }
[17:40:55.740]                       }
[17:40:55.740]                     }
[17:40:55.740]                     invisible(muffled)
[17:40:55.740]                   }
[17:40:55.740]                   muffleCondition(cond)
[17:40:55.740]                 })
[17:40:55.740]             }))
[17:40:55.740]             future::FutureResult(value = ...future.value$value, 
[17:40:55.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.740]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.740]                     ...future.globalenv.names))
[17:40:55.740]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.740]         }, condition = base::local({
[17:40:55.740]             c <- base::c
[17:40:55.740]             inherits <- base::inherits
[17:40:55.740]             invokeRestart <- base::invokeRestart
[17:40:55.740]             length <- base::length
[17:40:55.740]             list <- base::list
[17:40:55.740]             seq.int <- base::seq.int
[17:40:55.740]             signalCondition <- base::signalCondition
[17:40:55.740]             sys.calls <- base::sys.calls
[17:40:55.740]             `[[` <- base::`[[`
[17:40:55.740]             `+` <- base::`+`
[17:40:55.740]             `<<-` <- base::`<<-`
[17:40:55.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.740]                   3L)]
[17:40:55.740]             }
[17:40:55.740]             function(cond) {
[17:40:55.740]                 is_error <- inherits(cond, "error")
[17:40:55.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.740]                   NULL)
[17:40:55.740]                 if (is_error) {
[17:40:55.740]                   sessionInformation <- function() {
[17:40:55.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.740]                       search = base::search(), system = base::Sys.info())
[17:40:55.740]                   }
[17:40:55.740]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.740]                     cond$call), session = sessionInformation(), 
[17:40:55.740]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.740]                   signalCondition(cond)
[17:40:55.740]                 }
[17:40:55.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.740]                 "immediateCondition"))) {
[17:40:55.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.740]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.740]                   if (TRUE && !signal) {
[17:40:55.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.740]                     {
[17:40:55.740]                       inherits <- base::inherits
[17:40:55.740]                       invokeRestart <- base::invokeRestart
[17:40:55.740]                       is.null <- base::is.null
[17:40:55.740]                       muffled <- FALSE
[17:40:55.740]                       if (inherits(cond, "message")) {
[17:40:55.740]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.740]                         if (muffled) 
[17:40:55.740]                           invokeRestart("muffleMessage")
[17:40:55.740]                       }
[17:40:55.740]                       else if (inherits(cond, "warning")) {
[17:40:55.740]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.740]                         if (muffled) 
[17:40:55.740]                           invokeRestart("muffleWarning")
[17:40:55.740]                       }
[17:40:55.740]                       else if (inherits(cond, "condition")) {
[17:40:55.740]                         if (!is.null(pattern)) {
[17:40:55.740]                           computeRestarts <- base::computeRestarts
[17:40:55.740]                           grepl <- base::grepl
[17:40:55.740]                           restarts <- computeRestarts(cond)
[17:40:55.740]                           for (restart in restarts) {
[17:40:55.740]                             name <- restart$name
[17:40:55.740]                             if (is.null(name)) 
[17:40:55.740]                               next
[17:40:55.740]                             if (!grepl(pattern, name)) 
[17:40:55.740]                               next
[17:40:55.740]                             invokeRestart(restart)
[17:40:55.740]                             muffled <- TRUE
[17:40:55.740]                             break
[17:40:55.740]                           }
[17:40:55.740]                         }
[17:40:55.740]                       }
[17:40:55.740]                       invisible(muffled)
[17:40:55.740]                     }
[17:40:55.740]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.740]                   }
[17:40:55.740]                 }
[17:40:55.740]                 else {
[17:40:55.740]                   if (TRUE) {
[17:40:55.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.740]                     {
[17:40:55.740]                       inherits <- base::inherits
[17:40:55.740]                       invokeRestart <- base::invokeRestart
[17:40:55.740]                       is.null <- base::is.null
[17:40:55.740]                       muffled <- FALSE
[17:40:55.740]                       if (inherits(cond, "message")) {
[17:40:55.740]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.740]                         if (muffled) 
[17:40:55.740]                           invokeRestart("muffleMessage")
[17:40:55.740]                       }
[17:40:55.740]                       else if (inherits(cond, "warning")) {
[17:40:55.740]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.740]                         if (muffled) 
[17:40:55.740]                           invokeRestart("muffleWarning")
[17:40:55.740]                       }
[17:40:55.740]                       else if (inherits(cond, "condition")) {
[17:40:55.740]                         if (!is.null(pattern)) {
[17:40:55.740]                           computeRestarts <- base::computeRestarts
[17:40:55.740]                           grepl <- base::grepl
[17:40:55.740]                           restarts <- computeRestarts(cond)
[17:40:55.740]                           for (restart in restarts) {
[17:40:55.740]                             name <- restart$name
[17:40:55.740]                             if (is.null(name)) 
[17:40:55.740]                               next
[17:40:55.740]                             if (!grepl(pattern, name)) 
[17:40:55.740]                               next
[17:40:55.740]                             invokeRestart(restart)
[17:40:55.740]                             muffled <- TRUE
[17:40:55.740]                             break
[17:40:55.740]                           }
[17:40:55.740]                         }
[17:40:55.740]                       }
[17:40:55.740]                       invisible(muffled)
[17:40:55.740]                     }
[17:40:55.740]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.740]                   }
[17:40:55.740]                 }
[17:40:55.740]             }
[17:40:55.740]         }))
[17:40:55.740]     }, error = function(ex) {
[17:40:55.740]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.740]                 ...future.rng), started = ...future.startTime, 
[17:40:55.740]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.740]             version = "1.8"), class = "FutureResult")
[17:40:55.740]     }, finally = {
[17:40:55.740]         if (!identical(...future.workdir, getwd())) 
[17:40:55.740]             setwd(...future.workdir)
[17:40:55.740]         {
[17:40:55.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.740]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.740]             }
[17:40:55.740]             base::options(...future.oldOptions)
[17:40:55.740]             if (.Platform$OS.type == "windows") {
[17:40:55.740]                 old_names <- names(...future.oldEnvVars)
[17:40:55.740]                 envs <- base::Sys.getenv()
[17:40:55.740]                 names <- names(envs)
[17:40:55.740]                 common <- intersect(names, old_names)
[17:40:55.740]                 added <- setdiff(names, old_names)
[17:40:55.740]                 removed <- setdiff(old_names, names)
[17:40:55.740]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.740]                   envs[common]]
[17:40:55.740]                 NAMES <- toupper(changed)
[17:40:55.740]                 args <- list()
[17:40:55.740]                 for (kk in seq_along(NAMES)) {
[17:40:55.740]                   name <- changed[[kk]]
[17:40:55.740]                   NAME <- NAMES[[kk]]
[17:40:55.740]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.740]                     next
[17:40:55.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.740]                 }
[17:40:55.740]                 NAMES <- toupper(added)
[17:40:55.740]                 for (kk in seq_along(NAMES)) {
[17:40:55.740]                   name <- added[[kk]]
[17:40:55.740]                   NAME <- NAMES[[kk]]
[17:40:55.740]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.740]                     next
[17:40:55.740]                   args[[name]] <- ""
[17:40:55.740]                 }
[17:40:55.740]                 NAMES <- toupper(removed)
[17:40:55.740]                 for (kk in seq_along(NAMES)) {
[17:40:55.740]                   name <- removed[[kk]]
[17:40:55.740]                   NAME <- NAMES[[kk]]
[17:40:55.740]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.740]                     next
[17:40:55.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.740]                 }
[17:40:55.740]                 if (length(args) > 0) 
[17:40:55.740]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.740]             }
[17:40:55.740]             else {
[17:40:55.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.740]             }
[17:40:55.740]             {
[17:40:55.740]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.740]                   0L) {
[17:40:55.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.740]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.740]                   base::options(opts)
[17:40:55.740]                 }
[17:40:55.740]                 {
[17:40:55.740]                   {
[17:40:55.740]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.740]                     NULL
[17:40:55.740]                   }
[17:40:55.740]                   options(future.plan = NULL)
[17:40:55.740]                   if (is.na(NA_character_)) 
[17:40:55.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.740]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.740]                     envir = parent.frame()) 
[17:40:55.740]                   {
[17:40:55.740]                     default_workers <- missing(workers)
[17:40:55.740]                     if (is.function(workers)) 
[17:40:55.740]                       workers <- workers()
[17:40:55.740]                     workers <- structure(as.integer(workers), 
[17:40:55.740]                       class = class(workers))
[17:40:55.740]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.740]                       1L)
[17:40:55.740]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.740]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.740]                       if (default_workers) 
[17:40:55.740]                         supportsMulticore(warn = TRUE)
[17:40:55.740]                       return(sequential(..., envir = envir))
[17:40:55.740]                     }
[17:40:55.740]                     oopts <- options(mc.cores = workers)
[17:40:55.740]                     on.exit(options(oopts))
[17:40:55.740]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.740]                       envir = envir)
[17:40:55.740]                     if (!future$lazy) 
[17:40:55.740]                       future <- run(future)
[17:40:55.740]                     invisible(future)
[17:40:55.740]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.740]                 }
[17:40:55.740]             }
[17:40:55.740]         }
[17:40:55.740]     })
[17:40:55.740]     if (TRUE) {
[17:40:55.740]         base::sink(type = "output", split = FALSE)
[17:40:55.740]         if (TRUE) {
[17:40:55.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.740]         }
[17:40:55.740]         else {
[17:40:55.740]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.740]         }
[17:40:55.740]         base::close(...future.stdout)
[17:40:55.740]         ...future.stdout <- NULL
[17:40:55.740]     }
[17:40:55.740]     ...future.result$conditions <- ...future.conditions
[17:40:55.740]     ...future.result$finished <- base::Sys.time()
[17:40:55.740]     ...future.result
[17:40:55.740] }
[17:40:55.743] assign_globals() ...
[17:40:55.743] List of 5
[17:40:55.743]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:40:55.743]  $ future.call.arguments    : list()
[17:40:55.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.743]  $ ...future.elements_ii    :List of 4
[17:40:55.743]   ..$ : int [1:3] 1 2 3
[17:40:55.743]   ..$ : int [1:4] 1 2 3 4
[17:40:55.743]   ..$ : int [1:5] 1 2 3 4 5
[17:40:55.743]   ..$ : int [1:6] 1 2 3 4 5 6
[17:40:55.743]  $ ...future.seeds_ii       : NULL
[17:40:55.743]  $ ...future.globals.maxSize: NULL
[17:40:55.743]  - attr(*, "resolved")= logi FALSE
[17:40:55.743]  - attr(*, "total_size")= num 46960
[17:40:55.743]  - attr(*, "where")=List of 5
[17:40:55.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.743]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.743]  - attr(*, "already-done")= logi TRUE
[17:40:55.750] - copied ‘...future.FUN’ to environment
[17:40:55.750] - copied ‘future.call.arguments’ to environment
[17:40:55.751] - copied ‘...future.elements_ii’ to environment
[17:40:55.751] - copied ‘...future.seeds_ii’ to environment
[17:40:55.751] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.751] assign_globals() ... done
[17:40:55.751] requestCore(): workers = 2
[17:40:55.753] MulticoreFuture started
[17:40:55.754] - Launch lazy future ... done
[17:40:55.755] run() for ‘MulticoreFuture’ ... done
[17:40:55.755] Created future:
[17:40:55.755] plan(): Setting new future strategy stack:
[17:40:55.756] List of future strategies:
[17:40:55.756] 1. sequential:
[17:40:55.756]    - args: function (..., envir = parent.frame())
[17:40:55.756]    - tweaked: FALSE
[17:40:55.756]    - call: NULL
[17:40:55.757] plan(): nbrOfWorkers() = 1
[17:40:55.760] plan(): Setting new future strategy stack:
[17:40:55.760] List of future strategies:
[17:40:55.760] 1. multicore:
[17:40:55.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.760]    - tweaked: FALSE
[17:40:55.760]    - call: plan(strategy)
[17:40:55.766] plan(): nbrOfWorkers() = 2
[17:40:55.756] MulticoreFuture:
[17:40:55.756] Label: ‘future_sapply-1’
[17:40:55.756] Expression:
[17:40:55.756] {
[17:40:55.756]     do.call(function(...) {
[17:40:55.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.756]             on.exit(options(oopts), add = TRUE)
[17:40:55.756]         }
[17:40:55.756]         {
[17:40:55.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.756]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.756]             })
[17:40:55.756]         }
[17:40:55.756]     }, args = future.call.arguments)
[17:40:55.756] }
[17:40:55.756] Lazy evaluation: FALSE
[17:40:55.756] Asynchronous evaluation: TRUE
[17:40:55.756] Local evaluation: TRUE
[17:40:55.756] Environment: R_GlobalEnv
[17:40:55.756] Capture standard output: TRUE
[17:40:55.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.756] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:40:55.756] Packages: 1 packages (‘stats’)
[17:40:55.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.756] Resolved: TRUE
[17:40:55.756] Value: <not collected>
[17:40:55.756] Conditions captured: <none>
[17:40:55.756] Early signaling: FALSE
[17:40:55.756] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.756] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.768] Chunk #1 of 2 ... DONE
[17:40:55.768] Chunk #2 of 2 ...
[17:40:55.768]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.768] getGlobalsAndPackages() ...
[17:40:55.769] Searching for globals...
[17:40:55.769] 
[17:40:55.769] Searching for globals ... DONE
[17:40:55.770] - globals: [0] <none>
[17:40:55.770] getGlobalsAndPackages() ... DONE
[17:40:55.770]    + additional globals found: [n=0] 
[17:40:55.770]    + additional namespaces needed: [n=0] 
[17:40:55.770]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.770]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:40:55.770]  - seeds: <none>
[17:40:55.771] getGlobalsAndPackages() ...
[17:40:55.771] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.771] Resolving globals: FALSE
[17:40:55.771] Tweak future expression to call with '...' arguments ...
[17:40:55.771] {
[17:40:55.771]     do.call(function(...) {
[17:40:55.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.771]             on.exit(options(oopts), add = TRUE)
[17:40:55.771]         }
[17:40:55.771]         {
[17:40:55.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.771]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.771]             })
[17:40:55.771]         }
[17:40:55.771]     }, args = future.call.arguments)
[17:40:55.771] }
[17:40:55.772] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.773] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.773] - packages: [1] ‘stats’
[17:40:55.773] getGlobalsAndPackages() ... DONE
[17:40:55.774] run() for ‘Future’ ...
[17:40:55.774] - state: ‘created’
[17:40:55.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.779] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.780]   - Field: ‘label’
[17:40:55.780]   - Field: ‘local’
[17:40:55.780]   - Field: ‘owner’
[17:40:55.780]   - Field: ‘envir’
[17:40:55.780]   - Field: ‘workers’
[17:40:55.781]   - Field: ‘packages’
[17:40:55.781]   - Field: ‘gc’
[17:40:55.781]   - Field: ‘job’
[17:40:55.781]   - Field: ‘conditions’
[17:40:55.781]   - Field: ‘expr’
[17:40:55.781]   - Field: ‘uuid’
[17:40:55.781]   - Field: ‘seed’
[17:40:55.781]   - Field: ‘version’
[17:40:55.782]   - Field: ‘result’
[17:40:55.782]   - Field: ‘asynchronous’
[17:40:55.782]   - Field: ‘calls’
[17:40:55.782]   - Field: ‘globals’
[17:40:55.782]   - Field: ‘stdout’
[17:40:55.782]   - Field: ‘earlySignal’
[17:40:55.783]   - Field: ‘lazy’
[17:40:55.783]   - Field: ‘state’
[17:40:55.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.783] - Launch lazy future ...
[17:40:55.783] Packages needed by the future expression (n = 1): ‘stats’
[17:40:55.783] Packages needed by future strategies (n = 0): <none>
[17:40:55.784] {
[17:40:55.784]     {
[17:40:55.784]         {
[17:40:55.784]             ...future.startTime <- base::Sys.time()
[17:40:55.784]             {
[17:40:55.784]                 {
[17:40:55.784]                   {
[17:40:55.784]                     {
[17:40:55.784]                       {
[17:40:55.784]                         base::local({
[17:40:55.784]                           has_future <- base::requireNamespace("future", 
[17:40:55.784]                             quietly = TRUE)
[17:40:55.784]                           if (has_future) {
[17:40:55.784]                             ns <- base::getNamespace("future")
[17:40:55.784]                             version <- ns[[".package"]][["version"]]
[17:40:55.784]                             if (is.null(version)) 
[17:40:55.784]                               version <- utils::packageVersion("future")
[17:40:55.784]                           }
[17:40:55.784]                           else {
[17:40:55.784]                             version <- NULL
[17:40:55.784]                           }
[17:40:55.784]                           if (!has_future || version < "1.8.0") {
[17:40:55.784]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.784]                               "", base::R.version$version.string), 
[17:40:55.784]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.784]                                 base::R.version$platform, 8 * 
[17:40:55.784]                                   base::.Machine$sizeof.pointer), 
[17:40:55.784]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.784]                                 "release", "version")], collapse = " "), 
[17:40:55.784]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.784]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.784]                               info)
[17:40:55.784]                             info <- base::paste(info, collapse = "; ")
[17:40:55.784]                             if (!has_future) {
[17:40:55.784]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.784]                                 info)
[17:40:55.784]                             }
[17:40:55.784]                             else {
[17:40:55.784]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.784]                                 info, version)
[17:40:55.784]                             }
[17:40:55.784]                             base::stop(msg)
[17:40:55.784]                           }
[17:40:55.784]                         })
[17:40:55.784]                       }
[17:40:55.784]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.784]                       base::options(mc.cores = 1L)
[17:40:55.784]                     }
[17:40:55.784]                     base::local({
[17:40:55.784]                       for (pkg in "stats") {
[17:40:55.784]                         base::loadNamespace(pkg)
[17:40:55.784]                         base::library(pkg, character.only = TRUE)
[17:40:55.784]                       }
[17:40:55.784]                     })
[17:40:55.784]                   }
[17:40:55.784]                   options(future.plan = NULL)
[17:40:55.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.784]                 }
[17:40:55.784]                 ...future.workdir <- getwd()
[17:40:55.784]             }
[17:40:55.784]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.784]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.784]         }
[17:40:55.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.784]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:40:55.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.784]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.784]             base::names(...future.oldOptions))
[17:40:55.784]     }
[17:40:55.784]     if (FALSE) {
[17:40:55.784]     }
[17:40:55.784]     else {
[17:40:55.784]         if (TRUE) {
[17:40:55.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.784]                 open = "w")
[17:40:55.784]         }
[17:40:55.784]         else {
[17:40:55.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.784]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.784]         }
[17:40:55.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.784]             base::sink(type = "output", split = FALSE)
[17:40:55.784]             base::close(...future.stdout)
[17:40:55.784]         }, add = TRUE)
[17:40:55.784]     }
[17:40:55.784]     ...future.frame <- base::sys.nframe()
[17:40:55.784]     ...future.conditions <- base::list()
[17:40:55.784]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.784]     if (FALSE) {
[17:40:55.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.784]     }
[17:40:55.784]     ...future.result <- base::tryCatch({
[17:40:55.784]         base::withCallingHandlers({
[17:40:55.784]             ...future.value <- base::withVisible(base::local({
[17:40:55.784]                 withCallingHandlers({
[17:40:55.784]                   {
[17:40:55.784]                     do.call(function(...) {
[17:40:55.784]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.784]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.784]                         ...future.globals.maxSize)) {
[17:40:55.784]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.784]                         on.exit(options(oopts), add = TRUE)
[17:40:55.784]                       }
[17:40:55.784]                       {
[17:40:55.784]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.784]                           FUN = function(jj) {
[17:40:55.784]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.784]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.784]                           })
[17:40:55.784]                       }
[17:40:55.784]                     }, args = future.call.arguments)
[17:40:55.784]                   }
[17:40:55.784]                 }, immediateCondition = function(cond) {
[17:40:55.784]                   save_rds <- function (object, pathname, ...) 
[17:40:55.784]                   {
[17:40:55.784]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.784]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.784]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.784]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.784]                         fi_tmp[["mtime"]])
[17:40:55.784]                     }
[17:40:55.784]                     tryCatch({
[17:40:55.784]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.784]                     }, error = function(ex) {
[17:40:55.784]                       msg <- conditionMessage(ex)
[17:40:55.784]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.784]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.784]                         fi_tmp[["mtime"]], msg)
[17:40:55.784]                       ex$message <- msg
[17:40:55.784]                       stop(ex)
[17:40:55.784]                     })
[17:40:55.784]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.784]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.784]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.784]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.784]                       fi <- file.info(pathname)
[17:40:55.784]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.784]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.784]                         fi[["size"]], fi[["mtime"]])
[17:40:55.784]                       stop(msg)
[17:40:55.784]                     }
[17:40:55.784]                     invisible(pathname)
[17:40:55.784]                   }
[17:40:55.784]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.784]                     rootPath = tempdir()) 
[17:40:55.784]                   {
[17:40:55.784]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.784]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.784]                       tmpdir = path, fileext = ".rds")
[17:40:55.784]                     save_rds(obj, file)
[17:40:55.784]                   }
[17:40:55.784]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.784]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.784]                   {
[17:40:55.784]                     inherits <- base::inherits
[17:40:55.784]                     invokeRestart <- base::invokeRestart
[17:40:55.784]                     is.null <- base::is.null
[17:40:55.784]                     muffled <- FALSE
[17:40:55.784]                     if (inherits(cond, "message")) {
[17:40:55.784]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.784]                       if (muffled) 
[17:40:55.784]                         invokeRestart("muffleMessage")
[17:40:55.784]                     }
[17:40:55.784]                     else if (inherits(cond, "warning")) {
[17:40:55.784]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.784]                       if (muffled) 
[17:40:55.784]                         invokeRestart("muffleWarning")
[17:40:55.784]                     }
[17:40:55.784]                     else if (inherits(cond, "condition")) {
[17:40:55.784]                       if (!is.null(pattern)) {
[17:40:55.784]                         computeRestarts <- base::computeRestarts
[17:40:55.784]                         grepl <- base::grepl
[17:40:55.784]                         restarts <- computeRestarts(cond)
[17:40:55.784]                         for (restart in restarts) {
[17:40:55.784]                           name <- restart$name
[17:40:55.784]                           if (is.null(name)) 
[17:40:55.784]                             next
[17:40:55.784]                           if (!grepl(pattern, name)) 
[17:40:55.784]                             next
[17:40:55.784]                           invokeRestart(restart)
[17:40:55.784]                           muffled <- TRUE
[17:40:55.784]                           break
[17:40:55.784]                         }
[17:40:55.784]                       }
[17:40:55.784]                     }
[17:40:55.784]                     invisible(muffled)
[17:40:55.784]                   }
[17:40:55.784]                   muffleCondition(cond)
[17:40:55.784]                 })
[17:40:55.784]             }))
[17:40:55.784]             future::FutureResult(value = ...future.value$value, 
[17:40:55.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.784]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.784]                     ...future.globalenv.names))
[17:40:55.784]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.784]         }, condition = base::local({
[17:40:55.784]             c <- base::c
[17:40:55.784]             inherits <- base::inherits
[17:40:55.784]             invokeRestart <- base::invokeRestart
[17:40:55.784]             length <- base::length
[17:40:55.784]             list <- base::list
[17:40:55.784]             seq.int <- base::seq.int
[17:40:55.784]             signalCondition <- base::signalCondition
[17:40:55.784]             sys.calls <- base::sys.calls
[17:40:55.784]             `[[` <- base::`[[`
[17:40:55.784]             `+` <- base::`+`
[17:40:55.784]             `<<-` <- base::`<<-`
[17:40:55.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.784]                   3L)]
[17:40:55.784]             }
[17:40:55.784]             function(cond) {
[17:40:55.784]                 is_error <- inherits(cond, "error")
[17:40:55.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.784]                   NULL)
[17:40:55.784]                 if (is_error) {
[17:40:55.784]                   sessionInformation <- function() {
[17:40:55.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.784]                       search = base::search(), system = base::Sys.info())
[17:40:55.784]                   }
[17:40:55.784]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.784]                     cond$call), session = sessionInformation(), 
[17:40:55.784]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.784]                   signalCondition(cond)
[17:40:55.784]                 }
[17:40:55.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.784]                 "immediateCondition"))) {
[17:40:55.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.784]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.784]                   if (TRUE && !signal) {
[17:40:55.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.784]                     {
[17:40:55.784]                       inherits <- base::inherits
[17:40:55.784]                       invokeRestart <- base::invokeRestart
[17:40:55.784]                       is.null <- base::is.null
[17:40:55.784]                       muffled <- FALSE
[17:40:55.784]                       if (inherits(cond, "message")) {
[17:40:55.784]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.784]                         if (muffled) 
[17:40:55.784]                           invokeRestart("muffleMessage")
[17:40:55.784]                       }
[17:40:55.784]                       else if (inherits(cond, "warning")) {
[17:40:55.784]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.784]                         if (muffled) 
[17:40:55.784]                           invokeRestart("muffleWarning")
[17:40:55.784]                       }
[17:40:55.784]                       else if (inherits(cond, "condition")) {
[17:40:55.784]                         if (!is.null(pattern)) {
[17:40:55.784]                           computeRestarts <- base::computeRestarts
[17:40:55.784]                           grepl <- base::grepl
[17:40:55.784]                           restarts <- computeRestarts(cond)
[17:40:55.784]                           for (restart in restarts) {
[17:40:55.784]                             name <- restart$name
[17:40:55.784]                             if (is.null(name)) 
[17:40:55.784]                               next
[17:40:55.784]                             if (!grepl(pattern, name)) 
[17:40:55.784]                               next
[17:40:55.784]                             invokeRestart(restart)
[17:40:55.784]                             muffled <- TRUE
[17:40:55.784]                             break
[17:40:55.784]                           }
[17:40:55.784]                         }
[17:40:55.784]                       }
[17:40:55.784]                       invisible(muffled)
[17:40:55.784]                     }
[17:40:55.784]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.784]                   }
[17:40:55.784]                 }
[17:40:55.784]                 else {
[17:40:55.784]                   if (TRUE) {
[17:40:55.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.784]                     {
[17:40:55.784]                       inherits <- base::inherits
[17:40:55.784]                       invokeRestart <- base::invokeRestart
[17:40:55.784]                       is.null <- base::is.null
[17:40:55.784]                       muffled <- FALSE
[17:40:55.784]                       if (inherits(cond, "message")) {
[17:40:55.784]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.784]                         if (muffled) 
[17:40:55.784]                           invokeRestart("muffleMessage")
[17:40:55.784]                       }
[17:40:55.784]                       else if (inherits(cond, "warning")) {
[17:40:55.784]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.784]                         if (muffled) 
[17:40:55.784]                           invokeRestart("muffleWarning")
[17:40:55.784]                       }
[17:40:55.784]                       else if (inherits(cond, "condition")) {
[17:40:55.784]                         if (!is.null(pattern)) {
[17:40:55.784]                           computeRestarts <- base::computeRestarts
[17:40:55.784]                           grepl <- base::grepl
[17:40:55.784]                           restarts <- computeRestarts(cond)
[17:40:55.784]                           for (restart in restarts) {
[17:40:55.784]                             name <- restart$name
[17:40:55.784]                             if (is.null(name)) 
[17:40:55.784]                               next
[17:40:55.784]                             if (!grepl(pattern, name)) 
[17:40:55.784]                               next
[17:40:55.784]                             invokeRestart(restart)
[17:40:55.784]                             muffled <- TRUE
[17:40:55.784]                             break
[17:40:55.784]                           }
[17:40:55.784]                         }
[17:40:55.784]                       }
[17:40:55.784]                       invisible(muffled)
[17:40:55.784]                     }
[17:40:55.784]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.784]                   }
[17:40:55.784]                 }
[17:40:55.784]             }
[17:40:55.784]         }))
[17:40:55.784]     }, error = function(ex) {
[17:40:55.784]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.784]                 ...future.rng), started = ...future.startTime, 
[17:40:55.784]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.784]             version = "1.8"), class = "FutureResult")
[17:40:55.784]     }, finally = {
[17:40:55.784]         if (!identical(...future.workdir, getwd())) 
[17:40:55.784]             setwd(...future.workdir)
[17:40:55.784]         {
[17:40:55.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.784]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.784]             }
[17:40:55.784]             base::options(...future.oldOptions)
[17:40:55.784]             if (.Platform$OS.type == "windows") {
[17:40:55.784]                 old_names <- names(...future.oldEnvVars)
[17:40:55.784]                 envs <- base::Sys.getenv()
[17:40:55.784]                 names <- names(envs)
[17:40:55.784]                 common <- intersect(names, old_names)
[17:40:55.784]                 added <- setdiff(names, old_names)
[17:40:55.784]                 removed <- setdiff(old_names, names)
[17:40:55.784]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.784]                   envs[common]]
[17:40:55.784]                 NAMES <- toupper(changed)
[17:40:55.784]                 args <- list()
[17:40:55.784]                 for (kk in seq_along(NAMES)) {
[17:40:55.784]                   name <- changed[[kk]]
[17:40:55.784]                   NAME <- NAMES[[kk]]
[17:40:55.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.784]                     next
[17:40:55.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.784]                 }
[17:40:55.784]                 NAMES <- toupper(added)
[17:40:55.784]                 for (kk in seq_along(NAMES)) {
[17:40:55.784]                   name <- added[[kk]]
[17:40:55.784]                   NAME <- NAMES[[kk]]
[17:40:55.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.784]                     next
[17:40:55.784]                   args[[name]] <- ""
[17:40:55.784]                 }
[17:40:55.784]                 NAMES <- toupper(removed)
[17:40:55.784]                 for (kk in seq_along(NAMES)) {
[17:40:55.784]                   name <- removed[[kk]]
[17:40:55.784]                   NAME <- NAMES[[kk]]
[17:40:55.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.784]                     next
[17:40:55.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.784]                 }
[17:40:55.784]                 if (length(args) > 0) 
[17:40:55.784]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.784]             }
[17:40:55.784]             else {
[17:40:55.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.784]             }
[17:40:55.784]             {
[17:40:55.784]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.784]                   0L) {
[17:40:55.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.784]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.784]                   base::options(opts)
[17:40:55.784]                 }
[17:40:55.784]                 {
[17:40:55.784]                   {
[17:40:55.784]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.784]                     NULL
[17:40:55.784]                   }
[17:40:55.784]                   options(future.plan = NULL)
[17:40:55.784]                   if (is.na(NA_character_)) 
[17:40:55.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.784]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.784]                     envir = parent.frame()) 
[17:40:55.784]                   {
[17:40:55.784]                     default_workers <- missing(workers)
[17:40:55.784]                     if (is.function(workers)) 
[17:40:55.784]                       workers <- workers()
[17:40:55.784]                     workers <- structure(as.integer(workers), 
[17:40:55.784]                       class = class(workers))
[17:40:55.784]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.784]                       1L)
[17:40:55.784]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.784]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.784]                       if (default_workers) 
[17:40:55.784]                         supportsMulticore(warn = TRUE)
[17:40:55.784]                       return(sequential(..., envir = envir))
[17:40:55.784]                     }
[17:40:55.784]                     oopts <- options(mc.cores = workers)
[17:40:55.784]                     on.exit(options(oopts))
[17:40:55.784]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.784]                       envir = envir)
[17:40:55.784]                     if (!future$lazy) 
[17:40:55.784]                       future <- run(future)
[17:40:55.784]                     invisible(future)
[17:40:55.784]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.784]                 }
[17:40:55.784]             }
[17:40:55.784]         }
[17:40:55.784]     })
[17:40:55.784]     if (TRUE) {
[17:40:55.784]         base::sink(type = "output", split = FALSE)
[17:40:55.784]         if (TRUE) {
[17:40:55.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.784]         }
[17:40:55.784]         else {
[17:40:55.784]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.784]         }
[17:40:55.784]         base::close(...future.stdout)
[17:40:55.784]         ...future.stdout <- NULL
[17:40:55.784]     }
[17:40:55.784]     ...future.result$conditions <- ...future.conditions
[17:40:55.784]     ...future.result$finished <- base::Sys.time()
[17:40:55.784]     ...future.result
[17:40:55.784] }
[17:40:55.788] assign_globals() ...
[17:40:55.788] List of 5
[17:40:55.788]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:40:55.788]  $ future.call.arguments    : list()
[17:40:55.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.788]  $ ...future.elements_ii    :List of 3
[17:40:55.788]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:40:55.788]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:40:55.788]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:40:55.788]  $ ...future.seeds_ii       : NULL
[17:40:55.788]  $ ...future.globals.maxSize: NULL
[17:40:55.788]  - attr(*, "resolved")= logi FALSE
[17:40:55.788]  - attr(*, "total_size")= num 46960
[17:40:55.788]  - attr(*, "where")=List of 5
[17:40:55.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.788]  - attr(*, "already-done")= logi TRUE
[17:40:55.798] - copied ‘...future.FUN’ to environment
[17:40:55.798] - copied ‘future.call.arguments’ to environment
[17:40:55.798] - copied ‘...future.elements_ii’ to environment
[17:40:55.799] - copied ‘...future.seeds_ii’ to environment
[17:40:55.799] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.799] assign_globals() ... done
[17:40:55.799] requestCore(): workers = 2
[17:40:55.802] MulticoreFuture started
[17:40:55.802] - Launch lazy future ... done
[17:40:55.803] run() for ‘MulticoreFuture’ ... done
[17:40:55.803] Created future:
[17:40:55.804] plan(): Setting new future strategy stack:
[17:40:55.804] List of future strategies:
[17:40:55.804] 1. sequential:
[17:40:55.804]    - args: function (..., envir = parent.frame())
[17:40:55.804]    - tweaked: FALSE
[17:40:55.804]    - call: NULL
[17:40:55.806] plan(): nbrOfWorkers() = 1
[17:40:55.809] plan(): Setting new future strategy stack:
[17:40:55.809] List of future strategies:
[17:40:55.809] 1. multicore:
[17:40:55.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.809]    - tweaked: FALSE
[17:40:55.809]    - call: plan(strategy)
[17:40:55.816] plan(): nbrOfWorkers() = 2
[17:40:55.804] MulticoreFuture:
[17:40:55.804] Label: ‘future_sapply-2’
[17:40:55.804] Expression:
[17:40:55.804] {
[17:40:55.804]     do.call(function(...) {
[17:40:55.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.804]             on.exit(options(oopts), add = TRUE)
[17:40:55.804]         }
[17:40:55.804]         {
[17:40:55.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.804]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.804]             })
[17:40:55.804]         }
[17:40:55.804]     }, args = future.call.arguments)
[17:40:55.804] }
[17:40:55.804] Lazy evaluation: FALSE
[17:40:55.804] Asynchronous evaluation: TRUE
[17:40:55.804] Local evaluation: TRUE
[17:40:55.804] Environment: R_GlobalEnv
[17:40:55.804] Capture standard output: TRUE
[17:40:55.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.804] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:40:55.804] Packages: 1 packages (‘stats’)
[17:40:55.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.804] Resolved: TRUE
[17:40:55.804] Value: <not collected>
[17:40:55.804] Conditions captured: <none>
[17:40:55.804] Early signaling: FALSE
[17:40:55.804] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.804] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.817] Chunk #2 of 2 ... DONE
[17:40:55.817] Launching 2 futures (chunks) ... DONE
[17:40:55.817] Resolving 2 futures (chunks) ...
[17:40:55.817] resolve() on list ...
[17:40:55.818]  recursive: 0
[17:40:55.818]  length: 2
[17:40:55.818] 
[17:40:55.818] Future #1
[17:40:55.820] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.820] - nx: 2
[17:40:55.820] - relay: TRUE
[17:40:55.820] - stdout: TRUE
[17:40:55.820] - signal: TRUE
[17:40:55.820] - resignal: FALSE
[17:40:55.821] - force: TRUE
[17:40:55.821] - relayed: [n=2] FALSE, FALSE
[17:40:55.821] - queued futures: [n=2] FALSE, FALSE
[17:40:55.821]  - until=1
[17:40:55.821]  - relaying element #1
[17:40:55.822] - relayed: [n=2] TRUE, FALSE
[17:40:55.822] - queued futures: [n=2] TRUE, FALSE
[17:40:55.822] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.822]  length: 1 (resolved future 1)
[17:40:55.823] Future #2
[17:40:55.824] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.824] - nx: 2
[17:40:55.824] - relay: TRUE
[17:40:55.825] - stdout: TRUE
[17:40:55.825] - signal: TRUE
[17:40:55.825] - resignal: FALSE
[17:40:55.825] - force: TRUE
[17:40:55.825] - relayed: [n=2] TRUE, FALSE
[17:40:55.825] - queued futures: [n=2] TRUE, FALSE
[17:40:55.826]  - until=2
[17:40:55.826]  - relaying element #2
[17:40:55.826] - relayed: [n=2] TRUE, TRUE
[17:40:55.826] - queued futures: [n=2] TRUE, TRUE
[17:40:55.826] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.827]  length: 0 (resolved future 2)
[17:40:55.827] Relaying remaining futures
[17:40:55.827] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.827] - nx: 2
[17:40:55.827] - relay: TRUE
[17:40:55.827] - stdout: TRUE
[17:40:55.827] - signal: TRUE
[17:40:55.827] - resignal: FALSE
[17:40:55.828] - force: TRUE
[17:40:55.828] - relayed: [n=2] TRUE, TRUE
[17:40:55.828] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.828] - relayed: [n=2] TRUE, TRUE
[17:40:55.828] - queued futures: [n=2] TRUE, TRUE
[17:40:55.828] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.828] resolve() on list ... DONE
[17:40:55.829]  - Number of value chunks collected: 2
[17:40:55.829] Resolving 2 futures (chunks) ... DONE
[17:40:55.829] Reducing values from 2 chunks ...
[17:40:55.829]  - Number of values collected after concatenation: 7
[17:40:55.829]  - Number of values expected: 7
[17:40:55.829] Reducing values from 2 chunks ... DONE
[17:40:55.829] future_lapply() ... DONE
[17:40:55.830] future_lapply() ...
[17:40:55.836] Number of chunks: 2
[17:40:55.836] getGlobalsAndPackagesXApply() ...
[17:40:55.836]  - future.globals: TRUE
[17:40:55.836] getGlobalsAndPackages() ...
[17:40:55.836] Searching for globals...
[17:40:55.848] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:40:55.848] Searching for globals ... DONE
[17:40:55.848] Resolving globals: FALSE
[17:40:55.849] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:40:55.850] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:40:55.850] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.850] - packages: [2] ‘stats’, ‘future.apply’
[17:40:55.850] getGlobalsAndPackages() ... DONE
[17:40:55.850]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:55.850]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:40:55.850] Finding globals ... DONE
[17:40:55.850]  - use_args: TRUE
[17:40:55.850]  - Getting '...' globals ...
[17:40:55.851] resolve() on list ...
[17:40:55.851]  recursive: 0
[17:40:55.851]  length: 1
[17:40:55.851]  elements: ‘...’
[17:40:55.851]  length: 0 (resolved future 1)
[17:40:55.851] resolve() on list ... DONE
[17:40:55.851]    - '...' content: [n=0] 
[17:40:55.852] List of 1
[17:40:55.852]  $ ...: list()
[17:40:55.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.852]  - attr(*, "where")=List of 1
[17:40:55.852]   ..$ ...:<environment: 0x564f2e070c68> 
[17:40:55.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.852]  - attr(*, "resolved")= logi TRUE
[17:40:55.852]  - attr(*, "total_size")= num NA
[17:40:55.854]  - Getting '...' globals ... DONE
[17:40:55.854] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:55.854] List of 8
[17:40:55.854]  $ ...future.FUN:function (x, ...)  
[17:40:55.854]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:40:55.854]  $ times        : int 5
[17:40:55.854]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.854]  $ stop_if_not  :function (...)  
[17:40:55.854]  $ dim          : NULL
[17:40:55.854]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:55.854]  $ ...          : list()
[17:40:55.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.854]  - attr(*, "where")=List of 8
[17:40:55.854]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:55.854]   ..$ ...          :<environment: 0x564f2e070c68> 
[17:40:55.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.854]  - attr(*, "resolved")= logi FALSE
[17:40:55.854]  - attr(*, "total_size")= num 141240
[17:40:55.862] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:40:55.862] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.862] Number of futures (= number of chunks): 2
[17:40:55.862] Launching 2 futures (chunks) ...
[17:40:55.863] Chunk #1 of 2 ...
[17:40:55.863]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.863] getGlobalsAndPackages() ...
[17:40:55.863] Searching for globals...
[17:40:55.863] 
[17:40:55.863] Searching for globals ... DONE
[17:40:55.863] - globals: [0] <none>
[17:40:55.864] getGlobalsAndPackages() ... DONE
[17:40:55.864]    + additional globals found: [n=0] 
[17:40:55.864]    + additional namespaces needed: [n=0] 
[17:40:55.864]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.864]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[17:40:55.864]  - seeds: <none>
[17:40:55.864] getGlobalsAndPackages() ...
[17:40:55.864] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.864] Resolving globals: FALSE
[17:40:55.865] Tweak future expression to call with '...' arguments ...
[17:40:55.865] {
[17:40:55.865]     do.call(function(...) {
[17:40:55.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.865]             on.exit(options(oopts), add = TRUE)
[17:40:55.865]         }
[17:40:55.865]         {
[17:40:55.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.865]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.865]             })
[17:40:55.865]         }
[17:40:55.865]     }, args = future.call.arguments)
[17:40:55.865] }
[17:40:55.865] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.865] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.866] - packages: [2] ‘stats’, ‘future.apply’
[17:40:55.866] getGlobalsAndPackages() ... DONE
[17:40:55.866] run() for ‘Future’ ...
[17:40:55.866] - state: ‘created’
[17:40:55.866] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.870] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.870]   - Field: ‘label’
[17:40:55.871]   - Field: ‘local’
[17:40:55.871]   - Field: ‘owner’
[17:40:55.871]   - Field: ‘envir’
[17:40:55.871]   - Field: ‘workers’
[17:40:55.871]   - Field: ‘packages’
[17:40:55.871]   - Field: ‘gc’
[17:40:55.871]   - Field: ‘job’
[17:40:55.871]   - Field: ‘conditions’
[17:40:55.871]   - Field: ‘expr’
[17:40:55.871]   - Field: ‘uuid’
[17:40:55.871]   - Field: ‘seed’
[17:40:55.872]   - Field: ‘version’
[17:40:55.872]   - Field: ‘result’
[17:40:55.872]   - Field: ‘asynchronous’
[17:40:55.872]   - Field: ‘calls’
[17:40:55.872]   - Field: ‘globals’
[17:40:55.872]   - Field: ‘stdout’
[17:40:55.872]   - Field: ‘earlySignal’
[17:40:55.872]   - Field: ‘lazy’
[17:40:55.872]   - Field: ‘state’
[17:40:55.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.873] - Launch lazy future ...
[17:40:55.873] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:40:55.873] Packages needed by future strategies (n = 0): <none>
[17:40:55.873] {
[17:40:55.873]     {
[17:40:55.873]         {
[17:40:55.873]             ...future.startTime <- base::Sys.time()
[17:40:55.873]             {
[17:40:55.873]                 {
[17:40:55.873]                   {
[17:40:55.873]                     {
[17:40:55.873]                       {
[17:40:55.873]                         base::local({
[17:40:55.873]                           has_future <- base::requireNamespace("future", 
[17:40:55.873]                             quietly = TRUE)
[17:40:55.873]                           if (has_future) {
[17:40:55.873]                             ns <- base::getNamespace("future")
[17:40:55.873]                             version <- ns[[".package"]][["version"]]
[17:40:55.873]                             if (is.null(version)) 
[17:40:55.873]                               version <- utils::packageVersion("future")
[17:40:55.873]                           }
[17:40:55.873]                           else {
[17:40:55.873]                             version <- NULL
[17:40:55.873]                           }
[17:40:55.873]                           if (!has_future || version < "1.8.0") {
[17:40:55.873]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.873]                               "", base::R.version$version.string), 
[17:40:55.873]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.873]                                 base::R.version$platform, 8 * 
[17:40:55.873]                                   base::.Machine$sizeof.pointer), 
[17:40:55.873]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.873]                                 "release", "version")], collapse = " "), 
[17:40:55.873]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.873]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.873]                               info)
[17:40:55.873]                             info <- base::paste(info, collapse = "; ")
[17:40:55.873]                             if (!has_future) {
[17:40:55.873]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.873]                                 info)
[17:40:55.873]                             }
[17:40:55.873]                             else {
[17:40:55.873]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.873]                                 info, version)
[17:40:55.873]                             }
[17:40:55.873]                             base::stop(msg)
[17:40:55.873]                           }
[17:40:55.873]                         })
[17:40:55.873]                       }
[17:40:55.873]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.873]                       base::options(mc.cores = 1L)
[17:40:55.873]                     }
[17:40:55.873]                     base::local({
[17:40:55.873]                       for (pkg in c("stats", "future.apply")) {
[17:40:55.873]                         base::loadNamespace(pkg)
[17:40:55.873]                         base::library(pkg, character.only = TRUE)
[17:40:55.873]                       }
[17:40:55.873]                     })
[17:40:55.873]                   }
[17:40:55.873]                   options(future.plan = NULL)
[17:40:55.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.873]                 }
[17:40:55.873]                 ...future.workdir <- getwd()
[17:40:55.873]             }
[17:40:55.873]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.873]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.873]         }
[17:40:55.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.873]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[17:40:55.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.873]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.873]             base::names(...future.oldOptions))
[17:40:55.873]     }
[17:40:55.873]     if (FALSE) {
[17:40:55.873]     }
[17:40:55.873]     else {
[17:40:55.873]         if (TRUE) {
[17:40:55.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.873]                 open = "w")
[17:40:55.873]         }
[17:40:55.873]         else {
[17:40:55.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.873]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.873]         }
[17:40:55.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.873]             base::sink(type = "output", split = FALSE)
[17:40:55.873]             base::close(...future.stdout)
[17:40:55.873]         }, add = TRUE)
[17:40:55.873]     }
[17:40:55.873]     ...future.frame <- base::sys.nframe()
[17:40:55.873]     ...future.conditions <- base::list()
[17:40:55.873]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.873]     if (FALSE) {
[17:40:55.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.873]     }
[17:40:55.873]     ...future.result <- base::tryCatch({
[17:40:55.873]         base::withCallingHandlers({
[17:40:55.873]             ...future.value <- base::withVisible(base::local({
[17:40:55.873]                 withCallingHandlers({
[17:40:55.873]                   {
[17:40:55.873]                     do.call(function(...) {
[17:40:55.873]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.873]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.873]                         ...future.globals.maxSize)) {
[17:40:55.873]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.873]                         on.exit(options(oopts), add = TRUE)
[17:40:55.873]                       }
[17:40:55.873]                       {
[17:40:55.873]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.873]                           FUN = function(jj) {
[17:40:55.873]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.873]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.873]                           })
[17:40:55.873]                       }
[17:40:55.873]                     }, args = future.call.arguments)
[17:40:55.873]                   }
[17:40:55.873]                 }, immediateCondition = function(cond) {
[17:40:55.873]                   save_rds <- function (object, pathname, ...) 
[17:40:55.873]                   {
[17:40:55.873]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.873]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.873]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.873]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.873]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.873]                         fi_tmp[["mtime"]])
[17:40:55.873]                     }
[17:40:55.873]                     tryCatch({
[17:40:55.873]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.873]                     }, error = function(ex) {
[17:40:55.873]                       msg <- conditionMessage(ex)
[17:40:55.873]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.873]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.873]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.873]                         fi_tmp[["mtime"]], msg)
[17:40:55.873]                       ex$message <- msg
[17:40:55.873]                       stop(ex)
[17:40:55.873]                     })
[17:40:55.873]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.873]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.873]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.873]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.873]                       fi <- file.info(pathname)
[17:40:55.873]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.873]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.873]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.873]                         fi[["size"]], fi[["mtime"]])
[17:40:55.873]                       stop(msg)
[17:40:55.873]                     }
[17:40:55.873]                     invisible(pathname)
[17:40:55.873]                   }
[17:40:55.873]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.873]                     rootPath = tempdir()) 
[17:40:55.873]                   {
[17:40:55.873]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.873]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.873]                       tmpdir = path, fileext = ".rds")
[17:40:55.873]                     save_rds(obj, file)
[17:40:55.873]                   }
[17:40:55.873]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.873]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.873]                   {
[17:40:55.873]                     inherits <- base::inherits
[17:40:55.873]                     invokeRestart <- base::invokeRestart
[17:40:55.873]                     is.null <- base::is.null
[17:40:55.873]                     muffled <- FALSE
[17:40:55.873]                     if (inherits(cond, "message")) {
[17:40:55.873]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.873]                       if (muffled) 
[17:40:55.873]                         invokeRestart("muffleMessage")
[17:40:55.873]                     }
[17:40:55.873]                     else if (inherits(cond, "warning")) {
[17:40:55.873]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.873]                       if (muffled) 
[17:40:55.873]                         invokeRestart("muffleWarning")
[17:40:55.873]                     }
[17:40:55.873]                     else if (inherits(cond, "condition")) {
[17:40:55.873]                       if (!is.null(pattern)) {
[17:40:55.873]                         computeRestarts <- base::computeRestarts
[17:40:55.873]                         grepl <- base::grepl
[17:40:55.873]                         restarts <- computeRestarts(cond)
[17:40:55.873]                         for (restart in restarts) {
[17:40:55.873]                           name <- restart$name
[17:40:55.873]                           if (is.null(name)) 
[17:40:55.873]                             next
[17:40:55.873]                           if (!grepl(pattern, name)) 
[17:40:55.873]                             next
[17:40:55.873]                           invokeRestart(restart)
[17:40:55.873]                           muffled <- TRUE
[17:40:55.873]                           break
[17:40:55.873]                         }
[17:40:55.873]                       }
[17:40:55.873]                     }
[17:40:55.873]                     invisible(muffled)
[17:40:55.873]                   }
[17:40:55.873]                   muffleCondition(cond)
[17:40:55.873]                 })
[17:40:55.873]             }))
[17:40:55.873]             future::FutureResult(value = ...future.value$value, 
[17:40:55.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.873]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.873]                     ...future.globalenv.names))
[17:40:55.873]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.873]         }, condition = base::local({
[17:40:55.873]             c <- base::c
[17:40:55.873]             inherits <- base::inherits
[17:40:55.873]             invokeRestart <- base::invokeRestart
[17:40:55.873]             length <- base::length
[17:40:55.873]             list <- base::list
[17:40:55.873]             seq.int <- base::seq.int
[17:40:55.873]             signalCondition <- base::signalCondition
[17:40:55.873]             sys.calls <- base::sys.calls
[17:40:55.873]             `[[` <- base::`[[`
[17:40:55.873]             `+` <- base::`+`
[17:40:55.873]             `<<-` <- base::`<<-`
[17:40:55.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.873]                   3L)]
[17:40:55.873]             }
[17:40:55.873]             function(cond) {
[17:40:55.873]                 is_error <- inherits(cond, "error")
[17:40:55.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.873]                   NULL)
[17:40:55.873]                 if (is_error) {
[17:40:55.873]                   sessionInformation <- function() {
[17:40:55.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.873]                       search = base::search(), system = base::Sys.info())
[17:40:55.873]                   }
[17:40:55.873]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.873]                     cond$call), session = sessionInformation(), 
[17:40:55.873]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.873]                   signalCondition(cond)
[17:40:55.873]                 }
[17:40:55.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.873]                 "immediateCondition"))) {
[17:40:55.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.873]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.873]                   if (TRUE && !signal) {
[17:40:55.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.873]                     {
[17:40:55.873]                       inherits <- base::inherits
[17:40:55.873]                       invokeRestart <- base::invokeRestart
[17:40:55.873]                       is.null <- base::is.null
[17:40:55.873]                       muffled <- FALSE
[17:40:55.873]                       if (inherits(cond, "message")) {
[17:40:55.873]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.873]                         if (muffled) 
[17:40:55.873]                           invokeRestart("muffleMessage")
[17:40:55.873]                       }
[17:40:55.873]                       else if (inherits(cond, "warning")) {
[17:40:55.873]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.873]                         if (muffled) 
[17:40:55.873]                           invokeRestart("muffleWarning")
[17:40:55.873]                       }
[17:40:55.873]                       else if (inherits(cond, "condition")) {
[17:40:55.873]                         if (!is.null(pattern)) {
[17:40:55.873]                           computeRestarts <- base::computeRestarts
[17:40:55.873]                           grepl <- base::grepl
[17:40:55.873]                           restarts <- computeRestarts(cond)
[17:40:55.873]                           for (restart in restarts) {
[17:40:55.873]                             name <- restart$name
[17:40:55.873]                             if (is.null(name)) 
[17:40:55.873]                               next
[17:40:55.873]                             if (!grepl(pattern, name)) 
[17:40:55.873]                               next
[17:40:55.873]                             invokeRestart(restart)
[17:40:55.873]                             muffled <- TRUE
[17:40:55.873]                             break
[17:40:55.873]                           }
[17:40:55.873]                         }
[17:40:55.873]                       }
[17:40:55.873]                       invisible(muffled)
[17:40:55.873]                     }
[17:40:55.873]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.873]                   }
[17:40:55.873]                 }
[17:40:55.873]                 else {
[17:40:55.873]                   if (TRUE) {
[17:40:55.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.873]                     {
[17:40:55.873]                       inherits <- base::inherits
[17:40:55.873]                       invokeRestart <- base::invokeRestart
[17:40:55.873]                       is.null <- base::is.null
[17:40:55.873]                       muffled <- FALSE
[17:40:55.873]                       if (inherits(cond, "message")) {
[17:40:55.873]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.873]                         if (muffled) 
[17:40:55.873]                           invokeRestart("muffleMessage")
[17:40:55.873]                       }
[17:40:55.873]                       else if (inherits(cond, "warning")) {
[17:40:55.873]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.873]                         if (muffled) 
[17:40:55.873]                           invokeRestart("muffleWarning")
[17:40:55.873]                       }
[17:40:55.873]                       else if (inherits(cond, "condition")) {
[17:40:55.873]                         if (!is.null(pattern)) {
[17:40:55.873]                           computeRestarts <- base::computeRestarts
[17:40:55.873]                           grepl <- base::grepl
[17:40:55.873]                           restarts <- computeRestarts(cond)
[17:40:55.873]                           for (restart in restarts) {
[17:40:55.873]                             name <- restart$name
[17:40:55.873]                             if (is.null(name)) 
[17:40:55.873]                               next
[17:40:55.873]                             if (!grepl(pattern, name)) 
[17:40:55.873]                               next
[17:40:55.873]                             invokeRestart(restart)
[17:40:55.873]                             muffled <- TRUE
[17:40:55.873]                             break
[17:40:55.873]                           }
[17:40:55.873]                         }
[17:40:55.873]                       }
[17:40:55.873]                       invisible(muffled)
[17:40:55.873]                     }
[17:40:55.873]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.873]                   }
[17:40:55.873]                 }
[17:40:55.873]             }
[17:40:55.873]         }))
[17:40:55.873]     }, error = function(ex) {
[17:40:55.873]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.873]                 ...future.rng), started = ...future.startTime, 
[17:40:55.873]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.873]             version = "1.8"), class = "FutureResult")
[17:40:55.873]     }, finally = {
[17:40:55.873]         if (!identical(...future.workdir, getwd())) 
[17:40:55.873]             setwd(...future.workdir)
[17:40:55.873]         {
[17:40:55.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.873]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.873]             }
[17:40:55.873]             base::options(...future.oldOptions)
[17:40:55.873]             if (.Platform$OS.type == "windows") {
[17:40:55.873]                 old_names <- names(...future.oldEnvVars)
[17:40:55.873]                 envs <- base::Sys.getenv()
[17:40:55.873]                 names <- names(envs)
[17:40:55.873]                 common <- intersect(names, old_names)
[17:40:55.873]                 added <- setdiff(names, old_names)
[17:40:55.873]                 removed <- setdiff(old_names, names)
[17:40:55.873]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.873]                   envs[common]]
[17:40:55.873]                 NAMES <- toupper(changed)
[17:40:55.873]                 args <- list()
[17:40:55.873]                 for (kk in seq_along(NAMES)) {
[17:40:55.873]                   name <- changed[[kk]]
[17:40:55.873]                   NAME <- NAMES[[kk]]
[17:40:55.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.873]                     next
[17:40:55.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.873]                 }
[17:40:55.873]                 NAMES <- toupper(added)
[17:40:55.873]                 for (kk in seq_along(NAMES)) {
[17:40:55.873]                   name <- added[[kk]]
[17:40:55.873]                   NAME <- NAMES[[kk]]
[17:40:55.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.873]                     next
[17:40:55.873]                   args[[name]] <- ""
[17:40:55.873]                 }
[17:40:55.873]                 NAMES <- toupper(removed)
[17:40:55.873]                 for (kk in seq_along(NAMES)) {
[17:40:55.873]                   name <- removed[[kk]]
[17:40:55.873]                   NAME <- NAMES[[kk]]
[17:40:55.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.873]                     next
[17:40:55.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.873]                 }
[17:40:55.873]                 if (length(args) > 0) 
[17:40:55.873]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.873]             }
[17:40:55.873]             else {
[17:40:55.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.873]             }
[17:40:55.873]             {
[17:40:55.873]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.873]                   0L) {
[17:40:55.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.873]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.873]                   base::options(opts)
[17:40:55.873]                 }
[17:40:55.873]                 {
[17:40:55.873]                   {
[17:40:55.873]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.873]                     NULL
[17:40:55.873]                   }
[17:40:55.873]                   options(future.plan = NULL)
[17:40:55.873]                   if (is.na(NA_character_)) 
[17:40:55.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.873]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.873]                     envir = parent.frame()) 
[17:40:55.873]                   {
[17:40:55.873]                     default_workers <- missing(workers)
[17:40:55.873]                     if (is.function(workers)) 
[17:40:55.873]                       workers <- workers()
[17:40:55.873]                     workers <- structure(as.integer(workers), 
[17:40:55.873]                       class = class(workers))
[17:40:55.873]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.873]                       1L)
[17:40:55.873]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.873]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.873]                       if (default_workers) 
[17:40:55.873]                         supportsMulticore(warn = TRUE)
[17:40:55.873]                       return(sequential(..., envir = envir))
[17:40:55.873]                     }
[17:40:55.873]                     oopts <- options(mc.cores = workers)
[17:40:55.873]                     on.exit(options(oopts))
[17:40:55.873]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.873]                       envir = envir)
[17:40:55.873]                     if (!future$lazy) 
[17:40:55.873]                       future <- run(future)
[17:40:55.873]                     invisible(future)
[17:40:55.873]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.873]                 }
[17:40:55.873]             }
[17:40:55.873]         }
[17:40:55.873]     })
[17:40:55.873]     if (TRUE) {
[17:40:55.873]         base::sink(type = "output", split = FALSE)
[17:40:55.873]         if (TRUE) {
[17:40:55.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.873]         }
[17:40:55.873]         else {
[17:40:55.873]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.873]         }
[17:40:55.873]         base::close(...future.stdout)
[17:40:55.873]         ...future.stdout <- NULL
[17:40:55.873]     }
[17:40:55.873]     ...future.result$conditions <- ...future.conditions
[17:40:55.873]     ...future.result$finished <- base::Sys.time()
[17:40:55.873]     ...future.result
[17:40:55.873] }
[17:40:55.876] assign_globals() ...
[17:40:55.876] List of 11
[17:40:55.876]  $ ...future.FUN            :function (x, ...)  
[17:40:55.876]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:40:55.876]  $ times                    : int 5
[17:40:55.876]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.876]  $ stop_if_not              :function (...)  
[17:40:55.876]  $ dim                      : NULL
[17:40:55.876]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.876]  $ future.call.arguments    : list()
[17:40:55.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.876]  $ ...future.elements_ii    :List of 4
[17:40:55.876]   ..$ : int [1:3] 1 2 3
[17:40:55.876]   ..$ : int [1:4] 1 2 3 4
[17:40:55.876]   ..$ : int [1:5] 1 2 3 4 5
[17:40:55.876]   ..$ : int [1:6] 1 2 3 4 5 6
[17:40:55.876]  $ ...future.seeds_ii       : NULL
[17:40:55.876]  $ ...future.globals.maxSize: NULL
[17:40:55.876]  - attr(*, "resolved")= logi FALSE
[17:40:55.876]  - attr(*, "total_size")= num 141240
[17:40:55.876]  - attr(*, "where")=List of 11
[17:40:55.876]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.876]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.876]  - attr(*, "already-done")= logi TRUE
[17:40:55.887] - copied ‘...future.FUN’ to environment
[17:40:55.887] - copied ‘x_FUN’ to environment
[17:40:55.887] - copied ‘times’ to environment
[17:40:55.887] - copied ‘stopf’ to environment
[17:40:55.887] - copied ‘stop_if_not’ to environment
[17:40:55.888] - copied ‘dim’ to environment
[17:40:55.888] - copied ‘valid_types’ to environment
[17:40:55.888] - copied ‘future.call.arguments’ to environment
[17:40:55.888] - copied ‘...future.elements_ii’ to environment
[17:40:55.888] - copied ‘...future.seeds_ii’ to environment
[17:40:55.888] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.888] assign_globals() ... done
[17:40:55.888] requestCore(): workers = 2
[17:40:55.891] MulticoreFuture started
[17:40:55.891] - Launch lazy future ... done
[17:40:55.892] run() for ‘MulticoreFuture’ ... done
[17:40:55.892] Created future:
[17:40:55.893] plan(): Setting new future strategy stack:
[17:40:55.894] List of future strategies:
[17:40:55.894] 1. sequential:
[17:40:55.894]    - args: function (..., envir = parent.frame())
[17:40:55.894]    - tweaked: FALSE
[17:40:55.894]    - call: NULL
[17:40:55.895] plan(): nbrOfWorkers() = 1
[17:40:55.897] plan(): Setting new future strategy stack:
[17:40:55.898] List of future strategies:
[17:40:55.898] 1. multicore:
[17:40:55.898]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.898]    - tweaked: FALSE
[17:40:55.898]    - call: plan(strategy)
[17:40:55.904] plan(): nbrOfWorkers() = 2
[17:40:55.893] MulticoreFuture:
[17:40:55.893] Label: ‘future_vapply-1’
[17:40:55.893] Expression:
[17:40:55.893] {
[17:40:55.893]     do.call(function(...) {
[17:40:55.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.893]             on.exit(options(oopts), add = TRUE)
[17:40:55.893]         }
[17:40:55.893]         {
[17:40:55.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.893]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.893]             })
[17:40:55.893]         }
[17:40:55.893]     }, args = future.call.arguments)
[17:40:55.893] }
[17:40:55.893] Lazy evaluation: FALSE
[17:40:55.893] Asynchronous evaluation: TRUE
[17:40:55.893] Local evaluation: TRUE
[17:40:55.893] Environment: R_GlobalEnv
[17:40:55.893] Capture standard output: TRUE
[17:40:55.893] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.893] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.893] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:40:55.893] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.893] Resolved: TRUE
[17:40:55.893] Value: <not collected>
[17:40:55.893] Conditions captured: <none>
[17:40:55.893] Early signaling: FALSE
[17:40:55.893] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.893] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.905] Chunk #1 of 2 ... DONE
[17:40:55.905] Chunk #2 of 2 ...
[17:40:55.906]  - Finding globals in 'X' for chunk #2 ...
[17:40:55.906] getGlobalsAndPackages() ...
[17:40:55.906] Searching for globals...
[17:40:55.906] 
[17:40:55.906] Searching for globals ... DONE
[17:40:55.907] - globals: [0] <none>
[17:40:55.907] getGlobalsAndPackages() ... DONE
[17:40:55.907]    + additional globals found: [n=0] 
[17:40:55.907]    + additional namespaces needed: [n=0] 
[17:40:55.907]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:55.908]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:40:55.908]  - seeds: <none>
[17:40:55.908] getGlobalsAndPackages() ...
[17:40:55.908] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.908] Resolving globals: FALSE
[17:40:55.908] Tweak future expression to call with '...' arguments ...
[17:40:55.909] {
[17:40:55.909]     do.call(function(...) {
[17:40:55.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.909]             on.exit(options(oopts), add = TRUE)
[17:40:55.909]         }
[17:40:55.909]         {
[17:40:55.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.909]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.909]             })
[17:40:55.909]         }
[17:40:55.909]     }, args = future.call.arguments)
[17:40:55.909] }
[17:40:55.909] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.910] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.911] - packages: [2] ‘stats’, ‘future.apply’
[17:40:55.911] getGlobalsAndPackages() ... DONE
[17:40:55.911] run() for ‘Future’ ...
[17:40:55.912] - state: ‘created’
[17:40:55.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.916] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.917]   - Field: ‘label’
[17:40:55.917]   - Field: ‘local’
[17:40:55.917]   - Field: ‘owner’
[17:40:55.917]   - Field: ‘envir’
[17:40:55.917]   - Field: ‘workers’
[17:40:55.917]   - Field: ‘packages’
[17:40:55.918]   - Field: ‘gc’
[17:40:55.918]   - Field: ‘job’
[17:40:55.918]   - Field: ‘conditions’
[17:40:55.918]   - Field: ‘expr’
[17:40:55.918]   - Field: ‘uuid’
[17:40:55.918]   - Field: ‘seed’
[17:40:55.918]   - Field: ‘version’
[17:40:55.919]   - Field: ‘result’
[17:40:55.919]   - Field: ‘asynchronous’
[17:40:55.919]   - Field: ‘calls’
[17:40:55.919]   - Field: ‘globals’
[17:40:55.919]   - Field: ‘stdout’
[17:40:55.919]   - Field: ‘earlySignal’
[17:40:55.920]   - Field: ‘lazy’
[17:40:55.920]   - Field: ‘state’
[17:40:55.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:55.920] - Launch lazy future ...
[17:40:55.920] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:40:55.921] Packages needed by future strategies (n = 0): <none>
[17:40:55.921] {
[17:40:55.921]     {
[17:40:55.921]         {
[17:40:55.921]             ...future.startTime <- base::Sys.time()
[17:40:55.921]             {
[17:40:55.921]                 {
[17:40:55.921]                   {
[17:40:55.921]                     {
[17:40:55.921]                       {
[17:40:55.921]                         base::local({
[17:40:55.921]                           has_future <- base::requireNamespace("future", 
[17:40:55.921]                             quietly = TRUE)
[17:40:55.921]                           if (has_future) {
[17:40:55.921]                             ns <- base::getNamespace("future")
[17:40:55.921]                             version <- ns[[".package"]][["version"]]
[17:40:55.921]                             if (is.null(version)) 
[17:40:55.921]                               version <- utils::packageVersion("future")
[17:40:55.921]                           }
[17:40:55.921]                           else {
[17:40:55.921]                             version <- NULL
[17:40:55.921]                           }
[17:40:55.921]                           if (!has_future || version < "1.8.0") {
[17:40:55.921]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.921]                               "", base::R.version$version.string), 
[17:40:55.921]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:55.921]                                 base::R.version$platform, 8 * 
[17:40:55.921]                                   base::.Machine$sizeof.pointer), 
[17:40:55.921]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.921]                                 "release", "version")], collapse = " "), 
[17:40:55.921]                               hostname = base::Sys.info()[["nodename"]])
[17:40:55.921]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.921]                               info)
[17:40:55.921]                             info <- base::paste(info, collapse = "; ")
[17:40:55.921]                             if (!has_future) {
[17:40:55.921]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.921]                                 info)
[17:40:55.921]                             }
[17:40:55.921]                             else {
[17:40:55.921]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.921]                                 info, version)
[17:40:55.921]                             }
[17:40:55.921]                             base::stop(msg)
[17:40:55.921]                           }
[17:40:55.921]                         })
[17:40:55.921]                       }
[17:40:55.921]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.921]                       base::options(mc.cores = 1L)
[17:40:55.921]                     }
[17:40:55.921]                     base::local({
[17:40:55.921]                       for (pkg in c("stats", "future.apply")) {
[17:40:55.921]                         base::loadNamespace(pkg)
[17:40:55.921]                         base::library(pkg, character.only = TRUE)
[17:40:55.921]                       }
[17:40:55.921]                     })
[17:40:55.921]                   }
[17:40:55.921]                   options(future.plan = NULL)
[17:40:55.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.921]                 }
[17:40:55.921]                 ...future.workdir <- getwd()
[17:40:55.921]             }
[17:40:55.921]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.921]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.921]         }
[17:40:55.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.921]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:40:55.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.921]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.921]             base::names(...future.oldOptions))
[17:40:55.921]     }
[17:40:55.921]     if (FALSE) {
[17:40:55.921]     }
[17:40:55.921]     else {
[17:40:55.921]         if (TRUE) {
[17:40:55.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.921]                 open = "w")
[17:40:55.921]         }
[17:40:55.921]         else {
[17:40:55.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.921]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.921]         }
[17:40:55.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.921]             base::sink(type = "output", split = FALSE)
[17:40:55.921]             base::close(...future.stdout)
[17:40:55.921]         }, add = TRUE)
[17:40:55.921]     }
[17:40:55.921]     ...future.frame <- base::sys.nframe()
[17:40:55.921]     ...future.conditions <- base::list()
[17:40:55.921]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.921]     if (FALSE) {
[17:40:55.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.921]     }
[17:40:55.921]     ...future.result <- base::tryCatch({
[17:40:55.921]         base::withCallingHandlers({
[17:40:55.921]             ...future.value <- base::withVisible(base::local({
[17:40:55.921]                 withCallingHandlers({
[17:40:55.921]                   {
[17:40:55.921]                     do.call(function(...) {
[17:40:55.921]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.921]                       if (!identical(...future.globals.maxSize.org, 
[17:40:55.921]                         ...future.globals.maxSize)) {
[17:40:55.921]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.921]                         on.exit(options(oopts), add = TRUE)
[17:40:55.921]                       }
[17:40:55.921]                       {
[17:40:55.921]                         lapply(seq_along(...future.elements_ii), 
[17:40:55.921]                           FUN = function(jj) {
[17:40:55.921]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.921]                             ...future.FUN(...future.X_jj, ...)
[17:40:55.921]                           })
[17:40:55.921]                       }
[17:40:55.921]                     }, args = future.call.arguments)
[17:40:55.921]                   }
[17:40:55.921]                 }, immediateCondition = function(cond) {
[17:40:55.921]                   save_rds <- function (object, pathname, ...) 
[17:40:55.921]                   {
[17:40:55.921]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:55.921]                     if (file_test("-f", pathname_tmp)) {
[17:40:55.921]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.921]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:55.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.921]                         fi_tmp[["mtime"]])
[17:40:55.921]                     }
[17:40:55.921]                     tryCatch({
[17:40:55.921]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:55.921]                     }, error = function(ex) {
[17:40:55.921]                       msg <- conditionMessage(ex)
[17:40:55.921]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.921]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:55.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.921]                         fi_tmp[["mtime"]], msg)
[17:40:55.921]                       ex$message <- msg
[17:40:55.921]                       stop(ex)
[17:40:55.921]                     })
[17:40:55.921]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:55.921]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:55.921]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:55.921]                       fi_tmp <- file.info(pathname_tmp)
[17:40:55.921]                       fi <- file.info(pathname)
[17:40:55.921]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:55.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:55.921]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:55.921]                         fi[["size"]], fi[["mtime"]])
[17:40:55.921]                       stop(msg)
[17:40:55.921]                     }
[17:40:55.921]                     invisible(pathname)
[17:40:55.921]                   }
[17:40:55.921]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:55.921]                     rootPath = tempdir()) 
[17:40:55.921]                   {
[17:40:55.921]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:55.921]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:55.921]                       tmpdir = path, fileext = ".rds")
[17:40:55.921]                     save_rds(obj, file)
[17:40:55.921]                   }
[17:40:55.921]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:55.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.921]                   {
[17:40:55.921]                     inherits <- base::inherits
[17:40:55.921]                     invokeRestart <- base::invokeRestart
[17:40:55.921]                     is.null <- base::is.null
[17:40:55.921]                     muffled <- FALSE
[17:40:55.921]                     if (inherits(cond, "message")) {
[17:40:55.921]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.921]                       if (muffled) 
[17:40:55.921]                         invokeRestart("muffleMessage")
[17:40:55.921]                     }
[17:40:55.921]                     else if (inherits(cond, "warning")) {
[17:40:55.921]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.921]                       if (muffled) 
[17:40:55.921]                         invokeRestart("muffleWarning")
[17:40:55.921]                     }
[17:40:55.921]                     else if (inherits(cond, "condition")) {
[17:40:55.921]                       if (!is.null(pattern)) {
[17:40:55.921]                         computeRestarts <- base::computeRestarts
[17:40:55.921]                         grepl <- base::grepl
[17:40:55.921]                         restarts <- computeRestarts(cond)
[17:40:55.921]                         for (restart in restarts) {
[17:40:55.921]                           name <- restart$name
[17:40:55.921]                           if (is.null(name)) 
[17:40:55.921]                             next
[17:40:55.921]                           if (!grepl(pattern, name)) 
[17:40:55.921]                             next
[17:40:55.921]                           invokeRestart(restart)
[17:40:55.921]                           muffled <- TRUE
[17:40:55.921]                           break
[17:40:55.921]                         }
[17:40:55.921]                       }
[17:40:55.921]                     }
[17:40:55.921]                     invisible(muffled)
[17:40:55.921]                   }
[17:40:55.921]                   muffleCondition(cond)
[17:40:55.921]                 })
[17:40:55.921]             }))
[17:40:55.921]             future::FutureResult(value = ...future.value$value, 
[17:40:55.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.921]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.921]                     ...future.globalenv.names))
[17:40:55.921]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.921]         }, condition = base::local({
[17:40:55.921]             c <- base::c
[17:40:55.921]             inherits <- base::inherits
[17:40:55.921]             invokeRestart <- base::invokeRestart
[17:40:55.921]             length <- base::length
[17:40:55.921]             list <- base::list
[17:40:55.921]             seq.int <- base::seq.int
[17:40:55.921]             signalCondition <- base::signalCondition
[17:40:55.921]             sys.calls <- base::sys.calls
[17:40:55.921]             `[[` <- base::`[[`
[17:40:55.921]             `+` <- base::`+`
[17:40:55.921]             `<<-` <- base::`<<-`
[17:40:55.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.921]                   3L)]
[17:40:55.921]             }
[17:40:55.921]             function(cond) {
[17:40:55.921]                 is_error <- inherits(cond, "error")
[17:40:55.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.921]                   NULL)
[17:40:55.921]                 if (is_error) {
[17:40:55.921]                   sessionInformation <- function() {
[17:40:55.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.921]                       search = base::search(), system = base::Sys.info())
[17:40:55.921]                   }
[17:40:55.921]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.921]                     cond$call), session = sessionInformation(), 
[17:40:55.921]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.921]                   signalCondition(cond)
[17:40:55.921]                 }
[17:40:55.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.921]                 "immediateCondition"))) {
[17:40:55.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.921]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.921]                   if (TRUE && !signal) {
[17:40:55.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.921]                     {
[17:40:55.921]                       inherits <- base::inherits
[17:40:55.921]                       invokeRestart <- base::invokeRestart
[17:40:55.921]                       is.null <- base::is.null
[17:40:55.921]                       muffled <- FALSE
[17:40:55.921]                       if (inherits(cond, "message")) {
[17:40:55.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.921]                         if (muffled) 
[17:40:55.921]                           invokeRestart("muffleMessage")
[17:40:55.921]                       }
[17:40:55.921]                       else if (inherits(cond, "warning")) {
[17:40:55.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.921]                         if (muffled) 
[17:40:55.921]                           invokeRestart("muffleWarning")
[17:40:55.921]                       }
[17:40:55.921]                       else if (inherits(cond, "condition")) {
[17:40:55.921]                         if (!is.null(pattern)) {
[17:40:55.921]                           computeRestarts <- base::computeRestarts
[17:40:55.921]                           grepl <- base::grepl
[17:40:55.921]                           restarts <- computeRestarts(cond)
[17:40:55.921]                           for (restart in restarts) {
[17:40:55.921]                             name <- restart$name
[17:40:55.921]                             if (is.null(name)) 
[17:40:55.921]                               next
[17:40:55.921]                             if (!grepl(pattern, name)) 
[17:40:55.921]                               next
[17:40:55.921]                             invokeRestart(restart)
[17:40:55.921]                             muffled <- TRUE
[17:40:55.921]                             break
[17:40:55.921]                           }
[17:40:55.921]                         }
[17:40:55.921]                       }
[17:40:55.921]                       invisible(muffled)
[17:40:55.921]                     }
[17:40:55.921]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.921]                   }
[17:40:55.921]                 }
[17:40:55.921]                 else {
[17:40:55.921]                   if (TRUE) {
[17:40:55.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.921]                     {
[17:40:55.921]                       inherits <- base::inherits
[17:40:55.921]                       invokeRestart <- base::invokeRestart
[17:40:55.921]                       is.null <- base::is.null
[17:40:55.921]                       muffled <- FALSE
[17:40:55.921]                       if (inherits(cond, "message")) {
[17:40:55.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.921]                         if (muffled) 
[17:40:55.921]                           invokeRestart("muffleMessage")
[17:40:55.921]                       }
[17:40:55.921]                       else if (inherits(cond, "warning")) {
[17:40:55.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.921]                         if (muffled) 
[17:40:55.921]                           invokeRestart("muffleWarning")
[17:40:55.921]                       }
[17:40:55.921]                       else if (inherits(cond, "condition")) {
[17:40:55.921]                         if (!is.null(pattern)) {
[17:40:55.921]                           computeRestarts <- base::computeRestarts
[17:40:55.921]                           grepl <- base::grepl
[17:40:55.921]                           restarts <- computeRestarts(cond)
[17:40:55.921]                           for (restart in restarts) {
[17:40:55.921]                             name <- restart$name
[17:40:55.921]                             if (is.null(name)) 
[17:40:55.921]                               next
[17:40:55.921]                             if (!grepl(pattern, name)) 
[17:40:55.921]                               next
[17:40:55.921]                             invokeRestart(restart)
[17:40:55.921]                             muffled <- TRUE
[17:40:55.921]                             break
[17:40:55.921]                           }
[17:40:55.921]                         }
[17:40:55.921]                       }
[17:40:55.921]                       invisible(muffled)
[17:40:55.921]                     }
[17:40:55.921]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.921]                   }
[17:40:55.921]                 }
[17:40:55.921]             }
[17:40:55.921]         }))
[17:40:55.921]     }, error = function(ex) {
[17:40:55.921]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.921]                 ...future.rng), started = ...future.startTime, 
[17:40:55.921]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.921]             version = "1.8"), class = "FutureResult")
[17:40:55.921]     }, finally = {
[17:40:55.921]         if (!identical(...future.workdir, getwd())) 
[17:40:55.921]             setwd(...future.workdir)
[17:40:55.921]         {
[17:40:55.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.921]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.921]             }
[17:40:55.921]             base::options(...future.oldOptions)
[17:40:55.921]             if (.Platform$OS.type == "windows") {
[17:40:55.921]                 old_names <- names(...future.oldEnvVars)
[17:40:55.921]                 envs <- base::Sys.getenv()
[17:40:55.921]                 names <- names(envs)
[17:40:55.921]                 common <- intersect(names, old_names)
[17:40:55.921]                 added <- setdiff(names, old_names)
[17:40:55.921]                 removed <- setdiff(old_names, names)
[17:40:55.921]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.921]                   envs[common]]
[17:40:55.921]                 NAMES <- toupper(changed)
[17:40:55.921]                 args <- list()
[17:40:55.921]                 for (kk in seq_along(NAMES)) {
[17:40:55.921]                   name <- changed[[kk]]
[17:40:55.921]                   NAME <- NAMES[[kk]]
[17:40:55.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.921]                     next
[17:40:55.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.921]                 }
[17:40:55.921]                 NAMES <- toupper(added)
[17:40:55.921]                 for (kk in seq_along(NAMES)) {
[17:40:55.921]                   name <- added[[kk]]
[17:40:55.921]                   NAME <- NAMES[[kk]]
[17:40:55.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.921]                     next
[17:40:55.921]                   args[[name]] <- ""
[17:40:55.921]                 }
[17:40:55.921]                 NAMES <- toupper(removed)
[17:40:55.921]                 for (kk in seq_along(NAMES)) {
[17:40:55.921]                   name <- removed[[kk]]
[17:40:55.921]                   NAME <- NAMES[[kk]]
[17:40:55.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.921]                     next
[17:40:55.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.921]                 }
[17:40:55.921]                 if (length(args) > 0) 
[17:40:55.921]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.921]             }
[17:40:55.921]             else {
[17:40:55.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.921]             }
[17:40:55.921]             {
[17:40:55.921]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.921]                   0L) {
[17:40:55.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.921]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.921]                   base::options(opts)
[17:40:55.921]                 }
[17:40:55.921]                 {
[17:40:55.921]                   {
[17:40:55.921]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.921]                     NULL
[17:40:55.921]                   }
[17:40:55.921]                   options(future.plan = NULL)
[17:40:55.921]                   if (is.na(NA_character_)) 
[17:40:55.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.921]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:55.921]                     envir = parent.frame()) 
[17:40:55.921]                   {
[17:40:55.921]                     default_workers <- missing(workers)
[17:40:55.921]                     if (is.function(workers)) 
[17:40:55.921]                       workers <- workers()
[17:40:55.921]                     workers <- structure(as.integer(workers), 
[17:40:55.921]                       class = class(workers))
[17:40:55.921]                     stop_if_not(is.finite(workers), workers >= 
[17:40:55.921]                       1L)
[17:40:55.921]                     if ((workers == 1L && !inherits(workers, 
[17:40:55.921]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:55.921]                       if (default_workers) 
[17:40:55.921]                         supportsMulticore(warn = TRUE)
[17:40:55.921]                       return(sequential(..., envir = envir))
[17:40:55.921]                     }
[17:40:55.921]                     oopts <- options(mc.cores = workers)
[17:40:55.921]                     on.exit(options(oopts))
[17:40:55.921]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:55.921]                       envir = envir)
[17:40:55.921]                     if (!future$lazy) 
[17:40:55.921]                       future <- run(future)
[17:40:55.921]                     invisible(future)
[17:40:55.921]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:55.921]                 }
[17:40:55.921]             }
[17:40:55.921]         }
[17:40:55.921]     })
[17:40:55.921]     if (TRUE) {
[17:40:55.921]         base::sink(type = "output", split = FALSE)
[17:40:55.921]         if (TRUE) {
[17:40:55.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.921]         }
[17:40:55.921]         else {
[17:40:55.921]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.921]         }
[17:40:55.921]         base::close(...future.stdout)
[17:40:55.921]         ...future.stdout <- NULL
[17:40:55.921]     }
[17:40:55.921]     ...future.result$conditions <- ...future.conditions
[17:40:55.921]     ...future.result$finished <- base::Sys.time()
[17:40:55.921]     ...future.result
[17:40:55.921] }
[17:40:55.925] assign_globals() ...
[17:40:55.925] List of 11
[17:40:55.925]  $ ...future.FUN            :function (x, ...)  
[17:40:55.925]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:40:55.925]  $ times                    : int 5
[17:40:55.925]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:55.925]  $ stop_if_not              :function (...)  
[17:40:55.925]  $ dim                      : NULL
[17:40:55.925]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:55.925]  $ future.call.arguments    : list()
[17:40:55.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.925]  $ ...future.elements_ii    :List of 3
[17:40:55.925]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:40:55.925]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:40:55.925]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:40:55.925]  $ ...future.seeds_ii       : NULL
[17:40:55.925]  $ ...future.globals.maxSize: NULL
[17:40:55.925]  - attr(*, "resolved")= logi FALSE
[17:40:55.925]  - attr(*, "total_size")= num 141240
[17:40:55.925]  - attr(*, "where")=List of 11
[17:40:55.925]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:55.925]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:55.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.925]  - attr(*, "already-done")= logi TRUE
[17:40:55.941] - copied ‘...future.FUN’ to environment
[17:40:55.941] - copied ‘x_FUN’ to environment
[17:40:55.942] - copied ‘times’ to environment
[17:40:55.942] - copied ‘stopf’ to environment
[17:40:55.942] - copied ‘stop_if_not’ to environment
[17:40:55.942] - copied ‘dim’ to environment
[17:40:55.942] - copied ‘valid_types’ to environment
[17:40:55.942] - copied ‘future.call.arguments’ to environment
[17:40:55.942] - copied ‘...future.elements_ii’ to environment
[17:40:55.942] - copied ‘...future.seeds_ii’ to environment
[17:40:55.942] - copied ‘...future.globals.maxSize’ to environment
[17:40:55.943] assign_globals() ... done
[17:40:55.943] requestCore(): workers = 2
[17:40:55.945] MulticoreFuture started
[17:40:55.946] - Launch lazy future ... done
[17:40:55.946] run() for ‘MulticoreFuture’ ... done
[17:40:55.946] Created future:
[17:40:55.947] plan(): Setting new future strategy stack:
[17:40:55.947] List of future strategies:
[17:40:55.947] 1. sequential:
[17:40:55.947]    - args: function (..., envir = parent.frame())
[17:40:55.947]    - tweaked: FALSE
[17:40:55.947]    - call: NULL
[17:40:55.948] plan(): nbrOfWorkers() = 1
[17:40:55.950] plan(): Setting new future strategy stack:
[17:40:55.951] List of future strategies:
[17:40:55.951] 1. multicore:
[17:40:55.951]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:55.951]    - tweaked: FALSE
[17:40:55.951]    - call: plan(strategy)
[17:40:55.957] plan(): nbrOfWorkers() = 2
[17:40:55.946] MulticoreFuture:
[17:40:55.946] Label: ‘future_vapply-2’
[17:40:55.946] Expression:
[17:40:55.946] {
[17:40:55.946]     do.call(function(...) {
[17:40:55.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.946]             on.exit(options(oopts), add = TRUE)
[17:40:55.946]         }
[17:40:55.946]         {
[17:40:55.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.946]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.946]             })
[17:40:55.946]         }
[17:40:55.946]     }, args = future.call.arguments)
[17:40:55.946] }
[17:40:55.946] Lazy evaluation: FALSE
[17:40:55.946] Asynchronous evaluation: TRUE
[17:40:55.946] Local evaluation: TRUE
[17:40:55.946] Environment: R_GlobalEnv
[17:40:55.946] Capture standard output: TRUE
[17:40:55.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:55.946] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:55.946] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:40:55.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:55.946] Resolved: TRUE
[17:40:55.946] Value: <not collected>
[17:40:55.946] Conditions captured: <none>
[17:40:55.946] Early signaling: FALSE
[17:40:55.946] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:55.946] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.958] Chunk #2 of 2 ... DONE
[17:40:55.958] Launching 2 futures (chunks) ... DONE
[17:40:55.958] Resolving 2 futures (chunks) ...
[17:40:55.958] resolve() on list ...
[17:40:55.959]  recursive: 0
[17:40:55.959]  length: 2
[17:40:55.959] 
[17:40:55.959] Future #1
[17:40:55.960] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:55.960] - nx: 2
[17:40:55.961] - relay: TRUE
[17:40:55.961] - stdout: TRUE
[17:40:55.961] - signal: TRUE
[17:40:55.961] - resignal: FALSE
[17:40:55.961] - force: TRUE
[17:40:55.961] - relayed: [n=2] FALSE, FALSE
[17:40:55.961] - queued futures: [n=2] FALSE, FALSE
[17:40:55.962]  - until=1
[17:40:55.962]  - relaying element #1
[17:40:55.962] - relayed: [n=2] TRUE, FALSE
[17:40:55.962] - queued futures: [n=2] TRUE, FALSE
[17:40:55.962] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:55.963]  length: 1 (resolved future 1)
[17:40:55.963] Future #2
[17:40:55.964] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:55.964] - nx: 2
[17:40:55.964] - relay: TRUE
[17:40:55.964] - stdout: TRUE
[17:40:55.965] - signal: TRUE
[17:40:55.965] - resignal: FALSE
[17:40:55.965] - force: TRUE
[17:40:55.965] - relayed: [n=2] TRUE, FALSE
[17:40:55.965] - queued futures: [n=2] TRUE, FALSE
[17:40:55.965]  - until=2
[17:40:55.965]  - relaying element #2
[17:40:55.965] - relayed: [n=2] TRUE, TRUE
[17:40:55.966] - queued futures: [n=2] TRUE, TRUE
[17:40:55.966] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:55.966]  length: 0 (resolved future 2)
[17:40:55.966] Relaying remaining futures
[17:40:55.966] signalConditionsASAP(NULL, pos=0) ...
[17:40:55.966] - nx: 2
[17:40:55.966] - relay: TRUE
[17:40:55.966] - stdout: TRUE
[17:40:55.967] - signal: TRUE
[17:40:55.967] - resignal: FALSE
[17:40:55.967] - force: TRUE
[17:40:55.967] - relayed: [n=2] TRUE, TRUE
[17:40:55.967] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:55.967] - relayed: [n=2] TRUE, TRUE
[17:40:55.967] - queued futures: [n=2] TRUE, TRUE
[17:40:55.967] signalConditionsASAP(NULL, pos=0) ... done
[17:40:55.968] resolve() on list ... DONE
[17:40:55.968]  - Number of value chunks collected: 2
[17:40:55.968] Resolving 2 futures (chunks) ... DONE
[17:40:55.968] Reducing values from 2 chunks ...
[17:40:55.968]  - Number of values collected after concatenation: 7
[17:40:55.968]  - Number of values expected: 7
[17:40:55.968] Reducing values from 2 chunks ... DONE
[17:40:55.969] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:40:55.971] future_lapply() ...
[17:40:55.978] Number of chunks: 2
[17:40:55.978] getGlobalsAndPackagesXApply() ...
[17:40:55.978]  - future.globals: TRUE
[17:40:55.978] getGlobalsAndPackages() ...
[17:40:55.978] Searching for globals...
[17:40:55.980] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:40:55.980] Searching for globals ... DONE
[17:40:55.980] Resolving globals: FALSE
[17:40:55.981] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:40:55.981] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:40:55.982] - globals: [1] ‘FUN’
[17:40:55.982] 
[17:40:55.982] getGlobalsAndPackages() ... DONE
[17:40:55.982]  - globals found/used: [n=1] ‘FUN’
[17:40:55.982]  - needed namespaces: [n=0] 
[17:40:55.982] Finding globals ... DONE
[17:40:55.982]  - use_args: TRUE
[17:40:55.982]  - Getting '...' globals ...
[17:40:55.983] resolve() on list ...
[17:40:55.983]  recursive: 0
[17:40:55.983]  length: 1
[17:40:55.983]  elements: ‘...’
[17:40:55.984]  length: 0 (resolved future 1)
[17:40:55.984] resolve() on list ... DONE
[17:40:55.984]    - '...' content: [n=1] ‘y’
[17:40:55.984] List of 1
[17:40:55.984]  $ ...:List of 1
[17:40:55.984]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:55.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.984]  - attr(*, "where")=List of 1
[17:40:55.984]   ..$ ...:<environment: 0x564f30286fe0> 
[17:40:55.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.984]  - attr(*, "resolved")= logi TRUE
[17:40:55.984]  - attr(*, "total_size")= num NA
[17:40:55.988]  - Getting '...' globals ... DONE
[17:40:55.988] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:40:55.988] List of 2
[17:40:55.988]  $ ...future.FUN:function (x, y)  
[17:40:55.988]  $ ...          :List of 1
[17:40:55.988]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:55.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:55.988]  - attr(*, "where")=List of 2
[17:40:55.988]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:55.988]   ..$ ...          :<environment: 0x564f30286fe0> 
[17:40:55.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:55.988]  - attr(*, "resolved")= logi FALSE
[17:40:55.988]  - attr(*, "total_size")= num 4264
[17:40:55.991] Packages to be attached in all futures: [n=0] 
[17:40:55.991] getGlobalsAndPackagesXApply() ... DONE
[17:40:55.991] Number of futures (= number of chunks): 2
[17:40:55.992] Launching 2 futures (chunks) ...
[17:40:55.992] Chunk #1 of 2 ...
[17:40:55.992]  - Finding globals in 'X' for chunk #1 ...
[17:40:55.992] getGlobalsAndPackages() ...
[17:40:55.992] Searching for globals...
[17:40:55.992] 
[17:40:55.992] Searching for globals ... DONE
[17:40:55.992] - globals: [0] <none>
[17:40:55.993] getGlobalsAndPackages() ... DONE
[17:40:55.993]    + additional globals found: [n=0] 
[17:40:55.993]    + additional namespaces needed: [n=0] 
[17:40:55.993]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:55.993]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:55.993]  - seeds: <none>
[17:40:55.993] getGlobalsAndPackages() ...
[17:40:55.993] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.993] Resolving globals: FALSE
[17:40:55.993] Tweak future expression to call with '...' arguments ...
[17:40:55.994] {
[17:40:55.994]     do.call(function(...) {
[17:40:55.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:55.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:55.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:55.994]             on.exit(options(oopts), add = TRUE)
[17:40:55.994]         }
[17:40:55.994]         {
[17:40:55.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:55.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:55.994]                 ...future.FUN(...future.X_jj, ...)
[17:40:55.994]             })
[17:40:55.994]         }
[17:40:55.994]     }, args = future.call.arguments)
[17:40:55.994] }
[17:40:55.994] Tweak future expression to call with '...' arguments ... DONE
[17:40:55.994] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:55.994] 
[17:40:55.994] getGlobalsAndPackages() ... DONE
[17:40:55.995] run() for ‘Future’ ...
[17:40:55.995] - state: ‘created’
[17:40:55.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:55.999]   - Field: ‘label’
[17:40:55.999]   - Field: ‘local’
[17:40:55.999]   - Field: ‘owner’
[17:40:55.999]   - Field: ‘envir’
[17:40:55.999]   - Field: ‘workers’
[17:40:55.999]   - Field: ‘packages’
[17:40:56.000]   - Field: ‘gc’
[17:40:56.000]   - Field: ‘job’
[17:40:56.000]   - Field: ‘conditions’
[17:40:56.000]   - Field: ‘expr’
[17:40:56.000]   - Field: ‘uuid’
[17:40:56.000]   - Field: ‘seed’
[17:40:56.000]   - Field: ‘version’
[17:40:56.000]   - Field: ‘result’
[17:40:56.000]   - Field: ‘asynchronous’
[17:40:56.000]   - Field: ‘calls’
[17:40:56.001]   - Field: ‘globals’
[17:40:56.001]   - Field: ‘stdout’
[17:40:56.001]   - Field: ‘earlySignal’
[17:40:56.001]   - Field: ‘lazy’
[17:40:56.001]   - Field: ‘state’
[17:40:56.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.003] - Launch lazy future ...
[17:40:56.004] Packages needed by the future expression (n = 0): <none>
[17:40:56.004] Packages needed by future strategies (n = 0): <none>
[17:40:56.004] {
[17:40:56.004]     {
[17:40:56.004]         {
[17:40:56.004]             ...future.startTime <- base::Sys.time()
[17:40:56.004]             {
[17:40:56.004]                 {
[17:40:56.004]                   {
[17:40:56.004]                     {
[17:40:56.004]                       base::local({
[17:40:56.004]                         has_future <- base::requireNamespace("future", 
[17:40:56.004]                           quietly = TRUE)
[17:40:56.004]                         if (has_future) {
[17:40:56.004]                           ns <- base::getNamespace("future")
[17:40:56.004]                           version <- ns[[".package"]][["version"]]
[17:40:56.004]                           if (is.null(version)) 
[17:40:56.004]                             version <- utils::packageVersion("future")
[17:40:56.004]                         }
[17:40:56.004]                         else {
[17:40:56.004]                           version <- NULL
[17:40:56.004]                         }
[17:40:56.004]                         if (!has_future || version < "1.8.0") {
[17:40:56.004]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.004]                             "", base::R.version$version.string), 
[17:40:56.004]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:56.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:56.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.004]                               "release", "version")], collapse = " "), 
[17:40:56.004]                             hostname = base::Sys.info()[["nodename"]])
[17:40:56.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.004]                             info)
[17:40:56.004]                           info <- base::paste(info, collapse = "; ")
[17:40:56.004]                           if (!has_future) {
[17:40:56.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.004]                               info)
[17:40:56.004]                           }
[17:40:56.004]                           else {
[17:40:56.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.004]                               info, version)
[17:40:56.004]                           }
[17:40:56.004]                           base::stop(msg)
[17:40:56.004]                         }
[17:40:56.004]                       })
[17:40:56.004]                     }
[17:40:56.004]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.004]                     base::options(mc.cores = 1L)
[17:40:56.004]                   }
[17:40:56.004]                   options(future.plan = NULL)
[17:40:56.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.004]                 }
[17:40:56.004]                 ...future.workdir <- getwd()
[17:40:56.004]             }
[17:40:56.004]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.004]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.004]         }
[17:40:56.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.004]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:56.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.004]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.004]             base::names(...future.oldOptions))
[17:40:56.004]     }
[17:40:56.004]     if (FALSE) {
[17:40:56.004]     }
[17:40:56.004]     else {
[17:40:56.004]         if (TRUE) {
[17:40:56.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.004]                 open = "w")
[17:40:56.004]         }
[17:40:56.004]         else {
[17:40:56.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.004]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.004]         }
[17:40:56.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.004]             base::sink(type = "output", split = FALSE)
[17:40:56.004]             base::close(...future.stdout)
[17:40:56.004]         }, add = TRUE)
[17:40:56.004]     }
[17:40:56.004]     ...future.frame <- base::sys.nframe()
[17:40:56.004]     ...future.conditions <- base::list()
[17:40:56.004]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.004]     if (FALSE) {
[17:40:56.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.004]     }
[17:40:56.004]     ...future.result <- base::tryCatch({
[17:40:56.004]         base::withCallingHandlers({
[17:40:56.004]             ...future.value <- base::withVisible(base::local({
[17:40:56.004]                 withCallingHandlers({
[17:40:56.004]                   {
[17:40:56.004]                     do.call(function(...) {
[17:40:56.004]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.004]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.004]                         ...future.globals.maxSize)) {
[17:40:56.004]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.004]                         on.exit(options(oopts), add = TRUE)
[17:40:56.004]                       }
[17:40:56.004]                       {
[17:40:56.004]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.004]                           FUN = function(jj) {
[17:40:56.004]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.004]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.004]                           })
[17:40:56.004]                       }
[17:40:56.004]                     }, args = future.call.arguments)
[17:40:56.004]                   }
[17:40:56.004]                 }, immediateCondition = function(cond) {
[17:40:56.004]                   save_rds <- function (object, pathname, ...) 
[17:40:56.004]                   {
[17:40:56.004]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.004]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.004]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.004]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.004]                         fi_tmp[["mtime"]])
[17:40:56.004]                     }
[17:40:56.004]                     tryCatch({
[17:40:56.004]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.004]                     }, error = function(ex) {
[17:40:56.004]                       msg <- conditionMessage(ex)
[17:40:56.004]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.004]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.004]                         fi_tmp[["mtime"]], msg)
[17:40:56.004]                       ex$message <- msg
[17:40:56.004]                       stop(ex)
[17:40:56.004]                     })
[17:40:56.004]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.004]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.004]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.004]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.004]                       fi <- file.info(pathname)
[17:40:56.004]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.004]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.004]                         fi[["size"]], fi[["mtime"]])
[17:40:56.004]                       stop(msg)
[17:40:56.004]                     }
[17:40:56.004]                     invisible(pathname)
[17:40:56.004]                   }
[17:40:56.004]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.004]                     rootPath = tempdir()) 
[17:40:56.004]                   {
[17:40:56.004]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.004]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.004]                       tmpdir = path, fileext = ".rds")
[17:40:56.004]                     save_rds(obj, file)
[17:40:56.004]                   }
[17:40:56.004]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.004]                   {
[17:40:56.004]                     inherits <- base::inherits
[17:40:56.004]                     invokeRestart <- base::invokeRestart
[17:40:56.004]                     is.null <- base::is.null
[17:40:56.004]                     muffled <- FALSE
[17:40:56.004]                     if (inherits(cond, "message")) {
[17:40:56.004]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.004]                       if (muffled) 
[17:40:56.004]                         invokeRestart("muffleMessage")
[17:40:56.004]                     }
[17:40:56.004]                     else if (inherits(cond, "warning")) {
[17:40:56.004]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.004]                       if (muffled) 
[17:40:56.004]                         invokeRestart("muffleWarning")
[17:40:56.004]                     }
[17:40:56.004]                     else if (inherits(cond, "condition")) {
[17:40:56.004]                       if (!is.null(pattern)) {
[17:40:56.004]                         computeRestarts <- base::computeRestarts
[17:40:56.004]                         grepl <- base::grepl
[17:40:56.004]                         restarts <- computeRestarts(cond)
[17:40:56.004]                         for (restart in restarts) {
[17:40:56.004]                           name <- restart$name
[17:40:56.004]                           if (is.null(name)) 
[17:40:56.004]                             next
[17:40:56.004]                           if (!grepl(pattern, name)) 
[17:40:56.004]                             next
[17:40:56.004]                           invokeRestart(restart)
[17:40:56.004]                           muffled <- TRUE
[17:40:56.004]                           break
[17:40:56.004]                         }
[17:40:56.004]                       }
[17:40:56.004]                     }
[17:40:56.004]                     invisible(muffled)
[17:40:56.004]                   }
[17:40:56.004]                   muffleCondition(cond)
[17:40:56.004]                 })
[17:40:56.004]             }))
[17:40:56.004]             future::FutureResult(value = ...future.value$value, 
[17:40:56.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.004]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.004]                     ...future.globalenv.names))
[17:40:56.004]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.004]         }, condition = base::local({
[17:40:56.004]             c <- base::c
[17:40:56.004]             inherits <- base::inherits
[17:40:56.004]             invokeRestart <- base::invokeRestart
[17:40:56.004]             length <- base::length
[17:40:56.004]             list <- base::list
[17:40:56.004]             seq.int <- base::seq.int
[17:40:56.004]             signalCondition <- base::signalCondition
[17:40:56.004]             sys.calls <- base::sys.calls
[17:40:56.004]             `[[` <- base::`[[`
[17:40:56.004]             `+` <- base::`+`
[17:40:56.004]             `<<-` <- base::`<<-`
[17:40:56.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.004]                   3L)]
[17:40:56.004]             }
[17:40:56.004]             function(cond) {
[17:40:56.004]                 is_error <- inherits(cond, "error")
[17:40:56.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.004]                   NULL)
[17:40:56.004]                 if (is_error) {
[17:40:56.004]                   sessionInformation <- function() {
[17:40:56.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.004]                       search = base::search(), system = base::Sys.info())
[17:40:56.004]                   }
[17:40:56.004]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.004]                     cond$call), session = sessionInformation(), 
[17:40:56.004]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.004]                   signalCondition(cond)
[17:40:56.004]                 }
[17:40:56.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.004]                 "immediateCondition"))) {
[17:40:56.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.004]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.004]                   if (TRUE && !signal) {
[17:40:56.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.004]                     {
[17:40:56.004]                       inherits <- base::inherits
[17:40:56.004]                       invokeRestart <- base::invokeRestart
[17:40:56.004]                       is.null <- base::is.null
[17:40:56.004]                       muffled <- FALSE
[17:40:56.004]                       if (inherits(cond, "message")) {
[17:40:56.004]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.004]                         if (muffled) 
[17:40:56.004]                           invokeRestart("muffleMessage")
[17:40:56.004]                       }
[17:40:56.004]                       else if (inherits(cond, "warning")) {
[17:40:56.004]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.004]                         if (muffled) 
[17:40:56.004]                           invokeRestart("muffleWarning")
[17:40:56.004]                       }
[17:40:56.004]                       else if (inherits(cond, "condition")) {
[17:40:56.004]                         if (!is.null(pattern)) {
[17:40:56.004]                           computeRestarts <- base::computeRestarts
[17:40:56.004]                           grepl <- base::grepl
[17:40:56.004]                           restarts <- computeRestarts(cond)
[17:40:56.004]                           for (restart in restarts) {
[17:40:56.004]                             name <- restart$name
[17:40:56.004]                             if (is.null(name)) 
[17:40:56.004]                               next
[17:40:56.004]                             if (!grepl(pattern, name)) 
[17:40:56.004]                               next
[17:40:56.004]                             invokeRestart(restart)
[17:40:56.004]                             muffled <- TRUE
[17:40:56.004]                             break
[17:40:56.004]                           }
[17:40:56.004]                         }
[17:40:56.004]                       }
[17:40:56.004]                       invisible(muffled)
[17:40:56.004]                     }
[17:40:56.004]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.004]                   }
[17:40:56.004]                 }
[17:40:56.004]                 else {
[17:40:56.004]                   if (TRUE) {
[17:40:56.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.004]                     {
[17:40:56.004]                       inherits <- base::inherits
[17:40:56.004]                       invokeRestart <- base::invokeRestart
[17:40:56.004]                       is.null <- base::is.null
[17:40:56.004]                       muffled <- FALSE
[17:40:56.004]                       if (inherits(cond, "message")) {
[17:40:56.004]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.004]                         if (muffled) 
[17:40:56.004]                           invokeRestart("muffleMessage")
[17:40:56.004]                       }
[17:40:56.004]                       else if (inherits(cond, "warning")) {
[17:40:56.004]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.004]                         if (muffled) 
[17:40:56.004]                           invokeRestart("muffleWarning")
[17:40:56.004]                       }
[17:40:56.004]                       else if (inherits(cond, "condition")) {
[17:40:56.004]                         if (!is.null(pattern)) {
[17:40:56.004]                           computeRestarts <- base::computeRestarts
[17:40:56.004]                           grepl <- base::grepl
[17:40:56.004]                           restarts <- computeRestarts(cond)
[17:40:56.004]                           for (restart in restarts) {
[17:40:56.004]                             name <- restart$name
[17:40:56.004]                             if (is.null(name)) 
[17:40:56.004]                               next
[17:40:56.004]                             if (!grepl(pattern, name)) 
[17:40:56.004]                               next
[17:40:56.004]                             invokeRestart(restart)
[17:40:56.004]                             muffled <- TRUE
[17:40:56.004]                             break
[17:40:56.004]                           }
[17:40:56.004]                         }
[17:40:56.004]                       }
[17:40:56.004]                       invisible(muffled)
[17:40:56.004]                     }
[17:40:56.004]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.004]                   }
[17:40:56.004]                 }
[17:40:56.004]             }
[17:40:56.004]         }))
[17:40:56.004]     }, error = function(ex) {
[17:40:56.004]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.004]                 ...future.rng), started = ...future.startTime, 
[17:40:56.004]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.004]             version = "1.8"), class = "FutureResult")
[17:40:56.004]     }, finally = {
[17:40:56.004]         if (!identical(...future.workdir, getwd())) 
[17:40:56.004]             setwd(...future.workdir)
[17:40:56.004]         {
[17:40:56.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.004]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.004]             }
[17:40:56.004]             base::options(...future.oldOptions)
[17:40:56.004]             if (.Platform$OS.type == "windows") {
[17:40:56.004]                 old_names <- names(...future.oldEnvVars)
[17:40:56.004]                 envs <- base::Sys.getenv()
[17:40:56.004]                 names <- names(envs)
[17:40:56.004]                 common <- intersect(names, old_names)
[17:40:56.004]                 added <- setdiff(names, old_names)
[17:40:56.004]                 removed <- setdiff(old_names, names)
[17:40:56.004]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.004]                   envs[common]]
[17:40:56.004]                 NAMES <- toupper(changed)
[17:40:56.004]                 args <- list()
[17:40:56.004]                 for (kk in seq_along(NAMES)) {
[17:40:56.004]                   name <- changed[[kk]]
[17:40:56.004]                   NAME <- NAMES[[kk]]
[17:40:56.004]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.004]                     next
[17:40:56.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.004]                 }
[17:40:56.004]                 NAMES <- toupper(added)
[17:40:56.004]                 for (kk in seq_along(NAMES)) {
[17:40:56.004]                   name <- added[[kk]]
[17:40:56.004]                   NAME <- NAMES[[kk]]
[17:40:56.004]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.004]                     next
[17:40:56.004]                   args[[name]] <- ""
[17:40:56.004]                 }
[17:40:56.004]                 NAMES <- toupper(removed)
[17:40:56.004]                 for (kk in seq_along(NAMES)) {
[17:40:56.004]                   name <- removed[[kk]]
[17:40:56.004]                   NAME <- NAMES[[kk]]
[17:40:56.004]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.004]                     next
[17:40:56.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.004]                 }
[17:40:56.004]                 if (length(args) > 0) 
[17:40:56.004]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.004]             }
[17:40:56.004]             else {
[17:40:56.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.004]             }
[17:40:56.004]             {
[17:40:56.004]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.004]                   0L) {
[17:40:56.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.004]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.004]                   base::options(opts)
[17:40:56.004]                 }
[17:40:56.004]                 {
[17:40:56.004]                   {
[17:40:56.004]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.004]                     NULL
[17:40:56.004]                   }
[17:40:56.004]                   options(future.plan = NULL)
[17:40:56.004]                   if (is.na(NA_character_)) 
[17:40:56.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.004]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.004]                     envir = parent.frame()) 
[17:40:56.004]                   {
[17:40:56.004]                     default_workers <- missing(workers)
[17:40:56.004]                     if (is.function(workers)) 
[17:40:56.004]                       workers <- workers()
[17:40:56.004]                     workers <- structure(as.integer(workers), 
[17:40:56.004]                       class = class(workers))
[17:40:56.004]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.004]                       1L)
[17:40:56.004]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.004]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.004]                       if (default_workers) 
[17:40:56.004]                         supportsMulticore(warn = TRUE)
[17:40:56.004]                       return(sequential(..., envir = envir))
[17:40:56.004]                     }
[17:40:56.004]                     oopts <- options(mc.cores = workers)
[17:40:56.004]                     on.exit(options(oopts))
[17:40:56.004]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.004]                       envir = envir)
[17:40:56.004]                     if (!future$lazy) 
[17:40:56.004]                       future <- run(future)
[17:40:56.004]                     invisible(future)
[17:40:56.004]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.004]                 }
[17:40:56.004]             }
[17:40:56.004]         }
[17:40:56.004]     })
[17:40:56.004]     if (TRUE) {
[17:40:56.004]         base::sink(type = "output", split = FALSE)
[17:40:56.004]         if (TRUE) {
[17:40:56.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.004]         }
[17:40:56.004]         else {
[17:40:56.004]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.004]         }
[17:40:56.004]         base::close(...future.stdout)
[17:40:56.004]         ...future.stdout <- NULL
[17:40:56.004]     }
[17:40:56.004]     ...future.result$conditions <- ...future.conditions
[17:40:56.004]     ...future.result$finished <- base::Sys.time()
[17:40:56.004]     ...future.result
[17:40:56.004] }
[17:40:56.007] assign_globals() ...
[17:40:56.007] List of 5
[17:40:56.007]  $ ...future.FUN            :function (x, y)  
[17:40:56.007]  $ future.call.arguments    :List of 1
[17:40:56.007]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:56.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.007]  $ ...future.elements_ii    :List of 2
[17:40:56.007]   ..$ A: num 50
[17:40:56.007]   ..$ B: num 60
[17:40:56.007]  $ ...future.seeds_ii       : NULL
[17:40:56.007]  $ ...future.globals.maxSize: NULL
[17:40:56.007]  - attr(*, "resolved")= logi FALSE
[17:40:56.007]  - attr(*, "total_size")= num 4264
[17:40:56.007]  - attr(*, "where")=List of 5
[17:40:56.007]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.007]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.007]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.007]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.007]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.007]  - attr(*, "already-done")= logi TRUE
[17:40:56.014] - reassign environment for ‘...future.FUN’
[17:40:56.014] - copied ‘...future.FUN’ to environment
[17:40:56.014] - copied ‘future.call.arguments’ to environment
[17:40:56.014] - copied ‘...future.elements_ii’ to environment
[17:40:56.015] - copied ‘...future.seeds_ii’ to environment
[17:40:56.015] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.015] assign_globals() ... done
[17:40:56.015] requestCore(): workers = 2
[17:40:56.017] MulticoreFuture started
[17:40:56.018] - Launch lazy future ... done
[17:40:56.018] run() for ‘MulticoreFuture’ ... done
[17:40:56.018] Created future:
[17:40:56.018] plan(): Setting new future strategy stack:
[17:40:56.019] List of future strategies:
[17:40:56.019] 1. sequential:
[17:40:56.019]    - args: function (..., envir = parent.frame())
[17:40:56.019]    - tweaked: FALSE
[17:40:56.019]    - call: NULL
[17:40:56.020] plan(): nbrOfWorkers() = 1
[17:40:56.022] plan(): Setting new future strategy stack:
[17:40:56.022] List of future strategies:
[17:40:56.022] 1. multicore:
[17:40:56.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.022]    - tweaked: FALSE
[17:40:56.022]    - call: plan(strategy)
[17:40:56.028] plan(): nbrOfWorkers() = 2
[17:40:56.018] MulticoreFuture:
[17:40:56.018] Label: ‘future_sapply-1’
[17:40:56.018] Expression:
[17:40:56.018] {
[17:40:56.018]     do.call(function(...) {
[17:40:56.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.018]             on.exit(options(oopts), add = TRUE)
[17:40:56.018]         }
[17:40:56.018]         {
[17:40:56.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.018]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.018]             })
[17:40:56.018]         }
[17:40:56.018]     }, args = future.call.arguments)
[17:40:56.018] }
[17:40:56.018] Lazy evaluation: FALSE
[17:40:56.018] Asynchronous evaluation: TRUE
[17:40:56.018] Local evaluation: TRUE
[17:40:56.018] Environment: R_GlobalEnv
[17:40:56.018] Capture standard output: TRUE
[17:40:56.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.018] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:40:56.018] Packages: <none>
[17:40:56.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.018] Resolved: TRUE
[17:40:56.018] Value: <not collected>
[17:40:56.018] Conditions captured: <none>
[17:40:56.018] Early signaling: FALSE
[17:40:56.018] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.018] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.029] Chunk #1 of 2 ... DONE
[17:40:56.030] Chunk #2 of 2 ...
[17:40:56.030]  - Finding globals in 'X' for chunk #2 ...
[17:40:56.030] getGlobalsAndPackages() ...
[17:40:56.030] Searching for globals...
[17:40:56.031] 
[17:40:56.031] Searching for globals ... DONE
[17:40:56.031] - globals: [0] <none>
[17:40:56.031] getGlobalsAndPackages() ... DONE
[17:40:56.031]    + additional globals found: [n=0] 
[17:40:56.032]    + additional namespaces needed: [n=0] 
[17:40:56.032]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:56.032]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:56.032]  - seeds: <none>
[17:40:56.032] getGlobalsAndPackages() ...
[17:40:56.032] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.033] Resolving globals: FALSE
[17:40:56.033] Tweak future expression to call with '...' arguments ...
[17:40:56.033] {
[17:40:56.033]     do.call(function(...) {
[17:40:56.033]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.033]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.033]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.033]             on.exit(options(oopts), add = TRUE)
[17:40:56.033]         }
[17:40:56.033]         {
[17:40:56.033]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.033]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.033]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.033]             })
[17:40:56.033]         }
[17:40:56.033]     }, args = future.call.arguments)
[17:40:56.033] }
[17:40:56.034] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.034] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.035] 
[17:40:56.035] getGlobalsAndPackages() ... DONE
[17:40:56.035] run() for ‘Future’ ...
[17:40:56.035] - state: ‘created’
[17:40:56.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.041]   - Field: ‘label’
[17:40:56.041]   - Field: ‘local’
[17:40:56.042]   - Field: ‘owner’
[17:40:56.042]   - Field: ‘envir’
[17:40:56.042]   - Field: ‘workers’
[17:40:56.042]   - Field: ‘packages’
[17:40:56.042]   - Field: ‘gc’
[17:40:56.042]   - Field: ‘job’
[17:40:56.043]   - Field: ‘conditions’
[17:40:56.043]   - Field: ‘expr’
[17:40:56.043]   - Field: ‘uuid’
[17:40:56.043]   - Field: ‘seed’
[17:40:56.043]   - Field: ‘version’
[17:40:56.043]   - Field: ‘result’
[17:40:56.044]   - Field: ‘asynchronous’
[17:40:56.044]   - Field: ‘calls’
[17:40:56.044]   - Field: ‘globals’
[17:40:56.044]   - Field: ‘stdout’
[17:40:56.044]   - Field: ‘earlySignal’
[17:40:56.044]   - Field: ‘lazy’
[17:40:56.045]   - Field: ‘state’
[17:40:56.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.045] - Launch lazy future ...
[17:40:56.045] Packages needed by the future expression (n = 0): <none>
[17:40:56.046] Packages needed by future strategies (n = 0): <none>
[17:40:56.046] {
[17:40:56.046]     {
[17:40:56.046]         {
[17:40:56.046]             ...future.startTime <- base::Sys.time()
[17:40:56.046]             {
[17:40:56.046]                 {
[17:40:56.046]                   {
[17:40:56.046]                     {
[17:40:56.046]                       base::local({
[17:40:56.046]                         has_future <- base::requireNamespace("future", 
[17:40:56.046]                           quietly = TRUE)
[17:40:56.046]                         if (has_future) {
[17:40:56.046]                           ns <- base::getNamespace("future")
[17:40:56.046]                           version <- ns[[".package"]][["version"]]
[17:40:56.046]                           if (is.null(version)) 
[17:40:56.046]                             version <- utils::packageVersion("future")
[17:40:56.046]                         }
[17:40:56.046]                         else {
[17:40:56.046]                           version <- NULL
[17:40:56.046]                         }
[17:40:56.046]                         if (!has_future || version < "1.8.0") {
[17:40:56.046]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.046]                             "", base::R.version$version.string), 
[17:40:56.046]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:56.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:56.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.046]                               "release", "version")], collapse = " "), 
[17:40:56.046]                             hostname = base::Sys.info()[["nodename"]])
[17:40:56.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.046]                             info)
[17:40:56.046]                           info <- base::paste(info, collapse = "; ")
[17:40:56.046]                           if (!has_future) {
[17:40:56.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.046]                               info)
[17:40:56.046]                           }
[17:40:56.046]                           else {
[17:40:56.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.046]                               info, version)
[17:40:56.046]                           }
[17:40:56.046]                           base::stop(msg)
[17:40:56.046]                         }
[17:40:56.046]                       })
[17:40:56.046]                     }
[17:40:56.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.046]                     base::options(mc.cores = 1L)
[17:40:56.046]                   }
[17:40:56.046]                   options(future.plan = NULL)
[17:40:56.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.046]                 }
[17:40:56.046]                 ...future.workdir <- getwd()
[17:40:56.046]             }
[17:40:56.046]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.046]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.046]         }
[17:40:56.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.046]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:56.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.046]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.046]             base::names(...future.oldOptions))
[17:40:56.046]     }
[17:40:56.046]     if (FALSE) {
[17:40:56.046]     }
[17:40:56.046]     else {
[17:40:56.046]         if (TRUE) {
[17:40:56.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.046]                 open = "w")
[17:40:56.046]         }
[17:40:56.046]         else {
[17:40:56.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.046]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.046]         }
[17:40:56.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.046]             base::sink(type = "output", split = FALSE)
[17:40:56.046]             base::close(...future.stdout)
[17:40:56.046]         }, add = TRUE)
[17:40:56.046]     }
[17:40:56.046]     ...future.frame <- base::sys.nframe()
[17:40:56.046]     ...future.conditions <- base::list()
[17:40:56.046]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.046]     if (FALSE) {
[17:40:56.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.046]     }
[17:40:56.046]     ...future.result <- base::tryCatch({
[17:40:56.046]         base::withCallingHandlers({
[17:40:56.046]             ...future.value <- base::withVisible(base::local({
[17:40:56.046]                 withCallingHandlers({
[17:40:56.046]                   {
[17:40:56.046]                     do.call(function(...) {
[17:40:56.046]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.046]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.046]                         ...future.globals.maxSize)) {
[17:40:56.046]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.046]                         on.exit(options(oopts), add = TRUE)
[17:40:56.046]                       }
[17:40:56.046]                       {
[17:40:56.046]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.046]                           FUN = function(jj) {
[17:40:56.046]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.046]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.046]                           })
[17:40:56.046]                       }
[17:40:56.046]                     }, args = future.call.arguments)
[17:40:56.046]                   }
[17:40:56.046]                 }, immediateCondition = function(cond) {
[17:40:56.046]                   save_rds <- function (object, pathname, ...) 
[17:40:56.046]                   {
[17:40:56.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.046]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.046]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.046]                         fi_tmp[["mtime"]])
[17:40:56.046]                     }
[17:40:56.046]                     tryCatch({
[17:40:56.046]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.046]                     }, error = function(ex) {
[17:40:56.046]                       msg <- conditionMessage(ex)
[17:40:56.046]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.046]                         fi_tmp[["mtime"]], msg)
[17:40:56.046]                       ex$message <- msg
[17:40:56.046]                       stop(ex)
[17:40:56.046]                     })
[17:40:56.046]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.046]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.046]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.046]                       fi <- file.info(pathname)
[17:40:56.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.046]                         fi[["size"]], fi[["mtime"]])
[17:40:56.046]                       stop(msg)
[17:40:56.046]                     }
[17:40:56.046]                     invisible(pathname)
[17:40:56.046]                   }
[17:40:56.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.046]                     rootPath = tempdir()) 
[17:40:56.046]                   {
[17:40:56.046]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.046]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.046]                       tmpdir = path, fileext = ".rds")
[17:40:56.046]                     save_rds(obj, file)
[17:40:56.046]                   }
[17:40:56.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.046]                   {
[17:40:56.046]                     inherits <- base::inherits
[17:40:56.046]                     invokeRestart <- base::invokeRestart
[17:40:56.046]                     is.null <- base::is.null
[17:40:56.046]                     muffled <- FALSE
[17:40:56.046]                     if (inherits(cond, "message")) {
[17:40:56.046]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.046]                       if (muffled) 
[17:40:56.046]                         invokeRestart("muffleMessage")
[17:40:56.046]                     }
[17:40:56.046]                     else if (inherits(cond, "warning")) {
[17:40:56.046]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.046]                       if (muffled) 
[17:40:56.046]                         invokeRestart("muffleWarning")
[17:40:56.046]                     }
[17:40:56.046]                     else if (inherits(cond, "condition")) {
[17:40:56.046]                       if (!is.null(pattern)) {
[17:40:56.046]                         computeRestarts <- base::computeRestarts
[17:40:56.046]                         grepl <- base::grepl
[17:40:56.046]                         restarts <- computeRestarts(cond)
[17:40:56.046]                         for (restart in restarts) {
[17:40:56.046]                           name <- restart$name
[17:40:56.046]                           if (is.null(name)) 
[17:40:56.046]                             next
[17:40:56.046]                           if (!grepl(pattern, name)) 
[17:40:56.046]                             next
[17:40:56.046]                           invokeRestart(restart)
[17:40:56.046]                           muffled <- TRUE
[17:40:56.046]                           break
[17:40:56.046]                         }
[17:40:56.046]                       }
[17:40:56.046]                     }
[17:40:56.046]                     invisible(muffled)
[17:40:56.046]                   }
[17:40:56.046]                   muffleCondition(cond)
[17:40:56.046]                 })
[17:40:56.046]             }))
[17:40:56.046]             future::FutureResult(value = ...future.value$value, 
[17:40:56.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.046]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.046]                     ...future.globalenv.names))
[17:40:56.046]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.046]         }, condition = base::local({
[17:40:56.046]             c <- base::c
[17:40:56.046]             inherits <- base::inherits
[17:40:56.046]             invokeRestart <- base::invokeRestart
[17:40:56.046]             length <- base::length
[17:40:56.046]             list <- base::list
[17:40:56.046]             seq.int <- base::seq.int
[17:40:56.046]             signalCondition <- base::signalCondition
[17:40:56.046]             sys.calls <- base::sys.calls
[17:40:56.046]             `[[` <- base::`[[`
[17:40:56.046]             `+` <- base::`+`
[17:40:56.046]             `<<-` <- base::`<<-`
[17:40:56.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.046]                   3L)]
[17:40:56.046]             }
[17:40:56.046]             function(cond) {
[17:40:56.046]                 is_error <- inherits(cond, "error")
[17:40:56.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.046]                   NULL)
[17:40:56.046]                 if (is_error) {
[17:40:56.046]                   sessionInformation <- function() {
[17:40:56.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.046]                       search = base::search(), system = base::Sys.info())
[17:40:56.046]                   }
[17:40:56.046]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.046]                     cond$call), session = sessionInformation(), 
[17:40:56.046]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.046]                   signalCondition(cond)
[17:40:56.046]                 }
[17:40:56.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.046]                 "immediateCondition"))) {
[17:40:56.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.046]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.046]                   if (TRUE && !signal) {
[17:40:56.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.046]                     {
[17:40:56.046]                       inherits <- base::inherits
[17:40:56.046]                       invokeRestart <- base::invokeRestart
[17:40:56.046]                       is.null <- base::is.null
[17:40:56.046]                       muffled <- FALSE
[17:40:56.046]                       if (inherits(cond, "message")) {
[17:40:56.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.046]                         if (muffled) 
[17:40:56.046]                           invokeRestart("muffleMessage")
[17:40:56.046]                       }
[17:40:56.046]                       else if (inherits(cond, "warning")) {
[17:40:56.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.046]                         if (muffled) 
[17:40:56.046]                           invokeRestart("muffleWarning")
[17:40:56.046]                       }
[17:40:56.046]                       else if (inherits(cond, "condition")) {
[17:40:56.046]                         if (!is.null(pattern)) {
[17:40:56.046]                           computeRestarts <- base::computeRestarts
[17:40:56.046]                           grepl <- base::grepl
[17:40:56.046]                           restarts <- computeRestarts(cond)
[17:40:56.046]                           for (restart in restarts) {
[17:40:56.046]                             name <- restart$name
[17:40:56.046]                             if (is.null(name)) 
[17:40:56.046]                               next
[17:40:56.046]                             if (!grepl(pattern, name)) 
[17:40:56.046]                               next
[17:40:56.046]                             invokeRestart(restart)
[17:40:56.046]                             muffled <- TRUE
[17:40:56.046]                             break
[17:40:56.046]                           }
[17:40:56.046]                         }
[17:40:56.046]                       }
[17:40:56.046]                       invisible(muffled)
[17:40:56.046]                     }
[17:40:56.046]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.046]                   }
[17:40:56.046]                 }
[17:40:56.046]                 else {
[17:40:56.046]                   if (TRUE) {
[17:40:56.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.046]                     {
[17:40:56.046]                       inherits <- base::inherits
[17:40:56.046]                       invokeRestart <- base::invokeRestart
[17:40:56.046]                       is.null <- base::is.null
[17:40:56.046]                       muffled <- FALSE
[17:40:56.046]                       if (inherits(cond, "message")) {
[17:40:56.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.046]                         if (muffled) 
[17:40:56.046]                           invokeRestart("muffleMessage")
[17:40:56.046]                       }
[17:40:56.046]                       else if (inherits(cond, "warning")) {
[17:40:56.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.046]                         if (muffled) 
[17:40:56.046]                           invokeRestart("muffleWarning")
[17:40:56.046]                       }
[17:40:56.046]                       else if (inherits(cond, "condition")) {
[17:40:56.046]                         if (!is.null(pattern)) {
[17:40:56.046]                           computeRestarts <- base::computeRestarts
[17:40:56.046]                           grepl <- base::grepl
[17:40:56.046]                           restarts <- computeRestarts(cond)
[17:40:56.046]                           for (restart in restarts) {
[17:40:56.046]                             name <- restart$name
[17:40:56.046]                             if (is.null(name)) 
[17:40:56.046]                               next
[17:40:56.046]                             if (!grepl(pattern, name)) 
[17:40:56.046]                               next
[17:40:56.046]                             invokeRestart(restart)
[17:40:56.046]                             muffled <- TRUE
[17:40:56.046]                             break
[17:40:56.046]                           }
[17:40:56.046]                         }
[17:40:56.046]                       }
[17:40:56.046]                       invisible(muffled)
[17:40:56.046]                     }
[17:40:56.046]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.046]                   }
[17:40:56.046]                 }
[17:40:56.046]             }
[17:40:56.046]         }))
[17:40:56.046]     }, error = function(ex) {
[17:40:56.046]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.046]                 ...future.rng), started = ...future.startTime, 
[17:40:56.046]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.046]             version = "1.8"), class = "FutureResult")
[17:40:56.046]     }, finally = {
[17:40:56.046]         if (!identical(...future.workdir, getwd())) 
[17:40:56.046]             setwd(...future.workdir)
[17:40:56.046]         {
[17:40:56.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.046]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.046]             }
[17:40:56.046]             base::options(...future.oldOptions)
[17:40:56.046]             if (.Platform$OS.type == "windows") {
[17:40:56.046]                 old_names <- names(...future.oldEnvVars)
[17:40:56.046]                 envs <- base::Sys.getenv()
[17:40:56.046]                 names <- names(envs)
[17:40:56.046]                 common <- intersect(names, old_names)
[17:40:56.046]                 added <- setdiff(names, old_names)
[17:40:56.046]                 removed <- setdiff(old_names, names)
[17:40:56.046]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.046]                   envs[common]]
[17:40:56.046]                 NAMES <- toupper(changed)
[17:40:56.046]                 args <- list()
[17:40:56.046]                 for (kk in seq_along(NAMES)) {
[17:40:56.046]                   name <- changed[[kk]]
[17:40:56.046]                   NAME <- NAMES[[kk]]
[17:40:56.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.046]                     next
[17:40:56.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.046]                 }
[17:40:56.046]                 NAMES <- toupper(added)
[17:40:56.046]                 for (kk in seq_along(NAMES)) {
[17:40:56.046]                   name <- added[[kk]]
[17:40:56.046]                   NAME <- NAMES[[kk]]
[17:40:56.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.046]                     next
[17:40:56.046]                   args[[name]] <- ""
[17:40:56.046]                 }
[17:40:56.046]                 NAMES <- toupper(removed)
[17:40:56.046]                 for (kk in seq_along(NAMES)) {
[17:40:56.046]                   name <- removed[[kk]]
[17:40:56.046]                   NAME <- NAMES[[kk]]
[17:40:56.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.046]                     next
[17:40:56.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.046]                 }
[17:40:56.046]                 if (length(args) > 0) 
[17:40:56.046]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.046]             }
[17:40:56.046]             else {
[17:40:56.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.046]             }
[17:40:56.046]             {
[17:40:56.046]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.046]                   0L) {
[17:40:56.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.046]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.046]                   base::options(opts)
[17:40:56.046]                 }
[17:40:56.046]                 {
[17:40:56.046]                   {
[17:40:56.046]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.046]                     NULL
[17:40:56.046]                   }
[17:40:56.046]                   options(future.plan = NULL)
[17:40:56.046]                   if (is.na(NA_character_)) 
[17:40:56.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.046]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.046]                     envir = parent.frame()) 
[17:40:56.046]                   {
[17:40:56.046]                     default_workers <- missing(workers)
[17:40:56.046]                     if (is.function(workers)) 
[17:40:56.046]                       workers <- workers()
[17:40:56.046]                     workers <- structure(as.integer(workers), 
[17:40:56.046]                       class = class(workers))
[17:40:56.046]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.046]                       1L)
[17:40:56.046]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.046]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.046]                       if (default_workers) 
[17:40:56.046]                         supportsMulticore(warn = TRUE)
[17:40:56.046]                       return(sequential(..., envir = envir))
[17:40:56.046]                     }
[17:40:56.046]                     oopts <- options(mc.cores = workers)
[17:40:56.046]                     on.exit(options(oopts))
[17:40:56.046]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.046]                       envir = envir)
[17:40:56.046]                     if (!future$lazy) 
[17:40:56.046]                       future <- run(future)
[17:40:56.046]                     invisible(future)
[17:40:56.046]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.046]                 }
[17:40:56.046]             }
[17:40:56.046]         }
[17:40:56.046]     })
[17:40:56.046]     if (TRUE) {
[17:40:56.046]         base::sink(type = "output", split = FALSE)
[17:40:56.046]         if (TRUE) {
[17:40:56.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.046]         }
[17:40:56.046]         else {
[17:40:56.046]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.046]         }
[17:40:56.046]         base::close(...future.stdout)
[17:40:56.046]         ...future.stdout <- NULL
[17:40:56.046]     }
[17:40:56.046]     ...future.result$conditions <- ...future.conditions
[17:40:56.046]     ...future.result$finished <- base::Sys.time()
[17:40:56.046]     ...future.result
[17:40:56.046] }
[17:40:56.050] assign_globals() ...
[17:40:56.050] List of 5
[17:40:56.050]  $ ...future.FUN            :function (x, y)  
[17:40:56.050]  $ future.call.arguments    :List of 1
[17:40:56.050]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:56.050]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.050]  $ ...future.elements_ii    :List of 2
[17:40:56.050]   ..$ C: num 70
[17:40:56.050]   ..$ D: num 80
[17:40:56.050]  $ ...future.seeds_ii       : NULL
[17:40:56.050]  $ ...future.globals.maxSize: NULL
[17:40:56.050]  - attr(*, "resolved")= logi FALSE
[17:40:56.050]  - attr(*, "total_size")= num 4264
[17:40:56.050]  - attr(*, "where")=List of 5
[17:40:56.050]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.050]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.050]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.050]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.050]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.050]  - attr(*, "already-done")= logi TRUE
[17:40:56.065] - reassign environment for ‘...future.FUN’
[17:40:56.065] - copied ‘...future.FUN’ to environment
[17:40:56.065] - copied ‘future.call.arguments’ to environment
[17:40:56.066] - copied ‘...future.elements_ii’ to environment
[17:40:56.066] - copied ‘...future.seeds_ii’ to environment
[17:40:56.066] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.066] assign_globals() ... done
[17:40:56.066] requestCore(): workers = 2
[17:40:56.069] MulticoreFuture started
[17:40:56.070] - Launch lazy future ... done
[17:40:56.070] run() for ‘MulticoreFuture’ ... done
[17:40:56.070] plan(): Setting new future strategy stack:
[17:40:56.071] Created future:
[17:40:56.071] List of future strategies:
[17:40:56.071] 1. sequential:
[17:40:56.071]    - args: function (..., envir = parent.frame())
[17:40:56.071]    - tweaked: FALSE
[17:40:56.071]    - call: NULL
[17:40:56.072] plan(): nbrOfWorkers() = 1
[17:40:56.074] plan(): Setting new future strategy stack:
[17:40:56.075] List of future strategies:
[17:40:56.075] 1. multicore:
[17:40:56.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.075]    - tweaked: FALSE
[17:40:56.075]    - call: plan(strategy)
[17:40:56.080] plan(): nbrOfWorkers() = 2
[17:40:56.071] MulticoreFuture:
[17:40:56.071] Label: ‘future_sapply-2’
[17:40:56.071] Expression:
[17:40:56.071] {
[17:40:56.071]     do.call(function(...) {
[17:40:56.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.071]             on.exit(options(oopts), add = TRUE)
[17:40:56.071]         }
[17:40:56.071]         {
[17:40:56.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.071]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.071]             })
[17:40:56.071]         }
[17:40:56.071]     }, args = future.call.arguments)
[17:40:56.071] }
[17:40:56.071] Lazy evaluation: FALSE
[17:40:56.071] Asynchronous evaluation: TRUE
[17:40:56.071] Local evaluation: TRUE
[17:40:56.071] Environment: R_GlobalEnv
[17:40:56.071] Capture standard output: TRUE
[17:40:56.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.071] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:40:56.071] Packages: <none>
[17:40:56.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.071] Resolved: TRUE
[17:40:56.071] Value: <not collected>
[17:40:56.071] Conditions captured: <none>
[17:40:56.071] Early signaling: FALSE
[17:40:56.071] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.071] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.082] Chunk #2 of 2 ... DONE
[17:40:56.082] Launching 2 futures (chunks) ... DONE
[17:40:56.082] Resolving 2 futures (chunks) ...
[17:40:56.082] resolve() on list ...
[17:40:56.082]  recursive: 0
[17:40:56.082]  length: 2
[17:40:56.083] 
[17:40:56.083] Future #1
[17:40:56.084] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:56.084] - nx: 2
[17:40:56.084] - relay: TRUE
[17:40:56.085] - stdout: TRUE
[17:40:56.085] - signal: TRUE
[17:40:56.085] - resignal: FALSE
[17:40:56.085] - force: TRUE
[17:40:56.085] - relayed: [n=2] FALSE, FALSE
[17:40:56.085] - queued futures: [n=2] FALSE, FALSE
[17:40:56.086]  - until=1
[17:40:56.086]  - relaying element #1
[17:40:56.086] - relayed: [n=2] TRUE, FALSE
[17:40:56.086] - queued futures: [n=2] TRUE, FALSE
[17:40:56.087] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:56.087]  length: 1 (resolved future 1)
[17:40:56.087] Future #2
[17:40:56.088] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:56.088] - nx: 2
[17:40:56.089] - relay: TRUE
[17:40:56.089] - stdout: TRUE
[17:40:56.089] - signal: TRUE
[17:40:56.089] - resignal: FALSE
[17:40:56.089] - force: TRUE
[17:40:56.089] - relayed: [n=2] TRUE, FALSE
[17:40:56.090] - queued futures: [n=2] TRUE, FALSE
[17:40:56.090]  - until=2
[17:40:56.090]  - relaying element #2
[17:40:56.090] - relayed: [n=2] TRUE, TRUE
[17:40:56.090] - queued futures: [n=2] TRUE, TRUE
[17:40:56.091] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:56.091]  length: 0 (resolved future 2)
[17:40:56.091] Relaying remaining futures
[17:40:56.091] signalConditionsASAP(NULL, pos=0) ...
[17:40:56.091] - nx: 2
[17:40:56.091] - relay: TRUE
[17:40:56.091] - stdout: TRUE
[17:40:56.091] - signal: TRUE
[17:40:56.092] - resignal: FALSE
[17:40:56.092] - force: TRUE
[17:40:56.092] - relayed: [n=2] TRUE, TRUE
[17:40:56.092] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:56.092] - relayed: [n=2] TRUE, TRUE
[17:40:56.092] - queued futures: [n=2] TRUE, TRUE
[17:40:56.092] signalConditionsASAP(NULL, pos=0) ... done
[17:40:56.092] resolve() on list ... DONE
[17:40:56.093]  - Number of value chunks collected: 2
[17:40:56.093] Resolving 2 futures (chunks) ... DONE
[17:40:56.093] Reducing values from 2 chunks ...
[17:40:56.093]  - Number of values collected after concatenation: 4
[17:40:56.093]  - Number of values expected: 4
[17:40:56.093] Reducing values from 2 chunks ... DONE
[17:40:56.093] future_lapply() ... DONE
[17:40:56.094] future_lapply() ...
[17:40:56.101] Number of chunks: 2
[17:40:56.101] getGlobalsAndPackagesXApply() ...
[17:40:56.101]  - future.globals: TRUE
[17:40:56.102] getGlobalsAndPackages() ...
[17:40:56.102] Searching for globals...
[17:40:56.110] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:40:56.110] Searching for globals ... DONE
[17:40:56.110] Resolving globals: FALSE
[17:40:56.111] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:40:56.112] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:56.112] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.112] - packages: [1] ‘future.apply’
[17:40:56.113] getGlobalsAndPackages() ... DONE
[17:40:56.113]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.113]  - needed namespaces: [n=1] ‘future.apply’
[17:40:56.113] Finding globals ... DONE
[17:40:56.113]  - use_args: TRUE
[17:40:56.113]  - Getting '...' globals ...
[17:40:56.114] resolve() on list ...
[17:40:56.114]  recursive: 0
[17:40:56.114]  length: 1
[17:40:56.114]  elements: ‘...’
[17:40:56.114]  length: 0 (resolved future 1)
[17:40:56.114] resolve() on list ... DONE
[17:40:56.114]    - '...' content: [n=1] ‘y’
[17:40:56.114] List of 1
[17:40:56.114]  $ ...:List of 1
[17:40:56.114]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:56.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.114]  - attr(*, "where")=List of 1
[17:40:56.114]   ..$ ...:<environment: 0x564f2fceca80> 
[17:40:56.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.114]  - attr(*, "resolved")= logi TRUE
[17:40:56.114]  - attr(*, "total_size")= num NA
[17:40:56.118]  - Getting '...' globals ... DONE
[17:40:56.118] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:56.118] List of 8
[17:40:56.118]  $ ...future.FUN:function (x, ...)  
[17:40:56.118]  $ x_FUN        :function (x, y)  
[17:40:56.118]  $ times        : int 15
[17:40:56.118]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.118]  $ stop_if_not  :function (...)  
[17:40:56.118]  $ dim          : int [1:2] 3 5
[17:40:56.118]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:56.118]  $ ...          :List of 1
[17:40:56.118]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:56.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.118]  - attr(*, "where")=List of 8
[17:40:56.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:56.118]   ..$ ...          :<environment: 0x564f2fceca80> 
[17:40:56.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.118]  - attr(*, "resolved")= logi FALSE
[17:40:56.118]  - attr(*, "total_size")= num 98600
[17:40:56.124] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:56.124] getGlobalsAndPackagesXApply() ... DONE
[17:40:56.125] Number of futures (= number of chunks): 2
[17:40:56.127] Launching 2 futures (chunks) ...
[17:40:56.127] Chunk #1 of 2 ...
[17:40:56.128]  - Finding globals in 'X' for chunk #1 ...
[17:40:56.128] getGlobalsAndPackages() ...
[17:40:56.128] Searching for globals...
[17:40:56.128] 
[17:40:56.128] Searching for globals ... DONE
[17:40:56.128] - globals: [0] <none>
[17:40:56.129] getGlobalsAndPackages() ... DONE
[17:40:56.129]    + additional globals found: [n=0] 
[17:40:56.129]    + additional namespaces needed: [n=0] 
[17:40:56.129]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:56.129]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:56.129]  - seeds: <none>
[17:40:56.129] getGlobalsAndPackages() ...
[17:40:56.130] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.130] Resolving globals: FALSE
[17:40:56.130] Tweak future expression to call with '...' arguments ...
[17:40:56.130] {
[17:40:56.130]     do.call(function(...) {
[17:40:56.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.130]             on.exit(options(oopts), add = TRUE)
[17:40:56.130]         }
[17:40:56.130]         {
[17:40:56.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.130]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.130]             })
[17:40:56.130]         }
[17:40:56.130]     }, args = future.call.arguments)
[17:40:56.130] }
[17:40:56.130] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.131] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.131] - packages: [1] ‘future.apply’
[17:40:56.131] getGlobalsAndPackages() ... DONE
[17:40:56.132] run() for ‘Future’ ...
[17:40:56.132] - state: ‘created’
[17:40:56.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.137] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.137]   - Field: ‘label’
[17:40:56.137]   - Field: ‘local’
[17:40:56.137]   - Field: ‘owner’
[17:40:56.138]   - Field: ‘envir’
[17:40:56.138]   - Field: ‘workers’
[17:40:56.138]   - Field: ‘packages’
[17:40:56.138]   - Field: ‘gc’
[17:40:56.138]   - Field: ‘job’
[17:40:56.138]   - Field: ‘conditions’
[17:40:56.138]   - Field: ‘expr’
[17:40:56.139]   - Field: ‘uuid’
[17:40:56.139]   - Field: ‘seed’
[17:40:56.139]   - Field: ‘version’
[17:40:56.139]   - Field: ‘result’
[17:40:56.139]   - Field: ‘asynchronous’
[17:40:56.139]   - Field: ‘calls’
[17:40:56.139]   - Field: ‘globals’
[17:40:56.139]   - Field: ‘stdout’
[17:40:56.139]   - Field: ‘earlySignal’
[17:40:56.140]   - Field: ‘lazy’
[17:40:56.140]   - Field: ‘state’
[17:40:56.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.140] - Launch lazy future ...
[17:40:56.140] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.140] Packages needed by future strategies (n = 0): <none>
[17:40:56.141] {
[17:40:56.141]     {
[17:40:56.141]         {
[17:40:56.141]             ...future.startTime <- base::Sys.time()
[17:40:56.141]             {
[17:40:56.141]                 {
[17:40:56.141]                   {
[17:40:56.141]                     {
[17:40:56.141]                       {
[17:40:56.141]                         base::local({
[17:40:56.141]                           has_future <- base::requireNamespace("future", 
[17:40:56.141]                             quietly = TRUE)
[17:40:56.141]                           if (has_future) {
[17:40:56.141]                             ns <- base::getNamespace("future")
[17:40:56.141]                             version <- ns[[".package"]][["version"]]
[17:40:56.141]                             if (is.null(version)) 
[17:40:56.141]                               version <- utils::packageVersion("future")
[17:40:56.141]                           }
[17:40:56.141]                           else {
[17:40:56.141]                             version <- NULL
[17:40:56.141]                           }
[17:40:56.141]                           if (!has_future || version < "1.8.0") {
[17:40:56.141]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.141]                               "", base::R.version$version.string), 
[17:40:56.141]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.141]                                 base::R.version$platform, 8 * 
[17:40:56.141]                                   base::.Machine$sizeof.pointer), 
[17:40:56.141]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.141]                                 "release", "version")], collapse = " "), 
[17:40:56.141]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.141]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.141]                               info)
[17:40:56.141]                             info <- base::paste(info, collapse = "; ")
[17:40:56.141]                             if (!has_future) {
[17:40:56.141]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.141]                                 info)
[17:40:56.141]                             }
[17:40:56.141]                             else {
[17:40:56.141]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.141]                                 info, version)
[17:40:56.141]                             }
[17:40:56.141]                             base::stop(msg)
[17:40:56.141]                           }
[17:40:56.141]                         })
[17:40:56.141]                       }
[17:40:56.141]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.141]                       base::options(mc.cores = 1L)
[17:40:56.141]                     }
[17:40:56.141]                     base::local({
[17:40:56.141]                       for (pkg in "future.apply") {
[17:40:56.141]                         base::loadNamespace(pkg)
[17:40:56.141]                         base::library(pkg, character.only = TRUE)
[17:40:56.141]                       }
[17:40:56.141]                     })
[17:40:56.141]                   }
[17:40:56.141]                   options(future.plan = NULL)
[17:40:56.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.141]                 }
[17:40:56.141]                 ...future.workdir <- getwd()
[17:40:56.141]             }
[17:40:56.141]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.141]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.141]         }
[17:40:56.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.141]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:56.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.141]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.141]             base::names(...future.oldOptions))
[17:40:56.141]     }
[17:40:56.141]     if (FALSE) {
[17:40:56.141]     }
[17:40:56.141]     else {
[17:40:56.141]         if (TRUE) {
[17:40:56.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.141]                 open = "w")
[17:40:56.141]         }
[17:40:56.141]         else {
[17:40:56.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.141]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.141]         }
[17:40:56.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.141]             base::sink(type = "output", split = FALSE)
[17:40:56.141]             base::close(...future.stdout)
[17:40:56.141]         }, add = TRUE)
[17:40:56.141]     }
[17:40:56.141]     ...future.frame <- base::sys.nframe()
[17:40:56.141]     ...future.conditions <- base::list()
[17:40:56.141]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.141]     if (FALSE) {
[17:40:56.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.141]     }
[17:40:56.141]     ...future.result <- base::tryCatch({
[17:40:56.141]         base::withCallingHandlers({
[17:40:56.141]             ...future.value <- base::withVisible(base::local({
[17:40:56.141]                 withCallingHandlers({
[17:40:56.141]                   {
[17:40:56.141]                     do.call(function(...) {
[17:40:56.141]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.141]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.141]                         ...future.globals.maxSize)) {
[17:40:56.141]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.141]                         on.exit(options(oopts), add = TRUE)
[17:40:56.141]                       }
[17:40:56.141]                       {
[17:40:56.141]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.141]                           FUN = function(jj) {
[17:40:56.141]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.141]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.141]                           })
[17:40:56.141]                       }
[17:40:56.141]                     }, args = future.call.arguments)
[17:40:56.141]                   }
[17:40:56.141]                 }, immediateCondition = function(cond) {
[17:40:56.141]                   save_rds <- function (object, pathname, ...) 
[17:40:56.141]                   {
[17:40:56.141]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.141]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.141]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.141]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.141]                         fi_tmp[["mtime"]])
[17:40:56.141]                     }
[17:40:56.141]                     tryCatch({
[17:40:56.141]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.141]                     }, error = function(ex) {
[17:40:56.141]                       msg <- conditionMessage(ex)
[17:40:56.141]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.141]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.141]                         fi_tmp[["mtime"]], msg)
[17:40:56.141]                       ex$message <- msg
[17:40:56.141]                       stop(ex)
[17:40:56.141]                     })
[17:40:56.141]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.141]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.141]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.141]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.141]                       fi <- file.info(pathname)
[17:40:56.141]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.141]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.141]                         fi[["size"]], fi[["mtime"]])
[17:40:56.141]                       stop(msg)
[17:40:56.141]                     }
[17:40:56.141]                     invisible(pathname)
[17:40:56.141]                   }
[17:40:56.141]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.141]                     rootPath = tempdir()) 
[17:40:56.141]                   {
[17:40:56.141]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.141]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.141]                       tmpdir = path, fileext = ".rds")
[17:40:56.141]                     save_rds(obj, file)
[17:40:56.141]                   }
[17:40:56.141]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.141]                   {
[17:40:56.141]                     inherits <- base::inherits
[17:40:56.141]                     invokeRestart <- base::invokeRestart
[17:40:56.141]                     is.null <- base::is.null
[17:40:56.141]                     muffled <- FALSE
[17:40:56.141]                     if (inherits(cond, "message")) {
[17:40:56.141]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.141]                       if (muffled) 
[17:40:56.141]                         invokeRestart("muffleMessage")
[17:40:56.141]                     }
[17:40:56.141]                     else if (inherits(cond, "warning")) {
[17:40:56.141]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.141]                       if (muffled) 
[17:40:56.141]                         invokeRestart("muffleWarning")
[17:40:56.141]                     }
[17:40:56.141]                     else if (inherits(cond, "condition")) {
[17:40:56.141]                       if (!is.null(pattern)) {
[17:40:56.141]                         computeRestarts <- base::computeRestarts
[17:40:56.141]                         grepl <- base::grepl
[17:40:56.141]                         restarts <- computeRestarts(cond)
[17:40:56.141]                         for (restart in restarts) {
[17:40:56.141]                           name <- restart$name
[17:40:56.141]                           if (is.null(name)) 
[17:40:56.141]                             next
[17:40:56.141]                           if (!grepl(pattern, name)) 
[17:40:56.141]                             next
[17:40:56.141]                           invokeRestart(restart)
[17:40:56.141]                           muffled <- TRUE
[17:40:56.141]                           break
[17:40:56.141]                         }
[17:40:56.141]                       }
[17:40:56.141]                     }
[17:40:56.141]                     invisible(muffled)
[17:40:56.141]                   }
[17:40:56.141]                   muffleCondition(cond)
[17:40:56.141]                 })
[17:40:56.141]             }))
[17:40:56.141]             future::FutureResult(value = ...future.value$value, 
[17:40:56.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.141]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.141]                     ...future.globalenv.names))
[17:40:56.141]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.141]         }, condition = base::local({
[17:40:56.141]             c <- base::c
[17:40:56.141]             inherits <- base::inherits
[17:40:56.141]             invokeRestart <- base::invokeRestart
[17:40:56.141]             length <- base::length
[17:40:56.141]             list <- base::list
[17:40:56.141]             seq.int <- base::seq.int
[17:40:56.141]             signalCondition <- base::signalCondition
[17:40:56.141]             sys.calls <- base::sys.calls
[17:40:56.141]             `[[` <- base::`[[`
[17:40:56.141]             `+` <- base::`+`
[17:40:56.141]             `<<-` <- base::`<<-`
[17:40:56.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.141]                   3L)]
[17:40:56.141]             }
[17:40:56.141]             function(cond) {
[17:40:56.141]                 is_error <- inherits(cond, "error")
[17:40:56.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.141]                   NULL)
[17:40:56.141]                 if (is_error) {
[17:40:56.141]                   sessionInformation <- function() {
[17:40:56.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.141]                       search = base::search(), system = base::Sys.info())
[17:40:56.141]                   }
[17:40:56.141]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.141]                     cond$call), session = sessionInformation(), 
[17:40:56.141]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.141]                   signalCondition(cond)
[17:40:56.141]                 }
[17:40:56.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.141]                 "immediateCondition"))) {
[17:40:56.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.141]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.141]                   if (TRUE && !signal) {
[17:40:56.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.141]                     {
[17:40:56.141]                       inherits <- base::inherits
[17:40:56.141]                       invokeRestart <- base::invokeRestart
[17:40:56.141]                       is.null <- base::is.null
[17:40:56.141]                       muffled <- FALSE
[17:40:56.141]                       if (inherits(cond, "message")) {
[17:40:56.141]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.141]                         if (muffled) 
[17:40:56.141]                           invokeRestart("muffleMessage")
[17:40:56.141]                       }
[17:40:56.141]                       else if (inherits(cond, "warning")) {
[17:40:56.141]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.141]                         if (muffled) 
[17:40:56.141]                           invokeRestart("muffleWarning")
[17:40:56.141]                       }
[17:40:56.141]                       else if (inherits(cond, "condition")) {
[17:40:56.141]                         if (!is.null(pattern)) {
[17:40:56.141]                           computeRestarts <- base::computeRestarts
[17:40:56.141]                           grepl <- base::grepl
[17:40:56.141]                           restarts <- computeRestarts(cond)
[17:40:56.141]                           for (restart in restarts) {
[17:40:56.141]                             name <- restart$name
[17:40:56.141]                             if (is.null(name)) 
[17:40:56.141]                               next
[17:40:56.141]                             if (!grepl(pattern, name)) 
[17:40:56.141]                               next
[17:40:56.141]                             invokeRestart(restart)
[17:40:56.141]                             muffled <- TRUE
[17:40:56.141]                             break
[17:40:56.141]                           }
[17:40:56.141]                         }
[17:40:56.141]                       }
[17:40:56.141]                       invisible(muffled)
[17:40:56.141]                     }
[17:40:56.141]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.141]                   }
[17:40:56.141]                 }
[17:40:56.141]                 else {
[17:40:56.141]                   if (TRUE) {
[17:40:56.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.141]                     {
[17:40:56.141]                       inherits <- base::inherits
[17:40:56.141]                       invokeRestart <- base::invokeRestart
[17:40:56.141]                       is.null <- base::is.null
[17:40:56.141]                       muffled <- FALSE
[17:40:56.141]                       if (inherits(cond, "message")) {
[17:40:56.141]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.141]                         if (muffled) 
[17:40:56.141]                           invokeRestart("muffleMessage")
[17:40:56.141]                       }
[17:40:56.141]                       else if (inherits(cond, "warning")) {
[17:40:56.141]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.141]                         if (muffled) 
[17:40:56.141]                           invokeRestart("muffleWarning")
[17:40:56.141]                       }
[17:40:56.141]                       else if (inherits(cond, "condition")) {
[17:40:56.141]                         if (!is.null(pattern)) {
[17:40:56.141]                           computeRestarts <- base::computeRestarts
[17:40:56.141]                           grepl <- base::grepl
[17:40:56.141]                           restarts <- computeRestarts(cond)
[17:40:56.141]                           for (restart in restarts) {
[17:40:56.141]                             name <- restart$name
[17:40:56.141]                             if (is.null(name)) 
[17:40:56.141]                               next
[17:40:56.141]                             if (!grepl(pattern, name)) 
[17:40:56.141]                               next
[17:40:56.141]                             invokeRestart(restart)
[17:40:56.141]                             muffled <- TRUE
[17:40:56.141]                             break
[17:40:56.141]                           }
[17:40:56.141]                         }
[17:40:56.141]                       }
[17:40:56.141]                       invisible(muffled)
[17:40:56.141]                     }
[17:40:56.141]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.141]                   }
[17:40:56.141]                 }
[17:40:56.141]             }
[17:40:56.141]         }))
[17:40:56.141]     }, error = function(ex) {
[17:40:56.141]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.141]                 ...future.rng), started = ...future.startTime, 
[17:40:56.141]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.141]             version = "1.8"), class = "FutureResult")
[17:40:56.141]     }, finally = {
[17:40:56.141]         if (!identical(...future.workdir, getwd())) 
[17:40:56.141]             setwd(...future.workdir)
[17:40:56.141]         {
[17:40:56.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.141]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.141]             }
[17:40:56.141]             base::options(...future.oldOptions)
[17:40:56.141]             if (.Platform$OS.type == "windows") {
[17:40:56.141]                 old_names <- names(...future.oldEnvVars)
[17:40:56.141]                 envs <- base::Sys.getenv()
[17:40:56.141]                 names <- names(envs)
[17:40:56.141]                 common <- intersect(names, old_names)
[17:40:56.141]                 added <- setdiff(names, old_names)
[17:40:56.141]                 removed <- setdiff(old_names, names)
[17:40:56.141]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.141]                   envs[common]]
[17:40:56.141]                 NAMES <- toupper(changed)
[17:40:56.141]                 args <- list()
[17:40:56.141]                 for (kk in seq_along(NAMES)) {
[17:40:56.141]                   name <- changed[[kk]]
[17:40:56.141]                   NAME <- NAMES[[kk]]
[17:40:56.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.141]                     next
[17:40:56.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.141]                 }
[17:40:56.141]                 NAMES <- toupper(added)
[17:40:56.141]                 for (kk in seq_along(NAMES)) {
[17:40:56.141]                   name <- added[[kk]]
[17:40:56.141]                   NAME <- NAMES[[kk]]
[17:40:56.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.141]                     next
[17:40:56.141]                   args[[name]] <- ""
[17:40:56.141]                 }
[17:40:56.141]                 NAMES <- toupper(removed)
[17:40:56.141]                 for (kk in seq_along(NAMES)) {
[17:40:56.141]                   name <- removed[[kk]]
[17:40:56.141]                   NAME <- NAMES[[kk]]
[17:40:56.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.141]                     next
[17:40:56.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.141]                 }
[17:40:56.141]                 if (length(args) > 0) 
[17:40:56.141]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.141]             }
[17:40:56.141]             else {
[17:40:56.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.141]             }
[17:40:56.141]             {
[17:40:56.141]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.141]                   0L) {
[17:40:56.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.141]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.141]                   base::options(opts)
[17:40:56.141]                 }
[17:40:56.141]                 {
[17:40:56.141]                   {
[17:40:56.141]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.141]                     NULL
[17:40:56.141]                   }
[17:40:56.141]                   options(future.plan = NULL)
[17:40:56.141]                   if (is.na(NA_character_)) 
[17:40:56.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.141]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.141]                     envir = parent.frame()) 
[17:40:56.141]                   {
[17:40:56.141]                     default_workers <- missing(workers)
[17:40:56.141]                     if (is.function(workers)) 
[17:40:56.141]                       workers <- workers()
[17:40:56.141]                     workers <- structure(as.integer(workers), 
[17:40:56.141]                       class = class(workers))
[17:40:56.141]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.141]                       1L)
[17:40:56.141]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.141]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.141]                       if (default_workers) 
[17:40:56.141]                         supportsMulticore(warn = TRUE)
[17:40:56.141]                       return(sequential(..., envir = envir))
[17:40:56.141]                     }
[17:40:56.141]                     oopts <- options(mc.cores = workers)
[17:40:56.141]                     on.exit(options(oopts))
[17:40:56.141]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.141]                       envir = envir)
[17:40:56.141]                     if (!future$lazy) 
[17:40:56.141]                       future <- run(future)
[17:40:56.141]                     invisible(future)
[17:40:56.141]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.141]                 }
[17:40:56.141]             }
[17:40:56.141]         }
[17:40:56.141]     })
[17:40:56.141]     if (TRUE) {
[17:40:56.141]         base::sink(type = "output", split = FALSE)
[17:40:56.141]         if (TRUE) {
[17:40:56.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.141]         }
[17:40:56.141]         else {
[17:40:56.141]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.141]         }
[17:40:56.141]         base::close(...future.stdout)
[17:40:56.141]         ...future.stdout <- NULL
[17:40:56.141]     }
[17:40:56.141]     ...future.result$conditions <- ...future.conditions
[17:40:56.141]     ...future.result$finished <- base::Sys.time()
[17:40:56.141]     ...future.result
[17:40:56.141] }
[17:40:56.144] assign_globals() ...
[17:40:56.144] List of 11
[17:40:56.144]  $ ...future.FUN            :function (x, ...)  
[17:40:56.144]  $ x_FUN                    :function (x, y)  
[17:40:56.144]  $ times                    : int 15
[17:40:56.144]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.144]  $ stop_if_not              :function (...)  
[17:40:56.144]  $ dim                      : int [1:2] 3 5
[17:40:56.144]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:56.144]  $ future.call.arguments    :List of 1
[17:40:56.144]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:56.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.144]  $ ...future.elements_ii    :List of 2
[17:40:56.144]   ..$ A: num 50
[17:40:56.144]   ..$ B: num 60
[17:40:56.144]  $ ...future.seeds_ii       : NULL
[17:40:56.144]  $ ...future.globals.maxSize: NULL
[17:40:56.144]  - attr(*, "resolved")= logi FALSE
[17:40:56.144]  - attr(*, "total_size")= num 98600
[17:40:56.144]  - attr(*, "where")=List of 11
[17:40:56.144]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.144]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.144]  - attr(*, "already-done")= logi TRUE
[17:40:56.153] - copied ‘...future.FUN’ to environment
[17:40:56.153] - reassign environment for ‘x_FUN’
[17:40:56.153] - copied ‘x_FUN’ to environment
[17:40:56.153] - copied ‘times’ to environment
[17:40:56.153] - copied ‘stopf’ to environment
[17:40:56.155] - copied ‘stop_if_not’ to environment
[17:40:56.155] - copied ‘dim’ to environment
[17:40:56.156] - copied ‘valid_types’ to environment
[17:40:56.156] - copied ‘future.call.arguments’ to environment
[17:40:56.156] - copied ‘...future.elements_ii’ to environment
[17:40:56.156] - copied ‘...future.seeds_ii’ to environment
[17:40:56.156] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.156] assign_globals() ... done
[17:40:56.156] requestCore(): workers = 2
[17:40:56.159] MulticoreFuture started
[17:40:56.160] - Launch lazy future ... done
[17:40:56.160] run() for ‘MulticoreFuture’ ... done
[17:40:56.161] Created future:
[17:40:56.161] plan(): Setting new future strategy stack:
[17:40:56.161] List of future strategies:
[17:40:56.161] 1. sequential:
[17:40:56.161]    - args: function (..., envir = parent.frame())
[17:40:56.161]    - tweaked: FALSE
[17:40:56.161]    - call: NULL
[17:40:56.163] plan(): nbrOfWorkers() = 1
[17:40:56.166] plan(): Setting new future strategy stack:
[17:40:56.166] List of future strategies:
[17:40:56.166] 1. multicore:
[17:40:56.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.166]    - tweaked: FALSE
[17:40:56.166]    - call: plan(strategy)
[17:40:56.174] plan(): nbrOfWorkers() = 2
[17:40:56.161] MulticoreFuture:
[17:40:56.161] Label: ‘future_vapply-1’
[17:40:56.161] Expression:
[17:40:56.161] {
[17:40:56.161]     do.call(function(...) {
[17:40:56.161]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.161]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.161]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.161]             on.exit(options(oopts), add = TRUE)
[17:40:56.161]         }
[17:40:56.161]         {
[17:40:56.161]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.161]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.161]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.161]             })
[17:40:56.161]         }
[17:40:56.161]     }, args = future.call.arguments)
[17:40:56.161] }
[17:40:56.161] Lazy evaluation: FALSE
[17:40:56.161] Asynchronous evaluation: TRUE
[17:40:56.161] Local evaluation: TRUE
[17:40:56.161] Environment: R_GlobalEnv
[17:40:56.161] Capture standard output: TRUE
[17:40:56.161] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.161] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.161] Packages: 1 packages (‘future.apply’)
[17:40:56.161] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.161] Resolved: TRUE
[17:40:56.161] Value: <not collected>
[17:40:56.161] Conditions captured: <none>
[17:40:56.161] Early signaling: FALSE
[17:40:56.161] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.161] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.175] Chunk #1 of 2 ... DONE
[17:40:56.176] Chunk #2 of 2 ...
[17:40:56.176]  - Finding globals in 'X' for chunk #2 ...
[17:40:56.176] getGlobalsAndPackages() ...
[17:40:56.176] Searching for globals...
[17:40:56.177] 
[17:40:56.177] Searching for globals ... DONE
[17:40:56.177] - globals: [0] <none>
[17:40:56.177] getGlobalsAndPackages() ... DONE
[17:40:56.178]    + additional globals found: [n=0] 
[17:40:56.178]    + additional namespaces needed: [n=0] 
[17:40:56.178]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:56.178]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:56.179]  - seeds: <none>
[17:40:56.179] getGlobalsAndPackages() ...
[17:40:56.179] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.179] Resolving globals: FALSE
[17:40:56.180] Tweak future expression to call with '...' arguments ...
[17:40:56.180] {
[17:40:56.180]     do.call(function(...) {
[17:40:56.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.180]             on.exit(options(oopts), add = TRUE)
[17:40:56.180]         }
[17:40:56.180]         {
[17:40:56.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.180]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.180]             })
[17:40:56.180]         }
[17:40:56.180]     }, args = future.call.arguments)
[17:40:56.180] }
[17:40:56.181] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.182] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.182] - packages: [1] ‘future.apply’
[17:40:56.182] getGlobalsAndPackages() ... DONE
[17:40:56.183] run() for ‘Future’ ...
[17:40:56.183] - state: ‘created’
[17:40:56.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.189] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.189]   - Field: ‘label’
[17:40:56.189]   - Field: ‘local’
[17:40:56.190]   - Field: ‘owner’
[17:40:56.190]   - Field: ‘envir’
[17:40:56.190]   - Field: ‘workers’
[17:40:56.190]   - Field: ‘packages’
[17:40:56.190]   - Field: ‘gc’
[17:40:56.190]   - Field: ‘job’
[17:40:56.190]   - Field: ‘conditions’
[17:40:56.190]   - Field: ‘expr’
[17:40:56.191]   - Field: ‘uuid’
[17:40:56.191]   - Field: ‘seed’
[17:40:56.191]   - Field: ‘version’
[17:40:56.191]   - Field: ‘result’
[17:40:56.191]   - Field: ‘asynchronous’
[17:40:56.191]   - Field: ‘calls’
[17:40:56.192]   - Field: ‘globals’
[17:40:56.192]   - Field: ‘stdout’
[17:40:56.192]   - Field: ‘earlySignal’
[17:40:56.192]   - Field: ‘lazy’
[17:40:56.192]   - Field: ‘state’
[17:40:56.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.192] - Launch lazy future ...
[17:40:56.193] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.193] Packages needed by future strategies (n = 0): <none>
[17:40:56.194] {
[17:40:56.194]     {
[17:40:56.194]         {
[17:40:56.194]             ...future.startTime <- base::Sys.time()
[17:40:56.194]             {
[17:40:56.194]                 {
[17:40:56.194]                   {
[17:40:56.194]                     {
[17:40:56.194]                       {
[17:40:56.194]                         base::local({
[17:40:56.194]                           has_future <- base::requireNamespace("future", 
[17:40:56.194]                             quietly = TRUE)
[17:40:56.194]                           if (has_future) {
[17:40:56.194]                             ns <- base::getNamespace("future")
[17:40:56.194]                             version <- ns[[".package"]][["version"]]
[17:40:56.194]                             if (is.null(version)) 
[17:40:56.194]                               version <- utils::packageVersion("future")
[17:40:56.194]                           }
[17:40:56.194]                           else {
[17:40:56.194]                             version <- NULL
[17:40:56.194]                           }
[17:40:56.194]                           if (!has_future || version < "1.8.0") {
[17:40:56.194]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.194]                               "", base::R.version$version.string), 
[17:40:56.194]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.194]                                 base::R.version$platform, 8 * 
[17:40:56.194]                                   base::.Machine$sizeof.pointer), 
[17:40:56.194]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.194]                                 "release", "version")], collapse = " "), 
[17:40:56.194]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.194]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.194]                               info)
[17:40:56.194]                             info <- base::paste(info, collapse = "; ")
[17:40:56.194]                             if (!has_future) {
[17:40:56.194]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.194]                                 info)
[17:40:56.194]                             }
[17:40:56.194]                             else {
[17:40:56.194]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.194]                                 info, version)
[17:40:56.194]                             }
[17:40:56.194]                             base::stop(msg)
[17:40:56.194]                           }
[17:40:56.194]                         })
[17:40:56.194]                       }
[17:40:56.194]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.194]                       base::options(mc.cores = 1L)
[17:40:56.194]                     }
[17:40:56.194]                     base::local({
[17:40:56.194]                       for (pkg in "future.apply") {
[17:40:56.194]                         base::loadNamespace(pkg)
[17:40:56.194]                         base::library(pkg, character.only = TRUE)
[17:40:56.194]                       }
[17:40:56.194]                     })
[17:40:56.194]                   }
[17:40:56.194]                   options(future.plan = NULL)
[17:40:56.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.194]                 }
[17:40:56.194]                 ...future.workdir <- getwd()
[17:40:56.194]             }
[17:40:56.194]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.194]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.194]         }
[17:40:56.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.194]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:56.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.194]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.194]             base::names(...future.oldOptions))
[17:40:56.194]     }
[17:40:56.194]     if (FALSE) {
[17:40:56.194]     }
[17:40:56.194]     else {
[17:40:56.194]         if (TRUE) {
[17:40:56.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.194]                 open = "w")
[17:40:56.194]         }
[17:40:56.194]         else {
[17:40:56.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.194]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.194]         }
[17:40:56.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.194]             base::sink(type = "output", split = FALSE)
[17:40:56.194]             base::close(...future.stdout)
[17:40:56.194]         }, add = TRUE)
[17:40:56.194]     }
[17:40:56.194]     ...future.frame <- base::sys.nframe()
[17:40:56.194]     ...future.conditions <- base::list()
[17:40:56.194]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.194]     if (FALSE) {
[17:40:56.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.194]     }
[17:40:56.194]     ...future.result <- base::tryCatch({
[17:40:56.194]         base::withCallingHandlers({
[17:40:56.194]             ...future.value <- base::withVisible(base::local({
[17:40:56.194]                 withCallingHandlers({
[17:40:56.194]                   {
[17:40:56.194]                     do.call(function(...) {
[17:40:56.194]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.194]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.194]                         ...future.globals.maxSize)) {
[17:40:56.194]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.194]                         on.exit(options(oopts), add = TRUE)
[17:40:56.194]                       }
[17:40:56.194]                       {
[17:40:56.194]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.194]                           FUN = function(jj) {
[17:40:56.194]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.194]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.194]                           })
[17:40:56.194]                       }
[17:40:56.194]                     }, args = future.call.arguments)
[17:40:56.194]                   }
[17:40:56.194]                 }, immediateCondition = function(cond) {
[17:40:56.194]                   save_rds <- function (object, pathname, ...) 
[17:40:56.194]                   {
[17:40:56.194]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.194]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.194]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.194]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.194]                         fi_tmp[["mtime"]])
[17:40:56.194]                     }
[17:40:56.194]                     tryCatch({
[17:40:56.194]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.194]                     }, error = function(ex) {
[17:40:56.194]                       msg <- conditionMessage(ex)
[17:40:56.194]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.194]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.194]                         fi_tmp[["mtime"]], msg)
[17:40:56.194]                       ex$message <- msg
[17:40:56.194]                       stop(ex)
[17:40:56.194]                     })
[17:40:56.194]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.194]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.194]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.194]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.194]                       fi <- file.info(pathname)
[17:40:56.194]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.194]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.194]                         fi[["size"]], fi[["mtime"]])
[17:40:56.194]                       stop(msg)
[17:40:56.194]                     }
[17:40:56.194]                     invisible(pathname)
[17:40:56.194]                   }
[17:40:56.194]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.194]                     rootPath = tempdir()) 
[17:40:56.194]                   {
[17:40:56.194]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.194]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.194]                       tmpdir = path, fileext = ".rds")
[17:40:56.194]                     save_rds(obj, file)
[17:40:56.194]                   }
[17:40:56.194]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.194]                   {
[17:40:56.194]                     inherits <- base::inherits
[17:40:56.194]                     invokeRestart <- base::invokeRestart
[17:40:56.194]                     is.null <- base::is.null
[17:40:56.194]                     muffled <- FALSE
[17:40:56.194]                     if (inherits(cond, "message")) {
[17:40:56.194]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.194]                       if (muffled) 
[17:40:56.194]                         invokeRestart("muffleMessage")
[17:40:56.194]                     }
[17:40:56.194]                     else if (inherits(cond, "warning")) {
[17:40:56.194]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.194]                       if (muffled) 
[17:40:56.194]                         invokeRestart("muffleWarning")
[17:40:56.194]                     }
[17:40:56.194]                     else if (inherits(cond, "condition")) {
[17:40:56.194]                       if (!is.null(pattern)) {
[17:40:56.194]                         computeRestarts <- base::computeRestarts
[17:40:56.194]                         grepl <- base::grepl
[17:40:56.194]                         restarts <- computeRestarts(cond)
[17:40:56.194]                         for (restart in restarts) {
[17:40:56.194]                           name <- restart$name
[17:40:56.194]                           if (is.null(name)) 
[17:40:56.194]                             next
[17:40:56.194]                           if (!grepl(pattern, name)) 
[17:40:56.194]                             next
[17:40:56.194]                           invokeRestart(restart)
[17:40:56.194]                           muffled <- TRUE
[17:40:56.194]                           break
[17:40:56.194]                         }
[17:40:56.194]                       }
[17:40:56.194]                     }
[17:40:56.194]                     invisible(muffled)
[17:40:56.194]                   }
[17:40:56.194]                   muffleCondition(cond)
[17:40:56.194]                 })
[17:40:56.194]             }))
[17:40:56.194]             future::FutureResult(value = ...future.value$value, 
[17:40:56.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.194]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.194]                     ...future.globalenv.names))
[17:40:56.194]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.194]         }, condition = base::local({
[17:40:56.194]             c <- base::c
[17:40:56.194]             inherits <- base::inherits
[17:40:56.194]             invokeRestart <- base::invokeRestart
[17:40:56.194]             length <- base::length
[17:40:56.194]             list <- base::list
[17:40:56.194]             seq.int <- base::seq.int
[17:40:56.194]             signalCondition <- base::signalCondition
[17:40:56.194]             sys.calls <- base::sys.calls
[17:40:56.194]             `[[` <- base::`[[`
[17:40:56.194]             `+` <- base::`+`
[17:40:56.194]             `<<-` <- base::`<<-`
[17:40:56.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.194]                   3L)]
[17:40:56.194]             }
[17:40:56.194]             function(cond) {
[17:40:56.194]                 is_error <- inherits(cond, "error")
[17:40:56.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.194]                   NULL)
[17:40:56.194]                 if (is_error) {
[17:40:56.194]                   sessionInformation <- function() {
[17:40:56.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.194]                       search = base::search(), system = base::Sys.info())
[17:40:56.194]                   }
[17:40:56.194]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.194]                     cond$call), session = sessionInformation(), 
[17:40:56.194]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.194]                   signalCondition(cond)
[17:40:56.194]                 }
[17:40:56.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.194]                 "immediateCondition"))) {
[17:40:56.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.194]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.194]                   if (TRUE && !signal) {
[17:40:56.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.194]                     {
[17:40:56.194]                       inherits <- base::inherits
[17:40:56.194]                       invokeRestart <- base::invokeRestart
[17:40:56.194]                       is.null <- base::is.null
[17:40:56.194]                       muffled <- FALSE
[17:40:56.194]                       if (inherits(cond, "message")) {
[17:40:56.194]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.194]                         if (muffled) 
[17:40:56.194]                           invokeRestart("muffleMessage")
[17:40:56.194]                       }
[17:40:56.194]                       else if (inherits(cond, "warning")) {
[17:40:56.194]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.194]                         if (muffled) 
[17:40:56.194]                           invokeRestart("muffleWarning")
[17:40:56.194]                       }
[17:40:56.194]                       else if (inherits(cond, "condition")) {
[17:40:56.194]                         if (!is.null(pattern)) {
[17:40:56.194]                           computeRestarts <- base::computeRestarts
[17:40:56.194]                           grepl <- base::grepl
[17:40:56.194]                           restarts <- computeRestarts(cond)
[17:40:56.194]                           for (restart in restarts) {
[17:40:56.194]                             name <- restart$name
[17:40:56.194]                             if (is.null(name)) 
[17:40:56.194]                               next
[17:40:56.194]                             if (!grepl(pattern, name)) 
[17:40:56.194]                               next
[17:40:56.194]                             invokeRestart(restart)
[17:40:56.194]                             muffled <- TRUE
[17:40:56.194]                             break
[17:40:56.194]                           }
[17:40:56.194]                         }
[17:40:56.194]                       }
[17:40:56.194]                       invisible(muffled)
[17:40:56.194]                     }
[17:40:56.194]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.194]                   }
[17:40:56.194]                 }
[17:40:56.194]                 else {
[17:40:56.194]                   if (TRUE) {
[17:40:56.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.194]                     {
[17:40:56.194]                       inherits <- base::inherits
[17:40:56.194]                       invokeRestart <- base::invokeRestart
[17:40:56.194]                       is.null <- base::is.null
[17:40:56.194]                       muffled <- FALSE
[17:40:56.194]                       if (inherits(cond, "message")) {
[17:40:56.194]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.194]                         if (muffled) 
[17:40:56.194]                           invokeRestart("muffleMessage")
[17:40:56.194]                       }
[17:40:56.194]                       else if (inherits(cond, "warning")) {
[17:40:56.194]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.194]                         if (muffled) 
[17:40:56.194]                           invokeRestart("muffleWarning")
[17:40:56.194]                       }
[17:40:56.194]                       else if (inherits(cond, "condition")) {
[17:40:56.194]                         if (!is.null(pattern)) {
[17:40:56.194]                           computeRestarts <- base::computeRestarts
[17:40:56.194]                           grepl <- base::grepl
[17:40:56.194]                           restarts <- computeRestarts(cond)
[17:40:56.194]                           for (restart in restarts) {
[17:40:56.194]                             name <- restart$name
[17:40:56.194]                             if (is.null(name)) 
[17:40:56.194]                               next
[17:40:56.194]                             if (!grepl(pattern, name)) 
[17:40:56.194]                               next
[17:40:56.194]                             invokeRestart(restart)
[17:40:56.194]                             muffled <- TRUE
[17:40:56.194]                             break
[17:40:56.194]                           }
[17:40:56.194]                         }
[17:40:56.194]                       }
[17:40:56.194]                       invisible(muffled)
[17:40:56.194]                     }
[17:40:56.194]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.194]                   }
[17:40:56.194]                 }
[17:40:56.194]             }
[17:40:56.194]         }))
[17:40:56.194]     }, error = function(ex) {
[17:40:56.194]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.194]                 ...future.rng), started = ...future.startTime, 
[17:40:56.194]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.194]             version = "1.8"), class = "FutureResult")
[17:40:56.194]     }, finally = {
[17:40:56.194]         if (!identical(...future.workdir, getwd())) 
[17:40:56.194]             setwd(...future.workdir)
[17:40:56.194]         {
[17:40:56.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.194]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.194]             }
[17:40:56.194]             base::options(...future.oldOptions)
[17:40:56.194]             if (.Platform$OS.type == "windows") {
[17:40:56.194]                 old_names <- names(...future.oldEnvVars)
[17:40:56.194]                 envs <- base::Sys.getenv()
[17:40:56.194]                 names <- names(envs)
[17:40:56.194]                 common <- intersect(names, old_names)
[17:40:56.194]                 added <- setdiff(names, old_names)
[17:40:56.194]                 removed <- setdiff(old_names, names)
[17:40:56.194]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.194]                   envs[common]]
[17:40:56.194]                 NAMES <- toupper(changed)
[17:40:56.194]                 args <- list()
[17:40:56.194]                 for (kk in seq_along(NAMES)) {
[17:40:56.194]                   name <- changed[[kk]]
[17:40:56.194]                   NAME <- NAMES[[kk]]
[17:40:56.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.194]                     next
[17:40:56.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.194]                 }
[17:40:56.194]                 NAMES <- toupper(added)
[17:40:56.194]                 for (kk in seq_along(NAMES)) {
[17:40:56.194]                   name <- added[[kk]]
[17:40:56.194]                   NAME <- NAMES[[kk]]
[17:40:56.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.194]                     next
[17:40:56.194]                   args[[name]] <- ""
[17:40:56.194]                 }
[17:40:56.194]                 NAMES <- toupper(removed)
[17:40:56.194]                 for (kk in seq_along(NAMES)) {
[17:40:56.194]                   name <- removed[[kk]]
[17:40:56.194]                   NAME <- NAMES[[kk]]
[17:40:56.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.194]                     next
[17:40:56.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.194]                 }
[17:40:56.194]                 if (length(args) > 0) 
[17:40:56.194]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.194]             }
[17:40:56.194]             else {
[17:40:56.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.194]             }
[17:40:56.194]             {
[17:40:56.194]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.194]                   0L) {
[17:40:56.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.194]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.194]                   base::options(opts)
[17:40:56.194]                 }
[17:40:56.194]                 {
[17:40:56.194]                   {
[17:40:56.194]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.194]                     NULL
[17:40:56.194]                   }
[17:40:56.194]                   options(future.plan = NULL)
[17:40:56.194]                   if (is.na(NA_character_)) 
[17:40:56.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.194]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.194]                     envir = parent.frame()) 
[17:40:56.194]                   {
[17:40:56.194]                     default_workers <- missing(workers)
[17:40:56.194]                     if (is.function(workers)) 
[17:40:56.194]                       workers <- workers()
[17:40:56.194]                     workers <- structure(as.integer(workers), 
[17:40:56.194]                       class = class(workers))
[17:40:56.194]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.194]                       1L)
[17:40:56.194]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.194]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.194]                       if (default_workers) 
[17:40:56.194]                         supportsMulticore(warn = TRUE)
[17:40:56.194]                       return(sequential(..., envir = envir))
[17:40:56.194]                     }
[17:40:56.194]                     oopts <- options(mc.cores = workers)
[17:40:56.194]                     on.exit(options(oopts))
[17:40:56.194]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.194]                       envir = envir)
[17:40:56.194]                     if (!future$lazy) 
[17:40:56.194]                       future <- run(future)
[17:40:56.194]                     invisible(future)
[17:40:56.194]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.194]                 }
[17:40:56.194]             }
[17:40:56.194]         }
[17:40:56.194]     })
[17:40:56.194]     if (TRUE) {
[17:40:56.194]         base::sink(type = "output", split = FALSE)
[17:40:56.194]         if (TRUE) {
[17:40:56.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.194]         }
[17:40:56.194]         else {
[17:40:56.194]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.194]         }
[17:40:56.194]         base::close(...future.stdout)
[17:40:56.194]         ...future.stdout <- NULL
[17:40:56.194]     }
[17:40:56.194]     ...future.result$conditions <- ...future.conditions
[17:40:56.194]     ...future.result$finished <- base::Sys.time()
[17:40:56.194]     ...future.result
[17:40:56.194] }
[17:40:56.197] assign_globals() ...
[17:40:56.198] List of 11
[17:40:56.198]  $ ...future.FUN            :function (x, ...)  
[17:40:56.198]  $ x_FUN                    :function (x, y)  
[17:40:56.198]  $ times                    : int 15
[17:40:56.198]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.198]  $ stop_if_not              :function (...)  
[17:40:56.198]  $ dim                      : int [1:2] 3 5
[17:40:56.198]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:56.198]  $ future.call.arguments    :List of 1
[17:40:56.198]   ..$ y: num [1:5] 2 4 6 8 10
[17:40:56.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.198]  $ ...future.elements_ii    :List of 2
[17:40:56.198]   ..$ C: num 70
[17:40:56.198]   ..$ D: num 80
[17:40:56.198]  $ ...future.seeds_ii       : NULL
[17:40:56.198]  $ ...future.globals.maxSize: NULL
[17:40:56.198]  - attr(*, "resolved")= logi FALSE
[17:40:56.198]  - attr(*, "total_size")= num 98600
[17:40:56.198]  - attr(*, "where")=List of 11
[17:40:56.198]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.198]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.198]  - attr(*, "already-done")= logi TRUE
[17:40:56.211] - copied ‘...future.FUN’ to environment
[17:40:56.212] - reassign environment for ‘x_FUN’
[17:40:56.212] - copied ‘x_FUN’ to environment
[17:40:56.212] - copied ‘times’ to environment
[17:40:56.212] - copied ‘stopf’ to environment
[17:40:56.212] - copied ‘stop_if_not’ to environment
[17:40:56.212] - copied ‘dim’ to environment
[17:40:56.212] - copied ‘valid_types’ to environment
[17:40:56.212] - copied ‘future.call.arguments’ to environment
[17:40:56.213] - copied ‘...future.elements_ii’ to environment
[17:40:56.213] - copied ‘...future.seeds_ii’ to environment
[17:40:56.213] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.213] assign_globals() ... done
[17:40:56.213] requestCore(): workers = 2
[17:40:56.216] MulticoreFuture started
[17:40:56.216] - Launch lazy future ... done
[17:40:56.217] run() for ‘MulticoreFuture’ ... done
[17:40:56.217] Created future:
[17:40:56.218] plan(): Setting new future strategy stack:
[17:40:56.218] List of future strategies:
[17:40:56.218] 1. sequential:
[17:40:56.218]    - args: function (..., envir = parent.frame())
[17:40:56.218]    - tweaked: FALSE
[17:40:56.218]    - call: NULL
[17:40:56.220] plan(): nbrOfWorkers() = 1
[17:40:56.222] plan(): Setting new future strategy stack:
[17:40:56.223] List of future strategies:
[17:40:56.223] 1. multicore:
[17:40:56.223]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.223]    - tweaked: FALSE
[17:40:56.223]    - call: plan(strategy)
[17:40:56.229] plan(): nbrOfWorkers() = 2
[17:40:56.218] MulticoreFuture:
[17:40:56.218] Label: ‘future_vapply-2’
[17:40:56.218] Expression:
[17:40:56.218] {
[17:40:56.218]     do.call(function(...) {
[17:40:56.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.218]             on.exit(options(oopts), add = TRUE)
[17:40:56.218]         }
[17:40:56.218]         {
[17:40:56.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.218]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.218]             })
[17:40:56.218]         }
[17:40:56.218]     }, args = future.call.arguments)
[17:40:56.218] }
[17:40:56.218] Lazy evaluation: FALSE
[17:40:56.218] Asynchronous evaluation: TRUE
[17:40:56.218] Local evaluation: TRUE
[17:40:56.218] Environment: R_GlobalEnv
[17:40:56.218] Capture standard output: TRUE
[17:40:56.218] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.218] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.218] Packages: 1 packages (‘future.apply’)
[17:40:56.218] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.218] Resolved: TRUE
[17:40:56.218] Value: <not collected>
[17:40:56.218] Conditions captured: <none>
[17:40:56.218] Early signaling: FALSE
[17:40:56.218] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.218] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.231] Chunk #2 of 2 ... DONE
[17:40:56.231] Launching 2 futures (chunks) ... DONE
[17:40:56.231] Resolving 2 futures (chunks) ...
[17:40:56.231] resolve() on list ...
[17:40:56.232]  recursive: 0
[17:40:56.232]  length: 2
[17:40:56.232] 
[17:40:56.233] Future #1
[17:40:56.234] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:56.234] - nx: 2
[17:40:56.234] - relay: TRUE
[17:40:56.234] - stdout: TRUE
[17:40:56.234] - signal: TRUE
[17:40:56.234] - resignal: FALSE
[17:40:56.235] - force: TRUE
[17:40:56.235] - relayed: [n=2] FALSE, FALSE
[17:40:56.235] - queued futures: [n=2] FALSE, FALSE
[17:40:56.235]  - until=1
[17:40:56.235]  - relaying element #1
[17:40:56.236] - relayed: [n=2] TRUE, FALSE
[17:40:56.236] - queued futures: [n=2] TRUE, FALSE
[17:40:56.236] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:56.236]  length: 1 (resolved future 1)
[17:40:56.237] Future #2
[17:40:56.238] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:56.238] - nx: 2
[17:40:56.238] - relay: TRUE
[17:40:56.238] - stdout: TRUE
[17:40:56.239] - signal: TRUE
[17:40:56.239] - resignal: FALSE
[17:40:56.239] - force: TRUE
[17:40:56.239] - relayed: [n=2] TRUE, FALSE
[17:40:56.239] - queued futures: [n=2] TRUE, FALSE
[17:40:56.239]  - until=2
[17:40:56.239]  - relaying element #2
[17:40:56.240] - relayed: [n=2] TRUE, TRUE
[17:40:56.240] - queued futures: [n=2] TRUE, TRUE
[17:40:56.240] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:56.240]  length: 0 (resolved future 2)
[17:40:56.240] Relaying remaining futures
[17:40:56.240] signalConditionsASAP(NULL, pos=0) ...
[17:40:56.240] - nx: 2
[17:40:56.240] - relay: TRUE
[17:40:56.241] - stdout: TRUE
[17:40:56.241] - signal: TRUE
[17:40:56.241] - resignal: FALSE
[17:40:56.241] - force: TRUE
[17:40:56.241] - relayed: [n=2] TRUE, TRUE
[17:40:56.241] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:56.241] - relayed: [n=2] TRUE, TRUE
[17:40:56.241] - queued futures: [n=2] TRUE, TRUE
[17:40:56.241] signalConditionsASAP(NULL, pos=0) ... done
[17:40:56.242] resolve() on list ... DONE
[17:40:56.242]  - Number of value chunks collected: 2
[17:40:56.242] Resolving 2 futures (chunks) ... DONE
[17:40:56.242] Reducing values from 2 chunks ...
[17:40:56.242]  - Number of values collected after concatenation: 4
[17:40:56.242]  - Number of values expected: 4
[17:40:56.242] Reducing values from 2 chunks ... DONE
[17:40:56.243] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:40:56.245] future_lapply() ...
[17:40:56.252] Number of chunks: 2
[17:40:56.252] getGlobalsAndPackagesXApply() ...
[17:40:56.252]  - future.globals: TRUE
[17:40:56.252] getGlobalsAndPackages() ...
[17:40:56.252] Searching for globals...
[17:40:56.258] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:56.259] Searching for globals ... DONE
[17:40:56.259] Resolving globals: FALSE
[17:40:56.260] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:40:56.260] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:56.261] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.261] - packages: [1] ‘future.apply’
[17:40:56.261] getGlobalsAndPackages() ... DONE
[17:40:56.261]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.261]  - needed namespaces: [n=1] ‘future.apply’
[17:40:56.261] Finding globals ... DONE
[17:40:56.261]  - use_args: TRUE
[17:40:56.261]  - Getting '...' globals ...
[17:40:56.262] resolve() on list ...
[17:40:56.262]  recursive: 0
[17:40:56.262]  length: 1
[17:40:56.262]  elements: ‘...’
[17:40:56.262]  length: 0 (resolved future 1)
[17:40:56.262] resolve() on list ... DONE
[17:40:56.263]    - '...' content: [n=0] 
[17:40:56.263] List of 1
[17:40:56.263]  $ ...: list()
[17:40:56.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.263]  - attr(*, "where")=List of 1
[17:40:56.263]   ..$ ...:<environment: 0x564f2fbfce00> 
[17:40:56.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.263]  - attr(*, "resolved")= logi TRUE
[17:40:56.263]  - attr(*, "total_size")= num NA
[17:40:56.266]  - Getting '...' globals ... DONE
[17:40:56.266] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:56.266] List of 8
[17:40:56.266]  $ ...future.FUN:function (x, ...)  
[17:40:56.266]  $ x_FUN        :function (x)  
[17:40:56.266]  $ times        : int 1
[17:40:56.266]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.266]  $ stop_if_not  :function (...)  
[17:40:56.266]  $ dim          : NULL
[17:40:56.266]  $ valid_types  : chr "logical"
[17:40:56.266]  $ ...          : list()
[17:40:56.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.266]  - attr(*, "where")=List of 8
[17:40:56.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:56.266]   ..$ ...          :<environment: 0x564f2fbfce00> 
[17:40:56.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.266]  - attr(*, "resolved")= logi FALSE
[17:40:56.266]  - attr(*, "total_size")= num 94200
[17:40:56.272] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:56.272] getGlobalsAndPackagesXApply() ... DONE
[17:40:56.272] Number of futures (= number of chunks): 2
[17:40:56.272] Launching 2 futures (chunks) ...
[17:40:56.272] Chunk #1 of 2 ...
[17:40:56.272]  - Finding globals in 'X' for chunk #1 ...
[17:40:56.272] getGlobalsAndPackages() ...
[17:40:56.273] Searching for globals...
[17:40:56.273] 
[17:40:56.273] Searching for globals ... DONE
[17:40:56.273] - globals: [0] <none>
[17:40:56.273] getGlobalsAndPackages() ... DONE
[17:40:56.273]    + additional globals found: [n=0] 
[17:40:56.273]    + additional namespaces needed: [n=0] 
[17:40:56.273]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:56.274]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[17:40:56.274]  - seeds: <none>
[17:40:56.274] getGlobalsAndPackages() ...
[17:40:56.274] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.274] Resolving globals: FALSE
[17:40:56.277] Tweak future expression to call with '...' arguments ...
[17:40:56.277] {
[17:40:56.277]     do.call(function(...) {
[17:40:56.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.277]             on.exit(options(oopts), add = TRUE)
[17:40:56.277]         }
[17:40:56.277]         {
[17:40:56.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.277]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.277]             })
[17:40:56.277]         }
[17:40:56.277]     }, args = future.call.arguments)
[17:40:56.277] }
[17:40:56.277] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.278] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.278] - packages: [1] ‘future.apply’
[17:40:56.278] getGlobalsAndPackages() ... DONE
[17:40:56.278] run() for ‘Future’ ...
[17:40:56.279] - state: ‘created’
[17:40:56.279] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.283] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.283]   - Field: ‘label’
[17:40:56.283]   - Field: ‘local’
[17:40:56.283]   - Field: ‘owner’
[17:40:56.284]   - Field: ‘envir’
[17:40:56.284]   - Field: ‘workers’
[17:40:56.284]   - Field: ‘packages’
[17:40:56.284]   - Field: ‘gc’
[17:40:56.284]   - Field: ‘job’
[17:40:56.284]   - Field: ‘conditions’
[17:40:56.284]   - Field: ‘expr’
[17:40:56.284]   - Field: ‘uuid’
[17:40:56.285]   - Field: ‘seed’
[17:40:56.285]   - Field: ‘version’
[17:40:56.285]   - Field: ‘result’
[17:40:56.285]   - Field: ‘asynchronous’
[17:40:56.285]   - Field: ‘calls’
[17:40:56.285]   - Field: ‘globals’
[17:40:56.285]   - Field: ‘stdout’
[17:40:56.285]   - Field: ‘earlySignal’
[17:40:56.285]   - Field: ‘lazy’
[17:40:56.286]   - Field: ‘state’
[17:40:56.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.286] - Launch lazy future ...
[17:40:56.286] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.286] Packages needed by future strategies (n = 0): <none>
[17:40:56.287] {
[17:40:56.287]     {
[17:40:56.287]         {
[17:40:56.287]             ...future.startTime <- base::Sys.time()
[17:40:56.287]             {
[17:40:56.287]                 {
[17:40:56.287]                   {
[17:40:56.287]                     {
[17:40:56.287]                       {
[17:40:56.287]                         base::local({
[17:40:56.287]                           has_future <- base::requireNamespace("future", 
[17:40:56.287]                             quietly = TRUE)
[17:40:56.287]                           if (has_future) {
[17:40:56.287]                             ns <- base::getNamespace("future")
[17:40:56.287]                             version <- ns[[".package"]][["version"]]
[17:40:56.287]                             if (is.null(version)) 
[17:40:56.287]                               version <- utils::packageVersion("future")
[17:40:56.287]                           }
[17:40:56.287]                           else {
[17:40:56.287]                             version <- NULL
[17:40:56.287]                           }
[17:40:56.287]                           if (!has_future || version < "1.8.0") {
[17:40:56.287]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.287]                               "", base::R.version$version.string), 
[17:40:56.287]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.287]                                 base::R.version$platform, 8 * 
[17:40:56.287]                                   base::.Machine$sizeof.pointer), 
[17:40:56.287]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.287]                                 "release", "version")], collapse = " "), 
[17:40:56.287]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.287]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.287]                               info)
[17:40:56.287]                             info <- base::paste(info, collapse = "; ")
[17:40:56.287]                             if (!has_future) {
[17:40:56.287]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.287]                                 info)
[17:40:56.287]                             }
[17:40:56.287]                             else {
[17:40:56.287]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.287]                                 info, version)
[17:40:56.287]                             }
[17:40:56.287]                             base::stop(msg)
[17:40:56.287]                           }
[17:40:56.287]                         })
[17:40:56.287]                       }
[17:40:56.287]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.287]                       base::options(mc.cores = 1L)
[17:40:56.287]                     }
[17:40:56.287]                     base::local({
[17:40:56.287]                       for (pkg in "future.apply") {
[17:40:56.287]                         base::loadNamespace(pkg)
[17:40:56.287]                         base::library(pkg, character.only = TRUE)
[17:40:56.287]                       }
[17:40:56.287]                     })
[17:40:56.287]                   }
[17:40:56.287]                   options(future.plan = NULL)
[17:40:56.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.287]                 }
[17:40:56.287]                 ...future.workdir <- getwd()
[17:40:56.287]             }
[17:40:56.287]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.287]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.287]         }
[17:40:56.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.287]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[17:40:56.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.287]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.287]             base::names(...future.oldOptions))
[17:40:56.287]     }
[17:40:56.287]     if (FALSE) {
[17:40:56.287]     }
[17:40:56.287]     else {
[17:40:56.287]         if (TRUE) {
[17:40:56.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.287]                 open = "w")
[17:40:56.287]         }
[17:40:56.287]         else {
[17:40:56.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.287]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.287]         }
[17:40:56.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.287]             base::sink(type = "output", split = FALSE)
[17:40:56.287]             base::close(...future.stdout)
[17:40:56.287]         }, add = TRUE)
[17:40:56.287]     }
[17:40:56.287]     ...future.frame <- base::sys.nframe()
[17:40:56.287]     ...future.conditions <- base::list()
[17:40:56.287]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.287]     if (FALSE) {
[17:40:56.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.287]     }
[17:40:56.287]     ...future.result <- base::tryCatch({
[17:40:56.287]         base::withCallingHandlers({
[17:40:56.287]             ...future.value <- base::withVisible(base::local({
[17:40:56.287]                 withCallingHandlers({
[17:40:56.287]                   {
[17:40:56.287]                     do.call(function(...) {
[17:40:56.287]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.287]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.287]                         ...future.globals.maxSize)) {
[17:40:56.287]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.287]                         on.exit(options(oopts), add = TRUE)
[17:40:56.287]                       }
[17:40:56.287]                       {
[17:40:56.287]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.287]                           FUN = function(jj) {
[17:40:56.287]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.287]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.287]                           })
[17:40:56.287]                       }
[17:40:56.287]                     }, args = future.call.arguments)
[17:40:56.287]                   }
[17:40:56.287]                 }, immediateCondition = function(cond) {
[17:40:56.287]                   save_rds <- function (object, pathname, ...) 
[17:40:56.287]                   {
[17:40:56.287]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.287]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.287]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.287]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.287]                         fi_tmp[["mtime"]])
[17:40:56.287]                     }
[17:40:56.287]                     tryCatch({
[17:40:56.287]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.287]                     }, error = function(ex) {
[17:40:56.287]                       msg <- conditionMessage(ex)
[17:40:56.287]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.287]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.287]                         fi_tmp[["mtime"]], msg)
[17:40:56.287]                       ex$message <- msg
[17:40:56.287]                       stop(ex)
[17:40:56.287]                     })
[17:40:56.287]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.287]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.287]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.287]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.287]                       fi <- file.info(pathname)
[17:40:56.287]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.287]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.287]                         fi[["size"]], fi[["mtime"]])
[17:40:56.287]                       stop(msg)
[17:40:56.287]                     }
[17:40:56.287]                     invisible(pathname)
[17:40:56.287]                   }
[17:40:56.287]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.287]                     rootPath = tempdir()) 
[17:40:56.287]                   {
[17:40:56.287]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.287]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.287]                       tmpdir = path, fileext = ".rds")
[17:40:56.287]                     save_rds(obj, file)
[17:40:56.287]                   }
[17:40:56.287]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.287]                   {
[17:40:56.287]                     inherits <- base::inherits
[17:40:56.287]                     invokeRestart <- base::invokeRestart
[17:40:56.287]                     is.null <- base::is.null
[17:40:56.287]                     muffled <- FALSE
[17:40:56.287]                     if (inherits(cond, "message")) {
[17:40:56.287]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.287]                       if (muffled) 
[17:40:56.287]                         invokeRestart("muffleMessage")
[17:40:56.287]                     }
[17:40:56.287]                     else if (inherits(cond, "warning")) {
[17:40:56.287]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.287]                       if (muffled) 
[17:40:56.287]                         invokeRestart("muffleWarning")
[17:40:56.287]                     }
[17:40:56.287]                     else if (inherits(cond, "condition")) {
[17:40:56.287]                       if (!is.null(pattern)) {
[17:40:56.287]                         computeRestarts <- base::computeRestarts
[17:40:56.287]                         grepl <- base::grepl
[17:40:56.287]                         restarts <- computeRestarts(cond)
[17:40:56.287]                         for (restart in restarts) {
[17:40:56.287]                           name <- restart$name
[17:40:56.287]                           if (is.null(name)) 
[17:40:56.287]                             next
[17:40:56.287]                           if (!grepl(pattern, name)) 
[17:40:56.287]                             next
[17:40:56.287]                           invokeRestart(restart)
[17:40:56.287]                           muffled <- TRUE
[17:40:56.287]                           break
[17:40:56.287]                         }
[17:40:56.287]                       }
[17:40:56.287]                     }
[17:40:56.287]                     invisible(muffled)
[17:40:56.287]                   }
[17:40:56.287]                   muffleCondition(cond)
[17:40:56.287]                 })
[17:40:56.287]             }))
[17:40:56.287]             future::FutureResult(value = ...future.value$value, 
[17:40:56.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.287]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.287]                     ...future.globalenv.names))
[17:40:56.287]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.287]         }, condition = base::local({
[17:40:56.287]             c <- base::c
[17:40:56.287]             inherits <- base::inherits
[17:40:56.287]             invokeRestart <- base::invokeRestart
[17:40:56.287]             length <- base::length
[17:40:56.287]             list <- base::list
[17:40:56.287]             seq.int <- base::seq.int
[17:40:56.287]             signalCondition <- base::signalCondition
[17:40:56.287]             sys.calls <- base::sys.calls
[17:40:56.287]             `[[` <- base::`[[`
[17:40:56.287]             `+` <- base::`+`
[17:40:56.287]             `<<-` <- base::`<<-`
[17:40:56.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.287]                   3L)]
[17:40:56.287]             }
[17:40:56.287]             function(cond) {
[17:40:56.287]                 is_error <- inherits(cond, "error")
[17:40:56.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.287]                   NULL)
[17:40:56.287]                 if (is_error) {
[17:40:56.287]                   sessionInformation <- function() {
[17:40:56.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.287]                       search = base::search(), system = base::Sys.info())
[17:40:56.287]                   }
[17:40:56.287]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.287]                     cond$call), session = sessionInformation(), 
[17:40:56.287]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.287]                   signalCondition(cond)
[17:40:56.287]                 }
[17:40:56.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.287]                 "immediateCondition"))) {
[17:40:56.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.287]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.287]                   if (TRUE && !signal) {
[17:40:56.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.287]                     {
[17:40:56.287]                       inherits <- base::inherits
[17:40:56.287]                       invokeRestart <- base::invokeRestart
[17:40:56.287]                       is.null <- base::is.null
[17:40:56.287]                       muffled <- FALSE
[17:40:56.287]                       if (inherits(cond, "message")) {
[17:40:56.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.287]                         if (muffled) 
[17:40:56.287]                           invokeRestart("muffleMessage")
[17:40:56.287]                       }
[17:40:56.287]                       else if (inherits(cond, "warning")) {
[17:40:56.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.287]                         if (muffled) 
[17:40:56.287]                           invokeRestart("muffleWarning")
[17:40:56.287]                       }
[17:40:56.287]                       else if (inherits(cond, "condition")) {
[17:40:56.287]                         if (!is.null(pattern)) {
[17:40:56.287]                           computeRestarts <- base::computeRestarts
[17:40:56.287]                           grepl <- base::grepl
[17:40:56.287]                           restarts <- computeRestarts(cond)
[17:40:56.287]                           for (restart in restarts) {
[17:40:56.287]                             name <- restart$name
[17:40:56.287]                             if (is.null(name)) 
[17:40:56.287]                               next
[17:40:56.287]                             if (!grepl(pattern, name)) 
[17:40:56.287]                               next
[17:40:56.287]                             invokeRestart(restart)
[17:40:56.287]                             muffled <- TRUE
[17:40:56.287]                             break
[17:40:56.287]                           }
[17:40:56.287]                         }
[17:40:56.287]                       }
[17:40:56.287]                       invisible(muffled)
[17:40:56.287]                     }
[17:40:56.287]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.287]                   }
[17:40:56.287]                 }
[17:40:56.287]                 else {
[17:40:56.287]                   if (TRUE) {
[17:40:56.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.287]                     {
[17:40:56.287]                       inherits <- base::inherits
[17:40:56.287]                       invokeRestart <- base::invokeRestart
[17:40:56.287]                       is.null <- base::is.null
[17:40:56.287]                       muffled <- FALSE
[17:40:56.287]                       if (inherits(cond, "message")) {
[17:40:56.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.287]                         if (muffled) 
[17:40:56.287]                           invokeRestart("muffleMessage")
[17:40:56.287]                       }
[17:40:56.287]                       else if (inherits(cond, "warning")) {
[17:40:56.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.287]                         if (muffled) 
[17:40:56.287]                           invokeRestart("muffleWarning")
[17:40:56.287]                       }
[17:40:56.287]                       else if (inherits(cond, "condition")) {
[17:40:56.287]                         if (!is.null(pattern)) {
[17:40:56.287]                           computeRestarts <- base::computeRestarts
[17:40:56.287]                           grepl <- base::grepl
[17:40:56.287]                           restarts <- computeRestarts(cond)
[17:40:56.287]                           for (restart in restarts) {
[17:40:56.287]                             name <- restart$name
[17:40:56.287]                             if (is.null(name)) 
[17:40:56.287]                               next
[17:40:56.287]                             if (!grepl(pattern, name)) 
[17:40:56.287]                               next
[17:40:56.287]                             invokeRestart(restart)
[17:40:56.287]                             muffled <- TRUE
[17:40:56.287]                             break
[17:40:56.287]                           }
[17:40:56.287]                         }
[17:40:56.287]                       }
[17:40:56.287]                       invisible(muffled)
[17:40:56.287]                     }
[17:40:56.287]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.287]                   }
[17:40:56.287]                 }
[17:40:56.287]             }
[17:40:56.287]         }))
[17:40:56.287]     }, error = function(ex) {
[17:40:56.287]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.287]                 ...future.rng), started = ...future.startTime, 
[17:40:56.287]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.287]             version = "1.8"), class = "FutureResult")
[17:40:56.287]     }, finally = {
[17:40:56.287]         if (!identical(...future.workdir, getwd())) 
[17:40:56.287]             setwd(...future.workdir)
[17:40:56.287]         {
[17:40:56.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.287]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.287]             }
[17:40:56.287]             base::options(...future.oldOptions)
[17:40:56.287]             if (.Platform$OS.type == "windows") {
[17:40:56.287]                 old_names <- names(...future.oldEnvVars)
[17:40:56.287]                 envs <- base::Sys.getenv()
[17:40:56.287]                 names <- names(envs)
[17:40:56.287]                 common <- intersect(names, old_names)
[17:40:56.287]                 added <- setdiff(names, old_names)
[17:40:56.287]                 removed <- setdiff(old_names, names)
[17:40:56.287]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.287]                   envs[common]]
[17:40:56.287]                 NAMES <- toupper(changed)
[17:40:56.287]                 args <- list()
[17:40:56.287]                 for (kk in seq_along(NAMES)) {
[17:40:56.287]                   name <- changed[[kk]]
[17:40:56.287]                   NAME <- NAMES[[kk]]
[17:40:56.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.287]                     next
[17:40:56.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.287]                 }
[17:40:56.287]                 NAMES <- toupper(added)
[17:40:56.287]                 for (kk in seq_along(NAMES)) {
[17:40:56.287]                   name <- added[[kk]]
[17:40:56.287]                   NAME <- NAMES[[kk]]
[17:40:56.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.287]                     next
[17:40:56.287]                   args[[name]] <- ""
[17:40:56.287]                 }
[17:40:56.287]                 NAMES <- toupper(removed)
[17:40:56.287]                 for (kk in seq_along(NAMES)) {
[17:40:56.287]                   name <- removed[[kk]]
[17:40:56.287]                   NAME <- NAMES[[kk]]
[17:40:56.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.287]                     next
[17:40:56.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.287]                 }
[17:40:56.287]                 if (length(args) > 0) 
[17:40:56.287]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.287]             }
[17:40:56.287]             else {
[17:40:56.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.287]             }
[17:40:56.287]             {
[17:40:56.287]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.287]                   0L) {
[17:40:56.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.287]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.287]                   base::options(opts)
[17:40:56.287]                 }
[17:40:56.287]                 {
[17:40:56.287]                   {
[17:40:56.287]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.287]                     NULL
[17:40:56.287]                   }
[17:40:56.287]                   options(future.plan = NULL)
[17:40:56.287]                   if (is.na(NA_character_)) 
[17:40:56.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.287]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.287]                     envir = parent.frame()) 
[17:40:56.287]                   {
[17:40:56.287]                     default_workers <- missing(workers)
[17:40:56.287]                     if (is.function(workers)) 
[17:40:56.287]                       workers <- workers()
[17:40:56.287]                     workers <- structure(as.integer(workers), 
[17:40:56.287]                       class = class(workers))
[17:40:56.287]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.287]                       1L)
[17:40:56.287]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.287]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.287]                       if (default_workers) 
[17:40:56.287]                         supportsMulticore(warn = TRUE)
[17:40:56.287]                       return(sequential(..., envir = envir))
[17:40:56.287]                     }
[17:40:56.287]                     oopts <- options(mc.cores = workers)
[17:40:56.287]                     on.exit(options(oopts))
[17:40:56.287]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.287]                       envir = envir)
[17:40:56.287]                     if (!future$lazy) 
[17:40:56.287]                       future <- run(future)
[17:40:56.287]                     invisible(future)
[17:40:56.287]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.287]                 }
[17:40:56.287]             }
[17:40:56.287]         }
[17:40:56.287]     })
[17:40:56.287]     if (TRUE) {
[17:40:56.287]         base::sink(type = "output", split = FALSE)
[17:40:56.287]         if (TRUE) {
[17:40:56.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.287]         }
[17:40:56.287]         else {
[17:40:56.287]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.287]         }
[17:40:56.287]         base::close(...future.stdout)
[17:40:56.287]         ...future.stdout <- NULL
[17:40:56.287]     }
[17:40:56.287]     ...future.result$conditions <- ...future.conditions
[17:40:56.287]     ...future.result$finished <- base::Sys.time()
[17:40:56.287]     ...future.result
[17:40:56.287] }
[17:40:56.290] assign_globals() ...
[17:40:56.290] List of 11
[17:40:56.290]  $ ...future.FUN            :function (x, ...)  
[17:40:56.290]  $ x_FUN                    :function (x)  
[17:40:56.290]  $ times                    : int 1
[17:40:56.290]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.290]  $ stop_if_not              :function (...)  
[17:40:56.290]  $ dim                      : NULL
[17:40:56.290]  $ valid_types              : chr "logical"
[17:40:56.290]  $ future.call.arguments    : list()
[17:40:56.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.290]  $ ...future.elements_ii    :List of 6
[17:40:56.290]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:40:56.290]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:40:56.290]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:40:56.290]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:40:56.290]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:40:56.290]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:40:56.290]  $ ...future.seeds_ii       : NULL
[17:40:56.290]  $ ...future.globals.maxSize: NULL
[17:40:56.290]  - attr(*, "resolved")= logi FALSE
[17:40:56.290]  - attr(*, "total_size")= num 94200
[17:40:56.290]  - attr(*, "where")=List of 11
[17:40:56.290]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.290]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.290]  - attr(*, "already-done")= logi TRUE
[17:40:56.299] - copied ‘...future.FUN’ to environment
[17:40:56.299] - copied ‘x_FUN’ to environment
[17:40:56.300] - copied ‘times’ to environment
[17:40:56.300] - copied ‘stopf’ to environment
[17:40:56.300] - copied ‘stop_if_not’ to environment
[17:40:56.300] - copied ‘dim’ to environment
[17:40:56.300] - copied ‘valid_types’ to environment
[17:40:56.300] - copied ‘future.call.arguments’ to environment
[17:40:56.300] - copied ‘...future.elements_ii’ to environment
[17:40:56.302] - copied ‘...future.seeds_ii’ to environment
[17:40:56.303] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.303] assign_globals() ... done
[17:40:56.303] requestCore(): workers = 2
[17:40:56.305] MulticoreFuture started
[17:40:56.306] - Launch lazy future ... done
[17:40:56.307] run() for ‘MulticoreFuture’ ... done
[17:40:56.307] Created future:
[17:40:56.307] plan(): Setting new future strategy stack:
[17:40:56.308] List of future strategies:
[17:40:56.308] 1. sequential:
[17:40:56.308]    - args: function (..., envir = parent.frame())
[17:40:56.308]    - tweaked: FALSE
[17:40:56.308]    - call: NULL
[17:40:56.309] plan(): nbrOfWorkers() = 1
[17:40:56.312] plan(): Setting new future strategy stack:
[17:40:56.312] List of future strategies:
[17:40:56.312] 1. multicore:
[17:40:56.312]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.312]    - tweaked: FALSE
[17:40:56.312]    - call: plan(strategy)
[17:40:56.319] plan(): nbrOfWorkers() = 2
[17:40:56.307] MulticoreFuture:
[17:40:56.307] Label: ‘future_vapply-1’
[17:40:56.307] Expression:
[17:40:56.307] {
[17:40:56.307]     do.call(function(...) {
[17:40:56.307]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.307]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.307]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.307]             on.exit(options(oopts), add = TRUE)
[17:40:56.307]         }
[17:40:56.307]         {
[17:40:56.307]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.307]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.307]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.307]             })
[17:40:56.307]         }
[17:40:56.307]     }, args = future.call.arguments)
[17:40:56.307] }
[17:40:56.307] Lazy evaluation: FALSE
[17:40:56.307] Asynchronous evaluation: TRUE
[17:40:56.307] Local evaluation: TRUE
[17:40:56.307] Environment: R_GlobalEnv
[17:40:56.307] Capture standard output: TRUE
[17:40:56.307] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.307] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.307] Packages: 1 packages (‘future.apply’)
[17:40:56.307] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.307] Resolved: TRUE
[17:40:56.307] Value: <not collected>
[17:40:56.307] Conditions captured: <none>
[17:40:56.307] Early signaling: FALSE
[17:40:56.307] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.307] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.320] Chunk #1 of 2 ... DONE
[17:40:56.321] Chunk #2 of 2 ...
[17:40:56.321]  - Finding globals in 'X' for chunk #2 ...
[17:40:56.321] getGlobalsAndPackages() ...
[17:40:56.321] Searching for globals...
[17:40:56.322] 
[17:40:56.322] Searching for globals ... DONE
[17:40:56.322] - globals: [0] <none>
[17:40:56.322] getGlobalsAndPackages() ... DONE
[17:40:56.323]    + additional globals found: [n=0] 
[17:40:56.323]    + additional namespaces needed: [n=0] 
[17:40:56.323]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:56.323]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:56.323]  - seeds: <none>
[17:40:56.324] getGlobalsAndPackages() ...
[17:40:56.324] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.324] Resolving globals: FALSE
[17:40:56.325] Tweak future expression to call with '...' arguments ...
[17:40:56.325] {
[17:40:56.325]     do.call(function(...) {
[17:40:56.325]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.325]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.325]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.325]             on.exit(options(oopts), add = TRUE)
[17:40:56.325]         }
[17:40:56.325]         {
[17:40:56.325]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.325]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.325]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.325]             })
[17:40:56.325]         }
[17:40:56.325]     }, args = future.call.arguments)
[17:40:56.325] }
[17:40:56.325] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.327] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.327] - packages: [1] ‘future.apply’
[17:40:56.327] getGlobalsAndPackages() ... DONE
[17:40:56.328] run() for ‘Future’ ...
[17:40:56.328] - state: ‘created’
[17:40:56.328] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.333] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.333]   - Field: ‘label’
[17:40:56.334]   - Field: ‘local’
[17:40:56.334]   - Field: ‘owner’
[17:40:56.334]   - Field: ‘envir’
[17:40:56.334]   - Field: ‘workers’
[17:40:56.335]   - Field: ‘packages’
[17:40:56.335]   - Field: ‘gc’
[17:40:56.335]   - Field: ‘job’
[17:40:56.335]   - Field: ‘conditions’
[17:40:56.335]   - Field: ‘expr’
[17:40:56.335]   - Field: ‘uuid’
[17:40:56.335]   - Field: ‘seed’
[17:40:56.336]   - Field: ‘version’
[17:40:56.336]   - Field: ‘result’
[17:40:56.336]   - Field: ‘asynchronous’
[17:40:56.336]   - Field: ‘calls’
[17:40:56.336]   - Field: ‘globals’
[17:40:56.336]   - Field: ‘stdout’
[17:40:56.336]   - Field: ‘earlySignal’
[17:40:56.337]   - Field: ‘lazy’
[17:40:56.337]   - Field: ‘state’
[17:40:56.337] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.337] - Launch lazy future ...
[17:40:56.337] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.337] Packages needed by future strategies (n = 0): <none>
[17:40:56.338] {
[17:40:56.338]     {
[17:40:56.338]         {
[17:40:56.338]             ...future.startTime <- base::Sys.time()
[17:40:56.338]             {
[17:40:56.338]                 {
[17:40:56.338]                   {
[17:40:56.338]                     {
[17:40:56.338]                       {
[17:40:56.338]                         base::local({
[17:40:56.338]                           has_future <- base::requireNamespace("future", 
[17:40:56.338]                             quietly = TRUE)
[17:40:56.338]                           if (has_future) {
[17:40:56.338]                             ns <- base::getNamespace("future")
[17:40:56.338]                             version <- ns[[".package"]][["version"]]
[17:40:56.338]                             if (is.null(version)) 
[17:40:56.338]                               version <- utils::packageVersion("future")
[17:40:56.338]                           }
[17:40:56.338]                           else {
[17:40:56.338]                             version <- NULL
[17:40:56.338]                           }
[17:40:56.338]                           if (!has_future || version < "1.8.0") {
[17:40:56.338]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.338]                               "", base::R.version$version.string), 
[17:40:56.338]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.338]                                 base::R.version$platform, 8 * 
[17:40:56.338]                                   base::.Machine$sizeof.pointer), 
[17:40:56.338]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.338]                                 "release", "version")], collapse = " "), 
[17:40:56.338]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.338]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.338]                               info)
[17:40:56.338]                             info <- base::paste(info, collapse = "; ")
[17:40:56.338]                             if (!has_future) {
[17:40:56.338]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.338]                                 info)
[17:40:56.338]                             }
[17:40:56.338]                             else {
[17:40:56.338]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.338]                                 info, version)
[17:40:56.338]                             }
[17:40:56.338]                             base::stop(msg)
[17:40:56.338]                           }
[17:40:56.338]                         })
[17:40:56.338]                       }
[17:40:56.338]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.338]                       base::options(mc.cores = 1L)
[17:40:56.338]                     }
[17:40:56.338]                     base::local({
[17:40:56.338]                       for (pkg in "future.apply") {
[17:40:56.338]                         base::loadNamespace(pkg)
[17:40:56.338]                         base::library(pkg, character.only = TRUE)
[17:40:56.338]                       }
[17:40:56.338]                     })
[17:40:56.338]                   }
[17:40:56.338]                   options(future.plan = NULL)
[17:40:56.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.338]                 }
[17:40:56.338]                 ...future.workdir <- getwd()
[17:40:56.338]             }
[17:40:56.338]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.338]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.338]         }
[17:40:56.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.338]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:56.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.338]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.338]             base::names(...future.oldOptions))
[17:40:56.338]     }
[17:40:56.338]     if (FALSE) {
[17:40:56.338]     }
[17:40:56.338]     else {
[17:40:56.338]         if (TRUE) {
[17:40:56.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.338]                 open = "w")
[17:40:56.338]         }
[17:40:56.338]         else {
[17:40:56.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.338]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.338]         }
[17:40:56.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.338]             base::sink(type = "output", split = FALSE)
[17:40:56.338]             base::close(...future.stdout)
[17:40:56.338]         }, add = TRUE)
[17:40:56.338]     }
[17:40:56.338]     ...future.frame <- base::sys.nframe()
[17:40:56.338]     ...future.conditions <- base::list()
[17:40:56.338]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.338]     if (FALSE) {
[17:40:56.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.338]     }
[17:40:56.338]     ...future.result <- base::tryCatch({
[17:40:56.338]         base::withCallingHandlers({
[17:40:56.338]             ...future.value <- base::withVisible(base::local({
[17:40:56.338]                 withCallingHandlers({
[17:40:56.338]                   {
[17:40:56.338]                     do.call(function(...) {
[17:40:56.338]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.338]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.338]                         ...future.globals.maxSize)) {
[17:40:56.338]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.338]                         on.exit(options(oopts), add = TRUE)
[17:40:56.338]                       }
[17:40:56.338]                       {
[17:40:56.338]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.338]                           FUN = function(jj) {
[17:40:56.338]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.338]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.338]                           })
[17:40:56.338]                       }
[17:40:56.338]                     }, args = future.call.arguments)
[17:40:56.338]                   }
[17:40:56.338]                 }, immediateCondition = function(cond) {
[17:40:56.338]                   save_rds <- function (object, pathname, ...) 
[17:40:56.338]                   {
[17:40:56.338]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.338]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.338]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.338]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.338]                         fi_tmp[["mtime"]])
[17:40:56.338]                     }
[17:40:56.338]                     tryCatch({
[17:40:56.338]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.338]                     }, error = function(ex) {
[17:40:56.338]                       msg <- conditionMessage(ex)
[17:40:56.338]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.338]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.338]                         fi_tmp[["mtime"]], msg)
[17:40:56.338]                       ex$message <- msg
[17:40:56.338]                       stop(ex)
[17:40:56.338]                     })
[17:40:56.338]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.338]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.338]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.338]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.338]                       fi <- file.info(pathname)
[17:40:56.338]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.338]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.338]                         fi[["size"]], fi[["mtime"]])
[17:40:56.338]                       stop(msg)
[17:40:56.338]                     }
[17:40:56.338]                     invisible(pathname)
[17:40:56.338]                   }
[17:40:56.338]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.338]                     rootPath = tempdir()) 
[17:40:56.338]                   {
[17:40:56.338]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.338]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.338]                       tmpdir = path, fileext = ".rds")
[17:40:56.338]                     save_rds(obj, file)
[17:40:56.338]                   }
[17:40:56.338]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.338]                   {
[17:40:56.338]                     inherits <- base::inherits
[17:40:56.338]                     invokeRestart <- base::invokeRestart
[17:40:56.338]                     is.null <- base::is.null
[17:40:56.338]                     muffled <- FALSE
[17:40:56.338]                     if (inherits(cond, "message")) {
[17:40:56.338]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.338]                       if (muffled) 
[17:40:56.338]                         invokeRestart("muffleMessage")
[17:40:56.338]                     }
[17:40:56.338]                     else if (inherits(cond, "warning")) {
[17:40:56.338]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.338]                       if (muffled) 
[17:40:56.338]                         invokeRestart("muffleWarning")
[17:40:56.338]                     }
[17:40:56.338]                     else if (inherits(cond, "condition")) {
[17:40:56.338]                       if (!is.null(pattern)) {
[17:40:56.338]                         computeRestarts <- base::computeRestarts
[17:40:56.338]                         grepl <- base::grepl
[17:40:56.338]                         restarts <- computeRestarts(cond)
[17:40:56.338]                         for (restart in restarts) {
[17:40:56.338]                           name <- restart$name
[17:40:56.338]                           if (is.null(name)) 
[17:40:56.338]                             next
[17:40:56.338]                           if (!grepl(pattern, name)) 
[17:40:56.338]                             next
[17:40:56.338]                           invokeRestart(restart)
[17:40:56.338]                           muffled <- TRUE
[17:40:56.338]                           break
[17:40:56.338]                         }
[17:40:56.338]                       }
[17:40:56.338]                     }
[17:40:56.338]                     invisible(muffled)
[17:40:56.338]                   }
[17:40:56.338]                   muffleCondition(cond)
[17:40:56.338]                 })
[17:40:56.338]             }))
[17:40:56.338]             future::FutureResult(value = ...future.value$value, 
[17:40:56.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.338]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.338]                     ...future.globalenv.names))
[17:40:56.338]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.338]         }, condition = base::local({
[17:40:56.338]             c <- base::c
[17:40:56.338]             inherits <- base::inherits
[17:40:56.338]             invokeRestart <- base::invokeRestart
[17:40:56.338]             length <- base::length
[17:40:56.338]             list <- base::list
[17:40:56.338]             seq.int <- base::seq.int
[17:40:56.338]             signalCondition <- base::signalCondition
[17:40:56.338]             sys.calls <- base::sys.calls
[17:40:56.338]             `[[` <- base::`[[`
[17:40:56.338]             `+` <- base::`+`
[17:40:56.338]             `<<-` <- base::`<<-`
[17:40:56.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.338]                   3L)]
[17:40:56.338]             }
[17:40:56.338]             function(cond) {
[17:40:56.338]                 is_error <- inherits(cond, "error")
[17:40:56.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.338]                   NULL)
[17:40:56.338]                 if (is_error) {
[17:40:56.338]                   sessionInformation <- function() {
[17:40:56.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.338]                       search = base::search(), system = base::Sys.info())
[17:40:56.338]                   }
[17:40:56.338]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.338]                     cond$call), session = sessionInformation(), 
[17:40:56.338]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.338]                   signalCondition(cond)
[17:40:56.338]                 }
[17:40:56.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.338]                 "immediateCondition"))) {
[17:40:56.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.338]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.338]                   if (TRUE && !signal) {
[17:40:56.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.338]                     {
[17:40:56.338]                       inherits <- base::inherits
[17:40:56.338]                       invokeRestart <- base::invokeRestart
[17:40:56.338]                       is.null <- base::is.null
[17:40:56.338]                       muffled <- FALSE
[17:40:56.338]                       if (inherits(cond, "message")) {
[17:40:56.338]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.338]                         if (muffled) 
[17:40:56.338]                           invokeRestart("muffleMessage")
[17:40:56.338]                       }
[17:40:56.338]                       else if (inherits(cond, "warning")) {
[17:40:56.338]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.338]                         if (muffled) 
[17:40:56.338]                           invokeRestart("muffleWarning")
[17:40:56.338]                       }
[17:40:56.338]                       else if (inherits(cond, "condition")) {
[17:40:56.338]                         if (!is.null(pattern)) {
[17:40:56.338]                           computeRestarts <- base::computeRestarts
[17:40:56.338]                           grepl <- base::grepl
[17:40:56.338]                           restarts <- computeRestarts(cond)
[17:40:56.338]                           for (restart in restarts) {
[17:40:56.338]                             name <- restart$name
[17:40:56.338]                             if (is.null(name)) 
[17:40:56.338]                               next
[17:40:56.338]                             if (!grepl(pattern, name)) 
[17:40:56.338]                               next
[17:40:56.338]                             invokeRestart(restart)
[17:40:56.338]                             muffled <- TRUE
[17:40:56.338]                             break
[17:40:56.338]                           }
[17:40:56.338]                         }
[17:40:56.338]                       }
[17:40:56.338]                       invisible(muffled)
[17:40:56.338]                     }
[17:40:56.338]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.338]                   }
[17:40:56.338]                 }
[17:40:56.338]                 else {
[17:40:56.338]                   if (TRUE) {
[17:40:56.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.338]                     {
[17:40:56.338]                       inherits <- base::inherits
[17:40:56.338]                       invokeRestart <- base::invokeRestart
[17:40:56.338]                       is.null <- base::is.null
[17:40:56.338]                       muffled <- FALSE
[17:40:56.338]                       if (inherits(cond, "message")) {
[17:40:56.338]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.338]                         if (muffled) 
[17:40:56.338]                           invokeRestart("muffleMessage")
[17:40:56.338]                       }
[17:40:56.338]                       else if (inherits(cond, "warning")) {
[17:40:56.338]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.338]                         if (muffled) 
[17:40:56.338]                           invokeRestart("muffleWarning")
[17:40:56.338]                       }
[17:40:56.338]                       else if (inherits(cond, "condition")) {
[17:40:56.338]                         if (!is.null(pattern)) {
[17:40:56.338]                           computeRestarts <- base::computeRestarts
[17:40:56.338]                           grepl <- base::grepl
[17:40:56.338]                           restarts <- computeRestarts(cond)
[17:40:56.338]                           for (restart in restarts) {
[17:40:56.338]                             name <- restart$name
[17:40:56.338]                             if (is.null(name)) 
[17:40:56.338]                               next
[17:40:56.338]                             if (!grepl(pattern, name)) 
[17:40:56.338]                               next
[17:40:56.338]                             invokeRestart(restart)
[17:40:56.338]                             muffled <- TRUE
[17:40:56.338]                             break
[17:40:56.338]                           }
[17:40:56.338]                         }
[17:40:56.338]                       }
[17:40:56.338]                       invisible(muffled)
[17:40:56.338]                     }
[17:40:56.338]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.338]                   }
[17:40:56.338]                 }
[17:40:56.338]             }
[17:40:56.338]         }))
[17:40:56.338]     }, error = function(ex) {
[17:40:56.338]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.338]                 ...future.rng), started = ...future.startTime, 
[17:40:56.338]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.338]             version = "1.8"), class = "FutureResult")
[17:40:56.338]     }, finally = {
[17:40:56.338]         if (!identical(...future.workdir, getwd())) 
[17:40:56.338]             setwd(...future.workdir)
[17:40:56.338]         {
[17:40:56.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.338]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.338]             }
[17:40:56.338]             base::options(...future.oldOptions)
[17:40:56.338]             if (.Platform$OS.type == "windows") {
[17:40:56.338]                 old_names <- names(...future.oldEnvVars)
[17:40:56.338]                 envs <- base::Sys.getenv()
[17:40:56.338]                 names <- names(envs)
[17:40:56.338]                 common <- intersect(names, old_names)
[17:40:56.338]                 added <- setdiff(names, old_names)
[17:40:56.338]                 removed <- setdiff(old_names, names)
[17:40:56.338]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.338]                   envs[common]]
[17:40:56.338]                 NAMES <- toupper(changed)
[17:40:56.338]                 args <- list()
[17:40:56.338]                 for (kk in seq_along(NAMES)) {
[17:40:56.338]                   name <- changed[[kk]]
[17:40:56.338]                   NAME <- NAMES[[kk]]
[17:40:56.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.338]                     next
[17:40:56.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.338]                 }
[17:40:56.338]                 NAMES <- toupper(added)
[17:40:56.338]                 for (kk in seq_along(NAMES)) {
[17:40:56.338]                   name <- added[[kk]]
[17:40:56.338]                   NAME <- NAMES[[kk]]
[17:40:56.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.338]                     next
[17:40:56.338]                   args[[name]] <- ""
[17:40:56.338]                 }
[17:40:56.338]                 NAMES <- toupper(removed)
[17:40:56.338]                 for (kk in seq_along(NAMES)) {
[17:40:56.338]                   name <- removed[[kk]]
[17:40:56.338]                   NAME <- NAMES[[kk]]
[17:40:56.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.338]                     next
[17:40:56.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.338]                 }
[17:40:56.338]                 if (length(args) > 0) 
[17:40:56.338]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.338]             }
[17:40:56.338]             else {
[17:40:56.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.338]             }
[17:40:56.338]             {
[17:40:56.338]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.338]                   0L) {
[17:40:56.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.338]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.338]                   base::options(opts)
[17:40:56.338]                 }
[17:40:56.338]                 {
[17:40:56.338]                   {
[17:40:56.338]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.338]                     NULL
[17:40:56.338]                   }
[17:40:56.338]                   options(future.plan = NULL)
[17:40:56.338]                   if (is.na(NA_character_)) 
[17:40:56.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.338]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.338]                     envir = parent.frame()) 
[17:40:56.338]                   {
[17:40:56.338]                     default_workers <- missing(workers)
[17:40:56.338]                     if (is.function(workers)) 
[17:40:56.338]                       workers <- workers()
[17:40:56.338]                     workers <- structure(as.integer(workers), 
[17:40:56.338]                       class = class(workers))
[17:40:56.338]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.338]                       1L)
[17:40:56.338]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.338]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.338]                       if (default_workers) 
[17:40:56.338]                         supportsMulticore(warn = TRUE)
[17:40:56.338]                       return(sequential(..., envir = envir))
[17:40:56.338]                     }
[17:40:56.338]                     oopts <- options(mc.cores = workers)
[17:40:56.338]                     on.exit(options(oopts))
[17:40:56.338]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.338]                       envir = envir)
[17:40:56.338]                     if (!future$lazy) 
[17:40:56.338]                       future <- run(future)
[17:40:56.338]                     invisible(future)
[17:40:56.338]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.338]                 }
[17:40:56.338]             }
[17:40:56.338]         }
[17:40:56.338]     })
[17:40:56.338]     if (TRUE) {
[17:40:56.338]         base::sink(type = "output", split = FALSE)
[17:40:56.338]         if (TRUE) {
[17:40:56.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.338]         }
[17:40:56.338]         else {
[17:40:56.338]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.338]         }
[17:40:56.338]         base::close(...future.stdout)
[17:40:56.338]         ...future.stdout <- NULL
[17:40:56.338]     }
[17:40:56.338]     ...future.result$conditions <- ...future.conditions
[17:40:56.338]     ...future.result$finished <- base::Sys.time()
[17:40:56.338]     ...future.result
[17:40:56.338] }
[17:40:56.342] assign_globals() ...
[17:40:56.342] List of 11
[17:40:56.342]  $ ...future.FUN            :function (x, ...)  
[17:40:56.342]  $ x_FUN                    :function (x)  
[17:40:56.342]  $ times                    : int 1
[17:40:56.342]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.342]  $ stop_if_not              :function (...)  
[17:40:56.342]  $ dim                      : NULL
[17:40:56.342]  $ valid_types              : chr "logical"
[17:40:56.342]  $ future.call.arguments    : list()
[17:40:56.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.342]  $ ...future.elements_ii    :List of 5
[17:40:56.342]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:40:56.342]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:40:56.342]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:40:56.342]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:40:56.342]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:40:56.342]  $ ...future.seeds_ii       : NULL
[17:40:56.342]  $ ...future.globals.maxSize: NULL
[17:40:56.342]  - attr(*, "resolved")= logi FALSE
[17:40:56.342]  - attr(*, "total_size")= num 94200
[17:40:56.342]  - attr(*, "where")=List of 11
[17:40:56.342]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.342]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.342]  - attr(*, "already-done")= logi TRUE
[17:40:56.356] - copied ‘...future.FUN’ to environment
[17:40:56.356] - copied ‘x_FUN’ to environment
[17:40:56.356] - copied ‘times’ to environment
[17:40:56.356] - copied ‘stopf’ to environment
[17:40:56.356] - copied ‘stop_if_not’ to environment
[17:40:56.356] - copied ‘dim’ to environment
[17:40:56.357] - copied ‘valid_types’ to environment
[17:40:56.357] - copied ‘future.call.arguments’ to environment
[17:40:56.357] - copied ‘...future.elements_ii’ to environment
[17:40:56.357] - copied ‘...future.seeds_ii’ to environment
[17:40:56.357] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.357] assign_globals() ... done
[17:40:56.357] requestCore(): workers = 2
[17:40:56.360] MulticoreFuture started
[17:40:56.360] - Launch lazy future ... done
[17:40:56.361] run() for ‘MulticoreFuture’ ... done
[17:40:56.361] Created future:
[17:40:56.361] plan(): Setting new future strategy stack:
[17:40:56.362] List of future strategies:
[17:40:56.362] 1. sequential:
[17:40:56.362]    - args: function (..., envir = parent.frame())
[17:40:56.362]    - tweaked: FALSE
[17:40:56.362]    - call: NULL
[17:40:56.363] plan(): nbrOfWorkers() = 1
[17:40:56.366] plan(): Setting new future strategy stack:
[17:40:56.366] List of future strategies:
[17:40:56.366] 1. multicore:
[17:40:56.366]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.366]    - tweaked: FALSE
[17:40:56.366]    - call: plan(strategy)
[17:40:56.372] plan(): nbrOfWorkers() = 2
[17:40:56.362] MulticoreFuture:
[17:40:56.362] Label: ‘future_vapply-2’
[17:40:56.362] Expression:
[17:40:56.362] {
[17:40:56.362]     do.call(function(...) {
[17:40:56.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.362]             on.exit(options(oopts), add = TRUE)
[17:40:56.362]         }
[17:40:56.362]         {
[17:40:56.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.362]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.362]             })
[17:40:56.362]         }
[17:40:56.362]     }, args = future.call.arguments)
[17:40:56.362] }
[17:40:56.362] Lazy evaluation: FALSE
[17:40:56.362] Asynchronous evaluation: TRUE
[17:40:56.362] Local evaluation: TRUE
[17:40:56.362] Environment: R_GlobalEnv
[17:40:56.362] Capture standard output: TRUE
[17:40:56.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.362] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.362] Packages: 1 packages (‘future.apply’)
[17:40:56.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.362] Resolved: TRUE
[17:40:56.362] Value: <not collected>
[17:40:56.362] Conditions captured: <none>
[17:40:56.362] Early signaling: FALSE
[17:40:56.362] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.362] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.374] Chunk #2 of 2 ... DONE
[17:40:56.374] Launching 2 futures (chunks) ... DONE
[17:40:56.374] Resolving 2 futures (chunks) ...
[17:40:56.374] resolve() on list ...
[17:40:56.374]  recursive: 0
[17:40:56.375]  length: 2
[17:40:56.375] 
[17:40:56.375] Future #1
[17:40:56.376] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:56.376] - nx: 2
[17:40:56.376] - relay: TRUE
[17:40:56.376] - stdout: TRUE
[17:40:56.377] - signal: TRUE
[17:40:56.377] - resignal: FALSE
[17:40:56.377] - force: TRUE
[17:40:56.377] - relayed: [n=2] FALSE, FALSE
[17:40:56.377] - queued futures: [n=2] FALSE, FALSE
[17:40:56.377]  - until=1
[17:40:56.378]  - relaying element #1
[17:40:56.378] - relayed: [n=2] TRUE, FALSE
[17:40:56.378] - queued futures: [n=2] TRUE, FALSE
[17:40:56.379] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:56.379]  length: 1 (resolved future 1)
[17:40:56.379] Future #2
[17:40:56.380] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:56.380] - nx: 2
[17:40:56.380] - relay: TRUE
[17:40:56.381] - stdout: TRUE
[17:40:56.381] - signal: TRUE
[17:40:56.381] - resignal: FALSE
[17:40:56.381] - force: TRUE
[17:40:56.381] - relayed: [n=2] TRUE, FALSE
[17:40:56.381] - queued futures: [n=2] TRUE, FALSE
[17:40:56.381]  - until=2
[17:40:56.381]  - relaying element #2
[17:40:56.382] - relayed: [n=2] TRUE, TRUE
[17:40:56.382] - queued futures: [n=2] TRUE, TRUE
[17:40:56.382] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:56.382]  length: 0 (resolved future 2)
[17:40:56.382] Relaying remaining futures
[17:40:56.382] signalConditionsASAP(NULL, pos=0) ...
[17:40:56.382] - nx: 2
[17:40:56.383] - relay: TRUE
[17:40:56.383] - stdout: TRUE
[17:40:56.383] - signal: TRUE
[17:40:56.383] - resignal: FALSE
[17:40:56.383] - force: TRUE
[17:40:56.383] - relayed: [n=2] TRUE, TRUE
[17:40:56.383] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:56.383] - relayed: [n=2] TRUE, TRUE
[17:40:56.384] - queued futures: [n=2] TRUE, TRUE
[17:40:56.384] signalConditionsASAP(NULL, pos=0) ... done
[17:40:56.384] resolve() on list ... DONE
[17:40:56.384]  - Number of value chunks collected: 2
[17:40:56.384] Resolving 2 futures (chunks) ... DONE
[17:40:56.384] Reducing values from 2 chunks ...
[17:40:56.384]  - Number of values collected after concatenation: 11
[17:40:56.384]  - Number of values expected: 11
[17:40:56.384] Reducing values from 2 chunks ... DONE
[17:40:56.385] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:40:56.386] future_lapply() ...
[17:40:56.392] Number of chunks: 2
[17:40:56.392] getGlobalsAndPackagesXApply() ...
[17:40:56.392]  - future.globals: TRUE
[17:40:56.392] getGlobalsAndPackages() ...
[17:40:56.393] Searching for globals...
[17:40:56.399] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:56.399] Searching for globals ... DONE
[17:40:56.400] Resolving globals: FALSE
[17:40:56.401] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:40:56.401] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:56.401] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.401] - packages: [1] ‘future.apply’
[17:40:56.402] getGlobalsAndPackages() ... DONE
[17:40:56.402]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.402]  - needed namespaces: [n=1] ‘future.apply’
[17:40:56.402] Finding globals ... DONE
[17:40:56.402]  - use_args: TRUE
[17:40:56.402]  - Getting '...' globals ...
[17:40:56.403] resolve() on list ...
[17:40:56.403]  recursive: 0
[17:40:56.403]  length: 1
[17:40:56.403]  elements: ‘...’
[17:40:56.403]  length: 0 (resolved future 1)
[17:40:56.403] resolve() on list ... DONE
[17:40:56.403]    - '...' content: [n=0] 
[17:40:56.403] List of 1
[17:40:56.403]  $ ...: list()
[17:40:56.403]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.403]  - attr(*, "where")=List of 1
[17:40:56.403]   ..$ ...:<environment: 0x564f2fbed1e0> 
[17:40:56.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.403]  - attr(*, "resolved")= logi TRUE
[17:40:56.403]  - attr(*, "total_size")= num NA
[17:40:56.406]  - Getting '...' globals ... DONE
[17:40:56.406] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:56.406] List of 8
[17:40:56.406]  $ ...future.FUN:function (x, ...)  
[17:40:56.406]  $ x_FUN        :function (x)  
[17:40:56.406]  $ times        : int 1
[17:40:56.406]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.406]  $ stop_if_not  :function (...)  
[17:40:56.406]  $ dim          : NULL
[17:40:56.406]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:56.406]  $ ...          : list()
[17:40:56.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.406]  - attr(*, "where")=List of 8
[17:40:56.406]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:56.406]   ..$ ...          :<environment: 0x564f2fbed1e0> 
[17:40:56.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.406]  - attr(*, "resolved")= logi FALSE
[17:40:56.406]  - attr(*, "total_size")= num 94264
[17:40:56.412] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:56.412] getGlobalsAndPackagesXApply() ... DONE
[17:40:56.412] Number of futures (= number of chunks): 2
[17:40:56.412] Launching 2 futures (chunks) ...
[17:40:56.412] Chunk #1 of 2 ...
[17:40:56.412]  - Finding globals in 'X' for chunk #1 ...
[17:40:56.412] getGlobalsAndPackages() ...
[17:40:56.413] Searching for globals...
[17:40:56.413] 
[17:40:56.413] Searching for globals ... DONE
[17:40:56.413] - globals: [0] <none>
[17:40:56.413] getGlobalsAndPackages() ... DONE
[17:40:56.413]    + additional globals found: [n=0] 
[17:40:56.413]    + additional namespaces needed: [n=0] 
[17:40:56.415]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:56.415]  - seeds: <none>
[17:40:56.415] getGlobalsAndPackages() ...
[17:40:56.416] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.416] Resolving globals: FALSE
[17:40:56.416] Tweak future expression to call with '...' arguments ...
[17:40:56.416] {
[17:40:56.416]     do.call(function(...) {
[17:40:56.416]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.416]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.416]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.416]             on.exit(options(oopts), add = TRUE)
[17:40:56.416]         }
[17:40:56.416]         {
[17:40:56.416]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.416]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.416]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.416]             })
[17:40:56.416]         }
[17:40:56.416]     }, args = future.call.arguments)
[17:40:56.416] }
[17:40:56.416] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.417] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.417] - packages: [1] ‘future.apply’
[17:40:56.417] getGlobalsAndPackages() ... DONE
[17:40:56.417] run() for ‘Future’ ...
[17:40:56.417] - state: ‘created’
[17:40:56.418] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.422]   - Field: ‘label’
[17:40:56.422]   - Field: ‘local’
[17:40:56.422]   - Field: ‘owner’
[17:40:56.422]   - Field: ‘envir’
[17:40:56.422]   - Field: ‘workers’
[17:40:56.422]   - Field: ‘packages’
[17:40:56.422]   - Field: ‘gc’
[17:40:56.422]   - Field: ‘job’
[17:40:56.423]   - Field: ‘conditions’
[17:40:56.423]   - Field: ‘expr’
[17:40:56.423]   - Field: ‘uuid’
[17:40:56.423]   - Field: ‘seed’
[17:40:56.423]   - Field: ‘version’
[17:40:56.423]   - Field: ‘result’
[17:40:56.423]   - Field: ‘asynchronous’
[17:40:56.423]   - Field: ‘calls’
[17:40:56.423]   - Field: ‘globals’
[17:40:56.424]   - Field: ‘stdout’
[17:40:56.424]   - Field: ‘earlySignal’
[17:40:56.424]   - Field: ‘lazy’
[17:40:56.424]   - Field: ‘state’
[17:40:56.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.424] - Launch lazy future ...
[17:40:56.424] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.424] Packages needed by future strategies (n = 0): <none>
[17:40:56.425] {
[17:40:56.425]     {
[17:40:56.425]         {
[17:40:56.425]             ...future.startTime <- base::Sys.time()
[17:40:56.425]             {
[17:40:56.425]                 {
[17:40:56.425]                   {
[17:40:56.425]                     {
[17:40:56.425]                       {
[17:40:56.425]                         base::local({
[17:40:56.425]                           has_future <- base::requireNamespace("future", 
[17:40:56.425]                             quietly = TRUE)
[17:40:56.425]                           if (has_future) {
[17:40:56.425]                             ns <- base::getNamespace("future")
[17:40:56.425]                             version <- ns[[".package"]][["version"]]
[17:40:56.425]                             if (is.null(version)) 
[17:40:56.425]                               version <- utils::packageVersion("future")
[17:40:56.425]                           }
[17:40:56.425]                           else {
[17:40:56.425]                             version <- NULL
[17:40:56.425]                           }
[17:40:56.425]                           if (!has_future || version < "1.8.0") {
[17:40:56.425]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.425]                               "", base::R.version$version.string), 
[17:40:56.425]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.425]                                 base::R.version$platform, 8 * 
[17:40:56.425]                                   base::.Machine$sizeof.pointer), 
[17:40:56.425]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.425]                                 "release", "version")], collapse = " "), 
[17:40:56.425]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.425]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.425]                               info)
[17:40:56.425]                             info <- base::paste(info, collapse = "; ")
[17:40:56.425]                             if (!has_future) {
[17:40:56.425]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.425]                                 info)
[17:40:56.425]                             }
[17:40:56.425]                             else {
[17:40:56.425]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.425]                                 info, version)
[17:40:56.425]                             }
[17:40:56.425]                             base::stop(msg)
[17:40:56.425]                           }
[17:40:56.425]                         })
[17:40:56.425]                       }
[17:40:56.425]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.425]                       base::options(mc.cores = 1L)
[17:40:56.425]                     }
[17:40:56.425]                     base::local({
[17:40:56.425]                       for (pkg in "future.apply") {
[17:40:56.425]                         base::loadNamespace(pkg)
[17:40:56.425]                         base::library(pkg, character.only = TRUE)
[17:40:56.425]                       }
[17:40:56.425]                     })
[17:40:56.425]                   }
[17:40:56.425]                   options(future.plan = NULL)
[17:40:56.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.425]                 }
[17:40:56.425]                 ...future.workdir <- getwd()
[17:40:56.425]             }
[17:40:56.425]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.425]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.425]         }
[17:40:56.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:56.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.425]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.425]             base::names(...future.oldOptions))
[17:40:56.425]     }
[17:40:56.425]     if (FALSE) {
[17:40:56.425]     }
[17:40:56.425]     else {
[17:40:56.425]         if (TRUE) {
[17:40:56.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.425]                 open = "w")
[17:40:56.425]         }
[17:40:56.425]         else {
[17:40:56.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.425]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.425]         }
[17:40:56.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.425]             base::sink(type = "output", split = FALSE)
[17:40:56.425]             base::close(...future.stdout)
[17:40:56.425]         }, add = TRUE)
[17:40:56.425]     }
[17:40:56.425]     ...future.frame <- base::sys.nframe()
[17:40:56.425]     ...future.conditions <- base::list()
[17:40:56.425]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.425]     if (FALSE) {
[17:40:56.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.425]     }
[17:40:56.425]     ...future.result <- base::tryCatch({
[17:40:56.425]         base::withCallingHandlers({
[17:40:56.425]             ...future.value <- base::withVisible(base::local({
[17:40:56.425]                 withCallingHandlers({
[17:40:56.425]                   {
[17:40:56.425]                     do.call(function(...) {
[17:40:56.425]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.425]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.425]                         ...future.globals.maxSize)) {
[17:40:56.425]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.425]                         on.exit(options(oopts), add = TRUE)
[17:40:56.425]                       }
[17:40:56.425]                       {
[17:40:56.425]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.425]                           FUN = function(jj) {
[17:40:56.425]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.425]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.425]                           })
[17:40:56.425]                       }
[17:40:56.425]                     }, args = future.call.arguments)
[17:40:56.425]                   }
[17:40:56.425]                 }, immediateCondition = function(cond) {
[17:40:56.425]                   save_rds <- function (object, pathname, ...) 
[17:40:56.425]                   {
[17:40:56.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.425]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.425]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.425]                         fi_tmp[["mtime"]])
[17:40:56.425]                     }
[17:40:56.425]                     tryCatch({
[17:40:56.425]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.425]                     }, error = function(ex) {
[17:40:56.425]                       msg <- conditionMessage(ex)
[17:40:56.425]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.425]                         fi_tmp[["mtime"]], msg)
[17:40:56.425]                       ex$message <- msg
[17:40:56.425]                       stop(ex)
[17:40:56.425]                     })
[17:40:56.425]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.425]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.425]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.425]                       fi <- file.info(pathname)
[17:40:56.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.425]                         fi[["size"]], fi[["mtime"]])
[17:40:56.425]                       stop(msg)
[17:40:56.425]                     }
[17:40:56.425]                     invisible(pathname)
[17:40:56.425]                   }
[17:40:56.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.425]                     rootPath = tempdir()) 
[17:40:56.425]                   {
[17:40:56.425]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.425]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.425]                       tmpdir = path, fileext = ".rds")
[17:40:56.425]                     save_rds(obj, file)
[17:40:56.425]                   }
[17:40:56.425]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.425]                   {
[17:40:56.425]                     inherits <- base::inherits
[17:40:56.425]                     invokeRestart <- base::invokeRestart
[17:40:56.425]                     is.null <- base::is.null
[17:40:56.425]                     muffled <- FALSE
[17:40:56.425]                     if (inherits(cond, "message")) {
[17:40:56.425]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.425]                       if (muffled) 
[17:40:56.425]                         invokeRestart("muffleMessage")
[17:40:56.425]                     }
[17:40:56.425]                     else if (inherits(cond, "warning")) {
[17:40:56.425]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.425]                       if (muffled) 
[17:40:56.425]                         invokeRestart("muffleWarning")
[17:40:56.425]                     }
[17:40:56.425]                     else if (inherits(cond, "condition")) {
[17:40:56.425]                       if (!is.null(pattern)) {
[17:40:56.425]                         computeRestarts <- base::computeRestarts
[17:40:56.425]                         grepl <- base::grepl
[17:40:56.425]                         restarts <- computeRestarts(cond)
[17:40:56.425]                         for (restart in restarts) {
[17:40:56.425]                           name <- restart$name
[17:40:56.425]                           if (is.null(name)) 
[17:40:56.425]                             next
[17:40:56.425]                           if (!grepl(pattern, name)) 
[17:40:56.425]                             next
[17:40:56.425]                           invokeRestart(restart)
[17:40:56.425]                           muffled <- TRUE
[17:40:56.425]                           break
[17:40:56.425]                         }
[17:40:56.425]                       }
[17:40:56.425]                     }
[17:40:56.425]                     invisible(muffled)
[17:40:56.425]                   }
[17:40:56.425]                   muffleCondition(cond)
[17:40:56.425]                 })
[17:40:56.425]             }))
[17:40:56.425]             future::FutureResult(value = ...future.value$value, 
[17:40:56.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.425]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.425]                     ...future.globalenv.names))
[17:40:56.425]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.425]         }, condition = base::local({
[17:40:56.425]             c <- base::c
[17:40:56.425]             inherits <- base::inherits
[17:40:56.425]             invokeRestart <- base::invokeRestart
[17:40:56.425]             length <- base::length
[17:40:56.425]             list <- base::list
[17:40:56.425]             seq.int <- base::seq.int
[17:40:56.425]             signalCondition <- base::signalCondition
[17:40:56.425]             sys.calls <- base::sys.calls
[17:40:56.425]             `[[` <- base::`[[`
[17:40:56.425]             `+` <- base::`+`
[17:40:56.425]             `<<-` <- base::`<<-`
[17:40:56.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.425]                   3L)]
[17:40:56.425]             }
[17:40:56.425]             function(cond) {
[17:40:56.425]                 is_error <- inherits(cond, "error")
[17:40:56.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.425]                   NULL)
[17:40:56.425]                 if (is_error) {
[17:40:56.425]                   sessionInformation <- function() {
[17:40:56.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.425]                       search = base::search(), system = base::Sys.info())
[17:40:56.425]                   }
[17:40:56.425]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.425]                     cond$call), session = sessionInformation(), 
[17:40:56.425]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.425]                   signalCondition(cond)
[17:40:56.425]                 }
[17:40:56.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.425]                 "immediateCondition"))) {
[17:40:56.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.425]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.425]                   if (TRUE && !signal) {
[17:40:56.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.425]                     {
[17:40:56.425]                       inherits <- base::inherits
[17:40:56.425]                       invokeRestart <- base::invokeRestart
[17:40:56.425]                       is.null <- base::is.null
[17:40:56.425]                       muffled <- FALSE
[17:40:56.425]                       if (inherits(cond, "message")) {
[17:40:56.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.425]                         if (muffled) 
[17:40:56.425]                           invokeRestart("muffleMessage")
[17:40:56.425]                       }
[17:40:56.425]                       else if (inherits(cond, "warning")) {
[17:40:56.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.425]                         if (muffled) 
[17:40:56.425]                           invokeRestart("muffleWarning")
[17:40:56.425]                       }
[17:40:56.425]                       else if (inherits(cond, "condition")) {
[17:40:56.425]                         if (!is.null(pattern)) {
[17:40:56.425]                           computeRestarts <- base::computeRestarts
[17:40:56.425]                           grepl <- base::grepl
[17:40:56.425]                           restarts <- computeRestarts(cond)
[17:40:56.425]                           for (restart in restarts) {
[17:40:56.425]                             name <- restart$name
[17:40:56.425]                             if (is.null(name)) 
[17:40:56.425]                               next
[17:40:56.425]                             if (!grepl(pattern, name)) 
[17:40:56.425]                               next
[17:40:56.425]                             invokeRestart(restart)
[17:40:56.425]                             muffled <- TRUE
[17:40:56.425]                             break
[17:40:56.425]                           }
[17:40:56.425]                         }
[17:40:56.425]                       }
[17:40:56.425]                       invisible(muffled)
[17:40:56.425]                     }
[17:40:56.425]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.425]                   }
[17:40:56.425]                 }
[17:40:56.425]                 else {
[17:40:56.425]                   if (TRUE) {
[17:40:56.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.425]                     {
[17:40:56.425]                       inherits <- base::inherits
[17:40:56.425]                       invokeRestart <- base::invokeRestart
[17:40:56.425]                       is.null <- base::is.null
[17:40:56.425]                       muffled <- FALSE
[17:40:56.425]                       if (inherits(cond, "message")) {
[17:40:56.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.425]                         if (muffled) 
[17:40:56.425]                           invokeRestart("muffleMessage")
[17:40:56.425]                       }
[17:40:56.425]                       else if (inherits(cond, "warning")) {
[17:40:56.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.425]                         if (muffled) 
[17:40:56.425]                           invokeRestart("muffleWarning")
[17:40:56.425]                       }
[17:40:56.425]                       else if (inherits(cond, "condition")) {
[17:40:56.425]                         if (!is.null(pattern)) {
[17:40:56.425]                           computeRestarts <- base::computeRestarts
[17:40:56.425]                           grepl <- base::grepl
[17:40:56.425]                           restarts <- computeRestarts(cond)
[17:40:56.425]                           for (restart in restarts) {
[17:40:56.425]                             name <- restart$name
[17:40:56.425]                             if (is.null(name)) 
[17:40:56.425]                               next
[17:40:56.425]                             if (!grepl(pattern, name)) 
[17:40:56.425]                               next
[17:40:56.425]                             invokeRestart(restart)
[17:40:56.425]                             muffled <- TRUE
[17:40:56.425]                             break
[17:40:56.425]                           }
[17:40:56.425]                         }
[17:40:56.425]                       }
[17:40:56.425]                       invisible(muffled)
[17:40:56.425]                     }
[17:40:56.425]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.425]                   }
[17:40:56.425]                 }
[17:40:56.425]             }
[17:40:56.425]         }))
[17:40:56.425]     }, error = function(ex) {
[17:40:56.425]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.425]                 ...future.rng), started = ...future.startTime, 
[17:40:56.425]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.425]             version = "1.8"), class = "FutureResult")
[17:40:56.425]     }, finally = {
[17:40:56.425]         if (!identical(...future.workdir, getwd())) 
[17:40:56.425]             setwd(...future.workdir)
[17:40:56.425]         {
[17:40:56.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.425]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.425]             }
[17:40:56.425]             base::options(...future.oldOptions)
[17:40:56.425]             if (.Platform$OS.type == "windows") {
[17:40:56.425]                 old_names <- names(...future.oldEnvVars)
[17:40:56.425]                 envs <- base::Sys.getenv()
[17:40:56.425]                 names <- names(envs)
[17:40:56.425]                 common <- intersect(names, old_names)
[17:40:56.425]                 added <- setdiff(names, old_names)
[17:40:56.425]                 removed <- setdiff(old_names, names)
[17:40:56.425]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.425]                   envs[common]]
[17:40:56.425]                 NAMES <- toupper(changed)
[17:40:56.425]                 args <- list()
[17:40:56.425]                 for (kk in seq_along(NAMES)) {
[17:40:56.425]                   name <- changed[[kk]]
[17:40:56.425]                   NAME <- NAMES[[kk]]
[17:40:56.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.425]                     next
[17:40:56.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.425]                 }
[17:40:56.425]                 NAMES <- toupper(added)
[17:40:56.425]                 for (kk in seq_along(NAMES)) {
[17:40:56.425]                   name <- added[[kk]]
[17:40:56.425]                   NAME <- NAMES[[kk]]
[17:40:56.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.425]                     next
[17:40:56.425]                   args[[name]] <- ""
[17:40:56.425]                 }
[17:40:56.425]                 NAMES <- toupper(removed)
[17:40:56.425]                 for (kk in seq_along(NAMES)) {
[17:40:56.425]                   name <- removed[[kk]]
[17:40:56.425]                   NAME <- NAMES[[kk]]
[17:40:56.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.425]                     next
[17:40:56.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.425]                 }
[17:40:56.425]                 if (length(args) > 0) 
[17:40:56.425]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.425]             }
[17:40:56.425]             else {
[17:40:56.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.425]             }
[17:40:56.425]             {
[17:40:56.425]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.425]                   0L) {
[17:40:56.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.425]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.425]                   base::options(opts)
[17:40:56.425]                 }
[17:40:56.425]                 {
[17:40:56.425]                   {
[17:40:56.425]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.425]                     NULL
[17:40:56.425]                   }
[17:40:56.425]                   options(future.plan = NULL)
[17:40:56.425]                   if (is.na(NA_character_)) 
[17:40:56.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.425]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.425]                     envir = parent.frame()) 
[17:40:56.425]                   {
[17:40:56.425]                     default_workers <- missing(workers)
[17:40:56.425]                     if (is.function(workers)) 
[17:40:56.425]                       workers <- workers()
[17:40:56.425]                     workers <- structure(as.integer(workers), 
[17:40:56.425]                       class = class(workers))
[17:40:56.425]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.425]                       1L)
[17:40:56.425]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.425]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.425]                       if (default_workers) 
[17:40:56.425]                         supportsMulticore(warn = TRUE)
[17:40:56.425]                       return(sequential(..., envir = envir))
[17:40:56.425]                     }
[17:40:56.425]                     oopts <- options(mc.cores = workers)
[17:40:56.425]                     on.exit(options(oopts))
[17:40:56.425]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.425]                       envir = envir)
[17:40:56.425]                     if (!future$lazy) 
[17:40:56.425]                       future <- run(future)
[17:40:56.425]                     invisible(future)
[17:40:56.425]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.425]                 }
[17:40:56.425]             }
[17:40:56.425]         }
[17:40:56.425]     })
[17:40:56.425]     if (TRUE) {
[17:40:56.425]         base::sink(type = "output", split = FALSE)
[17:40:56.425]         if (TRUE) {
[17:40:56.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.425]         }
[17:40:56.425]         else {
[17:40:56.425]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.425]         }
[17:40:56.425]         base::close(...future.stdout)
[17:40:56.425]         ...future.stdout <- NULL
[17:40:56.425]     }
[17:40:56.425]     ...future.result$conditions <- ...future.conditions
[17:40:56.425]     ...future.result$finished <- base::Sys.time()
[17:40:56.425]     ...future.result
[17:40:56.425] }
[17:40:56.428] assign_globals() ...
[17:40:56.428] List of 11
[17:40:56.428]  $ ...future.FUN            :function (x, ...)  
[17:40:56.428]  $ x_FUN                    :function (x)  
[17:40:56.428]  $ times                    : int 1
[17:40:56.428]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.428]  $ stop_if_not              :function (...)  
[17:40:56.428]  $ dim                      : NULL
[17:40:56.428]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:56.428]  $ future.call.arguments    : list()
[17:40:56.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.428]  $ ...future.elements_ii    :List of 1
[17:40:56.428]   ..$ a: num 1
[17:40:56.428]  $ ...future.seeds_ii       : NULL
[17:40:56.428]  $ ...future.globals.maxSize: NULL
[17:40:56.428]  - attr(*, "where")=List of 11
[17:40:56.428]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.428]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.428]  - attr(*, "resolved")= logi FALSE
[17:40:56.428]  - attr(*, "total_size")= num 94264
[17:40:56.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.428]  - attr(*, "already-done")= logi TRUE
[17:40:56.435] - copied ‘...future.FUN’ to environment
[17:40:56.435] - copied ‘x_FUN’ to environment
[17:40:56.435] - copied ‘times’ to environment
[17:40:56.435] - copied ‘stopf’ to environment
[17:40:56.436] - copied ‘stop_if_not’ to environment
[17:40:56.436] - copied ‘dim’ to environment
[17:40:56.436] - copied ‘valid_types’ to environment
[17:40:56.436] - copied ‘future.call.arguments’ to environment
[17:40:56.436] - copied ‘...future.elements_ii’ to environment
[17:40:56.436] - copied ‘...future.seeds_ii’ to environment
[17:40:56.436] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.436] assign_globals() ... done
[17:40:56.436] requestCore(): workers = 2
[17:40:56.439] MulticoreFuture started
[17:40:56.443] - Launch lazy future ... done
[17:40:56.443] run() for ‘MulticoreFuture’ ... done
[17:40:56.444] Created future:
[17:40:56.444] plan(): Setting new future strategy stack:
[17:40:56.444] List of future strategies:
[17:40:56.444] 1. sequential:
[17:40:56.444]    - args: function (..., envir = parent.frame())
[17:40:56.444]    - tweaked: FALSE
[17:40:56.444]    - call: NULL
[17:40:56.446] plan(): nbrOfWorkers() = 1
[17:40:56.448] plan(): Setting new future strategy stack:
[17:40:56.448] List of future strategies:
[17:40:56.448] 1. multicore:
[17:40:56.448]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.448]    - tweaked: FALSE
[17:40:56.448]    - call: plan(strategy)
[17:40:56.455] plan(): nbrOfWorkers() = 2
[17:40:56.444] MulticoreFuture:
[17:40:56.444] Label: ‘future_vapply-1’
[17:40:56.444] Expression:
[17:40:56.444] {
[17:40:56.444]     do.call(function(...) {
[17:40:56.444]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.444]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.444]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.444]             on.exit(options(oopts), add = TRUE)
[17:40:56.444]         }
[17:40:56.444]         {
[17:40:56.444]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.444]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.444]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.444]             })
[17:40:56.444]         }
[17:40:56.444]     }, args = future.call.arguments)
[17:40:56.444] }
[17:40:56.444] Lazy evaluation: FALSE
[17:40:56.444] Asynchronous evaluation: TRUE
[17:40:56.444] Local evaluation: TRUE
[17:40:56.444] Environment: R_GlobalEnv
[17:40:56.444] Capture standard output: TRUE
[17:40:56.444] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.444] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.444] Packages: 1 packages (‘future.apply’)
[17:40:56.444] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.444] Resolved: TRUE
[17:40:56.444] Value: <not collected>
[17:40:56.444] Conditions captured: <none>
[17:40:56.444] Early signaling: FALSE
[17:40:56.444] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.444] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.456] Chunk #1 of 2 ... DONE
[17:40:56.456] Chunk #2 of 2 ...
[17:40:56.456]  - Finding globals in 'X' for chunk #2 ...
[17:40:56.457] getGlobalsAndPackages() ...
[17:40:56.457] Searching for globals...
[17:40:56.457] 
[17:40:56.458] Searching for globals ... DONE
[17:40:56.458] - globals: [0] <none>
[17:40:56.458] getGlobalsAndPackages() ... DONE
[17:40:56.458]    + additional globals found: [n=0] 
[17:40:56.458]    + additional namespaces needed: [n=0] 
[17:40:56.459]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:56.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:56.459]  - seeds: <none>
[17:40:56.459] getGlobalsAndPackages() ...
[17:40:56.460] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.460] Resolving globals: FALSE
[17:40:56.460] Tweak future expression to call with '...' arguments ...
[17:40:56.460] {
[17:40:56.460]     do.call(function(...) {
[17:40:56.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.460]             on.exit(options(oopts), add = TRUE)
[17:40:56.460]         }
[17:40:56.460]         {
[17:40:56.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.460]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.460]             })
[17:40:56.460]         }
[17:40:56.460]     }, args = future.call.arguments)
[17:40:56.460] }
[17:40:56.461] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.462] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.462] - packages: [1] ‘future.apply’
[17:40:56.463] getGlobalsAndPackages() ... DONE
[17:40:56.463] run() for ‘Future’ ...
[17:40:56.463] - state: ‘created’
[17:40:56.464] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.469] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.469]   - Field: ‘label’
[17:40:56.469]   - Field: ‘local’
[17:40:56.470]   - Field: ‘owner’
[17:40:56.470]   - Field: ‘envir’
[17:40:56.470]   - Field: ‘workers’
[17:40:56.470]   - Field: ‘packages’
[17:40:56.470]   - Field: ‘gc’
[17:40:56.470]   - Field: ‘job’
[17:40:56.470]   - Field: ‘conditions’
[17:40:56.471]   - Field: ‘expr’
[17:40:56.471]   - Field: ‘uuid’
[17:40:56.471]   - Field: ‘seed’
[17:40:56.471]   - Field: ‘version’
[17:40:56.472]   - Field: ‘result’
[17:40:56.472]   - Field: ‘asynchronous’
[17:40:56.472]   - Field: ‘calls’
[17:40:56.472]   - Field: ‘globals’
[17:40:56.472]   - Field: ‘stdout’
[17:40:56.472]   - Field: ‘earlySignal’
[17:40:56.472]   - Field: ‘lazy’
[17:40:56.472]   - Field: ‘state’
[17:40:56.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.473] - Launch lazy future ...
[17:40:56.473] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.473] Packages needed by future strategies (n = 0): <none>
[17:40:56.474] {
[17:40:56.474]     {
[17:40:56.474]         {
[17:40:56.474]             ...future.startTime <- base::Sys.time()
[17:40:56.474]             {
[17:40:56.474]                 {
[17:40:56.474]                   {
[17:40:56.474]                     {
[17:40:56.474]                       {
[17:40:56.474]                         base::local({
[17:40:56.474]                           has_future <- base::requireNamespace("future", 
[17:40:56.474]                             quietly = TRUE)
[17:40:56.474]                           if (has_future) {
[17:40:56.474]                             ns <- base::getNamespace("future")
[17:40:56.474]                             version <- ns[[".package"]][["version"]]
[17:40:56.474]                             if (is.null(version)) 
[17:40:56.474]                               version <- utils::packageVersion("future")
[17:40:56.474]                           }
[17:40:56.474]                           else {
[17:40:56.474]                             version <- NULL
[17:40:56.474]                           }
[17:40:56.474]                           if (!has_future || version < "1.8.0") {
[17:40:56.474]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.474]                               "", base::R.version$version.string), 
[17:40:56.474]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.474]                                 base::R.version$platform, 8 * 
[17:40:56.474]                                   base::.Machine$sizeof.pointer), 
[17:40:56.474]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.474]                                 "release", "version")], collapse = " "), 
[17:40:56.474]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.474]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.474]                               info)
[17:40:56.474]                             info <- base::paste(info, collapse = "; ")
[17:40:56.474]                             if (!has_future) {
[17:40:56.474]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.474]                                 info)
[17:40:56.474]                             }
[17:40:56.474]                             else {
[17:40:56.474]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.474]                                 info, version)
[17:40:56.474]                             }
[17:40:56.474]                             base::stop(msg)
[17:40:56.474]                           }
[17:40:56.474]                         })
[17:40:56.474]                       }
[17:40:56.474]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.474]                       base::options(mc.cores = 1L)
[17:40:56.474]                     }
[17:40:56.474]                     base::local({
[17:40:56.474]                       for (pkg in "future.apply") {
[17:40:56.474]                         base::loadNamespace(pkg)
[17:40:56.474]                         base::library(pkg, character.only = TRUE)
[17:40:56.474]                       }
[17:40:56.474]                     })
[17:40:56.474]                   }
[17:40:56.474]                   options(future.plan = NULL)
[17:40:56.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.474]                 }
[17:40:56.474]                 ...future.workdir <- getwd()
[17:40:56.474]             }
[17:40:56.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.474]         }
[17:40:56.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.474]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:56.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.474]             base::names(...future.oldOptions))
[17:40:56.474]     }
[17:40:56.474]     if (FALSE) {
[17:40:56.474]     }
[17:40:56.474]     else {
[17:40:56.474]         if (TRUE) {
[17:40:56.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.474]                 open = "w")
[17:40:56.474]         }
[17:40:56.474]         else {
[17:40:56.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.474]         }
[17:40:56.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.474]             base::sink(type = "output", split = FALSE)
[17:40:56.474]             base::close(...future.stdout)
[17:40:56.474]         }, add = TRUE)
[17:40:56.474]     }
[17:40:56.474]     ...future.frame <- base::sys.nframe()
[17:40:56.474]     ...future.conditions <- base::list()
[17:40:56.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.474]     if (FALSE) {
[17:40:56.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.474]     }
[17:40:56.474]     ...future.result <- base::tryCatch({
[17:40:56.474]         base::withCallingHandlers({
[17:40:56.474]             ...future.value <- base::withVisible(base::local({
[17:40:56.474]                 withCallingHandlers({
[17:40:56.474]                   {
[17:40:56.474]                     do.call(function(...) {
[17:40:56.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.474]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.474]                         ...future.globals.maxSize)) {
[17:40:56.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.474]                         on.exit(options(oopts), add = TRUE)
[17:40:56.474]                       }
[17:40:56.474]                       {
[17:40:56.474]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.474]                           FUN = function(jj) {
[17:40:56.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.474]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.474]                           })
[17:40:56.474]                       }
[17:40:56.474]                     }, args = future.call.arguments)
[17:40:56.474]                   }
[17:40:56.474]                 }, immediateCondition = function(cond) {
[17:40:56.474]                   save_rds <- function (object, pathname, ...) 
[17:40:56.474]                   {
[17:40:56.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.474]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.474]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.474]                         fi_tmp[["mtime"]])
[17:40:56.474]                     }
[17:40:56.474]                     tryCatch({
[17:40:56.474]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.474]                     }, error = function(ex) {
[17:40:56.474]                       msg <- conditionMessage(ex)
[17:40:56.474]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.474]                         fi_tmp[["mtime"]], msg)
[17:40:56.474]                       ex$message <- msg
[17:40:56.474]                       stop(ex)
[17:40:56.474]                     })
[17:40:56.474]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.474]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.474]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.474]                       fi <- file.info(pathname)
[17:40:56.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.474]                         fi[["size"]], fi[["mtime"]])
[17:40:56.474]                       stop(msg)
[17:40:56.474]                     }
[17:40:56.474]                     invisible(pathname)
[17:40:56.474]                   }
[17:40:56.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.474]                     rootPath = tempdir()) 
[17:40:56.474]                   {
[17:40:56.474]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.474]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.474]                       tmpdir = path, fileext = ".rds")
[17:40:56.474]                     save_rds(obj, file)
[17:40:56.474]                   }
[17:40:56.474]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.474]                   {
[17:40:56.474]                     inherits <- base::inherits
[17:40:56.474]                     invokeRestart <- base::invokeRestart
[17:40:56.474]                     is.null <- base::is.null
[17:40:56.474]                     muffled <- FALSE
[17:40:56.474]                     if (inherits(cond, "message")) {
[17:40:56.474]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.474]                       if (muffled) 
[17:40:56.474]                         invokeRestart("muffleMessage")
[17:40:56.474]                     }
[17:40:56.474]                     else if (inherits(cond, "warning")) {
[17:40:56.474]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.474]                       if (muffled) 
[17:40:56.474]                         invokeRestart("muffleWarning")
[17:40:56.474]                     }
[17:40:56.474]                     else if (inherits(cond, "condition")) {
[17:40:56.474]                       if (!is.null(pattern)) {
[17:40:56.474]                         computeRestarts <- base::computeRestarts
[17:40:56.474]                         grepl <- base::grepl
[17:40:56.474]                         restarts <- computeRestarts(cond)
[17:40:56.474]                         for (restart in restarts) {
[17:40:56.474]                           name <- restart$name
[17:40:56.474]                           if (is.null(name)) 
[17:40:56.474]                             next
[17:40:56.474]                           if (!grepl(pattern, name)) 
[17:40:56.474]                             next
[17:40:56.474]                           invokeRestart(restart)
[17:40:56.474]                           muffled <- TRUE
[17:40:56.474]                           break
[17:40:56.474]                         }
[17:40:56.474]                       }
[17:40:56.474]                     }
[17:40:56.474]                     invisible(muffled)
[17:40:56.474]                   }
[17:40:56.474]                   muffleCondition(cond)
[17:40:56.474]                 })
[17:40:56.474]             }))
[17:40:56.474]             future::FutureResult(value = ...future.value$value, 
[17:40:56.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.474]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.474]                     ...future.globalenv.names))
[17:40:56.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.474]         }, condition = base::local({
[17:40:56.474]             c <- base::c
[17:40:56.474]             inherits <- base::inherits
[17:40:56.474]             invokeRestart <- base::invokeRestart
[17:40:56.474]             length <- base::length
[17:40:56.474]             list <- base::list
[17:40:56.474]             seq.int <- base::seq.int
[17:40:56.474]             signalCondition <- base::signalCondition
[17:40:56.474]             sys.calls <- base::sys.calls
[17:40:56.474]             `[[` <- base::`[[`
[17:40:56.474]             `+` <- base::`+`
[17:40:56.474]             `<<-` <- base::`<<-`
[17:40:56.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.474]                   3L)]
[17:40:56.474]             }
[17:40:56.474]             function(cond) {
[17:40:56.474]                 is_error <- inherits(cond, "error")
[17:40:56.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.474]                   NULL)
[17:40:56.474]                 if (is_error) {
[17:40:56.474]                   sessionInformation <- function() {
[17:40:56.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.474]                       search = base::search(), system = base::Sys.info())
[17:40:56.474]                   }
[17:40:56.474]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.474]                     cond$call), session = sessionInformation(), 
[17:40:56.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.474]                   signalCondition(cond)
[17:40:56.474]                 }
[17:40:56.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.474]                 "immediateCondition"))) {
[17:40:56.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.474]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.474]                   if (TRUE && !signal) {
[17:40:56.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.474]                     {
[17:40:56.474]                       inherits <- base::inherits
[17:40:56.474]                       invokeRestart <- base::invokeRestart
[17:40:56.474]                       is.null <- base::is.null
[17:40:56.474]                       muffled <- FALSE
[17:40:56.474]                       if (inherits(cond, "message")) {
[17:40:56.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.474]                         if (muffled) 
[17:40:56.474]                           invokeRestart("muffleMessage")
[17:40:56.474]                       }
[17:40:56.474]                       else if (inherits(cond, "warning")) {
[17:40:56.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.474]                         if (muffled) 
[17:40:56.474]                           invokeRestart("muffleWarning")
[17:40:56.474]                       }
[17:40:56.474]                       else if (inherits(cond, "condition")) {
[17:40:56.474]                         if (!is.null(pattern)) {
[17:40:56.474]                           computeRestarts <- base::computeRestarts
[17:40:56.474]                           grepl <- base::grepl
[17:40:56.474]                           restarts <- computeRestarts(cond)
[17:40:56.474]                           for (restart in restarts) {
[17:40:56.474]                             name <- restart$name
[17:40:56.474]                             if (is.null(name)) 
[17:40:56.474]                               next
[17:40:56.474]                             if (!grepl(pattern, name)) 
[17:40:56.474]                               next
[17:40:56.474]                             invokeRestart(restart)
[17:40:56.474]                             muffled <- TRUE
[17:40:56.474]                             break
[17:40:56.474]                           }
[17:40:56.474]                         }
[17:40:56.474]                       }
[17:40:56.474]                       invisible(muffled)
[17:40:56.474]                     }
[17:40:56.474]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.474]                   }
[17:40:56.474]                 }
[17:40:56.474]                 else {
[17:40:56.474]                   if (TRUE) {
[17:40:56.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.474]                     {
[17:40:56.474]                       inherits <- base::inherits
[17:40:56.474]                       invokeRestart <- base::invokeRestart
[17:40:56.474]                       is.null <- base::is.null
[17:40:56.474]                       muffled <- FALSE
[17:40:56.474]                       if (inherits(cond, "message")) {
[17:40:56.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.474]                         if (muffled) 
[17:40:56.474]                           invokeRestart("muffleMessage")
[17:40:56.474]                       }
[17:40:56.474]                       else if (inherits(cond, "warning")) {
[17:40:56.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.474]                         if (muffled) 
[17:40:56.474]                           invokeRestart("muffleWarning")
[17:40:56.474]                       }
[17:40:56.474]                       else if (inherits(cond, "condition")) {
[17:40:56.474]                         if (!is.null(pattern)) {
[17:40:56.474]                           computeRestarts <- base::computeRestarts
[17:40:56.474]                           grepl <- base::grepl
[17:40:56.474]                           restarts <- computeRestarts(cond)
[17:40:56.474]                           for (restart in restarts) {
[17:40:56.474]                             name <- restart$name
[17:40:56.474]                             if (is.null(name)) 
[17:40:56.474]                               next
[17:40:56.474]                             if (!grepl(pattern, name)) 
[17:40:56.474]                               next
[17:40:56.474]                             invokeRestart(restart)
[17:40:56.474]                             muffled <- TRUE
[17:40:56.474]                             break
[17:40:56.474]                           }
[17:40:56.474]                         }
[17:40:56.474]                       }
[17:40:56.474]                       invisible(muffled)
[17:40:56.474]                     }
[17:40:56.474]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.474]                   }
[17:40:56.474]                 }
[17:40:56.474]             }
[17:40:56.474]         }))
[17:40:56.474]     }, error = function(ex) {
[17:40:56.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.474]                 ...future.rng), started = ...future.startTime, 
[17:40:56.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.474]             version = "1.8"), class = "FutureResult")
[17:40:56.474]     }, finally = {
[17:40:56.474]         if (!identical(...future.workdir, getwd())) 
[17:40:56.474]             setwd(...future.workdir)
[17:40:56.474]         {
[17:40:56.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.474]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.474]             }
[17:40:56.474]             base::options(...future.oldOptions)
[17:40:56.474]             if (.Platform$OS.type == "windows") {
[17:40:56.474]                 old_names <- names(...future.oldEnvVars)
[17:40:56.474]                 envs <- base::Sys.getenv()
[17:40:56.474]                 names <- names(envs)
[17:40:56.474]                 common <- intersect(names, old_names)
[17:40:56.474]                 added <- setdiff(names, old_names)
[17:40:56.474]                 removed <- setdiff(old_names, names)
[17:40:56.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.474]                   envs[common]]
[17:40:56.474]                 NAMES <- toupper(changed)
[17:40:56.474]                 args <- list()
[17:40:56.474]                 for (kk in seq_along(NAMES)) {
[17:40:56.474]                   name <- changed[[kk]]
[17:40:56.474]                   NAME <- NAMES[[kk]]
[17:40:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.474]                     next
[17:40:56.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.474]                 }
[17:40:56.474]                 NAMES <- toupper(added)
[17:40:56.474]                 for (kk in seq_along(NAMES)) {
[17:40:56.474]                   name <- added[[kk]]
[17:40:56.474]                   NAME <- NAMES[[kk]]
[17:40:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.474]                     next
[17:40:56.474]                   args[[name]] <- ""
[17:40:56.474]                 }
[17:40:56.474]                 NAMES <- toupper(removed)
[17:40:56.474]                 for (kk in seq_along(NAMES)) {
[17:40:56.474]                   name <- removed[[kk]]
[17:40:56.474]                   NAME <- NAMES[[kk]]
[17:40:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.474]                     next
[17:40:56.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.474]                 }
[17:40:56.474]                 if (length(args) > 0) 
[17:40:56.474]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.474]             }
[17:40:56.474]             else {
[17:40:56.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.474]             }
[17:40:56.474]             {
[17:40:56.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.474]                   0L) {
[17:40:56.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.474]                   base::options(opts)
[17:40:56.474]                 }
[17:40:56.474]                 {
[17:40:56.474]                   {
[17:40:56.474]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.474]                     NULL
[17:40:56.474]                   }
[17:40:56.474]                   options(future.plan = NULL)
[17:40:56.474]                   if (is.na(NA_character_)) 
[17:40:56.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.474]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.474]                     envir = parent.frame()) 
[17:40:56.474]                   {
[17:40:56.474]                     default_workers <- missing(workers)
[17:40:56.474]                     if (is.function(workers)) 
[17:40:56.474]                       workers <- workers()
[17:40:56.474]                     workers <- structure(as.integer(workers), 
[17:40:56.474]                       class = class(workers))
[17:40:56.474]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.474]                       1L)
[17:40:56.474]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.474]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.474]                       if (default_workers) 
[17:40:56.474]                         supportsMulticore(warn = TRUE)
[17:40:56.474]                       return(sequential(..., envir = envir))
[17:40:56.474]                     }
[17:40:56.474]                     oopts <- options(mc.cores = workers)
[17:40:56.474]                     on.exit(options(oopts))
[17:40:56.474]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.474]                       envir = envir)
[17:40:56.474]                     if (!future$lazy) 
[17:40:56.474]                       future <- run(future)
[17:40:56.474]                     invisible(future)
[17:40:56.474]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.474]                 }
[17:40:56.474]             }
[17:40:56.474]         }
[17:40:56.474]     })
[17:40:56.474]     if (TRUE) {
[17:40:56.474]         base::sink(type = "output", split = FALSE)
[17:40:56.474]         if (TRUE) {
[17:40:56.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.474]         }
[17:40:56.474]         else {
[17:40:56.474]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.474]         }
[17:40:56.474]         base::close(...future.stdout)
[17:40:56.474]         ...future.stdout <- NULL
[17:40:56.474]     }
[17:40:56.474]     ...future.result$conditions <- ...future.conditions
[17:40:56.474]     ...future.result$finished <- base::Sys.time()
[17:40:56.474]     ...future.result
[17:40:56.474] }
[17:40:56.477] assign_globals() ...
[17:40:56.477] List of 11
[17:40:56.477]  $ ...future.FUN            :function (x, ...)  
[17:40:56.477]  $ x_FUN                    :function (x)  
[17:40:56.477]  $ times                    : int 1
[17:40:56.477]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.477]  $ stop_if_not              :function (...)  
[17:40:56.477]  $ dim                      : NULL
[17:40:56.477]  $ valid_types              : chr [1:2] "logical" "integer"
[17:40:56.477]  $ future.call.arguments    : list()
[17:40:56.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.477]  $ ...future.elements_ii    :List of 2
[17:40:56.477]   ..$ b: num 2
[17:40:56.477]   ..$ c: num 3
[17:40:56.477]  $ ...future.seeds_ii       : NULL
[17:40:56.477]  $ ...future.globals.maxSize: NULL
[17:40:56.477]  - attr(*, "resolved")= logi FALSE
[17:40:56.477]  - attr(*, "total_size")= num 94264
[17:40:56.477]  - attr(*, "where")=List of 11
[17:40:56.477]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.477]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.477]  - attr(*, "already-done")= logi TRUE
[17:40:56.489] - copied ‘...future.FUN’ to environment
[17:40:56.489] - copied ‘x_FUN’ to environment
[17:40:56.489] - copied ‘times’ to environment
[17:40:56.490] - copied ‘stopf’ to environment
[17:40:56.490] - copied ‘stop_if_not’ to environment
[17:40:56.490] - copied ‘dim’ to environment
[17:40:56.490] - copied ‘valid_types’ to environment
[17:40:56.490] - copied ‘future.call.arguments’ to environment
[17:40:56.490] - copied ‘...future.elements_ii’ to environment
[17:40:56.490] - copied ‘...future.seeds_ii’ to environment
[17:40:56.490] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.490] assign_globals() ... done
[17:40:56.491] requestCore(): workers = 2
[17:40:56.493] MulticoreFuture started
[17:40:56.494] - Launch lazy future ... done
[17:40:56.494] run() for ‘MulticoreFuture’ ... done
[17:40:56.495] Created future:
[17:40:56.495] plan(): Setting new future strategy stack:
[17:40:56.495] List of future strategies:
[17:40:56.495] 1. sequential:
[17:40:56.495]    - args: function (..., envir = parent.frame())
[17:40:56.495]    - tweaked: FALSE
[17:40:56.495]    - call: NULL
[17:40:56.497] plan(): nbrOfWorkers() = 1
[17:40:56.500] plan(): Setting new future strategy stack:
[17:40:56.500] List of future strategies:
[17:40:56.500] 1. multicore:
[17:40:56.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.500]    - tweaked: FALSE
[17:40:56.500]    - call: plan(strategy)
[17:40:56.507] plan(): nbrOfWorkers() = 2
[17:40:56.495] MulticoreFuture:
[17:40:56.495] Label: ‘future_vapply-2’
[17:40:56.495] Expression:
[17:40:56.495] {
[17:40:56.495]     do.call(function(...) {
[17:40:56.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.495]             on.exit(options(oopts), add = TRUE)
[17:40:56.495]         }
[17:40:56.495]         {
[17:40:56.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.495]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.495]             })
[17:40:56.495]         }
[17:40:56.495]     }, args = future.call.arguments)
[17:40:56.495] }
[17:40:56.495] Lazy evaluation: FALSE
[17:40:56.495] Asynchronous evaluation: TRUE
[17:40:56.495] Local evaluation: TRUE
[17:40:56.495] Environment: R_GlobalEnv
[17:40:56.495] Capture standard output: TRUE
[17:40:56.495] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.495] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.495] Packages: 1 packages (‘future.apply’)
[17:40:56.495] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.495] Resolved: TRUE
[17:40:56.495] Value: <not collected>
[17:40:56.495] Conditions captured: <none>
[17:40:56.495] Early signaling: FALSE
[17:40:56.495] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.495] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.508] Chunk #2 of 2 ... DONE
[17:40:56.508] Launching 2 futures (chunks) ... DONE
[17:40:56.508] Resolving 2 futures (chunks) ...
[17:40:56.509] resolve() on list ...
[17:40:56.509]  recursive: 0
[17:40:56.509]  length: 2
[17:40:56.509] 
[17:40:56.509] Future #1
[17:40:56.511] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:56.511] - nx: 2
[17:40:56.511] - relay: TRUE
[17:40:56.511] - stdout: TRUE
[17:40:56.511] - signal: TRUE
[17:40:56.512] - resignal: FALSE
[17:40:56.512] - force: TRUE
[17:40:56.512] - relayed: [n=2] FALSE, FALSE
[17:40:56.512] - queued futures: [n=2] FALSE, FALSE
[17:40:56.512]  - until=1
[17:40:56.512]  - relaying element #1
[17:40:56.513] - relayed: [n=2] TRUE, FALSE
[17:40:56.513] - queued futures: [n=2] TRUE, FALSE
[17:40:56.513] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:56.513]  length: 1 (resolved future 1)
[17:40:56.514] Future #2
[17:40:56.515] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:40:56.515] - nx: 2
[17:40:56.515] - relay: TRUE
[17:40:56.515] - stdout: TRUE
[17:40:56.515] - signal: TRUE
[17:40:56.516] - resignal: FALSE
[17:40:56.516] - force: TRUE
[17:40:56.516] - relayed: [n=2] TRUE, FALSE
[17:40:56.516] - queued futures: [n=2] TRUE, FALSE
[17:40:56.516]  - until=2
[17:40:56.516]  - relaying element #2
[17:40:56.516] - relayed: [n=2] TRUE, TRUE
[17:40:56.517] - queued futures: [n=2] TRUE, TRUE
[17:40:56.517] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:40:56.517]  length: 0 (resolved future 2)
[17:40:56.517] Relaying remaining futures
[17:40:56.517] signalConditionsASAP(NULL, pos=0) ...
[17:40:56.517] - nx: 2
[17:40:56.517] - relay: TRUE
[17:40:56.517] - stdout: TRUE
[17:40:56.518] - signal: TRUE
[17:40:56.518] - resignal: FALSE
[17:40:56.518] - force: TRUE
[17:40:56.518] - relayed: [n=2] TRUE, TRUE
[17:40:56.518] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:56.518] - relayed: [n=2] TRUE, TRUE
[17:40:56.518] - queued futures: [n=2] TRUE, TRUE
[17:40:56.518] signalConditionsASAP(NULL, pos=0) ... done
[17:40:56.519] resolve() on list ... DONE
[17:40:56.519]  - Number of value chunks collected: 2
[17:40:56.519] Resolving 2 futures (chunks) ... DONE
[17:40:56.519] Reducing values from 2 chunks ...
[17:40:56.519]  - Number of values collected after concatenation: 3
[17:40:56.519]  - Number of values expected: 3
[17:40:56.519] Reducing values from 2 chunks ... DONE
[17:40:56.519] future_lapply() ... DONE
- exceptions ...
[17:40:56.520] future_lapply() ...
[17:40:56.526] Number of chunks: 2
[17:40:56.526] getGlobalsAndPackagesXApply() ...
[17:40:56.527]  - future.globals: TRUE
[17:40:56.527] getGlobalsAndPackages() ...
[17:40:56.527] Searching for globals...
[17:40:56.569] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:56.569] Searching for globals ... DONE
[17:40:56.569] Resolving globals: FALSE
[17:40:56.570] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:40:56.570] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:56.571] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.571] - packages: [1] ‘future.apply’
[17:40:56.571] getGlobalsAndPackages() ... DONE
[17:40:56.571]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:56.571]  - needed namespaces: [n=1] ‘future.apply’
[17:40:56.571] Finding globals ... DONE
[17:40:56.571]  - use_args: TRUE
[17:40:56.571]  - Getting '...' globals ...
[17:40:56.572] resolve() on list ...
[17:40:56.572]  recursive: 0
[17:40:56.572]  length: 1
[17:40:56.572]  elements: ‘...’
[17:40:56.572]  length: 0 (resolved future 1)
[17:40:56.572] resolve() on list ... DONE
[17:40:56.572]    - '...' content: [n=0] 
[17:40:56.572] List of 1
[17:40:56.572]  $ ...: list()
[17:40:56.572]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.572]  - attr(*, "where")=List of 1
[17:40:56.572]   ..$ ...:<environment: 0x564f2e3c81a0> 
[17:40:56.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.572]  - attr(*, "resolved")= logi TRUE
[17:40:56.572]  - attr(*, "total_size")= num NA
[17:40:56.575]  - Getting '...' globals ... DONE
[17:40:56.575] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:56.575] List of 8
[17:40:56.575]  $ ...future.FUN:function (x, ...)  
[17:40:56.575]  $ x_FUN        :function (x)  
[17:40:56.575]  $ times        : int 2
[17:40:56.575]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.575]  $ stop_if_not  :function (...)  
[17:40:56.575]  $ dim          : NULL
[17:40:56.575]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:56.575]  $ ...          : list()
[17:40:56.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.575]  - attr(*, "where")=List of 8
[17:40:56.575]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:56.575]   ..$ ...          :<environment: 0x564f2e3c81a0> 
[17:40:56.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.575]  - attr(*, "resolved")= logi FALSE
[17:40:56.575]  - attr(*, "total_size")= num 95128
[17:40:56.580] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:56.580] getGlobalsAndPackagesXApply() ... DONE
[17:40:56.580] Number of futures (= number of chunks): 2
[17:40:56.581] Launching 2 futures (chunks) ...
[17:40:56.581] Chunk #1 of 2 ...
[17:40:56.581]  - Finding globals in 'X' for chunk #1 ...
[17:40:56.581] getGlobalsAndPackages() ...
[17:40:56.581] Searching for globals...
[17:40:56.581] 
[17:40:56.581] Searching for globals ... DONE
[17:40:56.581] - globals: [0] <none>
[17:40:56.582] getGlobalsAndPackages() ... DONE
[17:40:56.582]    + additional globals found: [n=0] 
[17:40:56.582]    + additional namespaces needed: [n=0] 
[17:40:56.582]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:56.582]  - seeds: <none>
[17:40:56.582] getGlobalsAndPackages() ...
[17:40:56.582] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.582] Resolving globals: FALSE
[17:40:56.582] Tweak future expression to call with '...' arguments ...
[17:40:56.582] {
[17:40:56.582]     do.call(function(...) {
[17:40:56.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.582]             on.exit(options(oopts), add = TRUE)
[17:40:56.582]         }
[17:40:56.582]         {
[17:40:56.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.582]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.582]             })
[17:40:56.582]         }
[17:40:56.582]     }, args = future.call.arguments)
[17:40:56.582] }
[17:40:56.583] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.583] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.583] - packages: [1] ‘future.apply’
[17:40:56.583] getGlobalsAndPackages() ... DONE
[17:40:56.584] run() for ‘Future’ ...
[17:40:56.584] - state: ‘created’
[17:40:56.584] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.588]   - Field: ‘label’
[17:40:56.588]   - Field: ‘local’
[17:40:56.589]   - Field: ‘owner’
[17:40:56.589]   - Field: ‘envir’
[17:40:56.589]   - Field: ‘workers’
[17:40:56.589]   - Field: ‘packages’
[17:40:56.589]   - Field: ‘gc’
[17:40:56.589]   - Field: ‘job’
[17:40:56.589]   - Field: ‘conditions’
[17:40:56.589]   - Field: ‘expr’
[17:40:56.589]   - Field: ‘uuid’
[17:40:56.589]   - Field: ‘seed’
[17:40:56.589]   - Field: ‘version’
[17:40:56.590]   - Field: ‘result’
[17:40:56.590]   - Field: ‘asynchronous’
[17:40:56.590]   - Field: ‘calls’
[17:40:56.590]   - Field: ‘globals’
[17:40:56.590]   - Field: ‘stdout’
[17:40:56.590]   - Field: ‘earlySignal’
[17:40:56.590]   - Field: ‘lazy’
[17:40:56.590]   - Field: ‘state’
[17:40:56.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.590] - Launch lazy future ...
[17:40:56.591] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.591] Packages needed by future strategies (n = 0): <none>
[17:40:56.591] {
[17:40:56.591]     {
[17:40:56.591]         {
[17:40:56.591]             ...future.startTime <- base::Sys.time()
[17:40:56.591]             {
[17:40:56.591]                 {
[17:40:56.591]                   {
[17:40:56.591]                     {
[17:40:56.591]                       {
[17:40:56.591]                         base::local({
[17:40:56.591]                           has_future <- base::requireNamespace("future", 
[17:40:56.591]                             quietly = TRUE)
[17:40:56.591]                           if (has_future) {
[17:40:56.591]                             ns <- base::getNamespace("future")
[17:40:56.591]                             version <- ns[[".package"]][["version"]]
[17:40:56.591]                             if (is.null(version)) 
[17:40:56.591]                               version <- utils::packageVersion("future")
[17:40:56.591]                           }
[17:40:56.591]                           else {
[17:40:56.591]                             version <- NULL
[17:40:56.591]                           }
[17:40:56.591]                           if (!has_future || version < "1.8.0") {
[17:40:56.591]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.591]                               "", base::R.version$version.string), 
[17:40:56.591]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.591]                                 base::R.version$platform, 8 * 
[17:40:56.591]                                   base::.Machine$sizeof.pointer), 
[17:40:56.591]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.591]                                 "release", "version")], collapse = " "), 
[17:40:56.591]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.591]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.591]                               info)
[17:40:56.591]                             info <- base::paste(info, collapse = "; ")
[17:40:56.591]                             if (!has_future) {
[17:40:56.591]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.591]                                 info)
[17:40:56.591]                             }
[17:40:56.591]                             else {
[17:40:56.591]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.591]                                 info, version)
[17:40:56.591]                             }
[17:40:56.591]                             base::stop(msg)
[17:40:56.591]                           }
[17:40:56.591]                         })
[17:40:56.591]                       }
[17:40:56.591]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.591]                       base::options(mc.cores = 1L)
[17:40:56.591]                     }
[17:40:56.591]                     base::local({
[17:40:56.591]                       for (pkg in "future.apply") {
[17:40:56.591]                         base::loadNamespace(pkg)
[17:40:56.591]                         base::library(pkg, character.only = TRUE)
[17:40:56.591]                       }
[17:40:56.591]                     })
[17:40:56.591]                   }
[17:40:56.591]                   options(future.plan = NULL)
[17:40:56.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.591]                 }
[17:40:56.591]                 ...future.workdir <- getwd()
[17:40:56.591]             }
[17:40:56.591]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.591]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.591]         }
[17:40:56.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:56.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.591]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.591]             base::names(...future.oldOptions))
[17:40:56.591]     }
[17:40:56.591]     if (FALSE) {
[17:40:56.591]     }
[17:40:56.591]     else {
[17:40:56.591]         if (TRUE) {
[17:40:56.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.591]                 open = "w")
[17:40:56.591]         }
[17:40:56.591]         else {
[17:40:56.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.591]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.591]         }
[17:40:56.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.591]             base::sink(type = "output", split = FALSE)
[17:40:56.591]             base::close(...future.stdout)
[17:40:56.591]         }, add = TRUE)
[17:40:56.591]     }
[17:40:56.591]     ...future.frame <- base::sys.nframe()
[17:40:56.591]     ...future.conditions <- base::list()
[17:40:56.591]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.591]     if (FALSE) {
[17:40:56.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.591]     }
[17:40:56.591]     ...future.result <- base::tryCatch({
[17:40:56.591]         base::withCallingHandlers({
[17:40:56.591]             ...future.value <- base::withVisible(base::local({
[17:40:56.591]                 withCallingHandlers({
[17:40:56.591]                   {
[17:40:56.591]                     do.call(function(...) {
[17:40:56.591]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.591]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.591]                         ...future.globals.maxSize)) {
[17:40:56.591]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.591]                         on.exit(options(oopts), add = TRUE)
[17:40:56.591]                       }
[17:40:56.591]                       {
[17:40:56.591]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.591]                           FUN = function(jj) {
[17:40:56.591]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.591]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.591]                           })
[17:40:56.591]                       }
[17:40:56.591]                     }, args = future.call.arguments)
[17:40:56.591]                   }
[17:40:56.591]                 }, immediateCondition = function(cond) {
[17:40:56.591]                   save_rds <- function (object, pathname, ...) 
[17:40:56.591]                   {
[17:40:56.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.591]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.591]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.591]                         fi_tmp[["mtime"]])
[17:40:56.591]                     }
[17:40:56.591]                     tryCatch({
[17:40:56.591]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.591]                     }, error = function(ex) {
[17:40:56.591]                       msg <- conditionMessage(ex)
[17:40:56.591]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.591]                         fi_tmp[["mtime"]], msg)
[17:40:56.591]                       ex$message <- msg
[17:40:56.591]                       stop(ex)
[17:40:56.591]                     })
[17:40:56.591]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.591]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.591]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.591]                       fi <- file.info(pathname)
[17:40:56.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.591]                         fi[["size"]], fi[["mtime"]])
[17:40:56.591]                       stop(msg)
[17:40:56.591]                     }
[17:40:56.591]                     invisible(pathname)
[17:40:56.591]                   }
[17:40:56.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.591]                     rootPath = tempdir()) 
[17:40:56.591]                   {
[17:40:56.591]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.591]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.591]                       tmpdir = path, fileext = ".rds")
[17:40:56.591]                     save_rds(obj, file)
[17:40:56.591]                   }
[17:40:56.591]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.591]                   {
[17:40:56.591]                     inherits <- base::inherits
[17:40:56.591]                     invokeRestart <- base::invokeRestart
[17:40:56.591]                     is.null <- base::is.null
[17:40:56.591]                     muffled <- FALSE
[17:40:56.591]                     if (inherits(cond, "message")) {
[17:40:56.591]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.591]                       if (muffled) 
[17:40:56.591]                         invokeRestart("muffleMessage")
[17:40:56.591]                     }
[17:40:56.591]                     else if (inherits(cond, "warning")) {
[17:40:56.591]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.591]                       if (muffled) 
[17:40:56.591]                         invokeRestart("muffleWarning")
[17:40:56.591]                     }
[17:40:56.591]                     else if (inherits(cond, "condition")) {
[17:40:56.591]                       if (!is.null(pattern)) {
[17:40:56.591]                         computeRestarts <- base::computeRestarts
[17:40:56.591]                         grepl <- base::grepl
[17:40:56.591]                         restarts <- computeRestarts(cond)
[17:40:56.591]                         for (restart in restarts) {
[17:40:56.591]                           name <- restart$name
[17:40:56.591]                           if (is.null(name)) 
[17:40:56.591]                             next
[17:40:56.591]                           if (!grepl(pattern, name)) 
[17:40:56.591]                             next
[17:40:56.591]                           invokeRestart(restart)
[17:40:56.591]                           muffled <- TRUE
[17:40:56.591]                           break
[17:40:56.591]                         }
[17:40:56.591]                       }
[17:40:56.591]                     }
[17:40:56.591]                     invisible(muffled)
[17:40:56.591]                   }
[17:40:56.591]                   muffleCondition(cond)
[17:40:56.591]                 })
[17:40:56.591]             }))
[17:40:56.591]             future::FutureResult(value = ...future.value$value, 
[17:40:56.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.591]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.591]                     ...future.globalenv.names))
[17:40:56.591]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.591]         }, condition = base::local({
[17:40:56.591]             c <- base::c
[17:40:56.591]             inherits <- base::inherits
[17:40:56.591]             invokeRestart <- base::invokeRestart
[17:40:56.591]             length <- base::length
[17:40:56.591]             list <- base::list
[17:40:56.591]             seq.int <- base::seq.int
[17:40:56.591]             signalCondition <- base::signalCondition
[17:40:56.591]             sys.calls <- base::sys.calls
[17:40:56.591]             `[[` <- base::`[[`
[17:40:56.591]             `+` <- base::`+`
[17:40:56.591]             `<<-` <- base::`<<-`
[17:40:56.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.591]                   3L)]
[17:40:56.591]             }
[17:40:56.591]             function(cond) {
[17:40:56.591]                 is_error <- inherits(cond, "error")
[17:40:56.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.591]                   NULL)
[17:40:56.591]                 if (is_error) {
[17:40:56.591]                   sessionInformation <- function() {
[17:40:56.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.591]                       search = base::search(), system = base::Sys.info())
[17:40:56.591]                   }
[17:40:56.591]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.591]                     cond$call), session = sessionInformation(), 
[17:40:56.591]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.591]                   signalCondition(cond)
[17:40:56.591]                 }
[17:40:56.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.591]                 "immediateCondition"))) {
[17:40:56.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.591]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.591]                   if (TRUE && !signal) {
[17:40:56.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.591]                     {
[17:40:56.591]                       inherits <- base::inherits
[17:40:56.591]                       invokeRestart <- base::invokeRestart
[17:40:56.591]                       is.null <- base::is.null
[17:40:56.591]                       muffled <- FALSE
[17:40:56.591]                       if (inherits(cond, "message")) {
[17:40:56.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.591]                         if (muffled) 
[17:40:56.591]                           invokeRestart("muffleMessage")
[17:40:56.591]                       }
[17:40:56.591]                       else if (inherits(cond, "warning")) {
[17:40:56.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.591]                         if (muffled) 
[17:40:56.591]                           invokeRestart("muffleWarning")
[17:40:56.591]                       }
[17:40:56.591]                       else if (inherits(cond, "condition")) {
[17:40:56.591]                         if (!is.null(pattern)) {
[17:40:56.591]                           computeRestarts <- base::computeRestarts
[17:40:56.591]                           grepl <- base::grepl
[17:40:56.591]                           restarts <- computeRestarts(cond)
[17:40:56.591]                           for (restart in restarts) {
[17:40:56.591]                             name <- restart$name
[17:40:56.591]                             if (is.null(name)) 
[17:40:56.591]                               next
[17:40:56.591]                             if (!grepl(pattern, name)) 
[17:40:56.591]                               next
[17:40:56.591]                             invokeRestart(restart)
[17:40:56.591]                             muffled <- TRUE
[17:40:56.591]                             break
[17:40:56.591]                           }
[17:40:56.591]                         }
[17:40:56.591]                       }
[17:40:56.591]                       invisible(muffled)
[17:40:56.591]                     }
[17:40:56.591]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.591]                   }
[17:40:56.591]                 }
[17:40:56.591]                 else {
[17:40:56.591]                   if (TRUE) {
[17:40:56.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.591]                     {
[17:40:56.591]                       inherits <- base::inherits
[17:40:56.591]                       invokeRestart <- base::invokeRestart
[17:40:56.591]                       is.null <- base::is.null
[17:40:56.591]                       muffled <- FALSE
[17:40:56.591]                       if (inherits(cond, "message")) {
[17:40:56.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.591]                         if (muffled) 
[17:40:56.591]                           invokeRestart("muffleMessage")
[17:40:56.591]                       }
[17:40:56.591]                       else if (inherits(cond, "warning")) {
[17:40:56.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.591]                         if (muffled) 
[17:40:56.591]                           invokeRestart("muffleWarning")
[17:40:56.591]                       }
[17:40:56.591]                       else if (inherits(cond, "condition")) {
[17:40:56.591]                         if (!is.null(pattern)) {
[17:40:56.591]                           computeRestarts <- base::computeRestarts
[17:40:56.591]                           grepl <- base::grepl
[17:40:56.591]                           restarts <- computeRestarts(cond)
[17:40:56.591]                           for (restart in restarts) {
[17:40:56.591]                             name <- restart$name
[17:40:56.591]                             if (is.null(name)) 
[17:40:56.591]                               next
[17:40:56.591]                             if (!grepl(pattern, name)) 
[17:40:56.591]                               next
[17:40:56.591]                             invokeRestart(restart)
[17:40:56.591]                             muffled <- TRUE
[17:40:56.591]                             break
[17:40:56.591]                           }
[17:40:56.591]                         }
[17:40:56.591]                       }
[17:40:56.591]                       invisible(muffled)
[17:40:56.591]                     }
[17:40:56.591]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.591]                   }
[17:40:56.591]                 }
[17:40:56.591]             }
[17:40:56.591]         }))
[17:40:56.591]     }, error = function(ex) {
[17:40:56.591]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.591]                 ...future.rng), started = ...future.startTime, 
[17:40:56.591]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.591]             version = "1.8"), class = "FutureResult")
[17:40:56.591]     }, finally = {
[17:40:56.591]         if (!identical(...future.workdir, getwd())) 
[17:40:56.591]             setwd(...future.workdir)
[17:40:56.591]         {
[17:40:56.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.591]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.591]             }
[17:40:56.591]             base::options(...future.oldOptions)
[17:40:56.591]             if (.Platform$OS.type == "windows") {
[17:40:56.591]                 old_names <- names(...future.oldEnvVars)
[17:40:56.591]                 envs <- base::Sys.getenv()
[17:40:56.591]                 names <- names(envs)
[17:40:56.591]                 common <- intersect(names, old_names)
[17:40:56.591]                 added <- setdiff(names, old_names)
[17:40:56.591]                 removed <- setdiff(old_names, names)
[17:40:56.591]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.591]                   envs[common]]
[17:40:56.591]                 NAMES <- toupper(changed)
[17:40:56.591]                 args <- list()
[17:40:56.591]                 for (kk in seq_along(NAMES)) {
[17:40:56.591]                   name <- changed[[kk]]
[17:40:56.591]                   NAME <- NAMES[[kk]]
[17:40:56.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.591]                     next
[17:40:56.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.591]                 }
[17:40:56.591]                 NAMES <- toupper(added)
[17:40:56.591]                 for (kk in seq_along(NAMES)) {
[17:40:56.591]                   name <- added[[kk]]
[17:40:56.591]                   NAME <- NAMES[[kk]]
[17:40:56.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.591]                     next
[17:40:56.591]                   args[[name]] <- ""
[17:40:56.591]                 }
[17:40:56.591]                 NAMES <- toupper(removed)
[17:40:56.591]                 for (kk in seq_along(NAMES)) {
[17:40:56.591]                   name <- removed[[kk]]
[17:40:56.591]                   NAME <- NAMES[[kk]]
[17:40:56.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.591]                     next
[17:40:56.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.591]                 }
[17:40:56.591]                 if (length(args) > 0) 
[17:40:56.591]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.591]             }
[17:40:56.591]             else {
[17:40:56.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.591]             }
[17:40:56.591]             {
[17:40:56.591]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.591]                   0L) {
[17:40:56.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.591]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.591]                   base::options(opts)
[17:40:56.591]                 }
[17:40:56.591]                 {
[17:40:56.591]                   {
[17:40:56.591]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.591]                     NULL
[17:40:56.591]                   }
[17:40:56.591]                   options(future.plan = NULL)
[17:40:56.591]                   if (is.na(NA_character_)) 
[17:40:56.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.591]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.591]                     envir = parent.frame()) 
[17:40:56.591]                   {
[17:40:56.591]                     default_workers <- missing(workers)
[17:40:56.591]                     if (is.function(workers)) 
[17:40:56.591]                       workers <- workers()
[17:40:56.591]                     workers <- structure(as.integer(workers), 
[17:40:56.591]                       class = class(workers))
[17:40:56.591]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.591]                       1L)
[17:40:56.591]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.591]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.591]                       if (default_workers) 
[17:40:56.591]                         supportsMulticore(warn = TRUE)
[17:40:56.591]                       return(sequential(..., envir = envir))
[17:40:56.591]                     }
[17:40:56.591]                     oopts <- options(mc.cores = workers)
[17:40:56.591]                     on.exit(options(oopts))
[17:40:56.591]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.591]                       envir = envir)
[17:40:56.591]                     if (!future$lazy) 
[17:40:56.591]                       future <- run(future)
[17:40:56.591]                     invisible(future)
[17:40:56.591]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.591]                 }
[17:40:56.591]             }
[17:40:56.591]         }
[17:40:56.591]     })
[17:40:56.591]     if (TRUE) {
[17:40:56.591]         base::sink(type = "output", split = FALSE)
[17:40:56.591]         if (TRUE) {
[17:40:56.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.591]         }
[17:40:56.591]         else {
[17:40:56.591]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.591]         }
[17:40:56.591]         base::close(...future.stdout)
[17:40:56.591]         ...future.stdout <- NULL
[17:40:56.591]     }
[17:40:56.591]     ...future.result$conditions <- ...future.conditions
[17:40:56.591]     ...future.result$finished <- base::Sys.time()
[17:40:56.591]     ...future.result
[17:40:56.591] }
[17:40:56.594] assign_globals() ...
[17:40:56.594] List of 11
[17:40:56.594]  $ ...future.FUN            :function (x, ...)  
[17:40:56.594]  $ x_FUN                    :function (x)  
[17:40:56.594]  $ times                    : int 2
[17:40:56.594]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.594]  $ stop_if_not              :function (...)  
[17:40:56.594]  $ dim                      : NULL
[17:40:56.594]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:56.594]  $ future.call.arguments    : list()
[17:40:56.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.594]  $ ...future.elements_ii    :List of 1
[17:40:56.594]   ..$ : int 1
[17:40:56.594]  $ ...future.seeds_ii       : NULL
[17:40:56.594]  $ ...future.globals.maxSize: NULL
[17:40:56.594]  - attr(*, "where")=List of 11
[17:40:56.594]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.594]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.594]  - attr(*, "resolved")= logi FALSE
[17:40:56.594]  - attr(*, "total_size")= num 95128
[17:40:56.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.594]  - attr(*, "already-done")= logi TRUE
[17:40:56.602] - copied ‘...future.FUN’ to environment
[17:40:56.602] - copied ‘x_FUN’ to environment
[17:40:56.602] - copied ‘times’ to environment
[17:40:56.602] - copied ‘stopf’ to environment
[17:40:56.602] - copied ‘stop_if_not’ to environment
[17:40:56.602] - copied ‘dim’ to environment
[17:40:56.603] - copied ‘valid_types’ to environment
[17:40:56.603] - copied ‘future.call.arguments’ to environment
[17:40:56.603] - copied ‘...future.elements_ii’ to environment
[17:40:56.603] - copied ‘...future.seeds_ii’ to environment
[17:40:56.603] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.603] assign_globals() ... done
[17:40:56.603] requestCore(): workers = 2
[17:40:56.606] MulticoreFuture started
[17:40:56.606] - Launch lazy future ... done
[17:40:56.606] run() for ‘MulticoreFuture’ ... done
[17:40:56.606] Created future:
[17:40:56.607] plan(): Setting new future strategy stack:
[17:40:56.608] List of future strategies:
[17:40:56.608] 1. sequential:
[17:40:56.608]    - args: function (..., envir = parent.frame())
[17:40:56.608]    - tweaked: FALSE
[17:40:56.608]    - call: NULL
[17:40:56.608] plan(): nbrOfWorkers() = 1
[17:40:56.610] plan(): Setting new future strategy stack:
[17:40:56.611] List of future strategies:
[17:40:56.611] 1. multicore:
[17:40:56.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.611]    - tweaked: FALSE
[17:40:56.611]    - call: plan(strategy)
[17:40:56.616] plan(): nbrOfWorkers() = 2
[17:40:56.607] MulticoreFuture:
[17:40:56.607] Label: ‘future_vapply-1’
[17:40:56.607] Expression:
[17:40:56.607] {
[17:40:56.607]     do.call(function(...) {
[17:40:56.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.607]             on.exit(options(oopts), add = TRUE)
[17:40:56.607]         }
[17:40:56.607]         {
[17:40:56.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.607]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.607]             })
[17:40:56.607]         }
[17:40:56.607]     }, args = future.call.arguments)
[17:40:56.607] }
[17:40:56.607] Lazy evaluation: FALSE
[17:40:56.607] Asynchronous evaluation: TRUE
[17:40:56.607] Local evaluation: TRUE
[17:40:56.607] Environment: R_GlobalEnv
[17:40:56.607] Capture standard output: TRUE
[17:40:56.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.607] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.607] Packages: 1 packages (‘future.apply’)
[17:40:56.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.607] Resolved: FALSE
[17:40:56.607] Value: <not collected>
[17:40:56.607] Conditions captured: <none>
[17:40:56.607] Early signaling: FALSE
[17:40:56.607] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.607] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.620] Chunk #1 of 2 ... DONE
[17:40:56.620] Chunk #2 of 2 ...
[17:40:56.620]  - Finding globals in 'X' for chunk #2 ...
[17:40:56.620] getGlobalsAndPackages() ...
[17:40:56.621] Searching for globals...
[17:40:56.621] 
[17:40:56.621] Searching for globals ... DONE
[17:40:56.621] - globals: [0] <none>
[17:40:56.621] getGlobalsAndPackages() ... DONE
[17:40:56.622]    + additional globals found: [n=0] 
[17:40:56.622]    + additional namespaces needed: [n=0] 
[17:40:56.622]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:56.622]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:40:56.622]  - seeds: <none>
[17:40:56.622] getGlobalsAndPackages() ...
[17:40:56.622] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.623] Resolving globals: FALSE
[17:40:56.623] Tweak future expression to call with '...' arguments ...
[17:40:56.623] {
[17:40:56.623]     do.call(function(...) {
[17:40:56.623]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.623]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.623]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.623]             on.exit(options(oopts), add = TRUE)
[17:40:56.623]         }
[17:40:56.623]         {
[17:40:56.623]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.623]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.623]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.623]             })
[17:40:56.623]         }
[17:40:56.623]     }, args = future.call.arguments)
[17:40:56.623] }
[17:40:56.623] Tweak future expression to call with '...' arguments ... DONE
[17:40:56.624] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:56.625] - packages: [1] ‘future.apply’
[17:40:56.625] getGlobalsAndPackages() ... DONE
[17:40:56.625] run() for ‘Future’ ...
[17:40:56.625] - state: ‘created’
[17:40:56.626] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.630] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:56.631]   - Field: ‘label’
[17:40:56.631]   - Field: ‘local’
[17:40:56.631]   - Field: ‘owner’
[17:40:56.632]   - Field: ‘envir’
[17:40:56.632]   - Field: ‘workers’
[17:40:56.632]   - Field: ‘packages’
[17:40:56.632]   - Field: ‘gc’
[17:40:56.632]   - Field: ‘job’
[17:40:56.632]   - Field: ‘conditions’
[17:40:56.632]   - Field: ‘expr’
[17:40:56.633]   - Field: ‘uuid’
[17:40:56.633]   - Field: ‘seed’
[17:40:56.633]   - Field: ‘version’
[17:40:56.633]   - Field: ‘result’
[17:40:56.633]   - Field: ‘asynchronous’
[17:40:56.633]   - Field: ‘calls’
[17:40:56.633]   - Field: ‘globals’
[17:40:56.634]   - Field: ‘stdout’
[17:40:56.634]   - Field: ‘earlySignal’
[17:40:56.634]   - Field: ‘lazy’
[17:40:56.634]   - Field: ‘state’
[17:40:56.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:56.634] - Launch lazy future ...
[17:40:56.635] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:56.635] Packages needed by future strategies (n = 0): <none>
[17:40:56.636] {
[17:40:56.636]     {
[17:40:56.636]         {
[17:40:56.636]             ...future.startTime <- base::Sys.time()
[17:40:56.636]             {
[17:40:56.636]                 {
[17:40:56.636]                   {
[17:40:56.636]                     {
[17:40:56.636]                       {
[17:40:56.636]                         base::local({
[17:40:56.636]                           has_future <- base::requireNamespace("future", 
[17:40:56.636]                             quietly = TRUE)
[17:40:56.636]                           if (has_future) {
[17:40:56.636]                             ns <- base::getNamespace("future")
[17:40:56.636]                             version <- ns[[".package"]][["version"]]
[17:40:56.636]                             if (is.null(version)) 
[17:40:56.636]                               version <- utils::packageVersion("future")
[17:40:56.636]                           }
[17:40:56.636]                           else {
[17:40:56.636]                             version <- NULL
[17:40:56.636]                           }
[17:40:56.636]                           if (!has_future || version < "1.8.0") {
[17:40:56.636]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.636]                               "", base::R.version$version.string), 
[17:40:56.636]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:56.636]                                 base::R.version$platform, 8 * 
[17:40:56.636]                                   base::.Machine$sizeof.pointer), 
[17:40:56.636]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.636]                                 "release", "version")], collapse = " "), 
[17:40:56.636]                               hostname = base::Sys.info()[["nodename"]])
[17:40:56.636]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.636]                               info)
[17:40:56.636]                             info <- base::paste(info, collapse = "; ")
[17:40:56.636]                             if (!has_future) {
[17:40:56.636]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.636]                                 info)
[17:40:56.636]                             }
[17:40:56.636]                             else {
[17:40:56.636]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.636]                                 info, version)
[17:40:56.636]                             }
[17:40:56.636]                             base::stop(msg)
[17:40:56.636]                           }
[17:40:56.636]                         })
[17:40:56.636]                       }
[17:40:56.636]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.636]                       base::options(mc.cores = 1L)
[17:40:56.636]                     }
[17:40:56.636]                     base::local({
[17:40:56.636]                       for (pkg in "future.apply") {
[17:40:56.636]                         base::loadNamespace(pkg)
[17:40:56.636]                         base::library(pkg, character.only = TRUE)
[17:40:56.636]                       }
[17:40:56.636]                     })
[17:40:56.636]                   }
[17:40:56.636]                   options(future.plan = NULL)
[17:40:56.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.636]                 }
[17:40:56.636]                 ...future.workdir <- getwd()
[17:40:56.636]             }
[17:40:56.636]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.636]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.636]         }
[17:40:56.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.636]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:40:56.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.636]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.636]             base::names(...future.oldOptions))
[17:40:56.636]     }
[17:40:56.636]     if (FALSE) {
[17:40:56.636]     }
[17:40:56.636]     else {
[17:40:56.636]         if (TRUE) {
[17:40:56.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.636]                 open = "w")
[17:40:56.636]         }
[17:40:56.636]         else {
[17:40:56.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.636]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.636]         }
[17:40:56.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.636]             base::sink(type = "output", split = FALSE)
[17:40:56.636]             base::close(...future.stdout)
[17:40:56.636]         }, add = TRUE)
[17:40:56.636]     }
[17:40:56.636]     ...future.frame <- base::sys.nframe()
[17:40:56.636]     ...future.conditions <- base::list()
[17:40:56.636]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.636]     if (FALSE) {
[17:40:56.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.636]     }
[17:40:56.636]     ...future.result <- base::tryCatch({
[17:40:56.636]         base::withCallingHandlers({
[17:40:56.636]             ...future.value <- base::withVisible(base::local({
[17:40:56.636]                 withCallingHandlers({
[17:40:56.636]                   {
[17:40:56.636]                     do.call(function(...) {
[17:40:56.636]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.636]                       if (!identical(...future.globals.maxSize.org, 
[17:40:56.636]                         ...future.globals.maxSize)) {
[17:40:56.636]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.636]                         on.exit(options(oopts), add = TRUE)
[17:40:56.636]                       }
[17:40:56.636]                       {
[17:40:56.636]                         lapply(seq_along(...future.elements_ii), 
[17:40:56.636]                           FUN = function(jj) {
[17:40:56.636]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.636]                             ...future.FUN(...future.X_jj, ...)
[17:40:56.636]                           })
[17:40:56.636]                       }
[17:40:56.636]                     }, args = future.call.arguments)
[17:40:56.636]                   }
[17:40:56.636]                 }, immediateCondition = function(cond) {
[17:40:56.636]                   save_rds <- function (object, pathname, ...) 
[17:40:56.636]                   {
[17:40:56.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:56.636]                     if (file_test("-f", pathname_tmp)) {
[17:40:56.636]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:56.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.636]                         fi_tmp[["mtime"]])
[17:40:56.636]                     }
[17:40:56.636]                     tryCatch({
[17:40:56.636]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:56.636]                     }, error = function(ex) {
[17:40:56.636]                       msg <- conditionMessage(ex)
[17:40:56.636]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:56.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.636]                         fi_tmp[["mtime"]], msg)
[17:40:56.636]                       ex$message <- msg
[17:40:56.636]                       stop(ex)
[17:40:56.636]                     })
[17:40:56.636]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:56.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:56.636]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:56.636]                       fi_tmp <- file.info(pathname_tmp)
[17:40:56.636]                       fi <- file.info(pathname)
[17:40:56.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:56.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:56.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:56.636]                         fi[["size"]], fi[["mtime"]])
[17:40:56.636]                       stop(msg)
[17:40:56.636]                     }
[17:40:56.636]                     invisible(pathname)
[17:40:56.636]                   }
[17:40:56.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:56.636]                     rootPath = tempdir()) 
[17:40:56.636]                   {
[17:40:56.636]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:56.636]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:56.636]                       tmpdir = path, fileext = ".rds")
[17:40:56.636]                     save_rds(obj, file)
[17:40:56.636]                   }
[17:40:56.636]                   saveImmediateCondition(cond, path = "/tmp/RtmpS9IjGD/.future/immediateConditions")
[17:40:56.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.636]                   {
[17:40:56.636]                     inherits <- base::inherits
[17:40:56.636]                     invokeRestart <- base::invokeRestart
[17:40:56.636]                     is.null <- base::is.null
[17:40:56.636]                     muffled <- FALSE
[17:40:56.636]                     if (inherits(cond, "message")) {
[17:40:56.636]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.636]                       if (muffled) 
[17:40:56.636]                         invokeRestart("muffleMessage")
[17:40:56.636]                     }
[17:40:56.636]                     else if (inherits(cond, "warning")) {
[17:40:56.636]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.636]                       if (muffled) 
[17:40:56.636]                         invokeRestart("muffleWarning")
[17:40:56.636]                     }
[17:40:56.636]                     else if (inherits(cond, "condition")) {
[17:40:56.636]                       if (!is.null(pattern)) {
[17:40:56.636]                         computeRestarts <- base::computeRestarts
[17:40:56.636]                         grepl <- base::grepl
[17:40:56.636]                         restarts <- computeRestarts(cond)
[17:40:56.636]                         for (restart in restarts) {
[17:40:56.636]                           name <- restart$name
[17:40:56.636]                           if (is.null(name)) 
[17:40:56.636]                             next
[17:40:56.636]                           if (!grepl(pattern, name)) 
[17:40:56.636]                             next
[17:40:56.636]                           invokeRestart(restart)
[17:40:56.636]                           muffled <- TRUE
[17:40:56.636]                           break
[17:40:56.636]                         }
[17:40:56.636]                       }
[17:40:56.636]                     }
[17:40:56.636]                     invisible(muffled)
[17:40:56.636]                   }
[17:40:56.636]                   muffleCondition(cond)
[17:40:56.636]                 })
[17:40:56.636]             }))
[17:40:56.636]             future::FutureResult(value = ...future.value$value, 
[17:40:56.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.636]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.636]                     ...future.globalenv.names))
[17:40:56.636]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.636]         }, condition = base::local({
[17:40:56.636]             c <- base::c
[17:40:56.636]             inherits <- base::inherits
[17:40:56.636]             invokeRestart <- base::invokeRestart
[17:40:56.636]             length <- base::length
[17:40:56.636]             list <- base::list
[17:40:56.636]             seq.int <- base::seq.int
[17:40:56.636]             signalCondition <- base::signalCondition
[17:40:56.636]             sys.calls <- base::sys.calls
[17:40:56.636]             `[[` <- base::`[[`
[17:40:56.636]             `+` <- base::`+`
[17:40:56.636]             `<<-` <- base::`<<-`
[17:40:56.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.636]                   3L)]
[17:40:56.636]             }
[17:40:56.636]             function(cond) {
[17:40:56.636]                 is_error <- inherits(cond, "error")
[17:40:56.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.636]                   NULL)
[17:40:56.636]                 if (is_error) {
[17:40:56.636]                   sessionInformation <- function() {
[17:40:56.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.636]                       search = base::search(), system = base::Sys.info())
[17:40:56.636]                   }
[17:40:56.636]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.636]                     cond$call), session = sessionInformation(), 
[17:40:56.636]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.636]                   signalCondition(cond)
[17:40:56.636]                 }
[17:40:56.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.636]                 "immediateCondition"))) {
[17:40:56.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.636]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.636]                   if (TRUE && !signal) {
[17:40:56.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.636]                     {
[17:40:56.636]                       inherits <- base::inherits
[17:40:56.636]                       invokeRestart <- base::invokeRestart
[17:40:56.636]                       is.null <- base::is.null
[17:40:56.636]                       muffled <- FALSE
[17:40:56.636]                       if (inherits(cond, "message")) {
[17:40:56.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.636]                         if (muffled) 
[17:40:56.636]                           invokeRestart("muffleMessage")
[17:40:56.636]                       }
[17:40:56.636]                       else if (inherits(cond, "warning")) {
[17:40:56.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.636]                         if (muffled) 
[17:40:56.636]                           invokeRestart("muffleWarning")
[17:40:56.636]                       }
[17:40:56.636]                       else if (inherits(cond, "condition")) {
[17:40:56.636]                         if (!is.null(pattern)) {
[17:40:56.636]                           computeRestarts <- base::computeRestarts
[17:40:56.636]                           grepl <- base::grepl
[17:40:56.636]                           restarts <- computeRestarts(cond)
[17:40:56.636]                           for (restart in restarts) {
[17:40:56.636]                             name <- restart$name
[17:40:56.636]                             if (is.null(name)) 
[17:40:56.636]                               next
[17:40:56.636]                             if (!grepl(pattern, name)) 
[17:40:56.636]                               next
[17:40:56.636]                             invokeRestart(restart)
[17:40:56.636]                             muffled <- TRUE
[17:40:56.636]                             break
[17:40:56.636]                           }
[17:40:56.636]                         }
[17:40:56.636]                       }
[17:40:56.636]                       invisible(muffled)
[17:40:56.636]                     }
[17:40:56.636]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.636]                   }
[17:40:56.636]                 }
[17:40:56.636]                 else {
[17:40:56.636]                   if (TRUE) {
[17:40:56.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.636]                     {
[17:40:56.636]                       inherits <- base::inherits
[17:40:56.636]                       invokeRestart <- base::invokeRestart
[17:40:56.636]                       is.null <- base::is.null
[17:40:56.636]                       muffled <- FALSE
[17:40:56.636]                       if (inherits(cond, "message")) {
[17:40:56.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.636]                         if (muffled) 
[17:40:56.636]                           invokeRestart("muffleMessage")
[17:40:56.636]                       }
[17:40:56.636]                       else if (inherits(cond, "warning")) {
[17:40:56.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.636]                         if (muffled) 
[17:40:56.636]                           invokeRestart("muffleWarning")
[17:40:56.636]                       }
[17:40:56.636]                       else if (inherits(cond, "condition")) {
[17:40:56.636]                         if (!is.null(pattern)) {
[17:40:56.636]                           computeRestarts <- base::computeRestarts
[17:40:56.636]                           grepl <- base::grepl
[17:40:56.636]                           restarts <- computeRestarts(cond)
[17:40:56.636]                           for (restart in restarts) {
[17:40:56.636]                             name <- restart$name
[17:40:56.636]                             if (is.null(name)) 
[17:40:56.636]                               next
[17:40:56.636]                             if (!grepl(pattern, name)) 
[17:40:56.636]                               next
[17:40:56.636]                             invokeRestart(restart)
[17:40:56.636]                             muffled <- TRUE
[17:40:56.636]                             break
[17:40:56.636]                           }
[17:40:56.636]                         }
[17:40:56.636]                       }
[17:40:56.636]                       invisible(muffled)
[17:40:56.636]                     }
[17:40:56.636]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.636]                   }
[17:40:56.636]                 }
[17:40:56.636]             }
[17:40:56.636]         }))
[17:40:56.636]     }, error = function(ex) {
[17:40:56.636]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.636]                 ...future.rng), started = ...future.startTime, 
[17:40:56.636]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.636]             version = "1.8"), class = "FutureResult")
[17:40:56.636]     }, finally = {
[17:40:56.636]         if (!identical(...future.workdir, getwd())) 
[17:40:56.636]             setwd(...future.workdir)
[17:40:56.636]         {
[17:40:56.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.636]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.636]             }
[17:40:56.636]             base::options(...future.oldOptions)
[17:40:56.636]             if (.Platform$OS.type == "windows") {
[17:40:56.636]                 old_names <- names(...future.oldEnvVars)
[17:40:56.636]                 envs <- base::Sys.getenv()
[17:40:56.636]                 names <- names(envs)
[17:40:56.636]                 common <- intersect(names, old_names)
[17:40:56.636]                 added <- setdiff(names, old_names)
[17:40:56.636]                 removed <- setdiff(old_names, names)
[17:40:56.636]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.636]                   envs[common]]
[17:40:56.636]                 NAMES <- toupper(changed)
[17:40:56.636]                 args <- list()
[17:40:56.636]                 for (kk in seq_along(NAMES)) {
[17:40:56.636]                   name <- changed[[kk]]
[17:40:56.636]                   NAME <- NAMES[[kk]]
[17:40:56.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.636]                     next
[17:40:56.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.636]                 }
[17:40:56.636]                 NAMES <- toupper(added)
[17:40:56.636]                 for (kk in seq_along(NAMES)) {
[17:40:56.636]                   name <- added[[kk]]
[17:40:56.636]                   NAME <- NAMES[[kk]]
[17:40:56.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.636]                     next
[17:40:56.636]                   args[[name]] <- ""
[17:40:56.636]                 }
[17:40:56.636]                 NAMES <- toupper(removed)
[17:40:56.636]                 for (kk in seq_along(NAMES)) {
[17:40:56.636]                   name <- removed[[kk]]
[17:40:56.636]                   NAME <- NAMES[[kk]]
[17:40:56.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.636]                     next
[17:40:56.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.636]                 }
[17:40:56.636]                 if (length(args) > 0) 
[17:40:56.636]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.636]             }
[17:40:56.636]             else {
[17:40:56.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.636]             }
[17:40:56.636]             {
[17:40:56.636]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.636]                   0L) {
[17:40:56.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.636]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.636]                   base::options(opts)
[17:40:56.636]                 }
[17:40:56.636]                 {
[17:40:56.636]                   {
[17:40:56.636]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.636]                     NULL
[17:40:56.636]                   }
[17:40:56.636]                   options(future.plan = NULL)
[17:40:56.636]                   if (is.na(NA_character_)) 
[17:40:56.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.636]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:40:56.636]                     envir = parent.frame()) 
[17:40:56.636]                   {
[17:40:56.636]                     default_workers <- missing(workers)
[17:40:56.636]                     if (is.function(workers)) 
[17:40:56.636]                       workers <- workers()
[17:40:56.636]                     workers <- structure(as.integer(workers), 
[17:40:56.636]                       class = class(workers))
[17:40:56.636]                     stop_if_not(is.finite(workers), workers >= 
[17:40:56.636]                       1L)
[17:40:56.636]                     if ((workers == 1L && !inherits(workers, 
[17:40:56.636]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:56.636]                       if (default_workers) 
[17:40:56.636]                         supportsMulticore(warn = TRUE)
[17:40:56.636]                       return(sequential(..., envir = envir))
[17:40:56.636]                     }
[17:40:56.636]                     oopts <- options(mc.cores = workers)
[17:40:56.636]                     on.exit(options(oopts))
[17:40:56.636]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:56.636]                       envir = envir)
[17:40:56.636]                     if (!future$lazy) 
[17:40:56.636]                       future <- run(future)
[17:40:56.636]                     invisible(future)
[17:40:56.636]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:56.636]                 }
[17:40:56.636]             }
[17:40:56.636]         }
[17:40:56.636]     })
[17:40:56.636]     if (TRUE) {
[17:40:56.636]         base::sink(type = "output", split = FALSE)
[17:40:56.636]         if (TRUE) {
[17:40:56.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.636]         }
[17:40:56.636]         else {
[17:40:56.636]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.636]         }
[17:40:56.636]         base::close(...future.stdout)
[17:40:56.636]         ...future.stdout <- NULL
[17:40:56.636]     }
[17:40:56.636]     ...future.result$conditions <- ...future.conditions
[17:40:56.636]     ...future.result$finished <- base::Sys.time()
[17:40:56.636]     ...future.result
[17:40:56.636] }
[17:40:56.639] assign_globals() ...
[17:40:56.639] List of 11
[17:40:56.639]  $ ...future.FUN            :function (x, ...)  
[17:40:56.639]  $ x_FUN                    :function (x)  
[17:40:56.639]  $ times                    : int 2
[17:40:56.639]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:56.639]  $ stop_if_not              :function (...)  
[17:40:56.639]  $ dim                      : NULL
[17:40:56.639]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:40:56.639]  $ future.call.arguments    : list()
[17:40:56.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:56.639]  $ ...future.elements_ii    :List of 2
[17:40:56.639]   ..$ : int 2
[17:40:56.639]   ..$ : int 3
[17:40:56.639]  $ ...future.seeds_ii       : NULL
[17:40:56.639]  $ ...future.globals.maxSize: NULL
[17:40:56.639]  - attr(*, "resolved")= logi FALSE
[17:40:56.639]  - attr(*, "total_size")= num 95128
[17:40:56.639]  - attr(*, "where")=List of 11
[17:40:56.639]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ times                    :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:40:56.639]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:40:56.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:56.639]  - attr(*, "already-done")= logi TRUE
[17:40:56.651] - copied ‘...future.FUN’ to environment
[17:40:56.651] - copied ‘x_FUN’ to environment
[17:40:56.651] - copied ‘times’ to environment
[17:40:56.651] - copied ‘stopf’ to environment
[17:40:56.651] - copied ‘stop_if_not’ to environment
[17:40:56.651] - copied ‘dim’ to environment
[17:40:56.652] - copied ‘valid_types’ to environment
[17:40:56.652] - copied ‘future.call.arguments’ to environment
[17:40:56.652] - copied ‘...future.elements_ii’ to environment
[17:40:56.652] - copied ‘...future.seeds_ii’ to environment
[17:40:56.652] - copied ‘...future.globals.maxSize’ to environment
[17:40:56.652] assign_globals() ... done
[17:40:56.652] requestCore(): workers = 2
[17:40:56.655] MulticoreFuture started
[17:40:56.655] - Launch lazy future ... done
[17:40:56.655] run() for ‘MulticoreFuture’ ... done
[17:40:56.656] Created future:
[17:40:56.656] plan(): Setting new future strategy stack:
[17:40:56.657] List of future strategies:
[17:40:56.657] 1. sequential:
[17:40:56.657]    - args: function (..., envir = parent.frame())
[17:40:56.657]    - tweaked: FALSE
[17:40:56.657]    - call: NULL
[17:40:56.658] plan(): nbrOfWorkers() = 1
[17:40:56.659] plan(): Setting new future strategy stack:
[17:40:56.660] List of future strategies:
[17:40:56.660] 1. multicore:
[17:40:56.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:56.660]    - tweaked: FALSE
[17:40:56.660]    - call: plan(strategy)
[17:40:56.665] plan(): nbrOfWorkers() = 2
[17:40:56.656] MulticoreFuture:
[17:40:56.656] Label: ‘future_vapply-2’
[17:40:56.656] Expression:
[17:40:56.656] {
[17:40:56.656]     do.call(function(...) {
[17:40:56.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:56.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:56.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:56.656]             on.exit(options(oopts), add = TRUE)
[17:40:56.656]         }
[17:40:56.656]         {
[17:40:56.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:56.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:56.656]                 ...future.FUN(...future.X_jj, ...)
[17:40:56.656]             })
[17:40:56.656]         }
[17:40:56.656]     }, args = future.call.arguments)
[17:40:56.656] }
[17:40:56.656] Lazy evaluation: FALSE
[17:40:56.656] Asynchronous evaluation: TRUE
[17:40:56.656] Local evaluation: TRUE
[17:40:56.656] Environment: R_GlobalEnv
[17:40:56.656] Capture standard output: TRUE
[17:40:56.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:56.656] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:56.656] Packages: 1 packages (‘future.apply’)
[17:40:56.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:56.656] Resolved: FALSE
[17:40:56.656] Value: <not collected>
[17:40:56.656] Conditions captured: <none>
[17:40:56.656] Early signaling: FALSE
[17:40:56.656] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:56.656] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.669] Chunk #2 of 2 ... DONE
[17:40:56.669] Launching 2 futures (chunks) ... DONE
[17:40:56.669] Resolving 2 futures (chunks) ...
[17:40:56.669] resolve() on list ...
[17:40:56.669]  recursive: 0
[17:40:56.670]  length: 2
[17:40:56.670] 
[17:40:56.670] Future #1
[17:40:56.677] signalConditions() ...
[17:40:56.677]  - include = ‘immediateCondition’
[17:40:56.677]  - exclude = 
[17:40:56.677]  - resignal = FALSE
[17:40:56.678]  - Number of conditions: 1
[17:40:56.678] signalConditions() ... done
[17:40:56.678] signalConditions() ...
[17:40:56.678]  - include = ‘immediateCondition’
[17:40:56.678]  - exclude = 
[17:40:56.679]  - resignal = FALSE
[17:40:56.679]  - Number of conditions: 1
[17:40:56.679] signalConditions() ... done
[17:40:56.679] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:40:56.679] - nx: 2
[17:40:56.679] - relay: TRUE
[17:40:56.680] - stdout: TRUE
[17:40:56.680] - signal: TRUE
[17:40:56.680] - resignal: FALSE
[17:40:56.680] - force: TRUE
[17:40:56.680] - relayed: [n=2] FALSE, FALSE
[17:40:56.680] - queued futures: [n=2] FALSE, FALSE
[17:40:56.681]  - until=1
[17:40:56.681]  - relaying element #1
[17:40:56.681] signalConditions() ...
[17:40:56.681]  - include = ‘immediateCondition’
[17:40:56.681]  - exclude = 
[17:40:56.681]  - resignal = FALSE
[17:40:56.681]  - Number of conditions: 1
[17:40:56.682] signalConditions() ... done
[17:40:56.682] signalConditions() ...
[17:40:56.682]  - include = ‘immediateCondition’
[17:40:56.682]  - exclude = 
[17:40:56.682]  - resignal = FALSE
[17:40:56.682]  - Number of conditions: 1
[17:40:56.683] signalConditions() ... done
[17:40:56.683] signalConditions() ...
[17:40:56.683]  - include = ‘condition’
[17:40:56.683]  - exclude = ‘immediateCondition’
[17:40:56.683]  - resignal = TRUE
[17:40:56.683]  - Number of conditions: 1
[17:40:56.684]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:40:56.684] signalConditions() ... done
[17:40:56.684] - relayed: [n=2] FALSE, FALSE
[17:40:56.684] - queued futures: [n=2] TRUE, FALSE
[17:40:56.684] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:40:56.685] plan(): Setting new future strategy stack:
[17:40:56.685] List of future strategies:
[17:40:56.685] 1. sequential:
[17:40:56.685]    - args: function (..., envir = parent.frame())
[17:40:56.685]    - tweaked: FALSE
[17:40:56.685]    - call: plan(sequential)
[17:40:56.685] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:40:56.686] plan(): Setting new future strategy stack:
[17:40:56.686] List of future strategies:
[17:40:56.686] 1. multisession:
[17:40:56.686]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:56.686]    - tweaked: FALSE
[17:40:56.686]    - call: plan(strategy)
[17:40:56.687] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:56.687] multisession:
[17:40:56.687] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:56.687] - tweaked: FALSE
[17:40:56.687] - call: plan(strategy)
[17:40:56.695] getGlobalsAndPackages() ...
[17:40:56.695] Not searching for globals
[17:40:56.695] - globals: [0] <none>
[17:40:56.695] getGlobalsAndPackages() ... DONE
[17:40:56.696] [local output] makeClusterPSOCK() ...
[17:40:56.760] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:56.765] [local output] Base port: 11226
[17:40:56.766] [local output] Getting setup options for 2 cluster nodes ...
[17:40:56.766] [local output]  - Node 1 of 2 ...
[17:40:56.766] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:56.767] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS9IjGD/worker.rank=1.parallelly.parent=39671.9af71f9a4bcb.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpS9IjGD/worker.rank=1.parallelly.parent=39671.9af71f9a4bcb.pid")'’
[17:40:56.957] - Possible to infer worker's PID: TRUE
[17:40:56.957] [local output] Rscript port: 11226

[17:40:56.958] [local output]  - Node 2 of 2 ...
[17:40:56.958] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:56.959] [local output] Rscript port: 11226

[17:40:56.959] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:56.959] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:56.960] [local output] Setting up PSOCK nodes in parallel
[17:40:56.960] List of 36
[17:40:56.960]  $ worker          : chr "localhost"
[17:40:56.960]   ..- attr(*, "localhost")= logi TRUE
[17:40:56.960]  $ master          : chr "localhost"
[17:40:56.960]  $ port            : int 11226
[17:40:56.960]  $ connectTimeout  : num 120
[17:40:56.960]  $ timeout         : num 2592000
[17:40:56.960]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:56.960]  $ homogeneous     : logi TRUE
[17:40:56.960]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:56.960]  $ rscript_envs    : NULL
[17:40:56.960]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:56.960]  $ rscript_startup : NULL
[17:40:56.960]  $ rscript_sh      : chr "sh"
[17:40:56.960]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:56.960]  $ methods         : logi TRUE
[17:40:56.960]  $ socketOptions   : chr "no-delay"
[17:40:56.960]  $ useXDR          : logi FALSE
[17:40:56.960]  $ outfile         : chr "/dev/null"
[17:40:56.960]  $ renice          : int NA
[17:40:56.960]  $ rshcmd          : NULL
[17:40:56.960]  $ user            : chr(0) 
[17:40:56.960]  $ revtunnel       : logi FALSE
[17:40:56.960]  $ rshlogfile      : NULL
[17:40:56.960]  $ rshopts         : chr(0) 
[17:40:56.960]  $ rank            : int 1
[17:40:56.960]  $ manual          : logi FALSE
[17:40:56.960]  $ dryrun          : logi FALSE
[17:40:56.960]  $ quiet           : logi FALSE
[17:40:56.960]  $ setup_strategy  : chr "parallel"
[17:40:56.960]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:56.960]  $ pidfile         : chr "/tmp/RtmpS9IjGD/worker.rank=1.parallelly.parent=39671.9af71f9a4bcb.pid"
[17:40:56.960]  $ rshcmd_label    : NULL
[17:40:56.960]  $ rsh_call        : NULL
[17:40:56.960]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:56.960]  $ localMachine    : logi TRUE
[17:40:56.960]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:56.960]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:56.960]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:56.960]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:56.960]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:56.960]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:56.960]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:56.960]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:56.960]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:56.960]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:56.960]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:56.960]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:56.960]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:56.960]  $ arguments       :List of 28
[17:40:56.960]   ..$ worker          : chr "localhost"
[17:40:56.960]   ..$ master          : NULL
[17:40:56.960]   ..$ port            : int 11226
[17:40:56.960]   ..$ connectTimeout  : num 120
[17:40:56.960]   ..$ timeout         : num 2592000
[17:40:56.960]   ..$ rscript         : NULL
[17:40:56.960]   ..$ homogeneous     : NULL
[17:40:56.960]   ..$ rscript_args    : NULL
[17:40:56.960]   ..$ rscript_envs    : NULL
[17:40:56.960]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:56.960]   ..$ rscript_startup : NULL
[17:40:56.960]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:56.960]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:56.960]   ..$ methods         : logi TRUE
[17:40:56.960]   ..$ socketOptions   : chr "no-delay"
[17:40:56.960]   ..$ useXDR          : logi FALSE
[17:40:56.960]   ..$ outfile         : chr "/dev/null"
[17:40:56.960]   ..$ renice          : int NA
[17:40:56.960]   ..$ rshcmd          : NULL
[17:40:56.960]   ..$ user            : NULL
[17:40:56.960]   ..$ revtunnel       : logi NA
[17:40:56.960]   ..$ rshlogfile      : NULL
[17:40:56.960]   ..$ rshopts         : NULL
[17:40:56.960]   ..$ rank            : int 1
[17:40:56.960]   ..$ manual          : logi FALSE
[17:40:56.960]   ..$ dryrun          : logi FALSE
[17:40:56.960]   ..$ quiet           : logi FALSE
[17:40:56.960]   ..$ setup_strategy  : chr "parallel"
[17:40:56.960]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:56.976] [local output] System call to launch all workers:
[17:40:56.976] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS9IjGD/worker.rank=1.parallelly.parent=39671.9af71f9a4bcb.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11226 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:56.976] [local output] Starting PSOCK main server
[17:40:56.978] [local output] Workers launched
[17:40:56.978] [local output] Waiting for workers to connect back
[17:40:56.978]  - [local output] 0 workers out of 2 ready
[17:40:57.221]  - [local output] 0 workers out of 2 ready
[17:40:57.222]  - [local output] 1 workers out of 2 ready
[17:40:57.222]  - [local output] 2 workers out of 2 ready
[17:40:57.222] [local output] Launching of workers completed
[17:40:57.222] [local output] Collecting session information from workers
[17:40:57.223] [local output]  - Worker #1 of 2
[17:40:57.224] [local output]  - Worker #2 of 2
[17:40:57.224] [local output] makeClusterPSOCK() ... done
[17:40:57.235] Packages needed by the future expression (n = 0): <none>
[17:40:57.235] Packages needed by future strategies (n = 0): <none>
[17:40:57.236] {
[17:40:57.236]     {
[17:40:57.236]         {
[17:40:57.236]             ...future.startTime <- base::Sys.time()
[17:40:57.236]             {
[17:40:57.236]                 {
[17:40:57.236]                   {
[17:40:57.236]                     {
[17:40:57.236]                       base::local({
[17:40:57.236]                         has_future <- base::requireNamespace("future", 
[17:40:57.236]                           quietly = TRUE)
[17:40:57.236]                         if (has_future) {
[17:40:57.236]                           ns <- base::getNamespace("future")
[17:40:57.236]                           version <- ns[[".package"]][["version"]]
[17:40:57.236]                           if (is.null(version)) 
[17:40:57.236]                             version <- utils::packageVersion("future")
[17:40:57.236]                         }
[17:40:57.236]                         else {
[17:40:57.236]                           version <- NULL
[17:40:57.236]                         }
[17:40:57.236]                         if (!has_future || version < "1.8.0") {
[17:40:57.236]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:57.236]                             "", base::R.version$version.string), 
[17:40:57.236]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:57.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:57.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:57.236]                               "release", "version")], collapse = " "), 
[17:40:57.236]                             hostname = base::Sys.info()[["nodename"]])
[17:40:57.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:57.236]                             info)
[17:40:57.236]                           info <- base::paste(info, collapse = "; ")
[17:40:57.236]                           if (!has_future) {
[17:40:57.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:57.236]                               info)
[17:40:57.236]                           }
[17:40:57.236]                           else {
[17:40:57.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:57.236]                               info, version)
[17:40:57.236]                           }
[17:40:57.236]                           base::stop(msg)
[17:40:57.236]                         }
[17:40:57.236]                       })
[17:40:57.236]                     }
[17:40:57.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:57.236]                     base::options(mc.cores = 1L)
[17:40:57.236]                   }
[17:40:57.236]                   options(future.plan = NULL)
[17:40:57.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:57.236]                 }
[17:40:57.236]                 ...future.workdir <- getwd()
[17:40:57.236]             }
[17:40:57.236]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:57.236]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:57.236]         }
[17:40:57.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:57.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:57.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:57.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:57.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:57.236]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:57.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:57.236]             base::names(...future.oldOptions))
[17:40:57.236]     }
[17:40:57.236]     if (FALSE) {
[17:40:57.236]     }
[17:40:57.236]     else {
[17:40:57.236]         if (TRUE) {
[17:40:57.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:57.236]                 open = "w")
[17:40:57.236]         }
[17:40:57.236]         else {
[17:40:57.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:57.236]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:57.236]         }
[17:40:57.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:57.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:57.236]             base::sink(type = "output", split = FALSE)
[17:40:57.236]             base::close(...future.stdout)
[17:40:57.236]         }, add = TRUE)
[17:40:57.236]     }
[17:40:57.236]     ...future.frame <- base::sys.nframe()
[17:40:57.236]     ...future.conditions <- base::list()
[17:40:57.236]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:57.236]     if (FALSE) {
[17:40:57.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:57.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:57.236]     }
[17:40:57.236]     ...future.result <- base::tryCatch({
[17:40:57.236]         base::withCallingHandlers({
[17:40:57.236]             ...future.value <- base::withVisible(base::local({
[17:40:57.236]                 ...future.makeSendCondition <- local({
[17:40:57.236]                   sendCondition <- NULL
[17:40:57.236]                   function(frame = 1L) {
[17:40:57.236]                     if (is.function(sendCondition)) 
[17:40:57.236]                       return(sendCondition)
[17:40:57.236]                     ns <- getNamespace("parallel")
[17:40:57.236]                     if (exists("sendData", mode = "function", 
[17:40:57.236]                       envir = ns)) {
[17:40:57.236]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:57.236]                         envir = ns)
[17:40:57.236]                       envir <- sys.frame(frame)
[17:40:57.236]                       master <- NULL
[17:40:57.236]                       while (!identical(envir, .GlobalEnv) && 
[17:40:57.236]                         !identical(envir, emptyenv())) {
[17:40:57.236]                         if (exists("master", mode = "list", envir = envir, 
[17:40:57.236]                           inherits = FALSE)) {
[17:40:57.236]                           master <- get("master", mode = "list", 
[17:40:57.236]                             envir = envir, inherits = FALSE)
[17:40:57.236]                           if (inherits(master, c("SOCKnode", 
[17:40:57.236]                             "SOCK0node"))) {
[17:40:57.236]                             sendCondition <<- function(cond) {
[17:40:57.236]                               data <- list(type = "VALUE", value = cond, 
[17:40:57.236]                                 success = TRUE)
[17:40:57.236]                               parallel_sendData(master, data)
[17:40:57.236]                             }
[17:40:57.236]                             return(sendCondition)
[17:40:57.236]                           }
[17:40:57.236]                         }
[17:40:57.236]                         frame <- frame + 1L
[17:40:57.236]                         envir <- sys.frame(frame)
[17:40:57.236]                       }
[17:40:57.236]                     }
[17:40:57.236]                     sendCondition <<- function(cond) NULL
[17:40:57.236]                   }
[17:40:57.236]                 })
[17:40:57.236]                 withCallingHandlers({
[17:40:57.236]                   NA
[17:40:57.236]                 }, immediateCondition = function(cond) {
[17:40:57.236]                   sendCondition <- ...future.makeSendCondition()
[17:40:57.236]                   sendCondition(cond)
[17:40:57.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.236]                   {
[17:40:57.236]                     inherits <- base::inherits
[17:40:57.236]                     invokeRestart <- base::invokeRestart
[17:40:57.236]                     is.null <- base::is.null
[17:40:57.236]                     muffled <- FALSE
[17:40:57.236]                     if (inherits(cond, "message")) {
[17:40:57.236]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:57.236]                       if (muffled) 
[17:40:57.236]                         invokeRestart("muffleMessage")
[17:40:57.236]                     }
[17:40:57.236]                     else if (inherits(cond, "warning")) {
[17:40:57.236]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:57.236]                       if (muffled) 
[17:40:57.236]                         invokeRestart("muffleWarning")
[17:40:57.236]                     }
[17:40:57.236]                     else if (inherits(cond, "condition")) {
[17:40:57.236]                       if (!is.null(pattern)) {
[17:40:57.236]                         computeRestarts <- base::computeRestarts
[17:40:57.236]                         grepl <- base::grepl
[17:40:57.236]                         restarts <- computeRestarts(cond)
[17:40:57.236]                         for (restart in restarts) {
[17:40:57.236]                           name <- restart$name
[17:40:57.236]                           if (is.null(name)) 
[17:40:57.236]                             next
[17:40:57.236]                           if (!grepl(pattern, name)) 
[17:40:57.236]                             next
[17:40:57.236]                           invokeRestart(restart)
[17:40:57.236]                           muffled <- TRUE
[17:40:57.236]                           break
[17:40:57.236]                         }
[17:40:57.236]                       }
[17:40:57.236]                     }
[17:40:57.236]                     invisible(muffled)
[17:40:57.236]                   }
[17:40:57.236]                   muffleCondition(cond)
[17:40:57.236]                 })
[17:40:57.236]             }))
[17:40:57.236]             future::FutureResult(value = ...future.value$value, 
[17:40:57.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.236]                   ...future.rng), globalenv = if (FALSE) 
[17:40:57.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:57.236]                     ...future.globalenv.names))
[17:40:57.236]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:57.236]         }, condition = base::local({
[17:40:57.236]             c <- base::c
[17:40:57.236]             inherits <- base::inherits
[17:40:57.236]             invokeRestart <- base::invokeRestart
[17:40:57.236]             length <- base::length
[17:40:57.236]             list <- base::list
[17:40:57.236]             seq.int <- base::seq.int
[17:40:57.236]             signalCondition <- base::signalCondition
[17:40:57.236]             sys.calls <- base::sys.calls
[17:40:57.236]             `[[` <- base::`[[`
[17:40:57.236]             `+` <- base::`+`
[17:40:57.236]             `<<-` <- base::`<<-`
[17:40:57.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:57.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:57.236]                   3L)]
[17:40:57.236]             }
[17:40:57.236]             function(cond) {
[17:40:57.236]                 is_error <- inherits(cond, "error")
[17:40:57.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:57.236]                   NULL)
[17:40:57.236]                 if (is_error) {
[17:40:57.236]                   sessionInformation <- function() {
[17:40:57.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:57.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:57.236]                       search = base::search(), system = base::Sys.info())
[17:40:57.236]                   }
[17:40:57.236]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:57.236]                     cond$call), session = sessionInformation(), 
[17:40:57.236]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:57.236]                   signalCondition(cond)
[17:40:57.236]                 }
[17:40:57.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:57.236]                 "immediateCondition"))) {
[17:40:57.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:57.236]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:57.236]                   if (TRUE && !signal) {
[17:40:57.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.236]                     {
[17:40:57.236]                       inherits <- base::inherits
[17:40:57.236]                       invokeRestart <- base::invokeRestart
[17:40:57.236]                       is.null <- base::is.null
[17:40:57.236]                       muffled <- FALSE
[17:40:57.236]                       if (inherits(cond, "message")) {
[17:40:57.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.236]                         if (muffled) 
[17:40:57.236]                           invokeRestart("muffleMessage")
[17:40:57.236]                       }
[17:40:57.236]                       else if (inherits(cond, "warning")) {
[17:40:57.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.236]                         if (muffled) 
[17:40:57.236]                           invokeRestart("muffleWarning")
[17:40:57.236]                       }
[17:40:57.236]                       else if (inherits(cond, "condition")) {
[17:40:57.236]                         if (!is.null(pattern)) {
[17:40:57.236]                           computeRestarts <- base::computeRestarts
[17:40:57.236]                           grepl <- base::grepl
[17:40:57.236]                           restarts <- computeRestarts(cond)
[17:40:57.236]                           for (restart in restarts) {
[17:40:57.236]                             name <- restart$name
[17:40:57.236]                             if (is.null(name)) 
[17:40:57.236]                               next
[17:40:57.236]                             if (!grepl(pattern, name)) 
[17:40:57.236]                               next
[17:40:57.236]                             invokeRestart(restart)
[17:40:57.236]                             muffled <- TRUE
[17:40:57.236]                             break
[17:40:57.236]                           }
[17:40:57.236]                         }
[17:40:57.236]                       }
[17:40:57.236]                       invisible(muffled)
[17:40:57.236]                     }
[17:40:57.236]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.236]                   }
[17:40:57.236]                 }
[17:40:57.236]                 else {
[17:40:57.236]                   if (TRUE) {
[17:40:57.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.236]                     {
[17:40:57.236]                       inherits <- base::inherits
[17:40:57.236]                       invokeRestart <- base::invokeRestart
[17:40:57.236]                       is.null <- base::is.null
[17:40:57.236]                       muffled <- FALSE
[17:40:57.236]                       if (inherits(cond, "message")) {
[17:40:57.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.236]                         if (muffled) 
[17:40:57.236]                           invokeRestart("muffleMessage")
[17:40:57.236]                       }
[17:40:57.236]                       else if (inherits(cond, "warning")) {
[17:40:57.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.236]                         if (muffled) 
[17:40:57.236]                           invokeRestart("muffleWarning")
[17:40:57.236]                       }
[17:40:57.236]                       else if (inherits(cond, "condition")) {
[17:40:57.236]                         if (!is.null(pattern)) {
[17:40:57.236]                           computeRestarts <- base::computeRestarts
[17:40:57.236]                           grepl <- base::grepl
[17:40:57.236]                           restarts <- computeRestarts(cond)
[17:40:57.236]                           for (restart in restarts) {
[17:40:57.236]                             name <- restart$name
[17:40:57.236]                             if (is.null(name)) 
[17:40:57.236]                               next
[17:40:57.236]                             if (!grepl(pattern, name)) 
[17:40:57.236]                               next
[17:40:57.236]                             invokeRestart(restart)
[17:40:57.236]                             muffled <- TRUE
[17:40:57.236]                             break
[17:40:57.236]                           }
[17:40:57.236]                         }
[17:40:57.236]                       }
[17:40:57.236]                       invisible(muffled)
[17:40:57.236]                     }
[17:40:57.236]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.236]                   }
[17:40:57.236]                 }
[17:40:57.236]             }
[17:40:57.236]         }))
[17:40:57.236]     }, error = function(ex) {
[17:40:57.236]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:57.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.236]                 ...future.rng), started = ...future.startTime, 
[17:40:57.236]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:57.236]             version = "1.8"), class = "FutureResult")
[17:40:57.236]     }, finally = {
[17:40:57.236]         if (!identical(...future.workdir, getwd())) 
[17:40:57.236]             setwd(...future.workdir)
[17:40:57.236]         {
[17:40:57.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:57.236]                 ...future.oldOptions$nwarnings <- NULL
[17:40:57.236]             }
[17:40:57.236]             base::options(...future.oldOptions)
[17:40:57.236]             if (.Platform$OS.type == "windows") {
[17:40:57.236]                 old_names <- names(...future.oldEnvVars)
[17:40:57.236]                 envs <- base::Sys.getenv()
[17:40:57.236]                 names <- names(envs)
[17:40:57.236]                 common <- intersect(names, old_names)
[17:40:57.236]                 added <- setdiff(names, old_names)
[17:40:57.236]                 removed <- setdiff(old_names, names)
[17:40:57.236]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:57.236]                   envs[common]]
[17:40:57.236]                 NAMES <- toupper(changed)
[17:40:57.236]                 args <- list()
[17:40:57.236]                 for (kk in seq_along(NAMES)) {
[17:40:57.236]                   name <- changed[[kk]]
[17:40:57.236]                   NAME <- NAMES[[kk]]
[17:40:57.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.236]                     next
[17:40:57.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.236]                 }
[17:40:57.236]                 NAMES <- toupper(added)
[17:40:57.236]                 for (kk in seq_along(NAMES)) {
[17:40:57.236]                   name <- added[[kk]]
[17:40:57.236]                   NAME <- NAMES[[kk]]
[17:40:57.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.236]                     next
[17:40:57.236]                   args[[name]] <- ""
[17:40:57.236]                 }
[17:40:57.236]                 NAMES <- toupper(removed)
[17:40:57.236]                 for (kk in seq_along(NAMES)) {
[17:40:57.236]                   name <- removed[[kk]]
[17:40:57.236]                   NAME <- NAMES[[kk]]
[17:40:57.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.236]                     next
[17:40:57.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.236]                 }
[17:40:57.236]                 if (length(args) > 0) 
[17:40:57.236]                   base::do.call(base::Sys.setenv, args = args)
[17:40:57.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:57.236]             }
[17:40:57.236]             else {
[17:40:57.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:57.236]             }
[17:40:57.236]             {
[17:40:57.236]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:57.236]                   0L) {
[17:40:57.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:57.236]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:57.236]                   base::options(opts)
[17:40:57.236]                 }
[17:40:57.236]                 {
[17:40:57.236]                   {
[17:40:57.236]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:57.236]                     NULL
[17:40:57.236]                   }
[17:40:57.236]                   options(future.plan = NULL)
[17:40:57.236]                   if (is.na(NA_character_)) 
[17:40:57.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:57.236]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:57.236]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:57.236]                     envir = parent.frame()) 
[17:40:57.236]                   {
[17:40:57.236]                     if (is.function(workers)) 
[17:40:57.236]                       workers <- workers()
[17:40:57.236]                     workers <- structure(as.integer(workers), 
[17:40:57.236]                       class = class(workers))
[17:40:57.236]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:57.236]                       workers >= 1)
[17:40:57.236]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:57.236]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:57.236]                     }
[17:40:57.236]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:57.236]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:57.236]                       envir = envir)
[17:40:57.236]                     if (!future$lazy) 
[17:40:57.236]                       future <- run(future)
[17:40:57.236]                     invisible(future)
[17:40:57.236]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:57.236]                 }
[17:40:57.236]             }
[17:40:57.236]         }
[17:40:57.236]     })
[17:40:57.236]     if (TRUE) {
[17:40:57.236]         base::sink(type = "output", split = FALSE)
[17:40:57.236]         if (TRUE) {
[17:40:57.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:57.236]         }
[17:40:57.236]         else {
[17:40:57.236]             ...future.result["stdout"] <- base::list(NULL)
[17:40:57.236]         }
[17:40:57.236]         base::close(...future.stdout)
[17:40:57.236]         ...future.stdout <- NULL
[17:40:57.236]     }
[17:40:57.236]     ...future.result$conditions <- ...future.conditions
[17:40:57.236]     ...future.result$finished <- base::Sys.time()
[17:40:57.236]     ...future.result
[17:40:57.236] }
[17:40:57.307] MultisessionFuture started
[17:40:57.307] result() for ClusterFuture ...
[17:40:57.308] receiveMessageFromWorker() for ClusterFuture ...
[17:40:57.308] - Validating connection of MultisessionFuture
[17:40:57.340] - received message: FutureResult
[17:40:57.340] - Received FutureResult
[17:40:57.340] - Erased future from FutureRegistry
[17:40:57.340] result() for ClusterFuture ...
[17:40:57.340] - result already collected: FutureResult
[17:40:57.341] result() for ClusterFuture ... done
[17:40:57.341] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:57.341] result() for ClusterFuture ... done
[17:40:57.341] result() for ClusterFuture ...
[17:40:57.341] - result already collected: FutureResult
[17:40:57.341] result() for ClusterFuture ... done
[17:40:57.341] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:57.345] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:40:57.347] future_lapply() ...
[17:40:57.352] Number of chunks: 2
[17:40:57.352] getGlobalsAndPackagesXApply() ...
[17:40:57.352]  - future.globals: TRUE
[17:40:57.352] getGlobalsAndPackages() ...
[17:40:57.352] Searching for globals...
[17:40:57.355] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:57.355] Searching for globals ... DONE
[17:40:57.355] Resolving globals: FALSE
[17:40:57.356] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:40:57.357] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:57.357] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:57.357] - packages: [1] ‘future.apply’
[17:40:57.357] getGlobalsAndPackages() ... DONE
[17:40:57.357]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:57.357]  - needed namespaces: [n=1] ‘future.apply’
[17:40:57.357] Finding globals ... DONE
[17:40:57.357]  - use_args: TRUE
[17:40:57.357]  - Getting '...' globals ...
[17:40:57.358] resolve() on list ...
[17:40:57.358]  recursive: 0
[17:40:57.358]  length: 1
[17:40:57.358]  elements: ‘...’
[17:40:57.358]  length: 0 (resolved future 1)
[17:40:57.358] resolve() on list ... DONE
[17:40:57.359]    - '...' content: [n=0] 
[17:40:57.359] List of 1
[17:40:57.359]  $ ...: list()
[17:40:57.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:57.359]  - attr(*, "where")=List of 1
[17:40:57.359]   ..$ ...:<environment: 0x564f30cb4010> 
[17:40:57.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:57.359]  - attr(*, "resolved")= logi TRUE
[17:40:57.359]  - attr(*, "total_size")= num NA
[17:40:57.362]  - Getting '...' globals ... DONE
[17:40:57.362] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:57.362] List of 8
[17:40:57.362]  $ ...future.FUN:function (x, ...)  
[17:40:57.362]  $ x_FUN        :function (x)  
[17:40:57.362]  $ times        : int 1
[17:40:57.362]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:57.362]  $ stop_if_not  :function (...)  
[17:40:57.362]  $ dim          : NULL
[17:40:57.362]  $ valid_types  : chr "character"
[17:40:57.362]  $ ...          : list()
[17:40:57.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:57.362]  - attr(*, "where")=List of 8
[17:40:57.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:57.362]   ..$ ...          :<environment: 0x564f30cb4010> 
[17:40:57.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:57.362]  - attr(*, "resolved")= logi FALSE
[17:40:57.362]  - attr(*, "total_size")= num 94208
[17:40:57.367] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:57.367] getGlobalsAndPackagesXApply() ... DONE
[17:40:57.368] Number of futures (= number of chunks): 2
[17:40:57.368] Launching 2 futures (chunks) ...
[17:40:57.368] Chunk #1 of 2 ...
[17:40:57.368]  - Finding globals in 'X' for chunk #1 ...
[17:40:57.368] getGlobalsAndPackages() ...
[17:40:57.368] Searching for globals...
[17:40:57.368] 
[17:40:57.368] Searching for globals ... DONE
[17:40:57.369] - globals: [0] <none>
[17:40:57.369] getGlobalsAndPackages() ... DONE
[17:40:57.369]    + additional globals found: [n=0] 
[17:40:57.369]    + additional namespaces needed: [n=0] 
[17:40:57.369]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:57.369]  - seeds: <none>
[17:40:57.369] getGlobalsAndPackages() ...
[17:40:57.369] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:57.369] Resolving globals: FALSE
[17:40:57.369] Tweak future expression to call with '...' arguments ...
[17:40:57.370] {
[17:40:57.370]     do.call(function(...) {
[17:40:57.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:57.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.370]             on.exit(options(oopts), add = TRUE)
[17:40:57.370]         }
[17:40:57.370]         {
[17:40:57.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:57.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.370]                 ...future.FUN(...future.X_jj, ...)
[17:40:57.370]             })
[17:40:57.370]         }
[17:40:57.370]     }, args = future.call.arguments)
[17:40:57.370] }
[17:40:57.370] Tweak future expression to call with '...' arguments ... DONE
[17:40:57.370] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:57.370] - packages: [1] ‘future.apply’
[17:40:57.371] getGlobalsAndPackages() ... DONE
[17:40:57.371] run() for ‘Future’ ...
[17:40:57.371] - state: ‘created’
[17:40:57.371] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:57.387] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:57.387]   - Field: ‘node’
[17:40:57.388]   - Field: ‘label’
[17:40:57.388]   - Field: ‘local’
[17:40:57.388]   - Field: ‘owner’
[17:40:57.388]   - Field: ‘envir’
[17:40:57.388]   - Field: ‘workers’
[17:40:57.388]   - Field: ‘packages’
[17:40:57.388]   - Field: ‘gc’
[17:40:57.388]   - Field: ‘conditions’
[17:40:57.388]   - Field: ‘persistent’
[17:40:57.388]   - Field: ‘expr’
[17:40:57.388]   - Field: ‘uuid’
[17:40:57.389]   - Field: ‘seed’
[17:40:57.389]   - Field: ‘version’
[17:40:57.389]   - Field: ‘result’
[17:40:57.389]   - Field: ‘asynchronous’
[17:40:57.389]   - Field: ‘calls’
[17:40:57.389]   - Field: ‘globals’
[17:40:57.389]   - Field: ‘stdout’
[17:40:57.389]   - Field: ‘earlySignal’
[17:40:57.389]   - Field: ‘lazy’
[17:40:57.389]   - Field: ‘state’
[17:40:57.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:57.390] - Launch lazy future ...
[17:40:57.390] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:57.390] Packages needed by future strategies (n = 0): <none>
[17:40:57.391] {
[17:40:57.391]     {
[17:40:57.391]         {
[17:40:57.391]             ...future.startTime <- base::Sys.time()
[17:40:57.391]             {
[17:40:57.391]                 {
[17:40:57.391]                   {
[17:40:57.391]                     {
[17:40:57.391]                       {
[17:40:57.391]                         base::local({
[17:40:57.391]                           has_future <- base::requireNamespace("future", 
[17:40:57.391]                             quietly = TRUE)
[17:40:57.391]                           if (has_future) {
[17:40:57.391]                             ns <- base::getNamespace("future")
[17:40:57.391]                             version <- ns[[".package"]][["version"]]
[17:40:57.391]                             if (is.null(version)) 
[17:40:57.391]                               version <- utils::packageVersion("future")
[17:40:57.391]                           }
[17:40:57.391]                           else {
[17:40:57.391]                             version <- NULL
[17:40:57.391]                           }
[17:40:57.391]                           if (!has_future || version < "1.8.0") {
[17:40:57.391]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:57.391]                               "", base::R.version$version.string), 
[17:40:57.391]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:57.391]                                 base::R.version$platform, 8 * 
[17:40:57.391]                                   base::.Machine$sizeof.pointer), 
[17:40:57.391]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:57.391]                                 "release", "version")], collapse = " "), 
[17:40:57.391]                               hostname = base::Sys.info()[["nodename"]])
[17:40:57.391]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:57.391]                               info)
[17:40:57.391]                             info <- base::paste(info, collapse = "; ")
[17:40:57.391]                             if (!has_future) {
[17:40:57.391]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:57.391]                                 info)
[17:40:57.391]                             }
[17:40:57.391]                             else {
[17:40:57.391]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:57.391]                                 info, version)
[17:40:57.391]                             }
[17:40:57.391]                             base::stop(msg)
[17:40:57.391]                           }
[17:40:57.391]                         })
[17:40:57.391]                       }
[17:40:57.391]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:57.391]                       base::options(mc.cores = 1L)
[17:40:57.391]                     }
[17:40:57.391]                     base::local({
[17:40:57.391]                       for (pkg in "future.apply") {
[17:40:57.391]                         base::loadNamespace(pkg)
[17:40:57.391]                         base::library(pkg, character.only = TRUE)
[17:40:57.391]                       }
[17:40:57.391]                     })
[17:40:57.391]                   }
[17:40:57.391]                   options(future.plan = NULL)
[17:40:57.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:57.391]                 }
[17:40:57.391]                 ...future.workdir <- getwd()
[17:40:57.391]             }
[17:40:57.391]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:57.391]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:57.391]         }
[17:40:57.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:57.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:57.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:57.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:57.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:57.391]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:57.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:57.391]             base::names(...future.oldOptions))
[17:40:57.391]     }
[17:40:57.391]     if (FALSE) {
[17:40:57.391]     }
[17:40:57.391]     else {
[17:40:57.391]         if (TRUE) {
[17:40:57.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:57.391]                 open = "w")
[17:40:57.391]         }
[17:40:57.391]         else {
[17:40:57.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:57.391]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:57.391]         }
[17:40:57.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:57.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:57.391]             base::sink(type = "output", split = FALSE)
[17:40:57.391]             base::close(...future.stdout)
[17:40:57.391]         }, add = TRUE)
[17:40:57.391]     }
[17:40:57.391]     ...future.frame <- base::sys.nframe()
[17:40:57.391]     ...future.conditions <- base::list()
[17:40:57.391]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:57.391]     if (FALSE) {
[17:40:57.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:57.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:57.391]     }
[17:40:57.391]     ...future.result <- base::tryCatch({
[17:40:57.391]         base::withCallingHandlers({
[17:40:57.391]             ...future.value <- base::withVisible(base::local({
[17:40:57.391]                 ...future.makeSendCondition <- local({
[17:40:57.391]                   sendCondition <- NULL
[17:40:57.391]                   function(frame = 1L) {
[17:40:57.391]                     if (is.function(sendCondition)) 
[17:40:57.391]                       return(sendCondition)
[17:40:57.391]                     ns <- getNamespace("parallel")
[17:40:57.391]                     if (exists("sendData", mode = "function", 
[17:40:57.391]                       envir = ns)) {
[17:40:57.391]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:57.391]                         envir = ns)
[17:40:57.391]                       envir <- sys.frame(frame)
[17:40:57.391]                       master <- NULL
[17:40:57.391]                       while (!identical(envir, .GlobalEnv) && 
[17:40:57.391]                         !identical(envir, emptyenv())) {
[17:40:57.391]                         if (exists("master", mode = "list", envir = envir, 
[17:40:57.391]                           inherits = FALSE)) {
[17:40:57.391]                           master <- get("master", mode = "list", 
[17:40:57.391]                             envir = envir, inherits = FALSE)
[17:40:57.391]                           if (inherits(master, c("SOCKnode", 
[17:40:57.391]                             "SOCK0node"))) {
[17:40:57.391]                             sendCondition <<- function(cond) {
[17:40:57.391]                               data <- list(type = "VALUE", value = cond, 
[17:40:57.391]                                 success = TRUE)
[17:40:57.391]                               parallel_sendData(master, data)
[17:40:57.391]                             }
[17:40:57.391]                             return(sendCondition)
[17:40:57.391]                           }
[17:40:57.391]                         }
[17:40:57.391]                         frame <- frame + 1L
[17:40:57.391]                         envir <- sys.frame(frame)
[17:40:57.391]                       }
[17:40:57.391]                     }
[17:40:57.391]                     sendCondition <<- function(cond) NULL
[17:40:57.391]                   }
[17:40:57.391]                 })
[17:40:57.391]                 withCallingHandlers({
[17:40:57.391]                   {
[17:40:57.391]                     do.call(function(...) {
[17:40:57.391]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.391]                       if (!identical(...future.globals.maxSize.org, 
[17:40:57.391]                         ...future.globals.maxSize)) {
[17:40:57.391]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.391]                         on.exit(options(oopts), add = TRUE)
[17:40:57.391]                       }
[17:40:57.391]                       {
[17:40:57.391]                         lapply(seq_along(...future.elements_ii), 
[17:40:57.391]                           FUN = function(jj) {
[17:40:57.391]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.391]                             ...future.FUN(...future.X_jj, ...)
[17:40:57.391]                           })
[17:40:57.391]                       }
[17:40:57.391]                     }, args = future.call.arguments)
[17:40:57.391]                   }
[17:40:57.391]                 }, immediateCondition = function(cond) {
[17:40:57.391]                   sendCondition <- ...future.makeSendCondition()
[17:40:57.391]                   sendCondition(cond)
[17:40:57.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.391]                   {
[17:40:57.391]                     inherits <- base::inherits
[17:40:57.391]                     invokeRestart <- base::invokeRestart
[17:40:57.391]                     is.null <- base::is.null
[17:40:57.391]                     muffled <- FALSE
[17:40:57.391]                     if (inherits(cond, "message")) {
[17:40:57.391]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:57.391]                       if (muffled) 
[17:40:57.391]                         invokeRestart("muffleMessage")
[17:40:57.391]                     }
[17:40:57.391]                     else if (inherits(cond, "warning")) {
[17:40:57.391]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:57.391]                       if (muffled) 
[17:40:57.391]                         invokeRestart("muffleWarning")
[17:40:57.391]                     }
[17:40:57.391]                     else if (inherits(cond, "condition")) {
[17:40:57.391]                       if (!is.null(pattern)) {
[17:40:57.391]                         computeRestarts <- base::computeRestarts
[17:40:57.391]                         grepl <- base::grepl
[17:40:57.391]                         restarts <- computeRestarts(cond)
[17:40:57.391]                         for (restart in restarts) {
[17:40:57.391]                           name <- restart$name
[17:40:57.391]                           if (is.null(name)) 
[17:40:57.391]                             next
[17:40:57.391]                           if (!grepl(pattern, name)) 
[17:40:57.391]                             next
[17:40:57.391]                           invokeRestart(restart)
[17:40:57.391]                           muffled <- TRUE
[17:40:57.391]                           break
[17:40:57.391]                         }
[17:40:57.391]                       }
[17:40:57.391]                     }
[17:40:57.391]                     invisible(muffled)
[17:40:57.391]                   }
[17:40:57.391]                   muffleCondition(cond)
[17:40:57.391]                 })
[17:40:57.391]             }))
[17:40:57.391]             future::FutureResult(value = ...future.value$value, 
[17:40:57.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.391]                   ...future.rng), globalenv = if (FALSE) 
[17:40:57.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:57.391]                     ...future.globalenv.names))
[17:40:57.391]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:57.391]         }, condition = base::local({
[17:40:57.391]             c <- base::c
[17:40:57.391]             inherits <- base::inherits
[17:40:57.391]             invokeRestart <- base::invokeRestart
[17:40:57.391]             length <- base::length
[17:40:57.391]             list <- base::list
[17:40:57.391]             seq.int <- base::seq.int
[17:40:57.391]             signalCondition <- base::signalCondition
[17:40:57.391]             sys.calls <- base::sys.calls
[17:40:57.391]             `[[` <- base::`[[`
[17:40:57.391]             `+` <- base::`+`
[17:40:57.391]             `<<-` <- base::`<<-`
[17:40:57.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:57.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:57.391]                   3L)]
[17:40:57.391]             }
[17:40:57.391]             function(cond) {
[17:40:57.391]                 is_error <- inherits(cond, "error")
[17:40:57.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:57.391]                   NULL)
[17:40:57.391]                 if (is_error) {
[17:40:57.391]                   sessionInformation <- function() {
[17:40:57.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:57.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:57.391]                       search = base::search(), system = base::Sys.info())
[17:40:57.391]                   }
[17:40:57.391]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:57.391]                     cond$call), session = sessionInformation(), 
[17:40:57.391]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:57.391]                   signalCondition(cond)
[17:40:57.391]                 }
[17:40:57.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:57.391]                 "immediateCondition"))) {
[17:40:57.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:57.391]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:57.391]                   if (TRUE && !signal) {
[17:40:57.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.391]                     {
[17:40:57.391]                       inherits <- base::inherits
[17:40:57.391]                       invokeRestart <- base::invokeRestart
[17:40:57.391]                       is.null <- base::is.null
[17:40:57.391]                       muffled <- FALSE
[17:40:57.391]                       if (inherits(cond, "message")) {
[17:40:57.391]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.391]                         if (muffled) 
[17:40:57.391]                           invokeRestart("muffleMessage")
[17:40:57.391]                       }
[17:40:57.391]                       else if (inherits(cond, "warning")) {
[17:40:57.391]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.391]                         if (muffled) 
[17:40:57.391]                           invokeRestart("muffleWarning")
[17:40:57.391]                       }
[17:40:57.391]                       else if (inherits(cond, "condition")) {
[17:40:57.391]                         if (!is.null(pattern)) {
[17:40:57.391]                           computeRestarts <- base::computeRestarts
[17:40:57.391]                           grepl <- base::grepl
[17:40:57.391]                           restarts <- computeRestarts(cond)
[17:40:57.391]                           for (restart in restarts) {
[17:40:57.391]                             name <- restart$name
[17:40:57.391]                             if (is.null(name)) 
[17:40:57.391]                               next
[17:40:57.391]                             if (!grepl(pattern, name)) 
[17:40:57.391]                               next
[17:40:57.391]                             invokeRestart(restart)
[17:40:57.391]                             muffled <- TRUE
[17:40:57.391]                             break
[17:40:57.391]                           }
[17:40:57.391]                         }
[17:40:57.391]                       }
[17:40:57.391]                       invisible(muffled)
[17:40:57.391]                     }
[17:40:57.391]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.391]                   }
[17:40:57.391]                 }
[17:40:57.391]                 else {
[17:40:57.391]                   if (TRUE) {
[17:40:57.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.391]                     {
[17:40:57.391]                       inherits <- base::inherits
[17:40:57.391]                       invokeRestart <- base::invokeRestart
[17:40:57.391]                       is.null <- base::is.null
[17:40:57.391]                       muffled <- FALSE
[17:40:57.391]                       if (inherits(cond, "message")) {
[17:40:57.391]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.391]                         if (muffled) 
[17:40:57.391]                           invokeRestart("muffleMessage")
[17:40:57.391]                       }
[17:40:57.391]                       else if (inherits(cond, "warning")) {
[17:40:57.391]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.391]                         if (muffled) 
[17:40:57.391]                           invokeRestart("muffleWarning")
[17:40:57.391]                       }
[17:40:57.391]                       else if (inherits(cond, "condition")) {
[17:40:57.391]                         if (!is.null(pattern)) {
[17:40:57.391]                           computeRestarts <- base::computeRestarts
[17:40:57.391]                           grepl <- base::grepl
[17:40:57.391]                           restarts <- computeRestarts(cond)
[17:40:57.391]                           for (restart in restarts) {
[17:40:57.391]                             name <- restart$name
[17:40:57.391]                             if (is.null(name)) 
[17:40:57.391]                               next
[17:40:57.391]                             if (!grepl(pattern, name)) 
[17:40:57.391]                               next
[17:40:57.391]                             invokeRestart(restart)
[17:40:57.391]                             muffled <- TRUE
[17:40:57.391]                             break
[17:40:57.391]                           }
[17:40:57.391]                         }
[17:40:57.391]                       }
[17:40:57.391]                       invisible(muffled)
[17:40:57.391]                     }
[17:40:57.391]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.391]                   }
[17:40:57.391]                 }
[17:40:57.391]             }
[17:40:57.391]         }))
[17:40:57.391]     }, error = function(ex) {
[17:40:57.391]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:57.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.391]                 ...future.rng), started = ...future.startTime, 
[17:40:57.391]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:57.391]             version = "1.8"), class = "FutureResult")
[17:40:57.391]     }, finally = {
[17:40:57.391]         if (!identical(...future.workdir, getwd())) 
[17:40:57.391]             setwd(...future.workdir)
[17:40:57.391]         {
[17:40:57.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:57.391]                 ...future.oldOptions$nwarnings <- NULL
[17:40:57.391]             }
[17:40:57.391]             base::options(...future.oldOptions)
[17:40:57.391]             if (.Platform$OS.type == "windows") {
[17:40:57.391]                 old_names <- names(...future.oldEnvVars)
[17:40:57.391]                 envs <- base::Sys.getenv()
[17:40:57.391]                 names <- names(envs)
[17:40:57.391]                 common <- intersect(names, old_names)
[17:40:57.391]                 added <- setdiff(names, old_names)
[17:40:57.391]                 removed <- setdiff(old_names, names)
[17:40:57.391]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:57.391]                   envs[common]]
[17:40:57.391]                 NAMES <- toupper(changed)
[17:40:57.391]                 args <- list()
[17:40:57.391]                 for (kk in seq_along(NAMES)) {
[17:40:57.391]                   name <- changed[[kk]]
[17:40:57.391]                   NAME <- NAMES[[kk]]
[17:40:57.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.391]                     next
[17:40:57.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.391]                 }
[17:40:57.391]                 NAMES <- toupper(added)
[17:40:57.391]                 for (kk in seq_along(NAMES)) {
[17:40:57.391]                   name <- added[[kk]]
[17:40:57.391]                   NAME <- NAMES[[kk]]
[17:40:57.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.391]                     next
[17:40:57.391]                   args[[name]] <- ""
[17:40:57.391]                 }
[17:40:57.391]                 NAMES <- toupper(removed)
[17:40:57.391]                 for (kk in seq_along(NAMES)) {
[17:40:57.391]                   name <- removed[[kk]]
[17:40:57.391]                   NAME <- NAMES[[kk]]
[17:40:57.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.391]                     next
[17:40:57.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.391]                 }
[17:40:57.391]                 if (length(args) > 0) 
[17:40:57.391]                   base::do.call(base::Sys.setenv, args = args)
[17:40:57.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:57.391]             }
[17:40:57.391]             else {
[17:40:57.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:57.391]             }
[17:40:57.391]             {
[17:40:57.391]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:57.391]                   0L) {
[17:40:57.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:57.391]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:57.391]                   base::options(opts)
[17:40:57.391]                 }
[17:40:57.391]                 {
[17:40:57.391]                   {
[17:40:57.391]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:57.391]                     NULL
[17:40:57.391]                   }
[17:40:57.391]                   options(future.plan = NULL)
[17:40:57.391]                   if (is.na(NA_character_)) 
[17:40:57.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:57.391]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:57.391]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:57.391]                     envir = parent.frame()) 
[17:40:57.391]                   {
[17:40:57.391]                     if (is.function(workers)) 
[17:40:57.391]                       workers <- workers()
[17:40:57.391]                     workers <- structure(as.integer(workers), 
[17:40:57.391]                       class = class(workers))
[17:40:57.391]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:57.391]                       workers >= 1)
[17:40:57.391]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:57.391]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:57.391]                     }
[17:40:57.391]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:57.391]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:57.391]                       envir = envir)
[17:40:57.391]                     if (!future$lazy) 
[17:40:57.391]                       future <- run(future)
[17:40:57.391]                     invisible(future)
[17:40:57.391]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:57.391]                 }
[17:40:57.391]             }
[17:40:57.391]         }
[17:40:57.391]     })
[17:40:57.391]     if (TRUE) {
[17:40:57.391]         base::sink(type = "output", split = FALSE)
[17:40:57.391]         if (TRUE) {
[17:40:57.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:57.391]         }
[17:40:57.391]         else {
[17:40:57.391]             ...future.result["stdout"] <- base::list(NULL)
[17:40:57.391]         }
[17:40:57.391]         base::close(...future.stdout)
[17:40:57.391]         ...future.stdout <- NULL
[17:40:57.391]     }
[17:40:57.391]     ...future.result$conditions <- ...future.conditions
[17:40:57.391]     ...future.result$finished <- base::Sys.time()
[17:40:57.391]     ...future.result
[17:40:57.391] }
[17:40:57.393] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[17:40:57.394] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:40:57.435] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:40:57.435] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:40:57.436] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:40:57.436] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:40:57.437] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:40:57.437] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:40:57.479] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:40:57.479] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:40:57.523] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:40:57.526] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:40:57.526] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:40:57.527] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[17:40:57.527] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[17:40:57.527] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:40:57.528] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:40:57.528] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:40:57.528] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:40:57.528] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:40:57.529] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:40:57.529] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:40:57.529] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:40:57.529] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[17:40:57.530] MultisessionFuture started
[17:40:57.530] - Launch lazy future ... done
[17:40:57.530] run() for ‘MultisessionFuture’ ... done
[17:40:57.531] Created future:
[17:40:57.531] MultisessionFuture:
[17:40:57.531] Label: ‘future_vapply-1’
[17:40:57.531] Expression:
[17:40:57.531] {
[17:40:57.531]     do.call(function(...) {
[17:40:57.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:57.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.531]             on.exit(options(oopts), add = TRUE)
[17:40:57.531]         }
[17:40:57.531]         {
[17:40:57.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:57.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.531]                 ...future.FUN(...future.X_jj, ...)
[17:40:57.531]             })
[17:40:57.531]         }
[17:40:57.531]     }, args = future.call.arguments)
[17:40:57.531] }
[17:40:57.531] Lazy evaluation: FALSE
[17:40:57.531] Asynchronous evaluation: TRUE
[17:40:57.531] Local evaluation: TRUE
[17:40:57.531] Environment: R_GlobalEnv
[17:40:57.531] Capture standard output: TRUE
[17:40:57.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:57.531] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:57.531] Packages: 1 packages (‘future.apply’)
[17:40:57.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:57.531] Resolved: FALSE
[17:40:57.531] Value: <not collected>
[17:40:57.531] Conditions captured: <none>
[17:40:57.531] Early signaling: FALSE
[17:40:57.531] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:57.531] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.543] Chunk #1 of 2 ... DONE
[17:40:57.543] Chunk #2 of 2 ...
[17:40:57.543]  - Finding globals in 'X' for chunk #2 ...
[17:40:57.543] getGlobalsAndPackages() ...
[17:40:57.543] Searching for globals...
[17:40:57.543] 
[17:40:57.544] Searching for globals ... DONE
[17:40:57.544] - globals: [0] <none>
[17:40:57.544] getGlobalsAndPackages() ... DONE
[17:40:57.544]    + additional globals found: [n=0] 
[17:40:57.544]    + additional namespaces needed: [n=0] 
[17:40:57.544]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:57.544]  - seeds: <none>
[17:40:57.544] getGlobalsAndPackages() ...
[17:40:57.544] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:57.544] Resolving globals: FALSE
[17:40:57.545] Tweak future expression to call with '...' arguments ...
[17:40:57.545] {
[17:40:57.545]     do.call(function(...) {
[17:40:57.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:57.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.545]             on.exit(options(oopts), add = TRUE)
[17:40:57.545]         }
[17:40:57.545]         {
[17:40:57.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:57.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.545]                 ...future.FUN(...future.X_jj, ...)
[17:40:57.545]             })
[17:40:57.545]         }
[17:40:57.545]     }, args = future.call.arguments)
[17:40:57.545] }
[17:40:57.545] Tweak future expression to call with '...' arguments ... DONE
[17:40:57.545] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:57.546] - packages: [1] ‘future.apply’
[17:40:57.546] getGlobalsAndPackages() ... DONE
[17:40:57.546] run() for ‘Future’ ...
[17:40:57.546] - state: ‘created’
[17:40:57.546] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:57.561] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:57.561]   - Field: ‘node’
[17:40:57.561]   - Field: ‘label’
[17:40:57.561]   - Field: ‘local’
[17:40:57.561]   - Field: ‘owner’
[17:40:57.562]   - Field: ‘envir’
[17:40:57.562]   - Field: ‘workers’
[17:40:57.562]   - Field: ‘packages’
[17:40:57.562]   - Field: ‘gc’
[17:40:57.562]   - Field: ‘conditions’
[17:40:57.562]   - Field: ‘persistent’
[17:40:57.562]   - Field: ‘expr’
[17:40:57.562]   - Field: ‘uuid’
[17:40:57.562]   - Field: ‘seed’
[17:40:57.562]   - Field: ‘version’
[17:40:57.562]   - Field: ‘result’
[17:40:57.563]   - Field: ‘asynchronous’
[17:40:57.563]   - Field: ‘calls’
[17:40:57.563]   - Field: ‘globals’
[17:40:57.563]   - Field: ‘stdout’
[17:40:57.563]   - Field: ‘earlySignal’
[17:40:57.563]   - Field: ‘lazy’
[17:40:57.563]   - Field: ‘state’
[17:40:57.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:57.563] - Launch lazy future ...
[17:40:57.564] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:57.564] Packages needed by future strategies (n = 0): <none>
[17:40:57.564] {
[17:40:57.564]     {
[17:40:57.564]         {
[17:40:57.564]             ...future.startTime <- base::Sys.time()
[17:40:57.564]             {
[17:40:57.564]                 {
[17:40:57.564]                   {
[17:40:57.564]                     {
[17:40:57.564]                       {
[17:40:57.564]                         base::local({
[17:40:57.564]                           has_future <- base::requireNamespace("future", 
[17:40:57.564]                             quietly = TRUE)
[17:40:57.564]                           if (has_future) {
[17:40:57.564]                             ns <- base::getNamespace("future")
[17:40:57.564]                             version <- ns[[".package"]][["version"]]
[17:40:57.564]                             if (is.null(version)) 
[17:40:57.564]                               version <- utils::packageVersion("future")
[17:40:57.564]                           }
[17:40:57.564]                           else {
[17:40:57.564]                             version <- NULL
[17:40:57.564]                           }
[17:40:57.564]                           if (!has_future || version < "1.8.0") {
[17:40:57.564]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:57.564]                               "", base::R.version$version.string), 
[17:40:57.564]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:57.564]                                 base::R.version$platform, 8 * 
[17:40:57.564]                                   base::.Machine$sizeof.pointer), 
[17:40:57.564]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:57.564]                                 "release", "version")], collapse = " "), 
[17:40:57.564]                               hostname = base::Sys.info()[["nodename"]])
[17:40:57.564]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:57.564]                               info)
[17:40:57.564]                             info <- base::paste(info, collapse = "; ")
[17:40:57.564]                             if (!has_future) {
[17:40:57.564]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:57.564]                                 info)
[17:40:57.564]                             }
[17:40:57.564]                             else {
[17:40:57.564]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:57.564]                                 info, version)
[17:40:57.564]                             }
[17:40:57.564]                             base::stop(msg)
[17:40:57.564]                           }
[17:40:57.564]                         })
[17:40:57.564]                       }
[17:40:57.564]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:57.564]                       base::options(mc.cores = 1L)
[17:40:57.564]                     }
[17:40:57.564]                     base::local({
[17:40:57.564]                       for (pkg in "future.apply") {
[17:40:57.564]                         base::loadNamespace(pkg)
[17:40:57.564]                         base::library(pkg, character.only = TRUE)
[17:40:57.564]                       }
[17:40:57.564]                     })
[17:40:57.564]                   }
[17:40:57.564]                   options(future.plan = NULL)
[17:40:57.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:57.564]                 }
[17:40:57.564]                 ...future.workdir <- getwd()
[17:40:57.564]             }
[17:40:57.564]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:57.564]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:57.564]         }
[17:40:57.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:57.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:57.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:57.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:57.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:57.564]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:57.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:57.564]             base::names(...future.oldOptions))
[17:40:57.564]     }
[17:40:57.564]     if (FALSE) {
[17:40:57.564]     }
[17:40:57.564]     else {
[17:40:57.564]         if (TRUE) {
[17:40:57.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:57.564]                 open = "w")
[17:40:57.564]         }
[17:40:57.564]         else {
[17:40:57.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:57.564]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:57.564]         }
[17:40:57.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:57.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:57.564]             base::sink(type = "output", split = FALSE)
[17:40:57.564]             base::close(...future.stdout)
[17:40:57.564]         }, add = TRUE)
[17:40:57.564]     }
[17:40:57.564]     ...future.frame <- base::sys.nframe()
[17:40:57.564]     ...future.conditions <- base::list()
[17:40:57.564]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:57.564]     if (FALSE) {
[17:40:57.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:57.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:57.564]     }
[17:40:57.564]     ...future.result <- base::tryCatch({
[17:40:57.564]         base::withCallingHandlers({
[17:40:57.564]             ...future.value <- base::withVisible(base::local({
[17:40:57.564]                 ...future.makeSendCondition <- local({
[17:40:57.564]                   sendCondition <- NULL
[17:40:57.564]                   function(frame = 1L) {
[17:40:57.564]                     if (is.function(sendCondition)) 
[17:40:57.564]                       return(sendCondition)
[17:40:57.564]                     ns <- getNamespace("parallel")
[17:40:57.564]                     if (exists("sendData", mode = "function", 
[17:40:57.564]                       envir = ns)) {
[17:40:57.564]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:57.564]                         envir = ns)
[17:40:57.564]                       envir <- sys.frame(frame)
[17:40:57.564]                       master <- NULL
[17:40:57.564]                       while (!identical(envir, .GlobalEnv) && 
[17:40:57.564]                         !identical(envir, emptyenv())) {
[17:40:57.564]                         if (exists("master", mode = "list", envir = envir, 
[17:40:57.564]                           inherits = FALSE)) {
[17:40:57.564]                           master <- get("master", mode = "list", 
[17:40:57.564]                             envir = envir, inherits = FALSE)
[17:40:57.564]                           if (inherits(master, c("SOCKnode", 
[17:40:57.564]                             "SOCK0node"))) {
[17:40:57.564]                             sendCondition <<- function(cond) {
[17:40:57.564]                               data <- list(type = "VALUE", value = cond, 
[17:40:57.564]                                 success = TRUE)
[17:40:57.564]                               parallel_sendData(master, data)
[17:40:57.564]                             }
[17:40:57.564]                             return(sendCondition)
[17:40:57.564]                           }
[17:40:57.564]                         }
[17:40:57.564]                         frame <- frame + 1L
[17:40:57.564]                         envir <- sys.frame(frame)
[17:40:57.564]                       }
[17:40:57.564]                     }
[17:40:57.564]                     sendCondition <<- function(cond) NULL
[17:40:57.564]                   }
[17:40:57.564]                 })
[17:40:57.564]                 withCallingHandlers({
[17:40:57.564]                   {
[17:40:57.564]                     do.call(function(...) {
[17:40:57.564]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.564]                       if (!identical(...future.globals.maxSize.org, 
[17:40:57.564]                         ...future.globals.maxSize)) {
[17:40:57.564]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.564]                         on.exit(options(oopts), add = TRUE)
[17:40:57.564]                       }
[17:40:57.564]                       {
[17:40:57.564]                         lapply(seq_along(...future.elements_ii), 
[17:40:57.564]                           FUN = function(jj) {
[17:40:57.564]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.564]                             ...future.FUN(...future.X_jj, ...)
[17:40:57.564]                           })
[17:40:57.564]                       }
[17:40:57.564]                     }, args = future.call.arguments)
[17:40:57.564]                   }
[17:40:57.564]                 }, immediateCondition = function(cond) {
[17:40:57.564]                   sendCondition <- ...future.makeSendCondition()
[17:40:57.564]                   sendCondition(cond)
[17:40:57.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.564]                   {
[17:40:57.564]                     inherits <- base::inherits
[17:40:57.564]                     invokeRestart <- base::invokeRestart
[17:40:57.564]                     is.null <- base::is.null
[17:40:57.564]                     muffled <- FALSE
[17:40:57.564]                     if (inherits(cond, "message")) {
[17:40:57.564]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:57.564]                       if (muffled) 
[17:40:57.564]                         invokeRestart("muffleMessage")
[17:40:57.564]                     }
[17:40:57.564]                     else if (inherits(cond, "warning")) {
[17:40:57.564]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:57.564]                       if (muffled) 
[17:40:57.564]                         invokeRestart("muffleWarning")
[17:40:57.564]                     }
[17:40:57.564]                     else if (inherits(cond, "condition")) {
[17:40:57.564]                       if (!is.null(pattern)) {
[17:40:57.564]                         computeRestarts <- base::computeRestarts
[17:40:57.564]                         grepl <- base::grepl
[17:40:57.564]                         restarts <- computeRestarts(cond)
[17:40:57.564]                         for (restart in restarts) {
[17:40:57.564]                           name <- restart$name
[17:40:57.564]                           if (is.null(name)) 
[17:40:57.564]                             next
[17:40:57.564]                           if (!grepl(pattern, name)) 
[17:40:57.564]                             next
[17:40:57.564]                           invokeRestart(restart)
[17:40:57.564]                           muffled <- TRUE
[17:40:57.564]                           break
[17:40:57.564]                         }
[17:40:57.564]                       }
[17:40:57.564]                     }
[17:40:57.564]                     invisible(muffled)
[17:40:57.564]                   }
[17:40:57.564]                   muffleCondition(cond)
[17:40:57.564]                 })
[17:40:57.564]             }))
[17:40:57.564]             future::FutureResult(value = ...future.value$value, 
[17:40:57.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.564]                   ...future.rng), globalenv = if (FALSE) 
[17:40:57.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:57.564]                     ...future.globalenv.names))
[17:40:57.564]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:57.564]         }, condition = base::local({
[17:40:57.564]             c <- base::c
[17:40:57.564]             inherits <- base::inherits
[17:40:57.564]             invokeRestart <- base::invokeRestart
[17:40:57.564]             length <- base::length
[17:40:57.564]             list <- base::list
[17:40:57.564]             seq.int <- base::seq.int
[17:40:57.564]             signalCondition <- base::signalCondition
[17:40:57.564]             sys.calls <- base::sys.calls
[17:40:57.564]             `[[` <- base::`[[`
[17:40:57.564]             `+` <- base::`+`
[17:40:57.564]             `<<-` <- base::`<<-`
[17:40:57.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:57.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:57.564]                   3L)]
[17:40:57.564]             }
[17:40:57.564]             function(cond) {
[17:40:57.564]                 is_error <- inherits(cond, "error")
[17:40:57.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:57.564]                   NULL)
[17:40:57.564]                 if (is_error) {
[17:40:57.564]                   sessionInformation <- function() {
[17:40:57.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:57.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:57.564]                       search = base::search(), system = base::Sys.info())
[17:40:57.564]                   }
[17:40:57.564]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:57.564]                     cond$call), session = sessionInformation(), 
[17:40:57.564]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:57.564]                   signalCondition(cond)
[17:40:57.564]                 }
[17:40:57.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:57.564]                 "immediateCondition"))) {
[17:40:57.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:57.564]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:57.564]                   if (TRUE && !signal) {
[17:40:57.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.564]                     {
[17:40:57.564]                       inherits <- base::inherits
[17:40:57.564]                       invokeRestart <- base::invokeRestart
[17:40:57.564]                       is.null <- base::is.null
[17:40:57.564]                       muffled <- FALSE
[17:40:57.564]                       if (inherits(cond, "message")) {
[17:40:57.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.564]                         if (muffled) 
[17:40:57.564]                           invokeRestart("muffleMessage")
[17:40:57.564]                       }
[17:40:57.564]                       else if (inherits(cond, "warning")) {
[17:40:57.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.564]                         if (muffled) 
[17:40:57.564]                           invokeRestart("muffleWarning")
[17:40:57.564]                       }
[17:40:57.564]                       else if (inherits(cond, "condition")) {
[17:40:57.564]                         if (!is.null(pattern)) {
[17:40:57.564]                           computeRestarts <- base::computeRestarts
[17:40:57.564]                           grepl <- base::grepl
[17:40:57.564]                           restarts <- computeRestarts(cond)
[17:40:57.564]                           for (restart in restarts) {
[17:40:57.564]                             name <- restart$name
[17:40:57.564]                             if (is.null(name)) 
[17:40:57.564]                               next
[17:40:57.564]                             if (!grepl(pattern, name)) 
[17:40:57.564]                               next
[17:40:57.564]                             invokeRestart(restart)
[17:40:57.564]                             muffled <- TRUE
[17:40:57.564]                             break
[17:40:57.564]                           }
[17:40:57.564]                         }
[17:40:57.564]                       }
[17:40:57.564]                       invisible(muffled)
[17:40:57.564]                     }
[17:40:57.564]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.564]                   }
[17:40:57.564]                 }
[17:40:57.564]                 else {
[17:40:57.564]                   if (TRUE) {
[17:40:57.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.564]                     {
[17:40:57.564]                       inherits <- base::inherits
[17:40:57.564]                       invokeRestart <- base::invokeRestart
[17:40:57.564]                       is.null <- base::is.null
[17:40:57.564]                       muffled <- FALSE
[17:40:57.564]                       if (inherits(cond, "message")) {
[17:40:57.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.564]                         if (muffled) 
[17:40:57.564]                           invokeRestart("muffleMessage")
[17:40:57.564]                       }
[17:40:57.564]                       else if (inherits(cond, "warning")) {
[17:40:57.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.564]                         if (muffled) 
[17:40:57.564]                           invokeRestart("muffleWarning")
[17:40:57.564]                       }
[17:40:57.564]                       else if (inherits(cond, "condition")) {
[17:40:57.564]                         if (!is.null(pattern)) {
[17:40:57.564]                           computeRestarts <- base::computeRestarts
[17:40:57.564]                           grepl <- base::grepl
[17:40:57.564]                           restarts <- computeRestarts(cond)
[17:40:57.564]                           for (restart in restarts) {
[17:40:57.564]                             name <- restart$name
[17:40:57.564]                             if (is.null(name)) 
[17:40:57.564]                               next
[17:40:57.564]                             if (!grepl(pattern, name)) 
[17:40:57.564]                               next
[17:40:57.564]                             invokeRestart(restart)
[17:40:57.564]                             muffled <- TRUE
[17:40:57.564]                             break
[17:40:57.564]                           }
[17:40:57.564]                         }
[17:40:57.564]                       }
[17:40:57.564]                       invisible(muffled)
[17:40:57.564]                     }
[17:40:57.564]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.564]                   }
[17:40:57.564]                 }
[17:40:57.564]             }
[17:40:57.564]         }))
[17:40:57.564]     }, error = function(ex) {
[17:40:57.564]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:57.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.564]                 ...future.rng), started = ...future.startTime, 
[17:40:57.564]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:57.564]             version = "1.8"), class = "FutureResult")
[17:40:57.564]     }, finally = {
[17:40:57.564]         if (!identical(...future.workdir, getwd())) 
[17:40:57.564]             setwd(...future.workdir)
[17:40:57.564]         {
[17:40:57.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:57.564]                 ...future.oldOptions$nwarnings <- NULL
[17:40:57.564]             }
[17:40:57.564]             base::options(...future.oldOptions)
[17:40:57.564]             if (.Platform$OS.type == "windows") {
[17:40:57.564]                 old_names <- names(...future.oldEnvVars)
[17:40:57.564]                 envs <- base::Sys.getenv()
[17:40:57.564]                 names <- names(envs)
[17:40:57.564]                 common <- intersect(names, old_names)
[17:40:57.564]                 added <- setdiff(names, old_names)
[17:40:57.564]                 removed <- setdiff(old_names, names)
[17:40:57.564]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:57.564]                   envs[common]]
[17:40:57.564]                 NAMES <- toupper(changed)
[17:40:57.564]                 args <- list()
[17:40:57.564]                 for (kk in seq_along(NAMES)) {
[17:40:57.564]                   name <- changed[[kk]]
[17:40:57.564]                   NAME <- NAMES[[kk]]
[17:40:57.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.564]                     next
[17:40:57.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.564]                 }
[17:40:57.564]                 NAMES <- toupper(added)
[17:40:57.564]                 for (kk in seq_along(NAMES)) {
[17:40:57.564]                   name <- added[[kk]]
[17:40:57.564]                   NAME <- NAMES[[kk]]
[17:40:57.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.564]                     next
[17:40:57.564]                   args[[name]] <- ""
[17:40:57.564]                 }
[17:40:57.564]                 NAMES <- toupper(removed)
[17:40:57.564]                 for (kk in seq_along(NAMES)) {
[17:40:57.564]                   name <- removed[[kk]]
[17:40:57.564]                   NAME <- NAMES[[kk]]
[17:40:57.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.564]                     next
[17:40:57.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.564]                 }
[17:40:57.564]                 if (length(args) > 0) 
[17:40:57.564]                   base::do.call(base::Sys.setenv, args = args)
[17:40:57.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:57.564]             }
[17:40:57.564]             else {
[17:40:57.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:57.564]             }
[17:40:57.564]             {
[17:40:57.564]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:57.564]                   0L) {
[17:40:57.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:57.564]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:57.564]                   base::options(opts)
[17:40:57.564]                 }
[17:40:57.564]                 {
[17:40:57.564]                   {
[17:40:57.564]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:57.564]                     NULL
[17:40:57.564]                   }
[17:40:57.564]                   options(future.plan = NULL)
[17:40:57.564]                   if (is.na(NA_character_)) 
[17:40:57.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:57.564]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:57.564]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:57.564]                     envir = parent.frame()) 
[17:40:57.564]                   {
[17:40:57.564]                     if (is.function(workers)) 
[17:40:57.564]                       workers <- workers()
[17:40:57.564]                     workers <- structure(as.integer(workers), 
[17:40:57.564]                       class = class(workers))
[17:40:57.564]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:57.564]                       workers >= 1)
[17:40:57.564]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:57.564]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:57.564]                     }
[17:40:57.564]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:57.564]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:57.564]                       envir = envir)
[17:40:57.564]                     if (!future$lazy) 
[17:40:57.564]                       future <- run(future)
[17:40:57.564]                     invisible(future)
[17:40:57.564]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:57.564]                 }
[17:40:57.564]             }
[17:40:57.564]         }
[17:40:57.564]     })
[17:40:57.564]     if (TRUE) {
[17:40:57.564]         base::sink(type = "output", split = FALSE)
[17:40:57.564]         if (TRUE) {
[17:40:57.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:57.564]         }
[17:40:57.564]         else {
[17:40:57.564]             ...future.result["stdout"] <- base::list(NULL)
[17:40:57.564]         }
[17:40:57.564]         base::close(...future.stdout)
[17:40:57.564]         ...future.stdout <- NULL
[17:40:57.564]     }
[17:40:57.564]     ...future.result$conditions <- ...future.conditions
[17:40:57.564]     ...future.result$finished <- base::Sys.time()
[17:40:57.564]     ...future.result
[17:40:57.564] }
[17:40:57.635] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[17:40:57.635] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:40:57.640] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:40:57.640] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:40:57.640] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:40:57.640] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:40:57.641] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:40:57.641] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:40:57.683] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:40:57.683] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:40:57.727] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:40:57.727] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:40:57.728] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:40:57.728] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[17:40:57.728] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[17:40:57.728] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:40:57.729] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:40:57.729] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[17:40:57.729] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[17:40:57.729] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:40:57.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:40:57.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:40:57.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:40:57.730] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[17:40:57.731] MultisessionFuture started
[17:40:57.731] - Launch lazy future ... done
[17:40:57.731] run() for ‘MultisessionFuture’ ... done
[17:40:57.731] Created future:
[17:40:57.731] MultisessionFuture:
[17:40:57.731] Label: ‘future_vapply-2’
[17:40:57.731] Expression:
[17:40:57.731] {
[17:40:57.731]     do.call(function(...) {
[17:40:57.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:57.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.731]             on.exit(options(oopts), add = TRUE)
[17:40:57.731]         }
[17:40:57.731]         {
[17:40:57.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:57.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.731]                 ...future.FUN(...future.X_jj, ...)
[17:40:57.731]             })
[17:40:57.731]         }
[17:40:57.731]     }, args = future.call.arguments)
[17:40:57.731] }
[17:40:57.731] Lazy evaluation: FALSE
[17:40:57.731] Asynchronous evaluation: TRUE
[17:40:57.731] Local evaluation: TRUE
[17:40:57.731] Environment: R_GlobalEnv
[17:40:57.731] Capture standard output: TRUE
[17:40:57.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:57.731] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:57.731] Packages: 1 packages (‘future.apply’)
[17:40:57.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:57.731] Resolved: FALSE
[17:40:57.731] Value: <not collected>
[17:40:57.731] Conditions captured: <none>
[17:40:57.731] Early signaling: FALSE
[17:40:57.731] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:57.731] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.743] Chunk #2 of 2 ... DONE
[17:40:57.743] Launching 2 futures (chunks) ... DONE
[17:40:57.743] Resolving 2 futures (chunks) ...
[17:40:57.743] resolve() on list ...
[17:40:57.743]  recursive: 0
[17:40:57.744]  length: 2
[17:40:57.744] 
[17:40:57.744] receiveMessageFromWorker() for ClusterFuture ...
[17:40:57.744] - Validating connection of MultisessionFuture
[17:40:57.744] - received message: FutureResult
[17:40:57.745] - Received FutureResult
[17:40:57.745] - Erased future from FutureRegistry
[17:40:57.745] result() for ClusterFuture ...
[17:40:57.745] - result already collected: FutureResult
[17:40:57.745] result() for ClusterFuture ... done
[17:40:57.745] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:57.745] Future #1
[17:40:57.745] result() for ClusterFuture ...
[17:40:57.745] - result already collected: FutureResult
[17:40:57.745] result() for ClusterFuture ... done
[17:40:57.745] result() for ClusterFuture ...
[17:40:57.745] - result already collected: FutureResult
[17:40:57.746] result() for ClusterFuture ... done
[17:40:57.746] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:40:57.746] - nx: 2
[17:40:57.746] - relay: TRUE
[17:40:57.746] - stdout: TRUE
[17:40:57.746] - signal: TRUE
[17:40:57.746] - resignal: FALSE
[17:40:57.746] - force: TRUE
[17:40:57.746] - relayed: [n=2] FALSE, FALSE
[17:40:57.746] - queued futures: [n=2] FALSE, FALSE
[17:40:57.746]  - until=1
[17:40:57.747]  - relaying element #1
[17:40:57.747] result() for ClusterFuture ...
[17:40:57.747] - result already collected: FutureResult
[17:40:57.747] result() for ClusterFuture ... done
[17:40:57.747] result() for ClusterFuture ...
[17:40:57.747] - result already collected: FutureResult
[17:40:57.747] result() for ClusterFuture ... done
[17:40:57.747] result() for ClusterFuture ...
[17:40:57.747] - result already collected: FutureResult
[17:40:57.747] result() for ClusterFuture ... done
[17:40:57.747] result() for ClusterFuture ...
[17:40:57.748] - result already collected: FutureResult
[17:40:57.748] result() for ClusterFuture ... done
[17:40:57.748] - relayed: [n=2] TRUE, FALSE
[17:40:57.748] - queued futures: [n=2] TRUE, FALSE
[17:40:57.748] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:40:57.748]  length: 1 (resolved future 1)
[17:40:57.810] receiveMessageFromWorker() for ClusterFuture ...
[17:40:57.811] - Validating connection of MultisessionFuture
[17:40:57.811] - received message: FutureResult
[17:40:57.811] - Received FutureResult
[17:40:57.811] - Erased future from FutureRegistry
[17:40:57.811] result() for ClusterFuture ...
[17:40:57.811] - result already collected: FutureResult
[17:40:57.811] result() for ClusterFuture ... done
[17:40:57.812] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:57.812] Future #2
[17:40:57.812] result() for ClusterFuture ...
[17:40:57.812] - result already collected: FutureResult
[17:40:57.812] result() for ClusterFuture ... done
[17:40:57.812] result() for ClusterFuture ...
[17:40:57.812] - result already collected: FutureResult
[17:40:57.812] result() for ClusterFuture ... done
[17:40:57.812] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:40:57.812] - nx: 2
[17:40:57.812] - relay: TRUE
[17:40:57.813] - stdout: TRUE
[17:40:57.813] - signal: TRUE
[17:40:57.813] - resignal: FALSE
[17:40:57.813] - force: TRUE
[17:40:57.813] - relayed: [n=2] TRUE, FALSE
[17:40:57.813] - queued futures: [n=2] TRUE, FALSE
[17:40:57.813]  - until=2
[17:40:57.813]  - relaying element #2
[17:40:57.813] result() for ClusterFuture ...
[17:40:57.813] - result already collected: FutureResult
[17:40:57.813] result() for ClusterFuture ... done
[17:40:57.813] result() for ClusterFuture ...
[17:40:57.814] - result already collected: FutureResult
[17:40:57.814] result() for ClusterFuture ... done
[17:40:57.814] result() for ClusterFuture ...
[17:40:57.814] - result already collected: FutureResult
[17:40:57.814] result() for ClusterFuture ... done
[17:40:57.814] result() for ClusterFuture ...
[17:40:57.814] - result already collected: FutureResult
[17:40:57.814] result() for ClusterFuture ... done
[17:40:57.814] - relayed: [n=2] TRUE, TRUE
[17:40:57.814] - queued futures: [n=2] TRUE, TRUE
[17:40:57.814] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:40:57.815]  length: 0 (resolved future 2)
[17:40:57.815] Relaying remaining futures
[17:40:57.815] signalConditionsASAP(NULL, pos=0) ...
[17:40:57.815] - nx: 2
[17:40:57.815] - relay: TRUE
[17:40:57.815] - stdout: TRUE
[17:40:57.815] - signal: TRUE
[17:40:57.815] - resignal: FALSE
[17:40:57.815] - force: TRUE
[17:40:57.815] - relayed: [n=2] TRUE, TRUE
[17:40:57.815] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:57.816] - relayed: [n=2] TRUE, TRUE
[17:40:57.816] - queued futures: [n=2] TRUE, TRUE
[17:40:57.816] signalConditionsASAP(NULL, pos=0) ... done
[17:40:57.816] resolve() on list ... DONE
[17:40:57.816] result() for ClusterFuture ...
[17:40:57.816] - result already collected: FutureResult
[17:40:57.816] result() for ClusterFuture ... done
[17:40:57.816] result() for ClusterFuture ...
[17:40:57.816] - result already collected: FutureResult
[17:40:57.816] result() for ClusterFuture ... done
[17:40:57.816] result() for ClusterFuture ...
[17:40:57.817] - result already collected: FutureResult
[17:40:57.817] result() for ClusterFuture ... done
[17:40:57.817] result() for ClusterFuture ...
[17:40:57.817] - result already collected: FutureResult
[17:40:57.817] result() for ClusterFuture ... done
[17:40:57.817]  - Number of value chunks collected: 2
[17:40:57.817] Resolving 2 futures (chunks) ... DONE
[17:40:57.817] Reducing values from 2 chunks ...
[17:40:57.817]  - Number of values collected after concatenation: 2
[17:40:57.817]  - Number of values expected: 2
[17:40:57.817] Reducing values from 2 chunks ... DONE
[17:40:57.818] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:40:57.819] future_lapply() ...
[17:40:57.824] Number of chunks: 2
[17:40:57.824] getGlobalsAndPackagesXApply() ...
[17:40:57.824]  - future.globals: TRUE
[17:40:57.824] getGlobalsAndPackages() ...
[17:40:57.824] Searching for globals...
[17:40:57.828] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:40:57.828] Searching for globals ... DONE
[17:40:57.828] Resolving globals: FALSE
[17:40:57.829] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:40:57.829] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:57.829] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:57.829] - packages: [1] ‘future.apply’
[17:40:57.829] getGlobalsAndPackages() ... DONE
[17:40:57.830]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:57.830]  - needed namespaces: [n=1] ‘future.apply’
[17:40:57.830] Finding globals ... DONE
[17:40:57.830]  - use_args: TRUE
[17:40:57.830]  - Getting '...' globals ...
[17:40:57.830] resolve() on list ...
[17:40:57.830]  recursive: 0
[17:40:57.830]  length: 1
[17:40:57.830]  elements: ‘...’
[17:40:57.831]  length: 0 (resolved future 1)
[17:40:57.831] resolve() on list ... DONE
[17:40:57.831]    - '...' content: [n=0] 
[17:40:57.831] List of 1
[17:40:57.831]  $ ...: list()
[17:40:57.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:57.831]  - attr(*, "where")=List of 1
[17:40:57.831]   ..$ ...:<environment: 0x564f310b54b0> 
[17:40:57.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:57.831]  - attr(*, "resolved")= logi TRUE
[17:40:57.831]  - attr(*, "total_size")= num NA
[17:40:57.833]  - Getting '...' globals ... DONE
[17:40:57.834] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:57.834] List of 8
[17:40:57.834]  $ ...future.FUN:function (x, ...)  
[17:40:57.834]  $ x_FUN        :function (x)  
[17:40:57.834]  $ times        : int 0
[17:40:57.834]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:57.834]  $ stop_if_not  :function (...)  
[17:40:57.834]  $ dim          : NULL
[17:40:57.834]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:57.834]  $ ...          : list()
[17:40:57.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:57.834]  - attr(*, "where")=List of 8
[17:40:57.834]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:57.834]   ..$ ...          :<environment: 0x564f310b54b0> 
[17:40:57.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:57.834]  - attr(*, "resolved")= logi FALSE
[17:40:57.834]  - attr(*, "total_size")= num 95472
[17:40:57.839] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:57.839] getGlobalsAndPackagesXApply() ... DONE
[17:40:57.839] Number of futures (= number of chunks): 2
[17:40:57.839] Launching 2 futures (chunks) ...
[17:40:57.839] Chunk #1 of 2 ...
[17:40:57.840]  - Finding globals in 'X' for chunk #1 ...
[17:40:57.840] getGlobalsAndPackages() ...
[17:40:57.840] Searching for globals...
[17:40:57.840] 
[17:40:57.840] Searching for globals ... DONE
[17:40:57.840] - globals: [0] <none>
[17:40:57.840] getGlobalsAndPackages() ... DONE
[17:40:57.840]    + additional globals found: [n=0] 
[17:40:57.840]    + additional namespaces needed: [n=0] 
[17:40:57.841]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:57.841]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:57.841]  - seeds: <none>
[17:40:57.841] getGlobalsAndPackages() ...
[17:40:57.841] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:57.841] Resolving globals: FALSE
[17:40:57.841] Tweak future expression to call with '...' arguments ...
[17:40:57.841] {
[17:40:57.841]     do.call(function(...) {
[17:40:57.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:57.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.841]             on.exit(options(oopts), add = TRUE)
[17:40:57.841]         }
[17:40:57.841]         {
[17:40:57.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:57.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.841]                 ...future.FUN(...future.X_jj, ...)
[17:40:57.841]             })
[17:40:57.841]         }
[17:40:57.841]     }, args = future.call.arguments)
[17:40:57.841] }
[17:40:57.842] Tweak future expression to call with '...' arguments ... DONE
[17:40:57.842] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:57.842] - packages: [1] ‘future.apply’
[17:40:57.842] getGlobalsAndPackages() ... DONE
[17:40:57.843] run() for ‘Future’ ...
[17:40:57.843] - state: ‘created’
[17:40:57.843] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:57.857] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:57.857]   - Field: ‘node’
[17:40:57.857]   - Field: ‘label’
[17:40:57.857]   - Field: ‘local’
[17:40:57.858]   - Field: ‘owner’
[17:40:57.858]   - Field: ‘envir’
[17:40:57.858]   - Field: ‘workers’
[17:40:57.858]   - Field: ‘packages’
[17:40:57.858]   - Field: ‘gc’
[17:40:57.858]   - Field: ‘conditions’
[17:40:57.858]   - Field: ‘persistent’
[17:40:57.858]   - Field: ‘expr’
[17:40:57.858]   - Field: ‘uuid’
[17:40:57.858]   - Field: ‘seed’
[17:40:57.858]   - Field: ‘version’
[17:40:57.859]   - Field: ‘result’
[17:40:57.859]   - Field: ‘asynchronous’
[17:40:57.859]   - Field: ‘calls’
[17:40:57.859]   - Field: ‘globals’
[17:40:57.859]   - Field: ‘stdout’
[17:40:57.859]   - Field: ‘earlySignal’
[17:40:57.859]   - Field: ‘lazy’
[17:40:57.859]   - Field: ‘state’
[17:40:57.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:57.859] - Launch lazy future ...
[17:40:57.860] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:57.860] Packages needed by future strategies (n = 0): <none>
[17:40:57.860] {
[17:40:57.860]     {
[17:40:57.860]         {
[17:40:57.860]             ...future.startTime <- base::Sys.time()
[17:40:57.860]             {
[17:40:57.860]                 {
[17:40:57.860]                   {
[17:40:57.860]                     {
[17:40:57.860]                       {
[17:40:57.860]                         base::local({
[17:40:57.860]                           has_future <- base::requireNamespace("future", 
[17:40:57.860]                             quietly = TRUE)
[17:40:57.860]                           if (has_future) {
[17:40:57.860]                             ns <- base::getNamespace("future")
[17:40:57.860]                             version <- ns[[".package"]][["version"]]
[17:40:57.860]                             if (is.null(version)) 
[17:40:57.860]                               version <- utils::packageVersion("future")
[17:40:57.860]                           }
[17:40:57.860]                           else {
[17:40:57.860]                             version <- NULL
[17:40:57.860]                           }
[17:40:57.860]                           if (!has_future || version < "1.8.0") {
[17:40:57.860]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:57.860]                               "", base::R.version$version.string), 
[17:40:57.860]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:57.860]                                 base::R.version$platform, 8 * 
[17:40:57.860]                                   base::.Machine$sizeof.pointer), 
[17:40:57.860]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:57.860]                                 "release", "version")], collapse = " "), 
[17:40:57.860]                               hostname = base::Sys.info()[["nodename"]])
[17:40:57.860]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:57.860]                               info)
[17:40:57.860]                             info <- base::paste(info, collapse = "; ")
[17:40:57.860]                             if (!has_future) {
[17:40:57.860]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:57.860]                                 info)
[17:40:57.860]                             }
[17:40:57.860]                             else {
[17:40:57.860]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:57.860]                                 info, version)
[17:40:57.860]                             }
[17:40:57.860]                             base::stop(msg)
[17:40:57.860]                           }
[17:40:57.860]                         })
[17:40:57.860]                       }
[17:40:57.860]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:57.860]                       base::options(mc.cores = 1L)
[17:40:57.860]                     }
[17:40:57.860]                     base::local({
[17:40:57.860]                       for (pkg in "future.apply") {
[17:40:57.860]                         base::loadNamespace(pkg)
[17:40:57.860]                         base::library(pkg, character.only = TRUE)
[17:40:57.860]                       }
[17:40:57.860]                     })
[17:40:57.860]                   }
[17:40:57.860]                   options(future.plan = NULL)
[17:40:57.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:57.860]                 }
[17:40:57.860]                 ...future.workdir <- getwd()
[17:40:57.860]             }
[17:40:57.860]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:57.860]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:57.860]         }
[17:40:57.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:57.860]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:57.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:57.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:57.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:57.860]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:57.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:57.860]             base::names(...future.oldOptions))
[17:40:57.860]     }
[17:40:57.860]     if (FALSE) {
[17:40:57.860]     }
[17:40:57.860]     else {
[17:40:57.860]         if (TRUE) {
[17:40:57.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:57.860]                 open = "w")
[17:40:57.860]         }
[17:40:57.860]         else {
[17:40:57.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:57.860]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:57.860]         }
[17:40:57.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:57.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:57.860]             base::sink(type = "output", split = FALSE)
[17:40:57.860]             base::close(...future.stdout)
[17:40:57.860]         }, add = TRUE)
[17:40:57.860]     }
[17:40:57.860]     ...future.frame <- base::sys.nframe()
[17:40:57.860]     ...future.conditions <- base::list()
[17:40:57.860]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:57.860]     if (FALSE) {
[17:40:57.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:57.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:57.860]     }
[17:40:57.860]     ...future.result <- base::tryCatch({
[17:40:57.860]         base::withCallingHandlers({
[17:40:57.860]             ...future.value <- base::withVisible(base::local({
[17:40:57.860]                 ...future.makeSendCondition <- local({
[17:40:57.860]                   sendCondition <- NULL
[17:40:57.860]                   function(frame = 1L) {
[17:40:57.860]                     if (is.function(sendCondition)) 
[17:40:57.860]                       return(sendCondition)
[17:40:57.860]                     ns <- getNamespace("parallel")
[17:40:57.860]                     if (exists("sendData", mode = "function", 
[17:40:57.860]                       envir = ns)) {
[17:40:57.860]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:57.860]                         envir = ns)
[17:40:57.860]                       envir <- sys.frame(frame)
[17:40:57.860]                       master <- NULL
[17:40:57.860]                       while (!identical(envir, .GlobalEnv) && 
[17:40:57.860]                         !identical(envir, emptyenv())) {
[17:40:57.860]                         if (exists("master", mode = "list", envir = envir, 
[17:40:57.860]                           inherits = FALSE)) {
[17:40:57.860]                           master <- get("master", mode = "list", 
[17:40:57.860]                             envir = envir, inherits = FALSE)
[17:40:57.860]                           if (inherits(master, c("SOCKnode", 
[17:40:57.860]                             "SOCK0node"))) {
[17:40:57.860]                             sendCondition <<- function(cond) {
[17:40:57.860]                               data <- list(type = "VALUE", value = cond, 
[17:40:57.860]                                 success = TRUE)
[17:40:57.860]                               parallel_sendData(master, data)
[17:40:57.860]                             }
[17:40:57.860]                             return(sendCondition)
[17:40:57.860]                           }
[17:40:57.860]                         }
[17:40:57.860]                         frame <- frame + 1L
[17:40:57.860]                         envir <- sys.frame(frame)
[17:40:57.860]                       }
[17:40:57.860]                     }
[17:40:57.860]                     sendCondition <<- function(cond) NULL
[17:40:57.860]                   }
[17:40:57.860]                 })
[17:40:57.860]                 withCallingHandlers({
[17:40:57.860]                   {
[17:40:57.860]                     do.call(function(...) {
[17:40:57.860]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:57.860]                       if (!identical(...future.globals.maxSize.org, 
[17:40:57.860]                         ...future.globals.maxSize)) {
[17:40:57.860]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:57.860]                         on.exit(options(oopts), add = TRUE)
[17:40:57.860]                       }
[17:40:57.860]                       {
[17:40:57.860]                         lapply(seq_along(...future.elements_ii), 
[17:40:57.860]                           FUN = function(jj) {
[17:40:57.860]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:57.860]                             ...future.FUN(...future.X_jj, ...)
[17:40:57.860]                           })
[17:40:57.860]                       }
[17:40:57.860]                     }, args = future.call.arguments)
[17:40:57.860]                   }
[17:40:57.860]                 }, immediateCondition = function(cond) {
[17:40:57.860]                   sendCondition <- ...future.makeSendCondition()
[17:40:57.860]                   sendCondition(cond)
[17:40:57.860]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.860]                   {
[17:40:57.860]                     inherits <- base::inherits
[17:40:57.860]                     invokeRestart <- base::invokeRestart
[17:40:57.860]                     is.null <- base::is.null
[17:40:57.860]                     muffled <- FALSE
[17:40:57.860]                     if (inherits(cond, "message")) {
[17:40:57.860]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:57.860]                       if (muffled) 
[17:40:57.860]                         invokeRestart("muffleMessage")
[17:40:57.860]                     }
[17:40:57.860]                     else if (inherits(cond, "warning")) {
[17:40:57.860]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:57.860]                       if (muffled) 
[17:40:57.860]                         invokeRestart("muffleWarning")
[17:40:57.860]                     }
[17:40:57.860]                     else if (inherits(cond, "condition")) {
[17:40:57.860]                       if (!is.null(pattern)) {
[17:40:57.860]                         computeRestarts <- base::computeRestarts
[17:40:57.860]                         grepl <- base::grepl
[17:40:57.860]                         restarts <- computeRestarts(cond)
[17:40:57.860]                         for (restart in restarts) {
[17:40:57.860]                           name <- restart$name
[17:40:57.860]                           if (is.null(name)) 
[17:40:57.860]                             next
[17:40:57.860]                           if (!grepl(pattern, name)) 
[17:40:57.860]                             next
[17:40:57.860]                           invokeRestart(restart)
[17:40:57.860]                           muffled <- TRUE
[17:40:57.860]                           break
[17:40:57.860]                         }
[17:40:57.860]                       }
[17:40:57.860]                     }
[17:40:57.860]                     invisible(muffled)
[17:40:57.860]                   }
[17:40:57.860]                   muffleCondition(cond)
[17:40:57.860]                 })
[17:40:57.860]             }))
[17:40:57.860]             future::FutureResult(value = ...future.value$value, 
[17:40:57.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.860]                   ...future.rng), globalenv = if (FALSE) 
[17:40:57.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:57.860]                     ...future.globalenv.names))
[17:40:57.860]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:57.860]         }, condition = base::local({
[17:40:57.860]             c <- base::c
[17:40:57.860]             inherits <- base::inherits
[17:40:57.860]             invokeRestart <- base::invokeRestart
[17:40:57.860]             length <- base::length
[17:40:57.860]             list <- base::list
[17:40:57.860]             seq.int <- base::seq.int
[17:40:57.860]             signalCondition <- base::signalCondition
[17:40:57.860]             sys.calls <- base::sys.calls
[17:40:57.860]             `[[` <- base::`[[`
[17:40:57.860]             `+` <- base::`+`
[17:40:57.860]             `<<-` <- base::`<<-`
[17:40:57.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:57.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:57.860]                   3L)]
[17:40:57.860]             }
[17:40:57.860]             function(cond) {
[17:40:57.860]                 is_error <- inherits(cond, "error")
[17:40:57.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:57.860]                   NULL)
[17:40:57.860]                 if (is_error) {
[17:40:57.860]                   sessionInformation <- function() {
[17:40:57.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:57.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:57.860]                       search = base::search(), system = base::Sys.info())
[17:40:57.860]                   }
[17:40:57.860]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:57.860]                     cond$call), session = sessionInformation(), 
[17:40:57.860]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:57.860]                   signalCondition(cond)
[17:40:57.860]                 }
[17:40:57.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:57.860]                 "immediateCondition"))) {
[17:40:57.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:57.860]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:57.860]                   if (TRUE && !signal) {
[17:40:57.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.860]                     {
[17:40:57.860]                       inherits <- base::inherits
[17:40:57.860]                       invokeRestart <- base::invokeRestart
[17:40:57.860]                       is.null <- base::is.null
[17:40:57.860]                       muffled <- FALSE
[17:40:57.860]                       if (inherits(cond, "message")) {
[17:40:57.860]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.860]                         if (muffled) 
[17:40:57.860]                           invokeRestart("muffleMessage")
[17:40:57.860]                       }
[17:40:57.860]                       else if (inherits(cond, "warning")) {
[17:40:57.860]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.860]                         if (muffled) 
[17:40:57.860]                           invokeRestart("muffleWarning")
[17:40:57.860]                       }
[17:40:57.860]                       else if (inherits(cond, "condition")) {
[17:40:57.860]                         if (!is.null(pattern)) {
[17:40:57.860]                           computeRestarts <- base::computeRestarts
[17:40:57.860]                           grepl <- base::grepl
[17:40:57.860]                           restarts <- computeRestarts(cond)
[17:40:57.860]                           for (restart in restarts) {
[17:40:57.860]                             name <- restart$name
[17:40:57.860]                             if (is.null(name)) 
[17:40:57.860]                               next
[17:40:57.860]                             if (!grepl(pattern, name)) 
[17:40:57.860]                               next
[17:40:57.860]                             invokeRestart(restart)
[17:40:57.860]                             muffled <- TRUE
[17:40:57.860]                             break
[17:40:57.860]                           }
[17:40:57.860]                         }
[17:40:57.860]                       }
[17:40:57.860]                       invisible(muffled)
[17:40:57.860]                     }
[17:40:57.860]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.860]                   }
[17:40:57.860]                 }
[17:40:57.860]                 else {
[17:40:57.860]                   if (TRUE) {
[17:40:57.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.860]                     {
[17:40:57.860]                       inherits <- base::inherits
[17:40:57.860]                       invokeRestart <- base::invokeRestart
[17:40:57.860]                       is.null <- base::is.null
[17:40:57.860]                       muffled <- FALSE
[17:40:57.860]                       if (inherits(cond, "message")) {
[17:40:57.860]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.860]                         if (muffled) 
[17:40:57.860]                           invokeRestart("muffleMessage")
[17:40:57.860]                       }
[17:40:57.860]                       else if (inherits(cond, "warning")) {
[17:40:57.860]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.860]                         if (muffled) 
[17:40:57.860]                           invokeRestart("muffleWarning")
[17:40:57.860]                       }
[17:40:57.860]                       else if (inherits(cond, "condition")) {
[17:40:57.860]                         if (!is.null(pattern)) {
[17:40:57.860]                           computeRestarts <- base::computeRestarts
[17:40:57.860]                           grepl <- base::grepl
[17:40:57.860]                           restarts <- computeRestarts(cond)
[17:40:57.860]                           for (restart in restarts) {
[17:40:57.860]                             name <- restart$name
[17:40:57.860]                             if (is.null(name)) 
[17:40:57.860]                               next
[17:40:57.860]                             if (!grepl(pattern, name)) 
[17:40:57.860]                               next
[17:40:57.860]                             invokeRestart(restart)
[17:40:57.860]                             muffled <- TRUE
[17:40:57.860]                             break
[17:40:57.860]                           }
[17:40:57.860]                         }
[17:40:57.860]                       }
[17:40:57.860]                       invisible(muffled)
[17:40:57.860]                     }
[17:40:57.860]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.860]                   }
[17:40:57.860]                 }
[17:40:57.860]             }
[17:40:57.860]         }))
[17:40:57.860]     }, error = function(ex) {
[17:40:57.860]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:57.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.860]                 ...future.rng), started = ...future.startTime, 
[17:40:57.860]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:57.860]             version = "1.8"), class = "FutureResult")
[17:40:57.860]     }, finally = {
[17:40:57.860]         if (!identical(...future.workdir, getwd())) 
[17:40:57.860]             setwd(...future.workdir)
[17:40:57.860]         {
[17:40:57.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:57.860]                 ...future.oldOptions$nwarnings <- NULL
[17:40:57.860]             }
[17:40:57.860]             base::options(...future.oldOptions)
[17:40:57.860]             if (.Platform$OS.type == "windows") {
[17:40:57.860]                 old_names <- names(...future.oldEnvVars)
[17:40:57.860]                 envs <- base::Sys.getenv()
[17:40:57.860]                 names <- names(envs)
[17:40:57.860]                 common <- intersect(names, old_names)
[17:40:57.860]                 added <- setdiff(names, old_names)
[17:40:57.860]                 removed <- setdiff(old_names, names)
[17:40:57.860]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:57.860]                   envs[common]]
[17:40:57.860]                 NAMES <- toupper(changed)
[17:40:57.860]                 args <- list()
[17:40:57.860]                 for (kk in seq_along(NAMES)) {
[17:40:57.860]                   name <- changed[[kk]]
[17:40:57.860]                   NAME <- NAMES[[kk]]
[17:40:57.860]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.860]                     next
[17:40:57.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.860]                 }
[17:40:57.860]                 NAMES <- toupper(added)
[17:40:57.860]                 for (kk in seq_along(NAMES)) {
[17:40:57.860]                   name <- added[[kk]]
[17:40:57.860]                   NAME <- NAMES[[kk]]
[17:40:57.860]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.860]                     next
[17:40:57.860]                   args[[name]] <- ""
[17:40:57.860]                 }
[17:40:57.860]                 NAMES <- toupper(removed)
[17:40:57.860]                 for (kk in seq_along(NAMES)) {
[17:40:57.860]                   name <- removed[[kk]]
[17:40:57.860]                   NAME <- NAMES[[kk]]
[17:40:57.860]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.860]                     next
[17:40:57.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.860]                 }
[17:40:57.860]                 if (length(args) > 0) 
[17:40:57.860]                   base::do.call(base::Sys.setenv, args = args)
[17:40:57.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:57.860]             }
[17:40:57.860]             else {
[17:40:57.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:57.860]             }
[17:40:57.860]             {
[17:40:57.860]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:57.860]                   0L) {
[17:40:57.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:57.860]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:57.860]                   base::options(opts)
[17:40:57.860]                 }
[17:40:57.860]                 {
[17:40:57.860]                   {
[17:40:57.860]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:57.860]                     NULL
[17:40:57.860]                   }
[17:40:57.860]                   options(future.plan = NULL)
[17:40:57.860]                   if (is.na(NA_character_)) 
[17:40:57.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:57.860]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:57.860]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:57.860]                     envir = parent.frame()) 
[17:40:57.860]                   {
[17:40:57.860]                     if (is.function(workers)) 
[17:40:57.860]                       workers <- workers()
[17:40:57.860]                     workers <- structure(as.integer(workers), 
[17:40:57.860]                       class = class(workers))
[17:40:57.860]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:57.860]                       workers >= 1)
[17:40:57.860]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:57.860]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:57.860]                     }
[17:40:57.860]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:57.860]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:57.860]                       envir = envir)
[17:40:57.860]                     if (!future$lazy) 
[17:40:57.860]                       future <- run(future)
[17:40:57.860]                     invisible(future)
[17:40:57.860]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:57.860]                 }
[17:40:57.860]             }
[17:40:57.860]         }
[17:40:57.860]     })
[17:40:57.860]     if (TRUE) {
[17:40:57.860]         base::sink(type = "output", split = FALSE)
[17:40:57.860]         if (TRUE) {
[17:40:57.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:57.860]         }
[17:40:57.860]         else {
[17:40:57.860]             ...future.result["stdout"] <- base::list(NULL)
[17:40:57.860]         }
[17:40:57.860]         base::close(...future.stdout)
[17:40:57.860]         ...future.stdout <- NULL
[17:40:57.860]     }
[17:40:57.860]     ...future.result$conditions <- ...future.conditions
[17:40:57.860]     ...future.result$finished <- base::Sys.time()
[17:40:57.860]     ...future.result
[17:40:57.860] }
[17:40:57.863] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[17:40:57.863] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:40:57.907] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:40:57.907] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:40:57.908] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:40:57.908] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:40:57.908] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:40:57.908] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:40:57.951] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:40:57.951] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:40:57.995] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:40:57.995] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:40:57.996] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:40:57.996] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:40:57.999] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:40:58.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:40:58.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.000] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:40:58.001] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:40:58.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:40:58.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.001] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:40:58.002] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.002] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[17:40:58.003] MultisessionFuture started
[17:40:58.003] - Launch lazy future ... done
[17:40:58.003] run() for ‘MultisessionFuture’ ... done
[17:40:58.003] Created future:
[17:40:58.003] MultisessionFuture:
[17:40:58.003] Label: ‘future_vapply-1’
[17:40:58.003] Expression:
[17:40:58.003] {
[17:40:58.003]     do.call(function(...) {
[17:40:58.003]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.003]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.003]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.003]             on.exit(options(oopts), add = TRUE)
[17:40:58.003]         }
[17:40:58.003]         {
[17:40:58.003]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.003]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.003]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.003]             })
[17:40:58.003]         }
[17:40:58.003]     }, args = future.call.arguments)
[17:40:58.003] }
[17:40:58.003] Lazy evaluation: FALSE
[17:40:58.003] Asynchronous evaluation: TRUE
[17:40:58.003] Local evaluation: TRUE
[17:40:58.003] Environment: R_GlobalEnv
[17:40:58.003] Capture standard output: TRUE
[17:40:58.003] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:58.003] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:58.003] Packages: 1 packages (‘future.apply’)
[17:40:58.003] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:58.003] Resolved: FALSE
[17:40:58.003] Value: <not collected>
[17:40:58.003] Conditions captured: <none>
[17:40:58.003] Early signaling: FALSE
[17:40:58.003] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:58.003] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.015] Chunk #1 of 2 ... DONE
[17:40:58.015] Chunk #2 of 2 ...
[17:40:58.015]  - Finding globals in 'X' for chunk #2 ...
[17:40:58.015] getGlobalsAndPackages() ...
[17:40:58.015] Searching for globals...
[17:40:58.016] 
[17:40:58.016] Searching for globals ... DONE
[17:40:58.016] - globals: [0] <none>
[17:40:58.016] getGlobalsAndPackages() ... DONE
[17:40:58.016]    + additional globals found: [n=0] 
[17:40:58.016]    + additional namespaces needed: [n=0] 
[17:40:58.016]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:58.016]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:58.016]  - seeds: <none>
[17:40:58.017] getGlobalsAndPackages() ...
[17:40:58.017] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.017] Resolving globals: FALSE
[17:40:58.017] Tweak future expression to call with '...' arguments ...
[17:40:58.017] {
[17:40:58.017]     do.call(function(...) {
[17:40:58.017]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.017]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.017]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.017]             on.exit(options(oopts), add = TRUE)
[17:40:58.017]         }
[17:40:58.017]         {
[17:40:58.017]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.017]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.017]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.017]             })
[17:40:58.017]         }
[17:40:58.017]     }, args = future.call.arguments)
[17:40:58.017] }
[17:40:58.017] Tweak future expression to call with '...' arguments ... DONE
[17:40:58.018] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.018] - packages: [1] ‘future.apply’
[17:40:58.018] getGlobalsAndPackages() ... DONE
[17:40:58.018] run() for ‘Future’ ...
[17:40:58.018] - state: ‘created’
[17:40:58.019] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.033] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.033]   - Field: ‘node’
[17:40:58.034]   - Field: ‘label’
[17:40:58.034]   - Field: ‘local’
[17:40:58.034]   - Field: ‘owner’
[17:40:58.034]   - Field: ‘envir’
[17:40:58.034]   - Field: ‘workers’
[17:40:58.034]   - Field: ‘packages’
[17:40:58.034]   - Field: ‘gc’
[17:40:58.034]   - Field: ‘conditions’
[17:40:58.034]   - Field: ‘persistent’
[17:40:58.034]   - Field: ‘expr’
[17:40:58.034]   - Field: ‘uuid’
[17:40:58.035]   - Field: ‘seed’
[17:40:58.035]   - Field: ‘version’
[17:40:58.035]   - Field: ‘result’
[17:40:58.035]   - Field: ‘asynchronous’
[17:40:58.035]   - Field: ‘calls’
[17:40:58.035]   - Field: ‘globals’
[17:40:58.035]   - Field: ‘stdout’
[17:40:58.035]   - Field: ‘earlySignal’
[17:40:58.035]   - Field: ‘lazy’
[17:40:58.035]   - Field: ‘state’
[17:40:58.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.036] - Launch lazy future ...
[17:40:58.036] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:58.036] Packages needed by future strategies (n = 0): <none>
[17:40:58.037] {
[17:40:58.037]     {
[17:40:58.037]         {
[17:40:58.037]             ...future.startTime <- base::Sys.time()
[17:40:58.037]             {
[17:40:58.037]                 {
[17:40:58.037]                   {
[17:40:58.037]                     {
[17:40:58.037]                       {
[17:40:58.037]                         base::local({
[17:40:58.037]                           has_future <- base::requireNamespace("future", 
[17:40:58.037]                             quietly = TRUE)
[17:40:58.037]                           if (has_future) {
[17:40:58.037]                             ns <- base::getNamespace("future")
[17:40:58.037]                             version <- ns[[".package"]][["version"]]
[17:40:58.037]                             if (is.null(version)) 
[17:40:58.037]                               version <- utils::packageVersion("future")
[17:40:58.037]                           }
[17:40:58.037]                           else {
[17:40:58.037]                             version <- NULL
[17:40:58.037]                           }
[17:40:58.037]                           if (!has_future || version < "1.8.0") {
[17:40:58.037]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.037]                               "", base::R.version$version.string), 
[17:40:58.037]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:58.037]                                 base::R.version$platform, 8 * 
[17:40:58.037]                                   base::.Machine$sizeof.pointer), 
[17:40:58.037]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.037]                                 "release", "version")], collapse = " "), 
[17:40:58.037]                               hostname = base::Sys.info()[["nodename"]])
[17:40:58.037]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.037]                               info)
[17:40:58.037]                             info <- base::paste(info, collapse = "; ")
[17:40:58.037]                             if (!has_future) {
[17:40:58.037]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.037]                                 info)
[17:40:58.037]                             }
[17:40:58.037]                             else {
[17:40:58.037]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.037]                                 info, version)
[17:40:58.037]                             }
[17:40:58.037]                             base::stop(msg)
[17:40:58.037]                           }
[17:40:58.037]                         })
[17:40:58.037]                       }
[17:40:58.037]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.037]                       base::options(mc.cores = 1L)
[17:40:58.037]                     }
[17:40:58.037]                     base::local({
[17:40:58.037]                       for (pkg in "future.apply") {
[17:40:58.037]                         base::loadNamespace(pkg)
[17:40:58.037]                         base::library(pkg, character.only = TRUE)
[17:40:58.037]                       }
[17:40:58.037]                     })
[17:40:58.037]                   }
[17:40:58.037]                   options(future.plan = NULL)
[17:40:58.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.037]                 }
[17:40:58.037]                 ...future.workdir <- getwd()
[17:40:58.037]             }
[17:40:58.037]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.037]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.037]         }
[17:40:58.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.037]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:58.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.037]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.037]             base::names(...future.oldOptions))
[17:40:58.037]     }
[17:40:58.037]     if (FALSE) {
[17:40:58.037]     }
[17:40:58.037]     else {
[17:40:58.037]         if (TRUE) {
[17:40:58.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.037]                 open = "w")
[17:40:58.037]         }
[17:40:58.037]         else {
[17:40:58.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.037]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.037]         }
[17:40:58.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.037]             base::sink(type = "output", split = FALSE)
[17:40:58.037]             base::close(...future.stdout)
[17:40:58.037]         }, add = TRUE)
[17:40:58.037]     }
[17:40:58.037]     ...future.frame <- base::sys.nframe()
[17:40:58.037]     ...future.conditions <- base::list()
[17:40:58.037]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.037]     if (FALSE) {
[17:40:58.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.037]     }
[17:40:58.037]     ...future.result <- base::tryCatch({
[17:40:58.037]         base::withCallingHandlers({
[17:40:58.037]             ...future.value <- base::withVisible(base::local({
[17:40:58.037]                 ...future.makeSendCondition <- local({
[17:40:58.037]                   sendCondition <- NULL
[17:40:58.037]                   function(frame = 1L) {
[17:40:58.037]                     if (is.function(sendCondition)) 
[17:40:58.037]                       return(sendCondition)
[17:40:58.037]                     ns <- getNamespace("parallel")
[17:40:58.037]                     if (exists("sendData", mode = "function", 
[17:40:58.037]                       envir = ns)) {
[17:40:58.037]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.037]                         envir = ns)
[17:40:58.037]                       envir <- sys.frame(frame)
[17:40:58.037]                       master <- NULL
[17:40:58.037]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.037]                         !identical(envir, emptyenv())) {
[17:40:58.037]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.037]                           inherits = FALSE)) {
[17:40:58.037]                           master <- get("master", mode = "list", 
[17:40:58.037]                             envir = envir, inherits = FALSE)
[17:40:58.037]                           if (inherits(master, c("SOCKnode", 
[17:40:58.037]                             "SOCK0node"))) {
[17:40:58.037]                             sendCondition <<- function(cond) {
[17:40:58.037]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.037]                                 success = TRUE)
[17:40:58.037]                               parallel_sendData(master, data)
[17:40:58.037]                             }
[17:40:58.037]                             return(sendCondition)
[17:40:58.037]                           }
[17:40:58.037]                         }
[17:40:58.037]                         frame <- frame + 1L
[17:40:58.037]                         envir <- sys.frame(frame)
[17:40:58.037]                       }
[17:40:58.037]                     }
[17:40:58.037]                     sendCondition <<- function(cond) NULL
[17:40:58.037]                   }
[17:40:58.037]                 })
[17:40:58.037]                 withCallingHandlers({
[17:40:58.037]                   {
[17:40:58.037]                     do.call(function(...) {
[17:40:58.037]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.037]                       if (!identical(...future.globals.maxSize.org, 
[17:40:58.037]                         ...future.globals.maxSize)) {
[17:40:58.037]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.037]                         on.exit(options(oopts), add = TRUE)
[17:40:58.037]                       }
[17:40:58.037]                       {
[17:40:58.037]                         lapply(seq_along(...future.elements_ii), 
[17:40:58.037]                           FUN = function(jj) {
[17:40:58.037]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.037]                             ...future.FUN(...future.X_jj, ...)
[17:40:58.037]                           })
[17:40:58.037]                       }
[17:40:58.037]                     }, args = future.call.arguments)
[17:40:58.037]                   }
[17:40:58.037]                 }, immediateCondition = function(cond) {
[17:40:58.037]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.037]                   sendCondition(cond)
[17:40:58.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.037]                   {
[17:40:58.037]                     inherits <- base::inherits
[17:40:58.037]                     invokeRestart <- base::invokeRestart
[17:40:58.037]                     is.null <- base::is.null
[17:40:58.037]                     muffled <- FALSE
[17:40:58.037]                     if (inherits(cond, "message")) {
[17:40:58.037]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.037]                       if (muffled) 
[17:40:58.037]                         invokeRestart("muffleMessage")
[17:40:58.037]                     }
[17:40:58.037]                     else if (inherits(cond, "warning")) {
[17:40:58.037]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.037]                       if (muffled) 
[17:40:58.037]                         invokeRestart("muffleWarning")
[17:40:58.037]                     }
[17:40:58.037]                     else if (inherits(cond, "condition")) {
[17:40:58.037]                       if (!is.null(pattern)) {
[17:40:58.037]                         computeRestarts <- base::computeRestarts
[17:40:58.037]                         grepl <- base::grepl
[17:40:58.037]                         restarts <- computeRestarts(cond)
[17:40:58.037]                         for (restart in restarts) {
[17:40:58.037]                           name <- restart$name
[17:40:58.037]                           if (is.null(name)) 
[17:40:58.037]                             next
[17:40:58.037]                           if (!grepl(pattern, name)) 
[17:40:58.037]                             next
[17:40:58.037]                           invokeRestart(restart)
[17:40:58.037]                           muffled <- TRUE
[17:40:58.037]                           break
[17:40:58.037]                         }
[17:40:58.037]                       }
[17:40:58.037]                     }
[17:40:58.037]                     invisible(muffled)
[17:40:58.037]                   }
[17:40:58.037]                   muffleCondition(cond)
[17:40:58.037]                 })
[17:40:58.037]             }))
[17:40:58.037]             future::FutureResult(value = ...future.value$value, 
[17:40:58.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.037]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.037]                     ...future.globalenv.names))
[17:40:58.037]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.037]         }, condition = base::local({
[17:40:58.037]             c <- base::c
[17:40:58.037]             inherits <- base::inherits
[17:40:58.037]             invokeRestart <- base::invokeRestart
[17:40:58.037]             length <- base::length
[17:40:58.037]             list <- base::list
[17:40:58.037]             seq.int <- base::seq.int
[17:40:58.037]             signalCondition <- base::signalCondition
[17:40:58.037]             sys.calls <- base::sys.calls
[17:40:58.037]             `[[` <- base::`[[`
[17:40:58.037]             `+` <- base::`+`
[17:40:58.037]             `<<-` <- base::`<<-`
[17:40:58.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.037]                   3L)]
[17:40:58.037]             }
[17:40:58.037]             function(cond) {
[17:40:58.037]                 is_error <- inherits(cond, "error")
[17:40:58.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.037]                   NULL)
[17:40:58.037]                 if (is_error) {
[17:40:58.037]                   sessionInformation <- function() {
[17:40:58.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.037]                       search = base::search(), system = base::Sys.info())
[17:40:58.037]                   }
[17:40:58.037]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.037]                     cond$call), session = sessionInformation(), 
[17:40:58.037]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.037]                   signalCondition(cond)
[17:40:58.037]                 }
[17:40:58.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.037]                 "immediateCondition"))) {
[17:40:58.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.037]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.037]                   if (TRUE && !signal) {
[17:40:58.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.037]                     {
[17:40:58.037]                       inherits <- base::inherits
[17:40:58.037]                       invokeRestart <- base::invokeRestart
[17:40:58.037]                       is.null <- base::is.null
[17:40:58.037]                       muffled <- FALSE
[17:40:58.037]                       if (inherits(cond, "message")) {
[17:40:58.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.037]                         if (muffled) 
[17:40:58.037]                           invokeRestart("muffleMessage")
[17:40:58.037]                       }
[17:40:58.037]                       else if (inherits(cond, "warning")) {
[17:40:58.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.037]                         if (muffled) 
[17:40:58.037]                           invokeRestart("muffleWarning")
[17:40:58.037]                       }
[17:40:58.037]                       else if (inherits(cond, "condition")) {
[17:40:58.037]                         if (!is.null(pattern)) {
[17:40:58.037]                           computeRestarts <- base::computeRestarts
[17:40:58.037]                           grepl <- base::grepl
[17:40:58.037]                           restarts <- computeRestarts(cond)
[17:40:58.037]                           for (restart in restarts) {
[17:40:58.037]                             name <- restart$name
[17:40:58.037]                             if (is.null(name)) 
[17:40:58.037]                               next
[17:40:58.037]                             if (!grepl(pattern, name)) 
[17:40:58.037]                               next
[17:40:58.037]                             invokeRestart(restart)
[17:40:58.037]                             muffled <- TRUE
[17:40:58.037]                             break
[17:40:58.037]                           }
[17:40:58.037]                         }
[17:40:58.037]                       }
[17:40:58.037]                       invisible(muffled)
[17:40:58.037]                     }
[17:40:58.037]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.037]                   }
[17:40:58.037]                 }
[17:40:58.037]                 else {
[17:40:58.037]                   if (TRUE) {
[17:40:58.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.037]                     {
[17:40:58.037]                       inherits <- base::inherits
[17:40:58.037]                       invokeRestart <- base::invokeRestart
[17:40:58.037]                       is.null <- base::is.null
[17:40:58.037]                       muffled <- FALSE
[17:40:58.037]                       if (inherits(cond, "message")) {
[17:40:58.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.037]                         if (muffled) 
[17:40:58.037]                           invokeRestart("muffleMessage")
[17:40:58.037]                       }
[17:40:58.037]                       else if (inherits(cond, "warning")) {
[17:40:58.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.037]                         if (muffled) 
[17:40:58.037]                           invokeRestart("muffleWarning")
[17:40:58.037]                       }
[17:40:58.037]                       else if (inherits(cond, "condition")) {
[17:40:58.037]                         if (!is.null(pattern)) {
[17:40:58.037]                           computeRestarts <- base::computeRestarts
[17:40:58.037]                           grepl <- base::grepl
[17:40:58.037]                           restarts <- computeRestarts(cond)
[17:40:58.037]                           for (restart in restarts) {
[17:40:58.037]                             name <- restart$name
[17:40:58.037]                             if (is.null(name)) 
[17:40:58.037]                               next
[17:40:58.037]                             if (!grepl(pattern, name)) 
[17:40:58.037]                               next
[17:40:58.037]                             invokeRestart(restart)
[17:40:58.037]                             muffled <- TRUE
[17:40:58.037]                             break
[17:40:58.037]                           }
[17:40:58.037]                         }
[17:40:58.037]                       }
[17:40:58.037]                       invisible(muffled)
[17:40:58.037]                     }
[17:40:58.037]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.037]                   }
[17:40:58.037]                 }
[17:40:58.037]             }
[17:40:58.037]         }))
[17:40:58.037]     }, error = function(ex) {
[17:40:58.037]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.037]                 ...future.rng), started = ...future.startTime, 
[17:40:58.037]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.037]             version = "1.8"), class = "FutureResult")
[17:40:58.037]     }, finally = {
[17:40:58.037]         if (!identical(...future.workdir, getwd())) 
[17:40:58.037]             setwd(...future.workdir)
[17:40:58.037]         {
[17:40:58.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.037]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.037]             }
[17:40:58.037]             base::options(...future.oldOptions)
[17:40:58.037]             if (.Platform$OS.type == "windows") {
[17:40:58.037]                 old_names <- names(...future.oldEnvVars)
[17:40:58.037]                 envs <- base::Sys.getenv()
[17:40:58.037]                 names <- names(envs)
[17:40:58.037]                 common <- intersect(names, old_names)
[17:40:58.037]                 added <- setdiff(names, old_names)
[17:40:58.037]                 removed <- setdiff(old_names, names)
[17:40:58.037]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.037]                   envs[common]]
[17:40:58.037]                 NAMES <- toupper(changed)
[17:40:58.037]                 args <- list()
[17:40:58.037]                 for (kk in seq_along(NAMES)) {
[17:40:58.037]                   name <- changed[[kk]]
[17:40:58.037]                   NAME <- NAMES[[kk]]
[17:40:58.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.037]                     next
[17:40:58.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.037]                 }
[17:40:58.037]                 NAMES <- toupper(added)
[17:40:58.037]                 for (kk in seq_along(NAMES)) {
[17:40:58.037]                   name <- added[[kk]]
[17:40:58.037]                   NAME <- NAMES[[kk]]
[17:40:58.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.037]                     next
[17:40:58.037]                   args[[name]] <- ""
[17:40:58.037]                 }
[17:40:58.037]                 NAMES <- toupper(removed)
[17:40:58.037]                 for (kk in seq_along(NAMES)) {
[17:40:58.037]                   name <- removed[[kk]]
[17:40:58.037]                   NAME <- NAMES[[kk]]
[17:40:58.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.037]                     next
[17:40:58.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.037]                 }
[17:40:58.037]                 if (length(args) > 0) 
[17:40:58.037]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.037]             }
[17:40:58.037]             else {
[17:40:58.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.037]             }
[17:40:58.037]             {
[17:40:58.037]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.037]                   0L) {
[17:40:58.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.037]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.037]                   base::options(opts)
[17:40:58.037]                 }
[17:40:58.037]                 {
[17:40:58.037]                   {
[17:40:58.037]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.037]                     NULL
[17:40:58.037]                   }
[17:40:58.037]                   options(future.plan = NULL)
[17:40:58.037]                   if (is.na(NA_character_)) 
[17:40:58.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.037]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:58.037]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:58.037]                     envir = parent.frame()) 
[17:40:58.037]                   {
[17:40:58.037]                     if (is.function(workers)) 
[17:40:58.037]                       workers <- workers()
[17:40:58.037]                     workers <- structure(as.integer(workers), 
[17:40:58.037]                       class = class(workers))
[17:40:58.037]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:58.037]                       workers >= 1)
[17:40:58.037]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:58.037]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:58.037]                     }
[17:40:58.037]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:58.037]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:58.037]                       envir = envir)
[17:40:58.037]                     if (!future$lazy) 
[17:40:58.037]                       future <- run(future)
[17:40:58.037]                     invisible(future)
[17:40:58.037]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:58.037]                 }
[17:40:58.037]             }
[17:40:58.037]         }
[17:40:58.037]     })
[17:40:58.037]     if (TRUE) {
[17:40:58.037]         base::sink(type = "output", split = FALSE)
[17:40:58.037]         if (TRUE) {
[17:40:58.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.037]         }
[17:40:58.037]         else {
[17:40:58.037]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.037]         }
[17:40:58.037]         base::close(...future.stdout)
[17:40:58.037]         ...future.stdout <- NULL
[17:40:58.037]     }
[17:40:58.037]     ...future.result$conditions <- ...future.conditions
[17:40:58.037]     ...future.result$finished <- base::Sys.time()
[17:40:58.037]     ...future.result
[17:40:58.037] }
[17:40:58.040] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[17:40:58.040] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:40:58.083] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:40:58.083] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:40:58.084] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:40:58.084] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:40:58.084] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:40:58.084] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:40:58.127] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:40:58.127] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:40:58.171] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:40:58.171] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:40:58.172] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.172] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:40:58.172] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:40:58.172] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:40:58.173] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.173] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:40:58.173] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:40:58.173] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:40:58.174] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.174] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:40:58.174] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.174] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[17:40:58.175] MultisessionFuture started
[17:40:58.175] - Launch lazy future ... done
[17:40:58.175] run() for ‘MultisessionFuture’ ... done
[17:40:58.176] Created future:
[17:40:58.176] MultisessionFuture:
[17:40:58.176] Label: ‘future_vapply-2’
[17:40:58.176] Expression:
[17:40:58.176] {
[17:40:58.176]     do.call(function(...) {
[17:40:58.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.176]             on.exit(options(oopts), add = TRUE)
[17:40:58.176]         }
[17:40:58.176]         {
[17:40:58.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.176]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.176]             })
[17:40:58.176]         }
[17:40:58.176]     }, args = future.call.arguments)
[17:40:58.176] }
[17:40:58.176] Lazy evaluation: FALSE
[17:40:58.176] Asynchronous evaluation: TRUE
[17:40:58.176] Local evaluation: TRUE
[17:40:58.176] Environment: R_GlobalEnv
[17:40:58.176] Capture standard output: TRUE
[17:40:58.176] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:58.176] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:58.176] Packages: 1 packages (‘future.apply’)
[17:40:58.176] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:58.176] Resolved: FALSE
[17:40:58.176] Value: <not collected>
[17:40:58.176] Conditions captured: <none>
[17:40:58.176] Early signaling: FALSE
[17:40:58.176] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:58.176] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.187] Chunk #2 of 2 ... DONE
[17:40:58.188] Launching 2 futures (chunks) ... DONE
[17:40:58.188] Resolving 2 futures (chunks) ...
[17:40:58.188] resolve() on list ...
[17:40:58.188]  recursive: 0
[17:40:58.188]  length: 2
[17:40:58.188] 
[17:40:58.189] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.189] - Validating connection of MultisessionFuture
[17:40:58.189] - received message: FutureResult
[17:40:58.189] - Received FutureResult
[17:40:58.189] - Erased future from FutureRegistry
[17:40:58.189] result() for ClusterFuture ...
[17:40:58.189] - result already collected: FutureResult
[17:40:58.189] result() for ClusterFuture ... done
[17:40:58.189] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.190] Future #1
[17:40:58.190] result() for ClusterFuture ...
[17:40:58.190] - result already collected: FutureResult
[17:40:58.190] result() for ClusterFuture ... done
[17:40:58.190] result() for ClusterFuture ...
[17:40:58.190] - result already collected: FutureResult
[17:40:58.190] result() for ClusterFuture ... done
[17:40:58.190] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:40:58.190] - nx: 2
[17:40:58.190] - relay: TRUE
[17:40:58.190] - stdout: TRUE
[17:40:58.190] - signal: TRUE
[17:40:58.191] - resignal: FALSE
[17:40:58.191] - force: TRUE
[17:40:58.191] - relayed: [n=2] FALSE, FALSE
[17:40:58.191] - queued futures: [n=2] FALSE, FALSE
[17:40:58.191]  - until=1
[17:40:58.191]  - relaying element #1
[17:40:58.191] result() for ClusterFuture ...
[17:40:58.191] - result already collected: FutureResult
[17:40:58.191] result() for ClusterFuture ... done
[17:40:58.191] result() for ClusterFuture ...
[17:40:58.192] - result already collected: FutureResult
[17:40:58.192] result() for ClusterFuture ... done
[17:40:58.192] result() for ClusterFuture ...
[17:40:58.192] - result already collected: FutureResult
[17:40:58.192] result() for ClusterFuture ... done
[17:40:58.192] result() for ClusterFuture ...
[17:40:58.192] - result already collected: FutureResult
[17:40:58.192] result() for ClusterFuture ... done
[17:40:58.193] - relayed: [n=2] TRUE, FALSE
[17:40:58.193] - queued futures: [n=2] TRUE, FALSE
[17:40:58.193] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:40:58.193]  length: 1 (resolved future 1)
[17:40:58.224] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.225] - Validating connection of MultisessionFuture
[17:40:58.225] - received message: FutureResult
[17:40:58.225] - Received FutureResult
[17:40:58.225] - Erased future from FutureRegistry
[17:40:58.225] result() for ClusterFuture ...
[17:40:58.225] - result already collected: FutureResult
[17:40:58.225] result() for ClusterFuture ... done
[17:40:58.225] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.225] Future #2
[17:40:58.226] result() for ClusterFuture ...
[17:40:58.226] - result already collected: FutureResult
[17:40:58.226] result() for ClusterFuture ... done
[17:40:58.226] result() for ClusterFuture ...
[17:40:58.226] - result already collected: FutureResult
[17:40:58.226] result() for ClusterFuture ... done
[17:40:58.226] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:40:58.226] - nx: 2
[17:40:58.226] - relay: TRUE
[17:40:58.226] - stdout: TRUE
[17:40:58.226] - signal: TRUE
[17:40:58.226] - resignal: FALSE
[17:40:58.227] - force: TRUE
[17:40:58.227] - relayed: [n=2] TRUE, FALSE
[17:40:58.227] - queued futures: [n=2] TRUE, FALSE
[17:40:58.227]  - until=2
[17:40:58.227]  - relaying element #2
[17:40:58.227] result() for ClusterFuture ...
[17:40:58.227] - result already collected: FutureResult
[17:40:58.227] result() for ClusterFuture ... done
[17:40:58.227] result() for ClusterFuture ...
[17:40:58.227] - result already collected: FutureResult
[17:40:58.227] result() for ClusterFuture ... done
[17:40:58.228] result() for ClusterFuture ...
[17:40:58.228] - result already collected: FutureResult
[17:40:58.228] result() for ClusterFuture ... done
[17:40:58.228] result() for ClusterFuture ...
[17:40:58.228] - result already collected: FutureResult
[17:40:58.228] result() for ClusterFuture ... done
[17:40:58.228] - relayed: [n=2] TRUE, TRUE
[17:40:58.228] - queued futures: [n=2] TRUE, TRUE
[17:40:58.228] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:40:58.228]  length: 0 (resolved future 2)
[17:40:58.228] Relaying remaining futures
[17:40:58.229] signalConditionsASAP(NULL, pos=0) ...
[17:40:58.229] - nx: 2
[17:40:58.229] - relay: TRUE
[17:40:58.229] - stdout: TRUE
[17:40:58.229] - signal: TRUE
[17:40:58.229] - resignal: FALSE
[17:40:58.229] - force: TRUE
[17:40:58.229] - relayed: [n=2] TRUE, TRUE
[17:40:58.229] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:58.229] - relayed: [n=2] TRUE, TRUE
[17:40:58.229] - queued futures: [n=2] TRUE, TRUE
[17:40:58.229] signalConditionsASAP(NULL, pos=0) ... done
[17:40:58.230] resolve() on list ... DONE
[17:40:58.230] result() for ClusterFuture ...
[17:40:58.230] - result already collected: FutureResult
[17:40:58.230] result() for ClusterFuture ... done
[17:40:58.230] result() for ClusterFuture ...
[17:40:58.230] - result already collected: FutureResult
[17:40:58.230] result() for ClusterFuture ... done
[17:40:58.230] result() for ClusterFuture ...
[17:40:58.230] - result already collected: FutureResult
[17:40:58.230] result() for ClusterFuture ... done
[17:40:58.230] result() for ClusterFuture ...
[17:40:58.230] - result already collected: FutureResult
[17:40:58.231] result() for ClusterFuture ... done
[17:40:58.231]  - Number of value chunks collected: 2
[17:40:58.231] Resolving 2 futures (chunks) ... DONE
[17:40:58.231] Reducing values from 2 chunks ...
[17:40:58.231]  - Number of values collected after concatenation: 10
[17:40:58.231]  - Number of values expected: 10
[17:40:58.231] Reducing values from 2 chunks ... DONE
[17:40:58.231] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:40:58.232] future_lapply() ...
[17:40:58.237] Number of chunks: 2
[17:40:58.238] getGlobalsAndPackagesXApply() ...
[17:40:58.238]  - future.globals: TRUE
[17:40:58.238] getGlobalsAndPackages() ...
[17:40:58.238] Searching for globals...
[17:40:58.241] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:40:58.241] Searching for globals ... DONE
[17:40:58.241] Resolving globals: FALSE
[17:40:58.242] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:40:58.243] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:58.243] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:58.243] - packages: [1] ‘future.apply’
[17:40:58.243] getGlobalsAndPackages() ... DONE
[17:40:58.243]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:58.243]  - needed namespaces: [n=1] ‘future.apply’
[17:40:58.243] Finding globals ... DONE
[17:40:58.243]  - use_args: TRUE
[17:40:58.243]  - Getting '...' globals ...
[17:40:58.244] resolve() on list ...
[17:40:58.244]  recursive: 0
[17:40:58.244]  length: 1
[17:40:58.244]  elements: ‘...’
[17:40:58.244]  length: 0 (resolved future 1)
[17:40:58.244] resolve() on list ... DONE
[17:40:58.244]    - '...' content: [n=0] 
[17:40:58.244] List of 1
[17:40:58.244]  $ ...: list()
[17:40:58.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:58.244]  - attr(*, "where")=List of 1
[17:40:58.244]   ..$ ...:<environment: 0x564f31101178> 
[17:40:58.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:58.244]  - attr(*, "resolved")= logi TRUE
[17:40:58.244]  - attr(*, "total_size")= num NA
[17:40:58.247]  - Getting '...' globals ... DONE
[17:40:58.247] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:58.247] List of 8
[17:40:58.247]  $ ...future.FUN:function (x, ...)  
[17:40:58.247]  $ x_FUN        :function (x)  
[17:40:58.247]  $ times        : int 0
[17:40:58.247]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:58.247]  $ stop_if_not  :function (...)  
[17:40:58.247]  $ dim          : NULL
[17:40:58.247]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:58.247]  $ ...          : list()
[17:40:58.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:58.247]  - attr(*, "where")=List of 8
[17:40:58.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:58.247]   ..$ ...          :<environment: 0x564f31101178> 
[17:40:58.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:58.247]  - attr(*, "resolved")= logi FALSE
[17:40:58.247]  - attr(*, "total_size")= num 95400
[17:40:58.252] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:58.252] getGlobalsAndPackagesXApply() ... DONE
[17:40:58.253] Number of futures (= number of chunks): 2
[17:40:58.253] Launching 2 futures (chunks) ...
[17:40:58.253] Chunk #1 of 2 ...
[17:40:58.253]  - Finding globals in 'X' for chunk #1 ...
[17:40:58.253] getGlobalsAndPackages() ...
[17:40:58.253] Searching for globals...
[17:40:58.253] 
[17:40:58.253] Searching for globals ... DONE
[17:40:58.254] - globals: [0] <none>
[17:40:58.254] getGlobalsAndPackages() ... DONE
[17:40:58.254]    + additional globals found: [n=0] 
[17:40:58.254]    + additional namespaces needed: [n=0] 
[17:40:58.254]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:58.254]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:58.254]  - seeds: <none>
[17:40:58.254] getGlobalsAndPackages() ...
[17:40:58.254] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.254] Resolving globals: FALSE
[17:40:58.255] Tweak future expression to call with '...' arguments ...
[17:40:58.255] {
[17:40:58.255]     do.call(function(...) {
[17:40:58.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.255]             on.exit(options(oopts), add = TRUE)
[17:40:58.255]         }
[17:40:58.255]         {
[17:40:58.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.255]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.255]             })
[17:40:58.255]         }
[17:40:58.255]     }, args = future.call.arguments)
[17:40:58.255] }
[17:40:58.255] Tweak future expression to call with '...' arguments ... DONE
[17:40:58.255] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.256] - packages: [1] ‘future.apply’
[17:40:58.256] getGlobalsAndPackages() ... DONE
[17:40:58.256] run() for ‘Future’ ...
[17:40:58.256] - state: ‘created’
[17:40:58.256] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.271] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.271]   - Field: ‘node’
[17:40:58.271]   - Field: ‘label’
[17:40:58.271]   - Field: ‘local’
[17:40:58.272]   - Field: ‘owner’
[17:40:58.272]   - Field: ‘envir’
[17:40:58.272]   - Field: ‘workers’
[17:40:58.272]   - Field: ‘packages’
[17:40:58.272]   - Field: ‘gc’
[17:40:58.272]   - Field: ‘conditions’
[17:40:58.272]   - Field: ‘persistent’
[17:40:58.272]   - Field: ‘expr’
[17:40:58.272]   - Field: ‘uuid’
[17:40:58.272]   - Field: ‘seed’
[17:40:58.272]   - Field: ‘version’
[17:40:58.273]   - Field: ‘result’
[17:40:58.273]   - Field: ‘asynchronous’
[17:40:58.273]   - Field: ‘calls’
[17:40:58.273]   - Field: ‘globals’
[17:40:58.273]   - Field: ‘stdout’
[17:40:58.273]   - Field: ‘earlySignal’
[17:40:58.273]   - Field: ‘lazy’
[17:40:58.273]   - Field: ‘state’
[17:40:58.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.273] - Launch lazy future ...
[17:40:58.274] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:58.274] Packages needed by future strategies (n = 0): <none>
[17:40:58.274] {
[17:40:58.274]     {
[17:40:58.274]         {
[17:40:58.274]             ...future.startTime <- base::Sys.time()
[17:40:58.274]             {
[17:40:58.274]                 {
[17:40:58.274]                   {
[17:40:58.274]                     {
[17:40:58.274]                       {
[17:40:58.274]                         base::local({
[17:40:58.274]                           has_future <- base::requireNamespace("future", 
[17:40:58.274]                             quietly = TRUE)
[17:40:58.274]                           if (has_future) {
[17:40:58.274]                             ns <- base::getNamespace("future")
[17:40:58.274]                             version <- ns[[".package"]][["version"]]
[17:40:58.274]                             if (is.null(version)) 
[17:40:58.274]                               version <- utils::packageVersion("future")
[17:40:58.274]                           }
[17:40:58.274]                           else {
[17:40:58.274]                             version <- NULL
[17:40:58.274]                           }
[17:40:58.274]                           if (!has_future || version < "1.8.0") {
[17:40:58.274]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.274]                               "", base::R.version$version.string), 
[17:40:58.274]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:58.274]                                 base::R.version$platform, 8 * 
[17:40:58.274]                                   base::.Machine$sizeof.pointer), 
[17:40:58.274]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.274]                                 "release", "version")], collapse = " "), 
[17:40:58.274]                               hostname = base::Sys.info()[["nodename"]])
[17:40:58.274]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.274]                               info)
[17:40:58.274]                             info <- base::paste(info, collapse = "; ")
[17:40:58.274]                             if (!has_future) {
[17:40:58.274]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.274]                                 info)
[17:40:58.274]                             }
[17:40:58.274]                             else {
[17:40:58.274]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.274]                                 info, version)
[17:40:58.274]                             }
[17:40:58.274]                             base::stop(msg)
[17:40:58.274]                           }
[17:40:58.274]                         })
[17:40:58.274]                       }
[17:40:58.274]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.274]                       base::options(mc.cores = 1L)
[17:40:58.274]                     }
[17:40:58.274]                     base::local({
[17:40:58.274]                       for (pkg in "future.apply") {
[17:40:58.274]                         base::loadNamespace(pkg)
[17:40:58.274]                         base::library(pkg, character.only = TRUE)
[17:40:58.274]                       }
[17:40:58.274]                     })
[17:40:58.274]                   }
[17:40:58.274]                   options(future.plan = NULL)
[17:40:58.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.274]                 }
[17:40:58.274]                 ...future.workdir <- getwd()
[17:40:58.274]             }
[17:40:58.274]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.274]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.274]         }
[17:40:58.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.274]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:58.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.274]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.274]             base::names(...future.oldOptions))
[17:40:58.274]     }
[17:40:58.274]     if (FALSE) {
[17:40:58.274]     }
[17:40:58.274]     else {
[17:40:58.274]         if (TRUE) {
[17:40:58.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.274]                 open = "w")
[17:40:58.274]         }
[17:40:58.274]         else {
[17:40:58.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.274]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.274]         }
[17:40:58.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.274]             base::sink(type = "output", split = FALSE)
[17:40:58.274]             base::close(...future.stdout)
[17:40:58.274]         }, add = TRUE)
[17:40:58.274]     }
[17:40:58.274]     ...future.frame <- base::sys.nframe()
[17:40:58.274]     ...future.conditions <- base::list()
[17:40:58.274]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.274]     if (FALSE) {
[17:40:58.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.274]     }
[17:40:58.274]     ...future.result <- base::tryCatch({
[17:40:58.274]         base::withCallingHandlers({
[17:40:58.274]             ...future.value <- base::withVisible(base::local({
[17:40:58.274]                 ...future.makeSendCondition <- local({
[17:40:58.274]                   sendCondition <- NULL
[17:40:58.274]                   function(frame = 1L) {
[17:40:58.274]                     if (is.function(sendCondition)) 
[17:40:58.274]                       return(sendCondition)
[17:40:58.274]                     ns <- getNamespace("parallel")
[17:40:58.274]                     if (exists("sendData", mode = "function", 
[17:40:58.274]                       envir = ns)) {
[17:40:58.274]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.274]                         envir = ns)
[17:40:58.274]                       envir <- sys.frame(frame)
[17:40:58.274]                       master <- NULL
[17:40:58.274]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.274]                         !identical(envir, emptyenv())) {
[17:40:58.274]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.274]                           inherits = FALSE)) {
[17:40:58.274]                           master <- get("master", mode = "list", 
[17:40:58.274]                             envir = envir, inherits = FALSE)
[17:40:58.274]                           if (inherits(master, c("SOCKnode", 
[17:40:58.274]                             "SOCK0node"))) {
[17:40:58.274]                             sendCondition <<- function(cond) {
[17:40:58.274]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.274]                                 success = TRUE)
[17:40:58.274]                               parallel_sendData(master, data)
[17:40:58.274]                             }
[17:40:58.274]                             return(sendCondition)
[17:40:58.274]                           }
[17:40:58.274]                         }
[17:40:58.274]                         frame <- frame + 1L
[17:40:58.274]                         envir <- sys.frame(frame)
[17:40:58.274]                       }
[17:40:58.274]                     }
[17:40:58.274]                     sendCondition <<- function(cond) NULL
[17:40:58.274]                   }
[17:40:58.274]                 })
[17:40:58.274]                 withCallingHandlers({
[17:40:58.274]                   {
[17:40:58.274]                     do.call(function(...) {
[17:40:58.274]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.274]                       if (!identical(...future.globals.maxSize.org, 
[17:40:58.274]                         ...future.globals.maxSize)) {
[17:40:58.274]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.274]                         on.exit(options(oopts), add = TRUE)
[17:40:58.274]                       }
[17:40:58.274]                       {
[17:40:58.274]                         lapply(seq_along(...future.elements_ii), 
[17:40:58.274]                           FUN = function(jj) {
[17:40:58.274]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.274]                             ...future.FUN(...future.X_jj, ...)
[17:40:58.274]                           })
[17:40:58.274]                       }
[17:40:58.274]                     }, args = future.call.arguments)
[17:40:58.274]                   }
[17:40:58.274]                 }, immediateCondition = function(cond) {
[17:40:58.274]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.274]                   sendCondition(cond)
[17:40:58.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.274]                   {
[17:40:58.274]                     inherits <- base::inherits
[17:40:58.274]                     invokeRestart <- base::invokeRestart
[17:40:58.274]                     is.null <- base::is.null
[17:40:58.274]                     muffled <- FALSE
[17:40:58.274]                     if (inherits(cond, "message")) {
[17:40:58.274]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.274]                       if (muffled) 
[17:40:58.274]                         invokeRestart("muffleMessage")
[17:40:58.274]                     }
[17:40:58.274]                     else if (inherits(cond, "warning")) {
[17:40:58.274]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.274]                       if (muffled) 
[17:40:58.274]                         invokeRestart("muffleWarning")
[17:40:58.274]                     }
[17:40:58.274]                     else if (inherits(cond, "condition")) {
[17:40:58.274]                       if (!is.null(pattern)) {
[17:40:58.274]                         computeRestarts <- base::computeRestarts
[17:40:58.274]                         grepl <- base::grepl
[17:40:58.274]                         restarts <- computeRestarts(cond)
[17:40:58.274]                         for (restart in restarts) {
[17:40:58.274]                           name <- restart$name
[17:40:58.274]                           if (is.null(name)) 
[17:40:58.274]                             next
[17:40:58.274]                           if (!grepl(pattern, name)) 
[17:40:58.274]                             next
[17:40:58.274]                           invokeRestart(restart)
[17:40:58.274]                           muffled <- TRUE
[17:40:58.274]                           break
[17:40:58.274]                         }
[17:40:58.274]                       }
[17:40:58.274]                     }
[17:40:58.274]                     invisible(muffled)
[17:40:58.274]                   }
[17:40:58.274]                   muffleCondition(cond)
[17:40:58.274]                 })
[17:40:58.274]             }))
[17:40:58.274]             future::FutureResult(value = ...future.value$value, 
[17:40:58.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.274]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.274]                     ...future.globalenv.names))
[17:40:58.274]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.274]         }, condition = base::local({
[17:40:58.274]             c <- base::c
[17:40:58.274]             inherits <- base::inherits
[17:40:58.274]             invokeRestart <- base::invokeRestart
[17:40:58.274]             length <- base::length
[17:40:58.274]             list <- base::list
[17:40:58.274]             seq.int <- base::seq.int
[17:40:58.274]             signalCondition <- base::signalCondition
[17:40:58.274]             sys.calls <- base::sys.calls
[17:40:58.274]             `[[` <- base::`[[`
[17:40:58.274]             `+` <- base::`+`
[17:40:58.274]             `<<-` <- base::`<<-`
[17:40:58.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.274]                   3L)]
[17:40:58.274]             }
[17:40:58.274]             function(cond) {
[17:40:58.274]                 is_error <- inherits(cond, "error")
[17:40:58.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.274]                   NULL)
[17:40:58.274]                 if (is_error) {
[17:40:58.274]                   sessionInformation <- function() {
[17:40:58.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.274]                       search = base::search(), system = base::Sys.info())
[17:40:58.274]                   }
[17:40:58.274]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.274]                     cond$call), session = sessionInformation(), 
[17:40:58.274]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.274]                   signalCondition(cond)
[17:40:58.274]                 }
[17:40:58.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.274]                 "immediateCondition"))) {
[17:40:58.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.274]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.274]                   if (TRUE && !signal) {
[17:40:58.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.274]                     {
[17:40:58.274]                       inherits <- base::inherits
[17:40:58.274]                       invokeRestart <- base::invokeRestart
[17:40:58.274]                       is.null <- base::is.null
[17:40:58.274]                       muffled <- FALSE
[17:40:58.274]                       if (inherits(cond, "message")) {
[17:40:58.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.274]                         if (muffled) 
[17:40:58.274]                           invokeRestart("muffleMessage")
[17:40:58.274]                       }
[17:40:58.274]                       else if (inherits(cond, "warning")) {
[17:40:58.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.274]                         if (muffled) 
[17:40:58.274]                           invokeRestart("muffleWarning")
[17:40:58.274]                       }
[17:40:58.274]                       else if (inherits(cond, "condition")) {
[17:40:58.274]                         if (!is.null(pattern)) {
[17:40:58.274]                           computeRestarts <- base::computeRestarts
[17:40:58.274]                           grepl <- base::grepl
[17:40:58.274]                           restarts <- computeRestarts(cond)
[17:40:58.274]                           for (restart in restarts) {
[17:40:58.274]                             name <- restart$name
[17:40:58.274]                             if (is.null(name)) 
[17:40:58.274]                               next
[17:40:58.274]                             if (!grepl(pattern, name)) 
[17:40:58.274]                               next
[17:40:58.274]                             invokeRestart(restart)
[17:40:58.274]                             muffled <- TRUE
[17:40:58.274]                             break
[17:40:58.274]                           }
[17:40:58.274]                         }
[17:40:58.274]                       }
[17:40:58.274]                       invisible(muffled)
[17:40:58.274]                     }
[17:40:58.274]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.274]                   }
[17:40:58.274]                 }
[17:40:58.274]                 else {
[17:40:58.274]                   if (TRUE) {
[17:40:58.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.274]                     {
[17:40:58.274]                       inherits <- base::inherits
[17:40:58.274]                       invokeRestart <- base::invokeRestart
[17:40:58.274]                       is.null <- base::is.null
[17:40:58.274]                       muffled <- FALSE
[17:40:58.274]                       if (inherits(cond, "message")) {
[17:40:58.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.274]                         if (muffled) 
[17:40:58.274]                           invokeRestart("muffleMessage")
[17:40:58.274]                       }
[17:40:58.274]                       else if (inherits(cond, "warning")) {
[17:40:58.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.274]                         if (muffled) 
[17:40:58.274]                           invokeRestart("muffleWarning")
[17:40:58.274]                       }
[17:40:58.274]                       else if (inherits(cond, "condition")) {
[17:40:58.274]                         if (!is.null(pattern)) {
[17:40:58.274]                           computeRestarts <- base::computeRestarts
[17:40:58.274]                           grepl <- base::grepl
[17:40:58.274]                           restarts <- computeRestarts(cond)
[17:40:58.274]                           for (restart in restarts) {
[17:40:58.274]                             name <- restart$name
[17:40:58.274]                             if (is.null(name)) 
[17:40:58.274]                               next
[17:40:58.274]                             if (!grepl(pattern, name)) 
[17:40:58.274]                               next
[17:40:58.274]                             invokeRestart(restart)
[17:40:58.274]                             muffled <- TRUE
[17:40:58.274]                             break
[17:40:58.274]                           }
[17:40:58.274]                         }
[17:40:58.274]                       }
[17:40:58.274]                       invisible(muffled)
[17:40:58.274]                     }
[17:40:58.274]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.274]                   }
[17:40:58.274]                 }
[17:40:58.274]             }
[17:40:58.274]         }))
[17:40:58.274]     }, error = function(ex) {
[17:40:58.274]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.274]                 ...future.rng), started = ...future.startTime, 
[17:40:58.274]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.274]             version = "1.8"), class = "FutureResult")
[17:40:58.274]     }, finally = {
[17:40:58.274]         if (!identical(...future.workdir, getwd())) 
[17:40:58.274]             setwd(...future.workdir)
[17:40:58.274]         {
[17:40:58.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.274]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.274]             }
[17:40:58.274]             base::options(...future.oldOptions)
[17:40:58.274]             if (.Platform$OS.type == "windows") {
[17:40:58.274]                 old_names <- names(...future.oldEnvVars)
[17:40:58.274]                 envs <- base::Sys.getenv()
[17:40:58.274]                 names <- names(envs)
[17:40:58.274]                 common <- intersect(names, old_names)
[17:40:58.274]                 added <- setdiff(names, old_names)
[17:40:58.274]                 removed <- setdiff(old_names, names)
[17:40:58.274]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.274]                   envs[common]]
[17:40:58.274]                 NAMES <- toupper(changed)
[17:40:58.274]                 args <- list()
[17:40:58.274]                 for (kk in seq_along(NAMES)) {
[17:40:58.274]                   name <- changed[[kk]]
[17:40:58.274]                   NAME <- NAMES[[kk]]
[17:40:58.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.274]                     next
[17:40:58.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.274]                 }
[17:40:58.274]                 NAMES <- toupper(added)
[17:40:58.274]                 for (kk in seq_along(NAMES)) {
[17:40:58.274]                   name <- added[[kk]]
[17:40:58.274]                   NAME <- NAMES[[kk]]
[17:40:58.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.274]                     next
[17:40:58.274]                   args[[name]] <- ""
[17:40:58.274]                 }
[17:40:58.274]                 NAMES <- toupper(removed)
[17:40:58.274]                 for (kk in seq_along(NAMES)) {
[17:40:58.274]                   name <- removed[[kk]]
[17:40:58.274]                   NAME <- NAMES[[kk]]
[17:40:58.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.274]                     next
[17:40:58.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.274]                 }
[17:40:58.274]                 if (length(args) > 0) 
[17:40:58.274]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.274]             }
[17:40:58.274]             else {
[17:40:58.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.274]             }
[17:40:58.274]             {
[17:40:58.274]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.274]                   0L) {
[17:40:58.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.274]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.274]                   base::options(opts)
[17:40:58.274]                 }
[17:40:58.274]                 {
[17:40:58.274]                   {
[17:40:58.274]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.274]                     NULL
[17:40:58.274]                   }
[17:40:58.274]                   options(future.plan = NULL)
[17:40:58.274]                   if (is.na(NA_character_)) 
[17:40:58.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.274]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:58.274]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:58.274]                     envir = parent.frame()) 
[17:40:58.274]                   {
[17:40:58.274]                     if (is.function(workers)) 
[17:40:58.274]                       workers <- workers()
[17:40:58.274]                     workers <- structure(as.integer(workers), 
[17:40:58.274]                       class = class(workers))
[17:40:58.274]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:58.274]                       workers >= 1)
[17:40:58.274]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:58.274]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:58.274]                     }
[17:40:58.274]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:58.274]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:58.274]                       envir = envir)
[17:40:58.274]                     if (!future$lazy) 
[17:40:58.274]                       future <- run(future)
[17:40:58.274]                     invisible(future)
[17:40:58.274]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:58.274]                 }
[17:40:58.274]             }
[17:40:58.274]         }
[17:40:58.274]     })
[17:40:58.274]     if (TRUE) {
[17:40:58.274]         base::sink(type = "output", split = FALSE)
[17:40:58.274]         if (TRUE) {
[17:40:58.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.274]         }
[17:40:58.274]         else {
[17:40:58.274]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.274]         }
[17:40:58.274]         base::close(...future.stdout)
[17:40:58.274]         ...future.stdout <- NULL
[17:40:58.274]     }
[17:40:58.274]     ...future.result$conditions <- ...future.conditions
[17:40:58.274]     ...future.result$finished <- base::Sys.time()
[17:40:58.274]     ...future.result
[17:40:58.274] }
[17:40:58.277] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[17:40:58.277] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:40:58.319] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:40:58.319] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:40:58.320] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:40:58.320] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:40:58.321] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:40:58.321] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:40:58.363] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:40:58.363] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:40:58.407] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:40:58.407] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:40:58.408] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.408] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:40:58.408] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:40:58.409] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:40:58.411] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.411] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:40:58.411] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:40:58.411] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:40:58.412] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.412] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:40:58.412] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.412] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[17:40:58.413] MultisessionFuture started
[17:40:58.413] - Launch lazy future ... done
[17:40:58.413] run() for ‘MultisessionFuture’ ... done
[17:40:58.413] Created future:
[17:40:58.413] MultisessionFuture:
[17:40:58.413] Label: ‘future_vapply-1’
[17:40:58.413] Expression:
[17:40:58.413] {
[17:40:58.413]     do.call(function(...) {
[17:40:58.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.413]             on.exit(options(oopts), add = TRUE)
[17:40:58.413]         }
[17:40:58.413]         {
[17:40:58.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.413]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.413]             })
[17:40:58.413]         }
[17:40:58.413]     }, args = future.call.arguments)
[17:40:58.413] }
[17:40:58.413] Lazy evaluation: FALSE
[17:40:58.413] Asynchronous evaluation: TRUE
[17:40:58.413] Local evaluation: TRUE
[17:40:58.413] Environment: R_GlobalEnv
[17:40:58.413] Capture standard output: TRUE
[17:40:58.413] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:58.413] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:58.413] Packages: 1 packages (‘future.apply’)
[17:40:58.413] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:58.413] Resolved: FALSE
[17:40:58.413] Value: <not collected>
[17:40:58.413] Conditions captured: <none>
[17:40:58.413] Early signaling: FALSE
[17:40:58.413] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:58.413] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.425] Chunk #1 of 2 ... DONE
[17:40:58.425] Chunk #2 of 2 ...
[17:40:58.425]  - Finding globals in 'X' for chunk #2 ...
[17:40:58.425] getGlobalsAndPackages() ...
[17:40:58.425] Searching for globals...
[17:40:58.426] 
[17:40:58.426] Searching for globals ... DONE
[17:40:58.426] - globals: [0] <none>
[17:40:58.426] getGlobalsAndPackages() ... DONE
[17:40:58.426]    + additional globals found: [n=0] 
[17:40:58.426]    + additional namespaces needed: [n=0] 
[17:40:58.426]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:58.426]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:58.426]  - seeds: <none>
[17:40:58.426] getGlobalsAndPackages() ...
[17:40:58.427] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.427] Resolving globals: FALSE
[17:40:58.427] Tweak future expression to call with '...' arguments ...
[17:40:58.427] {
[17:40:58.427]     do.call(function(...) {
[17:40:58.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.427]             on.exit(options(oopts), add = TRUE)
[17:40:58.427]         }
[17:40:58.427]         {
[17:40:58.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.427]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.427]             })
[17:40:58.427]         }
[17:40:58.427]     }, args = future.call.arguments)
[17:40:58.427] }
[17:40:58.427] Tweak future expression to call with '...' arguments ... DONE
[17:40:58.428] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.428] - packages: [1] ‘future.apply’
[17:40:58.428] getGlobalsAndPackages() ... DONE
[17:40:58.428] run() for ‘Future’ ...
[17:40:58.428] - state: ‘created’
[17:40:58.428] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.442] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.443]   - Field: ‘node’
[17:40:58.443]   - Field: ‘label’
[17:40:58.443]   - Field: ‘local’
[17:40:58.443]   - Field: ‘owner’
[17:40:58.443]   - Field: ‘envir’
[17:40:58.443]   - Field: ‘workers’
[17:40:58.443]   - Field: ‘packages’
[17:40:58.443]   - Field: ‘gc’
[17:40:58.443]   - Field: ‘conditions’
[17:40:58.444]   - Field: ‘persistent’
[17:40:58.444]   - Field: ‘expr’
[17:40:58.444]   - Field: ‘uuid’
[17:40:58.444]   - Field: ‘seed’
[17:40:58.444]   - Field: ‘version’
[17:40:58.444]   - Field: ‘result’
[17:40:58.444]   - Field: ‘asynchronous’
[17:40:58.444]   - Field: ‘calls’
[17:40:58.444]   - Field: ‘globals’
[17:40:58.444]   - Field: ‘stdout’
[17:40:58.444]   - Field: ‘earlySignal’
[17:40:58.445]   - Field: ‘lazy’
[17:40:58.445]   - Field: ‘state’
[17:40:58.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.445] - Launch lazy future ...
[17:40:58.445] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:58.445] Packages needed by future strategies (n = 0): <none>
[17:40:58.446] {
[17:40:58.446]     {
[17:40:58.446]         {
[17:40:58.446]             ...future.startTime <- base::Sys.time()
[17:40:58.446]             {
[17:40:58.446]                 {
[17:40:58.446]                   {
[17:40:58.446]                     {
[17:40:58.446]                       {
[17:40:58.446]                         base::local({
[17:40:58.446]                           has_future <- base::requireNamespace("future", 
[17:40:58.446]                             quietly = TRUE)
[17:40:58.446]                           if (has_future) {
[17:40:58.446]                             ns <- base::getNamespace("future")
[17:40:58.446]                             version <- ns[[".package"]][["version"]]
[17:40:58.446]                             if (is.null(version)) 
[17:40:58.446]                               version <- utils::packageVersion("future")
[17:40:58.446]                           }
[17:40:58.446]                           else {
[17:40:58.446]                             version <- NULL
[17:40:58.446]                           }
[17:40:58.446]                           if (!has_future || version < "1.8.0") {
[17:40:58.446]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.446]                               "", base::R.version$version.string), 
[17:40:58.446]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:58.446]                                 base::R.version$platform, 8 * 
[17:40:58.446]                                   base::.Machine$sizeof.pointer), 
[17:40:58.446]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.446]                                 "release", "version")], collapse = " "), 
[17:40:58.446]                               hostname = base::Sys.info()[["nodename"]])
[17:40:58.446]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.446]                               info)
[17:40:58.446]                             info <- base::paste(info, collapse = "; ")
[17:40:58.446]                             if (!has_future) {
[17:40:58.446]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.446]                                 info)
[17:40:58.446]                             }
[17:40:58.446]                             else {
[17:40:58.446]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.446]                                 info, version)
[17:40:58.446]                             }
[17:40:58.446]                             base::stop(msg)
[17:40:58.446]                           }
[17:40:58.446]                         })
[17:40:58.446]                       }
[17:40:58.446]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.446]                       base::options(mc.cores = 1L)
[17:40:58.446]                     }
[17:40:58.446]                     base::local({
[17:40:58.446]                       for (pkg in "future.apply") {
[17:40:58.446]                         base::loadNamespace(pkg)
[17:40:58.446]                         base::library(pkg, character.only = TRUE)
[17:40:58.446]                       }
[17:40:58.446]                     })
[17:40:58.446]                   }
[17:40:58.446]                   options(future.plan = NULL)
[17:40:58.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.446]                 }
[17:40:58.446]                 ...future.workdir <- getwd()
[17:40:58.446]             }
[17:40:58.446]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.446]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.446]         }
[17:40:58.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.446]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:58.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.446]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.446]             base::names(...future.oldOptions))
[17:40:58.446]     }
[17:40:58.446]     if (FALSE) {
[17:40:58.446]     }
[17:40:58.446]     else {
[17:40:58.446]         if (TRUE) {
[17:40:58.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.446]                 open = "w")
[17:40:58.446]         }
[17:40:58.446]         else {
[17:40:58.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.446]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.446]         }
[17:40:58.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.446]             base::sink(type = "output", split = FALSE)
[17:40:58.446]             base::close(...future.stdout)
[17:40:58.446]         }, add = TRUE)
[17:40:58.446]     }
[17:40:58.446]     ...future.frame <- base::sys.nframe()
[17:40:58.446]     ...future.conditions <- base::list()
[17:40:58.446]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.446]     if (FALSE) {
[17:40:58.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.446]     }
[17:40:58.446]     ...future.result <- base::tryCatch({
[17:40:58.446]         base::withCallingHandlers({
[17:40:58.446]             ...future.value <- base::withVisible(base::local({
[17:40:58.446]                 ...future.makeSendCondition <- local({
[17:40:58.446]                   sendCondition <- NULL
[17:40:58.446]                   function(frame = 1L) {
[17:40:58.446]                     if (is.function(sendCondition)) 
[17:40:58.446]                       return(sendCondition)
[17:40:58.446]                     ns <- getNamespace("parallel")
[17:40:58.446]                     if (exists("sendData", mode = "function", 
[17:40:58.446]                       envir = ns)) {
[17:40:58.446]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.446]                         envir = ns)
[17:40:58.446]                       envir <- sys.frame(frame)
[17:40:58.446]                       master <- NULL
[17:40:58.446]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.446]                         !identical(envir, emptyenv())) {
[17:40:58.446]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.446]                           inherits = FALSE)) {
[17:40:58.446]                           master <- get("master", mode = "list", 
[17:40:58.446]                             envir = envir, inherits = FALSE)
[17:40:58.446]                           if (inherits(master, c("SOCKnode", 
[17:40:58.446]                             "SOCK0node"))) {
[17:40:58.446]                             sendCondition <<- function(cond) {
[17:40:58.446]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.446]                                 success = TRUE)
[17:40:58.446]                               parallel_sendData(master, data)
[17:40:58.446]                             }
[17:40:58.446]                             return(sendCondition)
[17:40:58.446]                           }
[17:40:58.446]                         }
[17:40:58.446]                         frame <- frame + 1L
[17:40:58.446]                         envir <- sys.frame(frame)
[17:40:58.446]                       }
[17:40:58.446]                     }
[17:40:58.446]                     sendCondition <<- function(cond) NULL
[17:40:58.446]                   }
[17:40:58.446]                 })
[17:40:58.446]                 withCallingHandlers({
[17:40:58.446]                   {
[17:40:58.446]                     do.call(function(...) {
[17:40:58.446]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.446]                       if (!identical(...future.globals.maxSize.org, 
[17:40:58.446]                         ...future.globals.maxSize)) {
[17:40:58.446]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.446]                         on.exit(options(oopts), add = TRUE)
[17:40:58.446]                       }
[17:40:58.446]                       {
[17:40:58.446]                         lapply(seq_along(...future.elements_ii), 
[17:40:58.446]                           FUN = function(jj) {
[17:40:58.446]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.446]                             ...future.FUN(...future.X_jj, ...)
[17:40:58.446]                           })
[17:40:58.446]                       }
[17:40:58.446]                     }, args = future.call.arguments)
[17:40:58.446]                   }
[17:40:58.446]                 }, immediateCondition = function(cond) {
[17:40:58.446]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.446]                   sendCondition(cond)
[17:40:58.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.446]                   {
[17:40:58.446]                     inherits <- base::inherits
[17:40:58.446]                     invokeRestart <- base::invokeRestart
[17:40:58.446]                     is.null <- base::is.null
[17:40:58.446]                     muffled <- FALSE
[17:40:58.446]                     if (inherits(cond, "message")) {
[17:40:58.446]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.446]                       if (muffled) 
[17:40:58.446]                         invokeRestart("muffleMessage")
[17:40:58.446]                     }
[17:40:58.446]                     else if (inherits(cond, "warning")) {
[17:40:58.446]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.446]                       if (muffled) 
[17:40:58.446]                         invokeRestart("muffleWarning")
[17:40:58.446]                     }
[17:40:58.446]                     else if (inherits(cond, "condition")) {
[17:40:58.446]                       if (!is.null(pattern)) {
[17:40:58.446]                         computeRestarts <- base::computeRestarts
[17:40:58.446]                         grepl <- base::grepl
[17:40:58.446]                         restarts <- computeRestarts(cond)
[17:40:58.446]                         for (restart in restarts) {
[17:40:58.446]                           name <- restart$name
[17:40:58.446]                           if (is.null(name)) 
[17:40:58.446]                             next
[17:40:58.446]                           if (!grepl(pattern, name)) 
[17:40:58.446]                             next
[17:40:58.446]                           invokeRestart(restart)
[17:40:58.446]                           muffled <- TRUE
[17:40:58.446]                           break
[17:40:58.446]                         }
[17:40:58.446]                       }
[17:40:58.446]                     }
[17:40:58.446]                     invisible(muffled)
[17:40:58.446]                   }
[17:40:58.446]                   muffleCondition(cond)
[17:40:58.446]                 })
[17:40:58.446]             }))
[17:40:58.446]             future::FutureResult(value = ...future.value$value, 
[17:40:58.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.446]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.446]                     ...future.globalenv.names))
[17:40:58.446]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.446]         }, condition = base::local({
[17:40:58.446]             c <- base::c
[17:40:58.446]             inherits <- base::inherits
[17:40:58.446]             invokeRestart <- base::invokeRestart
[17:40:58.446]             length <- base::length
[17:40:58.446]             list <- base::list
[17:40:58.446]             seq.int <- base::seq.int
[17:40:58.446]             signalCondition <- base::signalCondition
[17:40:58.446]             sys.calls <- base::sys.calls
[17:40:58.446]             `[[` <- base::`[[`
[17:40:58.446]             `+` <- base::`+`
[17:40:58.446]             `<<-` <- base::`<<-`
[17:40:58.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.446]                   3L)]
[17:40:58.446]             }
[17:40:58.446]             function(cond) {
[17:40:58.446]                 is_error <- inherits(cond, "error")
[17:40:58.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.446]                   NULL)
[17:40:58.446]                 if (is_error) {
[17:40:58.446]                   sessionInformation <- function() {
[17:40:58.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.446]                       search = base::search(), system = base::Sys.info())
[17:40:58.446]                   }
[17:40:58.446]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.446]                     cond$call), session = sessionInformation(), 
[17:40:58.446]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.446]                   signalCondition(cond)
[17:40:58.446]                 }
[17:40:58.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.446]                 "immediateCondition"))) {
[17:40:58.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.446]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.446]                   if (TRUE && !signal) {
[17:40:58.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.446]                     {
[17:40:58.446]                       inherits <- base::inherits
[17:40:58.446]                       invokeRestart <- base::invokeRestart
[17:40:58.446]                       is.null <- base::is.null
[17:40:58.446]                       muffled <- FALSE
[17:40:58.446]                       if (inherits(cond, "message")) {
[17:40:58.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.446]                         if (muffled) 
[17:40:58.446]                           invokeRestart("muffleMessage")
[17:40:58.446]                       }
[17:40:58.446]                       else if (inherits(cond, "warning")) {
[17:40:58.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.446]                         if (muffled) 
[17:40:58.446]                           invokeRestart("muffleWarning")
[17:40:58.446]                       }
[17:40:58.446]                       else if (inherits(cond, "condition")) {
[17:40:58.446]                         if (!is.null(pattern)) {
[17:40:58.446]                           computeRestarts <- base::computeRestarts
[17:40:58.446]                           grepl <- base::grepl
[17:40:58.446]                           restarts <- computeRestarts(cond)
[17:40:58.446]                           for (restart in restarts) {
[17:40:58.446]                             name <- restart$name
[17:40:58.446]                             if (is.null(name)) 
[17:40:58.446]                               next
[17:40:58.446]                             if (!grepl(pattern, name)) 
[17:40:58.446]                               next
[17:40:58.446]                             invokeRestart(restart)
[17:40:58.446]                             muffled <- TRUE
[17:40:58.446]                             break
[17:40:58.446]                           }
[17:40:58.446]                         }
[17:40:58.446]                       }
[17:40:58.446]                       invisible(muffled)
[17:40:58.446]                     }
[17:40:58.446]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.446]                   }
[17:40:58.446]                 }
[17:40:58.446]                 else {
[17:40:58.446]                   if (TRUE) {
[17:40:58.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.446]                     {
[17:40:58.446]                       inherits <- base::inherits
[17:40:58.446]                       invokeRestart <- base::invokeRestart
[17:40:58.446]                       is.null <- base::is.null
[17:40:58.446]                       muffled <- FALSE
[17:40:58.446]                       if (inherits(cond, "message")) {
[17:40:58.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.446]                         if (muffled) 
[17:40:58.446]                           invokeRestart("muffleMessage")
[17:40:58.446]                       }
[17:40:58.446]                       else if (inherits(cond, "warning")) {
[17:40:58.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.446]                         if (muffled) 
[17:40:58.446]                           invokeRestart("muffleWarning")
[17:40:58.446]                       }
[17:40:58.446]                       else if (inherits(cond, "condition")) {
[17:40:58.446]                         if (!is.null(pattern)) {
[17:40:58.446]                           computeRestarts <- base::computeRestarts
[17:40:58.446]                           grepl <- base::grepl
[17:40:58.446]                           restarts <- computeRestarts(cond)
[17:40:58.446]                           for (restart in restarts) {
[17:40:58.446]                             name <- restart$name
[17:40:58.446]                             if (is.null(name)) 
[17:40:58.446]                               next
[17:40:58.446]                             if (!grepl(pattern, name)) 
[17:40:58.446]                               next
[17:40:58.446]                             invokeRestart(restart)
[17:40:58.446]                             muffled <- TRUE
[17:40:58.446]                             break
[17:40:58.446]                           }
[17:40:58.446]                         }
[17:40:58.446]                       }
[17:40:58.446]                       invisible(muffled)
[17:40:58.446]                     }
[17:40:58.446]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.446]                   }
[17:40:58.446]                 }
[17:40:58.446]             }
[17:40:58.446]         }))
[17:40:58.446]     }, error = function(ex) {
[17:40:58.446]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.446]                 ...future.rng), started = ...future.startTime, 
[17:40:58.446]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.446]             version = "1.8"), class = "FutureResult")
[17:40:58.446]     }, finally = {
[17:40:58.446]         if (!identical(...future.workdir, getwd())) 
[17:40:58.446]             setwd(...future.workdir)
[17:40:58.446]         {
[17:40:58.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.446]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.446]             }
[17:40:58.446]             base::options(...future.oldOptions)
[17:40:58.446]             if (.Platform$OS.type == "windows") {
[17:40:58.446]                 old_names <- names(...future.oldEnvVars)
[17:40:58.446]                 envs <- base::Sys.getenv()
[17:40:58.446]                 names <- names(envs)
[17:40:58.446]                 common <- intersect(names, old_names)
[17:40:58.446]                 added <- setdiff(names, old_names)
[17:40:58.446]                 removed <- setdiff(old_names, names)
[17:40:58.446]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.446]                   envs[common]]
[17:40:58.446]                 NAMES <- toupper(changed)
[17:40:58.446]                 args <- list()
[17:40:58.446]                 for (kk in seq_along(NAMES)) {
[17:40:58.446]                   name <- changed[[kk]]
[17:40:58.446]                   NAME <- NAMES[[kk]]
[17:40:58.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.446]                     next
[17:40:58.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.446]                 }
[17:40:58.446]                 NAMES <- toupper(added)
[17:40:58.446]                 for (kk in seq_along(NAMES)) {
[17:40:58.446]                   name <- added[[kk]]
[17:40:58.446]                   NAME <- NAMES[[kk]]
[17:40:58.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.446]                     next
[17:40:58.446]                   args[[name]] <- ""
[17:40:58.446]                 }
[17:40:58.446]                 NAMES <- toupper(removed)
[17:40:58.446]                 for (kk in seq_along(NAMES)) {
[17:40:58.446]                   name <- removed[[kk]]
[17:40:58.446]                   NAME <- NAMES[[kk]]
[17:40:58.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.446]                     next
[17:40:58.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.446]                 }
[17:40:58.446]                 if (length(args) > 0) 
[17:40:58.446]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.446]             }
[17:40:58.446]             else {
[17:40:58.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.446]             }
[17:40:58.446]             {
[17:40:58.446]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.446]                   0L) {
[17:40:58.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.446]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.446]                   base::options(opts)
[17:40:58.446]                 }
[17:40:58.446]                 {
[17:40:58.446]                   {
[17:40:58.446]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.446]                     NULL
[17:40:58.446]                   }
[17:40:58.446]                   options(future.plan = NULL)
[17:40:58.446]                   if (is.na(NA_character_)) 
[17:40:58.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.446]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:58.446]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:58.446]                     envir = parent.frame()) 
[17:40:58.446]                   {
[17:40:58.446]                     if (is.function(workers)) 
[17:40:58.446]                       workers <- workers()
[17:40:58.446]                     workers <- structure(as.integer(workers), 
[17:40:58.446]                       class = class(workers))
[17:40:58.446]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:58.446]                       workers >= 1)
[17:40:58.446]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:58.446]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:58.446]                     }
[17:40:58.446]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:58.446]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:58.446]                       envir = envir)
[17:40:58.446]                     if (!future$lazy) 
[17:40:58.446]                       future <- run(future)
[17:40:58.446]                     invisible(future)
[17:40:58.446]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:58.446]                 }
[17:40:58.446]             }
[17:40:58.446]         }
[17:40:58.446]     })
[17:40:58.446]     if (TRUE) {
[17:40:58.446]         base::sink(type = "output", split = FALSE)
[17:40:58.446]         if (TRUE) {
[17:40:58.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.446]         }
[17:40:58.446]         else {
[17:40:58.446]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.446]         }
[17:40:58.446]         base::close(...future.stdout)
[17:40:58.446]         ...future.stdout <- NULL
[17:40:58.446]     }
[17:40:58.446]     ...future.result$conditions <- ...future.conditions
[17:40:58.446]     ...future.result$finished <- base::Sys.time()
[17:40:58.446]     ...future.result
[17:40:58.446] }
[17:40:58.449] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[17:40:58.449] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:40:58.491] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:40:58.491] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:40:58.492] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:40:58.492] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:40:58.492] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:40:58.492] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:40:58.535] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:40:58.535] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:40:58.579] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:40:58.579] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:40:58.580] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.580] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:40:58.580] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:40:58.581] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:40:58.581] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.581] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:40:58.581] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:40:58.582] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:40:58.582] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.582] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:40:58.582] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:40:58.583] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[17:40:58.583] MultisessionFuture started
[17:40:58.583] - Launch lazy future ... done
[17:40:58.584] run() for ‘MultisessionFuture’ ... done
[17:40:58.584] Created future:
[17:40:58.584] MultisessionFuture:
[17:40:58.584] Label: ‘future_vapply-2’
[17:40:58.584] Expression:
[17:40:58.584] {
[17:40:58.584]     do.call(function(...) {
[17:40:58.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.584]             on.exit(options(oopts), add = TRUE)
[17:40:58.584]         }
[17:40:58.584]         {
[17:40:58.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.584]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.584]             })
[17:40:58.584]         }
[17:40:58.584]     }, args = future.call.arguments)
[17:40:58.584] }
[17:40:58.584] Lazy evaluation: FALSE
[17:40:58.584] Asynchronous evaluation: TRUE
[17:40:58.584] Local evaluation: TRUE
[17:40:58.584] Environment: R_GlobalEnv
[17:40:58.584] Capture standard output: TRUE
[17:40:58.584] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:58.584] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:58.584] Packages: 1 packages (‘future.apply’)
[17:40:58.584] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:58.584] Resolved: FALSE
[17:40:58.584] Value: <not collected>
[17:40:58.584] Conditions captured: <none>
[17:40:58.584] Early signaling: FALSE
[17:40:58.584] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:58.584] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.596] Chunk #2 of 2 ... DONE
[17:40:58.596] Launching 2 futures (chunks) ... DONE
[17:40:58.596] Resolving 2 futures (chunks) ...
[17:40:58.596] resolve() on list ...
[17:40:58.596]  recursive: 0
[17:40:58.596]  length: 2
[17:40:58.596] 
[17:40:58.597] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.597] - Validating connection of MultisessionFuture
[17:40:58.597] - received message: FutureResult
[17:40:58.597] - Received FutureResult
[17:40:58.597] - Erased future from FutureRegistry
[17:40:58.597] result() for ClusterFuture ...
[17:40:58.598] - result already collected: FutureResult
[17:40:58.598] result() for ClusterFuture ... done
[17:40:58.598] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.598] Future #1
[17:40:58.598] result() for ClusterFuture ...
[17:40:58.598] - result already collected: FutureResult
[17:40:58.598] result() for ClusterFuture ... done
[17:40:58.598] result() for ClusterFuture ...
[17:40:58.598] - result already collected: FutureResult
[17:40:58.598] result() for ClusterFuture ... done
[17:40:58.598] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:40:58.599] - nx: 2
[17:40:58.599] - relay: TRUE
[17:40:58.599] - stdout: TRUE
[17:40:58.599] - signal: TRUE
[17:40:58.599] - resignal: FALSE
[17:40:58.599] - force: TRUE
[17:40:58.599] - relayed: [n=2] FALSE, FALSE
[17:40:58.599] - queued futures: [n=2] FALSE, FALSE
[17:40:58.599]  - until=1
[17:40:58.599]  - relaying element #1
[17:40:58.599] result() for ClusterFuture ...
[17:40:58.599] - result already collected: FutureResult
[17:40:58.600] result() for ClusterFuture ... done
[17:40:58.600] result() for ClusterFuture ...
[17:40:58.600] - result already collected: FutureResult
[17:40:58.600] result() for ClusterFuture ... done
[17:40:58.600] result() for ClusterFuture ...
[17:40:58.600] - result already collected: FutureResult
[17:40:58.600] result() for ClusterFuture ... done
[17:40:58.600] result() for ClusterFuture ...
[17:40:58.600] - result already collected: FutureResult
[17:40:58.600] result() for ClusterFuture ... done
[17:40:58.600] - relayed: [n=2] TRUE, FALSE
[17:40:58.601] - queued futures: [n=2] TRUE, FALSE
[17:40:58.601] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:40:58.601]  length: 1 (resolved future 1)
[17:40:58.643] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.643] - Validating connection of MultisessionFuture
[17:40:58.643] - received message: FutureResult
[17:40:58.643] - Received FutureResult
[17:40:58.643] - Erased future from FutureRegistry
[17:40:58.643] result() for ClusterFuture ...
[17:40:58.644] - result already collected: FutureResult
[17:40:58.644] result() for ClusterFuture ... done
[17:40:58.644] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.644] Future #2
[17:40:58.644] result() for ClusterFuture ...
[17:40:58.644] - result already collected: FutureResult
[17:40:58.644] result() for ClusterFuture ... done
[17:40:58.644] result() for ClusterFuture ...
[17:40:58.644] - result already collected: FutureResult
[17:40:58.644] result() for ClusterFuture ... done
[17:40:58.644] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:40:58.644] - nx: 2
[17:40:58.645] - relay: TRUE
[17:40:58.645] - stdout: TRUE
[17:40:58.645] - signal: TRUE
[17:40:58.645] - resignal: FALSE
[17:40:58.645] - force: TRUE
[17:40:58.645] - relayed: [n=2] TRUE, FALSE
[17:40:58.645] - queued futures: [n=2] TRUE, FALSE
[17:40:58.645]  - until=2
[17:40:58.645]  - relaying element #2
[17:40:58.645] result() for ClusterFuture ...
[17:40:58.645] - result already collected: FutureResult
[17:40:58.645] result() for ClusterFuture ... done
[17:40:58.646] result() for ClusterFuture ...
[17:40:58.646] - result already collected: FutureResult
[17:40:58.646] result() for ClusterFuture ... done
[17:40:58.646] result() for ClusterFuture ...
[17:40:58.646] - result already collected: FutureResult
[17:40:58.646] result() for ClusterFuture ... done
[17:40:58.646] result() for ClusterFuture ...
[17:40:58.646] - result already collected: FutureResult
[17:40:58.646] result() for ClusterFuture ... done
[17:40:58.646] - relayed: [n=2] TRUE, TRUE
[17:40:58.646] - queued futures: [n=2] TRUE, TRUE
[17:40:58.646] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:40:58.647]  length: 0 (resolved future 2)
[17:40:58.647] Relaying remaining futures
[17:40:58.647] signalConditionsASAP(NULL, pos=0) ...
[17:40:58.647] - nx: 2
[17:40:58.647] - relay: TRUE
[17:40:58.647] - stdout: TRUE
[17:40:58.647] - signal: TRUE
[17:40:58.647] - resignal: FALSE
[17:40:58.647] - force: TRUE
[17:40:58.647] - relayed: [n=2] TRUE, TRUE
[17:40:58.647] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:58.648] - relayed: [n=2] TRUE, TRUE
[17:40:58.648] - queued futures: [n=2] TRUE, TRUE
[17:40:58.648] signalConditionsASAP(NULL, pos=0) ... done
[17:40:58.648] resolve() on list ... DONE
[17:40:58.648] result() for ClusterFuture ...
[17:40:58.648] - result already collected: FutureResult
[17:40:58.648] result() for ClusterFuture ... done
[17:40:58.648] result() for ClusterFuture ...
[17:40:58.648] - result already collected: FutureResult
[17:40:58.648] result() for ClusterFuture ... done
[17:40:58.648] result() for ClusterFuture ...
[17:40:58.648] - result already collected: FutureResult
[17:40:58.649] result() for ClusterFuture ... done
[17:40:58.649] result() for ClusterFuture ...
[17:40:58.649] - result already collected: FutureResult
[17:40:58.649] result() for ClusterFuture ... done
[17:40:58.649]  - Number of value chunks collected: 2
[17:40:58.649] Resolving 2 futures (chunks) ... DONE
[17:40:58.649] Reducing values from 2 chunks ...
[17:40:58.649]  - Number of values collected after concatenation: 10
[17:40:58.649]  - Number of values expected: 10
[17:40:58.649] Reducing values from 2 chunks ... DONE
[17:40:58.649] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:40:58.650] future_lapply() ...
[17:40:58.655] Number of chunks: 2
[17:40:58.656] getGlobalsAndPackagesXApply() ...
[17:40:58.656]  - future.globals: TRUE
[17:40:58.656] getGlobalsAndPackages() ...
[17:40:58.656] Searching for globals...
[17:40:58.659] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:40:58.659] Searching for globals ... DONE
[17:40:58.659] Resolving globals: FALSE
[17:40:58.660] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:40:58.660] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:58.660] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:58.661] - packages: [1] ‘future.apply’
[17:40:58.661] getGlobalsAndPackages() ... DONE
[17:40:58.661]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:58.661]  - needed namespaces: [n=1] ‘future.apply’
[17:40:58.661] Finding globals ... DONE
[17:40:58.661]  - use_args: TRUE
[17:40:58.661]  - Getting '...' globals ...
[17:40:58.661] resolve() on list ...
[17:40:58.661]  recursive: 0
[17:40:58.662]  length: 1
[17:40:58.662]  elements: ‘...’
[17:40:58.662]  length: 0 (resolved future 1)
[17:40:58.662] resolve() on list ... DONE
[17:40:58.662]    - '...' content: [n=0] 
[17:40:58.662] List of 1
[17:40:58.662]  $ ...: list()
[17:40:58.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:58.662]  - attr(*, "where")=List of 1
[17:40:58.662]   ..$ ...:<environment: 0x564f311121b8> 
[17:40:58.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:58.662]  - attr(*, "resolved")= logi TRUE
[17:40:58.662]  - attr(*, "total_size")= num NA
[17:40:58.665]  - Getting '...' globals ... DONE
[17:40:58.665] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:58.665] List of 8
[17:40:58.665]  $ ...future.FUN:function (x, ...)  
[17:40:58.665]  $ x_FUN        :function (x)  
[17:40:58.665]  $ times        : int 1
[17:40:58.665]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:58.665]  $ stop_if_not  :function (...)  
[17:40:58.665]  $ dim          : NULL
[17:40:58.665]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:58.665]  $ ...          : list()
[17:40:58.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:58.665]  - attr(*, "where")=List of 8
[17:40:58.665]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:58.665]   ..$ ...          :<environment: 0x564f311121b8> 
[17:40:58.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:58.665]  - attr(*, "resolved")= logi FALSE
[17:40:58.665]  - attr(*, "total_size")= num 94336
[17:40:58.670] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:58.670] getGlobalsAndPackagesXApply() ... DONE
[17:40:58.671] Number of futures (= number of chunks): 2
[17:40:58.671] Launching 2 futures (chunks) ...
[17:40:58.671] Chunk #1 of 2 ...
[17:40:58.671]  - Finding globals in 'X' for chunk #1 ...
[17:40:58.671] getGlobalsAndPackages() ...
[17:40:58.671] Searching for globals...
[17:40:58.671] 
[17:40:58.671] Searching for globals ... DONE
[17:40:58.672] - globals: [0] <none>
[17:40:58.672] getGlobalsAndPackages() ... DONE
[17:40:58.672]    + additional globals found: [n=0] 
[17:40:58.672]    + additional namespaces needed: [n=0] 
[17:40:58.672]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:58.672]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:58.672]  - seeds: <none>
[17:40:58.672] getGlobalsAndPackages() ...
[17:40:58.672] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.672] Resolving globals: FALSE
[17:40:58.673] Tweak future expression to call with '...' arguments ...
[17:40:58.673] {
[17:40:58.673]     do.call(function(...) {
[17:40:58.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.673]             on.exit(options(oopts), add = TRUE)
[17:40:58.673]         }
[17:40:58.673]         {
[17:40:58.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.673]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.673]             })
[17:40:58.673]         }
[17:40:58.673]     }, args = future.call.arguments)
[17:40:58.673] }
[17:40:58.673] Tweak future expression to call with '...' arguments ... DONE
[17:40:58.673] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.674] - packages: [1] ‘future.apply’
[17:40:58.674] getGlobalsAndPackages() ... DONE
[17:40:58.674] run() for ‘Future’ ...
[17:40:58.674] - state: ‘created’
[17:40:58.674] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.689] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.689]   - Field: ‘node’
[17:40:58.689]   - Field: ‘label’
[17:40:58.689]   - Field: ‘local’
[17:40:58.690]   - Field: ‘owner’
[17:40:58.690]   - Field: ‘envir’
[17:40:58.690]   - Field: ‘workers’
[17:40:58.690]   - Field: ‘packages’
[17:40:58.690]   - Field: ‘gc’
[17:40:58.690]   - Field: ‘conditions’
[17:40:58.690]   - Field: ‘persistent’
[17:40:58.690]   - Field: ‘expr’
[17:40:58.690]   - Field: ‘uuid’
[17:40:58.690]   - Field: ‘seed’
[17:40:58.691]   - Field: ‘version’
[17:40:58.691]   - Field: ‘result’
[17:40:58.691]   - Field: ‘asynchronous’
[17:40:58.691]   - Field: ‘calls’
[17:40:58.691]   - Field: ‘globals’
[17:40:58.691]   - Field: ‘stdout’
[17:40:58.691]   - Field: ‘earlySignal’
[17:40:58.691]   - Field: ‘lazy’
[17:40:58.691]   - Field: ‘state’
[17:40:58.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.692] - Launch lazy future ...
[17:40:58.692] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:58.692] Packages needed by future strategies (n = 0): <none>
[17:40:58.692] {
[17:40:58.692]     {
[17:40:58.692]         {
[17:40:58.692]             ...future.startTime <- base::Sys.time()
[17:40:58.692]             {
[17:40:58.692]                 {
[17:40:58.692]                   {
[17:40:58.692]                     {
[17:40:58.692]                       {
[17:40:58.692]                         base::local({
[17:40:58.692]                           has_future <- base::requireNamespace("future", 
[17:40:58.692]                             quietly = TRUE)
[17:40:58.692]                           if (has_future) {
[17:40:58.692]                             ns <- base::getNamespace("future")
[17:40:58.692]                             version <- ns[[".package"]][["version"]]
[17:40:58.692]                             if (is.null(version)) 
[17:40:58.692]                               version <- utils::packageVersion("future")
[17:40:58.692]                           }
[17:40:58.692]                           else {
[17:40:58.692]                             version <- NULL
[17:40:58.692]                           }
[17:40:58.692]                           if (!has_future || version < "1.8.0") {
[17:40:58.692]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.692]                               "", base::R.version$version.string), 
[17:40:58.692]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:58.692]                                 base::R.version$platform, 8 * 
[17:40:58.692]                                   base::.Machine$sizeof.pointer), 
[17:40:58.692]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.692]                                 "release", "version")], collapse = " "), 
[17:40:58.692]                               hostname = base::Sys.info()[["nodename"]])
[17:40:58.692]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.692]                               info)
[17:40:58.692]                             info <- base::paste(info, collapse = "; ")
[17:40:58.692]                             if (!has_future) {
[17:40:58.692]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.692]                                 info)
[17:40:58.692]                             }
[17:40:58.692]                             else {
[17:40:58.692]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.692]                                 info, version)
[17:40:58.692]                             }
[17:40:58.692]                             base::stop(msg)
[17:40:58.692]                           }
[17:40:58.692]                         })
[17:40:58.692]                       }
[17:40:58.692]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.692]                       base::options(mc.cores = 1L)
[17:40:58.692]                     }
[17:40:58.692]                     base::local({
[17:40:58.692]                       for (pkg in "future.apply") {
[17:40:58.692]                         base::loadNamespace(pkg)
[17:40:58.692]                         base::library(pkg, character.only = TRUE)
[17:40:58.692]                       }
[17:40:58.692]                     })
[17:40:58.692]                   }
[17:40:58.692]                   options(future.plan = NULL)
[17:40:58.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.692]                 }
[17:40:58.692]                 ...future.workdir <- getwd()
[17:40:58.692]             }
[17:40:58.692]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.692]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.692]         }
[17:40:58.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.692]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:58.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.692]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.692]             base::names(...future.oldOptions))
[17:40:58.692]     }
[17:40:58.692]     if (FALSE) {
[17:40:58.692]     }
[17:40:58.692]     else {
[17:40:58.692]         if (TRUE) {
[17:40:58.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.692]                 open = "w")
[17:40:58.692]         }
[17:40:58.692]         else {
[17:40:58.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.692]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.692]         }
[17:40:58.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.692]             base::sink(type = "output", split = FALSE)
[17:40:58.692]             base::close(...future.stdout)
[17:40:58.692]         }, add = TRUE)
[17:40:58.692]     }
[17:40:58.692]     ...future.frame <- base::sys.nframe()
[17:40:58.692]     ...future.conditions <- base::list()
[17:40:58.692]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.692]     if (FALSE) {
[17:40:58.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.692]     }
[17:40:58.692]     ...future.result <- base::tryCatch({
[17:40:58.692]         base::withCallingHandlers({
[17:40:58.692]             ...future.value <- base::withVisible(base::local({
[17:40:58.692]                 ...future.makeSendCondition <- local({
[17:40:58.692]                   sendCondition <- NULL
[17:40:58.692]                   function(frame = 1L) {
[17:40:58.692]                     if (is.function(sendCondition)) 
[17:40:58.692]                       return(sendCondition)
[17:40:58.692]                     ns <- getNamespace("parallel")
[17:40:58.692]                     if (exists("sendData", mode = "function", 
[17:40:58.692]                       envir = ns)) {
[17:40:58.692]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.692]                         envir = ns)
[17:40:58.692]                       envir <- sys.frame(frame)
[17:40:58.692]                       master <- NULL
[17:40:58.692]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.692]                         !identical(envir, emptyenv())) {
[17:40:58.692]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.692]                           inherits = FALSE)) {
[17:40:58.692]                           master <- get("master", mode = "list", 
[17:40:58.692]                             envir = envir, inherits = FALSE)
[17:40:58.692]                           if (inherits(master, c("SOCKnode", 
[17:40:58.692]                             "SOCK0node"))) {
[17:40:58.692]                             sendCondition <<- function(cond) {
[17:40:58.692]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.692]                                 success = TRUE)
[17:40:58.692]                               parallel_sendData(master, data)
[17:40:58.692]                             }
[17:40:58.692]                             return(sendCondition)
[17:40:58.692]                           }
[17:40:58.692]                         }
[17:40:58.692]                         frame <- frame + 1L
[17:40:58.692]                         envir <- sys.frame(frame)
[17:40:58.692]                       }
[17:40:58.692]                     }
[17:40:58.692]                     sendCondition <<- function(cond) NULL
[17:40:58.692]                   }
[17:40:58.692]                 })
[17:40:58.692]                 withCallingHandlers({
[17:40:58.692]                   {
[17:40:58.692]                     do.call(function(...) {
[17:40:58.692]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.692]                       if (!identical(...future.globals.maxSize.org, 
[17:40:58.692]                         ...future.globals.maxSize)) {
[17:40:58.692]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.692]                         on.exit(options(oopts), add = TRUE)
[17:40:58.692]                       }
[17:40:58.692]                       {
[17:40:58.692]                         lapply(seq_along(...future.elements_ii), 
[17:40:58.692]                           FUN = function(jj) {
[17:40:58.692]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.692]                             ...future.FUN(...future.X_jj, ...)
[17:40:58.692]                           })
[17:40:58.692]                       }
[17:40:58.692]                     }, args = future.call.arguments)
[17:40:58.692]                   }
[17:40:58.692]                 }, immediateCondition = function(cond) {
[17:40:58.692]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.692]                   sendCondition(cond)
[17:40:58.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.692]                   {
[17:40:58.692]                     inherits <- base::inherits
[17:40:58.692]                     invokeRestart <- base::invokeRestart
[17:40:58.692]                     is.null <- base::is.null
[17:40:58.692]                     muffled <- FALSE
[17:40:58.692]                     if (inherits(cond, "message")) {
[17:40:58.692]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.692]                       if (muffled) 
[17:40:58.692]                         invokeRestart("muffleMessage")
[17:40:58.692]                     }
[17:40:58.692]                     else if (inherits(cond, "warning")) {
[17:40:58.692]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.692]                       if (muffled) 
[17:40:58.692]                         invokeRestart("muffleWarning")
[17:40:58.692]                     }
[17:40:58.692]                     else if (inherits(cond, "condition")) {
[17:40:58.692]                       if (!is.null(pattern)) {
[17:40:58.692]                         computeRestarts <- base::computeRestarts
[17:40:58.692]                         grepl <- base::grepl
[17:40:58.692]                         restarts <- computeRestarts(cond)
[17:40:58.692]                         for (restart in restarts) {
[17:40:58.692]                           name <- restart$name
[17:40:58.692]                           if (is.null(name)) 
[17:40:58.692]                             next
[17:40:58.692]                           if (!grepl(pattern, name)) 
[17:40:58.692]                             next
[17:40:58.692]                           invokeRestart(restart)
[17:40:58.692]                           muffled <- TRUE
[17:40:58.692]                           break
[17:40:58.692]                         }
[17:40:58.692]                       }
[17:40:58.692]                     }
[17:40:58.692]                     invisible(muffled)
[17:40:58.692]                   }
[17:40:58.692]                   muffleCondition(cond)
[17:40:58.692]                 })
[17:40:58.692]             }))
[17:40:58.692]             future::FutureResult(value = ...future.value$value, 
[17:40:58.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.692]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.692]                     ...future.globalenv.names))
[17:40:58.692]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.692]         }, condition = base::local({
[17:40:58.692]             c <- base::c
[17:40:58.692]             inherits <- base::inherits
[17:40:58.692]             invokeRestart <- base::invokeRestart
[17:40:58.692]             length <- base::length
[17:40:58.692]             list <- base::list
[17:40:58.692]             seq.int <- base::seq.int
[17:40:58.692]             signalCondition <- base::signalCondition
[17:40:58.692]             sys.calls <- base::sys.calls
[17:40:58.692]             `[[` <- base::`[[`
[17:40:58.692]             `+` <- base::`+`
[17:40:58.692]             `<<-` <- base::`<<-`
[17:40:58.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.692]                   3L)]
[17:40:58.692]             }
[17:40:58.692]             function(cond) {
[17:40:58.692]                 is_error <- inherits(cond, "error")
[17:40:58.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.692]                   NULL)
[17:40:58.692]                 if (is_error) {
[17:40:58.692]                   sessionInformation <- function() {
[17:40:58.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.692]                       search = base::search(), system = base::Sys.info())
[17:40:58.692]                   }
[17:40:58.692]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.692]                     cond$call), session = sessionInformation(), 
[17:40:58.692]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.692]                   signalCondition(cond)
[17:40:58.692]                 }
[17:40:58.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.692]                 "immediateCondition"))) {
[17:40:58.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.692]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.692]                   if (TRUE && !signal) {
[17:40:58.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.692]                     {
[17:40:58.692]                       inherits <- base::inherits
[17:40:58.692]                       invokeRestart <- base::invokeRestart
[17:40:58.692]                       is.null <- base::is.null
[17:40:58.692]                       muffled <- FALSE
[17:40:58.692]                       if (inherits(cond, "message")) {
[17:40:58.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.692]                         if (muffled) 
[17:40:58.692]                           invokeRestart("muffleMessage")
[17:40:58.692]                       }
[17:40:58.692]                       else if (inherits(cond, "warning")) {
[17:40:58.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.692]                         if (muffled) 
[17:40:58.692]                           invokeRestart("muffleWarning")
[17:40:58.692]                       }
[17:40:58.692]                       else if (inherits(cond, "condition")) {
[17:40:58.692]                         if (!is.null(pattern)) {
[17:40:58.692]                           computeRestarts <- base::computeRestarts
[17:40:58.692]                           grepl <- base::grepl
[17:40:58.692]                           restarts <- computeRestarts(cond)
[17:40:58.692]                           for (restart in restarts) {
[17:40:58.692]                             name <- restart$name
[17:40:58.692]                             if (is.null(name)) 
[17:40:58.692]                               next
[17:40:58.692]                             if (!grepl(pattern, name)) 
[17:40:58.692]                               next
[17:40:58.692]                             invokeRestart(restart)
[17:40:58.692]                             muffled <- TRUE
[17:40:58.692]                             break
[17:40:58.692]                           }
[17:40:58.692]                         }
[17:40:58.692]                       }
[17:40:58.692]                       invisible(muffled)
[17:40:58.692]                     }
[17:40:58.692]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.692]                   }
[17:40:58.692]                 }
[17:40:58.692]                 else {
[17:40:58.692]                   if (TRUE) {
[17:40:58.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.692]                     {
[17:40:58.692]                       inherits <- base::inherits
[17:40:58.692]                       invokeRestart <- base::invokeRestart
[17:40:58.692]                       is.null <- base::is.null
[17:40:58.692]                       muffled <- FALSE
[17:40:58.692]                       if (inherits(cond, "message")) {
[17:40:58.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.692]                         if (muffled) 
[17:40:58.692]                           invokeRestart("muffleMessage")
[17:40:58.692]                       }
[17:40:58.692]                       else if (inherits(cond, "warning")) {
[17:40:58.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.692]                         if (muffled) 
[17:40:58.692]                           invokeRestart("muffleWarning")
[17:40:58.692]                       }
[17:40:58.692]                       else if (inherits(cond, "condition")) {
[17:40:58.692]                         if (!is.null(pattern)) {
[17:40:58.692]                           computeRestarts <- base::computeRestarts
[17:40:58.692]                           grepl <- base::grepl
[17:40:58.692]                           restarts <- computeRestarts(cond)
[17:40:58.692]                           for (restart in restarts) {
[17:40:58.692]                             name <- restart$name
[17:40:58.692]                             if (is.null(name)) 
[17:40:58.692]                               next
[17:40:58.692]                             if (!grepl(pattern, name)) 
[17:40:58.692]                               next
[17:40:58.692]                             invokeRestart(restart)
[17:40:58.692]                             muffled <- TRUE
[17:40:58.692]                             break
[17:40:58.692]                           }
[17:40:58.692]                         }
[17:40:58.692]                       }
[17:40:58.692]                       invisible(muffled)
[17:40:58.692]                     }
[17:40:58.692]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.692]                   }
[17:40:58.692]                 }
[17:40:58.692]             }
[17:40:58.692]         }))
[17:40:58.692]     }, error = function(ex) {
[17:40:58.692]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.692]                 ...future.rng), started = ...future.startTime, 
[17:40:58.692]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.692]             version = "1.8"), class = "FutureResult")
[17:40:58.692]     }, finally = {
[17:40:58.692]         if (!identical(...future.workdir, getwd())) 
[17:40:58.692]             setwd(...future.workdir)
[17:40:58.692]         {
[17:40:58.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.692]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.692]             }
[17:40:58.692]             base::options(...future.oldOptions)
[17:40:58.692]             if (.Platform$OS.type == "windows") {
[17:40:58.692]                 old_names <- names(...future.oldEnvVars)
[17:40:58.692]                 envs <- base::Sys.getenv()
[17:40:58.692]                 names <- names(envs)
[17:40:58.692]                 common <- intersect(names, old_names)
[17:40:58.692]                 added <- setdiff(names, old_names)
[17:40:58.692]                 removed <- setdiff(old_names, names)
[17:40:58.692]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.692]                   envs[common]]
[17:40:58.692]                 NAMES <- toupper(changed)
[17:40:58.692]                 args <- list()
[17:40:58.692]                 for (kk in seq_along(NAMES)) {
[17:40:58.692]                   name <- changed[[kk]]
[17:40:58.692]                   NAME <- NAMES[[kk]]
[17:40:58.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.692]                     next
[17:40:58.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.692]                 }
[17:40:58.692]                 NAMES <- toupper(added)
[17:40:58.692]                 for (kk in seq_along(NAMES)) {
[17:40:58.692]                   name <- added[[kk]]
[17:40:58.692]                   NAME <- NAMES[[kk]]
[17:40:58.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.692]                     next
[17:40:58.692]                   args[[name]] <- ""
[17:40:58.692]                 }
[17:40:58.692]                 NAMES <- toupper(removed)
[17:40:58.692]                 for (kk in seq_along(NAMES)) {
[17:40:58.692]                   name <- removed[[kk]]
[17:40:58.692]                   NAME <- NAMES[[kk]]
[17:40:58.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.692]                     next
[17:40:58.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.692]                 }
[17:40:58.692]                 if (length(args) > 0) 
[17:40:58.692]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.692]             }
[17:40:58.692]             else {
[17:40:58.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.692]             }
[17:40:58.692]             {
[17:40:58.692]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.692]                   0L) {
[17:40:58.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.692]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.692]                   base::options(opts)
[17:40:58.692]                 }
[17:40:58.692]                 {
[17:40:58.692]                   {
[17:40:58.692]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.692]                     NULL
[17:40:58.692]                   }
[17:40:58.692]                   options(future.plan = NULL)
[17:40:58.692]                   if (is.na(NA_character_)) 
[17:40:58.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.692]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:58.692]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:58.692]                     envir = parent.frame()) 
[17:40:58.692]                   {
[17:40:58.692]                     if (is.function(workers)) 
[17:40:58.692]                       workers <- workers()
[17:40:58.692]                     workers <- structure(as.integer(workers), 
[17:40:58.692]                       class = class(workers))
[17:40:58.692]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:58.692]                       workers >= 1)
[17:40:58.692]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:58.692]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:58.692]                     }
[17:40:58.692]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:58.692]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:58.692]                       envir = envir)
[17:40:58.692]                     if (!future$lazy) 
[17:40:58.692]                       future <- run(future)
[17:40:58.692]                     invisible(future)
[17:40:58.692]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:58.692]                 }
[17:40:58.692]             }
[17:40:58.692]         }
[17:40:58.692]     })
[17:40:58.692]     if (TRUE) {
[17:40:58.692]         base::sink(type = "output", split = FALSE)
[17:40:58.692]         if (TRUE) {
[17:40:58.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.692]         }
[17:40:58.692]         else {
[17:40:58.692]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.692]         }
[17:40:58.692]         base::close(...future.stdout)
[17:40:58.692]         ...future.stdout <- NULL
[17:40:58.692]     }
[17:40:58.692]     ...future.result$conditions <- ...future.conditions
[17:40:58.692]     ...future.result$finished <- base::Sys.time()
[17:40:58.692]     ...future.result
[17:40:58.692] }
[17:40:58.695] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[17:40:58.696] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:40:58.739] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:40:58.739] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:40:58.740] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:40:58.740] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:40:58.740] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:40:58.740] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:40:58.783] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:40:58.783] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:40:58.827] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:40:58.828] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:40:58.828] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.828] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:40:58.829] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:40:58.829] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:40:58.829] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.830] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:40:58.833] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:40:58.833] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:40:58.833] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.833] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:40:58.834] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:40:58.834] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[17:40:58.834] MultisessionFuture started
[17:40:58.835] - Launch lazy future ... done
[17:40:58.835] run() for ‘MultisessionFuture’ ... done
[17:40:58.835] Created future:
[17:40:58.835] MultisessionFuture:
[17:40:58.835] Label: ‘future_vapply-1’
[17:40:58.835] Expression:
[17:40:58.835] {
[17:40:58.835]     do.call(function(...) {
[17:40:58.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.835]             on.exit(options(oopts), add = TRUE)
[17:40:58.835]         }
[17:40:58.835]         {
[17:40:58.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.835]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.835]             })
[17:40:58.835]         }
[17:40:58.835]     }, args = future.call.arguments)
[17:40:58.835] }
[17:40:58.835] Lazy evaluation: FALSE
[17:40:58.835] Asynchronous evaluation: TRUE
[17:40:58.835] Local evaluation: TRUE
[17:40:58.835] Environment: R_GlobalEnv
[17:40:58.835] Capture standard output: TRUE
[17:40:58.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:58.835] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:58.835] Packages: 1 packages (‘future.apply’)
[17:40:58.835] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:58.835] Resolved: FALSE
[17:40:58.835] Value: <not collected>
[17:40:58.835] Conditions captured: <none>
[17:40:58.835] Early signaling: FALSE
[17:40:58.835] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:58.835] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.847] Chunk #1 of 2 ... DONE
[17:40:58.847] Chunk #2 of 2 ...
[17:40:58.847]  - Finding globals in 'X' for chunk #2 ...
[17:40:58.847] getGlobalsAndPackages() ...
[17:40:58.848] Searching for globals...
[17:40:58.848] 
[17:40:58.848] Searching for globals ... DONE
[17:40:58.848] - globals: [0] <none>
[17:40:58.848] getGlobalsAndPackages() ... DONE
[17:40:58.848]    + additional globals found: [n=0] 
[17:40:58.848]    + additional namespaces needed: [n=0] 
[17:40:58.848]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:58.848]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:58.849]  - seeds: <none>
[17:40:58.849] getGlobalsAndPackages() ...
[17:40:58.849] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.849] Resolving globals: FALSE
[17:40:58.849] Tweak future expression to call with '...' arguments ...
[17:40:58.849] {
[17:40:58.849]     do.call(function(...) {
[17:40:58.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:58.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.849]             on.exit(options(oopts), add = TRUE)
[17:40:58.849]         }
[17:40:58.849]         {
[17:40:58.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:58.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.849]                 ...future.FUN(...future.X_jj, ...)
[17:40:58.849]             })
[17:40:58.849]         }
[17:40:58.849]     }, args = future.call.arguments)
[17:40:58.849] }
[17:40:58.849] Tweak future expression to call with '...' arguments ... DONE
[17:40:58.850] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:58.850] - packages: [1] ‘future.apply’
[17:40:58.850] getGlobalsAndPackages() ... DONE
[17:40:58.850] run() for ‘Future’ ...
[17:40:58.851] - state: ‘created’
[17:40:58.851] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.865] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.865]   - Field: ‘node’
[17:40:58.865]   - Field: ‘label’
[17:40:58.865]   - Field: ‘local’
[17:40:58.866]   - Field: ‘owner’
[17:40:58.866]   - Field: ‘envir’
[17:40:58.866]   - Field: ‘workers’
[17:40:58.866]   - Field: ‘packages’
[17:40:58.866]   - Field: ‘gc’
[17:40:58.866]   - Field: ‘conditions’
[17:40:58.866]   - Field: ‘persistent’
[17:40:58.866]   - Field: ‘expr’
[17:40:58.866]   - Field: ‘uuid’
[17:40:58.866]   - Field: ‘seed’
[17:40:58.866]   - Field: ‘version’
[17:40:58.867]   - Field: ‘result’
[17:40:58.867]   - Field: ‘asynchronous’
[17:40:58.867]   - Field: ‘calls’
[17:40:58.867]   - Field: ‘globals’
[17:40:58.867]   - Field: ‘stdout’
[17:40:58.867]   - Field: ‘earlySignal’
[17:40:58.867]   - Field: ‘lazy’
[17:40:58.867]   - Field: ‘state’
[17:40:58.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.867] - Launch lazy future ...
[17:40:58.868] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:58.868] Packages needed by future strategies (n = 0): <none>
[17:40:58.868] {
[17:40:58.868]     {
[17:40:58.868]         {
[17:40:58.868]             ...future.startTime <- base::Sys.time()
[17:40:58.868]             {
[17:40:58.868]                 {
[17:40:58.868]                   {
[17:40:58.868]                     {
[17:40:58.868]                       {
[17:40:58.868]                         base::local({
[17:40:58.868]                           has_future <- base::requireNamespace("future", 
[17:40:58.868]                             quietly = TRUE)
[17:40:58.868]                           if (has_future) {
[17:40:58.868]                             ns <- base::getNamespace("future")
[17:40:58.868]                             version <- ns[[".package"]][["version"]]
[17:40:58.868]                             if (is.null(version)) 
[17:40:58.868]                               version <- utils::packageVersion("future")
[17:40:58.868]                           }
[17:40:58.868]                           else {
[17:40:58.868]                             version <- NULL
[17:40:58.868]                           }
[17:40:58.868]                           if (!has_future || version < "1.8.0") {
[17:40:58.868]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.868]                               "", base::R.version$version.string), 
[17:40:58.868]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:58.868]                                 base::R.version$platform, 8 * 
[17:40:58.868]                                   base::.Machine$sizeof.pointer), 
[17:40:58.868]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.868]                                 "release", "version")], collapse = " "), 
[17:40:58.868]                               hostname = base::Sys.info()[["nodename"]])
[17:40:58.868]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.868]                               info)
[17:40:58.868]                             info <- base::paste(info, collapse = "; ")
[17:40:58.868]                             if (!has_future) {
[17:40:58.868]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.868]                                 info)
[17:40:58.868]                             }
[17:40:58.868]                             else {
[17:40:58.868]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.868]                                 info, version)
[17:40:58.868]                             }
[17:40:58.868]                             base::stop(msg)
[17:40:58.868]                           }
[17:40:58.868]                         })
[17:40:58.868]                       }
[17:40:58.868]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.868]                       base::options(mc.cores = 1L)
[17:40:58.868]                     }
[17:40:58.868]                     base::local({
[17:40:58.868]                       for (pkg in "future.apply") {
[17:40:58.868]                         base::loadNamespace(pkg)
[17:40:58.868]                         base::library(pkg, character.only = TRUE)
[17:40:58.868]                       }
[17:40:58.868]                     })
[17:40:58.868]                   }
[17:40:58.868]                   options(future.plan = NULL)
[17:40:58.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.868]                 }
[17:40:58.868]                 ...future.workdir <- getwd()
[17:40:58.868]             }
[17:40:58.868]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.868]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.868]         }
[17:40:58.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.868]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:58.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.868]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.868]             base::names(...future.oldOptions))
[17:40:58.868]     }
[17:40:58.868]     if (FALSE) {
[17:40:58.868]     }
[17:40:58.868]     else {
[17:40:58.868]         if (TRUE) {
[17:40:58.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.868]                 open = "w")
[17:40:58.868]         }
[17:40:58.868]         else {
[17:40:58.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.868]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.868]         }
[17:40:58.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.868]             base::sink(type = "output", split = FALSE)
[17:40:58.868]             base::close(...future.stdout)
[17:40:58.868]         }, add = TRUE)
[17:40:58.868]     }
[17:40:58.868]     ...future.frame <- base::sys.nframe()
[17:40:58.868]     ...future.conditions <- base::list()
[17:40:58.868]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.868]     if (FALSE) {
[17:40:58.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.868]     }
[17:40:58.868]     ...future.result <- base::tryCatch({
[17:40:58.868]         base::withCallingHandlers({
[17:40:58.868]             ...future.value <- base::withVisible(base::local({
[17:40:58.868]                 ...future.makeSendCondition <- local({
[17:40:58.868]                   sendCondition <- NULL
[17:40:58.868]                   function(frame = 1L) {
[17:40:58.868]                     if (is.function(sendCondition)) 
[17:40:58.868]                       return(sendCondition)
[17:40:58.868]                     ns <- getNamespace("parallel")
[17:40:58.868]                     if (exists("sendData", mode = "function", 
[17:40:58.868]                       envir = ns)) {
[17:40:58.868]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.868]                         envir = ns)
[17:40:58.868]                       envir <- sys.frame(frame)
[17:40:58.868]                       master <- NULL
[17:40:58.868]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.868]                         !identical(envir, emptyenv())) {
[17:40:58.868]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.868]                           inherits = FALSE)) {
[17:40:58.868]                           master <- get("master", mode = "list", 
[17:40:58.868]                             envir = envir, inherits = FALSE)
[17:40:58.868]                           if (inherits(master, c("SOCKnode", 
[17:40:58.868]                             "SOCK0node"))) {
[17:40:58.868]                             sendCondition <<- function(cond) {
[17:40:58.868]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.868]                                 success = TRUE)
[17:40:58.868]                               parallel_sendData(master, data)
[17:40:58.868]                             }
[17:40:58.868]                             return(sendCondition)
[17:40:58.868]                           }
[17:40:58.868]                         }
[17:40:58.868]                         frame <- frame + 1L
[17:40:58.868]                         envir <- sys.frame(frame)
[17:40:58.868]                       }
[17:40:58.868]                     }
[17:40:58.868]                     sendCondition <<- function(cond) NULL
[17:40:58.868]                   }
[17:40:58.868]                 })
[17:40:58.868]                 withCallingHandlers({
[17:40:58.868]                   {
[17:40:58.868]                     do.call(function(...) {
[17:40:58.868]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:58.868]                       if (!identical(...future.globals.maxSize.org, 
[17:40:58.868]                         ...future.globals.maxSize)) {
[17:40:58.868]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:58.868]                         on.exit(options(oopts), add = TRUE)
[17:40:58.868]                       }
[17:40:58.868]                       {
[17:40:58.868]                         lapply(seq_along(...future.elements_ii), 
[17:40:58.868]                           FUN = function(jj) {
[17:40:58.868]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:58.868]                             ...future.FUN(...future.X_jj, ...)
[17:40:58.868]                           })
[17:40:58.868]                       }
[17:40:58.868]                     }, args = future.call.arguments)
[17:40:58.868]                   }
[17:40:58.868]                 }, immediateCondition = function(cond) {
[17:40:58.868]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.868]                   sendCondition(cond)
[17:40:58.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.868]                   {
[17:40:58.868]                     inherits <- base::inherits
[17:40:58.868]                     invokeRestart <- base::invokeRestart
[17:40:58.868]                     is.null <- base::is.null
[17:40:58.868]                     muffled <- FALSE
[17:40:58.868]                     if (inherits(cond, "message")) {
[17:40:58.868]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.868]                       if (muffled) 
[17:40:58.868]                         invokeRestart("muffleMessage")
[17:40:58.868]                     }
[17:40:58.868]                     else if (inherits(cond, "warning")) {
[17:40:58.868]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.868]                       if (muffled) 
[17:40:58.868]                         invokeRestart("muffleWarning")
[17:40:58.868]                     }
[17:40:58.868]                     else if (inherits(cond, "condition")) {
[17:40:58.868]                       if (!is.null(pattern)) {
[17:40:58.868]                         computeRestarts <- base::computeRestarts
[17:40:58.868]                         grepl <- base::grepl
[17:40:58.868]                         restarts <- computeRestarts(cond)
[17:40:58.868]                         for (restart in restarts) {
[17:40:58.868]                           name <- restart$name
[17:40:58.868]                           if (is.null(name)) 
[17:40:58.868]                             next
[17:40:58.868]                           if (!grepl(pattern, name)) 
[17:40:58.868]                             next
[17:40:58.868]                           invokeRestart(restart)
[17:40:58.868]                           muffled <- TRUE
[17:40:58.868]                           break
[17:40:58.868]                         }
[17:40:58.868]                       }
[17:40:58.868]                     }
[17:40:58.868]                     invisible(muffled)
[17:40:58.868]                   }
[17:40:58.868]                   muffleCondition(cond)
[17:40:58.868]                 })
[17:40:58.868]             }))
[17:40:58.868]             future::FutureResult(value = ...future.value$value, 
[17:40:58.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.868]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.868]                     ...future.globalenv.names))
[17:40:58.868]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.868]         }, condition = base::local({
[17:40:58.868]             c <- base::c
[17:40:58.868]             inherits <- base::inherits
[17:40:58.868]             invokeRestart <- base::invokeRestart
[17:40:58.868]             length <- base::length
[17:40:58.868]             list <- base::list
[17:40:58.868]             seq.int <- base::seq.int
[17:40:58.868]             signalCondition <- base::signalCondition
[17:40:58.868]             sys.calls <- base::sys.calls
[17:40:58.868]             `[[` <- base::`[[`
[17:40:58.868]             `+` <- base::`+`
[17:40:58.868]             `<<-` <- base::`<<-`
[17:40:58.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.868]                   3L)]
[17:40:58.868]             }
[17:40:58.868]             function(cond) {
[17:40:58.868]                 is_error <- inherits(cond, "error")
[17:40:58.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.868]                   NULL)
[17:40:58.868]                 if (is_error) {
[17:40:58.868]                   sessionInformation <- function() {
[17:40:58.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.868]                       search = base::search(), system = base::Sys.info())
[17:40:58.868]                   }
[17:40:58.868]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.868]                     cond$call), session = sessionInformation(), 
[17:40:58.868]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.868]                   signalCondition(cond)
[17:40:58.868]                 }
[17:40:58.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.868]                 "immediateCondition"))) {
[17:40:58.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.868]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.868]                   if (TRUE && !signal) {
[17:40:58.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.868]                     {
[17:40:58.868]                       inherits <- base::inherits
[17:40:58.868]                       invokeRestart <- base::invokeRestart
[17:40:58.868]                       is.null <- base::is.null
[17:40:58.868]                       muffled <- FALSE
[17:40:58.868]                       if (inherits(cond, "message")) {
[17:40:58.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.868]                         if (muffled) 
[17:40:58.868]                           invokeRestart("muffleMessage")
[17:40:58.868]                       }
[17:40:58.868]                       else if (inherits(cond, "warning")) {
[17:40:58.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.868]                         if (muffled) 
[17:40:58.868]                           invokeRestart("muffleWarning")
[17:40:58.868]                       }
[17:40:58.868]                       else if (inherits(cond, "condition")) {
[17:40:58.868]                         if (!is.null(pattern)) {
[17:40:58.868]                           computeRestarts <- base::computeRestarts
[17:40:58.868]                           grepl <- base::grepl
[17:40:58.868]                           restarts <- computeRestarts(cond)
[17:40:58.868]                           for (restart in restarts) {
[17:40:58.868]                             name <- restart$name
[17:40:58.868]                             if (is.null(name)) 
[17:40:58.868]                               next
[17:40:58.868]                             if (!grepl(pattern, name)) 
[17:40:58.868]                               next
[17:40:58.868]                             invokeRestart(restart)
[17:40:58.868]                             muffled <- TRUE
[17:40:58.868]                             break
[17:40:58.868]                           }
[17:40:58.868]                         }
[17:40:58.868]                       }
[17:40:58.868]                       invisible(muffled)
[17:40:58.868]                     }
[17:40:58.868]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.868]                   }
[17:40:58.868]                 }
[17:40:58.868]                 else {
[17:40:58.868]                   if (TRUE) {
[17:40:58.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.868]                     {
[17:40:58.868]                       inherits <- base::inherits
[17:40:58.868]                       invokeRestart <- base::invokeRestart
[17:40:58.868]                       is.null <- base::is.null
[17:40:58.868]                       muffled <- FALSE
[17:40:58.868]                       if (inherits(cond, "message")) {
[17:40:58.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.868]                         if (muffled) 
[17:40:58.868]                           invokeRestart("muffleMessage")
[17:40:58.868]                       }
[17:40:58.868]                       else if (inherits(cond, "warning")) {
[17:40:58.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.868]                         if (muffled) 
[17:40:58.868]                           invokeRestart("muffleWarning")
[17:40:58.868]                       }
[17:40:58.868]                       else if (inherits(cond, "condition")) {
[17:40:58.868]                         if (!is.null(pattern)) {
[17:40:58.868]                           computeRestarts <- base::computeRestarts
[17:40:58.868]                           grepl <- base::grepl
[17:40:58.868]                           restarts <- computeRestarts(cond)
[17:40:58.868]                           for (restart in restarts) {
[17:40:58.868]                             name <- restart$name
[17:40:58.868]                             if (is.null(name)) 
[17:40:58.868]                               next
[17:40:58.868]                             if (!grepl(pattern, name)) 
[17:40:58.868]                               next
[17:40:58.868]                             invokeRestart(restart)
[17:40:58.868]                             muffled <- TRUE
[17:40:58.868]                             break
[17:40:58.868]                           }
[17:40:58.868]                         }
[17:40:58.868]                       }
[17:40:58.868]                       invisible(muffled)
[17:40:58.868]                     }
[17:40:58.868]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.868]                   }
[17:40:58.868]                 }
[17:40:58.868]             }
[17:40:58.868]         }))
[17:40:58.868]     }, error = function(ex) {
[17:40:58.868]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.868]                 ...future.rng), started = ...future.startTime, 
[17:40:58.868]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.868]             version = "1.8"), class = "FutureResult")
[17:40:58.868]     }, finally = {
[17:40:58.868]         if (!identical(...future.workdir, getwd())) 
[17:40:58.868]             setwd(...future.workdir)
[17:40:58.868]         {
[17:40:58.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.868]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.868]             }
[17:40:58.868]             base::options(...future.oldOptions)
[17:40:58.868]             if (.Platform$OS.type == "windows") {
[17:40:58.868]                 old_names <- names(...future.oldEnvVars)
[17:40:58.868]                 envs <- base::Sys.getenv()
[17:40:58.868]                 names <- names(envs)
[17:40:58.868]                 common <- intersect(names, old_names)
[17:40:58.868]                 added <- setdiff(names, old_names)
[17:40:58.868]                 removed <- setdiff(old_names, names)
[17:40:58.868]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.868]                   envs[common]]
[17:40:58.868]                 NAMES <- toupper(changed)
[17:40:58.868]                 args <- list()
[17:40:58.868]                 for (kk in seq_along(NAMES)) {
[17:40:58.868]                   name <- changed[[kk]]
[17:40:58.868]                   NAME <- NAMES[[kk]]
[17:40:58.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.868]                     next
[17:40:58.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.868]                 }
[17:40:58.868]                 NAMES <- toupper(added)
[17:40:58.868]                 for (kk in seq_along(NAMES)) {
[17:40:58.868]                   name <- added[[kk]]
[17:40:58.868]                   NAME <- NAMES[[kk]]
[17:40:58.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.868]                     next
[17:40:58.868]                   args[[name]] <- ""
[17:40:58.868]                 }
[17:40:58.868]                 NAMES <- toupper(removed)
[17:40:58.868]                 for (kk in seq_along(NAMES)) {
[17:40:58.868]                   name <- removed[[kk]]
[17:40:58.868]                   NAME <- NAMES[[kk]]
[17:40:58.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.868]                     next
[17:40:58.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.868]                 }
[17:40:58.868]                 if (length(args) > 0) 
[17:40:58.868]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.868]             }
[17:40:58.868]             else {
[17:40:58.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.868]             }
[17:40:58.868]             {
[17:40:58.868]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.868]                   0L) {
[17:40:58.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.868]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.868]                   base::options(opts)
[17:40:58.868]                 }
[17:40:58.868]                 {
[17:40:58.868]                   {
[17:40:58.868]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.868]                     NULL
[17:40:58.868]                   }
[17:40:58.868]                   options(future.plan = NULL)
[17:40:58.868]                   if (is.na(NA_character_)) 
[17:40:58.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.868]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:58.868]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:58.868]                     envir = parent.frame()) 
[17:40:58.868]                   {
[17:40:58.868]                     if (is.function(workers)) 
[17:40:58.868]                       workers <- workers()
[17:40:58.868]                     workers <- structure(as.integer(workers), 
[17:40:58.868]                       class = class(workers))
[17:40:58.868]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:58.868]                       workers >= 1)
[17:40:58.868]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:58.868]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:58.868]                     }
[17:40:58.868]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:58.868]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:58.868]                       envir = envir)
[17:40:58.868]                     if (!future$lazy) 
[17:40:58.868]                       future <- run(future)
[17:40:58.868]                     invisible(future)
[17:40:58.868]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:58.868]                 }
[17:40:58.868]             }
[17:40:58.868]         }
[17:40:58.868]     })
[17:40:58.868]     if (TRUE) {
[17:40:58.868]         base::sink(type = "output", split = FALSE)
[17:40:58.868]         if (TRUE) {
[17:40:58.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.868]         }
[17:40:58.868]         else {
[17:40:58.868]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.868]         }
[17:40:58.868]         base::close(...future.stdout)
[17:40:58.868]         ...future.stdout <- NULL
[17:40:58.868]     }
[17:40:58.868]     ...future.result$conditions <- ...future.conditions
[17:40:58.868]     ...future.result$finished <- base::Sys.time()
[17:40:58.868]     ...future.result
[17:40:58.868] }
[17:40:58.871] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[17:40:58.871] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:40:58.915] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:40:58.915] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:40:58.916] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:40:58.916] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:40:58.916] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:40:58.916] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:40:58.959] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:40:58.959] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:40:59.003] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:40:59.003] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:40:59.004] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.004] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:40:59.004] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:40:59.004] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:40:59.005] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.005] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:40:59.005] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:40:59.005] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:40:59.006] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.006] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:40:59.006] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.006] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[17:40:59.007] MultisessionFuture started
[17:40:59.007] - Launch lazy future ... done
[17:40:59.007] run() for ‘MultisessionFuture’ ... done
[17:40:59.008] Created future:
[17:40:59.008] MultisessionFuture:
[17:40:59.008] Label: ‘future_vapply-2’
[17:40:59.008] Expression:
[17:40:59.008] {
[17:40:59.008]     do.call(function(...) {
[17:40:59.008]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.008]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.008]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.008]             on.exit(options(oopts), add = TRUE)
[17:40:59.008]         }
[17:40:59.008]         {
[17:40:59.008]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.008]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.008]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.008]             })
[17:40:59.008]         }
[17:40:59.008]     }, args = future.call.arguments)
[17:40:59.008] }
[17:40:59.008] Lazy evaluation: FALSE
[17:40:59.008] Asynchronous evaluation: TRUE
[17:40:59.008] Local evaluation: TRUE
[17:40:59.008] Environment: R_GlobalEnv
[17:40:59.008] Capture standard output: TRUE
[17:40:59.008] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:59.008] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:59.008] Packages: 1 packages (‘future.apply’)
[17:40:59.008] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:59.008] Resolved: FALSE
[17:40:59.008] Value: <not collected>
[17:40:59.008] Conditions captured: <none>
[17:40:59.008] Early signaling: FALSE
[17:40:59.008] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:59.008] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.019] Chunk #2 of 2 ... DONE
[17:40:59.020] Launching 2 futures (chunks) ... DONE
[17:40:59.020] Resolving 2 futures (chunks) ...
[17:40:59.020] resolve() on list ...
[17:40:59.020]  recursive: 0
[17:40:59.020]  length: 2
[17:40:59.020] 
[17:40:59.020] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.021] - Validating connection of MultisessionFuture
[17:40:59.021] - received message: FutureResult
[17:40:59.021] - Received FutureResult
[17:40:59.021] - Erased future from FutureRegistry
[17:40:59.021] result() for ClusterFuture ...
[17:40:59.021] - result already collected: FutureResult
[17:40:59.021] result() for ClusterFuture ... done
[17:40:59.021] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.021] Future #1
[17:40:59.021] result() for ClusterFuture ...
[17:40:59.022] - result already collected: FutureResult
[17:40:59.022] result() for ClusterFuture ... done
[17:40:59.022] result() for ClusterFuture ...
[17:40:59.022] - result already collected: FutureResult
[17:40:59.022] result() for ClusterFuture ... done
[17:40:59.022] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:40:59.022] - nx: 2
[17:40:59.022] - relay: TRUE
[17:40:59.022] - stdout: TRUE
[17:40:59.022] - signal: TRUE
[17:40:59.022] - resignal: FALSE
[17:40:59.022] - force: TRUE
[17:40:59.023] - relayed: [n=2] FALSE, FALSE
[17:40:59.023] - queued futures: [n=2] FALSE, FALSE
[17:40:59.023]  - until=1
[17:40:59.023]  - relaying element #1
[17:40:59.023] result() for ClusterFuture ...
[17:40:59.023] - result already collected: FutureResult
[17:40:59.023] result() for ClusterFuture ... done
[17:40:59.023] result() for ClusterFuture ...
[17:40:59.023] - result already collected: FutureResult
[17:40:59.023] result() for ClusterFuture ... done
[17:40:59.024] result() for ClusterFuture ...
[17:40:59.024] - result already collected: FutureResult
[17:40:59.024] result() for ClusterFuture ... done
[17:40:59.024] result() for ClusterFuture ...
[17:40:59.024] - result already collected: FutureResult
[17:40:59.024] result() for ClusterFuture ... done
[17:40:59.024] - relayed: [n=2] TRUE, FALSE
[17:40:59.024] - queued futures: [n=2] TRUE, FALSE
[17:40:59.024] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:40:59.024]  length: 1 (resolved future 1)
[17:40:59.066] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.066] - Validating connection of MultisessionFuture
[17:40:59.066] - received message: FutureResult
[17:40:59.066] - Received FutureResult
[17:40:59.066] - Erased future from FutureRegistry
[17:40:59.067] result() for ClusterFuture ...
[17:40:59.067] - result already collected: FutureResult
[17:40:59.067] result() for ClusterFuture ... done
[17:40:59.067] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.067] Future #2
[17:40:59.067] result() for ClusterFuture ...
[17:40:59.067] - result already collected: FutureResult
[17:40:59.067] result() for ClusterFuture ... done
[17:40:59.067] result() for ClusterFuture ...
[17:40:59.067] - result already collected: FutureResult
[17:40:59.067] result() for ClusterFuture ... done
[17:40:59.068] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:40:59.068] - nx: 2
[17:40:59.068] - relay: TRUE
[17:40:59.068] - stdout: TRUE
[17:40:59.068] - signal: TRUE
[17:40:59.068] - resignal: FALSE
[17:40:59.068] - force: TRUE
[17:40:59.068] - relayed: [n=2] TRUE, FALSE
[17:40:59.068] - queued futures: [n=2] TRUE, FALSE
[17:40:59.068]  - until=2
[17:40:59.068]  - relaying element #2
[17:40:59.068] result() for ClusterFuture ...
[17:40:59.069] - result already collected: FutureResult
[17:40:59.069] result() for ClusterFuture ... done
[17:40:59.069] result() for ClusterFuture ...
[17:40:59.069] - result already collected: FutureResult
[17:40:59.069] result() for ClusterFuture ... done
[17:40:59.069] result() for ClusterFuture ...
[17:40:59.069] - result already collected: FutureResult
[17:40:59.069] result() for ClusterFuture ... done
[17:40:59.069] result() for ClusterFuture ...
[17:40:59.069] - result already collected: FutureResult
[17:40:59.069] result() for ClusterFuture ... done
[17:40:59.069] - relayed: [n=2] TRUE, TRUE
[17:40:59.070] - queued futures: [n=2] TRUE, TRUE
[17:40:59.070] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:40:59.070]  length: 0 (resolved future 2)
[17:40:59.070] Relaying remaining futures
[17:40:59.070] signalConditionsASAP(NULL, pos=0) ...
[17:40:59.070] - nx: 2
[17:40:59.070] - relay: TRUE
[17:40:59.070] - stdout: TRUE
[17:40:59.070] - signal: TRUE
[17:40:59.070] - resignal: FALSE
[17:40:59.070] - force: TRUE
[17:40:59.070] - relayed: [n=2] TRUE, TRUE
[17:40:59.071] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:59.071] - relayed: [n=2] TRUE, TRUE
[17:40:59.071] - queued futures: [n=2] TRUE, TRUE
[17:40:59.071] signalConditionsASAP(NULL, pos=0) ... done
[17:40:59.071] resolve() on list ... DONE
[17:40:59.071] result() for ClusterFuture ...
[17:40:59.071] - result already collected: FutureResult
[17:40:59.071] result() for ClusterFuture ... done
[17:40:59.071] result() for ClusterFuture ...
[17:40:59.071] - result already collected: FutureResult
[17:40:59.071] result() for ClusterFuture ... done
[17:40:59.072] result() for ClusterFuture ...
[17:40:59.072] - result already collected: FutureResult
[17:40:59.072] result() for ClusterFuture ... done
[17:40:59.072] result() for ClusterFuture ...
[17:40:59.072] - result already collected: FutureResult
[17:40:59.072] result() for ClusterFuture ... done
[17:40:59.072]  - Number of value chunks collected: 2
[17:40:59.072] Resolving 2 futures (chunks) ... DONE
[17:40:59.072] Reducing values from 2 chunks ...
[17:40:59.072]  - Number of values collected after concatenation: 10
[17:40:59.072]  - Number of values expected: 10
[17:40:59.072] Reducing values from 2 chunks ... DONE
[17:40:59.073] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:40:59.073] future_lapply() ...
[17:40:59.078] Number of chunks: 2
[17:40:59.078] getGlobalsAndPackagesXApply() ...
[17:40:59.079]  - future.globals: TRUE
[17:40:59.079] getGlobalsAndPackages() ...
[17:40:59.079] Searching for globals...
[17:40:59.082] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:40:59.082] Searching for globals ... DONE
[17:40:59.082] Resolving globals: FALSE
[17:40:59.083] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:40:59.084] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:59.084] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:59.084] - packages: [1] ‘future.apply’
[17:40:59.084] getGlobalsAndPackages() ... DONE
[17:40:59.084]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:59.084]  - needed namespaces: [n=1] ‘future.apply’
[17:40:59.084] Finding globals ... DONE
[17:40:59.084]  - use_args: TRUE
[17:40:59.085]  - Getting '...' globals ...
[17:40:59.085] resolve() on list ...
[17:40:59.085]  recursive: 0
[17:40:59.085]  length: 1
[17:40:59.085]  elements: ‘...’
[17:40:59.085]  length: 0 (resolved future 1)
[17:40:59.085] resolve() on list ... DONE
[17:40:59.085]    - '...' content: [n=0] 
[17:40:59.086] List of 1
[17:40:59.086]  $ ...: list()
[17:40:59.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:59.086]  - attr(*, "where")=List of 1
[17:40:59.086]   ..$ ...:<environment: 0x564f312430f8> 
[17:40:59.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:59.086]  - attr(*, "resolved")= logi TRUE
[17:40:59.086]  - attr(*, "total_size")= num NA
[17:40:59.088]  - Getting '...' globals ... DONE
[17:40:59.088] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:59.088] List of 8
[17:40:59.088]  $ ...future.FUN:function (x, ...)  
[17:40:59.088]  $ x_FUN        :function (x)  
[17:40:59.088]  $ times        : int 2
[17:40:59.088]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:59.088]  $ stop_if_not  :function (...)  
[17:40:59.088]  $ dim          : NULL
[17:40:59.088]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:59.088]  $ ...          : list()
[17:40:59.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:59.088]  - attr(*, "where")=List of 8
[17:40:59.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:59.088]   ..$ ...          :<environment: 0x564f312430f8> 
[17:40:59.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:59.088]  - attr(*, "resolved")= logi FALSE
[17:40:59.088]  - attr(*, "total_size")= num 96456
[17:40:59.093] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:59.094] getGlobalsAndPackagesXApply() ... DONE
[17:40:59.094] Number of futures (= number of chunks): 2
[17:40:59.094] Launching 2 futures (chunks) ...
[17:40:59.094] Chunk #1 of 2 ...
[17:40:59.094]  - Finding globals in 'X' for chunk #1 ...
[17:40:59.094] getGlobalsAndPackages() ...
[17:40:59.094] Searching for globals...
[17:40:59.094] 
[17:40:59.095] Searching for globals ... DONE
[17:40:59.095] - globals: [0] <none>
[17:40:59.095] getGlobalsAndPackages() ... DONE
[17:40:59.095]    + additional globals found: [n=0] 
[17:40:59.095]    + additional namespaces needed: [n=0] 
[17:40:59.095]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:59.095]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:59.095]  - seeds: <none>
[17:40:59.095] getGlobalsAndPackages() ...
[17:40:59.095] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.096] Resolving globals: FALSE
[17:40:59.096] Tweak future expression to call with '...' arguments ...
[17:40:59.096] {
[17:40:59.096]     do.call(function(...) {
[17:40:59.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.096]             on.exit(options(oopts), add = TRUE)
[17:40:59.096]         }
[17:40:59.096]         {
[17:40:59.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.096]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.096]             })
[17:40:59.096]         }
[17:40:59.096]     }, args = future.call.arguments)
[17:40:59.096] }
[17:40:59.096] Tweak future expression to call with '...' arguments ... DONE
[17:40:59.097] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.097] - packages: [1] ‘future.apply’
[17:40:59.097] getGlobalsAndPackages() ... DONE
[17:40:59.097] run() for ‘Future’ ...
[17:40:59.097] - state: ‘created’
[17:40:59.097] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.112] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.112]   - Field: ‘node’
[17:40:59.112]   - Field: ‘label’
[17:40:59.112]   - Field: ‘local’
[17:40:59.113]   - Field: ‘owner’
[17:40:59.113]   - Field: ‘envir’
[17:40:59.113]   - Field: ‘workers’
[17:40:59.113]   - Field: ‘packages’
[17:40:59.113]   - Field: ‘gc’
[17:40:59.113]   - Field: ‘conditions’
[17:40:59.113]   - Field: ‘persistent’
[17:40:59.113]   - Field: ‘expr’
[17:40:59.113]   - Field: ‘uuid’
[17:40:59.113]   - Field: ‘seed’
[17:40:59.113]   - Field: ‘version’
[17:40:59.114]   - Field: ‘result’
[17:40:59.114]   - Field: ‘asynchronous’
[17:40:59.114]   - Field: ‘calls’
[17:40:59.114]   - Field: ‘globals’
[17:40:59.114]   - Field: ‘stdout’
[17:40:59.114]   - Field: ‘earlySignal’
[17:40:59.114]   - Field: ‘lazy’
[17:40:59.114]   - Field: ‘state’
[17:40:59.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.114] - Launch lazy future ...
[17:40:59.115] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:59.115] Packages needed by future strategies (n = 0): <none>
[17:40:59.115] {
[17:40:59.115]     {
[17:40:59.115]         {
[17:40:59.115]             ...future.startTime <- base::Sys.time()
[17:40:59.115]             {
[17:40:59.115]                 {
[17:40:59.115]                   {
[17:40:59.115]                     {
[17:40:59.115]                       {
[17:40:59.115]                         base::local({
[17:40:59.115]                           has_future <- base::requireNamespace("future", 
[17:40:59.115]                             quietly = TRUE)
[17:40:59.115]                           if (has_future) {
[17:40:59.115]                             ns <- base::getNamespace("future")
[17:40:59.115]                             version <- ns[[".package"]][["version"]]
[17:40:59.115]                             if (is.null(version)) 
[17:40:59.115]                               version <- utils::packageVersion("future")
[17:40:59.115]                           }
[17:40:59.115]                           else {
[17:40:59.115]                             version <- NULL
[17:40:59.115]                           }
[17:40:59.115]                           if (!has_future || version < "1.8.0") {
[17:40:59.115]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.115]                               "", base::R.version$version.string), 
[17:40:59.115]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:59.115]                                 base::R.version$platform, 8 * 
[17:40:59.115]                                   base::.Machine$sizeof.pointer), 
[17:40:59.115]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.115]                                 "release", "version")], collapse = " "), 
[17:40:59.115]                               hostname = base::Sys.info()[["nodename"]])
[17:40:59.115]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.115]                               info)
[17:40:59.115]                             info <- base::paste(info, collapse = "; ")
[17:40:59.115]                             if (!has_future) {
[17:40:59.115]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.115]                                 info)
[17:40:59.115]                             }
[17:40:59.115]                             else {
[17:40:59.115]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.115]                                 info, version)
[17:40:59.115]                             }
[17:40:59.115]                             base::stop(msg)
[17:40:59.115]                           }
[17:40:59.115]                         })
[17:40:59.115]                       }
[17:40:59.115]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.115]                       base::options(mc.cores = 1L)
[17:40:59.115]                     }
[17:40:59.115]                     base::local({
[17:40:59.115]                       for (pkg in "future.apply") {
[17:40:59.115]                         base::loadNamespace(pkg)
[17:40:59.115]                         base::library(pkg, character.only = TRUE)
[17:40:59.115]                       }
[17:40:59.115]                     })
[17:40:59.115]                   }
[17:40:59.115]                   options(future.plan = NULL)
[17:40:59.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.115]                 }
[17:40:59.115]                 ...future.workdir <- getwd()
[17:40:59.115]             }
[17:40:59.115]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.115]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.115]         }
[17:40:59.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.115]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:59.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.115]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.115]             base::names(...future.oldOptions))
[17:40:59.115]     }
[17:40:59.115]     if (FALSE) {
[17:40:59.115]     }
[17:40:59.115]     else {
[17:40:59.115]         if (TRUE) {
[17:40:59.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.115]                 open = "w")
[17:40:59.115]         }
[17:40:59.115]         else {
[17:40:59.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.115]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.115]         }
[17:40:59.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.115]             base::sink(type = "output", split = FALSE)
[17:40:59.115]             base::close(...future.stdout)
[17:40:59.115]         }, add = TRUE)
[17:40:59.115]     }
[17:40:59.115]     ...future.frame <- base::sys.nframe()
[17:40:59.115]     ...future.conditions <- base::list()
[17:40:59.115]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.115]     if (FALSE) {
[17:40:59.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.115]     }
[17:40:59.115]     ...future.result <- base::tryCatch({
[17:40:59.115]         base::withCallingHandlers({
[17:40:59.115]             ...future.value <- base::withVisible(base::local({
[17:40:59.115]                 ...future.makeSendCondition <- local({
[17:40:59.115]                   sendCondition <- NULL
[17:40:59.115]                   function(frame = 1L) {
[17:40:59.115]                     if (is.function(sendCondition)) 
[17:40:59.115]                       return(sendCondition)
[17:40:59.115]                     ns <- getNamespace("parallel")
[17:40:59.115]                     if (exists("sendData", mode = "function", 
[17:40:59.115]                       envir = ns)) {
[17:40:59.115]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.115]                         envir = ns)
[17:40:59.115]                       envir <- sys.frame(frame)
[17:40:59.115]                       master <- NULL
[17:40:59.115]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.115]                         !identical(envir, emptyenv())) {
[17:40:59.115]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.115]                           inherits = FALSE)) {
[17:40:59.115]                           master <- get("master", mode = "list", 
[17:40:59.115]                             envir = envir, inherits = FALSE)
[17:40:59.115]                           if (inherits(master, c("SOCKnode", 
[17:40:59.115]                             "SOCK0node"))) {
[17:40:59.115]                             sendCondition <<- function(cond) {
[17:40:59.115]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.115]                                 success = TRUE)
[17:40:59.115]                               parallel_sendData(master, data)
[17:40:59.115]                             }
[17:40:59.115]                             return(sendCondition)
[17:40:59.115]                           }
[17:40:59.115]                         }
[17:40:59.115]                         frame <- frame + 1L
[17:40:59.115]                         envir <- sys.frame(frame)
[17:40:59.115]                       }
[17:40:59.115]                     }
[17:40:59.115]                     sendCondition <<- function(cond) NULL
[17:40:59.115]                   }
[17:40:59.115]                 })
[17:40:59.115]                 withCallingHandlers({
[17:40:59.115]                   {
[17:40:59.115]                     do.call(function(...) {
[17:40:59.115]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.115]                       if (!identical(...future.globals.maxSize.org, 
[17:40:59.115]                         ...future.globals.maxSize)) {
[17:40:59.115]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.115]                         on.exit(options(oopts), add = TRUE)
[17:40:59.115]                       }
[17:40:59.115]                       {
[17:40:59.115]                         lapply(seq_along(...future.elements_ii), 
[17:40:59.115]                           FUN = function(jj) {
[17:40:59.115]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.115]                             ...future.FUN(...future.X_jj, ...)
[17:40:59.115]                           })
[17:40:59.115]                       }
[17:40:59.115]                     }, args = future.call.arguments)
[17:40:59.115]                   }
[17:40:59.115]                 }, immediateCondition = function(cond) {
[17:40:59.115]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.115]                   sendCondition(cond)
[17:40:59.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.115]                   {
[17:40:59.115]                     inherits <- base::inherits
[17:40:59.115]                     invokeRestart <- base::invokeRestart
[17:40:59.115]                     is.null <- base::is.null
[17:40:59.115]                     muffled <- FALSE
[17:40:59.115]                     if (inherits(cond, "message")) {
[17:40:59.115]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.115]                       if (muffled) 
[17:40:59.115]                         invokeRestart("muffleMessage")
[17:40:59.115]                     }
[17:40:59.115]                     else if (inherits(cond, "warning")) {
[17:40:59.115]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.115]                       if (muffled) 
[17:40:59.115]                         invokeRestart("muffleWarning")
[17:40:59.115]                     }
[17:40:59.115]                     else if (inherits(cond, "condition")) {
[17:40:59.115]                       if (!is.null(pattern)) {
[17:40:59.115]                         computeRestarts <- base::computeRestarts
[17:40:59.115]                         grepl <- base::grepl
[17:40:59.115]                         restarts <- computeRestarts(cond)
[17:40:59.115]                         for (restart in restarts) {
[17:40:59.115]                           name <- restart$name
[17:40:59.115]                           if (is.null(name)) 
[17:40:59.115]                             next
[17:40:59.115]                           if (!grepl(pattern, name)) 
[17:40:59.115]                             next
[17:40:59.115]                           invokeRestart(restart)
[17:40:59.115]                           muffled <- TRUE
[17:40:59.115]                           break
[17:40:59.115]                         }
[17:40:59.115]                       }
[17:40:59.115]                     }
[17:40:59.115]                     invisible(muffled)
[17:40:59.115]                   }
[17:40:59.115]                   muffleCondition(cond)
[17:40:59.115]                 })
[17:40:59.115]             }))
[17:40:59.115]             future::FutureResult(value = ...future.value$value, 
[17:40:59.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.115]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.115]                     ...future.globalenv.names))
[17:40:59.115]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.115]         }, condition = base::local({
[17:40:59.115]             c <- base::c
[17:40:59.115]             inherits <- base::inherits
[17:40:59.115]             invokeRestart <- base::invokeRestart
[17:40:59.115]             length <- base::length
[17:40:59.115]             list <- base::list
[17:40:59.115]             seq.int <- base::seq.int
[17:40:59.115]             signalCondition <- base::signalCondition
[17:40:59.115]             sys.calls <- base::sys.calls
[17:40:59.115]             `[[` <- base::`[[`
[17:40:59.115]             `+` <- base::`+`
[17:40:59.115]             `<<-` <- base::`<<-`
[17:40:59.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.115]                   3L)]
[17:40:59.115]             }
[17:40:59.115]             function(cond) {
[17:40:59.115]                 is_error <- inherits(cond, "error")
[17:40:59.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.115]                   NULL)
[17:40:59.115]                 if (is_error) {
[17:40:59.115]                   sessionInformation <- function() {
[17:40:59.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.115]                       search = base::search(), system = base::Sys.info())
[17:40:59.115]                   }
[17:40:59.115]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.115]                     cond$call), session = sessionInformation(), 
[17:40:59.115]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.115]                   signalCondition(cond)
[17:40:59.115]                 }
[17:40:59.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.115]                 "immediateCondition"))) {
[17:40:59.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.115]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.115]                   if (TRUE && !signal) {
[17:40:59.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.115]                     {
[17:40:59.115]                       inherits <- base::inherits
[17:40:59.115]                       invokeRestart <- base::invokeRestart
[17:40:59.115]                       is.null <- base::is.null
[17:40:59.115]                       muffled <- FALSE
[17:40:59.115]                       if (inherits(cond, "message")) {
[17:40:59.115]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.115]                         if (muffled) 
[17:40:59.115]                           invokeRestart("muffleMessage")
[17:40:59.115]                       }
[17:40:59.115]                       else if (inherits(cond, "warning")) {
[17:40:59.115]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.115]                         if (muffled) 
[17:40:59.115]                           invokeRestart("muffleWarning")
[17:40:59.115]                       }
[17:40:59.115]                       else if (inherits(cond, "condition")) {
[17:40:59.115]                         if (!is.null(pattern)) {
[17:40:59.115]                           computeRestarts <- base::computeRestarts
[17:40:59.115]                           grepl <- base::grepl
[17:40:59.115]                           restarts <- computeRestarts(cond)
[17:40:59.115]                           for (restart in restarts) {
[17:40:59.115]                             name <- restart$name
[17:40:59.115]                             if (is.null(name)) 
[17:40:59.115]                               next
[17:40:59.115]                             if (!grepl(pattern, name)) 
[17:40:59.115]                               next
[17:40:59.115]                             invokeRestart(restart)
[17:40:59.115]                             muffled <- TRUE
[17:40:59.115]                             break
[17:40:59.115]                           }
[17:40:59.115]                         }
[17:40:59.115]                       }
[17:40:59.115]                       invisible(muffled)
[17:40:59.115]                     }
[17:40:59.115]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.115]                   }
[17:40:59.115]                 }
[17:40:59.115]                 else {
[17:40:59.115]                   if (TRUE) {
[17:40:59.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.115]                     {
[17:40:59.115]                       inherits <- base::inherits
[17:40:59.115]                       invokeRestart <- base::invokeRestart
[17:40:59.115]                       is.null <- base::is.null
[17:40:59.115]                       muffled <- FALSE
[17:40:59.115]                       if (inherits(cond, "message")) {
[17:40:59.115]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.115]                         if (muffled) 
[17:40:59.115]                           invokeRestart("muffleMessage")
[17:40:59.115]                       }
[17:40:59.115]                       else if (inherits(cond, "warning")) {
[17:40:59.115]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.115]                         if (muffled) 
[17:40:59.115]                           invokeRestart("muffleWarning")
[17:40:59.115]                       }
[17:40:59.115]                       else if (inherits(cond, "condition")) {
[17:40:59.115]                         if (!is.null(pattern)) {
[17:40:59.115]                           computeRestarts <- base::computeRestarts
[17:40:59.115]                           grepl <- base::grepl
[17:40:59.115]                           restarts <- computeRestarts(cond)
[17:40:59.115]                           for (restart in restarts) {
[17:40:59.115]                             name <- restart$name
[17:40:59.115]                             if (is.null(name)) 
[17:40:59.115]                               next
[17:40:59.115]                             if (!grepl(pattern, name)) 
[17:40:59.115]                               next
[17:40:59.115]                             invokeRestart(restart)
[17:40:59.115]                             muffled <- TRUE
[17:40:59.115]                             break
[17:40:59.115]                           }
[17:40:59.115]                         }
[17:40:59.115]                       }
[17:40:59.115]                       invisible(muffled)
[17:40:59.115]                     }
[17:40:59.115]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.115]                   }
[17:40:59.115]                 }
[17:40:59.115]             }
[17:40:59.115]         }))
[17:40:59.115]     }, error = function(ex) {
[17:40:59.115]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.115]                 ...future.rng), started = ...future.startTime, 
[17:40:59.115]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.115]             version = "1.8"), class = "FutureResult")
[17:40:59.115]     }, finally = {
[17:40:59.115]         if (!identical(...future.workdir, getwd())) 
[17:40:59.115]             setwd(...future.workdir)
[17:40:59.115]         {
[17:40:59.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.115]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.115]             }
[17:40:59.115]             base::options(...future.oldOptions)
[17:40:59.115]             if (.Platform$OS.type == "windows") {
[17:40:59.115]                 old_names <- names(...future.oldEnvVars)
[17:40:59.115]                 envs <- base::Sys.getenv()
[17:40:59.115]                 names <- names(envs)
[17:40:59.115]                 common <- intersect(names, old_names)
[17:40:59.115]                 added <- setdiff(names, old_names)
[17:40:59.115]                 removed <- setdiff(old_names, names)
[17:40:59.115]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.115]                   envs[common]]
[17:40:59.115]                 NAMES <- toupper(changed)
[17:40:59.115]                 args <- list()
[17:40:59.115]                 for (kk in seq_along(NAMES)) {
[17:40:59.115]                   name <- changed[[kk]]
[17:40:59.115]                   NAME <- NAMES[[kk]]
[17:40:59.115]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.115]                     next
[17:40:59.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.115]                 }
[17:40:59.115]                 NAMES <- toupper(added)
[17:40:59.115]                 for (kk in seq_along(NAMES)) {
[17:40:59.115]                   name <- added[[kk]]
[17:40:59.115]                   NAME <- NAMES[[kk]]
[17:40:59.115]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.115]                     next
[17:40:59.115]                   args[[name]] <- ""
[17:40:59.115]                 }
[17:40:59.115]                 NAMES <- toupper(removed)
[17:40:59.115]                 for (kk in seq_along(NAMES)) {
[17:40:59.115]                   name <- removed[[kk]]
[17:40:59.115]                   NAME <- NAMES[[kk]]
[17:40:59.115]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.115]                     next
[17:40:59.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.115]                 }
[17:40:59.115]                 if (length(args) > 0) 
[17:40:59.115]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.115]             }
[17:40:59.115]             else {
[17:40:59.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.115]             }
[17:40:59.115]             {
[17:40:59.115]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.115]                   0L) {
[17:40:59.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.115]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.115]                   base::options(opts)
[17:40:59.115]                 }
[17:40:59.115]                 {
[17:40:59.115]                   {
[17:40:59.115]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.115]                     NULL
[17:40:59.115]                   }
[17:40:59.115]                   options(future.plan = NULL)
[17:40:59.115]                   if (is.na(NA_character_)) 
[17:40:59.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.115]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:59.115]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:59.115]                     envir = parent.frame()) 
[17:40:59.115]                   {
[17:40:59.115]                     if (is.function(workers)) 
[17:40:59.115]                       workers <- workers()
[17:40:59.115]                     workers <- structure(as.integer(workers), 
[17:40:59.115]                       class = class(workers))
[17:40:59.115]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:59.115]                       workers >= 1)
[17:40:59.115]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:59.115]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:59.115]                     }
[17:40:59.115]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:59.115]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:59.115]                       envir = envir)
[17:40:59.115]                     if (!future$lazy) 
[17:40:59.115]                       future <- run(future)
[17:40:59.115]                     invisible(future)
[17:40:59.115]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:59.115]                 }
[17:40:59.115]             }
[17:40:59.115]         }
[17:40:59.115]     })
[17:40:59.115]     if (TRUE) {
[17:40:59.115]         base::sink(type = "output", split = FALSE)
[17:40:59.115]         if (TRUE) {
[17:40:59.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.115]         }
[17:40:59.115]         else {
[17:40:59.115]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.115]         }
[17:40:59.115]         base::close(...future.stdout)
[17:40:59.115]         ...future.stdout <- NULL
[17:40:59.115]     }
[17:40:59.115]     ...future.result$conditions <- ...future.conditions
[17:40:59.115]     ...future.result$finished <- base::Sys.time()
[17:40:59.115]     ...future.result
[17:40:59.115] }
[17:40:59.118] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[17:40:59.118] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:40:59.159] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:40:59.159] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[17:40:59.160] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[17:40:59.160] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:40:59.160] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:40:59.161] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:40:59.203] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:40:59.203] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:40:59.247] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:40:59.247] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:40:59.248] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.248] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:40:59.248] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:40:59.251] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:40:59.251] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.252] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:40:59.252] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:40:59.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:40:59.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.253] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:40:59.253] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.253] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[17:40:59.254] MultisessionFuture started
[17:40:59.254] - Launch lazy future ... done
[17:40:59.254] run() for ‘MultisessionFuture’ ... done
[17:40:59.254] Created future:
[17:40:59.254] MultisessionFuture:
[17:40:59.254] Label: ‘future_vapply-1’
[17:40:59.254] Expression:
[17:40:59.254] {
[17:40:59.254]     do.call(function(...) {
[17:40:59.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.254]             on.exit(options(oopts), add = TRUE)
[17:40:59.254]         }
[17:40:59.254]         {
[17:40:59.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.254]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.254]             })
[17:40:59.254]         }
[17:40:59.254]     }, args = future.call.arguments)
[17:40:59.254] }
[17:40:59.254] Lazy evaluation: FALSE
[17:40:59.254] Asynchronous evaluation: TRUE
[17:40:59.254] Local evaluation: TRUE
[17:40:59.254] Environment: R_GlobalEnv
[17:40:59.254] Capture standard output: TRUE
[17:40:59.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:59.254] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:59.254] Packages: 1 packages (‘future.apply’)
[17:40:59.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:59.254] Resolved: FALSE
[17:40:59.254] Value: <not collected>
[17:40:59.254] Conditions captured: <none>
[17:40:59.254] Early signaling: FALSE
[17:40:59.254] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:59.254] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.266] Chunk #1 of 2 ... DONE
[17:40:59.266] Chunk #2 of 2 ...
[17:40:59.266]  - Finding globals in 'X' for chunk #2 ...
[17:40:59.266] getGlobalsAndPackages() ...
[17:40:59.267] Searching for globals...
[17:40:59.267] 
[17:40:59.267] Searching for globals ... DONE
[17:40:59.267] - globals: [0] <none>
[17:40:59.267] getGlobalsAndPackages() ... DONE
[17:40:59.267]    + additional globals found: [n=0] 
[17:40:59.267]    + additional namespaces needed: [n=0] 
[17:40:59.267]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:59.267]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:59.268]  - seeds: <none>
[17:40:59.268] getGlobalsAndPackages() ...
[17:40:59.268] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.268] Resolving globals: FALSE
[17:40:59.268] Tweak future expression to call with '...' arguments ...
[17:40:59.268] {
[17:40:59.268]     do.call(function(...) {
[17:40:59.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.268]             on.exit(options(oopts), add = TRUE)
[17:40:59.268]         }
[17:40:59.268]         {
[17:40:59.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.268]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.268]             })
[17:40:59.268]         }
[17:40:59.268]     }, args = future.call.arguments)
[17:40:59.268] }
[17:40:59.268] Tweak future expression to call with '...' arguments ... DONE
[17:40:59.269] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.269] - packages: [1] ‘future.apply’
[17:40:59.269] getGlobalsAndPackages() ... DONE
[17:40:59.269] run() for ‘Future’ ...
[17:40:59.269] - state: ‘created’
[17:40:59.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.284]   - Field: ‘node’
[17:40:59.284]   - Field: ‘label’
[17:40:59.284]   - Field: ‘local’
[17:40:59.285]   - Field: ‘owner’
[17:40:59.285]   - Field: ‘envir’
[17:40:59.285]   - Field: ‘workers’
[17:40:59.285]   - Field: ‘packages’
[17:40:59.285]   - Field: ‘gc’
[17:40:59.285]   - Field: ‘conditions’
[17:40:59.285]   - Field: ‘persistent’
[17:40:59.285]   - Field: ‘expr’
[17:40:59.285]   - Field: ‘uuid’
[17:40:59.285]   - Field: ‘seed’
[17:40:59.285]   - Field: ‘version’
[17:40:59.286]   - Field: ‘result’
[17:40:59.286]   - Field: ‘asynchronous’
[17:40:59.286]   - Field: ‘calls’
[17:40:59.286]   - Field: ‘globals’
[17:40:59.286]   - Field: ‘stdout’
[17:40:59.286]   - Field: ‘earlySignal’
[17:40:59.286]   - Field: ‘lazy’
[17:40:59.286]   - Field: ‘state’
[17:40:59.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.286] - Launch lazy future ...
[17:40:59.287] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:59.287] Packages needed by future strategies (n = 0): <none>
[17:40:59.287] {
[17:40:59.287]     {
[17:40:59.287]         {
[17:40:59.287]             ...future.startTime <- base::Sys.time()
[17:40:59.287]             {
[17:40:59.287]                 {
[17:40:59.287]                   {
[17:40:59.287]                     {
[17:40:59.287]                       {
[17:40:59.287]                         base::local({
[17:40:59.287]                           has_future <- base::requireNamespace("future", 
[17:40:59.287]                             quietly = TRUE)
[17:40:59.287]                           if (has_future) {
[17:40:59.287]                             ns <- base::getNamespace("future")
[17:40:59.287]                             version <- ns[[".package"]][["version"]]
[17:40:59.287]                             if (is.null(version)) 
[17:40:59.287]                               version <- utils::packageVersion("future")
[17:40:59.287]                           }
[17:40:59.287]                           else {
[17:40:59.287]                             version <- NULL
[17:40:59.287]                           }
[17:40:59.287]                           if (!has_future || version < "1.8.0") {
[17:40:59.287]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.287]                               "", base::R.version$version.string), 
[17:40:59.287]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:59.287]                                 base::R.version$platform, 8 * 
[17:40:59.287]                                   base::.Machine$sizeof.pointer), 
[17:40:59.287]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.287]                                 "release", "version")], collapse = " "), 
[17:40:59.287]                               hostname = base::Sys.info()[["nodename"]])
[17:40:59.287]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.287]                               info)
[17:40:59.287]                             info <- base::paste(info, collapse = "; ")
[17:40:59.287]                             if (!has_future) {
[17:40:59.287]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.287]                                 info)
[17:40:59.287]                             }
[17:40:59.287]                             else {
[17:40:59.287]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.287]                                 info, version)
[17:40:59.287]                             }
[17:40:59.287]                             base::stop(msg)
[17:40:59.287]                           }
[17:40:59.287]                         })
[17:40:59.287]                       }
[17:40:59.287]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.287]                       base::options(mc.cores = 1L)
[17:40:59.287]                     }
[17:40:59.287]                     base::local({
[17:40:59.287]                       for (pkg in "future.apply") {
[17:40:59.287]                         base::loadNamespace(pkg)
[17:40:59.287]                         base::library(pkg, character.only = TRUE)
[17:40:59.287]                       }
[17:40:59.287]                     })
[17:40:59.287]                   }
[17:40:59.287]                   options(future.plan = NULL)
[17:40:59.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.287]                 }
[17:40:59.287]                 ...future.workdir <- getwd()
[17:40:59.287]             }
[17:40:59.287]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.287]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.287]         }
[17:40:59.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.287]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:59.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.287]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.287]             base::names(...future.oldOptions))
[17:40:59.287]     }
[17:40:59.287]     if (FALSE) {
[17:40:59.287]     }
[17:40:59.287]     else {
[17:40:59.287]         if (TRUE) {
[17:40:59.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.287]                 open = "w")
[17:40:59.287]         }
[17:40:59.287]         else {
[17:40:59.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.287]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.287]         }
[17:40:59.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.287]             base::sink(type = "output", split = FALSE)
[17:40:59.287]             base::close(...future.stdout)
[17:40:59.287]         }, add = TRUE)
[17:40:59.287]     }
[17:40:59.287]     ...future.frame <- base::sys.nframe()
[17:40:59.287]     ...future.conditions <- base::list()
[17:40:59.287]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.287]     if (FALSE) {
[17:40:59.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.287]     }
[17:40:59.287]     ...future.result <- base::tryCatch({
[17:40:59.287]         base::withCallingHandlers({
[17:40:59.287]             ...future.value <- base::withVisible(base::local({
[17:40:59.287]                 ...future.makeSendCondition <- local({
[17:40:59.287]                   sendCondition <- NULL
[17:40:59.287]                   function(frame = 1L) {
[17:40:59.287]                     if (is.function(sendCondition)) 
[17:40:59.287]                       return(sendCondition)
[17:40:59.287]                     ns <- getNamespace("parallel")
[17:40:59.287]                     if (exists("sendData", mode = "function", 
[17:40:59.287]                       envir = ns)) {
[17:40:59.287]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.287]                         envir = ns)
[17:40:59.287]                       envir <- sys.frame(frame)
[17:40:59.287]                       master <- NULL
[17:40:59.287]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.287]                         !identical(envir, emptyenv())) {
[17:40:59.287]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.287]                           inherits = FALSE)) {
[17:40:59.287]                           master <- get("master", mode = "list", 
[17:40:59.287]                             envir = envir, inherits = FALSE)
[17:40:59.287]                           if (inherits(master, c("SOCKnode", 
[17:40:59.287]                             "SOCK0node"))) {
[17:40:59.287]                             sendCondition <<- function(cond) {
[17:40:59.287]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.287]                                 success = TRUE)
[17:40:59.287]                               parallel_sendData(master, data)
[17:40:59.287]                             }
[17:40:59.287]                             return(sendCondition)
[17:40:59.287]                           }
[17:40:59.287]                         }
[17:40:59.287]                         frame <- frame + 1L
[17:40:59.287]                         envir <- sys.frame(frame)
[17:40:59.287]                       }
[17:40:59.287]                     }
[17:40:59.287]                     sendCondition <<- function(cond) NULL
[17:40:59.287]                   }
[17:40:59.287]                 })
[17:40:59.287]                 withCallingHandlers({
[17:40:59.287]                   {
[17:40:59.287]                     do.call(function(...) {
[17:40:59.287]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.287]                       if (!identical(...future.globals.maxSize.org, 
[17:40:59.287]                         ...future.globals.maxSize)) {
[17:40:59.287]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.287]                         on.exit(options(oopts), add = TRUE)
[17:40:59.287]                       }
[17:40:59.287]                       {
[17:40:59.287]                         lapply(seq_along(...future.elements_ii), 
[17:40:59.287]                           FUN = function(jj) {
[17:40:59.287]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.287]                             ...future.FUN(...future.X_jj, ...)
[17:40:59.287]                           })
[17:40:59.287]                       }
[17:40:59.287]                     }, args = future.call.arguments)
[17:40:59.287]                   }
[17:40:59.287]                 }, immediateCondition = function(cond) {
[17:40:59.287]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.287]                   sendCondition(cond)
[17:40:59.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.287]                   {
[17:40:59.287]                     inherits <- base::inherits
[17:40:59.287]                     invokeRestart <- base::invokeRestart
[17:40:59.287]                     is.null <- base::is.null
[17:40:59.287]                     muffled <- FALSE
[17:40:59.287]                     if (inherits(cond, "message")) {
[17:40:59.287]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.287]                       if (muffled) 
[17:40:59.287]                         invokeRestart("muffleMessage")
[17:40:59.287]                     }
[17:40:59.287]                     else if (inherits(cond, "warning")) {
[17:40:59.287]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.287]                       if (muffled) 
[17:40:59.287]                         invokeRestart("muffleWarning")
[17:40:59.287]                     }
[17:40:59.287]                     else if (inherits(cond, "condition")) {
[17:40:59.287]                       if (!is.null(pattern)) {
[17:40:59.287]                         computeRestarts <- base::computeRestarts
[17:40:59.287]                         grepl <- base::grepl
[17:40:59.287]                         restarts <- computeRestarts(cond)
[17:40:59.287]                         for (restart in restarts) {
[17:40:59.287]                           name <- restart$name
[17:40:59.287]                           if (is.null(name)) 
[17:40:59.287]                             next
[17:40:59.287]                           if (!grepl(pattern, name)) 
[17:40:59.287]                             next
[17:40:59.287]                           invokeRestart(restart)
[17:40:59.287]                           muffled <- TRUE
[17:40:59.287]                           break
[17:40:59.287]                         }
[17:40:59.287]                       }
[17:40:59.287]                     }
[17:40:59.287]                     invisible(muffled)
[17:40:59.287]                   }
[17:40:59.287]                   muffleCondition(cond)
[17:40:59.287]                 })
[17:40:59.287]             }))
[17:40:59.287]             future::FutureResult(value = ...future.value$value, 
[17:40:59.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.287]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.287]                     ...future.globalenv.names))
[17:40:59.287]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.287]         }, condition = base::local({
[17:40:59.287]             c <- base::c
[17:40:59.287]             inherits <- base::inherits
[17:40:59.287]             invokeRestart <- base::invokeRestart
[17:40:59.287]             length <- base::length
[17:40:59.287]             list <- base::list
[17:40:59.287]             seq.int <- base::seq.int
[17:40:59.287]             signalCondition <- base::signalCondition
[17:40:59.287]             sys.calls <- base::sys.calls
[17:40:59.287]             `[[` <- base::`[[`
[17:40:59.287]             `+` <- base::`+`
[17:40:59.287]             `<<-` <- base::`<<-`
[17:40:59.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.287]                   3L)]
[17:40:59.287]             }
[17:40:59.287]             function(cond) {
[17:40:59.287]                 is_error <- inherits(cond, "error")
[17:40:59.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.287]                   NULL)
[17:40:59.287]                 if (is_error) {
[17:40:59.287]                   sessionInformation <- function() {
[17:40:59.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.287]                       search = base::search(), system = base::Sys.info())
[17:40:59.287]                   }
[17:40:59.287]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.287]                     cond$call), session = sessionInformation(), 
[17:40:59.287]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.287]                   signalCondition(cond)
[17:40:59.287]                 }
[17:40:59.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.287]                 "immediateCondition"))) {
[17:40:59.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.287]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.287]                   if (TRUE && !signal) {
[17:40:59.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.287]                     {
[17:40:59.287]                       inherits <- base::inherits
[17:40:59.287]                       invokeRestart <- base::invokeRestart
[17:40:59.287]                       is.null <- base::is.null
[17:40:59.287]                       muffled <- FALSE
[17:40:59.287]                       if (inherits(cond, "message")) {
[17:40:59.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.287]                         if (muffled) 
[17:40:59.287]                           invokeRestart("muffleMessage")
[17:40:59.287]                       }
[17:40:59.287]                       else if (inherits(cond, "warning")) {
[17:40:59.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.287]                         if (muffled) 
[17:40:59.287]                           invokeRestart("muffleWarning")
[17:40:59.287]                       }
[17:40:59.287]                       else if (inherits(cond, "condition")) {
[17:40:59.287]                         if (!is.null(pattern)) {
[17:40:59.287]                           computeRestarts <- base::computeRestarts
[17:40:59.287]                           grepl <- base::grepl
[17:40:59.287]                           restarts <- computeRestarts(cond)
[17:40:59.287]                           for (restart in restarts) {
[17:40:59.287]                             name <- restart$name
[17:40:59.287]                             if (is.null(name)) 
[17:40:59.287]                               next
[17:40:59.287]                             if (!grepl(pattern, name)) 
[17:40:59.287]                               next
[17:40:59.287]                             invokeRestart(restart)
[17:40:59.287]                             muffled <- TRUE
[17:40:59.287]                             break
[17:40:59.287]                           }
[17:40:59.287]                         }
[17:40:59.287]                       }
[17:40:59.287]                       invisible(muffled)
[17:40:59.287]                     }
[17:40:59.287]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.287]                   }
[17:40:59.287]                 }
[17:40:59.287]                 else {
[17:40:59.287]                   if (TRUE) {
[17:40:59.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.287]                     {
[17:40:59.287]                       inherits <- base::inherits
[17:40:59.287]                       invokeRestart <- base::invokeRestart
[17:40:59.287]                       is.null <- base::is.null
[17:40:59.287]                       muffled <- FALSE
[17:40:59.287]                       if (inherits(cond, "message")) {
[17:40:59.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.287]                         if (muffled) 
[17:40:59.287]                           invokeRestart("muffleMessage")
[17:40:59.287]                       }
[17:40:59.287]                       else if (inherits(cond, "warning")) {
[17:40:59.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.287]                         if (muffled) 
[17:40:59.287]                           invokeRestart("muffleWarning")
[17:40:59.287]                       }
[17:40:59.287]                       else if (inherits(cond, "condition")) {
[17:40:59.287]                         if (!is.null(pattern)) {
[17:40:59.287]                           computeRestarts <- base::computeRestarts
[17:40:59.287]                           grepl <- base::grepl
[17:40:59.287]                           restarts <- computeRestarts(cond)
[17:40:59.287]                           for (restart in restarts) {
[17:40:59.287]                             name <- restart$name
[17:40:59.287]                             if (is.null(name)) 
[17:40:59.287]                               next
[17:40:59.287]                             if (!grepl(pattern, name)) 
[17:40:59.287]                               next
[17:40:59.287]                             invokeRestart(restart)
[17:40:59.287]                             muffled <- TRUE
[17:40:59.287]                             break
[17:40:59.287]                           }
[17:40:59.287]                         }
[17:40:59.287]                       }
[17:40:59.287]                       invisible(muffled)
[17:40:59.287]                     }
[17:40:59.287]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.287]                   }
[17:40:59.287]                 }
[17:40:59.287]             }
[17:40:59.287]         }))
[17:40:59.287]     }, error = function(ex) {
[17:40:59.287]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.287]                 ...future.rng), started = ...future.startTime, 
[17:40:59.287]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.287]             version = "1.8"), class = "FutureResult")
[17:40:59.287]     }, finally = {
[17:40:59.287]         if (!identical(...future.workdir, getwd())) 
[17:40:59.287]             setwd(...future.workdir)
[17:40:59.287]         {
[17:40:59.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.287]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.287]             }
[17:40:59.287]             base::options(...future.oldOptions)
[17:40:59.287]             if (.Platform$OS.type == "windows") {
[17:40:59.287]                 old_names <- names(...future.oldEnvVars)
[17:40:59.287]                 envs <- base::Sys.getenv()
[17:40:59.287]                 names <- names(envs)
[17:40:59.287]                 common <- intersect(names, old_names)
[17:40:59.287]                 added <- setdiff(names, old_names)
[17:40:59.287]                 removed <- setdiff(old_names, names)
[17:40:59.287]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.287]                   envs[common]]
[17:40:59.287]                 NAMES <- toupper(changed)
[17:40:59.287]                 args <- list()
[17:40:59.287]                 for (kk in seq_along(NAMES)) {
[17:40:59.287]                   name <- changed[[kk]]
[17:40:59.287]                   NAME <- NAMES[[kk]]
[17:40:59.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.287]                     next
[17:40:59.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.287]                 }
[17:40:59.287]                 NAMES <- toupper(added)
[17:40:59.287]                 for (kk in seq_along(NAMES)) {
[17:40:59.287]                   name <- added[[kk]]
[17:40:59.287]                   NAME <- NAMES[[kk]]
[17:40:59.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.287]                     next
[17:40:59.287]                   args[[name]] <- ""
[17:40:59.287]                 }
[17:40:59.287]                 NAMES <- toupper(removed)
[17:40:59.287]                 for (kk in seq_along(NAMES)) {
[17:40:59.287]                   name <- removed[[kk]]
[17:40:59.287]                   NAME <- NAMES[[kk]]
[17:40:59.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.287]                     next
[17:40:59.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.287]                 }
[17:40:59.287]                 if (length(args) > 0) 
[17:40:59.287]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.287]             }
[17:40:59.287]             else {
[17:40:59.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.287]             }
[17:40:59.287]             {
[17:40:59.287]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.287]                   0L) {
[17:40:59.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.287]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.287]                   base::options(opts)
[17:40:59.287]                 }
[17:40:59.287]                 {
[17:40:59.287]                   {
[17:40:59.287]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.287]                     NULL
[17:40:59.287]                   }
[17:40:59.287]                   options(future.plan = NULL)
[17:40:59.287]                   if (is.na(NA_character_)) 
[17:40:59.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.287]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:59.287]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:59.287]                     envir = parent.frame()) 
[17:40:59.287]                   {
[17:40:59.287]                     if (is.function(workers)) 
[17:40:59.287]                       workers <- workers()
[17:40:59.287]                     workers <- structure(as.integer(workers), 
[17:40:59.287]                       class = class(workers))
[17:40:59.287]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:59.287]                       workers >= 1)
[17:40:59.287]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:59.287]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:59.287]                     }
[17:40:59.287]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:59.287]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:59.287]                       envir = envir)
[17:40:59.287]                     if (!future$lazy) 
[17:40:59.287]                       future <- run(future)
[17:40:59.287]                     invisible(future)
[17:40:59.287]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:59.287]                 }
[17:40:59.287]             }
[17:40:59.287]         }
[17:40:59.287]     })
[17:40:59.287]     if (TRUE) {
[17:40:59.287]         base::sink(type = "output", split = FALSE)
[17:40:59.287]         if (TRUE) {
[17:40:59.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.287]         }
[17:40:59.287]         else {
[17:40:59.287]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.287]         }
[17:40:59.287]         base::close(...future.stdout)
[17:40:59.287]         ...future.stdout <- NULL
[17:40:59.287]     }
[17:40:59.287]     ...future.result$conditions <- ...future.conditions
[17:40:59.287]     ...future.result$finished <- base::Sys.time()
[17:40:59.287]     ...future.result
[17:40:59.287] }
[17:40:59.290] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[17:40:59.290] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:40:59.331] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:40:59.331] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[17:40:59.332] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[17:40:59.332] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:40:59.332] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:40:59.332] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:40:59.375] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:40:59.375] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:40:59.419] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:40:59.419] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:40:59.420] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.420] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:40:59.420] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:40:59.420] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:40:59.421] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.421] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:40:59.421] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:40:59.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:40:59.422] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.422] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:40:59.422] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.422] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[17:40:59.423] MultisessionFuture started
[17:40:59.423] - Launch lazy future ... done
[17:40:59.423] run() for ‘MultisessionFuture’ ... done
[17:40:59.423] Created future:
[17:40:59.423] MultisessionFuture:
[17:40:59.423] Label: ‘future_vapply-2’
[17:40:59.423] Expression:
[17:40:59.423] {
[17:40:59.423]     do.call(function(...) {
[17:40:59.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.423]             on.exit(options(oopts), add = TRUE)
[17:40:59.423]         }
[17:40:59.423]         {
[17:40:59.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.423]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.423]             })
[17:40:59.423]         }
[17:40:59.423]     }, args = future.call.arguments)
[17:40:59.423] }
[17:40:59.423] Lazy evaluation: FALSE
[17:40:59.423] Asynchronous evaluation: TRUE
[17:40:59.423] Local evaluation: TRUE
[17:40:59.423] Environment: R_GlobalEnv
[17:40:59.423] Capture standard output: TRUE
[17:40:59.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:59.423] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:59.423] Packages: 1 packages (‘future.apply’)
[17:40:59.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:59.423] Resolved: FALSE
[17:40:59.423] Value: <not collected>
[17:40:59.423] Conditions captured: <none>
[17:40:59.423] Early signaling: FALSE
[17:40:59.423] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:59.423] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.435] Chunk #2 of 2 ... DONE
[17:40:59.435] Launching 2 futures (chunks) ... DONE
[17:40:59.435] Resolving 2 futures (chunks) ...
[17:40:59.435] resolve() on list ...
[17:40:59.436]  recursive: 0
[17:40:59.436]  length: 2
[17:40:59.436] 
[17:40:59.436] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.436] - Validating connection of MultisessionFuture
[17:40:59.436] - received message: FutureResult
[17:40:59.437] - Received FutureResult
[17:40:59.437] - Erased future from FutureRegistry
[17:40:59.437] result() for ClusterFuture ...
[17:40:59.437] - result already collected: FutureResult
[17:40:59.437] result() for ClusterFuture ... done
[17:40:59.437] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.437] Future #1
[17:40:59.437] result() for ClusterFuture ...
[17:40:59.437] - result already collected: FutureResult
[17:40:59.437] result() for ClusterFuture ... done
[17:40:59.437] result() for ClusterFuture ...
[17:40:59.438] - result already collected: FutureResult
[17:40:59.438] result() for ClusterFuture ... done
[17:40:59.438] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:40:59.438] - nx: 2
[17:40:59.438] - relay: TRUE
[17:40:59.438] - stdout: TRUE
[17:40:59.438] - signal: TRUE
[17:40:59.438] - resignal: FALSE
[17:40:59.438] - force: TRUE
[17:40:59.438] - relayed: [n=2] FALSE, FALSE
[17:40:59.438] - queued futures: [n=2] FALSE, FALSE
[17:40:59.438]  - until=1
[17:40:59.439]  - relaying element #1
[17:40:59.439] result() for ClusterFuture ...
[17:40:59.439] - result already collected: FutureResult
[17:40:59.439] result() for ClusterFuture ... done
[17:40:59.439] result() for ClusterFuture ...
[17:40:59.439] - result already collected: FutureResult
[17:40:59.439] result() for ClusterFuture ... done
[17:40:59.439] result() for ClusterFuture ...
[17:40:59.439] - result already collected: FutureResult
[17:40:59.439] result() for ClusterFuture ... done
[17:40:59.439] result() for ClusterFuture ...
[17:40:59.440] - result already collected: FutureResult
[17:40:59.440] result() for ClusterFuture ... done
[17:40:59.440] - relayed: [n=2] TRUE, FALSE
[17:40:59.440] - queued futures: [n=2] TRUE, FALSE
[17:40:59.440] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:40:59.440]  length: 1 (resolved future 1)
[17:40:59.482] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.482] - Validating connection of MultisessionFuture
[17:40:59.482] - received message: FutureResult
[17:40:59.482] - Received FutureResult
[17:40:59.482] - Erased future from FutureRegistry
[17:40:59.482] result() for ClusterFuture ...
[17:40:59.482] - result already collected: FutureResult
[17:40:59.482] result() for ClusterFuture ... done
[17:40:59.483] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.483] Future #2
[17:40:59.483] result() for ClusterFuture ...
[17:40:59.483] - result already collected: FutureResult
[17:40:59.483] result() for ClusterFuture ... done
[17:40:59.483] result() for ClusterFuture ...
[17:40:59.483] - result already collected: FutureResult
[17:40:59.483] result() for ClusterFuture ... done
[17:40:59.483] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:40:59.483] - nx: 2
[17:40:59.484] - relay: TRUE
[17:40:59.484] - stdout: TRUE
[17:40:59.484] - signal: TRUE
[17:40:59.484] - resignal: FALSE
[17:40:59.484] - force: TRUE
[17:40:59.484] - relayed: [n=2] TRUE, FALSE
[17:40:59.484] - queued futures: [n=2] TRUE, FALSE
[17:40:59.484]  - until=2
[17:40:59.484]  - relaying element #2
[17:40:59.484] result() for ClusterFuture ...
[17:40:59.484] - result already collected: FutureResult
[17:40:59.484] result() for ClusterFuture ... done
[17:40:59.485] result() for ClusterFuture ...
[17:40:59.485] - result already collected: FutureResult
[17:40:59.485] result() for ClusterFuture ... done
[17:40:59.485] result() for ClusterFuture ...
[17:40:59.485] - result already collected: FutureResult
[17:40:59.485] result() for ClusterFuture ... done
[17:40:59.485] result() for ClusterFuture ...
[17:40:59.485] - result already collected: FutureResult
[17:40:59.485] result() for ClusterFuture ... done
[17:40:59.485] - relayed: [n=2] TRUE, TRUE
[17:40:59.485] - queued futures: [n=2] TRUE, TRUE
[17:40:59.486] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:40:59.486]  length: 0 (resolved future 2)
[17:40:59.486] Relaying remaining futures
[17:40:59.486] signalConditionsASAP(NULL, pos=0) ...
[17:40:59.486] - nx: 2
[17:40:59.486] - relay: TRUE
[17:40:59.486] - stdout: TRUE
[17:40:59.486] - signal: TRUE
[17:40:59.486] - resignal: FALSE
[17:40:59.486] - force: TRUE
[17:40:59.486] - relayed: [n=2] TRUE, TRUE
[17:40:59.486] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:59.487] - relayed: [n=2] TRUE, TRUE
[17:40:59.487] - queued futures: [n=2] TRUE, TRUE
[17:40:59.487] signalConditionsASAP(NULL, pos=0) ... done
[17:40:59.487] resolve() on list ... DONE
[17:40:59.487] result() for ClusterFuture ...
[17:40:59.487] - result already collected: FutureResult
[17:40:59.487] result() for ClusterFuture ... done
[17:40:59.487] result() for ClusterFuture ...
[17:40:59.487] - result already collected: FutureResult
[17:40:59.487] result() for ClusterFuture ... done
[17:40:59.488] result() for ClusterFuture ...
[17:40:59.488] - result already collected: FutureResult
[17:40:59.488] result() for ClusterFuture ... done
[17:40:59.488] result() for ClusterFuture ...
[17:40:59.488] - result already collected: FutureResult
[17:40:59.488] result() for ClusterFuture ... done
[17:40:59.488]  - Number of value chunks collected: 2
[17:40:59.488] Resolving 2 futures (chunks) ... DONE
[17:40:59.488] Reducing values from 2 chunks ...
[17:40:59.488]  - Number of values collected after concatenation: 10
[17:40:59.488]  - Number of values expected: 10
[17:40:59.489] Reducing values from 2 chunks ... DONE
[17:40:59.489] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:40:59.490] future_lapply() ...
[17:40:59.495] Number of chunks: 2
[17:40:59.495] getGlobalsAndPackagesXApply() ...
[17:40:59.495]  - future.globals: TRUE
[17:40:59.495] getGlobalsAndPackages() ...
[17:40:59.496] Searching for globals...
[17:40:59.499] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:40:59.499] Searching for globals ... DONE
[17:40:59.499] Resolving globals: FALSE
[17:40:59.500] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:40:59.500] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:59.501] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:59.501] - packages: [1] ‘future.apply’
[17:40:59.501] getGlobalsAndPackages() ... DONE
[17:40:59.501]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:59.501]  - needed namespaces: [n=1] ‘future.apply’
[17:40:59.501] Finding globals ... DONE
[17:40:59.501]  - use_args: TRUE
[17:40:59.501]  - Getting '...' globals ...
[17:40:59.501] resolve() on list ...
[17:40:59.502]  recursive: 0
[17:40:59.502]  length: 1
[17:40:59.502]  elements: ‘...’
[17:40:59.502]  length: 0 (resolved future 1)
[17:40:59.502] resolve() on list ... DONE
[17:40:59.502]    - '...' content: [n=0] 
[17:40:59.502] List of 1
[17:40:59.502]  $ ...: list()
[17:40:59.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:59.502]  - attr(*, "where")=List of 1
[17:40:59.502]   ..$ ...:<environment: 0x564f310e9bf8> 
[17:40:59.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:59.502]  - attr(*, "resolved")= logi TRUE
[17:40:59.502]  - attr(*, "total_size")= num NA
[17:40:59.505]  - Getting '...' globals ... DONE
[17:40:59.505] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:59.505] List of 8
[17:40:59.505]  $ ...future.FUN:function (x, ...)  
[17:40:59.505]  $ x_FUN        :function (x)  
[17:40:59.505]  $ times        : int 4
[17:40:59.505]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:59.505]  $ stop_if_not  :function (...)  
[17:40:59.505]  $ dim          : int [1:2] 2 2
[17:40:59.505]  $ valid_types  : chr [1:2] "logical" "integer"
[17:40:59.505]  $ ...          : list()
[17:40:59.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:59.505]  - attr(*, "where")=List of 8
[17:40:59.505]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:59.505]   ..$ ...          :<environment: 0x564f310e9bf8> 
[17:40:59.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:59.505]  - attr(*, "resolved")= logi FALSE
[17:40:59.505]  - attr(*, "total_size")= num 97232
[17:40:59.510] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:59.510] getGlobalsAndPackagesXApply() ... DONE
[17:40:59.511] Number of futures (= number of chunks): 2
[17:40:59.511] Launching 2 futures (chunks) ...
[17:40:59.511] Chunk #1 of 2 ...
[17:40:59.511]  - Finding globals in 'X' for chunk #1 ...
[17:40:59.511] getGlobalsAndPackages() ...
[17:40:59.511] Searching for globals...
[17:40:59.511] 
[17:40:59.512] Searching for globals ... DONE
[17:40:59.512] - globals: [0] <none>
[17:40:59.512] getGlobalsAndPackages() ... DONE
[17:40:59.512]    + additional globals found: [n=0] 
[17:40:59.512]    + additional namespaces needed: [n=0] 
[17:40:59.512]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:59.512]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:59.512]  - seeds: <none>
[17:40:59.512] getGlobalsAndPackages() ...
[17:40:59.512] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.513] Resolving globals: FALSE
[17:40:59.513] Tweak future expression to call with '...' arguments ...
[17:40:59.513] {
[17:40:59.513]     do.call(function(...) {
[17:40:59.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.513]             on.exit(options(oopts), add = TRUE)
[17:40:59.513]         }
[17:40:59.513]         {
[17:40:59.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.513]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.513]             })
[17:40:59.513]         }
[17:40:59.513]     }, args = future.call.arguments)
[17:40:59.513] }
[17:40:59.513] Tweak future expression to call with '...' arguments ... DONE
[17:40:59.514] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.514] - packages: [1] ‘future.apply’
[17:40:59.514] getGlobalsAndPackages() ... DONE
[17:40:59.514] run() for ‘Future’ ...
[17:40:59.514] - state: ‘created’
[17:40:59.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.529] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.529]   - Field: ‘node’
[17:40:59.530]   - Field: ‘label’
[17:40:59.530]   - Field: ‘local’
[17:40:59.530]   - Field: ‘owner’
[17:40:59.530]   - Field: ‘envir’
[17:40:59.530]   - Field: ‘workers’
[17:40:59.530]   - Field: ‘packages’
[17:40:59.530]   - Field: ‘gc’
[17:40:59.530]   - Field: ‘conditions’
[17:40:59.530]   - Field: ‘persistent’
[17:40:59.530]   - Field: ‘expr’
[17:40:59.531]   - Field: ‘uuid’
[17:40:59.531]   - Field: ‘seed’
[17:40:59.531]   - Field: ‘version’
[17:40:59.531]   - Field: ‘result’
[17:40:59.531]   - Field: ‘asynchronous’
[17:40:59.531]   - Field: ‘calls’
[17:40:59.531]   - Field: ‘globals’
[17:40:59.531]   - Field: ‘stdout’
[17:40:59.531]   - Field: ‘earlySignal’
[17:40:59.531]   - Field: ‘lazy’
[17:40:59.532]   - Field: ‘state’
[17:40:59.532] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.532] - Launch lazy future ...
[17:40:59.532] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:59.532] Packages needed by future strategies (n = 0): <none>
[17:40:59.533] {
[17:40:59.533]     {
[17:40:59.533]         {
[17:40:59.533]             ...future.startTime <- base::Sys.time()
[17:40:59.533]             {
[17:40:59.533]                 {
[17:40:59.533]                   {
[17:40:59.533]                     {
[17:40:59.533]                       {
[17:40:59.533]                         base::local({
[17:40:59.533]                           has_future <- base::requireNamespace("future", 
[17:40:59.533]                             quietly = TRUE)
[17:40:59.533]                           if (has_future) {
[17:40:59.533]                             ns <- base::getNamespace("future")
[17:40:59.533]                             version <- ns[[".package"]][["version"]]
[17:40:59.533]                             if (is.null(version)) 
[17:40:59.533]                               version <- utils::packageVersion("future")
[17:40:59.533]                           }
[17:40:59.533]                           else {
[17:40:59.533]                             version <- NULL
[17:40:59.533]                           }
[17:40:59.533]                           if (!has_future || version < "1.8.0") {
[17:40:59.533]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.533]                               "", base::R.version$version.string), 
[17:40:59.533]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:59.533]                                 base::R.version$platform, 8 * 
[17:40:59.533]                                   base::.Machine$sizeof.pointer), 
[17:40:59.533]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.533]                                 "release", "version")], collapse = " "), 
[17:40:59.533]                               hostname = base::Sys.info()[["nodename"]])
[17:40:59.533]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.533]                               info)
[17:40:59.533]                             info <- base::paste(info, collapse = "; ")
[17:40:59.533]                             if (!has_future) {
[17:40:59.533]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.533]                                 info)
[17:40:59.533]                             }
[17:40:59.533]                             else {
[17:40:59.533]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.533]                                 info, version)
[17:40:59.533]                             }
[17:40:59.533]                             base::stop(msg)
[17:40:59.533]                           }
[17:40:59.533]                         })
[17:40:59.533]                       }
[17:40:59.533]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.533]                       base::options(mc.cores = 1L)
[17:40:59.533]                     }
[17:40:59.533]                     base::local({
[17:40:59.533]                       for (pkg in "future.apply") {
[17:40:59.533]                         base::loadNamespace(pkg)
[17:40:59.533]                         base::library(pkg, character.only = TRUE)
[17:40:59.533]                       }
[17:40:59.533]                     })
[17:40:59.533]                   }
[17:40:59.533]                   options(future.plan = NULL)
[17:40:59.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.533]                 }
[17:40:59.533]                 ...future.workdir <- getwd()
[17:40:59.533]             }
[17:40:59.533]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.533]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.533]         }
[17:40:59.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.533]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:59.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.533]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.533]             base::names(...future.oldOptions))
[17:40:59.533]     }
[17:40:59.533]     if (FALSE) {
[17:40:59.533]     }
[17:40:59.533]     else {
[17:40:59.533]         if (TRUE) {
[17:40:59.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.533]                 open = "w")
[17:40:59.533]         }
[17:40:59.533]         else {
[17:40:59.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.533]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.533]         }
[17:40:59.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.533]             base::sink(type = "output", split = FALSE)
[17:40:59.533]             base::close(...future.stdout)
[17:40:59.533]         }, add = TRUE)
[17:40:59.533]     }
[17:40:59.533]     ...future.frame <- base::sys.nframe()
[17:40:59.533]     ...future.conditions <- base::list()
[17:40:59.533]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.533]     if (FALSE) {
[17:40:59.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.533]     }
[17:40:59.533]     ...future.result <- base::tryCatch({
[17:40:59.533]         base::withCallingHandlers({
[17:40:59.533]             ...future.value <- base::withVisible(base::local({
[17:40:59.533]                 ...future.makeSendCondition <- local({
[17:40:59.533]                   sendCondition <- NULL
[17:40:59.533]                   function(frame = 1L) {
[17:40:59.533]                     if (is.function(sendCondition)) 
[17:40:59.533]                       return(sendCondition)
[17:40:59.533]                     ns <- getNamespace("parallel")
[17:40:59.533]                     if (exists("sendData", mode = "function", 
[17:40:59.533]                       envir = ns)) {
[17:40:59.533]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.533]                         envir = ns)
[17:40:59.533]                       envir <- sys.frame(frame)
[17:40:59.533]                       master <- NULL
[17:40:59.533]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.533]                         !identical(envir, emptyenv())) {
[17:40:59.533]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.533]                           inherits = FALSE)) {
[17:40:59.533]                           master <- get("master", mode = "list", 
[17:40:59.533]                             envir = envir, inherits = FALSE)
[17:40:59.533]                           if (inherits(master, c("SOCKnode", 
[17:40:59.533]                             "SOCK0node"))) {
[17:40:59.533]                             sendCondition <<- function(cond) {
[17:40:59.533]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.533]                                 success = TRUE)
[17:40:59.533]                               parallel_sendData(master, data)
[17:40:59.533]                             }
[17:40:59.533]                             return(sendCondition)
[17:40:59.533]                           }
[17:40:59.533]                         }
[17:40:59.533]                         frame <- frame + 1L
[17:40:59.533]                         envir <- sys.frame(frame)
[17:40:59.533]                       }
[17:40:59.533]                     }
[17:40:59.533]                     sendCondition <<- function(cond) NULL
[17:40:59.533]                   }
[17:40:59.533]                 })
[17:40:59.533]                 withCallingHandlers({
[17:40:59.533]                   {
[17:40:59.533]                     do.call(function(...) {
[17:40:59.533]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.533]                       if (!identical(...future.globals.maxSize.org, 
[17:40:59.533]                         ...future.globals.maxSize)) {
[17:40:59.533]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.533]                         on.exit(options(oopts), add = TRUE)
[17:40:59.533]                       }
[17:40:59.533]                       {
[17:40:59.533]                         lapply(seq_along(...future.elements_ii), 
[17:40:59.533]                           FUN = function(jj) {
[17:40:59.533]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.533]                             ...future.FUN(...future.X_jj, ...)
[17:40:59.533]                           })
[17:40:59.533]                       }
[17:40:59.533]                     }, args = future.call.arguments)
[17:40:59.533]                   }
[17:40:59.533]                 }, immediateCondition = function(cond) {
[17:40:59.533]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.533]                   sendCondition(cond)
[17:40:59.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.533]                   {
[17:40:59.533]                     inherits <- base::inherits
[17:40:59.533]                     invokeRestart <- base::invokeRestart
[17:40:59.533]                     is.null <- base::is.null
[17:40:59.533]                     muffled <- FALSE
[17:40:59.533]                     if (inherits(cond, "message")) {
[17:40:59.533]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.533]                       if (muffled) 
[17:40:59.533]                         invokeRestart("muffleMessage")
[17:40:59.533]                     }
[17:40:59.533]                     else if (inherits(cond, "warning")) {
[17:40:59.533]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.533]                       if (muffled) 
[17:40:59.533]                         invokeRestart("muffleWarning")
[17:40:59.533]                     }
[17:40:59.533]                     else if (inherits(cond, "condition")) {
[17:40:59.533]                       if (!is.null(pattern)) {
[17:40:59.533]                         computeRestarts <- base::computeRestarts
[17:40:59.533]                         grepl <- base::grepl
[17:40:59.533]                         restarts <- computeRestarts(cond)
[17:40:59.533]                         for (restart in restarts) {
[17:40:59.533]                           name <- restart$name
[17:40:59.533]                           if (is.null(name)) 
[17:40:59.533]                             next
[17:40:59.533]                           if (!grepl(pattern, name)) 
[17:40:59.533]                             next
[17:40:59.533]                           invokeRestart(restart)
[17:40:59.533]                           muffled <- TRUE
[17:40:59.533]                           break
[17:40:59.533]                         }
[17:40:59.533]                       }
[17:40:59.533]                     }
[17:40:59.533]                     invisible(muffled)
[17:40:59.533]                   }
[17:40:59.533]                   muffleCondition(cond)
[17:40:59.533]                 })
[17:40:59.533]             }))
[17:40:59.533]             future::FutureResult(value = ...future.value$value, 
[17:40:59.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.533]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.533]                     ...future.globalenv.names))
[17:40:59.533]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.533]         }, condition = base::local({
[17:40:59.533]             c <- base::c
[17:40:59.533]             inherits <- base::inherits
[17:40:59.533]             invokeRestart <- base::invokeRestart
[17:40:59.533]             length <- base::length
[17:40:59.533]             list <- base::list
[17:40:59.533]             seq.int <- base::seq.int
[17:40:59.533]             signalCondition <- base::signalCondition
[17:40:59.533]             sys.calls <- base::sys.calls
[17:40:59.533]             `[[` <- base::`[[`
[17:40:59.533]             `+` <- base::`+`
[17:40:59.533]             `<<-` <- base::`<<-`
[17:40:59.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.533]                   3L)]
[17:40:59.533]             }
[17:40:59.533]             function(cond) {
[17:40:59.533]                 is_error <- inherits(cond, "error")
[17:40:59.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.533]                   NULL)
[17:40:59.533]                 if (is_error) {
[17:40:59.533]                   sessionInformation <- function() {
[17:40:59.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.533]                       search = base::search(), system = base::Sys.info())
[17:40:59.533]                   }
[17:40:59.533]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.533]                     cond$call), session = sessionInformation(), 
[17:40:59.533]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.533]                   signalCondition(cond)
[17:40:59.533]                 }
[17:40:59.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.533]                 "immediateCondition"))) {
[17:40:59.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.533]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.533]                   if (TRUE && !signal) {
[17:40:59.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.533]                     {
[17:40:59.533]                       inherits <- base::inherits
[17:40:59.533]                       invokeRestart <- base::invokeRestart
[17:40:59.533]                       is.null <- base::is.null
[17:40:59.533]                       muffled <- FALSE
[17:40:59.533]                       if (inherits(cond, "message")) {
[17:40:59.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.533]                         if (muffled) 
[17:40:59.533]                           invokeRestart("muffleMessage")
[17:40:59.533]                       }
[17:40:59.533]                       else if (inherits(cond, "warning")) {
[17:40:59.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.533]                         if (muffled) 
[17:40:59.533]                           invokeRestart("muffleWarning")
[17:40:59.533]                       }
[17:40:59.533]                       else if (inherits(cond, "condition")) {
[17:40:59.533]                         if (!is.null(pattern)) {
[17:40:59.533]                           computeRestarts <- base::computeRestarts
[17:40:59.533]                           grepl <- base::grepl
[17:40:59.533]                           restarts <- computeRestarts(cond)
[17:40:59.533]                           for (restart in restarts) {
[17:40:59.533]                             name <- restart$name
[17:40:59.533]                             if (is.null(name)) 
[17:40:59.533]                               next
[17:40:59.533]                             if (!grepl(pattern, name)) 
[17:40:59.533]                               next
[17:40:59.533]                             invokeRestart(restart)
[17:40:59.533]                             muffled <- TRUE
[17:40:59.533]                             break
[17:40:59.533]                           }
[17:40:59.533]                         }
[17:40:59.533]                       }
[17:40:59.533]                       invisible(muffled)
[17:40:59.533]                     }
[17:40:59.533]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.533]                   }
[17:40:59.533]                 }
[17:40:59.533]                 else {
[17:40:59.533]                   if (TRUE) {
[17:40:59.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.533]                     {
[17:40:59.533]                       inherits <- base::inherits
[17:40:59.533]                       invokeRestart <- base::invokeRestart
[17:40:59.533]                       is.null <- base::is.null
[17:40:59.533]                       muffled <- FALSE
[17:40:59.533]                       if (inherits(cond, "message")) {
[17:40:59.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.533]                         if (muffled) 
[17:40:59.533]                           invokeRestart("muffleMessage")
[17:40:59.533]                       }
[17:40:59.533]                       else if (inherits(cond, "warning")) {
[17:40:59.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.533]                         if (muffled) 
[17:40:59.533]                           invokeRestart("muffleWarning")
[17:40:59.533]                       }
[17:40:59.533]                       else if (inherits(cond, "condition")) {
[17:40:59.533]                         if (!is.null(pattern)) {
[17:40:59.533]                           computeRestarts <- base::computeRestarts
[17:40:59.533]                           grepl <- base::grepl
[17:40:59.533]                           restarts <- computeRestarts(cond)
[17:40:59.533]                           for (restart in restarts) {
[17:40:59.533]                             name <- restart$name
[17:40:59.533]                             if (is.null(name)) 
[17:40:59.533]                               next
[17:40:59.533]                             if (!grepl(pattern, name)) 
[17:40:59.533]                               next
[17:40:59.533]                             invokeRestart(restart)
[17:40:59.533]                             muffled <- TRUE
[17:40:59.533]                             break
[17:40:59.533]                           }
[17:40:59.533]                         }
[17:40:59.533]                       }
[17:40:59.533]                       invisible(muffled)
[17:40:59.533]                     }
[17:40:59.533]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.533]                   }
[17:40:59.533]                 }
[17:40:59.533]             }
[17:40:59.533]         }))
[17:40:59.533]     }, error = function(ex) {
[17:40:59.533]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.533]                 ...future.rng), started = ...future.startTime, 
[17:40:59.533]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.533]             version = "1.8"), class = "FutureResult")
[17:40:59.533]     }, finally = {
[17:40:59.533]         if (!identical(...future.workdir, getwd())) 
[17:40:59.533]             setwd(...future.workdir)
[17:40:59.533]         {
[17:40:59.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.533]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.533]             }
[17:40:59.533]             base::options(...future.oldOptions)
[17:40:59.533]             if (.Platform$OS.type == "windows") {
[17:40:59.533]                 old_names <- names(...future.oldEnvVars)
[17:40:59.533]                 envs <- base::Sys.getenv()
[17:40:59.533]                 names <- names(envs)
[17:40:59.533]                 common <- intersect(names, old_names)
[17:40:59.533]                 added <- setdiff(names, old_names)
[17:40:59.533]                 removed <- setdiff(old_names, names)
[17:40:59.533]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.533]                   envs[common]]
[17:40:59.533]                 NAMES <- toupper(changed)
[17:40:59.533]                 args <- list()
[17:40:59.533]                 for (kk in seq_along(NAMES)) {
[17:40:59.533]                   name <- changed[[kk]]
[17:40:59.533]                   NAME <- NAMES[[kk]]
[17:40:59.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.533]                     next
[17:40:59.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.533]                 }
[17:40:59.533]                 NAMES <- toupper(added)
[17:40:59.533]                 for (kk in seq_along(NAMES)) {
[17:40:59.533]                   name <- added[[kk]]
[17:40:59.533]                   NAME <- NAMES[[kk]]
[17:40:59.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.533]                     next
[17:40:59.533]                   args[[name]] <- ""
[17:40:59.533]                 }
[17:40:59.533]                 NAMES <- toupper(removed)
[17:40:59.533]                 for (kk in seq_along(NAMES)) {
[17:40:59.533]                   name <- removed[[kk]]
[17:40:59.533]                   NAME <- NAMES[[kk]]
[17:40:59.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.533]                     next
[17:40:59.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.533]                 }
[17:40:59.533]                 if (length(args) > 0) 
[17:40:59.533]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.533]             }
[17:40:59.533]             else {
[17:40:59.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.533]             }
[17:40:59.533]             {
[17:40:59.533]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.533]                   0L) {
[17:40:59.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.533]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.533]                   base::options(opts)
[17:40:59.533]                 }
[17:40:59.533]                 {
[17:40:59.533]                   {
[17:40:59.533]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.533]                     NULL
[17:40:59.533]                   }
[17:40:59.533]                   options(future.plan = NULL)
[17:40:59.533]                   if (is.na(NA_character_)) 
[17:40:59.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.533]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:59.533]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:59.533]                     envir = parent.frame()) 
[17:40:59.533]                   {
[17:40:59.533]                     if (is.function(workers)) 
[17:40:59.533]                       workers <- workers()
[17:40:59.533]                     workers <- structure(as.integer(workers), 
[17:40:59.533]                       class = class(workers))
[17:40:59.533]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:59.533]                       workers >= 1)
[17:40:59.533]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:59.533]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:59.533]                     }
[17:40:59.533]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:59.533]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:59.533]                       envir = envir)
[17:40:59.533]                     if (!future$lazy) 
[17:40:59.533]                       future <- run(future)
[17:40:59.533]                     invisible(future)
[17:40:59.533]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:59.533]                 }
[17:40:59.533]             }
[17:40:59.533]         }
[17:40:59.533]     })
[17:40:59.533]     if (TRUE) {
[17:40:59.533]         base::sink(type = "output", split = FALSE)
[17:40:59.533]         if (TRUE) {
[17:40:59.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.533]         }
[17:40:59.533]         else {
[17:40:59.533]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.533]         }
[17:40:59.533]         base::close(...future.stdout)
[17:40:59.533]         ...future.stdout <- NULL
[17:40:59.533]     }
[17:40:59.533]     ...future.result$conditions <- ...future.conditions
[17:40:59.533]     ...future.result$finished <- base::Sys.time()
[17:40:59.533]     ...future.result
[17:40:59.533] }
[17:40:59.536] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[17:40:59.536] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:40:59.579] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:40:59.580] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:40:59.580] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:40:59.580] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:40:59.581] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:40:59.581] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:40:59.627] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:40:59.628] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:40:59.671] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:40:59.671] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:40:59.672] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:40:59.672] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:40:59.672] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:40:59.673] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:40:59.673] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.673] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:40:59.674] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:40:59.674] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:40:59.674] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.674] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:40:59.675] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:40:59.675] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[17:40:59.675] MultisessionFuture started
[17:40:59.676] - Launch lazy future ... done
[17:40:59.676] run() for ‘MultisessionFuture’ ... done
[17:40:59.676] Created future:
[17:40:59.676] MultisessionFuture:
[17:40:59.676] Label: ‘future_vapply-1’
[17:40:59.676] Expression:
[17:40:59.676] {
[17:40:59.676]     do.call(function(...) {
[17:40:59.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.676]             on.exit(options(oopts), add = TRUE)
[17:40:59.676]         }
[17:40:59.676]         {
[17:40:59.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.676]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.676]             })
[17:40:59.676]         }
[17:40:59.676]     }, args = future.call.arguments)
[17:40:59.676] }
[17:40:59.676] Lazy evaluation: FALSE
[17:40:59.676] Asynchronous evaluation: TRUE
[17:40:59.676] Local evaluation: TRUE
[17:40:59.676] Environment: R_GlobalEnv
[17:40:59.676] Capture standard output: TRUE
[17:40:59.676] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:59.676] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:59.676] Packages: 1 packages (‘future.apply’)
[17:40:59.676] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:59.676] Resolved: FALSE
[17:40:59.676] Value: <not collected>
[17:40:59.676] Conditions captured: <none>
[17:40:59.676] Early signaling: FALSE
[17:40:59.676] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:59.676] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.688] Chunk #1 of 2 ... DONE
[17:40:59.688] Chunk #2 of 2 ...
[17:40:59.688]  - Finding globals in 'X' for chunk #2 ...
[17:40:59.688] getGlobalsAndPackages() ...
[17:40:59.688] Searching for globals...
[17:40:59.689] 
[17:40:59.689] Searching for globals ... DONE
[17:40:59.689] - globals: [0] <none>
[17:40:59.689] getGlobalsAndPackages() ... DONE
[17:40:59.689]    + additional globals found: [n=0] 
[17:40:59.689]    + additional namespaces needed: [n=0] 
[17:40:59.689]  - Finding globals in 'X' for chunk #2 ... DONE
[17:40:59.689]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:59.689]  - seeds: <none>
[17:40:59.689] getGlobalsAndPackages() ...
[17:40:59.690] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.690] Resolving globals: FALSE
[17:40:59.690] Tweak future expression to call with '...' arguments ...
[17:40:59.690] {
[17:40:59.690]     do.call(function(...) {
[17:40:59.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.690]             on.exit(options(oopts), add = TRUE)
[17:40:59.690]         }
[17:40:59.690]         {
[17:40:59.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.690]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.690]             })
[17:40:59.690]         }
[17:40:59.690]     }, args = future.call.arguments)
[17:40:59.690] }
[17:40:59.690] Tweak future expression to call with '...' arguments ... DONE
[17:40:59.691] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.691] - packages: [1] ‘future.apply’
[17:40:59.691] getGlobalsAndPackages() ... DONE
[17:40:59.691] run() for ‘Future’ ...
[17:40:59.691] - state: ‘created’
[17:40:59.692] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.707] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.707]   - Field: ‘node’
[17:40:59.707]   - Field: ‘label’
[17:40:59.708]   - Field: ‘local’
[17:40:59.708]   - Field: ‘owner’
[17:40:59.708]   - Field: ‘envir’
[17:40:59.708]   - Field: ‘workers’
[17:40:59.708]   - Field: ‘packages’
[17:40:59.708]   - Field: ‘gc’
[17:40:59.708]   - Field: ‘conditions’
[17:40:59.708]   - Field: ‘persistent’
[17:40:59.708]   - Field: ‘expr’
[17:40:59.708]   - Field: ‘uuid’
[17:40:59.708]   - Field: ‘seed’
[17:40:59.708]   - Field: ‘version’
[17:40:59.709]   - Field: ‘result’
[17:40:59.709]   - Field: ‘asynchronous’
[17:40:59.709]   - Field: ‘calls’
[17:40:59.709]   - Field: ‘globals’
[17:40:59.709]   - Field: ‘stdout’
[17:40:59.709]   - Field: ‘earlySignal’
[17:40:59.709]   - Field: ‘lazy’
[17:40:59.709]   - Field: ‘state’
[17:40:59.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.709] - Launch lazy future ...
[17:40:59.710] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:59.710] Packages needed by future strategies (n = 0): <none>
[17:40:59.710] {
[17:40:59.710]     {
[17:40:59.710]         {
[17:40:59.710]             ...future.startTime <- base::Sys.time()
[17:40:59.710]             {
[17:40:59.710]                 {
[17:40:59.710]                   {
[17:40:59.710]                     {
[17:40:59.710]                       {
[17:40:59.710]                         base::local({
[17:40:59.710]                           has_future <- base::requireNamespace("future", 
[17:40:59.710]                             quietly = TRUE)
[17:40:59.710]                           if (has_future) {
[17:40:59.710]                             ns <- base::getNamespace("future")
[17:40:59.710]                             version <- ns[[".package"]][["version"]]
[17:40:59.710]                             if (is.null(version)) 
[17:40:59.710]                               version <- utils::packageVersion("future")
[17:40:59.710]                           }
[17:40:59.710]                           else {
[17:40:59.710]                             version <- NULL
[17:40:59.710]                           }
[17:40:59.710]                           if (!has_future || version < "1.8.0") {
[17:40:59.710]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.710]                               "", base::R.version$version.string), 
[17:40:59.710]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:59.710]                                 base::R.version$platform, 8 * 
[17:40:59.710]                                   base::.Machine$sizeof.pointer), 
[17:40:59.710]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.710]                                 "release", "version")], collapse = " "), 
[17:40:59.710]                               hostname = base::Sys.info()[["nodename"]])
[17:40:59.710]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.710]                               info)
[17:40:59.710]                             info <- base::paste(info, collapse = "; ")
[17:40:59.710]                             if (!has_future) {
[17:40:59.710]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.710]                                 info)
[17:40:59.710]                             }
[17:40:59.710]                             else {
[17:40:59.710]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.710]                                 info, version)
[17:40:59.710]                             }
[17:40:59.710]                             base::stop(msg)
[17:40:59.710]                           }
[17:40:59.710]                         })
[17:40:59.710]                       }
[17:40:59.710]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.710]                       base::options(mc.cores = 1L)
[17:40:59.710]                     }
[17:40:59.710]                     base::local({
[17:40:59.710]                       for (pkg in "future.apply") {
[17:40:59.710]                         base::loadNamespace(pkg)
[17:40:59.710]                         base::library(pkg, character.only = TRUE)
[17:40:59.710]                       }
[17:40:59.710]                     })
[17:40:59.710]                   }
[17:40:59.710]                   options(future.plan = NULL)
[17:40:59.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.710]                 }
[17:40:59.710]                 ...future.workdir <- getwd()
[17:40:59.710]             }
[17:40:59.710]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.710]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.710]         }
[17:40:59.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.710]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:59.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.710]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.710]             base::names(...future.oldOptions))
[17:40:59.710]     }
[17:40:59.710]     if (FALSE) {
[17:40:59.710]     }
[17:40:59.710]     else {
[17:40:59.710]         if (TRUE) {
[17:40:59.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.710]                 open = "w")
[17:40:59.710]         }
[17:40:59.710]         else {
[17:40:59.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.710]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.710]         }
[17:40:59.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.710]             base::sink(type = "output", split = FALSE)
[17:40:59.710]             base::close(...future.stdout)
[17:40:59.710]         }, add = TRUE)
[17:40:59.710]     }
[17:40:59.710]     ...future.frame <- base::sys.nframe()
[17:40:59.710]     ...future.conditions <- base::list()
[17:40:59.710]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.710]     if (FALSE) {
[17:40:59.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.710]     }
[17:40:59.710]     ...future.result <- base::tryCatch({
[17:40:59.710]         base::withCallingHandlers({
[17:40:59.710]             ...future.value <- base::withVisible(base::local({
[17:40:59.710]                 ...future.makeSendCondition <- local({
[17:40:59.710]                   sendCondition <- NULL
[17:40:59.710]                   function(frame = 1L) {
[17:40:59.710]                     if (is.function(sendCondition)) 
[17:40:59.710]                       return(sendCondition)
[17:40:59.710]                     ns <- getNamespace("parallel")
[17:40:59.710]                     if (exists("sendData", mode = "function", 
[17:40:59.710]                       envir = ns)) {
[17:40:59.710]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.710]                         envir = ns)
[17:40:59.710]                       envir <- sys.frame(frame)
[17:40:59.710]                       master <- NULL
[17:40:59.710]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.710]                         !identical(envir, emptyenv())) {
[17:40:59.710]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.710]                           inherits = FALSE)) {
[17:40:59.710]                           master <- get("master", mode = "list", 
[17:40:59.710]                             envir = envir, inherits = FALSE)
[17:40:59.710]                           if (inherits(master, c("SOCKnode", 
[17:40:59.710]                             "SOCK0node"))) {
[17:40:59.710]                             sendCondition <<- function(cond) {
[17:40:59.710]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.710]                                 success = TRUE)
[17:40:59.710]                               parallel_sendData(master, data)
[17:40:59.710]                             }
[17:40:59.710]                             return(sendCondition)
[17:40:59.710]                           }
[17:40:59.710]                         }
[17:40:59.710]                         frame <- frame + 1L
[17:40:59.710]                         envir <- sys.frame(frame)
[17:40:59.710]                       }
[17:40:59.710]                     }
[17:40:59.710]                     sendCondition <<- function(cond) NULL
[17:40:59.710]                   }
[17:40:59.710]                 })
[17:40:59.710]                 withCallingHandlers({
[17:40:59.710]                   {
[17:40:59.710]                     do.call(function(...) {
[17:40:59.710]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.710]                       if (!identical(...future.globals.maxSize.org, 
[17:40:59.710]                         ...future.globals.maxSize)) {
[17:40:59.710]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.710]                         on.exit(options(oopts), add = TRUE)
[17:40:59.710]                       }
[17:40:59.710]                       {
[17:40:59.710]                         lapply(seq_along(...future.elements_ii), 
[17:40:59.710]                           FUN = function(jj) {
[17:40:59.710]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.710]                             ...future.FUN(...future.X_jj, ...)
[17:40:59.710]                           })
[17:40:59.710]                       }
[17:40:59.710]                     }, args = future.call.arguments)
[17:40:59.710]                   }
[17:40:59.710]                 }, immediateCondition = function(cond) {
[17:40:59.710]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.710]                   sendCondition(cond)
[17:40:59.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.710]                   {
[17:40:59.710]                     inherits <- base::inherits
[17:40:59.710]                     invokeRestart <- base::invokeRestart
[17:40:59.710]                     is.null <- base::is.null
[17:40:59.710]                     muffled <- FALSE
[17:40:59.710]                     if (inherits(cond, "message")) {
[17:40:59.710]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.710]                       if (muffled) 
[17:40:59.710]                         invokeRestart("muffleMessage")
[17:40:59.710]                     }
[17:40:59.710]                     else if (inherits(cond, "warning")) {
[17:40:59.710]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.710]                       if (muffled) 
[17:40:59.710]                         invokeRestart("muffleWarning")
[17:40:59.710]                     }
[17:40:59.710]                     else if (inherits(cond, "condition")) {
[17:40:59.710]                       if (!is.null(pattern)) {
[17:40:59.710]                         computeRestarts <- base::computeRestarts
[17:40:59.710]                         grepl <- base::grepl
[17:40:59.710]                         restarts <- computeRestarts(cond)
[17:40:59.710]                         for (restart in restarts) {
[17:40:59.710]                           name <- restart$name
[17:40:59.710]                           if (is.null(name)) 
[17:40:59.710]                             next
[17:40:59.710]                           if (!grepl(pattern, name)) 
[17:40:59.710]                             next
[17:40:59.710]                           invokeRestart(restart)
[17:40:59.710]                           muffled <- TRUE
[17:40:59.710]                           break
[17:40:59.710]                         }
[17:40:59.710]                       }
[17:40:59.710]                     }
[17:40:59.710]                     invisible(muffled)
[17:40:59.710]                   }
[17:40:59.710]                   muffleCondition(cond)
[17:40:59.710]                 })
[17:40:59.710]             }))
[17:40:59.710]             future::FutureResult(value = ...future.value$value, 
[17:40:59.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.710]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.710]                     ...future.globalenv.names))
[17:40:59.710]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.710]         }, condition = base::local({
[17:40:59.710]             c <- base::c
[17:40:59.710]             inherits <- base::inherits
[17:40:59.710]             invokeRestart <- base::invokeRestart
[17:40:59.710]             length <- base::length
[17:40:59.710]             list <- base::list
[17:40:59.710]             seq.int <- base::seq.int
[17:40:59.710]             signalCondition <- base::signalCondition
[17:40:59.710]             sys.calls <- base::sys.calls
[17:40:59.710]             `[[` <- base::`[[`
[17:40:59.710]             `+` <- base::`+`
[17:40:59.710]             `<<-` <- base::`<<-`
[17:40:59.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.710]                   3L)]
[17:40:59.710]             }
[17:40:59.710]             function(cond) {
[17:40:59.710]                 is_error <- inherits(cond, "error")
[17:40:59.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.710]                   NULL)
[17:40:59.710]                 if (is_error) {
[17:40:59.710]                   sessionInformation <- function() {
[17:40:59.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.710]                       search = base::search(), system = base::Sys.info())
[17:40:59.710]                   }
[17:40:59.710]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.710]                     cond$call), session = sessionInformation(), 
[17:40:59.710]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.710]                   signalCondition(cond)
[17:40:59.710]                 }
[17:40:59.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.710]                 "immediateCondition"))) {
[17:40:59.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.710]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.710]                   if (TRUE && !signal) {
[17:40:59.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.710]                     {
[17:40:59.710]                       inherits <- base::inherits
[17:40:59.710]                       invokeRestart <- base::invokeRestart
[17:40:59.710]                       is.null <- base::is.null
[17:40:59.710]                       muffled <- FALSE
[17:40:59.710]                       if (inherits(cond, "message")) {
[17:40:59.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.710]                         if (muffled) 
[17:40:59.710]                           invokeRestart("muffleMessage")
[17:40:59.710]                       }
[17:40:59.710]                       else if (inherits(cond, "warning")) {
[17:40:59.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.710]                         if (muffled) 
[17:40:59.710]                           invokeRestart("muffleWarning")
[17:40:59.710]                       }
[17:40:59.710]                       else if (inherits(cond, "condition")) {
[17:40:59.710]                         if (!is.null(pattern)) {
[17:40:59.710]                           computeRestarts <- base::computeRestarts
[17:40:59.710]                           grepl <- base::grepl
[17:40:59.710]                           restarts <- computeRestarts(cond)
[17:40:59.710]                           for (restart in restarts) {
[17:40:59.710]                             name <- restart$name
[17:40:59.710]                             if (is.null(name)) 
[17:40:59.710]                               next
[17:40:59.710]                             if (!grepl(pattern, name)) 
[17:40:59.710]                               next
[17:40:59.710]                             invokeRestart(restart)
[17:40:59.710]                             muffled <- TRUE
[17:40:59.710]                             break
[17:40:59.710]                           }
[17:40:59.710]                         }
[17:40:59.710]                       }
[17:40:59.710]                       invisible(muffled)
[17:40:59.710]                     }
[17:40:59.710]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.710]                   }
[17:40:59.710]                 }
[17:40:59.710]                 else {
[17:40:59.710]                   if (TRUE) {
[17:40:59.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.710]                     {
[17:40:59.710]                       inherits <- base::inherits
[17:40:59.710]                       invokeRestart <- base::invokeRestart
[17:40:59.710]                       is.null <- base::is.null
[17:40:59.710]                       muffled <- FALSE
[17:40:59.710]                       if (inherits(cond, "message")) {
[17:40:59.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.710]                         if (muffled) 
[17:40:59.710]                           invokeRestart("muffleMessage")
[17:40:59.710]                       }
[17:40:59.710]                       else if (inherits(cond, "warning")) {
[17:40:59.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.710]                         if (muffled) 
[17:40:59.710]                           invokeRestart("muffleWarning")
[17:40:59.710]                       }
[17:40:59.710]                       else if (inherits(cond, "condition")) {
[17:40:59.710]                         if (!is.null(pattern)) {
[17:40:59.710]                           computeRestarts <- base::computeRestarts
[17:40:59.710]                           grepl <- base::grepl
[17:40:59.710]                           restarts <- computeRestarts(cond)
[17:40:59.710]                           for (restart in restarts) {
[17:40:59.710]                             name <- restart$name
[17:40:59.710]                             if (is.null(name)) 
[17:40:59.710]                               next
[17:40:59.710]                             if (!grepl(pattern, name)) 
[17:40:59.710]                               next
[17:40:59.710]                             invokeRestart(restart)
[17:40:59.710]                             muffled <- TRUE
[17:40:59.710]                             break
[17:40:59.710]                           }
[17:40:59.710]                         }
[17:40:59.710]                       }
[17:40:59.710]                       invisible(muffled)
[17:40:59.710]                     }
[17:40:59.710]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.710]                   }
[17:40:59.710]                 }
[17:40:59.710]             }
[17:40:59.710]         }))
[17:40:59.710]     }, error = function(ex) {
[17:40:59.710]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.710]                 ...future.rng), started = ...future.startTime, 
[17:40:59.710]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.710]             version = "1.8"), class = "FutureResult")
[17:40:59.710]     }, finally = {
[17:40:59.710]         if (!identical(...future.workdir, getwd())) 
[17:40:59.710]             setwd(...future.workdir)
[17:40:59.710]         {
[17:40:59.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.710]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.710]             }
[17:40:59.710]             base::options(...future.oldOptions)
[17:40:59.710]             if (.Platform$OS.type == "windows") {
[17:40:59.710]                 old_names <- names(...future.oldEnvVars)
[17:40:59.710]                 envs <- base::Sys.getenv()
[17:40:59.710]                 names <- names(envs)
[17:40:59.710]                 common <- intersect(names, old_names)
[17:40:59.710]                 added <- setdiff(names, old_names)
[17:40:59.710]                 removed <- setdiff(old_names, names)
[17:40:59.710]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.710]                   envs[common]]
[17:40:59.710]                 NAMES <- toupper(changed)
[17:40:59.710]                 args <- list()
[17:40:59.710]                 for (kk in seq_along(NAMES)) {
[17:40:59.710]                   name <- changed[[kk]]
[17:40:59.710]                   NAME <- NAMES[[kk]]
[17:40:59.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.710]                     next
[17:40:59.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.710]                 }
[17:40:59.710]                 NAMES <- toupper(added)
[17:40:59.710]                 for (kk in seq_along(NAMES)) {
[17:40:59.710]                   name <- added[[kk]]
[17:40:59.710]                   NAME <- NAMES[[kk]]
[17:40:59.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.710]                     next
[17:40:59.710]                   args[[name]] <- ""
[17:40:59.710]                 }
[17:40:59.710]                 NAMES <- toupper(removed)
[17:40:59.710]                 for (kk in seq_along(NAMES)) {
[17:40:59.710]                   name <- removed[[kk]]
[17:40:59.710]                   NAME <- NAMES[[kk]]
[17:40:59.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.710]                     next
[17:40:59.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.710]                 }
[17:40:59.710]                 if (length(args) > 0) 
[17:40:59.710]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.710]             }
[17:40:59.710]             else {
[17:40:59.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.710]             }
[17:40:59.710]             {
[17:40:59.710]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.710]                   0L) {
[17:40:59.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.710]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.710]                   base::options(opts)
[17:40:59.710]                 }
[17:40:59.710]                 {
[17:40:59.710]                   {
[17:40:59.710]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.710]                     NULL
[17:40:59.710]                   }
[17:40:59.710]                   options(future.plan = NULL)
[17:40:59.710]                   if (is.na(NA_character_)) 
[17:40:59.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.710]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:59.710]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:59.710]                     envir = parent.frame()) 
[17:40:59.710]                   {
[17:40:59.710]                     if (is.function(workers)) 
[17:40:59.710]                       workers <- workers()
[17:40:59.710]                     workers <- structure(as.integer(workers), 
[17:40:59.710]                       class = class(workers))
[17:40:59.710]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:59.710]                       workers >= 1)
[17:40:59.710]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:59.710]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:59.710]                     }
[17:40:59.710]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:59.710]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:59.710]                       envir = envir)
[17:40:59.710]                     if (!future$lazy) 
[17:40:59.710]                       future <- run(future)
[17:40:59.710]                     invisible(future)
[17:40:59.710]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:59.710]                 }
[17:40:59.710]             }
[17:40:59.710]         }
[17:40:59.710]     })
[17:40:59.710]     if (TRUE) {
[17:40:59.710]         base::sink(type = "output", split = FALSE)
[17:40:59.710]         if (TRUE) {
[17:40:59.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.710]         }
[17:40:59.710]         else {
[17:40:59.710]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.710]         }
[17:40:59.710]         base::close(...future.stdout)
[17:40:59.710]         ...future.stdout <- NULL
[17:40:59.710]     }
[17:40:59.710]     ...future.result$conditions <- ...future.conditions
[17:40:59.710]     ...future.result$finished <- base::Sys.time()
[17:40:59.710]     ...future.result
[17:40:59.710] }
[17:40:59.713] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[17:40:59.713] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:40:59.755] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:40:59.755] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[17:40:59.756] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[17:40:59.756] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:40:59.756] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:40:59.756] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:40:59.799] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:40:59.799] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:40:59.843] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:40:59.844] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:40:59.844] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:40:59.844] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:40:59.844] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:40:59.845] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:40:59.845] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.845] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:40:59.846] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:40:59.846] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:40:59.846] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.847] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:40:59.847] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:40:59.847] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[17:40:59.848] MultisessionFuture started
[17:40:59.848] - Launch lazy future ... done
[17:40:59.848] run() for ‘MultisessionFuture’ ... done
[17:40:59.848] Created future:
[17:40:59.848] MultisessionFuture:
[17:40:59.848] Label: ‘future_vapply-2’
[17:40:59.848] Expression:
[17:40:59.848] {
[17:40:59.848]     do.call(function(...) {
[17:40:59.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.848]             on.exit(options(oopts), add = TRUE)
[17:40:59.848]         }
[17:40:59.848]         {
[17:40:59.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.848]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.848]             })
[17:40:59.848]         }
[17:40:59.848]     }, args = future.call.arguments)
[17:40:59.848] }
[17:40:59.848] Lazy evaluation: FALSE
[17:40:59.848] Asynchronous evaluation: TRUE
[17:40:59.848] Local evaluation: TRUE
[17:40:59.848] Environment: R_GlobalEnv
[17:40:59.848] Capture standard output: TRUE
[17:40:59.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:40:59.848] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:40:59.848] Packages: 1 packages (‘future.apply’)
[17:40:59.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:59.848] Resolved: FALSE
[17:40:59.848] Value: <not collected>
[17:40:59.848] Conditions captured: <none>
[17:40:59.848] Early signaling: FALSE
[17:40:59.848] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:40:59.848] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.860] Chunk #2 of 2 ... DONE
[17:40:59.860] Launching 2 futures (chunks) ... DONE
[17:40:59.860] Resolving 2 futures (chunks) ...
[17:40:59.860] resolve() on list ...
[17:40:59.860]  recursive: 0
[17:40:59.860]  length: 2
[17:40:59.860] 
[17:40:59.861] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.861] - Validating connection of MultisessionFuture
[17:40:59.861] - received message: FutureResult
[17:40:59.861] - Received FutureResult
[17:40:59.861] - Erased future from FutureRegistry
[17:40:59.862] result() for ClusterFuture ...
[17:40:59.862] - result already collected: FutureResult
[17:40:59.862] result() for ClusterFuture ... done
[17:40:59.862] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.862] Future #1
[17:40:59.862] result() for ClusterFuture ...
[17:40:59.862] - result already collected: FutureResult
[17:40:59.862] result() for ClusterFuture ... done
[17:40:59.862] result() for ClusterFuture ...
[17:40:59.862] - result already collected: FutureResult
[17:40:59.862] result() for ClusterFuture ... done
[17:40:59.862] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:40:59.863] - nx: 2
[17:40:59.863] - relay: TRUE
[17:40:59.863] - stdout: TRUE
[17:40:59.863] - signal: TRUE
[17:40:59.863] - resignal: FALSE
[17:40:59.863] - force: TRUE
[17:40:59.863] - relayed: [n=2] FALSE, FALSE
[17:40:59.863] - queued futures: [n=2] FALSE, FALSE
[17:40:59.863]  - until=1
[17:40:59.863]  - relaying element #1
[17:40:59.863] result() for ClusterFuture ...
[17:40:59.864] - result already collected: FutureResult
[17:40:59.864] result() for ClusterFuture ... done
[17:40:59.864] result() for ClusterFuture ...
[17:40:59.864] - result already collected: FutureResult
[17:40:59.864] result() for ClusterFuture ... done
[17:40:59.864] result() for ClusterFuture ...
[17:40:59.864] - result already collected: FutureResult
[17:40:59.864] result() for ClusterFuture ... done
[17:40:59.864] result() for ClusterFuture ...
[17:40:59.864] - result already collected: FutureResult
[17:40:59.864] result() for ClusterFuture ... done
[17:40:59.864] - relayed: [n=2] TRUE, FALSE
[17:40:59.865] - queued futures: [n=2] TRUE, FALSE
[17:40:59.865] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:40:59.865]  length: 1 (resolved future 1)
[17:40:59.906] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.907] - Validating connection of MultisessionFuture
[17:40:59.907] - received message: FutureResult
[17:40:59.907] - Received FutureResult
[17:40:59.907] - Erased future from FutureRegistry
[17:40:59.907] result() for ClusterFuture ...
[17:40:59.907] - result already collected: FutureResult
[17:40:59.908] result() for ClusterFuture ... done
[17:40:59.908] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.908] Future #2
[17:40:59.908] result() for ClusterFuture ...
[17:40:59.908] - result already collected: FutureResult
[17:40:59.908] result() for ClusterFuture ... done
[17:40:59.908] result() for ClusterFuture ...
[17:40:59.908] - result already collected: FutureResult
[17:40:59.908] result() for ClusterFuture ... done
[17:40:59.908] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:40:59.908] - nx: 2
[17:40:59.909] - relay: TRUE
[17:40:59.909] - stdout: TRUE
[17:40:59.909] - signal: TRUE
[17:40:59.909] - resignal: FALSE
[17:40:59.909] - force: TRUE
[17:40:59.909] - relayed: [n=2] TRUE, FALSE
[17:40:59.909] - queued futures: [n=2] TRUE, FALSE
[17:40:59.909]  - until=2
[17:40:59.909]  - relaying element #2
[17:40:59.909] result() for ClusterFuture ...
[17:40:59.909] - result already collected: FutureResult
[17:40:59.909] result() for ClusterFuture ... done
[17:40:59.910] result() for ClusterFuture ...
[17:40:59.910] - result already collected: FutureResult
[17:40:59.910] result() for ClusterFuture ... done
[17:40:59.910] result() for ClusterFuture ...
[17:40:59.910] - result already collected: FutureResult
[17:40:59.910] result() for ClusterFuture ... done
[17:40:59.910] result() for ClusterFuture ...
[17:40:59.910] - result already collected: FutureResult
[17:40:59.910] result() for ClusterFuture ... done
[17:40:59.910] - relayed: [n=2] TRUE, TRUE
[17:40:59.910] - queued futures: [n=2] TRUE, TRUE
[17:40:59.910] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:40:59.911]  length: 0 (resolved future 2)
[17:40:59.911] Relaying remaining futures
[17:40:59.911] signalConditionsASAP(NULL, pos=0) ...
[17:40:59.911] - nx: 2
[17:40:59.911] - relay: TRUE
[17:40:59.911] - stdout: TRUE
[17:40:59.911] - signal: TRUE
[17:40:59.911] - resignal: FALSE
[17:40:59.911] - force: TRUE
[17:40:59.911] - relayed: [n=2] TRUE, TRUE
[17:40:59.911] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:40:59.912] - relayed: [n=2] TRUE, TRUE
[17:40:59.912] - queued futures: [n=2] TRUE, TRUE
[17:40:59.912] signalConditionsASAP(NULL, pos=0) ... done
[17:40:59.912] resolve() on list ... DONE
[17:40:59.912] result() for ClusterFuture ...
[17:40:59.912] - result already collected: FutureResult
[17:40:59.912] result() for ClusterFuture ... done
[17:40:59.912] result() for ClusterFuture ...
[17:40:59.912] - result already collected: FutureResult
[17:40:59.912] result() for ClusterFuture ... done
[17:40:59.912] result() for ClusterFuture ...
[17:40:59.913] - result already collected: FutureResult
[17:40:59.913] result() for ClusterFuture ... done
[17:40:59.913] result() for ClusterFuture ...
[17:40:59.913] - result already collected: FutureResult
[17:40:59.913] result() for ClusterFuture ... done
[17:40:59.913]  - Number of value chunks collected: 2
[17:40:59.913] Resolving 2 futures (chunks) ... DONE
[17:40:59.913] Reducing values from 2 chunks ...
[17:40:59.913]  - Number of values collected after concatenation: 10
[17:40:59.913]  - Number of values expected: 10
[17:40:59.913] Reducing values from 2 chunks ... DONE
[17:40:59.914] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:40:59.915] future_lapply() ...
[17:40:59.920] Number of chunks: 2
[17:40:59.920] getGlobalsAndPackagesXApply() ...
[17:40:59.920]  - future.globals: TRUE
[17:40:59.920] getGlobalsAndPackages() ...
[17:40:59.920] Searching for globals...
[17:40:59.924] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:40:59.924] Searching for globals ... DONE
[17:40:59.924] Resolving globals: FALSE
[17:40:59.925] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:40:59.925] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:40:59.925] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:59.926] - packages: [1] ‘future.apply’
[17:40:59.926] getGlobalsAndPackages() ... DONE
[17:40:59.926]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:40:59.926]  - needed namespaces: [n=1] ‘future.apply’
[17:40:59.926] Finding globals ... DONE
[17:40:59.926]  - use_args: TRUE
[17:40:59.926]  - Getting '...' globals ...
[17:40:59.926] resolve() on list ...
[17:40:59.927]  recursive: 0
[17:40:59.927]  length: 1
[17:40:59.927]  elements: ‘...’
[17:40:59.927]  length: 0 (resolved future 1)
[17:40:59.927] resolve() on list ... DONE
[17:40:59.927]    - '...' content: [n=0] 
[17:40:59.927] List of 1
[17:40:59.927]  $ ...: list()
[17:40:59.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:59.927]  - attr(*, "where")=List of 1
[17:40:59.927]   ..$ ...:<environment: 0x564f3118c5c8> 
[17:40:59.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:59.927]  - attr(*, "resolved")= logi TRUE
[17:40:59.927]  - attr(*, "total_size")= num NA
[17:40:59.930]  - Getting '...' globals ... DONE
[17:40:59.930] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:40:59.930] List of 8
[17:40:59.930]  $ ...future.FUN:function (x, ...)  
[17:40:59.930]  $ x_FUN        :function (x)  
[17:40:59.930]  $ times        : int 4
[17:40:59.930]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:40:59.930]  $ stop_if_not  :function (...)  
[17:40:59.930]  $ dim          : int [1:2] 2 2
[17:40:59.930]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:40:59.930]  $ ...          : list()
[17:40:59.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:40:59.930]  - attr(*, "where")=List of 8
[17:40:59.930]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ times        :<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ dim          :<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:40:59.930]   ..$ ...          :<environment: 0x564f3118c5c8> 
[17:40:59.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:59.930]  - attr(*, "resolved")= logi FALSE
[17:40:59.930]  - attr(*, "total_size")= num 97304
[17:40:59.935] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:40:59.935] getGlobalsAndPackagesXApply() ... DONE
[17:40:59.936] Number of futures (= number of chunks): 2
[17:40:59.936] Launching 2 futures (chunks) ...
[17:40:59.936] Chunk #1 of 2 ...
[17:40:59.936]  - Finding globals in 'X' for chunk #1 ...
[17:40:59.936] getGlobalsAndPackages() ...
[17:40:59.936] Searching for globals...
[17:40:59.936] 
[17:40:59.936] Searching for globals ... DONE
[17:40:59.937] - globals: [0] <none>
[17:40:59.937] getGlobalsAndPackages() ... DONE
[17:40:59.937]    + additional globals found: [n=0] 
[17:40:59.937]    + additional namespaces needed: [n=0] 
[17:40:59.937]  - Finding globals in 'X' for chunk #1 ... DONE
[17:40:59.937]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:40:59.937]  - seeds: <none>
[17:40:59.937] getGlobalsAndPackages() ...
[17:40:59.937] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.937] Resolving globals: FALSE
[17:40:59.938] Tweak future expression to call with '...' arguments ...
[17:40:59.938] {
[17:40:59.938]     do.call(function(...) {
[17:40:59.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:40:59.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.938]             on.exit(options(oopts), add = TRUE)
[17:40:59.938]         }
[17:40:59.938]         {
[17:40:59.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:40:59.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.938]                 ...future.FUN(...future.X_jj, ...)
[17:40:59.938]             })
[17:40:59.938]         }
[17:40:59.938]     }, args = future.call.arguments)
[17:40:59.938] }
[17:40:59.938] Tweak future expression to call with '...' arguments ... DONE
[17:40:59.938] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:40:59.939] - packages: [1] ‘future.apply’
[17:40:59.939] getGlobalsAndPackages() ... DONE
[17:40:59.939] run() for ‘Future’ ...
[17:40:59.939] - state: ‘created’
[17:40:59.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.955]   - Field: ‘node’
[17:40:59.955]   - Field: ‘label’
[17:40:59.955]   - Field: ‘local’
[17:40:59.955]   - Field: ‘owner’
[17:40:59.955]   - Field: ‘envir’
[17:40:59.955]   - Field: ‘workers’
[17:40:59.955]   - Field: ‘packages’
[17:40:59.955]   - Field: ‘gc’
[17:40:59.956]   - Field: ‘conditions’
[17:40:59.956]   - Field: ‘persistent’
[17:40:59.956]   - Field: ‘expr’
[17:40:59.956]   - Field: ‘uuid’
[17:40:59.956]   - Field: ‘seed’
[17:40:59.956]   - Field: ‘version’
[17:40:59.956]   - Field: ‘result’
[17:40:59.956]   - Field: ‘asynchronous’
[17:40:59.956]   - Field: ‘calls’
[17:40:59.956]   - Field: ‘globals’
[17:40:59.956]   - Field: ‘stdout’
[17:40:59.957]   - Field: ‘earlySignal’
[17:40:59.957]   - Field: ‘lazy’
[17:40:59.957]   - Field: ‘state’
[17:40:59.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.957] - Launch lazy future ...
[17:40:59.957] Packages needed by the future expression (n = 1): ‘future.apply’
[17:40:59.957] Packages needed by future strategies (n = 0): <none>
[17:40:59.958] {
[17:40:59.958]     {
[17:40:59.958]         {
[17:40:59.958]             ...future.startTime <- base::Sys.time()
[17:40:59.958]             {
[17:40:59.958]                 {
[17:40:59.958]                   {
[17:40:59.958]                     {
[17:40:59.958]                       {
[17:40:59.958]                         base::local({
[17:40:59.958]                           has_future <- base::requireNamespace("future", 
[17:40:59.958]                             quietly = TRUE)
[17:40:59.958]                           if (has_future) {
[17:40:59.958]                             ns <- base::getNamespace("future")
[17:40:59.958]                             version <- ns[[".package"]][["version"]]
[17:40:59.958]                             if (is.null(version)) 
[17:40:59.958]                               version <- utils::packageVersion("future")
[17:40:59.958]                           }
[17:40:59.958]                           else {
[17:40:59.958]                             version <- NULL
[17:40:59.958]                           }
[17:40:59.958]                           if (!has_future || version < "1.8.0") {
[17:40:59.958]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.958]                               "", base::R.version$version.string), 
[17:40:59.958]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:59.958]                                 base::R.version$platform, 8 * 
[17:40:59.958]                                   base::.Machine$sizeof.pointer), 
[17:40:59.958]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.958]                                 "release", "version")], collapse = " "), 
[17:40:59.958]                               hostname = base::Sys.info()[["nodename"]])
[17:40:59.958]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.958]                               info)
[17:40:59.958]                             info <- base::paste(info, collapse = "; ")
[17:40:59.958]                             if (!has_future) {
[17:40:59.958]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.958]                                 info)
[17:40:59.958]                             }
[17:40:59.958]                             else {
[17:40:59.958]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.958]                                 info, version)
[17:40:59.958]                             }
[17:40:59.958]                             base::stop(msg)
[17:40:59.958]                           }
[17:40:59.958]                         })
[17:40:59.958]                       }
[17:40:59.958]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.958]                       base::options(mc.cores = 1L)
[17:40:59.958]                     }
[17:40:59.958]                     base::local({
[17:40:59.958]                       for (pkg in "future.apply") {
[17:40:59.958]                         base::loadNamespace(pkg)
[17:40:59.958]                         base::library(pkg, character.only = TRUE)
[17:40:59.958]                       }
[17:40:59.958]                     })
[17:40:59.958]                   }
[17:40:59.958]                   options(future.plan = NULL)
[17:40:59.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.958]                 }
[17:40:59.958]                 ...future.workdir <- getwd()
[17:40:59.958]             }
[17:40:59.958]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.958]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.958]         }
[17:40:59.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.958]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:40:59.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.958]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.958]             base::names(...future.oldOptions))
[17:40:59.958]     }
[17:40:59.958]     if (FALSE) {
[17:40:59.958]     }
[17:40:59.958]     else {
[17:40:59.958]         if (TRUE) {
[17:40:59.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.958]                 open = "w")
[17:40:59.958]         }
[17:40:59.958]         else {
[17:40:59.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.958]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.958]         }
[17:40:59.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.958]             base::sink(type = "output", split = FALSE)
[17:40:59.958]             base::close(...future.stdout)
[17:40:59.958]         }, add = TRUE)
[17:40:59.958]     }
[17:40:59.958]     ...future.frame <- base::sys.nframe()
[17:40:59.958]     ...future.conditions <- base::list()
[17:40:59.958]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.958]     if (FALSE) {
[17:40:59.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.958]     }
[17:40:59.958]     ...future.result <- base::tryCatch({
[17:40:59.958]         base::withCallingHandlers({
[17:40:59.958]             ...future.value <- base::withVisible(base::local({
[17:40:59.958]                 ...future.makeSendCondition <- local({
[17:40:59.958]                   sendCondition <- NULL
[17:40:59.958]                   function(frame = 1L) {
[17:40:59.958]                     if (is.function(sendCondition)) 
[17:40:59.958]                       return(sendCondition)
[17:40:59.958]                     ns <- getNamespace("parallel")
[17:40:59.958]                     if (exists("sendData", mode = "function", 
[17:40:59.958]                       envir = ns)) {
[17:40:59.958]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.958]                         envir = ns)
[17:40:59.958]                       envir <- sys.frame(frame)
[17:40:59.958]                       master <- NULL
[17:40:59.958]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.958]                         !identical(envir, emptyenv())) {
[17:40:59.958]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.958]                           inherits = FALSE)) {
[17:40:59.958]                           master <- get("master", mode = "list", 
[17:40:59.958]                             envir = envir, inherits = FALSE)
[17:40:59.958]                           if (inherits(master, c("SOCKnode", 
[17:40:59.958]                             "SOCK0node"))) {
[17:40:59.958]                             sendCondition <<- function(cond) {
[17:40:59.958]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.958]                                 success = TRUE)
[17:40:59.958]                               parallel_sendData(master, data)
[17:40:59.958]                             }
[17:40:59.958]                             return(sendCondition)
[17:40:59.958]                           }
[17:40:59.958]                         }
[17:40:59.958]                         frame <- frame + 1L
[17:40:59.958]                         envir <- sys.frame(frame)
[17:40:59.958]                       }
[17:40:59.958]                     }
[17:40:59.958]                     sendCondition <<- function(cond) NULL
[17:40:59.958]                   }
[17:40:59.958]                 })
[17:40:59.958]                 withCallingHandlers({
[17:40:59.958]                   {
[17:40:59.958]                     do.call(function(...) {
[17:40:59.958]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:40:59.958]                       if (!identical(...future.globals.maxSize.org, 
[17:40:59.958]                         ...future.globals.maxSize)) {
[17:40:59.958]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:40:59.958]                         on.exit(options(oopts), add = TRUE)
[17:40:59.958]                       }
[17:40:59.958]                       {
[17:40:59.958]                         lapply(seq_along(...future.elements_ii), 
[17:40:59.958]                           FUN = function(jj) {
[17:40:59.958]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:40:59.958]                             ...future.FUN(...future.X_jj, ...)
[17:40:59.958]                           })
[17:40:59.958]                       }
[17:40:59.958]                     }, args = future.call.arguments)
[17:40:59.958]                   }
[17:40:59.958]                 }, immediateCondition = function(cond) {
[17:40:59.958]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.958]                   sendCondition(cond)
[17:40:59.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.958]                   {
[17:40:59.958]                     inherits <- base::inherits
[17:40:59.958]                     invokeRestart <- base::invokeRestart
[17:40:59.958]                     is.null <- base::is.null
[17:40:59.958]                     muffled <- FALSE
[17:40:59.958]                     if (inherits(cond, "message")) {
[17:40:59.958]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.958]                       if (muffled) 
[17:40:59.958]                         invokeRestart("muffleMessage")
[17:40:59.958]                     }
[17:40:59.958]                     else if (inherits(cond, "warning")) {
[17:40:59.958]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.958]                       if (muffled) 
[17:40:59.958]                         invokeRestart("muffleWarning")
[17:40:59.958]                     }
[17:40:59.958]                     else if (inherits(cond, "condition")) {
[17:40:59.958]                       if (!is.null(pattern)) {
[17:40:59.958]                         computeRestarts <- base::computeRestarts
[17:40:59.958]                         grepl <- base::grepl
[17:40:59.958]                         restarts <- computeRestarts(cond)
[17:40:59.958]                         for (restart in restarts) {
[17:40:59.958]                           name <- restart$name
[17:40:59.958]                           if (is.null(name)) 
[17:40:59.958]                             next
[17:40:59.958]                           if (!grepl(pattern, name)) 
[17:40:59.958]                             next
[17:40:59.958]                           invokeRestart(restart)
[17:40:59.958]                           muffled <- TRUE
[17:40:59.958]                           break
[17:40:59.958]                         }
[17:40:59.958]                       }
[17:40:59.958]                     }
[17:40:59.958]                     invisible(muffled)
[17:40:59.958]                   }
[17:40:59.958]                   muffleCondition(cond)
[17:40:59.958]                 })
[17:40:59.958]             }))
[17:40:59.958]             future::FutureResult(value = ...future.value$value, 
[17:40:59.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.958]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.958]                     ...future.globalenv.names))
[17:40:59.958]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.958]         }, condition = base::local({
[17:40:59.958]             c <- base::c
[17:40:59.958]             inherits <- base::inherits
[17:40:59.958]             invokeRestart <- base::invokeRestart
[17:40:59.958]             length <- base::length
[17:40:59.958]             list <- base::list
[17:40:59.958]             seq.int <- base::seq.int
[17:40:59.958]             signalCondition <- base::signalCondition
[17:40:59.958]             sys.calls <- base::sys.calls
[17:40:59.958]             `[[` <- base::`[[`
[17:40:59.958]             `+` <- base::`+`
[17:40:59.958]             `<<-` <- base::`<<-`
[17:40:59.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.958]                   3L)]
[17:40:59.958]             }
[17:40:59.958]             function(cond) {
[17:40:59.958]                 is_error <- inherits(cond, "error")
[17:40:59.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.958]                   NULL)
[17:40:59.958]                 if (is_error) {
[17:40:59.958]                   sessionInformation <- function() {
[17:40:59.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.958]                       search = base::search(), system = base::Sys.info())
[17:40:59.958]                   }
[17:40:59.958]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.958]                     cond$call), session = sessionInformation(), 
[17:40:59.958]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.958]                   signalCondition(cond)
[17:40:59.958]                 }
[17:40:59.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.958]                 "immediateCondition"))) {
[17:40:59.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.958]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.958]                   if (TRUE && !signal) {
[17:40:59.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.958]                     {
[17:40:59.958]                       inherits <- base::inherits
[17:40:59.958]                       invokeRestart <- base::invokeRestart
[17:40:59.958]                       is.null <- base::is.null
[17:40:59.958]                       muffled <- FALSE
[17:40:59.958]                       if (inherits(cond, "message")) {
[17:40:59.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.958]                         if (muffled) 
[17:40:59.958]                           invokeRestart("muffleMessage")
[17:40:59.958]                       }
[17:40:59.958]                       else if (inherits(cond, "warning")) {
[17:40:59.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.958]                         if (muffled) 
[17:40:59.958]                           invokeRestart("muffleWarning")
[17:40:59.958]                       }
[17:40:59.958]                       else if (inherits(cond, "condition")) {
[17:40:59.958]                         if (!is.null(pattern)) {
[17:40:59.958]                           computeRestarts <- base::computeRestarts
[17:40:59.958]                           grepl <- base::grepl
[17:40:59.958]                           restarts <- computeRestarts(cond)
[17:40:59.958]                           for (restart in restarts) {
[17:40:59.958]                             name <- restart$name
[17:40:59.958]                             if (is.null(name)) 
[17:40:59.958]                               next
[17:40:59.958]                             if (!grepl(pattern, name)) 
[17:40:59.958]                               next
[17:40:59.958]                             invokeRestart(restart)
[17:40:59.958]                             muffled <- TRUE
[17:40:59.958]                             break
[17:40:59.958]                           }
[17:40:59.958]                         }
[17:40:59.958]                       }
[17:40:59.958]                       invisible(muffled)
[17:40:59.958]                     }
[17:40:59.958]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.958]                   }
[17:40:59.958]                 }
[17:40:59.958]                 else {
[17:40:59.958]                   if (TRUE) {
[17:40:59.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.958]                     {
[17:40:59.958]                       inherits <- base::inherits
[17:40:59.958]                       invokeRestart <- base::invokeRestart
[17:40:59.958]                       is.null <- base::is.null
[17:40:59.958]                       muffled <- FALSE
[17:40:59.958]                       if (inherits(cond, "message")) {
[17:40:59.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.958]                         if (muffled) 
[17:40:59.958]                           invokeRestart("muffleMessage")
[17:40:59.958]                       }
[17:40:59.958]                       else if (inherits(cond, "warning")) {
[17:40:59.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.958]                         if (muffled) 
[17:40:59.958]                           invokeRestart("muffleWarning")
[17:40:59.958]                       }
[17:40:59.958]                       else if (inherits(cond, "condition")) {
[17:40:59.958]                         if (!is.null(pattern)) {
[17:40:59.958]                           computeRestarts <- base::computeRestarts
[17:40:59.958]                           grepl <- base::grepl
[17:40:59.958]                           restarts <- computeRestarts(cond)
[17:40:59.958]                           for (restart in restarts) {
[17:40:59.958]                             name <- restart$name
[17:40:59.958]                             if (is.null(name)) 
[17:40:59.958]                               next
[17:40:59.958]                             if (!grepl(pattern, name)) 
[17:40:59.958]                               next
[17:40:59.958]                             invokeRestart(restart)
[17:40:59.958]                             muffled <- TRUE
[17:40:59.958]                             break
[17:40:59.958]                           }
[17:40:59.958]                         }
[17:40:59.958]                       }
[17:40:59.958]                       invisible(muffled)
[17:40:59.958]                     }
[17:40:59.958]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.958]                   }
[17:40:59.958]                 }
[17:40:59.958]             }
[17:40:59.958]         }))
[17:40:59.958]     }, error = function(ex) {
[17:40:59.958]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.958]                 ...future.rng), started = ...future.startTime, 
[17:40:59.958]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.958]             version = "1.8"), class = "FutureResult")
[17:40:59.958]     }, finally = {
[17:40:59.958]         if (!identical(...future.workdir, getwd())) 
[17:40:59.958]             setwd(...future.workdir)
[17:40:59.958]         {
[17:40:59.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.958]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.958]             }
[17:40:59.958]             base::options(...future.oldOptions)
[17:40:59.958]             if (.Platform$OS.type == "windows") {
[17:40:59.958]                 old_names <- names(...future.oldEnvVars)
[17:40:59.958]                 envs <- base::Sys.getenv()
[17:40:59.958]                 names <- names(envs)
[17:40:59.958]                 common <- intersect(names, old_names)
[17:40:59.958]                 added <- setdiff(names, old_names)
[17:40:59.958]                 removed <- setdiff(old_names, names)
[17:40:59.958]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.958]                   envs[common]]
[17:40:59.958]                 NAMES <- toupper(changed)
[17:40:59.958]                 args <- list()
[17:40:59.958]                 for (kk in seq_along(NAMES)) {
[17:40:59.958]                   name <- changed[[kk]]
[17:40:59.958]                   NAME <- NAMES[[kk]]
[17:40:59.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.958]                     next
[17:40:59.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.958]                 }
[17:40:59.958]                 NAMES <- toupper(added)
[17:40:59.958]                 for (kk in seq_along(NAMES)) {
[17:40:59.958]                   name <- added[[kk]]
[17:40:59.958]                   NAME <- NAMES[[kk]]
[17:40:59.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.958]                     next
[17:40:59.958]                   args[[name]] <- ""
[17:40:59.958]                 }
[17:40:59.958]                 NAMES <- toupper(removed)
[17:40:59.958]                 for (kk in seq_along(NAMES)) {
[17:40:59.958]                   name <- removed[[kk]]
[17:40:59.958]                   NAME <- NAMES[[kk]]
[17:40:59.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.958]                     next
[17:40:59.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.958]                 }
[17:40:59.958]                 if (length(args) > 0) 
[17:40:59.958]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.958]             }
[17:40:59.958]             else {
[17:40:59.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.958]             }
[17:40:59.958]             {
[17:40:59.958]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.958]                   0L) {
[17:40:59.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.958]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.958]                   base::options(opts)
[17:40:59.958]                 }
[17:40:59.958]                 {
[17:40:59.958]                   {
[17:40:59.958]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.958]                     NULL
[17:40:59.958]                   }
[17:40:59.958]                   options(future.plan = NULL)
[17:40:59.958]                   if (is.na(NA_character_)) 
[17:40:59.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.958]                   future::plan(list(function (..., workers = availableCores(), 
[17:40:59.958]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:59.958]                     envir = parent.frame()) 
[17:40:59.958]                   {
[17:40:59.958]                     if (is.function(workers)) 
[17:40:59.958]                       workers <- workers()
[17:40:59.958]                     workers <- structure(as.integer(workers), 
[17:40:59.958]                       class = class(workers))
[17:40:59.958]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:59.958]                       workers >= 1)
[17:40:59.958]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:59.958]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:59.958]                     }
[17:40:59.958]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:59.958]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:59.958]                       envir = envir)
[17:40:59.958]                     if (!future$lazy) 
[17:40:59.958]                       future <- run(future)
[17:40:59.958]                     invisible(future)
[17:40:59.958]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:59.958]                 }
[17:40:59.958]             }
[17:40:59.958]         }
[17:40:59.958]     })
[17:40:59.958]     if (TRUE) {
[17:40:59.958]         base::sink(type = "output", split = FALSE)
[17:40:59.958]         if (TRUE) {
[17:40:59.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.958]         }
[17:40:59.958]         else {
[17:40:59.958]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.958]         }
[17:40:59.958]         base::close(...future.stdout)
[17:40:59.958]         ...future.stdout <- NULL
[17:40:59.958]     }
[17:40:59.958]     ...future.result$conditions <- ...future.conditions
[17:40:59.958]     ...future.result$finished <- base::Sys.time()
[17:40:59.958]     ...future.result
[17:40:59.958] }
[17:40:59.963] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[17:40:59.963] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:00.007] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:00.007] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:41:00.008] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:41:00.008] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:00.008] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.008] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:00.051] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:00.051] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:00.095] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:00.095] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:41:00.096] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.096] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:41:00.096] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:41:00.096] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:00.097] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.097] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:41:00.097] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:41:00.097] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:00.098] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.098] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:00.098] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.098] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[17:41:00.099] MultisessionFuture started
[17:41:00.099] - Launch lazy future ... done
[17:41:00.099] run() for ‘MultisessionFuture’ ... done
[17:41:00.099] Created future:
[17:41:00.099] MultisessionFuture:
[17:41:00.099] Label: ‘future_vapply-1’
[17:41:00.099] Expression:
[17:41:00.099] {
[17:41:00.099]     do.call(function(...) {
[17:41:00.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.099]             on.exit(options(oopts), add = TRUE)
[17:41:00.099]         }
[17:41:00.099]         {
[17:41:00.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.099]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.099]             })
[17:41:00.099]         }
[17:41:00.099]     }, args = future.call.arguments)
[17:41:00.099] }
[17:41:00.099] Lazy evaluation: FALSE
[17:41:00.099] Asynchronous evaluation: TRUE
[17:41:00.099] Local evaluation: TRUE
[17:41:00.099] Environment: R_GlobalEnv
[17:41:00.099] Capture standard output: TRUE
[17:41:00.099] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:00.099] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:00.099] Packages: 1 packages (‘future.apply’)
[17:41:00.099] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:00.099] Resolved: FALSE
[17:41:00.099] Value: <not collected>
[17:41:00.099] Conditions captured: <none>
[17:41:00.099] Early signaling: FALSE
[17:41:00.099] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:00.099] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.111] Chunk #1 of 2 ... DONE
[17:41:00.111] Chunk #2 of 2 ...
[17:41:00.111]  - Finding globals in 'X' for chunk #2 ...
[17:41:00.112] getGlobalsAndPackages() ...
[17:41:00.112] Searching for globals...
[17:41:00.112] 
[17:41:00.112] Searching for globals ... DONE
[17:41:00.112] - globals: [0] <none>
[17:41:00.112] getGlobalsAndPackages() ... DONE
[17:41:00.112]    + additional globals found: [n=0] 
[17:41:00.112]    + additional namespaces needed: [n=0] 
[17:41:00.113]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:00.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:41:00.113]  - seeds: <none>
[17:41:00.113] getGlobalsAndPackages() ...
[17:41:00.113] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.113] Resolving globals: FALSE
[17:41:00.113] Tweak future expression to call with '...' arguments ...
[17:41:00.113] {
[17:41:00.113]     do.call(function(...) {
[17:41:00.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.113]             on.exit(options(oopts), add = TRUE)
[17:41:00.113]         }
[17:41:00.113]         {
[17:41:00.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.113]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.113]             })
[17:41:00.113]         }
[17:41:00.113]     }, args = future.call.arguments)
[17:41:00.113] }
[17:41:00.114] Tweak future expression to call with '...' arguments ... DONE
[17:41:00.114] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.114] - packages: [1] ‘future.apply’
[17:41:00.114] getGlobalsAndPackages() ... DONE
[17:41:00.115] run() for ‘Future’ ...
[17:41:00.115] - state: ‘created’
[17:41:00.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.130]   - Field: ‘node’
[17:41:00.130]   - Field: ‘label’
[17:41:00.130]   - Field: ‘local’
[17:41:00.130]   - Field: ‘owner’
[17:41:00.130]   - Field: ‘envir’
[17:41:00.130]   - Field: ‘workers’
[17:41:00.130]   - Field: ‘packages’
[17:41:00.130]   - Field: ‘gc’
[17:41:00.130]   - Field: ‘conditions’
[17:41:00.131]   - Field: ‘persistent’
[17:41:00.131]   - Field: ‘expr’
[17:41:00.131]   - Field: ‘uuid’
[17:41:00.131]   - Field: ‘seed’
[17:41:00.131]   - Field: ‘version’
[17:41:00.131]   - Field: ‘result’
[17:41:00.131]   - Field: ‘asynchronous’
[17:41:00.131]   - Field: ‘calls’
[17:41:00.131]   - Field: ‘globals’
[17:41:00.131]   - Field: ‘stdout’
[17:41:00.132]   - Field: ‘earlySignal’
[17:41:00.132]   - Field: ‘lazy’
[17:41:00.132]   - Field: ‘state’
[17:41:00.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.132] - Launch lazy future ...
[17:41:00.132] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:00.132] Packages needed by future strategies (n = 0): <none>
[17:41:00.133] {
[17:41:00.133]     {
[17:41:00.133]         {
[17:41:00.133]             ...future.startTime <- base::Sys.time()
[17:41:00.133]             {
[17:41:00.133]                 {
[17:41:00.133]                   {
[17:41:00.133]                     {
[17:41:00.133]                       {
[17:41:00.133]                         base::local({
[17:41:00.133]                           has_future <- base::requireNamespace("future", 
[17:41:00.133]                             quietly = TRUE)
[17:41:00.133]                           if (has_future) {
[17:41:00.133]                             ns <- base::getNamespace("future")
[17:41:00.133]                             version <- ns[[".package"]][["version"]]
[17:41:00.133]                             if (is.null(version)) 
[17:41:00.133]                               version <- utils::packageVersion("future")
[17:41:00.133]                           }
[17:41:00.133]                           else {
[17:41:00.133]                             version <- NULL
[17:41:00.133]                           }
[17:41:00.133]                           if (!has_future || version < "1.8.0") {
[17:41:00.133]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.133]                               "", base::R.version$version.string), 
[17:41:00.133]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:00.133]                                 base::R.version$platform, 8 * 
[17:41:00.133]                                   base::.Machine$sizeof.pointer), 
[17:41:00.133]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.133]                                 "release", "version")], collapse = " "), 
[17:41:00.133]                               hostname = base::Sys.info()[["nodename"]])
[17:41:00.133]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.133]                               info)
[17:41:00.133]                             info <- base::paste(info, collapse = "; ")
[17:41:00.133]                             if (!has_future) {
[17:41:00.133]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.133]                                 info)
[17:41:00.133]                             }
[17:41:00.133]                             else {
[17:41:00.133]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.133]                                 info, version)
[17:41:00.133]                             }
[17:41:00.133]                             base::stop(msg)
[17:41:00.133]                           }
[17:41:00.133]                         })
[17:41:00.133]                       }
[17:41:00.133]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.133]                       base::options(mc.cores = 1L)
[17:41:00.133]                     }
[17:41:00.133]                     base::local({
[17:41:00.133]                       for (pkg in "future.apply") {
[17:41:00.133]                         base::loadNamespace(pkg)
[17:41:00.133]                         base::library(pkg, character.only = TRUE)
[17:41:00.133]                       }
[17:41:00.133]                     })
[17:41:00.133]                   }
[17:41:00.133]                   options(future.plan = NULL)
[17:41:00.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.133]                 }
[17:41:00.133]                 ...future.workdir <- getwd()
[17:41:00.133]             }
[17:41:00.133]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.133]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.133]         }
[17:41:00.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.133]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:41:00.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.133]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.133]             base::names(...future.oldOptions))
[17:41:00.133]     }
[17:41:00.133]     if (FALSE) {
[17:41:00.133]     }
[17:41:00.133]     else {
[17:41:00.133]         if (TRUE) {
[17:41:00.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.133]                 open = "w")
[17:41:00.133]         }
[17:41:00.133]         else {
[17:41:00.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.133]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.133]         }
[17:41:00.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.133]             base::sink(type = "output", split = FALSE)
[17:41:00.133]             base::close(...future.stdout)
[17:41:00.133]         }, add = TRUE)
[17:41:00.133]     }
[17:41:00.133]     ...future.frame <- base::sys.nframe()
[17:41:00.133]     ...future.conditions <- base::list()
[17:41:00.133]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.133]     if (FALSE) {
[17:41:00.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.133]     }
[17:41:00.133]     ...future.result <- base::tryCatch({
[17:41:00.133]         base::withCallingHandlers({
[17:41:00.133]             ...future.value <- base::withVisible(base::local({
[17:41:00.133]                 ...future.makeSendCondition <- local({
[17:41:00.133]                   sendCondition <- NULL
[17:41:00.133]                   function(frame = 1L) {
[17:41:00.133]                     if (is.function(sendCondition)) 
[17:41:00.133]                       return(sendCondition)
[17:41:00.133]                     ns <- getNamespace("parallel")
[17:41:00.133]                     if (exists("sendData", mode = "function", 
[17:41:00.133]                       envir = ns)) {
[17:41:00.133]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.133]                         envir = ns)
[17:41:00.133]                       envir <- sys.frame(frame)
[17:41:00.133]                       master <- NULL
[17:41:00.133]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.133]                         !identical(envir, emptyenv())) {
[17:41:00.133]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.133]                           inherits = FALSE)) {
[17:41:00.133]                           master <- get("master", mode = "list", 
[17:41:00.133]                             envir = envir, inherits = FALSE)
[17:41:00.133]                           if (inherits(master, c("SOCKnode", 
[17:41:00.133]                             "SOCK0node"))) {
[17:41:00.133]                             sendCondition <<- function(cond) {
[17:41:00.133]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.133]                                 success = TRUE)
[17:41:00.133]                               parallel_sendData(master, data)
[17:41:00.133]                             }
[17:41:00.133]                             return(sendCondition)
[17:41:00.133]                           }
[17:41:00.133]                         }
[17:41:00.133]                         frame <- frame + 1L
[17:41:00.133]                         envir <- sys.frame(frame)
[17:41:00.133]                       }
[17:41:00.133]                     }
[17:41:00.133]                     sendCondition <<- function(cond) NULL
[17:41:00.133]                   }
[17:41:00.133]                 })
[17:41:00.133]                 withCallingHandlers({
[17:41:00.133]                   {
[17:41:00.133]                     do.call(function(...) {
[17:41:00.133]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.133]                       if (!identical(...future.globals.maxSize.org, 
[17:41:00.133]                         ...future.globals.maxSize)) {
[17:41:00.133]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.133]                         on.exit(options(oopts), add = TRUE)
[17:41:00.133]                       }
[17:41:00.133]                       {
[17:41:00.133]                         lapply(seq_along(...future.elements_ii), 
[17:41:00.133]                           FUN = function(jj) {
[17:41:00.133]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.133]                             ...future.FUN(...future.X_jj, ...)
[17:41:00.133]                           })
[17:41:00.133]                       }
[17:41:00.133]                     }, args = future.call.arguments)
[17:41:00.133]                   }
[17:41:00.133]                 }, immediateCondition = function(cond) {
[17:41:00.133]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.133]                   sendCondition(cond)
[17:41:00.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.133]                   {
[17:41:00.133]                     inherits <- base::inherits
[17:41:00.133]                     invokeRestart <- base::invokeRestart
[17:41:00.133]                     is.null <- base::is.null
[17:41:00.133]                     muffled <- FALSE
[17:41:00.133]                     if (inherits(cond, "message")) {
[17:41:00.133]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.133]                       if (muffled) 
[17:41:00.133]                         invokeRestart("muffleMessage")
[17:41:00.133]                     }
[17:41:00.133]                     else if (inherits(cond, "warning")) {
[17:41:00.133]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.133]                       if (muffled) 
[17:41:00.133]                         invokeRestart("muffleWarning")
[17:41:00.133]                     }
[17:41:00.133]                     else if (inherits(cond, "condition")) {
[17:41:00.133]                       if (!is.null(pattern)) {
[17:41:00.133]                         computeRestarts <- base::computeRestarts
[17:41:00.133]                         grepl <- base::grepl
[17:41:00.133]                         restarts <- computeRestarts(cond)
[17:41:00.133]                         for (restart in restarts) {
[17:41:00.133]                           name <- restart$name
[17:41:00.133]                           if (is.null(name)) 
[17:41:00.133]                             next
[17:41:00.133]                           if (!grepl(pattern, name)) 
[17:41:00.133]                             next
[17:41:00.133]                           invokeRestart(restart)
[17:41:00.133]                           muffled <- TRUE
[17:41:00.133]                           break
[17:41:00.133]                         }
[17:41:00.133]                       }
[17:41:00.133]                     }
[17:41:00.133]                     invisible(muffled)
[17:41:00.133]                   }
[17:41:00.133]                   muffleCondition(cond)
[17:41:00.133]                 })
[17:41:00.133]             }))
[17:41:00.133]             future::FutureResult(value = ...future.value$value, 
[17:41:00.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.133]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.133]                     ...future.globalenv.names))
[17:41:00.133]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.133]         }, condition = base::local({
[17:41:00.133]             c <- base::c
[17:41:00.133]             inherits <- base::inherits
[17:41:00.133]             invokeRestart <- base::invokeRestart
[17:41:00.133]             length <- base::length
[17:41:00.133]             list <- base::list
[17:41:00.133]             seq.int <- base::seq.int
[17:41:00.133]             signalCondition <- base::signalCondition
[17:41:00.133]             sys.calls <- base::sys.calls
[17:41:00.133]             `[[` <- base::`[[`
[17:41:00.133]             `+` <- base::`+`
[17:41:00.133]             `<<-` <- base::`<<-`
[17:41:00.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.133]                   3L)]
[17:41:00.133]             }
[17:41:00.133]             function(cond) {
[17:41:00.133]                 is_error <- inherits(cond, "error")
[17:41:00.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.133]                   NULL)
[17:41:00.133]                 if (is_error) {
[17:41:00.133]                   sessionInformation <- function() {
[17:41:00.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.133]                       search = base::search(), system = base::Sys.info())
[17:41:00.133]                   }
[17:41:00.133]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.133]                     cond$call), session = sessionInformation(), 
[17:41:00.133]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.133]                   signalCondition(cond)
[17:41:00.133]                 }
[17:41:00.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.133]                 "immediateCondition"))) {
[17:41:00.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.133]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.133]                   if (TRUE && !signal) {
[17:41:00.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.133]                     {
[17:41:00.133]                       inherits <- base::inherits
[17:41:00.133]                       invokeRestart <- base::invokeRestart
[17:41:00.133]                       is.null <- base::is.null
[17:41:00.133]                       muffled <- FALSE
[17:41:00.133]                       if (inherits(cond, "message")) {
[17:41:00.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.133]                         if (muffled) 
[17:41:00.133]                           invokeRestart("muffleMessage")
[17:41:00.133]                       }
[17:41:00.133]                       else if (inherits(cond, "warning")) {
[17:41:00.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.133]                         if (muffled) 
[17:41:00.133]                           invokeRestart("muffleWarning")
[17:41:00.133]                       }
[17:41:00.133]                       else if (inherits(cond, "condition")) {
[17:41:00.133]                         if (!is.null(pattern)) {
[17:41:00.133]                           computeRestarts <- base::computeRestarts
[17:41:00.133]                           grepl <- base::grepl
[17:41:00.133]                           restarts <- computeRestarts(cond)
[17:41:00.133]                           for (restart in restarts) {
[17:41:00.133]                             name <- restart$name
[17:41:00.133]                             if (is.null(name)) 
[17:41:00.133]                               next
[17:41:00.133]                             if (!grepl(pattern, name)) 
[17:41:00.133]                               next
[17:41:00.133]                             invokeRestart(restart)
[17:41:00.133]                             muffled <- TRUE
[17:41:00.133]                             break
[17:41:00.133]                           }
[17:41:00.133]                         }
[17:41:00.133]                       }
[17:41:00.133]                       invisible(muffled)
[17:41:00.133]                     }
[17:41:00.133]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.133]                   }
[17:41:00.133]                 }
[17:41:00.133]                 else {
[17:41:00.133]                   if (TRUE) {
[17:41:00.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.133]                     {
[17:41:00.133]                       inherits <- base::inherits
[17:41:00.133]                       invokeRestart <- base::invokeRestart
[17:41:00.133]                       is.null <- base::is.null
[17:41:00.133]                       muffled <- FALSE
[17:41:00.133]                       if (inherits(cond, "message")) {
[17:41:00.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.133]                         if (muffled) 
[17:41:00.133]                           invokeRestart("muffleMessage")
[17:41:00.133]                       }
[17:41:00.133]                       else if (inherits(cond, "warning")) {
[17:41:00.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.133]                         if (muffled) 
[17:41:00.133]                           invokeRestart("muffleWarning")
[17:41:00.133]                       }
[17:41:00.133]                       else if (inherits(cond, "condition")) {
[17:41:00.133]                         if (!is.null(pattern)) {
[17:41:00.133]                           computeRestarts <- base::computeRestarts
[17:41:00.133]                           grepl <- base::grepl
[17:41:00.133]                           restarts <- computeRestarts(cond)
[17:41:00.133]                           for (restart in restarts) {
[17:41:00.133]                             name <- restart$name
[17:41:00.133]                             if (is.null(name)) 
[17:41:00.133]                               next
[17:41:00.133]                             if (!grepl(pattern, name)) 
[17:41:00.133]                               next
[17:41:00.133]                             invokeRestart(restart)
[17:41:00.133]                             muffled <- TRUE
[17:41:00.133]                             break
[17:41:00.133]                           }
[17:41:00.133]                         }
[17:41:00.133]                       }
[17:41:00.133]                       invisible(muffled)
[17:41:00.133]                     }
[17:41:00.133]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.133]                   }
[17:41:00.133]                 }
[17:41:00.133]             }
[17:41:00.133]         }))
[17:41:00.133]     }, error = function(ex) {
[17:41:00.133]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.133]                 ...future.rng), started = ...future.startTime, 
[17:41:00.133]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.133]             version = "1.8"), class = "FutureResult")
[17:41:00.133]     }, finally = {
[17:41:00.133]         if (!identical(...future.workdir, getwd())) 
[17:41:00.133]             setwd(...future.workdir)
[17:41:00.133]         {
[17:41:00.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.133]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.133]             }
[17:41:00.133]             base::options(...future.oldOptions)
[17:41:00.133]             if (.Platform$OS.type == "windows") {
[17:41:00.133]                 old_names <- names(...future.oldEnvVars)
[17:41:00.133]                 envs <- base::Sys.getenv()
[17:41:00.133]                 names <- names(envs)
[17:41:00.133]                 common <- intersect(names, old_names)
[17:41:00.133]                 added <- setdiff(names, old_names)
[17:41:00.133]                 removed <- setdiff(old_names, names)
[17:41:00.133]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.133]                   envs[common]]
[17:41:00.133]                 NAMES <- toupper(changed)
[17:41:00.133]                 args <- list()
[17:41:00.133]                 for (kk in seq_along(NAMES)) {
[17:41:00.133]                   name <- changed[[kk]]
[17:41:00.133]                   NAME <- NAMES[[kk]]
[17:41:00.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.133]                     next
[17:41:00.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.133]                 }
[17:41:00.133]                 NAMES <- toupper(added)
[17:41:00.133]                 for (kk in seq_along(NAMES)) {
[17:41:00.133]                   name <- added[[kk]]
[17:41:00.133]                   NAME <- NAMES[[kk]]
[17:41:00.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.133]                     next
[17:41:00.133]                   args[[name]] <- ""
[17:41:00.133]                 }
[17:41:00.133]                 NAMES <- toupper(removed)
[17:41:00.133]                 for (kk in seq_along(NAMES)) {
[17:41:00.133]                   name <- removed[[kk]]
[17:41:00.133]                   NAME <- NAMES[[kk]]
[17:41:00.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.133]                     next
[17:41:00.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.133]                 }
[17:41:00.133]                 if (length(args) > 0) 
[17:41:00.133]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.133]             }
[17:41:00.133]             else {
[17:41:00.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.133]             }
[17:41:00.133]             {
[17:41:00.133]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.133]                   0L) {
[17:41:00.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.133]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.133]                   base::options(opts)
[17:41:00.133]                 }
[17:41:00.133]                 {
[17:41:00.133]                   {
[17:41:00.133]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.133]                     NULL
[17:41:00.133]                   }
[17:41:00.133]                   options(future.plan = NULL)
[17:41:00.133]                   if (is.na(NA_character_)) 
[17:41:00.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.133]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:00.133]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:00.133]                     envir = parent.frame()) 
[17:41:00.133]                   {
[17:41:00.133]                     if (is.function(workers)) 
[17:41:00.133]                       workers <- workers()
[17:41:00.133]                     workers <- structure(as.integer(workers), 
[17:41:00.133]                       class = class(workers))
[17:41:00.133]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:00.133]                       workers >= 1)
[17:41:00.133]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:00.133]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:00.133]                     }
[17:41:00.133]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:00.133]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:00.133]                       envir = envir)
[17:41:00.133]                     if (!future$lazy) 
[17:41:00.133]                       future <- run(future)
[17:41:00.133]                     invisible(future)
[17:41:00.133]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:00.133]                 }
[17:41:00.133]             }
[17:41:00.133]         }
[17:41:00.133]     })
[17:41:00.133]     if (TRUE) {
[17:41:00.133]         base::sink(type = "output", split = FALSE)
[17:41:00.133]         if (TRUE) {
[17:41:00.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.133]         }
[17:41:00.133]         else {
[17:41:00.133]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.133]         }
[17:41:00.133]         base::close(...future.stdout)
[17:41:00.133]         ...future.stdout <- NULL
[17:41:00.133]     }
[17:41:00.133]     ...future.result$conditions <- ...future.conditions
[17:41:00.133]     ...future.result$finished <- base::Sys.time()
[17:41:00.133]     ...future.result
[17:41:00.133] }
[17:41:00.136] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[17:41:00.136] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:00.183] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:00.183] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[17:41:00.184] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[17:41:00.184] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:00.184] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:00.184] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:00.227] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:00.227] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:00.271] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:00.271] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:41:00.272] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:41:00.272] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:41:00.272] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:41:00.272] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:00.273] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:00.273] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:41:00.275] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:41:00.275] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:00.276] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:00.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:00.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:00.276] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[17:41:00.277] MultisessionFuture started
[17:41:00.277] - Launch lazy future ... done
[17:41:00.277] run() for ‘MultisessionFuture’ ... done
[17:41:00.277] Created future:
[17:41:00.277] MultisessionFuture:
[17:41:00.277] Label: ‘future_vapply-2’
[17:41:00.277] Expression:
[17:41:00.277] {
[17:41:00.277]     do.call(function(...) {
[17:41:00.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.277]             on.exit(options(oopts), add = TRUE)
[17:41:00.277]         }
[17:41:00.277]         {
[17:41:00.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.277]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.277]             })
[17:41:00.277]         }
[17:41:00.277]     }, args = future.call.arguments)
[17:41:00.277] }
[17:41:00.277] Lazy evaluation: FALSE
[17:41:00.277] Asynchronous evaluation: TRUE
[17:41:00.277] Local evaluation: TRUE
[17:41:00.277] Environment: R_GlobalEnv
[17:41:00.277] Capture standard output: TRUE
[17:41:00.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:00.277] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:00.277] Packages: 1 packages (‘future.apply’)
[17:41:00.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:00.277] Resolved: FALSE
[17:41:00.277] Value: <not collected>
[17:41:00.277] Conditions captured: <none>
[17:41:00.277] Early signaling: FALSE
[17:41:00.277] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:00.277] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.289] Chunk #2 of 2 ... DONE
[17:41:00.289] Launching 2 futures (chunks) ... DONE
[17:41:00.289] Resolving 2 futures (chunks) ...
[17:41:00.289] resolve() on list ...
[17:41:00.289]  recursive: 0
[17:41:00.290]  length: 2
[17:41:00.290] 
[17:41:00.290] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.290] - Validating connection of MultisessionFuture
[17:41:00.290] - received message: FutureResult
[17:41:00.290] - Received FutureResult
[17:41:00.291] - Erased future from FutureRegistry
[17:41:00.291] result() for ClusterFuture ...
[17:41:00.291] - result already collected: FutureResult
[17:41:00.291] result() for ClusterFuture ... done
[17:41:00.291] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.291] Future #1
[17:41:00.291] result() for ClusterFuture ...
[17:41:00.291] - result already collected: FutureResult
[17:41:00.291] result() for ClusterFuture ... done
[17:41:00.291] result() for ClusterFuture ...
[17:41:00.291] - result already collected: FutureResult
[17:41:00.292] result() for ClusterFuture ... done
[17:41:00.292] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:00.292] - nx: 2
[17:41:00.292] - relay: TRUE
[17:41:00.292] - stdout: TRUE
[17:41:00.292] - signal: TRUE
[17:41:00.292] - resignal: FALSE
[17:41:00.292] - force: TRUE
[17:41:00.292] - relayed: [n=2] FALSE, FALSE
[17:41:00.292] - queued futures: [n=2] FALSE, FALSE
[17:41:00.292]  - until=1
[17:41:00.292]  - relaying element #1
[17:41:00.293] result() for ClusterFuture ...
[17:41:00.293] - result already collected: FutureResult
[17:41:00.293] result() for ClusterFuture ... done
[17:41:00.293] result() for ClusterFuture ...
[17:41:00.293] - result already collected: FutureResult
[17:41:00.293] result() for ClusterFuture ... done
[17:41:00.293] result() for ClusterFuture ...
[17:41:00.293] - result already collected: FutureResult
[17:41:00.293] result() for ClusterFuture ... done
[17:41:00.293] result() for ClusterFuture ...
[17:41:00.293] - result already collected: FutureResult
[17:41:00.293] result() for ClusterFuture ... done
[17:41:00.294] - relayed: [n=2] TRUE, FALSE
[17:41:00.294] - queued futures: [n=2] TRUE, FALSE
[17:41:00.294] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:00.294]  length: 1 (resolved future 1)
[17:41:00.324] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.324] - Validating connection of MultisessionFuture
[17:41:00.324] - received message: FutureResult
[17:41:00.324] - Received FutureResult
[17:41:00.324] - Erased future from FutureRegistry
[17:41:00.324] result() for ClusterFuture ...
[17:41:00.324] - result already collected: FutureResult
[17:41:00.324] result() for ClusterFuture ... done
[17:41:00.325] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.325] Future #2
[17:41:00.325] result() for ClusterFuture ...
[17:41:00.325] - result already collected: FutureResult
[17:41:00.325] result() for ClusterFuture ... done
[17:41:00.325] result() for ClusterFuture ...
[17:41:00.325] - result already collected: FutureResult
[17:41:00.325] result() for ClusterFuture ... done
[17:41:00.325] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:00.325] - nx: 2
[17:41:00.325] - relay: TRUE
[17:41:00.326] - stdout: TRUE
[17:41:00.326] - signal: TRUE
[17:41:00.326] - resignal: FALSE
[17:41:00.326] - force: TRUE
[17:41:00.326] - relayed: [n=2] TRUE, FALSE
[17:41:00.326] - queued futures: [n=2] TRUE, FALSE
[17:41:00.326]  - until=2
[17:41:00.326]  - relaying element #2
[17:41:00.326] result() for ClusterFuture ...
[17:41:00.326] - result already collected: FutureResult
[17:41:00.326] result() for ClusterFuture ... done
[17:41:00.326] result() for ClusterFuture ...
[17:41:00.327] - result already collected: FutureResult
[17:41:00.327] result() for ClusterFuture ... done
[17:41:00.327] result() for ClusterFuture ...
[17:41:00.327] - result already collected: FutureResult
[17:41:00.327] result() for ClusterFuture ... done
[17:41:00.327] result() for ClusterFuture ...
[17:41:00.327] - result already collected: FutureResult
[17:41:00.327] result() for ClusterFuture ... done
[17:41:00.327] - relayed: [n=2] TRUE, TRUE
[17:41:00.327] - queued futures: [n=2] TRUE, TRUE
[17:41:00.327] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:00.328]  length: 0 (resolved future 2)
[17:41:00.328] Relaying remaining futures
[17:41:00.328] signalConditionsASAP(NULL, pos=0) ...
[17:41:00.328] - nx: 2
[17:41:00.328] - relay: TRUE
[17:41:00.328] - stdout: TRUE
[17:41:00.328] - signal: TRUE
[17:41:00.328] - resignal: FALSE
[17:41:00.328] - force: TRUE
[17:41:00.328] - relayed: [n=2] TRUE, TRUE
[17:41:00.328] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:00.329] - relayed: [n=2] TRUE, TRUE
[17:41:00.329] - queued futures: [n=2] TRUE, TRUE
[17:41:00.329] signalConditionsASAP(NULL, pos=0) ... done
[17:41:00.329] resolve() on list ... DONE
[17:41:00.329] result() for ClusterFuture ...
[17:41:00.329] - result already collected: FutureResult
[17:41:00.329] result() for ClusterFuture ... done
[17:41:00.329] result() for ClusterFuture ...
[17:41:00.329] - result already collected: FutureResult
[17:41:00.329] result() for ClusterFuture ... done
[17:41:00.329] result() for ClusterFuture ...
[17:41:00.330] - result already collected: FutureResult
[17:41:00.330] result() for ClusterFuture ... done
[17:41:00.330] result() for ClusterFuture ...
[17:41:00.330] - result already collected: FutureResult
[17:41:00.330] result() for ClusterFuture ... done
[17:41:00.330]  - Number of value chunks collected: 2
[17:41:00.330] Resolving 2 futures (chunks) ... DONE
[17:41:00.330] Reducing values from 2 chunks ...
[17:41:00.330]  - Number of values collected after concatenation: 10
[17:41:00.330]  - Number of values expected: 10
[17:41:00.330] Reducing values from 2 chunks ... DONE
[17:41:00.330] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:41:00.333] future_lapply() ...
[17:41:00.338] Number of chunks: 2
[17:41:00.338] getGlobalsAndPackagesXApply() ...
[17:41:00.338]  - future.globals: TRUE
[17:41:00.338] getGlobalsAndPackages() ...
[17:41:00.338] Searching for globals...
[17:41:00.342] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:41:00.342] Searching for globals ... DONE
[17:41:00.342] Resolving globals: FALSE
[17:41:00.343] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:41:00.343] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:41:00.343] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:00.344] - packages: [1] ‘future.apply’
[17:41:00.344] getGlobalsAndPackages() ... DONE
[17:41:00.344]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:00.344]  - needed namespaces: [n=1] ‘future.apply’
[17:41:00.344] Finding globals ... DONE
[17:41:00.344]  - use_args: TRUE
[17:41:00.344]  - Getting '...' globals ...
[17:41:00.344] resolve() on list ...
[17:41:00.344]  recursive: 0
[17:41:00.345]  length: 1
[17:41:00.345]  elements: ‘...’
[17:41:00.345]  length: 0 (resolved future 1)
[17:41:00.345] resolve() on list ... DONE
[17:41:00.345]    - '...' content: [n=0] 
[17:41:00.345] List of 1
[17:41:00.345]  $ ...: list()
[17:41:00.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:00.345]  - attr(*, "where")=List of 1
[17:41:00.345]   ..$ ...:<environment: 0x564f3112a4f8> 
[17:41:00.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:00.345]  - attr(*, "resolved")= logi TRUE
[17:41:00.345]  - attr(*, "total_size")= num NA
[17:41:00.348]  - Getting '...' globals ... DONE
[17:41:00.348] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:00.348] List of 8
[17:41:00.348]  $ ...future.FUN:function (x, ...)  
[17:41:00.348]  $ x_FUN        :function (x)  
[17:41:00.348]  $ times        : int 4
[17:41:00.348]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:00.348]  $ stop_if_not  :function (...)  
[17:41:00.348]  $ dim          : int [1:2] 2 2
[17:41:00.348]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:41:00.348]  $ ...          : list()
[17:41:00.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:00.348]  - attr(*, "where")=List of 8
[17:41:00.348]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:00.348]   ..$ ...          :<environment: 0x564f3112a4f8> 
[17:41:00.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:00.348]  - attr(*, "resolved")= logi FALSE
[17:41:00.348]  - attr(*, "total_size")= num 105552
[17:41:00.353] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:41:00.353] getGlobalsAndPackagesXApply() ... DONE
[17:41:00.353] Number of futures (= number of chunks): 2
[17:41:00.354] Launching 2 futures (chunks) ...
[17:41:00.354] Chunk #1 of 2 ...
[17:41:00.354]  - Finding globals in 'X' for chunk #1 ...
[17:41:00.354] getGlobalsAndPackages() ...
[17:41:00.354] Searching for globals...
[17:41:00.354] 
[17:41:00.354] Searching for globals ... DONE
[17:41:00.354] - globals: [0] <none>
[17:41:00.355] getGlobalsAndPackages() ... DONE
[17:41:00.355]    + additional globals found: [n=0] 
[17:41:00.355]    + additional namespaces needed: [n=0] 
[17:41:00.355]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:00.355]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:41:00.355]  - seeds: <none>
[17:41:00.355] getGlobalsAndPackages() ...
[17:41:00.355] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.355] Resolving globals: FALSE
[17:41:00.356] Tweak future expression to call with '...' arguments ...
[17:41:00.356] {
[17:41:00.356]     do.call(function(...) {
[17:41:00.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.356]             on.exit(options(oopts), add = TRUE)
[17:41:00.356]         }
[17:41:00.356]         {
[17:41:00.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.356]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.356]             })
[17:41:00.356]         }
[17:41:00.356]     }, args = future.call.arguments)
[17:41:00.356] }
[17:41:00.356] Tweak future expression to call with '...' arguments ... DONE
[17:41:00.356] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.357] - packages: [1] ‘future.apply’
[17:41:00.357] getGlobalsAndPackages() ... DONE
[17:41:00.357] run() for ‘Future’ ...
[17:41:00.357] - state: ‘created’
[17:41:00.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.373]   - Field: ‘node’
[17:41:00.373]   - Field: ‘label’
[17:41:00.373]   - Field: ‘local’
[17:41:00.373]   - Field: ‘owner’
[17:41:00.379]   - Field: ‘envir’
[17:41:00.379]   - Field: ‘workers’
[17:41:00.379]   - Field: ‘packages’
[17:41:00.380]   - Field: ‘gc’
[17:41:00.380]   - Field: ‘conditions’
[17:41:00.380]   - Field: ‘persistent’
[17:41:00.380]   - Field: ‘expr’
[17:41:00.380]   - Field: ‘uuid’
[17:41:00.380]   - Field: ‘seed’
[17:41:00.380]   - Field: ‘version’
[17:41:00.380]   - Field: ‘result’
[17:41:00.380]   - Field: ‘asynchronous’
[17:41:00.380]   - Field: ‘calls’
[17:41:00.380]   - Field: ‘globals’
[17:41:00.381]   - Field: ‘stdout’
[17:41:00.381]   - Field: ‘earlySignal’
[17:41:00.381]   - Field: ‘lazy’
[17:41:00.381]   - Field: ‘state’
[17:41:00.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.381] - Launch lazy future ...
[17:41:00.381] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:00.381] Packages needed by future strategies (n = 0): <none>
[17:41:00.382] {
[17:41:00.382]     {
[17:41:00.382]         {
[17:41:00.382]             ...future.startTime <- base::Sys.time()
[17:41:00.382]             {
[17:41:00.382]                 {
[17:41:00.382]                   {
[17:41:00.382]                     {
[17:41:00.382]                       {
[17:41:00.382]                         base::local({
[17:41:00.382]                           has_future <- base::requireNamespace("future", 
[17:41:00.382]                             quietly = TRUE)
[17:41:00.382]                           if (has_future) {
[17:41:00.382]                             ns <- base::getNamespace("future")
[17:41:00.382]                             version <- ns[[".package"]][["version"]]
[17:41:00.382]                             if (is.null(version)) 
[17:41:00.382]                               version <- utils::packageVersion("future")
[17:41:00.382]                           }
[17:41:00.382]                           else {
[17:41:00.382]                             version <- NULL
[17:41:00.382]                           }
[17:41:00.382]                           if (!has_future || version < "1.8.0") {
[17:41:00.382]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.382]                               "", base::R.version$version.string), 
[17:41:00.382]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:00.382]                                 base::R.version$platform, 8 * 
[17:41:00.382]                                   base::.Machine$sizeof.pointer), 
[17:41:00.382]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.382]                                 "release", "version")], collapse = " "), 
[17:41:00.382]                               hostname = base::Sys.info()[["nodename"]])
[17:41:00.382]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.382]                               info)
[17:41:00.382]                             info <- base::paste(info, collapse = "; ")
[17:41:00.382]                             if (!has_future) {
[17:41:00.382]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.382]                                 info)
[17:41:00.382]                             }
[17:41:00.382]                             else {
[17:41:00.382]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.382]                                 info, version)
[17:41:00.382]                             }
[17:41:00.382]                             base::stop(msg)
[17:41:00.382]                           }
[17:41:00.382]                         })
[17:41:00.382]                       }
[17:41:00.382]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.382]                       base::options(mc.cores = 1L)
[17:41:00.382]                     }
[17:41:00.382]                     base::local({
[17:41:00.382]                       for (pkg in "future.apply") {
[17:41:00.382]                         base::loadNamespace(pkg)
[17:41:00.382]                         base::library(pkg, character.only = TRUE)
[17:41:00.382]                       }
[17:41:00.382]                     })
[17:41:00.382]                   }
[17:41:00.382]                   options(future.plan = NULL)
[17:41:00.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.382]                 }
[17:41:00.382]                 ...future.workdir <- getwd()
[17:41:00.382]             }
[17:41:00.382]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.382]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.382]         }
[17:41:00.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.382]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:41:00.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.382]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.382]             base::names(...future.oldOptions))
[17:41:00.382]     }
[17:41:00.382]     if (FALSE) {
[17:41:00.382]     }
[17:41:00.382]     else {
[17:41:00.382]         if (TRUE) {
[17:41:00.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.382]                 open = "w")
[17:41:00.382]         }
[17:41:00.382]         else {
[17:41:00.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.382]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.382]         }
[17:41:00.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.382]             base::sink(type = "output", split = FALSE)
[17:41:00.382]             base::close(...future.stdout)
[17:41:00.382]         }, add = TRUE)
[17:41:00.382]     }
[17:41:00.382]     ...future.frame <- base::sys.nframe()
[17:41:00.382]     ...future.conditions <- base::list()
[17:41:00.382]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.382]     if (FALSE) {
[17:41:00.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.382]     }
[17:41:00.382]     ...future.result <- base::tryCatch({
[17:41:00.382]         base::withCallingHandlers({
[17:41:00.382]             ...future.value <- base::withVisible(base::local({
[17:41:00.382]                 ...future.makeSendCondition <- local({
[17:41:00.382]                   sendCondition <- NULL
[17:41:00.382]                   function(frame = 1L) {
[17:41:00.382]                     if (is.function(sendCondition)) 
[17:41:00.382]                       return(sendCondition)
[17:41:00.382]                     ns <- getNamespace("parallel")
[17:41:00.382]                     if (exists("sendData", mode = "function", 
[17:41:00.382]                       envir = ns)) {
[17:41:00.382]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.382]                         envir = ns)
[17:41:00.382]                       envir <- sys.frame(frame)
[17:41:00.382]                       master <- NULL
[17:41:00.382]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.382]                         !identical(envir, emptyenv())) {
[17:41:00.382]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.382]                           inherits = FALSE)) {
[17:41:00.382]                           master <- get("master", mode = "list", 
[17:41:00.382]                             envir = envir, inherits = FALSE)
[17:41:00.382]                           if (inherits(master, c("SOCKnode", 
[17:41:00.382]                             "SOCK0node"))) {
[17:41:00.382]                             sendCondition <<- function(cond) {
[17:41:00.382]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.382]                                 success = TRUE)
[17:41:00.382]                               parallel_sendData(master, data)
[17:41:00.382]                             }
[17:41:00.382]                             return(sendCondition)
[17:41:00.382]                           }
[17:41:00.382]                         }
[17:41:00.382]                         frame <- frame + 1L
[17:41:00.382]                         envir <- sys.frame(frame)
[17:41:00.382]                       }
[17:41:00.382]                     }
[17:41:00.382]                     sendCondition <<- function(cond) NULL
[17:41:00.382]                   }
[17:41:00.382]                 })
[17:41:00.382]                 withCallingHandlers({
[17:41:00.382]                   {
[17:41:00.382]                     do.call(function(...) {
[17:41:00.382]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.382]                       if (!identical(...future.globals.maxSize.org, 
[17:41:00.382]                         ...future.globals.maxSize)) {
[17:41:00.382]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.382]                         on.exit(options(oopts), add = TRUE)
[17:41:00.382]                       }
[17:41:00.382]                       {
[17:41:00.382]                         lapply(seq_along(...future.elements_ii), 
[17:41:00.382]                           FUN = function(jj) {
[17:41:00.382]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.382]                             ...future.FUN(...future.X_jj, ...)
[17:41:00.382]                           })
[17:41:00.382]                       }
[17:41:00.382]                     }, args = future.call.arguments)
[17:41:00.382]                   }
[17:41:00.382]                 }, immediateCondition = function(cond) {
[17:41:00.382]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.382]                   sendCondition(cond)
[17:41:00.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.382]                   {
[17:41:00.382]                     inherits <- base::inherits
[17:41:00.382]                     invokeRestart <- base::invokeRestart
[17:41:00.382]                     is.null <- base::is.null
[17:41:00.382]                     muffled <- FALSE
[17:41:00.382]                     if (inherits(cond, "message")) {
[17:41:00.382]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.382]                       if (muffled) 
[17:41:00.382]                         invokeRestart("muffleMessage")
[17:41:00.382]                     }
[17:41:00.382]                     else if (inherits(cond, "warning")) {
[17:41:00.382]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.382]                       if (muffled) 
[17:41:00.382]                         invokeRestart("muffleWarning")
[17:41:00.382]                     }
[17:41:00.382]                     else if (inherits(cond, "condition")) {
[17:41:00.382]                       if (!is.null(pattern)) {
[17:41:00.382]                         computeRestarts <- base::computeRestarts
[17:41:00.382]                         grepl <- base::grepl
[17:41:00.382]                         restarts <- computeRestarts(cond)
[17:41:00.382]                         for (restart in restarts) {
[17:41:00.382]                           name <- restart$name
[17:41:00.382]                           if (is.null(name)) 
[17:41:00.382]                             next
[17:41:00.382]                           if (!grepl(pattern, name)) 
[17:41:00.382]                             next
[17:41:00.382]                           invokeRestart(restart)
[17:41:00.382]                           muffled <- TRUE
[17:41:00.382]                           break
[17:41:00.382]                         }
[17:41:00.382]                       }
[17:41:00.382]                     }
[17:41:00.382]                     invisible(muffled)
[17:41:00.382]                   }
[17:41:00.382]                   muffleCondition(cond)
[17:41:00.382]                 })
[17:41:00.382]             }))
[17:41:00.382]             future::FutureResult(value = ...future.value$value, 
[17:41:00.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.382]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.382]                     ...future.globalenv.names))
[17:41:00.382]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.382]         }, condition = base::local({
[17:41:00.382]             c <- base::c
[17:41:00.382]             inherits <- base::inherits
[17:41:00.382]             invokeRestart <- base::invokeRestart
[17:41:00.382]             length <- base::length
[17:41:00.382]             list <- base::list
[17:41:00.382]             seq.int <- base::seq.int
[17:41:00.382]             signalCondition <- base::signalCondition
[17:41:00.382]             sys.calls <- base::sys.calls
[17:41:00.382]             `[[` <- base::`[[`
[17:41:00.382]             `+` <- base::`+`
[17:41:00.382]             `<<-` <- base::`<<-`
[17:41:00.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.382]                   3L)]
[17:41:00.382]             }
[17:41:00.382]             function(cond) {
[17:41:00.382]                 is_error <- inherits(cond, "error")
[17:41:00.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.382]                   NULL)
[17:41:00.382]                 if (is_error) {
[17:41:00.382]                   sessionInformation <- function() {
[17:41:00.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.382]                       search = base::search(), system = base::Sys.info())
[17:41:00.382]                   }
[17:41:00.382]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.382]                     cond$call), session = sessionInformation(), 
[17:41:00.382]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.382]                   signalCondition(cond)
[17:41:00.382]                 }
[17:41:00.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.382]                 "immediateCondition"))) {
[17:41:00.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.382]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.382]                   if (TRUE && !signal) {
[17:41:00.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.382]                     {
[17:41:00.382]                       inherits <- base::inherits
[17:41:00.382]                       invokeRestart <- base::invokeRestart
[17:41:00.382]                       is.null <- base::is.null
[17:41:00.382]                       muffled <- FALSE
[17:41:00.382]                       if (inherits(cond, "message")) {
[17:41:00.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.382]                         if (muffled) 
[17:41:00.382]                           invokeRestart("muffleMessage")
[17:41:00.382]                       }
[17:41:00.382]                       else if (inherits(cond, "warning")) {
[17:41:00.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.382]                         if (muffled) 
[17:41:00.382]                           invokeRestart("muffleWarning")
[17:41:00.382]                       }
[17:41:00.382]                       else if (inherits(cond, "condition")) {
[17:41:00.382]                         if (!is.null(pattern)) {
[17:41:00.382]                           computeRestarts <- base::computeRestarts
[17:41:00.382]                           grepl <- base::grepl
[17:41:00.382]                           restarts <- computeRestarts(cond)
[17:41:00.382]                           for (restart in restarts) {
[17:41:00.382]                             name <- restart$name
[17:41:00.382]                             if (is.null(name)) 
[17:41:00.382]                               next
[17:41:00.382]                             if (!grepl(pattern, name)) 
[17:41:00.382]                               next
[17:41:00.382]                             invokeRestart(restart)
[17:41:00.382]                             muffled <- TRUE
[17:41:00.382]                             break
[17:41:00.382]                           }
[17:41:00.382]                         }
[17:41:00.382]                       }
[17:41:00.382]                       invisible(muffled)
[17:41:00.382]                     }
[17:41:00.382]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.382]                   }
[17:41:00.382]                 }
[17:41:00.382]                 else {
[17:41:00.382]                   if (TRUE) {
[17:41:00.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.382]                     {
[17:41:00.382]                       inherits <- base::inherits
[17:41:00.382]                       invokeRestart <- base::invokeRestart
[17:41:00.382]                       is.null <- base::is.null
[17:41:00.382]                       muffled <- FALSE
[17:41:00.382]                       if (inherits(cond, "message")) {
[17:41:00.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.382]                         if (muffled) 
[17:41:00.382]                           invokeRestart("muffleMessage")
[17:41:00.382]                       }
[17:41:00.382]                       else if (inherits(cond, "warning")) {
[17:41:00.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.382]                         if (muffled) 
[17:41:00.382]                           invokeRestart("muffleWarning")
[17:41:00.382]                       }
[17:41:00.382]                       else if (inherits(cond, "condition")) {
[17:41:00.382]                         if (!is.null(pattern)) {
[17:41:00.382]                           computeRestarts <- base::computeRestarts
[17:41:00.382]                           grepl <- base::grepl
[17:41:00.382]                           restarts <- computeRestarts(cond)
[17:41:00.382]                           for (restart in restarts) {
[17:41:00.382]                             name <- restart$name
[17:41:00.382]                             if (is.null(name)) 
[17:41:00.382]                               next
[17:41:00.382]                             if (!grepl(pattern, name)) 
[17:41:00.382]                               next
[17:41:00.382]                             invokeRestart(restart)
[17:41:00.382]                             muffled <- TRUE
[17:41:00.382]                             break
[17:41:00.382]                           }
[17:41:00.382]                         }
[17:41:00.382]                       }
[17:41:00.382]                       invisible(muffled)
[17:41:00.382]                     }
[17:41:00.382]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.382]                   }
[17:41:00.382]                 }
[17:41:00.382]             }
[17:41:00.382]         }))
[17:41:00.382]     }, error = function(ex) {
[17:41:00.382]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.382]                 ...future.rng), started = ...future.startTime, 
[17:41:00.382]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.382]             version = "1.8"), class = "FutureResult")
[17:41:00.382]     }, finally = {
[17:41:00.382]         if (!identical(...future.workdir, getwd())) 
[17:41:00.382]             setwd(...future.workdir)
[17:41:00.382]         {
[17:41:00.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.382]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.382]             }
[17:41:00.382]             base::options(...future.oldOptions)
[17:41:00.382]             if (.Platform$OS.type == "windows") {
[17:41:00.382]                 old_names <- names(...future.oldEnvVars)
[17:41:00.382]                 envs <- base::Sys.getenv()
[17:41:00.382]                 names <- names(envs)
[17:41:00.382]                 common <- intersect(names, old_names)
[17:41:00.382]                 added <- setdiff(names, old_names)
[17:41:00.382]                 removed <- setdiff(old_names, names)
[17:41:00.382]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.382]                   envs[common]]
[17:41:00.382]                 NAMES <- toupper(changed)
[17:41:00.382]                 args <- list()
[17:41:00.382]                 for (kk in seq_along(NAMES)) {
[17:41:00.382]                   name <- changed[[kk]]
[17:41:00.382]                   NAME <- NAMES[[kk]]
[17:41:00.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.382]                     next
[17:41:00.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.382]                 }
[17:41:00.382]                 NAMES <- toupper(added)
[17:41:00.382]                 for (kk in seq_along(NAMES)) {
[17:41:00.382]                   name <- added[[kk]]
[17:41:00.382]                   NAME <- NAMES[[kk]]
[17:41:00.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.382]                     next
[17:41:00.382]                   args[[name]] <- ""
[17:41:00.382]                 }
[17:41:00.382]                 NAMES <- toupper(removed)
[17:41:00.382]                 for (kk in seq_along(NAMES)) {
[17:41:00.382]                   name <- removed[[kk]]
[17:41:00.382]                   NAME <- NAMES[[kk]]
[17:41:00.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.382]                     next
[17:41:00.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.382]                 }
[17:41:00.382]                 if (length(args) > 0) 
[17:41:00.382]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.382]             }
[17:41:00.382]             else {
[17:41:00.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.382]             }
[17:41:00.382]             {
[17:41:00.382]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.382]                   0L) {
[17:41:00.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.382]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.382]                   base::options(opts)
[17:41:00.382]                 }
[17:41:00.382]                 {
[17:41:00.382]                   {
[17:41:00.382]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.382]                     NULL
[17:41:00.382]                   }
[17:41:00.382]                   options(future.plan = NULL)
[17:41:00.382]                   if (is.na(NA_character_)) 
[17:41:00.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.382]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:00.382]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:00.382]                     envir = parent.frame()) 
[17:41:00.382]                   {
[17:41:00.382]                     if (is.function(workers)) 
[17:41:00.382]                       workers <- workers()
[17:41:00.382]                     workers <- structure(as.integer(workers), 
[17:41:00.382]                       class = class(workers))
[17:41:00.382]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:00.382]                       workers >= 1)
[17:41:00.382]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:00.382]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:00.382]                     }
[17:41:00.382]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:00.382]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:00.382]                       envir = envir)
[17:41:00.382]                     if (!future$lazy) 
[17:41:00.382]                       future <- run(future)
[17:41:00.382]                     invisible(future)
[17:41:00.382]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:00.382]                 }
[17:41:00.382]             }
[17:41:00.382]         }
[17:41:00.382]     })
[17:41:00.382]     if (TRUE) {
[17:41:00.382]         base::sink(type = "output", split = FALSE)
[17:41:00.382]         if (TRUE) {
[17:41:00.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.382]         }
[17:41:00.382]         else {
[17:41:00.382]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.382]         }
[17:41:00.382]         base::close(...future.stdout)
[17:41:00.382]         ...future.stdout <- NULL
[17:41:00.382]     }
[17:41:00.382]     ...future.result$conditions <- ...future.conditions
[17:41:00.382]     ...future.result$finished <- base::Sys.time()
[17:41:00.382]     ...future.result
[17:41:00.382] }
[17:41:00.385] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[17:41:00.385] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:00.427] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:00.427] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[17:41:00.428] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[17:41:00.428] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:00.428] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.428] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:00.471] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:00.471] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:00.515] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:00.515] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:41:00.516] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.516] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:41:00.516] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:41:00.517] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:00.517] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.517] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:41:00.518] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:41:00.518] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:00.518] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.518] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:00.519] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.519] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[17:41:00.519] MultisessionFuture started
[17:41:00.520] - Launch lazy future ... done
[17:41:00.520] run() for ‘MultisessionFuture’ ... done
[17:41:00.520] Created future:
[17:41:00.520] MultisessionFuture:
[17:41:00.520] Label: ‘future_vapply-1’
[17:41:00.520] Expression:
[17:41:00.520] {
[17:41:00.520]     do.call(function(...) {
[17:41:00.520]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.520]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.520]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.520]             on.exit(options(oopts), add = TRUE)
[17:41:00.520]         }
[17:41:00.520]         {
[17:41:00.520]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.520]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.520]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.520]             })
[17:41:00.520]         }
[17:41:00.520]     }, args = future.call.arguments)
[17:41:00.520] }
[17:41:00.520] Lazy evaluation: FALSE
[17:41:00.520] Asynchronous evaluation: TRUE
[17:41:00.520] Local evaluation: TRUE
[17:41:00.520] Environment: R_GlobalEnv
[17:41:00.520] Capture standard output: TRUE
[17:41:00.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:00.520] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:00.520] Packages: 1 packages (‘future.apply’)
[17:41:00.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:00.520] Resolved: FALSE
[17:41:00.520] Value: <not collected>
[17:41:00.520] Conditions captured: <none>
[17:41:00.520] Early signaling: FALSE
[17:41:00.520] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:00.520] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.532] Chunk #1 of 2 ... DONE
[17:41:00.532] Chunk #2 of 2 ...
[17:41:00.532]  - Finding globals in 'X' for chunk #2 ...
[17:41:00.532] getGlobalsAndPackages() ...
[17:41:00.532] Searching for globals...
[17:41:00.533] 
[17:41:00.533] Searching for globals ... DONE
[17:41:00.533] - globals: [0] <none>
[17:41:00.533] getGlobalsAndPackages() ... DONE
[17:41:00.533]    + additional globals found: [n=0] 
[17:41:00.533]    + additional namespaces needed: [n=0] 
[17:41:00.533]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:00.533]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:41:00.534]  - seeds: <none>
[17:41:00.534] getGlobalsAndPackages() ...
[17:41:00.534] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.534] Resolving globals: FALSE
[17:41:00.534] Tweak future expression to call with '...' arguments ...
[17:41:00.534] {
[17:41:00.534]     do.call(function(...) {
[17:41:00.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.534]             on.exit(options(oopts), add = TRUE)
[17:41:00.534]         }
[17:41:00.534]         {
[17:41:00.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.534]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.534]             })
[17:41:00.534]         }
[17:41:00.534]     }, args = future.call.arguments)
[17:41:00.534] }
[17:41:00.534] Tweak future expression to call with '...' arguments ... DONE
[17:41:00.535] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.535] - packages: [1] ‘future.apply’
[17:41:00.535] getGlobalsAndPackages() ... DONE
[17:41:00.536] run() for ‘Future’ ...
[17:41:00.536] - state: ‘created’
[17:41:00.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.551]   - Field: ‘node’
[17:41:00.551]   - Field: ‘label’
[17:41:00.551]   - Field: ‘local’
[17:41:00.551]   - Field: ‘owner’
[17:41:00.551]   - Field: ‘envir’
[17:41:00.551]   - Field: ‘workers’
[17:41:00.551]   - Field: ‘packages’
[17:41:00.552]   - Field: ‘gc’
[17:41:00.552]   - Field: ‘conditions’
[17:41:00.552]   - Field: ‘persistent’
[17:41:00.552]   - Field: ‘expr’
[17:41:00.552]   - Field: ‘uuid’
[17:41:00.552]   - Field: ‘seed’
[17:41:00.552]   - Field: ‘version’
[17:41:00.552]   - Field: ‘result’
[17:41:00.552]   - Field: ‘asynchronous’
[17:41:00.552]   - Field: ‘calls’
[17:41:00.552]   - Field: ‘globals’
[17:41:00.553]   - Field: ‘stdout’
[17:41:00.553]   - Field: ‘earlySignal’
[17:41:00.553]   - Field: ‘lazy’
[17:41:00.553]   - Field: ‘state’
[17:41:00.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.553] - Launch lazy future ...
[17:41:00.553] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:00.553] Packages needed by future strategies (n = 0): <none>
[17:41:00.554] {
[17:41:00.554]     {
[17:41:00.554]         {
[17:41:00.554]             ...future.startTime <- base::Sys.time()
[17:41:00.554]             {
[17:41:00.554]                 {
[17:41:00.554]                   {
[17:41:00.554]                     {
[17:41:00.554]                       {
[17:41:00.554]                         base::local({
[17:41:00.554]                           has_future <- base::requireNamespace("future", 
[17:41:00.554]                             quietly = TRUE)
[17:41:00.554]                           if (has_future) {
[17:41:00.554]                             ns <- base::getNamespace("future")
[17:41:00.554]                             version <- ns[[".package"]][["version"]]
[17:41:00.554]                             if (is.null(version)) 
[17:41:00.554]                               version <- utils::packageVersion("future")
[17:41:00.554]                           }
[17:41:00.554]                           else {
[17:41:00.554]                             version <- NULL
[17:41:00.554]                           }
[17:41:00.554]                           if (!has_future || version < "1.8.0") {
[17:41:00.554]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.554]                               "", base::R.version$version.string), 
[17:41:00.554]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:00.554]                                 base::R.version$platform, 8 * 
[17:41:00.554]                                   base::.Machine$sizeof.pointer), 
[17:41:00.554]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.554]                                 "release", "version")], collapse = " "), 
[17:41:00.554]                               hostname = base::Sys.info()[["nodename"]])
[17:41:00.554]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.554]                               info)
[17:41:00.554]                             info <- base::paste(info, collapse = "; ")
[17:41:00.554]                             if (!has_future) {
[17:41:00.554]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.554]                                 info)
[17:41:00.554]                             }
[17:41:00.554]                             else {
[17:41:00.554]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.554]                                 info, version)
[17:41:00.554]                             }
[17:41:00.554]                             base::stop(msg)
[17:41:00.554]                           }
[17:41:00.554]                         })
[17:41:00.554]                       }
[17:41:00.554]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.554]                       base::options(mc.cores = 1L)
[17:41:00.554]                     }
[17:41:00.554]                     base::local({
[17:41:00.554]                       for (pkg in "future.apply") {
[17:41:00.554]                         base::loadNamespace(pkg)
[17:41:00.554]                         base::library(pkg, character.only = TRUE)
[17:41:00.554]                       }
[17:41:00.554]                     })
[17:41:00.554]                   }
[17:41:00.554]                   options(future.plan = NULL)
[17:41:00.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.554]                 }
[17:41:00.554]                 ...future.workdir <- getwd()
[17:41:00.554]             }
[17:41:00.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.554]         }
[17:41:00.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.554]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:41:00.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.554]             base::names(...future.oldOptions))
[17:41:00.554]     }
[17:41:00.554]     if (FALSE) {
[17:41:00.554]     }
[17:41:00.554]     else {
[17:41:00.554]         if (TRUE) {
[17:41:00.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.554]                 open = "w")
[17:41:00.554]         }
[17:41:00.554]         else {
[17:41:00.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.554]         }
[17:41:00.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.554]             base::sink(type = "output", split = FALSE)
[17:41:00.554]             base::close(...future.stdout)
[17:41:00.554]         }, add = TRUE)
[17:41:00.554]     }
[17:41:00.554]     ...future.frame <- base::sys.nframe()
[17:41:00.554]     ...future.conditions <- base::list()
[17:41:00.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.554]     if (FALSE) {
[17:41:00.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.554]     }
[17:41:00.554]     ...future.result <- base::tryCatch({
[17:41:00.554]         base::withCallingHandlers({
[17:41:00.554]             ...future.value <- base::withVisible(base::local({
[17:41:00.554]                 ...future.makeSendCondition <- local({
[17:41:00.554]                   sendCondition <- NULL
[17:41:00.554]                   function(frame = 1L) {
[17:41:00.554]                     if (is.function(sendCondition)) 
[17:41:00.554]                       return(sendCondition)
[17:41:00.554]                     ns <- getNamespace("parallel")
[17:41:00.554]                     if (exists("sendData", mode = "function", 
[17:41:00.554]                       envir = ns)) {
[17:41:00.554]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.554]                         envir = ns)
[17:41:00.554]                       envir <- sys.frame(frame)
[17:41:00.554]                       master <- NULL
[17:41:00.554]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.554]                         !identical(envir, emptyenv())) {
[17:41:00.554]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.554]                           inherits = FALSE)) {
[17:41:00.554]                           master <- get("master", mode = "list", 
[17:41:00.554]                             envir = envir, inherits = FALSE)
[17:41:00.554]                           if (inherits(master, c("SOCKnode", 
[17:41:00.554]                             "SOCK0node"))) {
[17:41:00.554]                             sendCondition <<- function(cond) {
[17:41:00.554]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.554]                                 success = TRUE)
[17:41:00.554]                               parallel_sendData(master, data)
[17:41:00.554]                             }
[17:41:00.554]                             return(sendCondition)
[17:41:00.554]                           }
[17:41:00.554]                         }
[17:41:00.554]                         frame <- frame + 1L
[17:41:00.554]                         envir <- sys.frame(frame)
[17:41:00.554]                       }
[17:41:00.554]                     }
[17:41:00.554]                     sendCondition <<- function(cond) NULL
[17:41:00.554]                   }
[17:41:00.554]                 })
[17:41:00.554]                 withCallingHandlers({
[17:41:00.554]                   {
[17:41:00.554]                     do.call(function(...) {
[17:41:00.554]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.554]                       if (!identical(...future.globals.maxSize.org, 
[17:41:00.554]                         ...future.globals.maxSize)) {
[17:41:00.554]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.554]                         on.exit(options(oopts), add = TRUE)
[17:41:00.554]                       }
[17:41:00.554]                       {
[17:41:00.554]                         lapply(seq_along(...future.elements_ii), 
[17:41:00.554]                           FUN = function(jj) {
[17:41:00.554]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.554]                             ...future.FUN(...future.X_jj, ...)
[17:41:00.554]                           })
[17:41:00.554]                       }
[17:41:00.554]                     }, args = future.call.arguments)
[17:41:00.554]                   }
[17:41:00.554]                 }, immediateCondition = function(cond) {
[17:41:00.554]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.554]                   sendCondition(cond)
[17:41:00.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.554]                   {
[17:41:00.554]                     inherits <- base::inherits
[17:41:00.554]                     invokeRestart <- base::invokeRestart
[17:41:00.554]                     is.null <- base::is.null
[17:41:00.554]                     muffled <- FALSE
[17:41:00.554]                     if (inherits(cond, "message")) {
[17:41:00.554]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.554]                       if (muffled) 
[17:41:00.554]                         invokeRestart("muffleMessage")
[17:41:00.554]                     }
[17:41:00.554]                     else if (inherits(cond, "warning")) {
[17:41:00.554]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.554]                       if (muffled) 
[17:41:00.554]                         invokeRestart("muffleWarning")
[17:41:00.554]                     }
[17:41:00.554]                     else if (inherits(cond, "condition")) {
[17:41:00.554]                       if (!is.null(pattern)) {
[17:41:00.554]                         computeRestarts <- base::computeRestarts
[17:41:00.554]                         grepl <- base::grepl
[17:41:00.554]                         restarts <- computeRestarts(cond)
[17:41:00.554]                         for (restart in restarts) {
[17:41:00.554]                           name <- restart$name
[17:41:00.554]                           if (is.null(name)) 
[17:41:00.554]                             next
[17:41:00.554]                           if (!grepl(pattern, name)) 
[17:41:00.554]                             next
[17:41:00.554]                           invokeRestart(restart)
[17:41:00.554]                           muffled <- TRUE
[17:41:00.554]                           break
[17:41:00.554]                         }
[17:41:00.554]                       }
[17:41:00.554]                     }
[17:41:00.554]                     invisible(muffled)
[17:41:00.554]                   }
[17:41:00.554]                   muffleCondition(cond)
[17:41:00.554]                 })
[17:41:00.554]             }))
[17:41:00.554]             future::FutureResult(value = ...future.value$value, 
[17:41:00.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.554]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.554]                     ...future.globalenv.names))
[17:41:00.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.554]         }, condition = base::local({
[17:41:00.554]             c <- base::c
[17:41:00.554]             inherits <- base::inherits
[17:41:00.554]             invokeRestart <- base::invokeRestart
[17:41:00.554]             length <- base::length
[17:41:00.554]             list <- base::list
[17:41:00.554]             seq.int <- base::seq.int
[17:41:00.554]             signalCondition <- base::signalCondition
[17:41:00.554]             sys.calls <- base::sys.calls
[17:41:00.554]             `[[` <- base::`[[`
[17:41:00.554]             `+` <- base::`+`
[17:41:00.554]             `<<-` <- base::`<<-`
[17:41:00.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.554]                   3L)]
[17:41:00.554]             }
[17:41:00.554]             function(cond) {
[17:41:00.554]                 is_error <- inherits(cond, "error")
[17:41:00.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.554]                   NULL)
[17:41:00.554]                 if (is_error) {
[17:41:00.554]                   sessionInformation <- function() {
[17:41:00.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.554]                       search = base::search(), system = base::Sys.info())
[17:41:00.554]                   }
[17:41:00.554]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.554]                     cond$call), session = sessionInformation(), 
[17:41:00.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.554]                   signalCondition(cond)
[17:41:00.554]                 }
[17:41:00.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.554]                 "immediateCondition"))) {
[17:41:00.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.554]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.554]                   if (TRUE && !signal) {
[17:41:00.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.554]                     {
[17:41:00.554]                       inherits <- base::inherits
[17:41:00.554]                       invokeRestart <- base::invokeRestart
[17:41:00.554]                       is.null <- base::is.null
[17:41:00.554]                       muffled <- FALSE
[17:41:00.554]                       if (inherits(cond, "message")) {
[17:41:00.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.554]                         if (muffled) 
[17:41:00.554]                           invokeRestart("muffleMessage")
[17:41:00.554]                       }
[17:41:00.554]                       else if (inherits(cond, "warning")) {
[17:41:00.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.554]                         if (muffled) 
[17:41:00.554]                           invokeRestart("muffleWarning")
[17:41:00.554]                       }
[17:41:00.554]                       else if (inherits(cond, "condition")) {
[17:41:00.554]                         if (!is.null(pattern)) {
[17:41:00.554]                           computeRestarts <- base::computeRestarts
[17:41:00.554]                           grepl <- base::grepl
[17:41:00.554]                           restarts <- computeRestarts(cond)
[17:41:00.554]                           for (restart in restarts) {
[17:41:00.554]                             name <- restart$name
[17:41:00.554]                             if (is.null(name)) 
[17:41:00.554]                               next
[17:41:00.554]                             if (!grepl(pattern, name)) 
[17:41:00.554]                               next
[17:41:00.554]                             invokeRestart(restart)
[17:41:00.554]                             muffled <- TRUE
[17:41:00.554]                             break
[17:41:00.554]                           }
[17:41:00.554]                         }
[17:41:00.554]                       }
[17:41:00.554]                       invisible(muffled)
[17:41:00.554]                     }
[17:41:00.554]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.554]                   }
[17:41:00.554]                 }
[17:41:00.554]                 else {
[17:41:00.554]                   if (TRUE) {
[17:41:00.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.554]                     {
[17:41:00.554]                       inherits <- base::inherits
[17:41:00.554]                       invokeRestart <- base::invokeRestart
[17:41:00.554]                       is.null <- base::is.null
[17:41:00.554]                       muffled <- FALSE
[17:41:00.554]                       if (inherits(cond, "message")) {
[17:41:00.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.554]                         if (muffled) 
[17:41:00.554]                           invokeRestart("muffleMessage")
[17:41:00.554]                       }
[17:41:00.554]                       else if (inherits(cond, "warning")) {
[17:41:00.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.554]                         if (muffled) 
[17:41:00.554]                           invokeRestart("muffleWarning")
[17:41:00.554]                       }
[17:41:00.554]                       else if (inherits(cond, "condition")) {
[17:41:00.554]                         if (!is.null(pattern)) {
[17:41:00.554]                           computeRestarts <- base::computeRestarts
[17:41:00.554]                           grepl <- base::grepl
[17:41:00.554]                           restarts <- computeRestarts(cond)
[17:41:00.554]                           for (restart in restarts) {
[17:41:00.554]                             name <- restart$name
[17:41:00.554]                             if (is.null(name)) 
[17:41:00.554]                               next
[17:41:00.554]                             if (!grepl(pattern, name)) 
[17:41:00.554]                               next
[17:41:00.554]                             invokeRestart(restart)
[17:41:00.554]                             muffled <- TRUE
[17:41:00.554]                             break
[17:41:00.554]                           }
[17:41:00.554]                         }
[17:41:00.554]                       }
[17:41:00.554]                       invisible(muffled)
[17:41:00.554]                     }
[17:41:00.554]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.554]                   }
[17:41:00.554]                 }
[17:41:00.554]             }
[17:41:00.554]         }))
[17:41:00.554]     }, error = function(ex) {
[17:41:00.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.554]                 ...future.rng), started = ...future.startTime, 
[17:41:00.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.554]             version = "1.8"), class = "FutureResult")
[17:41:00.554]     }, finally = {
[17:41:00.554]         if (!identical(...future.workdir, getwd())) 
[17:41:00.554]             setwd(...future.workdir)
[17:41:00.554]         {
[17:41:00.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.554]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.554]             }
[17:41:00.554]             base::options(...future.oldOptions)
[17:41:00.554]             if (.Platform$OS.type == "windows") {
[17:41:00.554]                 old_names <- names(...future.oldEnvVars)
[17:41:00.554]                 envs <- base::Sys.getenv()
[17:41:00.554]                 names <- names(envs)
[17:41:00.554]                 common <- intersect(names, old_names)
[17:41:00.554]                 added <- setdiff(names, old_names)
[17:41:00.554]                 removed <- setdiff(old_names, names)
[17:41:00.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.554]                   envs[common]]
[17:41:00.554]                 NAMES <- toupper(changed)
[17:41:00.554]                 args <- list()
[17:41:00.554]                 for (kk in seq_along(NAMES)) {
[17:41:00.554]                   name <- changed[[kk]]
[17:41:00.554]                   NAME <- NAMES[[kk]]
[17:41:00.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.554]                     next
[17:41:00.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.554]                 }
[17:41:00.554]                 NAMES <- toupper(added)
[17:41:00.554]                 for (kk in seq_along(NAMES)) {
[17:41:00.554]                   name <- added[[kk]]
[17:41:00.554]                   NAME <- NAMES[[kk]]
[17:41:00.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.554]                     next
[17:41:00.554]                   args[[name]] <- ""
[17:41:00.554]                 }
[17:41:00.554]                 NAMES <- toupper(removed)
[17:41:00.554]                 for (kk in seq_along(NAMES)) {
[17:41:00.554]                   name <- removed[[kk]]
[17:41:00.554]                   NAME <- NAMES[[kk]]
[17:41:00.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.554]                     next
[17:41:00.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.554]                 }
[17:41:00.554]                 if (length(args) > 0) 
[17:41:00.554]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.554]             }
[17:41:00.554]             else {
[17:41:00.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.554]             }
[17:41:00.554]             {
[17:41:00.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.554]                   0L) {
[17:41:00.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.554]                   base::options(opts)
[17:41:00.554]                 }
[17:41:00.554]                 {
[17:41:00.554]                   {
[17:41:00.554]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.554]                     NULL
[17:41:00.554]                   }
[17:41:00.554]                   options(future.plan = NULL)
[17:41:00.554]                   if (is.na(NA_character_)) 
[17:41:00.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.554]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:00.554]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:00.554]                     envir = parent.frame()) 
[17:41:00.554]                   {
[17:41:00.554]                     if (is.function(workers)) 
[17:41:00.554]                       workers <- workers()
[17:41:00.554]                     workers <- structure(as.integer(workers), 
[17:41:00.554]                       class = class(workers))
[17:41:00.554]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:00.554]                       workers >= 1)
[17:41:00.554]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:00.554]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:00.554]                     }
[17:41:00.554]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:00.554]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:00.554]                       envir = envir)
[17:41:00.554]                     if (!future$lazy) 
[17:41:00.554]                       future <- run(future)
[17:41:00.554]                     invisible(future)
[17:41:00.554]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:00.554]                 }
[17:41:00.554]             }
[17:41:00.554]         }
[17:41:00.554]     })
[17:41:00.554]     if (TRUE) {
[17:41:00.554]         base::sink(type = "output", split = FALSE)
[17:41:00.554]         if (TRUE) {
[17:41:00.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.554]         }
[17:41:00.554]         else {
[17:41:00.554]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.554]         }
[17:41:00.554]         base::close(...future.stdout)
[17:41:00.554]         ...future.stdout <- NULL
[17:41:00.554]     }
[17:41:00.554]     ...future.result$conditions <- ...future.conditions
[17:41:00.554]     ...future.result$finished <- base::Sys.time()
[17:41:00.554]     ...future.result
[17:41:00.554] }
[17:41:00.557] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[17:41:00.557] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:00.599] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:00.599] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[17:41:00.600] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[17:41:00.600] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:00.600] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:00.601] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:00.643] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:00.643] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:00.687] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:00.687] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:41:00.688] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:41:00.688] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:41:00.688] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:41:00.688] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:00.689] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:00.689] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:41:00.689] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:41:00.689] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:00.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:00.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:00.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:00.690] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[17:41:00.691] MultisessionFuture started
[17:41:00.691] - Launch lazy future ... done
[17:41:00.691] run() for ‘MultisessionFuture’ ... done
[17:41:00.692] Created future:
[17:41:00.692] MultisessionFuture:
[17:41:00.692] Label: ‘future_vapply-2’
[17:41:00.692] Expression:
[17:41:00.692] {
[17:41:00.692]     do.call(function(...) {
[17:41:00.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.692]             on.exit(options(oopts), add = TRUE)
[17:41:00.692]         }
[17:41:00.692]         {
[17:41:00.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.692]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.692]             })
[17:41:00.692]         }
[17:41:00.692]     }, args = future.call.arguments)
[17:41:00.692] }
[17:41:00.692] Lazy evaluation: FALSE
[17:41:00.692] Asynchronous evaluation: TRUE
[17:41:00.692] Local evaluation: TRUE
[17:41:00.692] Environment: R_GlobalEnv
[17:41:00.692] Capture standard output: TRUE
[17:41:00.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:00.692] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:00.692] Packages: 1 packages (‘future.apply’)
[17:41:00.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:00.692] Resolved: FALSE
[17:41:00.692] Value: <not collected>
[17:41:00.692] Conditions captured: <none>
[17:41:00.692] Early signaling: FALSE
[17:41:00.692] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:00.692] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.703] Chunk #2 of 2 ... DONE
[17:41:00.704] Launching 2 futures (chunks) ... DONE
[17:41:00.704] Resolving 2 futures (chunks) ...
[17:41:00.704] resolve() on list ...
[17:41:00.704]  recursive: 0
[17:41:00.704]  length: 2
[17:41:00.704] 
[17:41:00.705] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.705] - Validating connection of MultisessionFuture
[17:41:00.705] - received message: FutureResult
[17:41:00.705] - Received FutureResult
[17:41:00.705] - Erased future from FutureRegistry
[17:41:00.705] result() for ClusterFuture ...
[17:41:00.705] - result already collected: FutureResult
[17:41:00.705] result() for ClusterFuture ... done
[17:41:00.706] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.706] Future #1
[17:41:00.706] result() for ClusterFuture ...
[17:41:00.706] - result already collected: FutureResult
[17:41:00.706] result() for ClusterFuture ... done
[17:41:00.706] result() for ClusterFuture ...
[17:41:00.706] - result already collected: FutureResult
[17:41:00.706] result() for ClusterFuture ... done
[17:41:00.706] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:00.706] - nx: 2
[17:41:00.706] - relay: TRUE
[17:41:00.706] - stdout: TRUE
[17:41:00.707] - signal: TRUE
[17:41:00.707] - resignal: FALSE
[17:41:00.707] - force: TRUE
[17:41:00.707] - relayed: [n=2] FALSE, FALSE
[17:41:00.707] - queued futures: [n=2] FALSE, FALSE
[17:41:00.707]  - until=1
[17:41:00.707]  - relaying element #1
[17:41:00.707] result() for ClusterFuture ...
[17:41:00.707] - result already collected: FutureResult
[17:41:00.707] result() for ClusterFuture ... done
[17:41:00.708] result() for ClusterFuture ...
[17:41:00.708] - result already collected: FutureResult
[17:41:00.708] result() for ClusterFuture ... done
[17:41:00.708] result() for ClusterFuture ...
[17:41:00.708] - result already collected: FutureResult
[17:41:00.708] result() for ClusterFuture ... done
[17:41:00.708] result() for ClusterFuture ...
[17:41:00.708] - result already collected: FutureResult
[17:41:00.708] result() for ClusterFuture ... done
[17:41:00.708] - relayed: [n=2] TRUE, FALSE
[17:41:00.708] - queued futures: [n=2] TRUE, FALSE
[17:41:00.708] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:00.709]  length: 1 (resolved future 1)
[17:41:00.750] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.750] - Validating connection of MultisessionFuture
[17:41:00.751] - received message: FutureResult
[17:41:00.751] - Received FutureResult
[17:41:00.751] - Erased future from FutureRegistry
[17:41:00.751] result() for ClusterFuture ...
[17:41:00.751] - result already collected: FutureResult
[17:41:00.751] result() for ClusterFuture ... done
[17:41:00.751] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.751] Future #2
[17:41:00.751] result() for ClusterFuture ...
[17:41:00.751] - result already collected: FutureResult
[17:41:00.752] result() for ClusterFuture ... done
[17:41:00.752] result() for ClusterFuture ...
[17:41:00.752] - result already collected: FutureResult
[17:41:00.752] result() for ClusterFuture ... done
[17:41:00.752] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:00.752] - nx: 2
[17:41:00.752] - relay: TRUE
[17:41:00.752] - stdout: TRUE
[17:41:00.752] - signal: TRUE
[17:41:00.752] - resignal: FALSE
[17:41:00.752] - force: TRUE
[17:41:00.753] - relayed: [n=2] TRUE, FALSE
[17:41:00.753] - queued futures: [n=2] TRUE, FALSE
[17:41:00.753]  - until=2
[17:41:00.753]  - relaying element #2
[17:41:00.753] result() for ClusterFuture ...
[17:41:00.753] - result already collected: FutureResult
[17:41:00.753] result() for ClusterFuture ... done
[17:41:00.753] result() for ClusterFuture ...
[17:41:00.753] - result already collected: FutureResult
[17:41:00.753] result() for ClusterFuture ... done
[17:41:00.753] result() for ClusterFuture ...
[17:41:00.754] - result already collected: FutureResult
[17:41:00.754] result() for ClusterFuture ... done
[17:41:00.754] result() for ClusterFuture ...
[17:41:00.754] - result already collected: FutureResult
[17:41:00.754] result() for ClusterFuture ... done
[17:41:00.754] - relayed: [n=2] TRUE, TRUE
[17:41:00.754] - queued futures: [n=2] TRUE, TRUE
[17:41:00.754] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:00.754]  length: 0 (resolved future 2)
[17:41:00.754] Relaying remaining futures
[17:41:00.754] signalConditionsASAP(NULL, pos=0) ...
[17:41:00.755] - nx: 2
[17:41:00.755] - relay: TRUE
[17:41:00.755] - stdout: TRUE
[17:41:00.755] - signal: TRUE
[17:41:00.755] - resignal: FALSE
[17:41:00.755] - force: TRUE
[17:41:00.755] - relayed: [n=2] TRUE, TRUE
[17:41:00.755] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:00.755] - relayed: [n=2] TRUE, TRUE
[17:41:00.755] - queued futures: [n=2] TRUE, TRUE
[17:41:00.755] signalConditionsASAP(NULL, pos=0) ... done
[17:41:00.756] resolve() on list ... DONE
[17:41:00.756] result() for ClusterFuture ...
[17:41:00.756] - result already collected: FutureResult
[17:41:00.756] result() for ClusterFuture ... done
[17:41:00.756] result() for ClusterFuture ...
[17:41:00.756] - result already collected: FutureResult
[17:41:00.756] result() for ClusterFuture ... done
[17:41:00.756] result() for ClusterFuture ...
[17:41:00.756] - result already collected: FutureResult
[17:41:00.756] result() for ClusterFuture ... done
[17:41:00.756] result() for ClusterFuture ...
[17:41:00.757] - result already collected: FutureResult
[17:41:00.757] result() for ClusterFuture ... done
[17:41:00.757]  - Number of value chunks collected: 2
[17:41:00.757] Resolving 2 futures (chunks) ... DONE
[17:41:00.757] Reducing values from 2 chunks ...
[17:41:00.757]  - Number of values collected after concatenation: 10
[17:41:00.757]  - Number of values expected: 10
[17:41:00.757] Reducing values from 2 chunks ... DONE
[17:41:00.757] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:41:00.760] future_lapply() ...
[17:41:00.765] Number of chunks: 2
[17:41:00.765] getGlobalsAndPackagesXApply() ...
[17:41:00.765]  - future.globals: TRUE
[17:41:00.765] getGlobalsAndPackages() ...
[17:41:00.765] Searching for globals...
[17:41:00.769] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:41:00.769] Searching for globals ... DONE
[17:41:00.769] Resolving globals: FALSE
[17:41:00.770] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:41:00.770] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:41:00.771] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:00.771] - packages: [2] ‘stats’, ‘future.apply’
[17:41:00.771] getGlobalsAndPackages() ... DONE
[17:41:00.771]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:00.771]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:41:00.771] Finding globals ... DONE
[17:41:00.771]  - use_args: TRUE
[17:41:00.771]  - Getting '...' globals ...
[17:41:00.772] resolve() on list ...
[17:41:00.772]  recursive: 0
[17:41:00.772]  length: 1
[17:41:00.772]  elements: ‘...’
[17:41:00.772]  length: 0 (resolved future 1)
[17:41:00.772] resolve() on list ... DONE
[17:41:00.772]    - '...' content: [n=0] 
[17:41:00.772] List of 1
[17:41:00.772]  $ ...: list()
[17:41:00.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:00.772]  - attr(*, "where")=List of 1
[17:41:00.772]   ..$ ...:<environment: 0x564f3229a068> 
[17:41:00.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:00.772]  - attr(*, "resolved")= logi TRUE
[17:41:00.772]  - attr(*, "total_size")= num NA
[17:41:00.775]  - Getting '...' globals ... DONE
[17:41:00.775] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:00.775] List of 8
[17:41:00.775]  $ ...future.FUN:function (x, ...)  
[17:41:00.775]  $ x_FUN        :function (x, ...)  
[17:41:00.775]  $ times        : int 5
[17:41:00.775]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:00.775]  $ stop_if_not  :function (...)  
[17:41:00.775]  $ dim          : NULL
[17:41:00.775]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:41:00.775]  $ ...          : list()
[17:41:00.775]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:00.775]  - attr(*, "where")=List of 8
[17:41:00.775]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:00.775]   ..$ ...          :<environment: 0x564f3229a068> 
[17:41:00.775]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:00.775]  - attr(*, "resolved")= logi FALSE
[17:41:00.775]  - attr(*, "total_size")= num 95528
[17:41:00.781] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:41:00.781] getGlobalsAndPackagesXApply() ... DONE
[17:41:00.781] Number of futures (= number of chunks): 2
[17:41:00.781] Launching 2 futures (chunks) ...
[17:41:00.782] Chunk #1 of 2 ...
[17:41:00.782]  - Finding globals in 'X' for chunk #1 ...
[17:41:00.782] getGlobalsAndPackages() ...
[17:41:00.782] Searching for globals...
[17:41:00.782] 
[17:41:00.782] Searching for globals ... DONE
[17:41:00.782] - globals: [0] <none>
[17:41:00.782] getGlobalsAndPackages() ... DONE
[17:41:00.782]    + additional globals found: [n=0] 
[17:41:00.783]    + additional namespaces needed: [n=0] 
[17:41:00.783]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:00.783]  - seeds: <none>
[17:41:00.783] getGlobalsAndPackages() ...
[17:41:00.783] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.783] Resolving globals: FALSE
[17:41:00.783] Tweak future expression to call with '...' arguments ...
[17:41:00.783] {
[17:41:00.783]     do.call(function(...) {
[17:41:00.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.783]             on.exit(options(oopts), add = TRUE)
[17:41:00.783]         }
[17:41:00.783]         {
[17:41:00.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.783]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.783]             })
[17:41:00.783]         }
[17:41:00.783]     }, args = future.call.arguments)
[17:41:00.783] }
[17:41:00.784] Tweak future expression to call with '...' arguments ... DONE
[17:41:00.784] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.784] - packages: [2] ‘stats’, ‘future.apply’
[17:41:00.784] getGlobalsAndPackages() ... DONE
[17:41:00.785] run() for ‘Future’ ...
[17:41:00.785] - state: ‘created’
[17:41:00.785] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.806] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.806]   - Field: ‘node’
[17:41:00.806]   - Field: ‘label’
[17:41:00.806]   - Field: ‘local’
[17:41:00.807]   - Field: ‘owner’
[17:41:00.807]   - Field: ‘envir’
[17:41:00.807]   - Field: ‘workers’
[17:41:00.807]   - Field: ‘packages’
[17:41:00.807]   - Field: ‘gc’
[17:41:00.807]   - Field: ‘conditions’
[17:41:00.807]   - Field: ‘persistent’
[17:41:00.807]   - Field: ‘expr’
[17:41:00.807]   - Field: ‘uuid’
[17:41:00.807]   - Field: ‘seed’
[17:41:00.808]   - Field: ‘version’
[17:41:00.808]   - Field: ‘result’
[17:41:00.808]   - Field: ‘asynchronous’
[17:41:00.808]   - Field: ‘calls’
[17:41:00.808]   - Field: ‘globals’
[17:41:00.808]   - Field: ‘stdout’
[17:41:00.808]   - Field: ‘earlySignal’
[17:41:00.808]   - Field: ‘lazy’
[17:41:00.808]   - Field: ‘state’
[17:41:00.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.808] - Launch lazy future ...
[17:41:00.809] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:41:00.809] Packages needed by future strategies (n = 0): <none>
[17:41:00.809] {
[17:41:00.809]     {
[17:41:00.809]         {
[17:41:00.809]             ...future.startTime <- base::Sys.time()
[17:41:00.809]             {
[17:41:00.809]                 {
[17:41:00.809]                   {
[17:41:00.809]                     {
[17:41:00.809]                       {
[17:41:00.809]                         base::local({
[17:41:00.809]                           has_future <- base::requireNamespace("future", 
[17:41:00.809]                             quietly = TRUE)
[17:41:00.809]                           if (has_future) {
[17:41:00.809]                             ns <- base::getNamespace("future")
[17:41:00.809]                             version <- ns[[".package"]][["version"]]
[17:41:00.809]                             if (is.null(version)) 
[17:41:00.809]                               version <- utils::packageVersion("future")
[17:41:00.809]                           }
[17:41:00.809]                           else {
[17:41:00.809]                             version <- NULL
[17:41:00.809]                           }
[17:41:00.809]                           if (!has_future || version < "1.8.0") {
[17:41:00.809]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.809]                               "", base::R.version$version.string), 
[17:41:00.809]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:00.809]                                 base::R.version$platform, 8 * 
[17:41:00.809]                                   base::.Machine$sizeof.pointer), 
[17:41:00.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.809]                                 "release", "version")], collapse = " "), 
[17:41:00.809]                               hostname = base::Sys.info()[["nodename"]])
[17:41:00.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.809]                               info)
[17:41:00.809]                             info <- base::paste(info, collapse = "; ")
[17:41:00.809]                             if (!has_future) {
[17:41:00.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.809]                                 info)
[17:41:00.809]                             }
[17:41:00.809]                             else {
[17:41:00.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.809]                                 info, version)
[17:41:00.809]                             }
[17:41:00.809]                             base::stop(msg)
[17:41:00.809]                           }
[17:41:00.809]                         })
[17:41:00.809]                       }
[17:41:00.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.809]                       base::options(mc.cores = 1L)
[17:41:00.809]                     }
[17:41:00.809]                     base::local({
[17:41:00.809]                       for (pkg in c("stats", "future.apply")) {
[17:41:00.809]                         base::loadNamespace(pkg)
[17:41:00.809]                         base::library(pkg, character.only = TRUE)
[17:41:00.809]                       }
[17:41:00.809]                     })
[17:41:00.809]                   }
[17:41:00.809]                   options(future.plan = NULL)
[17:41:00.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.809]                 }
[17:41:00.809]                 ...future.workdir <- getwd()
[17:41:00.809]             }
[17:41:00.809]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.809]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.809]         }
[17:41:00.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.809]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.809]             base::names(...future.oldOptions))
[17:41:00.809]     }
[17:41:00.809]     if (FALSE) {
[17:41:00.809]     }
[17:41:00.809]     else {
[17:41:00.809]         if (TRUE) {
[17:41:00.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.809]                 open = "w")
[17:41:00.809]         }
[17:41:00.809]         else {
[17:41:00.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.809]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.809]         }
[17:41:00.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.809]             base::sink(type = "output", split = FALSE)
[17:41:00.809]             base::close(...future.stdout)
[17:41:00.809]         }, add = TRUE)
[17:41:00.809]     }
[17:41:00.809]     ...future.frame <- base::sys.nframe()
[17:41:00.809]     ...future.conditions <- base::list()
[17:41:00.809]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.809]     if (FALSE) {
[17:41:00.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.809]     }
[17:41:00.809]     ...future.result <- base::tryCatch({
[17:41:00.809]         base::withCallingHandlers({
[17:41:00.809]             ...future.value <- base::withVisible(base::local({
[17:41:00.809]                 ...future.makeSendCondition <- local({
[17:41:00.809]                   sendCondition <- NULL
[17:41:00.809]                   function(frame = 1L) {
[17:41:00.809]                     if (is.function(sendCondition)) 
[17:41:00.809]                       return(sendCondition)
[17:41:00.809]                     ns <- getNamespace("parallel")
[17:41:00.809]                     if (exists("sendData", mode = "function", 
[17:41:00.809]                       envir = ns)) {
[17:41:00.809]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.809]                         envir = ns)
[17:41:00.809]                       envir <- sys.frame(frame)
[17:41:00.809]                       master <- NULL
[17:41:00.809]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.809]                         !identical(envir, emptyenv())) {
[17:41:00.809]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.809]                           inherits = FALSE)) {
[17:41:00.809]                           master <- get("master", mode = "list", 
[17:41:00.809]                             envir = envir, inherits = FALSE)
[17:41:00.809]                           if (inherits(master, c("SOCKnode", 
[17:41:00.809]                             "SOCK0node"))) {
[17:41:00.809]                             sendCondition <<- function(cond) {
[17:41:00.809]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.809]                                 success = TRUE)
[17:41:00.809]                               parallel_sendData(master, data)
[17:41:00.809]                             }
[17:41:00.809]                             return(sendCondition)
[17:41:00.809]                           }
[17:41:00.809]                         }
[17:41:00.809]                         frame <- frame + 1L
[17:41:00.809]                         envir <- sys.frame(frame)
[17:41:00.809]                       }
[17:41:00.809]                     }
[17:41:00.809]                     sendCondition <<- function(cond) NULL
[17:41:00.809]                   }
[17:41:00.809]                 })
[17:41:00.809]                 withCallingHandlers({
[17:41:00.809]                   {
[17:41:00.809]                     do.call(function(...) {
[17:41:00.809]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.809]                       if (!identical(...future.globals.maxSize.org, 
[17:41:00.809]                         ...future.globals.maxSize)) {
[17:41:00.809]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.809]                         on.exit(options(oopts), add = TRUE)
[17:41:00.809]                       }
[17:41:00.809]                       {
[17:41:00.809]                         lapply(seq_along(...future.elements_ii), 
[17:41:00.809]                           FUN = function(jj) {
[17:41:00.809]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.809]                             ...future.FUN(...future.X_jj, ...)
[17:41:00.809]                           })
[17:41:00.809]                       }
[17:41:00.809]                     }, args = future.call.arguments)
[17:41:00.809]                   }
[17:41:00.809]                 }, immediateCondition = function(cond) {
[17:41:00.809]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.809]                   sendCondition(cond)
[17:41:00.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.809]                   {
[17:41:00.809]                     inherits <- base::inherits
[17:41:00.809]                     invokeRestart <- base::invokeRestart
[17:41:00.809]                     is.null <- base::is.null
[17:41:00.809]                     muffled <- FALSE
[17:41:00.809]                     if (inherits(cond, "message")) {
[17:41:00.809]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.809]                       if (muffled) 
[17:41:00.809]                         invokeRestart("muffleMessage")
[17:41:00.809]                     }
[17:41:00.809]                     else if (inherits(cond, "warning")) {
[17:41:00.809]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.809]                       if (muffled) 
[17:41:00.809]                         invokeRestart("muffleWarning")
[17:41:00.809]                     }
[17:41:00.809]                     else if (inherits(cond, "condition")) {
[17:41:00.809]                       if (!is.null(pattern)) {
[17:41:00.809]                         computeRestarts <- base::computeRestarts
[17:41:00.809]                         grepl <- base::grepl
[17:41:00.809]                         restarts <- computeRestarts(cond)
[17:41:00.809]                         for (restart in restarts) {
[17:41:00.809]                           name <- restart$name
[17:41:00.809]                           if (is.null(name)) 
[17:41:00.809]                             next
[17:41:00.809]                           if (!grepl(pattern, name)) 
[17:41:00.809]                             next
[17:41:00.809]                           invokeRestart(restart)
[17:41:00.809]                           muffled <- TRUE
[17:41:00.809]                           break
[17:41:00.809]                         }
[17:41:00.809]                       }
[17:41:00.809]                     }
[17:41:00.809]                     invisible(muffled)
[17:41:00.809]                   }
[17:41:00.809]                   muffleCondition(cond)
[17:41:00.809]                 })
[17:41:00.809]             }))
[17:41:00.809]             future::FutureResult(value = ...future.value$value, 
[17:41:00.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.809]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.809]                     ...future.globalenv.names))
[17:41:00.809]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.809]         }, condition = base::local({
[17:41:00.809]             c <- base::c
[17:41:00.809]             inherits <- base::inherits
[17:41:00.809]             invokeRestart <- base::invokeRestart
[17:41:00.809]             length <- base::length
[17:41:00.809]             list <- base::list
[17:41:00.809]             seq.int <- base::seq.int
[17:41:00.809]             signalCondition <- base::signalCondition
[17:41:00.809]             sys.calls <- base::sys.calls
[17:41:00.809]             `[[` <- base::`[[`
[17:41:00.809]             `+` <- base::`+`
[17:41:00.809]             `<<-` <- base::`<<-`
[17:41:00.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.809]                   3L)]
[17:41:00.809]             }
[17:41:00.809]             function(cond) {
[17:41:00.809]                 is_error <- inherits(cond, "error")
[17:41:00.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.809]                   NULL)
[17:41:00.809]                 if (is_error) {
[17:41:00.809]                   sessionInformation <- function() {
[17:41:00.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.809]                       search = base::search(), system = base::Sys.info())
[17:41:00.809]                   }
[17:41:00.809]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.809]                     cond$call), session = sessionInformation(), 
[17:41:00.809]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.809]                   signalCondition(cond)
[17:41:00.809]                 }
[17:41:00.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.809]                 "immediateCondition"))) {
[17:41:00.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.809]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.809]                   if (TRUE && !signal) {
[17:41:00.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.809]                     {
[17:41:00.809]                       inherits <- base::inherits
[17:41:00.809]                       invokeRestart <- base::invokeRestart
[17:41:00.809]                       is.null <- base::is.null
[17:41:00.809]                       muffled <- FALSE
[17:41:00.809]                       if (inherits(cond, "message")) {
[17:41:00.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.809]                         if (muffled) 
[17:41:00.809]                           invokeRestart("muffleMessage")
[17:41:00.809]                       }
[17:41:00.809]                       else if (inherits(cond, "warning")) {
[17:41:00.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.809]                         if (muffled) 
[17:41:00.809]                           invokeRestart("muffleWarning")
[17:41:00.809]                       }
[17:41:00.809]                       else if (inherits(cond, "condition")) {
[17:41:00.809]                         if (!is.null(pattern)) {
[17:41:00.809]                           computeRestarts <- base::computeRestarts
[17:41:00.809]                           grepl <- base::grepl
[17:41:00.809]                           restarts <- computeRestarts(cond)
[17:41:00.809]                           for (restart in restarts) {
[17:41:00.809]                             name <- restart$name
[17:41:00.809]                             if (is.null(name)) 
[17:41:00.809]                               next
[17:41:00.809]                             if (!grepl(pattern, name)) 
[17:41:00.809]                               next
[17:41:00.809]                             invokeRestart(restart)
[17:41:00.809]                             muffled <- TRUE
[17:41:00.809]                             break
[17:41:00.809]                           }
[17:41:00.809]                         }
[17:41:00.809]                       }
[17:41:00.809]                       invisible(muffled)
[17:41:00.809]                     }
[17:41:00.809]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.809]                   }
[17:41:00.809]                 }
[17:41:00.809]                 else {
[17:41:00.809]                   if (TRUE) {
[17:41:00.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.809]                     {
[17:41:00.809]                       inherits <- base::inherits
[17:41:00.809]                       invokeRestart <- base::invokeRestart
[17:41:00.809]                       is.null <- base::is.null
[17:41:00.809]                       muffled <- FALSE
[17:41:00.809]                       if (inherits(cond, "message")) {
[17:41:00.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.809]                         if (muffled) 
[17:41:00.809]                           invokeRestart("muffleMessage")
[17:41:00.809]                       }
[17:41:00.809]                       else if (inherits(cond, "warning")) {
[17:41:00.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.809]                         if (muffled) 
[17:41:00.809]                           invokeRestart("muffleWarning")
[17:41:00.809]                       }
[17:41:00.809]                       else if (inherits(cond, "condition")) {
[17:41:00.809]                         if (!is.null(pattern)) {
[17:41:00.809]                           computeRestarts <- base::computeRestarts
[17:41:00.809]                           grepl <- base::grepl
[17:41:00.809]                           restarts <- computeRestarts(cond)
[17:41:00.809]                           for (restart in restarts) {
[17:41:00.809]                             name <- restart$name
[17:41:00.809]                             if (is.null(name)) 
[17:41:00.809]                               next
[17:41:00.809]                             if (!grepl(pattern, name)) 
[17:41:00.809]                               next
[17:41:00.809]                             invokeRestart(restart)
[17:41:00.809]                             muffled <- TRUE
[17:41:00.809]                             break
[17:41:00.809]                           }
[17:41:00.809]                         }
[17:41:00.809]                       }
[17:41:00.809]                       invisible(muffled)
[17:41:00.809]                     }
[17:41:00.809]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.809]                   }
[17:41:00.809]                 }
[17:41:00.809]             }
[17:41:00.809]         }))
[17:41:00.809]     }, error = function(ex) {
[17:41:00.809]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.809]                 ...future.rng), started = ...future.startTime, 
[17:41:00.809]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.809]             version = "1.8"), class = "FutureResult")
[17:41:00.809]     }, finally = {
[17:41:00.809]         if (!identical(...future.workdir, getwd())) 
[17:41:00.809]             setwd(...future.workdir)
[17:41:00.809]         {
[17:41:00.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.809]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.809]             }
[17:41:00.809]             base::options(...future.oldOptions)
[17:41:00.809]             if (.Platform$OS.type == "windows") {
[17:41:00.809]                 old_names <- names(...future.oldEnvVars)
[17:41:00.809]                 envs <- base::Sys.getenv()
[17:41:00.809]                 names <- names(envs)
[17:41:00.809]                 common <- intersect(names, old_names)
[17:41:00.809]                 added <- setdiff(names, old_names)
[17:41:00.809]                 removed <- setdiff(old_names, names)
[17:41:00.809]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.809]                   envs[common]]
[17:41:00.809]                 NAMES <- toupper(changed)
[17:41:00.809]                 args <- list()
[17:41:00.809]                 for (kk in seq_along(NAMES)) {
[17:41:00.809]                   name <- changed[[kk]]
[17:41:00.809]                   NAME <- NAMES[[kk]]
[17:41:00.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.809]                     next
[17:41:00.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.809]                 }
[17:41:00.809]                 NAMES <- toupper(added)
[17:41:00.809]                 for (kk in seq_along(NAMES)) {
[17:41:00.809]                   name <- added[[kk]]
[17:41:00.809]                   NAME <- NAMES[[kk]]
[17:41:00.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.809]                     next
[17:41:00.809]                   args[[name]] <- ""
[17:41:00.809]                 }
[17:41:00.809]                 NAMES <- toupper(removed)
[17:41:00.809]                 for (kk in seq_along(NAMES)) {
[17:41:00.809]                   name <- removed[[kk]]
[17:41:00.809]                   NAME <- NAMES[[kk]]
[17:41:00.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.809]                     next
[17:41:00.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.809]                 }
[17:41:00.809]                 if (length(args) > 0) 
[17:41:00.809]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.809]             }
[17:41:00.809]             else {
[17:41:00.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.809]             }
[17:41:00.809]             {
[17:41:00.809]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.809]                   0L) {
[17:41:00.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.809]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.809]                   base::options(opts)
[17:41:00.809]                 }
[17:41:00.809]                 {
[17:41:00.809]                   {
[17:41:00.809]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.809]                     NULL
[17:41:00.809]                   }
[17:41:00.809]                   options(future.plan = NULL)
[17:41:00.809]                   if (is.na(NA_character_)) 
[17:41:00.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.809]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:00.809]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:00.809]                     envir = parent.frame()) 
[17:41:00.809]                   {
[17:41:00.809]                     if (is.function(workers)) 
[17:41:00.809]                       workers <- workers()
[17:41:00.809]                     workers <- structure(as.integer(workers), 
[17:41:00.809]                       class = class(workers))
[17:41:00.809]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:00.809]                       workers >= 1)
[17:41:00.809]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:00.809]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:00.809]                     }
[17:41:00.809]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:00.809]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:00.809]                       envir = envir)
[17:41:00.809]                     if (!future$lazy) 
[17:41:00.809]                       future <- run(future)
[17:41:00.809]                     invisible(future)
[17:41:00.809]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:00.809]                 }
[17:41:00.809]             }
[17:41:00.809]         }
[17:41:00.809]     })
[17:41:00.809]     if (TRUE) {
[17:41:00.809]         base::sink(type = "output", split = FALSE)
[17:41:00.809]         if (TRUE) {
[17:41:00.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.809]         }
[17:41:00.809]         else {
[17:41:00.809]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.809]         }
[17:41:00.809]         base::close(...future.stdout)
[17:41:00.809]         ...future.stdout <- NULL
[17:41:00.809]     }
[17:41:00.809]     ...future.result$conditions <- ...future.conditions
[17:41:00.809]     ...future.result$finished <- base::Sys.time()
[17:41:00.809]     ...future.result
[17:41:00.809] }
[17:41:00.813] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[17:41:00.813] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:00.855] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:00.855] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[17:41:00.856] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:41:00.856] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:00.856] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.856] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:00.899] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:00.899] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:00.943] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:00.943] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:41:00.944] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.944] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:41:00.944] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:41:00.944] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:00.945] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.945] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:41:00.945] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:41:00.945] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:00.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:00.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:00.946] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[17:41:00.947] MultisessionFuture started
[17:41:00.947] - Launch lazy future ... done
[17:41:00.947] run() for ‘MultisessionFuture’ ... done
[17:41:00.947] Created future:
[17:41:00.948] MultisessionFuture:
[17:41:00.948] Label: ‘future_vapply-1’
[17:41:00.948] Expression:
[17:41:00.948] {
[17:41:00.948]     do.call(function(...) {
[17:41:00.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.948]             on.exit(options(oopts), add = TRUE)
[17:41:00.948]         }
[17:41:00.948]         {
[17:41:00.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.948]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.948]             })
[17:41:00.948]         }
[17:41:00.948]     }, args = future.call.arguments)
[17:41:00.948] }
[17:41:00.948] Lazy evaluation: FALSE
[17:41:00.948] Asynchronous evaluation: TRUE
[17:41:00.948] Local evaluation: TRUE
[17:41:00.948] Environment: R_GlobalEnv
[17:41:00.948] Capture standard output: TRUE
[17:41:00.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:00.948] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:00.948] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:41:00.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:00.948] Resolved: FALSE
[17:41:00.948] Value: <not collected>
[17:41:00.948] Conditions captured: <none>
[17:41:00.948] Early signaling: FALSE
[17:41:00.948] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:00.948] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.959] Chunk #1 of 2 ... DONE
[17:41:00.959] Chunk #2 of 2 ...
[17:41:00.959]  - Finding globals in 'X' for chunk #2 ...
[17:41:00.960] getGlobalsAndPackages() ...
[17:41:00.960] Searching for globals...
[17:41:00.960] 
[17:41:00.960] Searching for globals ... DONE
[17:41:00.960] - globals: [0] <none>
[17:41:00.960] getGlobalsAndPackages() ... DONE
[17:41:00.960]    + additional globals found: [n=0] 
[17:41:00.960]    + additional namespaces needed: [n=0] 
[17:41:00.960]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:00.961]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:00.961]  - seeds: <none>
[17:41:00.961] getGlobalsAndPackages() ...
[17:41:00.961] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.961] Resolving globals: FALSE
[17:41:00.961] Tweak future expression to call with '...' arguments ...
[17:41:00.961] {
[17:41:00.961]     do.call(function(...) {
[17:41:00.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:00.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.961]             on.exit(options(oopts), add = TRUE)
[17:41:00.961]         }
[17:41:00.961]         {
[17:41:00.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:00.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.961]                 ...future.FUN(...future.X_jj, ...)
[17:41:00.961]             })
[17:41:00.961]         }
[17:41:00.961]     }, args = future.call.arguments)
[17:41:00.961] }
[17:41:00.961] Tweak future expression to call with '...' arguments ... DONE
[17:41:00.962] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:00.962] - packages: [2] ‘stats’, ‘future.apply’
[17:41:00.962] getGlobalsAndPackages() ... DONE
[17:41:00.962] run() for ‘Future’ ...
[17:41:00.963] - state: ‘created’
[17:41:00.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.978]   - Field: ‘node’
[17:41:00.978]   - Field: ‘label’
[17:41:00.978]   - Field: ‘local’
[17:41:00.978]   - Field: ‘owner’
[17:41:00.978]   - Field: ‘envir’
[17:41:00.978]   - Field: ‘workers’
[17:41:00.978]   - Field: ‘packages’
[17:41:00.978]   - Field: ‘gc’
[17:41:00.978]   - Field: ‘conditions’
[17:41:00.978]   - Field: ‘persistent’
[17:41:00.978]   - Field: ‘expr’
[17:41:00.979]   - Field: ‘uuid’
[17:41:00.979]   - Field: ‘seed’
[17:41:00.979]   - Field: ‘version’
[17:41:00.979]   - Field: ‘result’
[17:41:00.979]   - Field: ‘asynchronous’
[17:41:00.979]   - Field: ‘calls’
[17:41:00.979]   - Field: ‘globals’
[17:41:00.979]   - Field: ‘stdout’
[17:41:00.979]   - Field: ‘earlySignal’
[17:41:00.979]   - Field: ‘lazy’
[17:41:00.979]   - Field: ‘state’
[17:41:00.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.980] - Launch lazy future ...
[17:41:00.980] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:41:00.980] Packages needed by future strategies (n = 0): <none>
[17:41:00.981] {
[17:41:00.981]     {
[17:41:00.981]         {
[17:41:00.981]             ...future.startTime <- base::Sys.time()
[17:41:00.981]             {
[17:41:00.981]                 {
[17:41:00.981]                   {
[17:41:00.981]                     {
[17:41:00.981]                       {
[17:41:00.981]                         base::local({
[17:41:00.981]                           has_future <- base::requireNamespace("future", 
[17:41:00.981]                             quietly = TRUE)
[17:41:00.981]                           if (has_future) {
[17:41:00.981]                             ns <- base::getNamespace("future")
[17:41:00.981]                             version <- ns[[".package"]][["version"]]
[17:41:00.981]                             if (is.null(version)) 
[17:41:00.981]                               version <- utils::packageVersion("future")
[17:41:00.981]                           }
[17:41:00.981]                           else {
[17:41:00.981]                             version <- NULL
[17:41:00.981]                           }
[17:41:00.981]                           if (!has_future || version < "1.8.0") {
[17:41:00.981]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.981]                               "", base::R.version$version.string), 
[17:41:00.981]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:00.981]                                 base::R.version$platform, 8 * 
[17:41:00.981]                                   base::.Machine$sizeof.pointer), 
[17:41:00.981]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.981]                                 "release", "version")], collapse = " "), 
[17:41:00.981]                               hostname = base::Sys.info()[["nodename"]])
[17:41:00.981]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.981]                               info)
[17:41:00.981]                             info <- base::paste(info, collapse = "; ")
[17:41:00.981]                             if (!has_future) {
[17:41:00.981]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.981]                                 info)
[17:41:00.981]                             }
[17:41:00.981]                             else {
[17:41:00.981]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.981]                                 info, version)
[17:41:00.981]                             }
[17:41:00.981]                             base::stop(msg)
[17:41:00.981]                           }
[17:41:00.981]                         })
[17:41:00.981]                       }
[17:41:00.981]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.981]                       base::options(mc.cores = 1L)
[17:41:00.981]                     }
[17:41:00.981]                     base::local({
[17:41:00.981]                       for (pkg in c("stats", "future.apply")) {
[17:41:00.981]                         base::loadNamespace(pkg)
[17:41:00.981]                         base::library(pkg, character.only = TRUE)
[17:41:00.981]                       }
[17:41:00.981]                     })
[17:41:00.981]                   }
[17:41:00.981]                   options(future.plan = NULL)
[17:41:00.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.981]                 }
[17:41:00.981]                 ...future.workdir <- getwd()
[17:41:00.981]             }
[17:41:00.981]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.981]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.981]         }
[17:41:00.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.981]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:00.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.981]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.981]             base::names(...future.oldOptions))
[17:41:00.981]     }
[17:41:00.981]     if (FALSE) {
[17:41:00.981]     }
[17:41:00.981]     else {
[17:41:00.981]         if (TRUE) {
[17:41:00.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.981]                 open = "w")
[17:41:00.981]         }
[17:41:00.981]         else {
[17:41:00.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.981]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.981]         }
[17:41:00.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.981]             base::sink(type = "output", split = FALSE)
[17:41:00.981]             base::close(...future.stdout)
[17:41:00.981]         }, add = TRUE)
[17:41:00.981]     }
[17:41:00.981]     ...future.frame <- base::sys.nframe()
[17:41:00.981]     ...future.conditions <- base::list()
[17:41:00.981]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.981]     if (FALSE) {
[17:41:00.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.981]     }
[17:41:00.981]     ...future.result <- base::tryCatch({
[17:41:00.981]         base::withCallingHandlers({
[17:41:00.981]             ...future.value <- base::withVisible(base::local({
[17:41:00.981]                 ...future.makeSendCondition <- local({
[17:41:00.981]                   sendCondition <- NULL
[17:41:00.981]                   function(frame = 1L) {
[17:41:00.981]                     if (is.function(sendCondition)) 
[17:41:00.981]                       return(sendCondition)
[17:41:00.981]                     ns <- getNamespace("parallel")
[17:41:00.981]                     if (exists("sendData", mode = "function", 
[17:41:00.981]                       envir = ns)) {
[17:41:00.981]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.981]                         envir = ns)
[17:41:00.981]                       envir <- sys.frame(frame)
[17:41:00.981]                       master <- NULL
[17:41:00.981]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.981]                         !identical(envir, emptyenv())) {
[17:41:00.981]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.981]                           inherits = FALSE)) {
[17:41:00.981]                           master <- get("master", mode = "list", 
[17:41:00.981]                             envir = envir, inherits = FALSE)
[17:41:00.981]                           if (inherits(master, c("SOCKnode", 
[17:41:00.981]                             "SOCK0node"))) {
[17:41:00.981]                             sendCondition <<- function(cond) {
[17:41:00.981]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.981]                                 success = TRUE)
[17:41:00.981]                               parallel_sendData(master, data)
[17:41:00.981]                             }
[17:41:00.981]                             return(sendCondition)
[17:41:00.981]                           }
[17:41:00.981]                         }
[17:41:00.981]                         frame <- frame + 1L
[17:41:00.981]                         envir <- sys.frame(frame)
[17:41:00.981]                       }
[17:41:00.981]                     }
[17:41:00.981]                     sendCondition <<- function(cond) NULL
[17:41:00.981]                   }
[17:41:00.981]                 })
[17:41:00.981]                 withCallingHandlers({
[17:41:00.981]                   {
[17:41:00.981]                     do.call(function(...) {
[17:41:00.981]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:00.981]                       if (!identical(...future.globals.maxSize.org, 
[17:41:00.981]                         ...future.globals.maxSize)) {
[17:41:00.981]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:00.981]                         on.exit(options(oopts), add = TRUE)
[17:41:00.981]                       }
[17:41:00.981]                       {
[17:41:00.981]                         lapply(seq_along(...future.elements_ii), 
[17:41:00.981]                           FUN = function(jj) {
[17:41:00.981]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:00.981]                             ...future.FUN(...future.X_jj, ...)
[17:41:00.981]                           })
[17:41:00.981]                       }
[17:41:00.981]                     }, args = future.call.arguments)
[17:41:00.981]                   }
[17:41:00.981]                 }, immediateCondition = function(cond) {
[17:41:00.981]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.981]                   sendCondition(cond)
[17:41:00.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.981]                   {
[17:41:00.981]                     inherits <- base::inherits
[17:41:00.981]                     invokeRestart <- base::invokeRestart
[17:41:00.981]                     is.null <- base::is.null
[17:41:00.981]                     muffled <- FALSE
[17:41:00.981]                     if (inherits(cond, "message")) {
[17:41:00.981]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.981]                       if (muffled) 
[17:41:00.981]                         invokeRestart("muffleMessage")
[17:41:00.981]                     }
[17:41:00.981]                     else if (inherits(cond, "warning")) {
[17:41:00.981]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.981]                       if (muffled) 
[17:41:00.981]                         invokeRestart("muffleWarning")
[17:41:00.981]                     }
[17:41:00.981]                     else if (inherits(cond, "condition")) {
[17:41:00.981]                       if (!is.null(pattern)) {
[17:41:00.981]                         computeRestarts <- base::computeRestarts
[17:41:00.981]                         grepl <- base::grepl
[17:41:00.981]                         restarts <- computeRestarts(cond)
[17:41:00.981]                         for (restart in restarts) {
[17:41:00.981]                           name <- restart$name
[17:41:00.981]                           if (is.null(name)) 
[17:41:00.981]                             next
[17:41:00.981]                           if (!grepl(pattern, name)) 
[17:41:00.981]                             next
[17:41:00.981]                           invokeRestart(restart)
[17:41:00.981]                           muffled <- TRUE
[17:41:00.981]                           break
[17:41:00.981]                         }
[17:41:00.981]                       }
[17:41:00.981]                     }
[17:41:00.981]                     invisible(muffled)
[17:41:00.981]                   }
[17:41:00.981]                   muffleCondition(cond)
[17:41:00.981]                 })
[17:41:00.981]             }))
[17:41:00.981]             future::FutureResult(value = ...future.value$value, 
[17:41:00.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.981]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.981]                     ...future.globalenv.names))
[17:41:00.981]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.981]         }, condition = base::local({
[17:41:00.981]             c <- base::c
[17:41:00.981]             inherits <- base::inherits
[17:41:00.981]             invokeRestart <- base::invokeRestart
[17:41:00.981]             length <- base::length
[17:41:00.981]             list <- base::list
[17:41:00.981]             seq.int <- base::seq.int
[17:41:00.981]             signalCondition <- base::signalCondition
[17:41:00.981]             sys.calls <- base::sys.calls
[17:41:00.981]             `[[` <- base::`[[`
[17:41:00.981]             `+` <- base::`+`
[17:41:00.981]             `<<-` <- base::`<<-`
[17:41:00.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.981]                   3L)]
[17:41:00.981]             }
[17:41:00.981]             function(cond) {
[17:41:00.981]                 is_error <- inherits(cond, "error")
[17:41:00.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.981]                   NULL)
[17:41:00.981]                 if (is_error) {
[17:41:00.981]                   sessionInformation <- function() {
[17:41:00.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.981]                       search = base::search(), system = base::Sys.info())
[17:41:00.981]                   }
[17:41:00.981]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.981]                     cond$call), session = sessionInformation(), 
[17:41:00.981]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.981]                   signalCondition(cond)
[17:41:00.981]                 }
[17:41:00.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.981]                 "immediateCondition"))) {
[17:41:00.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.981]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.981]                   if (TRUE && !signal) {
[17:41:00.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.981]                     {
[17:41:00.981]                       inherits <- base::inherits
[17:41:00.981]                       invokeRestart <- base::invokeRestart
[17:41:00.981]                       is.null <- base::is.null
[17:41:00.981]                       muffled <- FALSE
[17:41:00.981]                       if (inherits(cond, "message")) {
[17:41:00.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.981]                         if (muffled) 
[17:41:00.981]                           invokeRestart("muffleMessage")
[17:41:00.981]                       }
[17:41:00.981]                       else if (inherits(cond, "warning")) {
[17:41:00.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.981]                         if (muffled) 
[17:41:00.981]                           invokeRestart("muffleWarning")
[17:41:00.981]                       }
[17:41:00.981]                       else if (inherits(cond, "condition")) {
[17:41:00.981]                         if (!is.null(pattern)) {
[17:41:00.981]                           computeRestarts <- base::computeRestarts
[17:41:00.981]                           grepl <- base::grepl
[17:41:00.981]                           restarts <- computeRestarts(cond)
[17:41:00.981]                           for (restart in restarts) {
[17:41:00.981]                             name <- restart$name
[17:41:00.981]                             if (is.null(name)) 
[17:41:00.981]                               next
[17:41:00.981]                             if (!grepl(pattern, name)) 
[17:41:00.981]                               next
[17:41:00.981]                             invokeRestart(restart)
[17:41:00.981]                             muffled <- TRUE
[17:41:00.981]                             break
[17:41:00.981]                           }
[17:41:00.981]                         }
[17:41:00.981]                       }
[17:41:00.981]                       invisible(muffled)
[17:41:00.981]                     }
[17:41:00.981]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.981]                   }
[17:41:00.981]                 }
[17:41:00.981]                 else {
[17:41:00.981]                   if (TRUE) {
[17:41:00.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.981]                     {
[17:41:00.981]                       inherits <- base::inherits
[17:41:00.981]                       invokeRestart <- base::invokeRestart
[17:41:00.981]                       is.null <- base::is.null
[17:41:00.981]                       muffled <- FALSE
[17:41:00.981]                       if (inherits(cond, "message")) {
[17:41:00.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.981]                         if (muffled) 
[17:41:00.981]                           invokeRestart("muffleMessage")
[17:41:00.981]                       }
[17:41:00.981]                       else if (inherits(cond, "warning")) {
[17:41:00.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.981]                         if (muffled) 
[17:41:00.981]                           invokeRestart("muffleWarning")
[17:41:00.981]                       }
[17:41:00.981]                       else if (inherits(cond, "condition")) {
[17:41:00.981]                         if (!is.null(pattern)) {
[17:41:00.981]                           computeRestarts <- base::computeRestarts
[17:41:00.981]                           grepl <- base::grepl
[17:41:00.981]                           restarts <- computeRestarts(cond)
[17:41:00.981]                           for (restart in restarts) {
[17:41:00.981]                             name <- restart$name
[17:41:00.981]                             if (is.null(name)) 
[17:41:00.981]                               next
[17:41:00.981]                             if (!grepl(pattern, name)) 
[17:41:00.981]                               next
[17:41:00.981]                             invokeRestart(restart)
[17:41:00.981]                             muffled <- TRUE
[17:41:00.981]                             break
[17:41:00.981]                           }
[17:41:00.981]                         }
[17:41:00.981]                       }
[17:41:00.981]                       invisible(muffled)
[17:41:00.981]                     }
[17:41:00.981]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.981]                   }
[17:41:00.981]                 }
[17:41:00.981]             }
[17:41:00.981]         }))
[17:41:00.981]     }, error = function(ex) {
[17:41:00.981]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.981]                 ...future.rng), started = ...future.startTime, 
[17:41:00.981]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.981]             version = "1.8"), class = "FutureResult")
[17:41:00.981]     }, finally = {
[17:41:00.981]         if (!identical(...future.workdir, getwd())) 
[17:41:00.981]             setwd(...future.workdir)
[17:41:00.981]         {
[17:41:00.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.981]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.981]             }
[17:41:00.981]             base::options(...future.oldOptions)
[17:41:00.981]             if (.Platform$OS.type == "windows") {
[17:41:00.981]                 old_names <- names(...future.oldEnvVars)
[17:41:00.981]                 envs <- base::Sys.getenv()
[17:41:00.981]                 names <- names(envs)
[17:41:00.981]                 common <- intersect(names, old_names)
[17:41:00.981]                 added <- setdiff(names, old_names)
[17:41:00.981]                 removed <- setdiff(old_names, names)
[17:41:00.981]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.981]                   envs[common]]
[17:41:00.981]                 NAMES <- toupper(changed)
[17:41:00.981]                 args <- list()
[17:41:00.981]                 for (kk in seq_along(NAMES)) {
[17:41:00.981]                   name <- changed[[kk]]
[17:41:00.981]                   NAME <- NAMES[[kk]]
[17:41:00.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.981]                     next
[17:41:00.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.981]                 }
[17:41:00.981]                 NAMES <- toupper(added)
[17:41:00.981]                 for (kk in seq_along(NAMES)) {
[17:41:00.981]                   name <- added[[kk]]
[17:41:00.981]                   NAME <- NAMES[[kk]]
[17:41:00.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.981]                     next
[17:41:00.981]                   args[[name]] <- ""
[17:41:00.981]                 }
[17:41:00.981]                 NAMES <- toupper(removed)
[17:41:00.981]                 for (kk in seq_along(NAMES)) {
[17:41:00.981]                   name <- removed[[kk]]
[17:41:00.981]                   NAME <- NAMES[[kk]]
[17:41:00.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.981]                     next
[17:41:00.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.981]                 }
[17:41:00.981]                 if (length(args) > 0) 
[17:41:00.981]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.981]             }
[17:41:00.981]             else {
[17:41:00.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.981]             }
[17:41:00.981]             {
[17:41:00.981]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.981]                   0L) {
[17:41:00.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.981]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.981]                   base::options(opts)
[17:41:00.981]                 }
[17:41:00.981]                 {
[17:41:00.981]                   {
[17:41:00.981]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.981]                     NULL
[17:41:00.981]                   }
[17:41:00.981]                   options(future.plan = NULL)
[17:41:00.981]                   if (is.na(NA_character_)) 
[17:41:00.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.981]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:00.981]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:00.981]                     envir = parent.frame()) 
[17:41:00.981]                   {
[17:41:00.981]                     if (is.function(workers)) 
[17:41:00.981]                       workers <- workers()
[17:41:00.981]                     workers <- structure(as.integer(workers), 
[17:41:00.981]                       class = class(workers))
[17:41:00.981]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:00.981]                       workers >= 1)
[17:41:00.981]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:00.981]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:00.981]                     }
[17:41:00.981]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:00.981]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:00.981]                       envir = envir)
[17:41:00.981]                     if (!future$lazy) 
[17:41:00.981]                       future <- run(future)
[17:41:00.981]                     invisible(future)
[17:41:00.981]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:00.981]                 }
[17:41:00.981]             }
[17:41:00.981]         }
[17:41:00.981]     })
[17:41:00.981]     if (TRUE) {
[17:41:00.981]         base::sink(type = "output", split = FALSE)
[17:41:00.981]         if (TRUE) {
[17:41:00.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.981]         }
[17:41:00.981]         else {
[17:41:00.981]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.981]         }
[17:41:00.981]         base::close(...future.stdout)
[17:41:00.981]         ...future.stdout <- NULL
[17:41:00.981]     }
[17:41:00.981]     ...future.result$conditions <- ...future.conditions
[17:41:00.981]     ...future.result$finished <- base::Sys.time()
[17:41:00.981]     ...future.result
[17:41:00.981] }
[17:41:00.983] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[17:41:00.984] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:01.027] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:01.027] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[17:41:01.028] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:41:01.028] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:01.028] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:01.028] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:01.071] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:01.071] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:01.115] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:01.115] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:41:01.116] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.116] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:41:01.116] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:41:01.117] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:01.117] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.117] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[17:41:01.118] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[17:41:01.118] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:01.118] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:01.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.119] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[17:41:01.119] MultisessionFuture started
[17:41:01.119] - Launch lazy future ... done
[17:41:01.119] run() for ‘MultisessionFuture’ ... done
[17:41:01.120] Created future:
[17:41:01.120] MultisessionFuture:
[17:41:01.120] Label: ‘future_vapply-2’
[17:41:01.120] Expression:
[17:41:01.120] {
[17:41:01.120]     do.call(function(...) {
[17:41:01.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.120]             on.exit(options(oopts), add = TRUE)
[17:41:01.120]         }
[17:41:01.120]         {
[17:41:01.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.120]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.120]             })
[17:41:01.120]         }
[17:41:01.120]     }, args = future.call.arguments)
[17:41:01.120] }
[17:41:01.120] Lazy evaluation: FALSE
[17:41:01.120] Asynchronous evaluation: TRUE
[17:41:01.120] Local evaluation: TRUE
[17:41:01.120] Environment: R_GlobalEnv
[17:41:01.120] Capture standard output: TRUE
[17:41:01.120] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:01.120] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:01.120] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:41:01.120] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:01.120] Resolved: FALSE
[17:41:01.120] Value: <not collected>
[17:41:01.120] Conditions captured: <none>
[17:41:01.120] Early signaling: FALSE
[17:41:01.120] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:01.120] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.132] Chunk #2 of 2 ... DONE
[17:41:01.132] Launching 2 futures (chunks) ... DONE
[17:41:01.132] Resolving 2 futures (chunks) ...
[17:41:01.132] resolve() on list ...
[17:41:01.132]  recursive: 0
[17:41:01.132]  length: 2
[17:41:01.132] 
[17:41:01.133] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.133] - Validating connection of MultisessionFuture
[17:41:01.133] - received message: FutureResult
[17:41:01.133] - Received FutureResult
[17:41:01.133] - Erased future from FutureRegistry
[17:41:01.133] result() for ClusterFuture ...
[17:41:01.134] - result already collected: FutureResult
[17:41:01.134] result() for ClusterFuture ... done
[17:41:01.134] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.134] Future #1
[17:41:01.134] result() for ClusterFuture ...
[17:41:01.134] - result already collected: FutureResult
[17:41:01.134] result() for ClusterFuture ... done
[17:41:01.134] result() for ClusterFuture ...
[17:41:01.134] - result already collected: FutureResult
[17:41:01.134] result() for ClusterFuture ... done
[17:41:01.134] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:01.134] - nx: 2
[17:41:01.135] - relay: TRUE
[17:41:01.135] - stdout: TRUE
[17:41:01.135] - signal: TRUE
[17:41:01.135] - resignal: FALSE
[17:41:01.135] - force: TRUE
[17:41:01.135] - relayed: [n=2] FALSE, FALSE
[17:41:01.135] - queued futures: [n=2] FALSE, FALSE
[17:41:01.135]  - until=1
[17:41:01.135]  - relaying element #1
[17:41:01.135] result() for ClusterFuture ...
[17:41:01.135] - result already collected: FutureResult
[17:41:01.136] result() for ClusterFuture ... done
[17:41:01.136] result() for ClusterFuture ...
[17:41:01.136] - result already collected: FutureResult
[17:41:01.136] result() for ClusterFuture ... done
[17:41:01.136] result() for ClusterFuture ...
[17:41:01.136] - result already collected: FutureResult
[17:41:01.136] result() for ClusterFuture ... done
[17:41:01.136] result() for ClusterFuture ...
[17:41:01.136] - result already collected: FutureResult
[17:41:01.136] result() for ClusterFuture ... done
[17:41:01.136] - relayed: [n=2] TRUE, FALSE
[17:41:01.137] - queued futures: [n=2] TRUE, FALSE
[17:41:01.137] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:01.137]  length: 1 (resolved future 1)
[17:41:01.178] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.179] - Validating connection of MultisessionFuture
[17:41:01.179] - received message: FutureResult
[17:41:01.179] - Received FutureResult
[17:41:01.179] - Erased future from FutureRegistry
[17:41:01.179] result() for ClusterFuture ...
[17:41:01.179] - result already collected: FutureResult
[17:41:01.179] result() for ClusterFuture ... done
[17:41:01.180] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.180] Future #2
[17:41:01.180] result() for ClusterFuture ...
[17:41:01.180] - result already collected: FutureResult
[17:41:01.180] result() for ClusterFuture ... done
[17:41:01.180] result() for ClusterFuture ...
[17:41:01.180] - result already collected: FutureResult
[17:41:01.180] result() for ClusterFuture ... done
[17:41:01.180] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:01.180] - nx: 2
[17:41:01.180] - relay: TRUE
[17:41:01.180] - stdout: TRUE
[17:41:01.181] - signal: TRUE
[17:41:01.181] - resignal: FALSE
[17:41:01.181] - force: TRUE
[17:41:01.181] - relayed: [n=2] TRUE, FALSE
[17:41:01.181] - queued futures: [n=2] TRUE, FALSE
[17:41:01.181]  - until=2
[17:41:01.181]  - relaying element #2
[17:41:01.181] result() for ClusterFuture ...
[17:41:01.181] - result already collected: FutureResult
[17:41:01.181] result() for ClusterFuture ... done
[17:41:01.181] result() for ClusterFuture ...
[17:41:01.182] - result already collected: FutureResult
[17:41:01.182] result() for ClusterFuture ... done
[17:41:01.182] result() for ClusterFuture ...
[17:41:01.182] - result already collected: FutureResult
[17:41:01.182] result() for ClusterFuture ... done
[17:41:01.182] result() for ClusterFuture ...
[17:41:01.182] - result already collected: FutureResult
[17:41:01.182] result() for ClusterFuture ... done
[17:41:01.182] - relayed: [n=2] TRUE, TRUE
[17:41:01.182] - queued futures: [n=2] TRUE, TRUE
[17:41:01.182] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:01.183]  length: 0 (resolved future 2)
[17:41:01.183] Relaying remaining futures
[17:41:01.183] signalConditionsASAP(NULL, pos=0) ...
[17:41:01.183] - nx: 2
[17:41:01.183] - relay: TRUE
[17:41:01.183] - stdout: TRUE
[17:41:01.183] - signal: TRUE
[17:41:01.183] - resignal: FALSE
[17:41:01.183] - force: TRUE
[17:41:01.183] - relayed: [n=2] TRUE, TRUE
[17:41:01.183] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:01.184] - relayed: [n=2] TRUE, TRUE
[17:41:01.184] - queued futures: [n=2] TRUE, TRUE
[17:41:01.184] signalConditionsASAP(NULL, pos=0) ... done
[17:41:01.184] resolve() on list ... DONE
[17:41:01.184] result() for ClusterFuture ...
[17:41:01.184] - result already collected: FutureResult
[17:41:01.184] result() for ClusterFuture ... done
[17:41:01.184] result() for ClusterFuture ...
[17:41:01.184] - result already collected: FutureResult
[17:41:01.184] result() for ClusterFuture ... done
[17:41:01.185] result() for ClusterFuture ...
[17:41:01.185] - result already collected: FutureResult
[17:41:01.185] result() for ClusterFuture ... done
[17:41:01.185] result() for ClusterFuture ...
[17:41:01.185] - result already collected: FutureResult
[17:41:01.185] result() for ClusterFuture ... done
[17:41:01.185]  - Number of value chunks collected: 2
[17:41:01.185] Resolving 2 futures (chunks) ... DONE
[17:41:01.185] Reducing values from 2 chunks ...
[17:41:01.185]  - Number of values collected after concatenation: 3
[17:41:01.185]  - Number of values expected: 3
[17:41:01.186] Reducing values from 2 chunks ... DONE
[17:41:01.186] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:41:01.187] future_lapply() ...
[17:41:01.194] Number of chunks: 2
[17:41:01.195] getGlobalsAndPackagesXApply() ...
[17:41:01.195]  - future.globals: TRUE
[17:41:01.195] getGlobalsAndPackages() ...
[17:41:01.195] Searching for globals...
[17:41:01.200] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:41:01.200] Searching for globals ... DONE
[17:41:01.200] Resolving globals: FALSE
[17:41:01.201] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:41:01.201] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:41:01.201] - globals: [1] ‘FUN’
[17:41:01.201] - packages: [1] ‘stats’
[17:41:01.201] getGlobalsAndPackages() ... DONE
[17:41:01.201]  - globals found/used: [n=1] ‘FUN’
[17:41:01.202]  - needed namespaces: [n=1] ‘stats’
[17:41:01.202] Finding globals ... DONE
[17:41:01.202]  - use_args: TRUE
[17:41:01.202]  - Getting '...' globals ...
[17:41:01.202] resolve() on list ...
[17:41:01.202]  recursive: 0
[17:41:01.202]  length: 1
[17:41:01.202]  elements: ‘...’
[17:41:01.202]  length: 0 (resolved future 1)
[17:41:01.203] resolve() on list ... DONE
[17:41:01.203]    - '...' content: [n=0] 
[17:41:01.203] List of 1
[17:41:01.203]  $ ...: list()
[17:41:01.203]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:01.203]  - attr(*, "where")=List of 1
[17:41:01.203]   ..$ ...:<environment: 0x564f31409628> 
[17:41:01.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:01.203]  - attr(*, "resolved")= logi TRUE
[17:41:01.203]  - attr(*, "total_size")= num NA
[17:41:01.205]  - Getting '...' globals ... DONE
[17:41:01.205] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:01.206] List of 2
[17:41:01.206]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:41:01.206]  $ ...          : list()
[17:41:01.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:01.206]  - attr(*, "where")=List of 2
[17:41:01.206]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:01.206]   ..$ ...          :<environment: 0x564f31409628> 
[17:41:01.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:01.206]  - attr(*, "resolved")= logi FALSE
[17:41:01.206]  - attr(*, "total_size")= num 46960
[17:41:01.208] Packages to be attached in all futures: [n=1] ‘stats’
[17:41:01.208] getGlobalsAndPackagesXApply() ... DONE
[17:41:01.209] Number of futures (= number of chunks): 2
[17:41:01.209] Launching 2 futures (chunks) ...
[17:41:01.209] Chunk #1 of 2 ...
[17:41:01.209]  - Finding globals in 'X' for chunk #1 ...
[17:41:01.209] getGlobalsAndPackages() ...
[17:41:01.209] Searching for globals...
[17:41:01.209] 
[17:41:01.209] Searching for globals ... DONE
[17:41:01.210] - globals: [0] <none>
[17:41:01.210] getGlobalsAndPackages() ... DONE
[17:41:01.212]    + additional globals found: [n=0] 
[17:41:01.212]    + additional namespaces needed: [n=0] 
[17:41:01.212]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:01.212]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[17:41:01.213]  - seeds: <none>
[17:41:01.213] getGlobalsAndPackages() ...
[17:41:01.213] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.213] Resolving globals: FALSE
[17:41:01.213] Tweak future expression to call with '...' arguments ...
[17:41:01.213] {
[17:41:01.213]     do.call(function(...) {
[17:41:01.213]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.213]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.213]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.213]             on.exit(options(oopts), add = TRUE)
[17:41:01.213]         }
[17:41:01.213]         {
[17:41:01.213]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.213]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.213]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.213]             })
[17:41:01.213]         }
[17:41:01.213]     }, args = future.call.arguments)
[17:41:01.213] }
[17:41:01.213] Tweak future expression to call with '...' arguments ... DONE
[17:41:01.214] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.214] - packages: [1] ‘stats’
[17:41:01.214] getGlobalsAndPackages() ... DONE
[17:41:01.214] run() for ‘Future’ ...
[17:41:01.214] - state: ‘created’
[17:41:01.215] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:01.229] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:01.229]   - Field: ‘node’
[17:41:01.229]   - Field: ‘label’
[17:41:01.229]   - Field: ‘local’
[17:41:01.229]   - Field: ‘owner’
[17:41:01.229]   - Field: ‘envir’
[17:41:01.229]   - Field: ‘workers’
[17:41:01.230]   - Field: ‘packages’
[17:41:01.230]   - Field: ‘gc’
[17:41:01.230]   - Field: ‘conditions’
[17:41:01.230]   - Field: ‘persistent’
[17:41:01.230]   - Field: ‘expr’
[17:41:01.230]   - Field: ‘uuid’
[17:41:01.230]   - Field: ‘seed’
[17:41:01.230]   - Field: ‘version’
[17:41:01.230]   - Field: ‘result’
[17:41:01.230]   - Field: ‘asynchronous’
[17:41:01.230]   - Field: ‘calls’
[17:41:01.230]   - Field: ‘globals’
[17:41:01.231]   - Field: ‘stdout’
[17:41:01.231]   - Field: ‘earlySignal’
[17:41:01.231]   - Field: ‘lazy’
[17:41:01.231]   - Field: ‘state’
[17:41:01.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:01.231] - Launch lazy future ...
[17:41:01.231] Packages needed by the future expression (n = 1): ‘stats’
[17:41:01.231] Packages needed by future strategies (n = 0): <none>
[17:41:01.232] {
[17:41:01.232]     {
[17:41:01.232]         {
[17:41:01.232]             ...future.startTime <- base::Sys.time()
[17:41:01.232]             {
[17:41:01.232]                 {
[17:41:01.232]                   {
[17:41:01.232]                     {
[17:41:01.232]                       {
[17:41:01.232]                         base::local({
[17:41:01.232]                           has_future <- base::requireNamespace("future", 
[17:41:01.232]                             quietly = TRUE)
[17:41:01.232]                           if (has_future) {
[17:41:01.232]                             ns <- base::getNamespace("future")
[17:41:01.232]                             version <- ns[[".package"]][["version"]]
[17:41:01.232]                             if (is.null(version)) 
[17:41:01.232]                               version <- utils::packageVersion("future")
[17:41:01.232]                           }
[17:41:01.232]                           else {
[17:41:01.232]                             version <- NULL
[17:41:01.232]                           }
[17:41:01.232]                           if (!has_future || version < "1.8.0") {
[17:41:01.232]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:01.232]                               "", base::R.version$version.string), 
[17:41:01.232]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:01.232]                                 base::R.version$platform, 8 * 
[17:41:01.232]                                   base::.Machine$sizeof.pointer), 
[17:41:01.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:01.232]                                 "release", "version")], collapse = " "), 
[17:41:01.232]                               hostname = base::Sys.info()[["nodename"]])
[17:41:01.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:01.232]                               info)
[17:41:01.232]                             info <- base::paste(info, collapse = "; ")
[17:41:01.232]                             if (!has_future) {
[17:41:01.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:01.232]                                 info)
[17:41:01.232]                             }
[17:41:01.232]                             else {
[17:41:01.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:01.232]                                 info, version)
[17:41:01.232]                             }
[17:41:01.232]                             base::stop(msg)
[17:41:01.232]                           }
[17:41:01.232]                         })
[17:41:01.232]                       }
[17:41:01.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:01.232]                       base::options(mc.cores = 1L)
[17:41:01.232]                     }
[17:41:01.232]                     base::local({
[17:41:01.232]                       for (pkg in "stats") {
[17:41:01.232]                         base::loadNamespace(pkg)
[17:41:01.232]                         base::library(pkg, character.only = TRUE)
[17:41:01.232]                       }
[17:41:01.232]                     })
[17:41:01.232]                   }
[17:41:01.232]                   options(future.plan = NULL)
[17:41:01.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:01.232]                 }
[17:41:01.232]                 ...future.workdir <- getwd()
[17:41:01.232]             }
[17:41:01.232]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:01.232]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:01.232]         }
[17:41:01.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:01.232]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[17:41:01.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:01.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:01.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:01.232]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:01.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:01.232]             base::names(...future.oldOptions))
[17:41:01.232]     }
[17:41:01.232]     if (FALSE) {
[17:41:01.232]     }
[17:41:01.232]     else {
[17:41:01.232]         if (TRUE) {
[17:41:01.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:01.232]                 open = "w")
[17:41:01.232]         }
[17:41:01.232]         else {
[17:41:01.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:01.232]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:01.232]         }
[17:41:01.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:01.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:01.232]             base::sink(type = "output", split = FALSE)
[17:41:01.232]             base::close(...future.stdout)
[17:41:01.232]         }, add = TRUE)
[17:41:01.232]     }
[17:41:01.232]     ...future.frame <- base::sys.nframe()
[17:41:01.232]     ...future.conditions <- base::list()
[17:41:01.232]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:01.232]     if (FALSE) {
[17:41:01.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:01.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:01.232]     }
[17:41:01.232]     ...future.result <- base::tryCatch({
[17:41:01.232]         base::withCallingHandlers({
[17:41:01.232]             ...future.value <- base::withVisible(base::local({
[17:41:01.232]                 ...future.makeSendCondition <- local({
[17:41:01.232]                   sendCondition <- NULL
[17:41:01.232]                   function(frame = 1L) {
[17:41:01.232]                     if (is.function(sendCondition)) 
[17:41:01.232]                       return(sendCondition)
[17:41:01.232]                     ns <- getNamespace("parallel")
[17:41:01.232]                     if (exists("sendData", mode = "function", 
[17:41:01.232]                       envir = ns)) {
[17:41:01.232]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:01.232]                         envir = ns)
[17:41:01.232]                       envir <- sys.frame(frame)
[17:41:01.232]                       master <- NULL
[17:41:01.232]                       while (!identical(envir, .GlobalEnv) && 
[17:41:01.232]                         !identical(envir, emptyenv())) {
[17:41:01.232]                         if (exists("master", mode = "list", envir = envir, 
[17:41:01.232]                           inherits = FALSE)) {
[17:41:01.232]                           master <- get("master", mode = "list", 
[17:41:01.232]                             envir = envir, inherits = FALSE)
[17:41:01.232]                           if (inherits(master, c("SOCKnode", 
[17:41:01.232]                             "SOCK0node"))) {
[17:41:01.232]                             sendCondition <<- function(cond) {
[17:41:01.232]                               data <- list(type = "VALUE", value = cond, 
[17:41:01.232]                                 success = TRUE)
[17:41:01.232]                               parallel_sendData(master, data)
[17:41:01.232]                             }
[17:41:01.232]                             return(sendCondition)
[17:41:01.232]                           }
[17:41:01.232]                         }
[17:41:01.232]                         frame <- frame + 1L
[17:41:01.232]                         envir <- sys.frame(frame)
[17:41:01.232]                       }
[17:41:01.232]                     }
[17:41:01.232]                     sendCondition <<- function(cond) NULL
[17:41:01.232]                   }
[17:41:01.232]                 })
[17:41:01.232]                 withCallingHandlers({
[17:41:01.232]                   {
[17:41:01.232]                     do.call(function(...) {
[17:41:01.232]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.232]                       if (!identical(...future.globals.maxSize.org, 
[17:41:01.232]                         ...future.globals.maxSize)) {
[17:41:01.232]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.232]                         on.exit(options(oopts), add = TRUE)
[17:41:01.232]                       }
[17:41:01.232]                       {
[17:41:01.232]                         lapply(seq_along(...future.elements_ii), 
[17:41:01.232]                           FUN = function(jj) {
[17:41:01.232]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.232]                             ...future.FUN(...future.X_jj, ...)
[17:41:01.232]                           })
[17:41:01.232]                       }
[17:41:01.232]                     }, args = future.call.arguments)
[17:41:01.232]                   }
[17:41:01.232]                 }, immediateCondition = function(cond) {
[17:41:01.232]                   sendCondition <- ...future.makeSendCondition()
[17:41:01.232]                   sendCondition(cond)
[17:41:01.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.232]                   {
[17:41:01.232]                     inherits <- base::inherits
[17:41:01.232]                     invokeRestart <- base::invokeRestart
[17:41:01.232]                     is.null <- base::is.null
[17:41:01.232]                     muffled <- FALSE
[17:41:01.232]                     if (inherits(cond, "message")) {
[17:41:01.232]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:01.232]                       if (muffled) 
[17:41:01.232]                         invokeRestart("muffleMessage")
[17:41:01.232]                     }
[17:41:01.232]                     else if (inherits(cond, "warning")) {
[17:41:01.232]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:01.232]                       if (muffled) 
[17:41:01.232]                         invokeRestart("muffleWarning")
[17:41:01.232]                     }
[17:41:01.232]                     else if (inherits(cond, "condition")) {
[17:41:01.232]                       if (!is.null(pattern)) {
[17:41:01.232]                         computeRestarts <- base::computeRestarts
[17:41:01.232]                         grepl <- base::grepl
[17:41:01.232]                         restarts <- computeRestarts(cond)
[17:41:01.232]                         for (restart in restarts) {
[17:41:01.232]                           name <- restart$name
[17:41:01.232]                           if (is.null(name)) 
[17:41:01.232]                             next
[17:41:01.232]                           if (!grepl(pattern, name)) 
[17:41:01.232]                             next
[17:41:01.232]                           invokeRestart(restart)
[17:41:01.232]                           muffled <- TRUE
[17:41:01.232]                           break
[17:41:01.232]                         }
[17:41:01.232]                       }
[17:41:01.232]                     }
[17:41:01.232]                     invisible(muffled)
[17:41:01.232]                   }
[17:41:01.232]                   muffleCondition(cond)
[17:41:01.232]                 })
[17:41:01.232]             }))
[17:41:01.232]             future::FutureResult(value = ...future.value$value, 
[17:41:01.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.232]                   ...future.rng), globalenv = if (FALSE) 
[17:41:01.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:01.232]                     ...future.globalenv.names))
[17:41:01.232]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:01.232]         }, condition = base::local({
[17:41:01.232]             c <- base::c
[17:41:01.232]             inherits <- base::inherits
[17:41:01.232]             invokeRestart <- base::invokeRestart
[17:41:01.232]             length <- base::length
[17:41:01.232]             list <- base::list
[17:41:01.232]             seq.int <- base::seq.int
[17:41:01.232]             signalCondition <- base::signalCondition
[17:41:01.232]             sys.calls <- base::sys.calls
[17:41:01.232]             `[[` <- base::`[[`
[17:41:01.232]             `+` <- base::`+`
[17:41:01.232]             `<<-` <- base::`<<-`
[17:41:01.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:01.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:01.232]                   3L)]
[17:41:01.232]             }
[17:41:01.232]             function(cond) {
[17:41:01.232]                 is_error <- inherits(cond, "error")
[17:41:01.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:01.232]                   NULL)
[17:41:01.232]                 if (is_error) {
[17:41:01.232]                   sessionInformation <- function() {
[17:41:01.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:01.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:01.232]                       search = base::search(), system = base::Sys.info())
[17:41:01.232]                   }
[17:41:01.232]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:01.232]                     cond$call), session = sessionInformation(), 
[17:41:01.232]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:01.232]                   signalCondition(cond)
[17:41:01.232]                 }
[17:41:01.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:01.232]                 "immediateCondition"))) {
[17:41:01.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:01.232]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:01.232]                   if (TRUE && !signal) {
[17:41:01.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.232]                     {
[17:41:01.232]                       inherits <- base::inherits
[17:41:01.232]                       invokeRestart <- base::invokeRestart
[17:41:01.232]                       is.null <- base::is.null
[17:41:01.232]                       muffled <- FALSE
[17:41:01.232]                       if (inherits(cond, "message")) {
[17:41:01.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.232]                         if (muffled) 
[17:41:01.232]                           invokeRestart("muffleMessage")
[17:41:01.232]                       }
[17:41:01.232]                       else if (inherits(cond, "warning")) {
[17:41:01.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.232]                         if (muffled) 
[17:41:01.232]                           invokeRestart("muffleWarning")
[17:41:01.232]                       }
[17:41:01.232]                       else if (inherits(cond, "condition")) {
[17:41:01.232]                         if (!is.null(pattern)) {
[17:41:01.232]                           computeRestarts <- base::computeRestarts
[17:41:01.232]                           grepl <- base::grepl
[17:41:01.232]                           restarts <- computeRestarts(cond)
[17:41:01.232]                           for (restart in restarts) {
[17:41:01.232]                             name <- restart$name
[17:41:01.232]                             if (is.null(name)) 
[17:41:01.232]                               next
[17:41:01.232]                             if (!grepl(pattern, name)) 
[17:41:01.232]                               next
[17:41:01.232]                             invokeRestart(restart)
[17:41:01.232]                             muffled <- TRUE
[17:41:01.232]                             break
[17:41:01.232]                           }
[17:41:01.232]                         }
[17:41:01.232]                       }
[17:41:01.232]                       invisible(muffled)
[17:41:01.232]                     }
[17:41:01.232]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.232]                   }
[17:41:01.232]                 }
[17:41:01.232]                 else {
[17:41:01.232]                   if (TRUE) {
[17:41:01.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.232]                     {
[17:41:01.232]                       inherits <- base::inherits
[17:41:01.232]                       invokeRestart <- base::invokeRestart
[17:41:01.232]                       is.null <- base::is.null
[17:41:01.232]                       muffled <- FALSE
[17:41:01.232]                       if (inherits(cond, "message")) {
[17:41:01.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.232]                         if (muffled) 
[17:41:01.232]                           invokeRestart("muffleMessage")
[17:41:01.232]                       }
[17:41:01.232]                       else if (inherits(cond, "warning")) {
[17:41:01.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.232]                         if (muffled) 
[17:41:01.232]                           invokeRestart("muffleWarning")
[17:41:01.232]                       }
[17:41:01.232]                       else if (inherits(cond, "condition")) {
[17:41:01.232]                         if (!is.null(pattern)) {
[17:41:01.232]                           computeRestarts <- base::computeRestarts
[17:41:01.232]                           grepl <- base::grepl
[17:41:01.232]                           restarts <- computeRestarts(cond)
[17:41:01.232]                           for (restart in restarts) {
[17:41:01.232]                             name <- restart$name
[17:41:01.232]                             if (is.null(name)) 
[17:41:01.232]                               next
[17:41:01.232]                             if (!grepl(pattern, name)) 
[17:41:01.232]                               next
[17:41:01.232]                             invokeRestart(restart)
[17:41:01.232]                             muffled <- TRUE
[17:41:01.232]                             break
[17:41:01.232]                           }
[17:41:01.232]                         }
[17:41:01.232]                       }
[17:41:01.232]                       invisible(muffled)
[17:41:01.232]                     }
[17:41:01.232]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.232]                   }
[17:41:01.232]                 }
[17:41:01.232]             }
[17:41:01.232]         }))
[17:41:01.232]     }, error = function(ex) {
[17:41:01.232]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:01.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.232]                 ...future.rng), started = ...future.startTime, 
[17:41:01.232]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:01.232]             version = "1.8"), class = "FutureResult")
[17:41:01.232]     }, finally = {
[17:41:01.232]         if (!identical(...future.workdir, getwd())) 
[17:41:01.232]             setwd(...future.workdir)
[17:41:01.232]         {
[17:41:01.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:01.232]                 ...future.oldOptions$nwarnings <- NULL
[17:41:01.232]             }
[17:41:01.232]             base::options(...future.oldOptions)
[17:41:01.232]             if (.Platform$OS.type == "windows") {
[17:41:01.232]                 old_names <- names(...future.oldEnvVars)
[17:41:01.232]                 envs <- base::Sys.getenv()
[17:41:01.232]                 names <- names(envs)
[17:41:01.232]                 common <- intersect(names, old_names)
[17:41:01.232]                 added <- setdiff(names, old_names)
[17:41:01.232]                 removed <- setdiff(old_names, names)
[17:41:01.232]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:01.232]                   envs[common]]
[17:41:01.232]                 NAMES <- toupper(changed)
[17:41:01.232]                 args <- list()
[17:41:01.232]                 for (kk in seq_along(NAMES)) {
[17:41:01.232]                   name <- changed[[kk]]
[17:41:01.232]                   NAME <- NAMES[[kk]]
[17:41:01.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.232]                     next
[17:41:01.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.232]                 }
[17:41:01.232]                 NAMES <- toupper(added)
[17:41:01.232]                 for (kk in seq_along(NAMES)) {
[17:41:01.232]                   name <- added[[kk]]
[17:41:01.232]                   NAME <- NAMES[[kk]]
[17:41:01.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.232]                     next
[17:41:01.232]                   args[[name]] <- ""
[17:41:01.232]                 }
[17:41:01.232]                 NAMES <- toupper(removed)
[17:41:01.232]                 for (kk in seq_along(NAMES)) {
[17:41:01.232]                   name <- removed[[kk]]
[17:41:01.232]                   NAME <- NAMES[[kk]]
[17:41:01.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.232]                     next
[17:41:01.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.232]                 }
[17:41:01.232]                 if (length(args) > 0) 
[17:41:01.232]                   base::do.call(base::Sys.setenv, args = args)
[17:41:01.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:01.232]             }
[17:41:01.232]             else {
[17:41:01.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:01.232]             }
[17:41:01.232]             {
[17:41:01.232]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:01.232]                   0L) {
[17:41:01.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:01.232]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:01.232]                   base::options(opts)
[17:41:01.232]                 }
[17:41:01.232]                 {
[17:41:01.232]                   {
[17:41:01.232]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:01.232]                     NULL
[17:41:01.232]                   }
[17:41:01.232]                   options(future.plan = NULL)
[17:41:01.232]                   if (is.na(NA_character_)) 
[17:41:01.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:01.232]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:01.232]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:01.232]                     envir = parent.frame()) 
[17:41:01.232]                   {
[17:41:01.232]                     if (is.function(workers)) 
[17:41:01.232]                       workers <- workers()
[17:41:01.232]                     workers <- structure(as.integer(workers), 
[17:41:01.232]                       class = class(workers))
[17:41:01.232]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:01.232]                       workers >= 1)
[17:41:01.232]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:01.232]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:01.232]                     }
[17:41:01.232]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:01.232]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:01.232]                       envir = envir)
[17:41:01.232]                     if (!future$lazy) 
[17:41:01.232]                       future <- run(future)
[17:41:01.232]                     invisible(future)
[17:41:01.232]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:01.232]                 }
[17:41:01.232]             }
[17:41:01.232]         }
[17:41:01.232]     })
[17:41:01.232]     if (TRUE) {
[17:41:01.232]         base::sink(type = "output", split = FALSE)
[17:41:01.232]         if (TRUE) {
[17:41:01.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:01.232]         }
[17:41:01.232]         else {
[17:41:01.232]             ...future.result["stdout"] <- base::list(NULL)
[17:41:01.232]         }
[17:41:01.232]         base::close(...future.stdout)
[17:41:01.232]         ...future.stdout <- NULL
[17:41:01.232]     }
[17:41:01.232]     ...future.result$conditions <- ...future.conditions
[17:41:01.232]     ...future.result$finished <- base::Sys.time()
[17:41:01.232]     ...future.result
[17:41:01.232] }
[17:41:01.235] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[17:41:01.235] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[17:41:01.279] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:41:01.279] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:01.280] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.280] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:41:01.280] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:41:01.280] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:01.281] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:01.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.281] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[17:41:01.282] MultisessionFuture started
[17:41:01.282] - Launch lazy future ... done
[17:41:01.282] run() for ‘MultisessionFuture’ ... done
[17:41:01.282] Created future:
[17:41:01.282] MultisessionFuture:
[17:41:01.282] Label: ‘future_sapply-1’
[17:41:01.282] Expression:
[17:41:01.282] {
[17:41:01.282]     do.call(function(...) {
[17:41:01.282]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.282]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.282]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.282]             on.exit(options(oopts), add = TRUE)
[17:41:01.282]         }
[17:41:01.282]         {
[17:41:01.282]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.282]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.282]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.282]             })
[17:41:01.282]         }
[17:41:01.282]     }, args = future.call.arguments)
[17:41:01.282] }
[17:41:01.282] Lazy evaluation: FALSE
[17:41:01.282] Asynchronous evaluation: TRUE
[17:41:01.282] Local evaluation: TRUE
[17:41:01.282] Environment: R_GlobalEnv
[17:41:01.282] Capture standard output: TRUE
[17:41:01.282] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:01.282] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:01.282] Packages: 1 packages (‘stats’)
[17:41:01.282] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:01.282] Resolved: FALSE
[17:41:01.282] Value: <not collected>
[17:41:01.282] Conditions captured: <none>
[17:41:01.282] Early signaling: FALSE
[17:41:01.282] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:01.282] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.294] Chunk #1 of 2 ... DONE
[17:41:01.294] Chunk #2 of 2 ...
[17:41:01.294]  - Finding globals in 'X' for chunk #2 ...
[17:41:01.294] getGlobalsAndPackages() ...
[17:41:01.294] Searching for globals...
[17:41:01.294] 
[17:41:01.294] Searching for globals ... DONE
[17:41:01.295] - globals: [0] <none>
[17:41:01.295] getGlobalsAndPackages() ... DONE
[17:41:01.295]    + additional globals found: [n=0] 
[17:41:01.295]    + additional namespaces needed: [n=0] 
[17:41:01.295]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:01.295]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:41:01.295]  - seeds: <none>
[17:41:01.295] getGlobalsAndPackages() ...
[17:41:01.295] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.295] Resolving globals: FALSE
[17:41:01.296] Tweak future expression to call with '...' arguments ...
[17:41:01.296] {
[17:41:01.296]     do.call(function(...) {
[17:41:01.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.296]             on.exit(options(oopts), add = TRUE)
[17:41:01.296]         }
[17:41:01.296]         {
[17:41:01.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.296]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.296]             })
[17:41:01.296]         }
[17:41:01.296]     }, args = future.call.arguments)
[17:41:01.296] }
[17:41:01.296] Tweak future expression to call with '...' arguments ... DONE
[17:41:01.296] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.296] - packages: [1] ‘stats’
[17:41:01.296] getGlobalsAndPackages() ... DONE
[17:41:01.297] run() for ‘Future’ ...
[17:41:01.297] - state: ‘created’
[17:41:01.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:01.312] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:01.312]   - Field: ‘node’
[17:41:01.312]   - Field: ‘label’
[17:41:01.312]   - Field: ‘local’
[17:41:01.312]   - Field: ‘owner’
[17:41:01.312]   - Field: ‘envir’
[17:41:01.312]   - Field: ‘workers’
[17:41:01.312]   - Field: ‘packages’
[17:41:01.313]   - Field: ‘gc’
[17:41:01.313]   - Field: ‘conditions’
[17:41:01.313]   - Field: ‘persistent’
[17:41:01.313]   - Field: ‘expr’
[17:41:01.313]   - Field: ‘uuid’
[17:41:01.313]   - Field: ‘seed’
[17:41:01.313]   - Field: ‘version’
[17:41:01.313]   - Field: ‘result’
[17:41:01.313]   - Field: ‘asynchronous’
[17:41:01.313]   - Field: ‘calls’
[17:41:01.313]   - Field: ‘globals’
[17:41:01.314]   - Field: ‘stdout’
[17:41:01.314]   - Field: ‘earlySignal’
[17:41:01.314]   - Field: ‘lazy’
[17:41:01.314]   - Field: ‘state’
[17:41:01.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:01.314] - Launch lazy future ...
[17:41:01.314] Packages needed by the future expression (n = 1): ‘stats’
[17:41:01.314] Packages needed by future strategies (n = 0): <none>
[17:41:01.315] {
[17:41:01.315]     {
[17:41:01.315]         {
[17:41:01.315]             ...future.startTime <- base::Sys.time()
[17:41:01.315]             {
[17:41:01.315]                 {
[17:41:01.315]                   {
[17:41:01.315]                     {
[17:41:01.315]                       {
[17:41:01.315]                         base::local({
[17:41:01.315]                           has_future <- base::requireNamespace("future", 
[17:41:01.315]                             quietly = TRUE)
[17:41:01.315]                           if (has_future) {
[17:41:01.315]                             ns <- base::getNamespace("future")
[17:41:01.315]                             version <- ns[[".package"]][["version"]]
[17:41:01.315]                             if (is.null(version)) 
[17:41:01.315]                               version <- utils::packageVersion("future")
[17:41:01.315]                           }
[17:41:01.315]                           else {
[17:41:01.315]                             version <- NULL
[17:41:01.315]                           }
[17:41:01.315]                           if (!has_future || version < "1.8.0") {
[17:41:01.315]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:01.315]                               "", base::R.version$version.string), 
[17:41:01.315]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:01.315]                                 base::R.version$platform, 8 * 
[17:41:01.315]                                   base::.Machine$sizeof.pointer), 
[17:41:01.315]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:01.315]                                 "release", "version")], collapse = " "), 
[17:41:01.315]                               hostname = base::Sys.info()[["nodename"]])
[17:41:01.315]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:01.315]                               info)
[17:41:01.315]                             info <- base::paste(info, collapse = "; ")
[17:41:01.315]                             if (!has_future) {
[17:41:01.315]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:01.315]                                 info)
[17:41:01.315]                             }
[17:41:01.315]                             else {
[17:41:01.315]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:01.315]                                 info, version)
[17:41:01.315]                             }
[17:41:01.315]                             base::stop(msg)
[17:41:01.315]                           }
[17:41:01.315]                         })
[17:41:01.315]                       }
[17:41:01.315]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:01.315]                       base::options(mc.cores = 1L)
[17:41:01.315]                     }
[17:41:01.315]                     base::local({
[17:41:01.315]                       for (pkg in "stats") {
[17:41:01.315]                         base::loadNamespace(pkg)
[17:41:01.315]                         base::library(pkg, character.only = TRUE)
[17:41:01.315]                       }
[17:41:01.315]                     })
[17:41:01.315]                   }
[17:41:01.315]                   options(future.plan = NULL)
[17:41:01.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:01.315]                 }
[17:41:01.315]                 ...future.workdir <- getwd()
[17:41:01.315]             }
[17:41:01.315]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:01.315]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:01.315]         }
[17:41:01.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:01.315]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:41:01.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:01.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:01.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:01.315]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:01.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:01.315]             base::names(...future.oldOptions))
[17:41:01.315]     }
[17:41:01.315]     if (FALSE) {
[17:41:01.315]     }
[17:41:01.315]     else {
[17:41:01.315]         if (TRUE) {
[17:41:01.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:01.315]                 open = "w")
[17:41:01.315]         }
[17:41:01.315]         else {
[17:41:01.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:01.315]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:01.315]         }
[17:41:01.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:01.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:01.315]             base::sink(type = "output", split = FALSE)
[17:41:01.315]             base::close(...future.stdout)
[17:41:01.315]         }, add = TRUE)
[17:41:01.315]     }
[17:41:01.315]     ...future.frame <- base::sys.nframe()
[17:41:01.315]     ...future.conditions <- base::list()
[17:41:01.315]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:01.315]     if (FALSE) {
[17:41:01.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:01.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:01.315]     }
[17:41:01.315]     ...future.result <- base::tryCatch({
[17:41:01.315]         base::withCallingHandlers({
[17:41:01.315]             ...future.value <- base::withVisible(base::local({
[17:41:01.315]                 ...future.makeSendCondition <- local({
[17:41:01.315]                   sendCondition <- NULL
[17:41:01.315]                   function(frame = 1L) {
[17:41:01.315]                     if (is.function(sendCondition)) 
[17:41:01.315]                       return(sendCondition)
[17:41:01.315]                     ns <- getNamespace("parallel")
[17:41:01.315]                     if (exists("sendData", mode = "function", 
[17:41:01.315]                       envir = ns)) {
[17:41:01.315]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:01.315]                         envir = ns)
[17:41:01.315]                       envir <- sys.frame(frame)
[17:41:01.315]                       master <- NULL
[17:41:01.315]                       while (!identical(envir, .GlobalEnv) && 
[17:41:01.315]                         !identical(envir, emptyenv())) {
[17:41:01.315]                         if (exists("master", mode = "list", envir = envir, 
[17:41:01.315]                           inherits = FALSE)) {
[17:41:01.315]                           master <- get("master", mode = "list", 
[17:41:01.315]                             envir = envir, inherits = FALSE)
[17:41:01.315]                           if (inherits(master, c("SOCKnode", 
[17:41:01.315]                             "SOCK0node"))) {
[17:41:01.315]                             sendCondition <<- function(cond) {
[17:41:01.315]                               data <- list(type = "VALUE", value = cond, 
[17:41:01.315]                                 success = TRUE)
[17:41:01.315]                               parallel_sendData(master, data)
[17:41:01.315]                             }
[17:41:01.315]                             return(sendCondition)
[17:41:01.315]                           }
[17:41:01.315]                         }
[17:41:01.315]                         frame <- frame + 1L
[17:41:01.315]                         envir <- sys.frame(frame)
[17:41:01.315]                       }
[17:41:01.315]                     }
[17:41:01.315]                     sendCondition <<- function(cond) NULL
[17:41:01.315]                   }
[17:41:01.315]                 })
[17:41:01.315]                 withCallingHandlers({
[17:41:01.315]                   {
[17:41:01.315]                     do.call(function(...) {
[17:41:01.315]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.315]                       if (!identical(...future.globals.maxSize.org, 
[17:41:01.315]                         ...future.globals.maxSize)) {
[17:41:01.315]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.315]                         on.exit(options(oopts), add = TRUE)
[17:41:01.315]                       }
[17:41:01.315]                       {
[17:41:01.315]                         lapply(seq_along(...future.elements_ii), 
[17:41:01.315]                           FUN = function(jj) {
[17:41:01.315]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.315]                             ...future.FUN(...future.X_jj, ...)
[17:41:01.315]                           })
[17:41:01.315]                       }
[17:41:01.315]                     }, args = future.call.arguments)
[17:41:01.315]                   }
[17:41:01.315]                 }, immediateCondition = function(cond) {
[17:41:01.315]                   sendCondition <- ...future.makeSendCondition()
[17:41:01.315]                   sendCondition(cond)
[17:41:01.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.315]                   {
[17:41:01.315]                     inherits <- base::inherits
[17:41:01.315]                     invokeRestart <- base::invokeRestart
[17:41:01.315]                     is.null <- base::is.null
[17:41:01.315]                     muffled <- FALSE
[17:41:01.315]                     if (inherits(cond, "message")) {
[17:41:01.315]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:01.315]                       if (muffled) 
[17:41:01.315]                         invokeRestart("muffleMessage")
[17:41:01.315]                     }
[17:41:01.315]                     else if (inherits(cond, "warning")) {
[17:41:01.315]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:01.315]                       if (muffled) 
[17:41:01.315]                         invokeRestart("muffleWarning")
[17:41:01.315]                     }
[17:41:01.315]                     else if (inherits(cond, "condition")) {
[17:41:01.315]                       if (!is.null(pattern)) {
[17:41:01.315]                         computeRestarts <- base::computeRestarts
[17:41:01.315]                         grepl <- base::grepl
[17:41:01.315]                         restarts <- computeRestarts(cond)
[17:41:01.315]                         for (restart in restarts) {
[17:41:01.315]                           name <- restart$name
[17:41:01.315]                           if (is.null(name)) 
[17:41:01.315]                             next
[17:41:01.315]                           if (!grepl(pattern, name)) 
[17:41:01.315]                             next
[17:41:01.315]                           invokeRestart(restart)
[17:41:01.315]                           muffled <- TRUE
[17:41:01.315]                           break
[17:41:01.315]                         }
[17:41:01.315]                       }
[17:41:01.315]                     }
[17:41:01.315]                     invisible(muffled)
[17:41:01.315]                   }
[17:41:01.315]                   muffleCondition(cond)
[17:41:01.315]                 })
[17:41:01.315]             }))
[17:41:01.315]             future::FutureResult(value = ...future.value$value, 
[17:41:01.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.315]                   ...future.rng), globalenv = if (FALSE) 
[17:41:01.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:01.315]                     ...future.globalenv.names))
[17:41:01.315]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:01.315]         }, condition = base::local({
[17:41:01.315]             c <- base::c
[17:41:01.315]             inherits <- base::inherits
[17:41:01.315]             invokeRestart <- base::invokeRestart
[17:41:01.315]             length <- base::length
[17:41:01.315]             list <- base::list
[17:41:01.315]             seq.int <- base::seq.int
[17:41:01.315]             signalCondition <- base::signalCondition
[17:41:01.315]             sys.calls <- base::sys.calls
[17:41:01.315]             `[[` <- base::`[[`
[17:41:01.315]             `+` <- base::`+`
[17:41:01.315]             `<<-` <- base::`<<-`
[17:41:01.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:01.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:01.315]                   3L)]
[17:41:01.315]             }
[17:41:01.315]             function(cond) {
[17:41:01.315]                 is_error <- inherits(cond, "error")
[17:41:01.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:01.315]                   NULL)
[17:41:01.315]                 if (is_error) {
[17:41:01.315]                   sessionInformation <- function() {
[17:41:01.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:01.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:01.315]                       search = base::search(), system = base::Sys.info())
[17:41:01.315]                   }
[17:41:01.315]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:01.315]                     cond$call), session = sessionInformation(), 
[17:41:01.315]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:01.315]                   signalCondition(cond)
[17:41:01.315]                 }
[17:41:01.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:01.315]                 "immediateCondition"))) {
[17:41:01.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:01.315]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:01.315]                   if (TRUE && !signal) {
[17:41:01.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.315]                     {
[17:41:01.315]                       inherits <- base::inherits
[17:41:01.315]                       invokeRestart <- base::invokeRestart
[17:41:01.315]                       is.null <- base::is.null
[17:41:01.315]                       muffled <- FALSE
[17:41:01.315]                       if (inherits(cond, "message")) {
[17:41:01.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.315]                         if (muffled) 
[17:41:01.315]                           invokeRestart("muffleMessage")
[17:41:01.315]                       }
[17:41:01.315]                       else if (inherits(cond, "warning")) {
[17:41:01.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.315]                         if (muffled) 
[17:41:01.315]                           invokeRestart("muffleWarning")
[17:41:01.315]                       }
[17:41:01.315]                       else if (inherits(cond, "condition")) {
[17:41:01.315]                         if (!is.null(pattern)) {
[17:41:01.315]                           computeRestarts <- base::computeRestarts
[17:41:01.315]                           grepl <- base::grepl
[17:41:01.315]                           restarts <- computeRestarts(cond)
[17:41:01.315]                           for (restart in restarts) {
[17:41:01.315]                             name <- restart$name
[17:41:01.315]                             if (is.null(name)) 
[17:41:01.315]                               next
[17:41:01.315]                             if (!grepl(pattern, name)) 
[17:41:01.315]                               next
[17:41:01.315]                             invokeRestart(restart)
[17:41:01.315]                             muffled <- TRUE
[17:41:01.315]                             break
[17:41:01.315]                           }
[17:41:01.315]                         }
[17:41:01.315]                       }
[17:41:01.315]                       invisible(muffled)
[17:41:01.315]                     }
[17:41:01.315]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.315]                   }
[17:41:01.315]                 }
[17:41:01.315]                 else {
[17:41:01.315]                   if (TRUE) {
[17:41:01.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.315]                     {
[17:41:01.315]                       inherits <- base::inherits
[17:41:01.315]                       invokeRestart <- base::invokeRestart
[17:41:01.315]                       is.null <- base::is.null
[17:41:01.315]                       muffled <- FALSE
[17:41:01.315]                       if (inherits(cond, "message")) {
[17:41:01.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.315]                         if (muffled) 
[17:41:01.315]                           invokeRestart("muffleMessage")
[17:41:01.315]                       }
[17:41:01.315]                       else if (inherits(cond, "warning")) {
[17:41:01.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.315]                         if (muffled) 
[17:41:01.315]                           invokeRestart("muffleWarning")
[17:41:01.315]                       }
[17:41:01.315]                       else if (inherits(cond, "condition")) {
[17:41:01.315]                         if (!is.null(pattern)) {
[17:41:01.315]                           computeRestarts <- base::computeRestarts
[17:41:01.315]                           grepl <- base::grepl
[17:41:01.315]                           restarts <- computeRestarts(cond)
[17:41:01.315]                           for (restart in restarts) {
[17:41:01.315]                             name <- restart$name
[17:41:01.315]                             if (is.null(name)) 
[17:41:01.315]                               next
[17:41:01.315]                             if (!grepl(pattern, name)) 
[17:41:01.315]                               next
[17:41:01.315]                             invokeRestart(restart)
[17:41:01.315]                             muffled <- TRUE
[17:41:01.315]                             break
[17:41:01.315]                           }
[17:41:01.315]                         }
[17:41:01.315]                       }
[17:41:01.315]                       invisible(muffled)
[17:41:01.315]                     }
[17:41:01.315]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.315]                   }
[17:41:01.315]                 }
[17:41:01.315]             }
[17:41:01.315]         }))
[17:41:01.315]     }, error = function(ex) {
[17:41:01.315]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:01.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.315]                 ...future.rng), started = ...future.startTime, 
[17:41:01.315]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:01.315]             version = "1.8"), class = "FutureResult")
[17:41:01.315]     }, finally = {
[17:41:01.315]         if (!identical(...future.workdir, getwd())) 
[17:41:01.315]             setwd(...future.workdir)
[17:41:01.315]         {
[17:41:01.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:01.315]                 ...future.oldOptions$nwarnings <- NULL
[17:41:01.315]             }
[17:41:01.315]             base::options(...future.oldOptions)
[17:41:01.315]             if (.Platform$OS.type == "windows") {
[17:41:01.315]                 old_names <- names(...future.oldEnvVars)
[17:41:01.315]                 envs <- base::Sys.getenv()
[17:41:01.315]                 names <- names(envs)
[17:41:01.315]                 common <- intersect(names, old_names)
[17:41:01.315]                 added <- setdiff(names, old_names)
[17:41:01.315]                 removed <- setdiff(old_names, names)
[17:41:01.315]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:01.315]                   envs[common]]
[17:41:01.315]                 NAMES <- toupper(changed)
[17:41:01.315]                 args <- list()
[17:41:01.315]                 for (kk in seq_along(NAMES)) {
[17:41:01.315]                   name <- changed[[kk]]
[17:41:01.315]                   NAME <- NAMES[[kk]]
[17:41:01.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.315]                     next
[17:41:01.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.315]                 }
[17:41:01.315]                 NAMES <- toupper(added)
[17:41:01.315]                 for (kk in seq_along(NAMES)) {
[17:41:01.315]                   name <- added[[kk]]
[17:41:01.315]                   NAME <- NAMES[[kk]]
[17:41:01.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.315]                     next
[17:41:01.315]                   args[[name]] <- ""
[17:41:01.315]                 }
[17:41:01.315]                 NAMES <- toupper(removed)
[17:41:01.315]                 for (kk in seq_along(NAMES)) {
[17:41:01.315]                   name <- removed[[kk]]
[17:41:01.315]                   NAME <- NAMES[[kk]]
[17:41:01.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.315]                     next
[17:41:01.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.315]                 }
[17:41:01.315]                 if (length(args) > 0) 
[17:41:01.315]                   base::do.call(base::Sys.setenv, args = args)
[17:41:01.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:01.315]             }
[17:41:01.315]             else {
[17:41:01.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:01.315]             }
[17:41:01.315]             {
[17:41:01.315]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:01.315]                   0L) {
[17:41:01.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:01.315]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:01.315]                   base::options(opts)
[17:41:01.315]                 }
[17:41:01.315]                 {
[17:41:01.315]                   {
[17:41:01.315]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:01.315]                     NULL
[17:41:01.315]                   }
[17:41:01.315]                   options(future.plan = NULL)
[17:41:01.315]                   if (is.na(NA_character_)) 
[17:41:01.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:01.315]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:01.315]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:01.315]                     envir = parent.frame()) 
[17:41:01.315]                   {
[17:41:01.315]                     if (is.function(workers)) 
[17:41:01.315]                       workers <- workers()
[17:41:01.315]                     workers <- structure(as.integer(workers), 
[17:41:01.315]                       class = class(workers))
[17:41:01.315]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:01.315]                       workers >= 1)
[17:41:01.315]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:01.315]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:01.315]                     }
[17:41:01.315]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:01.315]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:01.315]                       envir = envir)
[17:41:01.315]                     if (!future$lazy) 
[17:41:01.315]                       future <- run(future)
[17:41:01.315]                     invisible(future)
[17:41:01.315]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:01.315]                 }
[17:41:01.315]             }
[17:41:01.315]         }
[17:41:01.315]     })
[17:41:01.315]     if (TRUE) {
[17:41:01.315]         base::sink(type = "output", split = FALSE)
[17:41:01.315]         if (TRUE) {
[17:41:01.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:01.315]         }
[17:41:01.315]         else {
[17:41:01.315]             ...future.result["stdout"] <- base::list(NULL)
[17:41:01.315]         }
[17:41:01.315]         base::close(...future.stdout)
[17:41:01.315]         ...future.stdout <- NULL
[17:41:01.315]     }
[17:41:01.315]     ...future.result$conditions <- ...future.conditions
[17:41:01.315]     ...future.result$finished <- base::Sys.time()
[17:41:01.315]     ...future.result
[17:41:01.315] }
[17:41:01.318] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[17:41:01.318] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[17:41:01.359] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:41:01.359] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:01.360] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.360] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:41:01.360] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:41:01.360] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:01.361] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.361] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:01.361] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.361] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[17:41:01.362] MultisessionFuture started
[17:41:01.362] - Launch lazy future ... done
[17:41:01.362] run() for ‘MultisessionFuture’ ... done
[17:41:01.362] Created future:
[17:41:01.362] MultisessionFuture:
[17:41:01.362] Label: ‘future_sapply-2’
[17:41:01.362] Expression:
[17:41:01.362] {
[17:41:01.362]     do.call(function(...) {
[17:41:01.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.362]             on.exit(options(oopts), add = TRUE)
[17:41:01.362]         }
[17:41:01.362]         {
[17:41:01.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.362]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.362]             })
[17:41:01.362]         }
[17:41:01.362]     }, args = future.call.arguments)
[17:41:01.362] }
[17:41:01.362] Lazy evaluation: FALSE
[17:41:01.362] Asynchronous evaluation: TRUE
[17:41:01.362] Local evaluation: TRUE
[17:41:01.362] Environment: R_GlobalEnv
[17:41:01.362] Capture standard output: TRUE
[17:41:01.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:01.362] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:01.362] Packages: 1 packages (‘stats’)
[17:41:01.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:01.362] Resolved: FALSE
[17:41:01.362] Value: <not collected>
[17:41:01.362] Conditions captured: <none>
[17:41:01.362] Early signaling: FALSE
[17:41:01.362] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:01.362] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.374] Chunk #2 of 2 ... DONE
[17:41:01.374] Launching 2 futures (chunks) ... DONE
[17:41:01.374] Resolving 2 futures (chunks) ...
[17:41:01.374] resolve() on list ...
[17:41:01.375]  recursive: 0
[17:41:01.375]  length: 2
[17:41:01.375] 
[17:41:01.375] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.375] - Validating connection of MultisessionFuture
[17:41:01.375] - received message: FutureResult
[17:41:01.376] - Received FutureResult
[17:41:01.376] - Erased future from FutureRegistry
[17:41:01.376] result() for ClusterFuture ...
[17:41:01.376] - result already collected: FutureResult
[17:41:01.376] result() for ClusterFuture ... done
[17:41:01.376] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.376] Future #1
[17:41:01.376] result() for ClusterFuture ...
[17:41:01.376] - result already collected: FutureResult
[17:41:01.376] result() for ClusterFuture ... done
[17:41:01.376] result() for ClusterFuture ...
[17:41:01.377] - result already collected: FutureResult
[17:41:01.377] result() for ClusterFuture ... done
[17:41:01.377] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:01.377] - nx: 2
[17:41:01.377] - relay: TRUE
[17:41:01.377] - stdout: TRUE
[17:41:01.377] - signal: TRUE
[17:41:01.377] - resignal: FALSE
[17:41:01.377] - force: TRUE
[17:41:01.377] - relayed: [n=2] FALSE, FALSE
[17:41:01.377] - queued futures: [n=2] FALSE, FALSE
[17:41:01.378]  - until=1
[17:41:01.378]  - relaying element #1
[17:41:01.378] result() for ClusterFuture ...
[17:41:01.378] - result already collected: FutureResult
[17:41:01.378] result() for ClusterFuture ... done
[17:41:01.378] result() for ClusterFuture ...
[17:41:01.378] - result already collected: FutureResult
[17:41:01.378] result() for ClusterFuture ... done
[17:41:01.378] result() for ClusterFuture ...
[17:41:01.378] - result already collected: FutureResult
[17:41:01.378] result() for ClusterFuture ... done
[17:41:01.379] result() for ClusterFuture ...
[17:41:01.379] - result already collected: FutureResult
[17:41:01.379] result() for ClusterFuture ... done
[17:41:01.379] - relayed: [n=2] TRUE, FALSE
[17:41:01.379] - queued futures: [n=2] TRUE, FALSE
[17:41:01.379] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:01.379]  length: 1 (resolved future 1)
[17:41:01.408] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.408] - Validating connection of MultisessionFuture
[17:41:01.408] - received message: FutureResult
[17:41:01.408] - Received FutureResult
[17:41:01.409] - Erased future from FutureRegistry
[17:41:01.409] result() for ClusterFuture ...
[17:41:01.409] - result already collected: FutureResult
[17:41:01.409] result() for ClusterFuture ... done
[17:41:01.409] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.409] Future #2
[17:41:01.409] result() for ClusterFuture ...
[17:41:01.409] - result already collected: FutureResult
[17:41:01.409] result() for ClusterFuture ... done
[17:41:01.409] result() for ClusterFuture ...
[17:41:01.409] - result already collected: FutureResult
[17:41:01.410] result() for ClusterFuture ... done
[17:41:01.410] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:01.410] - nx: 2
[17:41:01.410] - relay: TRUE
[17:41:01.410] - stdout: TRUE
[17:41:01.410] - signal: TRUE
[17:41:01.410] - resignal: FALSE
[17:41:01.410] - force: TRUE
[17:41:01.410] - relayed: [n=2] TRUE, FALSE
[17:41:01.410] - queued futures: [n=2] TRUE, FALSE
[17:41:01.410]  - until=2
[17:41:01.411]  - relaying element #2
[17:41:01.411] result() for ClusterFuture ...
[17:41:01.411] - result already collected: FutureResult
[17:41:01.411] result() for ClusterFuture ... done
[17:41:01.411] result() for ClusterFuture ...
[17:41:01.411] - result already collected: FutureResult
[17:41:01.411] result() for ClusterFuture ... done
[17:41:01.411] result() for ClusterFuture ...
[17:41:01.411] - result already collected: FutureResult
[17:41:01.411] result() for ClusterFuture ... done
[17:41:01.411] result() for ClusterFuture ...
[17:41:01.412] - result already collected: FutureResult
[17:41:01.412] result() for ClusterFuture ... done
[17:41:01.412] - relayed: [n=2] TRUE, TRUE
[17:41:01.412] - queued futures: [n=2] TRUE, TRUE
[17:41:01.412] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:01.412]  length: 0 (resolved future 2)
[17:41:01.412] Relaying remaining futures
[17:41:01.412] signalConditionsASAP(NULL, pos=0) ...
[17:41:01.412] - nx: 2
[17:41:01.412] - relay: TRUE
[17:41:01.412] - stdout: TRUE
[17:41:01.413] - signal: TRUE
[17:41:01.413] - resignal: FALSE
[17:41:01.413] - force: TRUE
[17:41:01.413] - relayed: [n=2] TRUE, TRUE
[17:41:01.413] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:01.413] - relayed: [n=2] TRUE, TRUE
[17:41:01.413] - queued futures: [n=2] TRUE, TRUE
[17:41:01.413] signalConditionsASAP(NULL, pos=0) ... done
[17:41:01.413] resolve() on list ... DONE
[17:41:01.413] result() for ClusterFuture ...
[17:41:01.413] - result already collected: FutureResult
[17:41:01.413] result() for ClusterFuture ... done
[17:41:01.414] result() for ClusterFuture ...
[17:41:01.414] - result already collected: FutureResult
[17:41:01.414] result() for ClusterFuture ... done
[17:41:01.414] result() for ClusterFuture ...
[17:41:01.414] - result already collected: FutureResult
[17:41:01.414] result() for ClusterFuture ... done
[17:41:01.414] result() for ClusterFuture ...
[17:41:01.414] - result already collected: FutureResult
[17:41:01.414] result() for ClusterFuture ... done
[17:41:01.414]  - Number of value chunks collected: 2
[17:41:01.415] Resolving 2 futures (chunks) ... DONE
[17:41:01.415] Reducing values from 2 chunks ...
[17:41:01.415]  - Number of values collected after concatenation: 7
[17:41:01.415]  - Number of values expected: 7
[17:41:01.415] Reducing values from 2 chunks ... DONE
[17:41:01.415] future_lapply() ... DONE
[17:41:01.415] future_lapply() ...
[17:41:01.421] Number of chunks: 2
[17:41:01.421] getGlobalsAndPackagesXApply() ...
[17:41:01.421]  - future.globals: TRUE
[17:41:01.421] getGlobalsAndPackages() ...
[17:41:01.421] Searching for globals...
[17:41:01.428] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:41:01.428] Searching for globals ... DONE
[17:41:01.428] Resolving globals: FALSE
[17:41:01.430] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:41:01.430] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:41:01.430] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:01.430] - packages: [2] ‘stats’, ‘future.apply’
[17:41:01.430] getGlobalsAndPackages() ... DONE
[17:41:01.430]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:01.431]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:41:01.431] Finding globals ... DONE
[17:41:01.431]  - use_args: TRUE
[17:41:01.431]  - Getting '...' globals ...
[17:41:01.431] resolve() on list ...
[17:41:01.431]  recursive: 0
[17:41:01.431]  length: 1
[17:41:01.431]  elements: ‘...’
[17:41:01.432]  length: 0 (resolved future 1)
[17:41:01.432] resolve() on list ... DONE
[17:41:01.432]    - '...' content: [n=0] 
[17:41:01.432] List of 1
[17:41:01.432]  $ ...: list()
[17:41:01.432]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:01.432]  - attr(*, "where")=List of 1
[17:41:01.432]   ..$ ...:<environment: 0x564f30d4dc68> 
[17:41:01.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:01.432]  - attr(*, "resolved")= logi TRUE
[17:41:01.432]  - attr(*, "total_size")= num NA
[17:41:01.434]  - Getting '...' globals ... DONE
[17:41:01.435] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:01.435] List of 8
[17:41:01.435]  $ ...future.FUN:function (x, ...)  
[17:41:01.435]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:41:01.435]  $ times        : int 5
[17:41:01.435]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:01.435]  $ stop_if_not  :function (...)  
[17:41:01.435]  $ dim          : NULL
[17:41:01.435]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:41:01.435]  $ ...          : list()
[17:41:01.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:01.435]  - attr(*, "where")=List of 8
[17:41:01.435]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:01.435]   ..$ ...          :<environment: 0x564f30d4dc68> 
[17:41:01.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:01.435]  - attr(*, "resolved")= logi FALSE
[17:41:01.435]  - attr(*, "total_size")= num 141240
[17:41:01.442] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:41:01.443] getGlobalsAndPackagesXApply() ... DONE
[17:41:01.443] Number of futures (= number of chunks): 2
[17:41:01.443] Launching 2 futures (chunks) ...
[17:41:01.443] Chunk #1 of 2 ...
[17:41:01.443]  - Finding globals in 'X' for chunk #1 ...
[17:41:01.443] getGlobalsAndPackages() ...
[17:41:01.444] Searching for globals...
[17:41:01.444] 
[17:41:01.444] Searching for globals ... DONE
[17:41:01.444] - globals: [0] <none>
[17:41:01.444] getGlobalsAndPackages() ... DONE
[17:41:01.444]    + additional globals found: [n=0] 
[17:41:01.444]    + additional namespaces needed: [n=0] 
[17:41:01.444]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:01.444]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[17:41:01.444]  - seeds: <none>
[17:41:01.445] getGlobalsAndPackages() ...
[17:41:01.445] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.445] Resolving globals: FALSE
[17:41:01.445] Tweak future expression to call with '...' arguments ...
[17:41:01.445] {
[17:41:01.445]     do.call(function(...) {
[17:41:01.445]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.445]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.445]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.445]             on.exit(options(oopts), add = TRUE)
[17:41:01.445]         }
[17:41:01.445]         {
[17:41:01.445]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.445]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.445]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.445]             })
[17:41:01.445]         }
[17:41:01.445]     }, args = future.call.arguments)
[17:41:01.445] }
[17:41:01.445] Tweak future expression to call with '...' arguments ... DONE
[17:41:01.446] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.446] - packages: [2] ‘stats’, ‘future.apply’
[17:41:01.446] getGlobalsAndPackages() ... DONE
[17:41:01.446] run() for ‘Future’ ...
[17:41:01.446] - state: ‘created’
[17:41:01.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:01.461] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:01.462]   - Field: ‘node’
[17:41:01.462]   - Field: ‘label’
[17:41:01.462]   - Field: ‘local’
[17:41:01.462]   - Field: ‘owner’
[17:41:01.462]   - Field: ‘envir’
[17:41:01.462]   - Field: ‘workers’
[17:41:01.462]   - Field: ‘packages’
[17:41:01.462]   - Field: ‘gc’
[17:41:01.462]   - Field: ‘conditions’
[17:41:01.463]   - Field: ‘persistent’
[17:41:01.463]   - Field: ‘expr’
[17:41:01.463]   - Field: ‘uuid’
[17:41:01.463]   - Field: ‘seed’
[17:41:01.463]   - Field: ‘version’
[17:41:01.463]   - Field: ‘result’
[17:41:01.463]   - Field: ‘asynchronous’
[17:41:01.463]   - Field: ‘calls’
[17:41:01.463]   - Field: ‘globals’
[17:41:01.463]   - Field: ‘stdout’
[17:41:01.463]   - Field: ‘earlySignal’
[17:41:01.464]   - Field: ‘lazy’
[17:41:01.464]   - Field: ‘state’
[17:41:01.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:01.464] - Launch lazy future ...
[17:41:01.464] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:41:01.464] Packages needed by future strategies (n = 0): <none>
[17:41:01.465] {
[17:41:01.465]     {
[17:41:01.465]         {
[17:41:01.465]             ...future.startTime <- base::Sys.time()
[17:41:01.465]             {
[17:41:01.465]                 {
[17:41:01.465]                   {
[17:41:01.465]                     {
[17:41:01.465]                       {
[17:41:01.465]                         base::local({
[17:41:01.465]                           has_future <- base::requireNamespace("future", 
[17:41:01.465]                             quietly = TRUE)
[17:41:01.465]                           if (has_future) {
[17:41:01.465]                             ns <- base::getNamespace("future")
[17:41:01.465]                             version <- ns[[".package"]][["version"]]
[17:41:01.465]                             if (is.null(version)) 
[17:41:01.465]                               version <- utils::packageVersion("future")
[17:41:01.465]                           }
[17:41:01.465]                           else {
[17:41:01.465]                             version <- NULL
[17:41:01.465]                           }
[17:41:01.465]                           if (!has_future || version < "1.8.0") {
[17:41:01.465]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:01.465]                               "", base::R.version$version.string), 
[17:41:01.465]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:01.465]                                 base::R.version$platform, 8 * 
[17:41:01.465]                                   base::.Machine$sizeof.pointer), 
[17:41:01.465]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:01.465]                                 "release", "version")], collapse = " "), 
[17:41:01.465]                               hostname = base::Sys.info()[["nodename"]])
[17:41:01.465]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:01.465]                               info)
[17:41:01.465]                             info <- base::paste(info, collapse = "; ")
[17:41:01.465]                             if (!has_future) {
[17:41:01.465]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:01.465]                                 info)
[17:41:01.465]                             }
[17:41:01.465]                             else {
[17:41:01.465]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:01.465]                                 info, version)
[17:41:01.465]                             }
[17:41:01.465]                             base::stop(msg)
[17:41:01.465]                           }
[17:41:01.465]                         })
[17:41:01.465]                       }
[17:41:01.465]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:01.465]                       base::options(mc.cores = 1L)
[17:41:01.465]                     }
[17:41:01.465]                     base::local({
[17:41:01.465]                       for (pkg in c("stats", "future.apply")) {
[17:41:01.465]                         base::loadNamespace(pkg)
[17:41:01.465]                         base::library(pkg, character.only = TRUE)
[17:41:01.465]                       }
[17:41:01.465]                     })
[17:41:01.465]                   }
[17:41:01.465]                   options(future.plan = NULL)
[17:41:01.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:01.465]                 }
[17:41:01.465]                 ...future.workdir <- getwd()
[17:41:01.465]             }
[17:41:01.465]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:01.465]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:01.465]         }
[17:41:01.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:01.465]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[17:41:01.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:01.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:01.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:01.465]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:01.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:01.465]             base::names(...future.oldOptions))
[17:41:01.465]     }
[17:41:01.465]     if (FALSE) {
[17:41:01.465]     }
[17:41:01.465]     else {
[17:41:01.465]         if (TRUE) {
[17:41:01.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:01.465]                 open = "w")
[17:41:01.465]         }
[17:41:01.465]         else {
[17:41:01.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:01.465]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:01.465]         }
[17:41:01.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:01.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:01.465]             base::sink(type = "output", split = FALSE)
[17:41:01.465]             base::close(...future.stdout)
[17:41:01.465]         }, add = TRUE)
[17:41:01.465]     }
[17:41:01.465]     ...future.frame <- base::sys.nframe()
[17:41:01.465]     ...future.conditions <- base::list()
[17:41:01.465]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:01.465]     if (FALSE) {
[17:41:01.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:01.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:01.465]     }
[17:41:01.465]     ...future.result <- base::tryCatch({
[17:41:01.465]         base::withCallingHandlers({
[17:41:01.465]             ...future.value <- base::withVisible(base::local({
[17:41:01.465]                 ...future.makeSendCondition <- local({
[17:41:01.465]                   sendCondition <- NULL
[17:41:01.465]                   function(frame = 1L) {
[17:41:01.465]                     if (is.function(sendCondition)) 
[17:41:01.465]                       return(sendCondition)
[17:41:01.465]                     ns <- getNamespace("parallel")
[17:41:01.465]                     if (exists("sendData", mode = "function", 
[17:41:01.465]                       envir = ns)) {
[17:41:01.465]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:01.465]                         envir = ns)
[17:41:01.465]                       envir <- sys.frame(frame)
[17:41:01.465]                       master <- NULL
[17:41:01.465]                       while (!identical(envir, .GlobalEnv) && 
[17:41:01.465]                         !identical(envir, emptyenv())) {
[17:41:01.465]                         if (exists("master", mode = "list", envir = envir, 
[17:41:01.465]                           inherits = FALSE)) {
[17:41:01.465]                           master <- get("master", mode = "list", 
[17:41:01.465]                             envir = envir, inherits = FALSE)
[17:41:01.465]                           if (inherits(master, c("SOCKnode", 
[17:41:01.465]                             "SOCK0node"))) {
[17:41:01.465]                             sendCondition <<- function(cond) {
[17:41:01.465]                               data <- list(type = "VALUE", value = cond, 
[17:41:01.465]                                 success = TRUE)
[17:41:01.465]                               parallel_sendData(master, data)
[17:41:01.465]                             }
[17:41:01.465]                             return(sendCondition)
[17:41:01.465]                           }
[17:41:01.465]                         }
[17:41:01.465]                         frame <- frame + 1L
[17:41:01.465]                         envir <- sys.frame(frame)
[17:41:01.465]                       }
[17:41:01.465]                     }
[17:41:01.465]                     sendCondition <<- function(cond) NULL
[17:41:01.465]                   }
[17:41:01.465]                 })
[17:41:01.465]                 withCallingHandlers({
[17:41:01.465]                   {
[17:41:01.465]                     do.call(function(...) {
[17:41:01.465]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.465]                       if (!identical(...future.globals.maxSize.org, 
[17:41:01.465]                         ...future.globals.maxSize)) {
[17:41:01.465]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.465]                         on.exit(options(oopts), add = TRUE)
[17:41:01.465]                       }
[17:41:01.465]                       {
[17:41:01.465]                         lapply(seq_along(...future.elements_ii), 
[17:41:01.465]                           FUN = function(jj) {
[17:41:01.465]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.465]                             ...future.FUN(...future.X_jj, ...)
[17:41:01.465]                           })
[17:41:01.465]                       }
[17:41:01.465]                     }, args = future.call.arguments)
[17:41:01.465]                   }
[17:41:01.465]                 }, immediateCondition = function(cond) {
[17:41:01.465]                   sendCondition <- ...future.makeSendCondition()
[17:41:01.465]                   sendCondition(cond)
[17:41:01.465]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.465]                   {
[17:41:01.465]                     inherits <- base::inherits
[17:41:01.465]                     invokeRestart <- base::invokeRestart
[17:41:01.465]                     is.null <- base::is.null
[17:41:01.465]                     muffled <- FALSE
[17:41:01.465]                     if (inherits(cond, "message")) {
[17:41:01.465]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:01.465]                       if (muffled) 
[17:41:01.465]                         invokeRestart("muffleMessage")
[17:41:01.465]                     }
[17:41:01.465]                     else if (inherits(cond, "warning")) {
[17:41:01.465]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:01.465]                       if (muffled) 
[17:41:01.465]                         invokeRestart("muffleWarning")
[17:41:01.465]                     }
[17:41:01.465]                     else if (inherits(cond, "condition")) {
[17:41:01.465]                       if (!is.null(pattern)) {
[17:41:01.465]                         computeRestarts <- base::computeRestarts
[17:41:01.465]                         grepl <- base::grepl
[17:41:01.465]                         restarts <- computeRestarts(cond)
[17:41:01.465]                         for (restart in restarts) {
[17:41:01.465]                           name <- restart$name
[17:41:01.465]                           if (is.null(name)) 
[17:41:01.465]                             next
[17:41:01.465]                           if (!grepl(pattern, name)) 
[17:41:01.465]                             next
[17:41:01.465]                           invokeRestart(restart)
[17:41:01.465]                           muffled <- TRUE
[17:41:01.465]                           break
[17:41:01.465]                         }
[17:41:01.465]                       }
[17:41:01.465]                     }
[17:41:01.465]                     invisible(muffled)
[17:41:01.465]                   }
[17:41:01.465]                   muffleCondition(cond)
[17:41:01.465]                 })
[17:41:01.465]             }))
[17:41:01.465]             future::FutureResult(value = ...future.value$value, 
[17:41:01.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.465]                   ...future.rng), globalenv = if (FALSE) 
[17:41:01.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:01.465]                     ...future.globalenv.names))
[17:41:01.465]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:01.465]         }, condition = base::local({
[17:41:01.465]             c <- base::c
[17:41:01.465]             inherits <- base::inherits
[17:41:01.465]             invokeRestart <- base::invokeRestart
[17:41:01.465]             length <- base::length
[17:41:01.465]             list <- base::list
[17:41:01.465]             seq.int <- base::seq.int
[17:41:01.465]             signalCondition <- base::signalCondition
[17:41:01.465]             sys.calls <- base::sys.calls
[17:41:01.465]             `[[` <- base::`[[`
[17:41:01.465]             `+` <- base::`+`
[17:41:01.465]             `<<-` <- base::`<<-`
[17:41:01.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:01.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:01.465]                   3L)]
[17:41:01.465]             }
[17:41:01.465]             function(cond) {
[17:41:01.465]                 is_error <- inherits(cond, "error")
[17:41:01.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:01.465]                   NULL)
[17:41:01.465]                 if (is_error) {
[17:41:01.465]                   sessionInformation <- function() {
[17:41:01.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:01.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:01.465]                       search = base::search(), system = base::Sys.info())
[17:41:01.465]                   }
[17:41:01.465]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:01.465]                     cond$call), session = sessionInformation(), 
[17:41:01.465]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:01.465]                   signalCondition(cond)
[17:41:01.465]                 }
[17:41:01.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:01.465]                 "immediateCondition"))) {
[17:41:01.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:01.465]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:01.465]                   if (TRUE && !signal) {
[17:41:01.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.465]                     {
[17:41:01.465]                       inherits <- base::inherits
[17:41:01.465]                       invokeRestart <- base::invokeRestart
[17:41:01.465]                       is.null <- base::is.null
[17:41:01.465]                       muffled <- FALSE
[17:41:01.465]                       if (inherits(cond, "message")) {
[17:41:01.465]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.465]                         if (muffled) 
[17:41:01.465]                           invokeRestart("muffleMessage")
[17:41:01.465]                       }
[17:41:01.465]                       else if (inherits(cond, "warning")) {
[17:41:01.465]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.465]                         if (muffled) 
[17:41:01.465]                           invokeRestart("muffleWarning")
[17:41:01.465]                       }
[17:41:01.465]                       else if (inherits(cond, "condition")) {
[17:41:01.465]                         if (!is.null(pattern)) {
[17:41:01.465]                           computeRestarts <- base::computeRestarts
[17:41:01.465]                           grepl <- base::grepl
[17:41:01.465]                           restarts <- computeRestarts(cond)
[17:41:01.465]                           for (restart in restarts) {
[17:41:01.465]                             name <- restart$name
[17:41:01.465]                             if (is.null(name)) 
[17:41:01.465]                               next
[17:41:01.465]                             if (!grepl(pattern, name)) 
[17:41:01.465]                               next
[17:41:01.465]                             invokeRestart(restart)
[17:41:01.465]                             muffled <- TRUE
[17:41:01.465]                             break
[17:41:01.465]                           }
[17:41:01.465]                         }
[17:41:01.465]                       }
[17:41:01.465]                       invisible(muffled)
[17:41:01.465]                     }
[17:41:01.465]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.465]                   }
[17:41:01.465]                 }
[17:41:01.465]                 else {
[17:41:01.465]                   if (TRUE) {
[17:41:01.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.465]                     {
[17:41:01.465]                       inherits <- base::inherits
[17:41:01.465]                       invokeRestart <- base::invokeRestart
[17:41:01.465]                       is.null <- base::is.null
[17:41:01.465]                       muffled <- FALSE
[17:41:01.465]                       if (inherits(cond, "message")) {
[17:41:01.465]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.465]                         if (muffled) 
[17:41:01.465]                           invokeRestart("muffleMessage")
[17:41:01.465]                       }
[17:41:01.465]                       else if (inherits(cond, "warning")) {
[17:41:01.465]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.465]                         if (muffled) 
[17:41:01.465]                           invokeRestart("muffleWarning")
[17:41:01.465]                       }
[17:41:01.465]                       else if (inherits(cond, "condition")) {
[17:41:01.465]                         if (!is.null(pattern)) {
[17:41:01.465]                           computeRestarts <- base::computeRestarts
[17:41:01.465]                           grepl <- base::grepl
[17:41:01.465]                           restarts <- computeRestarts(cond)
[17:41:01.465]                           for (restart in restarts) {
[17:41:01.465]                             name <- restart$name
[17:41:01.465]                             if (is.null(name)) 
[17:41:01.465]                               next
[17:41:01.465]                             if (!grepl(pattern, name)) 
[17:41:01.465]                               next
[17:41:01.465]                             invokeRestart(restart)
[17:41:01.465]                             muffled <- TRUE
[17:41:01.465]                             break
[17:41:01.465]                           }
[17:41:01.465]                         }
[17:41:01.465]                       }
[17:41:01.465]                       invisible(muffled)
[17:41:01.465]                     }
[17:41:01.465]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.465]                   }
[17:41:01.465]                 }
[17:41:01.465]             }
[17:41:01.465]         }))
[17:41:01.465]     }, error = function(ex) {
[17:41:01.465]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:01.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.465]                 ...future.rng), started = ...future.startTime, 
[17:41:01.465]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:01.465]             version = "1.8"), class = "FutureResult")
[17:41:01.465]     }, finally = {
[17:41:01.465]         if (!identical(...future.workdir, getwd())) 
[17:41:01.465]             setwd(...future.workdir)
[17:41:01.465]         {
[17:41:01.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:01.465]                 ...future.oldOptions$nwarnings <- NULL
[17:41:01.465]             }
[17:41:01.465]             base::options(...future.oldOptions)
[17:41:01.465]             if (.Platform$OS.type == "windows") {
[17:41:01.465]                 old_names <- names(...future.oldEnvVars)
[17:41:01.465]                 envs <- base::Sys.getenv()
[17:41:01.465]                 names <- names(envs)
[17:41:01.465]                 common <- intersect(names, old_names)
[17:41:01.465]                 added <- setdiff(names, old_names)
[17:41:01.465]                 removed <- setdiff(old_names, names)
[17:41:01.465]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:01.465]                   envs[common]]
[17:41:01.465]                 NAMES <- toupper(changed)
[17:41:01.465]                 args <- list()
[17:41:01.465]                 for (kk in seq_along(NAMES)) {
[17:41:01.465]                   name <- changed[[kk]]
[17:41:01.465]                   NAME <- NAMES[[kk]]
[17:41:01.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.465]                     next
[17:41:01.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.465]                 }
[17:41:01.465]                 NAMES <- toupper(added)
[17:41:01.465]                 for (kk in seq_along(NAMES)) {
[17:41:01.465]                   name <- added[[kk]]
[17:41:01.465]                   NAME <- NAMES[[kk]]
[17:41:01.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.465]                     next
[17:41:01.465]                   args[[name]] <- ""
[17:41:01.465]                 }
[17:41:01.465]                 NAMES <- toupper(removed)
[17:41:01.465]                 for (kk in seq_along(NAMES)) {
[17:41:01.465]                   name <- removed[[kk]]
[17:41:01.465]                   NAME <- NAMES[[kk]]
[17:41:01.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.465]                     next
[17:41:01.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.465]                 }
[17:41:01.465]                 if (length(args) > 0) 
[17:41:01.465]                   base::do.call(base::Sys.setenv, args = args)
[17:41:01.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:01.465]             }
[17:41:01.465]             else {
[17:41:01.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:01.465]             }
[17:41:01.465]             {
[17:41:01.465]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:01.465]                   0L) {
[17:41:01.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:01.465]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:01.465]                   base::options(opts)
[17:41:01.465]                 }
[17:41:01.465]                 {
[17:41:01.465]                   {
[17:41:01.465]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:01.465]                     NULL
[17:41:01.465]                   }
[17:41:01.465]                   options(future.plan = NULL)
[17:41:01.465]                   if (is.na(NA_character_)) 
[17:41:01.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:01.465]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:01.465]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:01.465]                     envir = parent.frame()) 
[17:41:01.465]                   {
[17:41:01.465]                     if (is.function(workers)) 
[17:41:01.465]                       workers <- workers()
[17:41:01.465]                     workers <- structure(as.integer(workers), 
[17:41:01.465]                       class = class(workers))
[17:41:01.465]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:01.465]                       workers >= 1)
[17:41:01.465]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:01.465]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:01.465]                     }
[17:41:01.465]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:01.465]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:01.465]                       envir = envir)
[17:41:01.465]                     if (!future$lazy) 
[17:41:01.465]                       future <- run(future)
[17:41:01.465]                     invisible(future)
[17:41:01.465]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:01.465]                 }
[17:41:01.465]             }
[17:41:01.465]         }
[17:41:01.465]     })
[17:41:01.465]     if (TRUE) {
[17:41:01.465]         base::sink(type = "output", split = FALSE)
[17:41:01.465]         if (TRUE) {
[17:41:01.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:01.465]         }
[17:41:01.465]         else {
[17:41:01.465]             ...future.result["stdout"] <- base::list(NULL)
[17:41:01.465]         }
[17:41:01.465]         base::close(...future.stdout)
[17:41:01.465]         ...future.stdout <- NULL
[17:41:01.465]     }
[17:41:01.465]     ...future.result$conditions <- ...future.conditions
[17:41:01.465]     ...future.result$finished <- base::Sys.time()
[17:41:01.465]     ...future.result
[17:41:01.465] }
[17:41:01.468] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[17:41:01.468] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:01.511] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:01.511] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[17:41:01.555] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:41:01.555] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:01.556] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:01.556] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:01.599] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:01.599] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:01.643] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:01.643] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:41:01.644] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.644] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:41:01.645] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:41:01.645] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:01.645] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.646] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:41:01.646] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:41:01.646] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:01.646] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.646] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:01.647] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.647] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[17:41:01.647] MultisessionFuture started
[17:41:01.648] - Launch lazy future ... done
[17:41:01.648] run() for ‘MultisessionFuture’ ... done
[17:41:01.648] Created future:
[17:41:01.648] MultisessionFuture:
[17:41:01.648] Label: ‘future_vapply-1’
[17:41:01.648] Expression:
[17:41:01.648] {
[17:41:01.648]     do.call(function(...) {
[17:41:01.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.648]             on.exit(options(oopts), add = TRUE)
[17:41:01.648]         }
[17:41:01.648]         {
[17:41:01.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.648]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.648]             })
[17:41:01.648]         }
[17:41:01.648]     }, args = future.call.arguments)
[17:41:01.648] }
[17:41:01.648] Lazy evaluation: FALSE
[17:41:01.648] Asynchronous evaluation: TRUE
[17:41:01.648] Local evaluation: TRUE
[17:41:01.648] Environment: R_GlobalEnv
[17:41:01.648] Capture standard output: TRUE
[17:41:01.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:01.648] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:01.648] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:41:01.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:01.648] Resolved: FALSE
[17:41:01.648] Value: <not collected>
[17:41:01.648] Conditions captured: <none>
[17:41:01.648] Early signaling: FALSE
[17:41:01.648] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:01.648] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.660] Chunk #1 of 2 ... DONE
[17:41:01.660] Chunk #2 of 2 ...
[17:41:01.660]  - Finding globals in 'X' for chunk #2 ...
[17:41:01.660] getGlobalsAndPackages() ...
[17:41:01.660] Searching for globals...
[17:41:01.660] 
[17:41:01.661] Searching for globals ... DONE
[17:41:01.661] - globals: [0] <none>
[17:41:01.661] getGlobalsAndPackages() ... DONE
[17:41:01.661]    + additional globals found: [n=0] 
[17:41:01.661]    + additional namespaces needed: [n=0] 
[17:41:01.661]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:01.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:41:01.661]  - seeds: <none>
[17:41:01.661] getGlobalsAndPackages() ...
[17:41:01.661] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.662] Resolving globals: FALSE
[17:41:01.662] Tweak future expression to call with '...' arguments ...
[17:41:01.662] {
[17:41:01.662]     do.call(function(...) {
[17:41:01.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.662]             on.exit(options(oopts), add = TRUE)
[17:41:01.662]         }
[17:41:01.662]         {
[17:41:01.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.662]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.662]             })
[17:41:01.662]         }
[17:41:01.662]     }, args = future.call.arguments)
[17:41:01.662] }
[17:41:01.662] Tweak future expression to call with '...' arguments ... DONE
[17:41:01.663] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.663] - packages: [2] ‘stats’, ‘future.apply’
[17:41:01.663] getGlobalsAndPackages() ... DONE
[17:41:01.663] run() for ‘Future’ ...
[17:41:01.663] - state: ‘created’
[17:41:01.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:01.679] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:01.679]   - Field: ‘node’
[17:41:01.679]   - Field: ‘label’
[17:41:01.679]   - Field: ‘local’
[17:41:01.679]   - Field: ‘owner’
[17:41:01.679]   - Field: ‘envir’
[17:41:01.679]   - Field: ‘workers’
[17:41:01.680]   - Field: ‘packages’
[17:41:01.680]   - Field: ‘gc’
[17:41:01.680]   - Field: ‘conditions’
[17:41:01.680]   - Field: ‘persistent’
[17:41:01.680]   - Field: ‘expr’
[17:41:01.680]   - Field: ‘uuid’
[17:41:01.680]   - Field: ‘seed’
[17:41:01.680]   - Field: ‘version’
[17:41:01.680]   - Field: ‘result’
[17:41:01.680]   - Field: ‘asynchronous’
[17:41:01.680]   - Field: ‘calls’
[17:41:01.681]   - Field: ‘globals’
[17:41:01.681]   - Field: ‘stdout’
[17:41:01.681]   - Field: ‘earlySignal’
[17:41:01.681]   - Field: ‘lazy’
[17:41:01.681]   - Field: ‘state’
[17:41:01.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:01.681] - Launch lazy future ...
[17:41:01.681] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:41:01.682] Packages needed by future strategies (n = 0): <none>
[17:41:01.682] {
[17:41:01.682]     {
[17:41:01.682]         {
[17:41:01.682]             ...future.startTime <- base::Sys.time()
[17:41:01.682]             {
[17:41:01.682]                 {
[17:41:01.682]                   {
[17:41:01.682]                     {
[17:41:01.682]                       {
[17:41:01.682]                         base::local({
[17:41:01.682]                           has_future <- base::requireNamespace("future", 
[17:41:01.682]                             quietly = TRUE)
[17:41:01.682]                           if (has_future) {
[17:41:01.682]                             ns <- base::getNamespace("future")
[17:41:01.682]                             version <- ns[[".package"]][["version"]]
[17:41:01.682]                             if (is.null(version)) 
[17:41:01.682]                               version <- utils::packageVersion("future")
[17:41:01.682]                           }
[17:41:01.682]                           else {
[17:41:01.682]                             version <- NULL
[17:41:01.682]                           }
[17:41:01.682]                           if (!has_future || version < "1.8.0") {
[17:41:01.682]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:01.682]                               "", base::R.version$version.string), 
[17:41:01.682]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:01.682]                                 base::R.version$platform, 8 * 
[17:41:01.682]                                   base::.Machine$sizeof.pointer), 
[17:41:01.682]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:01.682]                                 "release", "version")], collapse = " "), 
[17:41:01.682]                               hostname = base::Sys.info()[["nodename"]])
[17:41:01.682]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:01.682]                               info)
[17:41:01.682]                             info <- base::paste(info, collapse = "; ")
[17:41:01.682]                             if (!has_future) {
[17:41:01.682]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:01.682]                                 info)
[17:41:01.682]                             }
[17:41:01.682]                             else {
[17:41:01.682]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:01.682]                                 info, version)
[17:41:01.682]                             }
[17:41:01.682]                             base::stop(msg)
[17:41:01.682]                           }
[17:41:01.682]                         })
[17:41:01.682]                       }
[17:41:01.682]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:01.682]                       base::options(mc.cores = 1L)
[17:41:01.682]                     }
[17:41:01.682]                     base::local({
[17:41:01.682]                       for (pkg in c("stats", "future.apply")) {
[17:41:01.682]                         base::loadNamespace(pkg)
[17:41:01.682]                         base::library(pkg, character.only = TRUE)
[17:41:01.682]                       }
[17:41:01.682]                     })
[17:41:01.682]                   }
[17:41:01.682]                   options(future.plan = NULL)
[17:41:01.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:01.682]                 }
[17:41:01.682]                 ...future.workdir <- getwd()
[17:41:01.682]             }
[17:41:01.682]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:01.682]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:01.682]         }
[17:41:01.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:01.682]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:41:01.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:01.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:01.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:01.682]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:01.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:01.682]             base::names(...future.oldOptions))
[17:41:01.682]     }
[17:41:01.682]     if (FALSE) {
[17:41:01.682]     }
[17:41:01.682]     else {
[17:41:01.682]         if (TRUE) {
[17:41:01.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:01.682]                 open = "w")
[17:41:01.682]         }
[17:41:01.682]         else {
[17:41:01.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:01.682]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:01.682]         }
[17:41:01.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:01.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:01.682]             base::sink(type = "output", split = FALSE)
[17:41:01.682]             base::close(...future.stdout)
[17:41:01.682]         }, add = TRUE)
[17:41:01.682]     }
[17:41:01.682]     ...future.frame <- base::sys.nframe()
[17:41:01.682]     ...future.conditions <- base::list()
[17:41:01.682]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:01.682]     if (FALSE) {
[17:41:01.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:01.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:01.682]     }
[17:41:01.682]     ...future.result <- base::tryCatch({
[17:41:01.682]         base::withCallingHandlers({
[17:41:01.682]             ...future.value <- base::withVisible(base::local({
[17:41:01.682]                 ...future.makeSendCondition <- local({
[17:41:01.682]                   sendCondition <- NULL
[17:41:01.682]                   function(frame = 1L) {
[17:41:01.682]                     if (is.function(sendCondition)) 
[17:41:01.682]                       return(sendCondition)
[17:41:01.682]                     ns <- getNamespace("parallel")
[17:41:01.682]                     if (exists("sendData", mode = "function", 
[17:41:01.682]                       envir = ns)) {
[17:41:01.682]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:01.682]                         envir = ns)
[17:41:01.682]                       envir <- sys.frame(frame)
[17:41:01.682]                       master <- NULL
[17:41:01.682]                       while (!identical(envir, .GlobalEnv) && 
[17:41:01.682]                         !identical(envir, emptyenv())) {
[17:41:01.682]                         if (exists("master", mode = "list", envir = envir, 
[17:41:01.682]                           inherits = FALSE)) {
[17:41:01.682]                           master <- get("master", mode = "list", 
[17:41:01.682]                             envir = envir, inherits = FALSE)
[17:41:01.682]                           if (inherits(master, c("SOCKnode", 
[17:41:01.682]                             "SOCK0node"))) {
[17:41:01.682]                             sendCondition <<- function(cond) {
[17:41:01.682]                               data <- list(type = "VALUE", value = cond, 
[17:41:01.682]                                 success = TRUE)
[17:41:01.682]                               parallel_sendData(master, data)
[17:41:01.682]                             }
[17:41:01.682]                             return(sendCondition)
[17:41:01.682]                           }
[17:41:01.682]                         }
[17:41:01.682]                         frame <- frame + 1L
[17:41:01.682]                         envir <- sys.frame(frame)
[17:41:01.682]                       }
[17:41:01.682]                     }
[17:41:01.682]                     sendCondition <<- function(cond) NULL
[17:41:01.682]                   }
[17:41:01.682]                 })
[17:41:01.682]                 withCallingHandlers({
[17:41:01.682]                   {
[17:41:01.682]                     do.call(function(...) {
[17:41:01.682]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.682]                       if (!identical(...future.globals.maxSize.org, 
[17:41:01.682]                         ...future.globals.maxSize)) {
[17:41:01.682]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.682]                         on.exit(options(oopts), add = TRUE)
[17:41:01.682]                       }
[17:41:01.682]                       {
[17:41:01.682]                         lapply(seq_along(...future.elements_ii), 
[17:41:01.682]                           FUN = function(jj) {
[17:41:01.682]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.682]                             ...future.FUN(...future.X_jj, ...)
[17:41:01.682]                           })
[17:41:01.682]                       }
[17:41:01.682]                     }, args = future.call.arguments)
[17:41:01.682]                   }
[17:41:01.682]                 }, immediateCondition = function(cond) {
[17:41:01.682]                   sendCondition <- ...future.makeSendCondition()
[17:41:01.682]                   sendCondition(cond)
[17:41:01.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.682]                   {
[17:41:01.682]                     inherits <- base::inherits
[17:41:01.682]                     invokeRestart <- base::invokeRestart
[17:41:01.682]                     is.null <- base::is.null
[17:41:01.682]                     muffled <- FALSE
[17:41:01.682]                     if (inherits(cond, "message")) {
[17:41:01.682]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:01.682]                       if (muffled) 
[17:41:01.682]                         invokeRestart("muffleMessage")
[17:41:01.682]                     }
[17:41:01.682]                     else if (inherits(cond, "warning")) {
[17:41:01.682]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:01.682]                       if (muffled) 
[17:41:01.682]                         invokeRestart("muffleWarning")
[17:41:01.682]                     }
[17:41:01.682]                     else if (inherits(cond, "condition")) {
[17:41:01.682]                       if (!is.null(pattern)) {
[17:41:01.682]                         computeRestarts <- base::computeRestarts
[17:41:01.682]                         grepl <- base::grepl
[17:41:01.682]                         restarts <- computeRestarts(cond)
[17:41:01.682]                         for (restart in restarts) {
[17:41:01.682]                           name <- restart$name
[17:41:01.682]                           if (is.null(name)) 
[17:41:01.682]                             next
[17:41:01.682]                           if (!grepl(pattern, name)) 
[17:41:01.682]                             next
[17:41:01.682]                           invokeRestart(restart)
[17:41:01.682]                           muffled <- TRUE
[17:41:01.682]                           break
[17:41:01.682]                         }
[17:41:01.682]                       }
[17:41:01.682]                     }
[17:41:01.682]                     invisible(muffled)
[17:41:01.682]                   }
[17:41:01.682]                   muffleCondition(cond)
[17:41:01.682]                 })
[17:41:01.682]             }))
[17:41:01.682]             future::FutureResult(value = ...future.value$value, 
[17:41:01.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.682]                   ...future.rng), globalenv = if (FALSE) 
[17:41:01.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:01.682]                     ...future.globalenv.names))
[17:41:01.682]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:01.682]         }, condition = base::local({
[17:41:01.682]             c <- base::c
[17:41:01.682]             inherits <- base::inherits
[17:41:01.682]             invokeRestart <- base::invokeRestart
[17:41:01.682]             length <- base::length
[17:41:01.682]             list <- base::list
[17:41:01.682]             seq.int <- base::seq.int
[17:41:01.682]             signalCondition <- base::signalCondition
[17:41:01.682]             sys.calls <- base::sys.calls
[17:41:01.682]             `[[` <- base::`[[`
[17:41:01.682]             `+` <- base::`+`
[17:41:01.682]             `<<-` <- base::`<<-`
[17:41:01.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:01.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:01.682]                   3L)]
[17:41:01.682]             }
[17:41:01.682]             function(cond) {
[17:41:01.682]                 is_error <- inherits(cond, "error")
[17:41:01.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:01.682]                   NULL)
[17:41:01.682]                 if (is_error) {
[17:41:01.682]                   sessionInformation <- function() {
[17:41:01.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:01.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:01.682]                       search = base::search(), system = base::Sys.info())
[17:41:01.682]                   }
[17:41:01.682]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:01.682]                     cond$call), session = sessionInformation(), 
[17:41:01.682]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:01.682]                   signalCondition(cond)
[17:41:01.682]                 }
[17:41:01.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:01.682]                 "immediateCondition"))) {
[17:41:01.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:01.682]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:01.682]                   if (TRUE && !signal) {
[17:41:01.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.682]                     {
[17:41:01.682]                       inherits <- base::inherits
[17:41:01.682]                       invokeRestart <- base::invokeRestart
[17:41:01.682]                       is.null <- base::is.null
[17:41:01.682]                       muffled <- FALSE
[17:41:01.682]                       if (inherits(cond, "message")) {
[17:41:01.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.682]                         if (muffled) 
[17:41:01.682]                           invokeRestart("muffleMessage")
[17:41:01.682]                       }
[17:41:01.682]                       else if (inherits(cond, "warning")) {
[17:41:01.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.682]                         if (muffled) 
[17:41:01.682]                           invokeRestart("muffleWarning")
[17:41:01.682]                       }
[17:41:01.682]                       else if (inherits(cond, "condition")) {
[17:41:01.682]                         if (!is.null(pattern)) {
[17:41:01.682]                           computeRestarts <- base::computeRestarts
[17:41:01.682]                           grepl <- base::grepl
[17:41:01.682]                           restarts <- computeRestarts(cond)
[17:41:01.682]                           for (restart in restarts) {
[17:41:01.682]                             name <- restart$name
[17:41:01.682]                             if (is.null(name)) 
[17:41:01.682]                               next
[17:41:01.682]                             if (!grepl(pattern, name)) 
[17:41:01.682]                               next
[17:41:01.682]                             invokeRestart(restart)
[17:41:01.682]                             muffled <- TRUE
[17:41:01.682]                             break
[17:41:01.682]                           }
[17:41:01.682]                         }
[17:41:01.682]                       }
[17:41:01.682]                       invisible(muffled)
[17:41:01.682]                     }
[17:41:01.682]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.682]                   }
[17:41:01.682]                 }
[17:41:01.682]                 else {
[17:41:01.682]                   if (TRUE) {
[17:41:01.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.682]                     {
[17:41:01.682]                       inherits <- base::inherits
[17:41:01.682]                       invokeRestart <- base::invokeRestart
[17:41:01.682]                       is.null <- base::is.null
[17:41:01.682]                       muffled <- FALSE
[17:41:01.682]                       if (inherits(cond, "message")) {
[17:41:01.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.682]                         if (muffled) 
[17:41:01.682]                           invokeRestart("muffleMessage")
[17:41:01.682]                       }
[17:41:01.682]                       else if (inherits(cond, "warning")) {
[17:41:01.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.682]                         if (muffled) 
[17:41:01.682]                           invokeRestart("muffleWarning")
[17:41:01.682]                       }
[17:41:01.682]                       else if (inherits(cond, "condition")) {
[17:41:01.682]                         if (!is.null(pattern)) {
[17:41:01.682]                           computeRestarts <- base::computeRestarts
[17:41:01.682]                           grepl <- base::grepl
[17:41:01.682]                           restarts <- computeRestarts(cond)
[17:41:01.682]                           for (restart in restarts) {
[17:41:01.682]                             name <- restart$name
[17:41:01.682]                             if (is.null(name)) 
[17:41:01.682]                               next
[17:41:01.682]                             if (!grepl(pattern, name)) 
[17:41:01.682]                               next
[17:41:01.682]                             invokeRestart(restart)
[17:41:01.682]                             muffled <- TRUE
[17:41:01.682]                             break
[17:41:01.682]                           }
[17:41:01.682]                         }
[17:41:01.682]                       }
[17:41:01.682]                       invisible(muffled)
[17:41:01.682]                     }
[17:41:01.682]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.682]                   }
[17:41:01.682]                 }
[17:41:01.682]             }
[17:41:01.682]         }))
[17:41:01.682]     }, error = function(ex) {
[17:41:01.682]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:01.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.682]                 ...future.rng), started = ...future.startTime, 
[17:41:01.682]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:01.682]             version = "1.8"), class = "FutureResult")
[17:41:01.682]     }, finally = {
[17:41:01.682]         if (!identical(...future.workdir, getwd())) 
[17:41:01.682]             setwd(...future.workdir)
[17:41:01.682]         {
[17:41:01.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:01.682]                 ...future.oldOptions$nwarnings <- NULL
[17:41:01.682]             }
[17:41:01.682]             base::options(...future.oldOptions)
[17:41:01.682]             if (.Platform$OS.type == "windows") {
[17:41:01.682]                 old_names <- names(...future.oldEnvVars)
[17:41:01.682]                 envs <- base::Sys.getenv()
[17:41:01.682]                 names <- names(envs)
[17:41:01.682]                 common <- intersect(names, old_names)
[17:41:01.682]                 added <- setdiff(names, old_names)
[17:41:01.682]                 removed <- setdiff(old_names, names)
[17:41:01.682]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:01.682]                   envs[common]]
[17:41:01.682]                 NAMES <- toupper(changed)
[17:41:01.682]                 args <- list()
[17:41:01.682]                 for (kk in seq_along(NAMES)) {
[17:41:01.682]                   name <- changed[[kk]]
[17:41:01.682]                   NAME <- NAMES[[kk]]
[17:41:01.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.682]                     next
[17:41:01.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.682]                 }
[17:41:01.682]                 NAMES <- toupper(added)
[17:41:01.682]                 for (kk in seq_along(NAMES)) {
[17:41:01.682]                   name <- added[[kk]]
[17:41:01.682]                   NAME <- NAMES[[kk]]
[17:41:01.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.682]                     next
[17:41:01.682]                   args[[name]] <- ""
[17:41:01.682]                 }
[17:41:01.682]                 NAMES <- toupper(removed)
[17:41:01.682]                 for (kk in seq_along(NAMES)) {
[17:41:01.682]                   name <- removed[[kk]]
[17:41:01.682]                   NAME <- NAMES[[kk]]
[17:41:01.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.682]                     next
[17:41:01.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.682]                 }
[17:41:01.682]                 if (length(args) > 0) 
[17:41:01.682]                   base::do.call(base::Sys.setenv, args = args)
[17:41:01.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:01.682]             }
[17:41:01.682]             else {
[17:41:01.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:01.682]             }
[17:41:01.682]             {
[17:41:01.682]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:01.682]                   0L) {
[17:41:01.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:01.682]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:01.682]                   base::options(opts)
[17:41:01.682]                 }
[17:41:01.682]                 {
[17:41:01.682]                   {
[17:41:01.682]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:01.682]                     NULL
[17:41:01.682]                   }
[17:41:01.682]                   options(future.plan = NULL)
[17:41:01.682]                   if (is.na(NA_character_)) 
[17:41:01.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:01.682]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:01.682]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:01.682]                     envir = parent.frame()) 
[17:41:01.682]                   {
[17:41:01.682]                     if (is.function(workers)) 
[17:41:01.682]                       workers <- workers()
[17:41:01.682]                     workers <- structure(as.integer(workers), 
[17:41:01.682]                       class = class(workers))
[17:41:01.682]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:01.682]                       workers >= 1)
[17:41:01.682]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:01.682]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:01.682]                     }
[17:41:01.682]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:01.682]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:01.682]                       envir = envir)
[17:41:01.682]                     if (!future$lazy) 
[17:41:01.682]                       future <- run(future)
[17:41:01.682]                     invisible(future)
[17:41:01.682]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:01.682]                 }
[17:41:01.682]             }
[17:41:01.682]         }
[17:41:01.682]     })
[17:41:01.682]     if (TRUE) {
[17:41:01.682]         base::sink(type = "output", split = FALSE)
[17:41:01.682]         if (TRUE) {
[17:41:01.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:01.682]         }
[17:41:01.682]         else {
[17:41:01.682]             ...future.result["stdout"] <- base::list(NULL)
[17:41:01.682]         }
[17:41:01.682]         base::close(...future.stdout)
[17:41:01.682]         ...future.stdout <- NULL
[17:41:01.682]     }
[17:41:01.682]     ...future.result$conditions <- ...future.conditions
[17:41:01.682]     ...future.result$finished <- base::Sys.time()
[17:41:01.682]     ...future.result
[17:41:01.682] }
[17:41:01.685] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[17:41:01.685] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:01.727] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:01.727] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[17:41:01.771] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:41:01.771] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:01.772] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:01.772] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:01.815] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:01.815] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:01.859] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:01.859] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:41:01.860] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.860] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:41:01.861] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:41:01.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:01.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.861] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:41:01.862] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:41:01.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:01.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.863] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:01.863] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:01.863] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[17:41:01.864] MultisessionFuture started
[17:41:01.864] - Launch lazy future ... done
[17:41:01.864] run() for ‘MultisessionFuture’ ... done
[17:41:01.864] Created future:
[17:41:01.864] MultisessionFuture:
[17:41:01.864] Label: ‘future_vapply-2’
[17:41:01.864] Expression:
[17:41:01.864] {
[17:41:01.864]     do.call(function(...) {
[17:41:01.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.864]             on.exit(options(oopts), add = TRUE)
[17:41:01.864]         }
[17:41:01.864]         {
[17:41:01.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.864]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.864]             })
[17:41:01.864]         }
[17:41:01.864]     }, args = future.call.arguments)
[17:41:01.864] }
[17:41:01.864] Lazy evaluation: FALSE
[17:41:01.864] Asynchronous evaluation: TRUE
[17:41:01.864] Local evaluation: TRUE
[17:41:01.864] Environment: R_GlobalEnv
[17:41:01.864] Capture standard output: TRUE
[17:41:01.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:01.864] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:01.864] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:41:01.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:01.864] Resolved: FALSE
[17:41:01.864] Value: <not collected>
[17:41:01.864] Conditions captured: <none>
[17:41:01.864] Early signaling: FALSE
[17:41:01.864] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:01.864] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.876] Chunk #2 of 2 ... DONE
[17:41:01.876] Launching 2 futures (chunks) ... DONE
[17:41:01.876] Resolving 2 futures (chunks) ...
[17:41:01.876] resolve() on list ...
[17:41:01.877]  recursive: 0
[17:41:01.877]  length: 2
[17:41:01.877] 
[17:41:01.877] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.877] - Validating connection of MultisessionFuture
[17:41:01.877] - received message: FutureResult
[17:41:01.878] - Received FutureResult
[17:41:01.878] - Erased future from FutureRegistry
[17:41:01.878] result() for ClusterFuture ...
[17:41:01.878] - result already collected: FutureResult
[17:41:01.878] result() for ClusterFuture ... done
[17:41:01.878] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.878] Future #1
[17:41:01.878] result() for ClusterFuture ...
[17:41:01.878] - result already collected: FutureResult
[17:41:01.878] result() for ClusterFuture ... done
[17:41:01.878] result() for ClusterFuture ...
[17:41:01.878] - result already collected: FutureResult
[17:41:01.879] result() for ClusterFuture ... done
[17:41:01.879] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:01.879] - nx: 2
[17:41:01.879] - relay: TRUE
[17:41:01.879] - stdout: TRUE
[17:41:01.879] - signal: TRUE
[17:41:01.879] - resignal: FALSE
[17:41:01.879] - force: TRUE
[17:41:01.879] - relayed: [n=2] FALSE, FALSE
[17:41:01.879] - queued futures: [n=2] FALSE, FALSE
[17:41:01.879]  - until=1
[17:41:01.880]  - relaying element #1
[17:41:01.880] result() for ClusterFuture ...
[17:41:01.880] - result already collected: FutureResult
[17:41:01.880] result() for ClusterFuture ... done
[17:41:01.880] result() for ClusterFuture ...
[17:41:01.880] - result already collected: FutureResult
[17:41:01.880] result() for ClusterFuture ... done
[17:41:01.880] result() for ClusterFuture ...
[17:41:01.880] - result already collected: FutureResult
[17:41:01.880] result() for ClusterFuture ... done
[17:41:01.880] result() for ClusterFuture ...
[17:41:01.881] - result already collected: FutureResult
[17:41:01.881] result() for ClusterFuture ... done
[17:41:01.881] - relayed: [n=2] TRUE, FALSE
[17:41:01.881] - queued futures: [n=2] TRUE, FALSE
[17:41:01.881] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:01.881]  length: 1 (resolved future 1)
[17:41:01.912] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.912] - Validating connection of MultisessionFuture
[17:41:01.912] - received message: FutureResult
[17:41:01.912] - Received FutureResult
[17:41:01.913] - Erased future from FutureRegistry
[17:41:01.913] result() for ClusterFuture ...
[17:41:01.913] - result already collected: FutureResult
[17:41:01.913] result() for ClusterFuture ... done
[17:41:01.913] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.913] Future #2
[17:41:01.913] result() for ClusterFuture ...
[17:41:01.913] - result already collected: FutureResult
[17:41:01.913] result() for ClusterFuture ... done
[17:41:01.913] result() for ClusterFuture ...
[17:41:01.913] - result already collected: FutureResult
[17:41:01.914] result() for ClusterFuture ... done
[17:41:01.914] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:01.914] - nx: 2
[17:41:01.914] - relay: TRUE
[17:41:01.914] - stdout: TRUE
[17:41:01.914] - signal: TRUE
[17:41:01.914] - resignal: FALSE
[17:41:01.914] - force: TRUE
[17:41:01.914] - relayed: [n=2] TRUE, FALSE
[17:41:01.914] - queued futures: [n=2] TRUE, FALSE
[17:41:01.914]  - until=2
[17:41:01.914]  - relaying element #2
[17:41:01.915] result() for ClusterFuture ...
[17:41:01.915] - result already collected: FutureResult
[17:41:01.915] result() for ClusterFuture ... done
[17:41:01.915] result() for ClusterFuture ...
[17:41:01.915] - result already collected: FutureResult
[17:41:01.915] result() for ClusterFuture ... done
[17:41:01.915] result() for ClusterFuture ...
[17:41:01.915] - result already collected: FutureResult
[17:41:01.915] result() for ClusterFuture ... done
[17:41:01.915] result() for ClusterFuture ...
[17:41:01.916] - result already collected: FutureResult
[17:41:01.916] result() for ClusterFuture ... done
[17:41:01.916] - relayed: [n=2] TRUE, TRUE
[17:41:01.916] - queued futures: [n=2] TRUE, TRUE
[17:41:01.916] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:01.916]  length: 0 (resolved future 2)
[17:41:01.916] Relaying remaining futures
[17:41:01.916] signalConditionsASAP(NULL, pos=0) ...
[17:41:01.916] - nx: 2
[17:41:01.916] - relay: TRUE
[17:41:01.916] - stdout: TRUE
[17:41:01.916] - signal: TRUE
[17:41:01.917] - resignal: FALSE
[17:41:01.917] - force: TRUE
[17:41:01.917] - relayed: [n=2] TRUE, TRUE
[17:41:01.917] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:01.917] - relayed: [n=2] TRUE, TRUE
[17:41:01.917] - queued futures: [n=2] TRUE, TRUE
[17:41:01.917] signalConditionsASAP(NULL, pos=0) ... done
[17:41:01.917] resolve() on list ... DONE
[17:41:01.917] result() for ClusterFuture ...
[17:41:01.917] - result already collected: FutureResult
[17:41:01.917] result() for ClusterFuture ... done
[17:41:01.918] result() for ClusterFuture ...
[17:41:01.918] - result already collected: FutureResult
[17:41:01.918] result() for ClusterFuture ... done
[17:41:01.918] result() for ClusterFuture ...
[17:41:01.918] - result already collected: FutureResult
[17:41:01.918] result() for ClusterFuture ... done
[17:41:01.918] result() for ClusterFuture ...
[17:41:01.918] - result already collected: FutureResult
[17:41:01.918] result() for ClusterFuture ... done
[17:41:01.918]  - Number of value chunks collected: 2
[17:41:01.918] Resolving 2 futures (chunks) ... DONE
[17:41:01.918] Reducing values from 2 chunks ...
[17:41:01.919]  - Number of values collected after concatenation: 7
[17:41:01.919]  - Number of values expected: 7
[17:41:01.919] Reducing values from 2 chunks ... DONE
[17:41:01.919] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:41:01.920] future_lapply() ...
[17:41:01.925] Number of chunks: 2
[17:41:01.925] getGlobalsAndPackagesXApply() ...
[17:41:01.925]  - future.globals: TRUE
[17:41:01.925] getGlobalsAndPackages() ...
[17:41:01.925] Searching for globals...
[17:41:01.926] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:41:01.926] Searching for globals ... DONE
[17:41:01.926] Resolving globals: FALSE
[17:41:01.927] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:41:01.927] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:41:01.927] - globals: [1] ‘FUN’
[17:41:01.927] 
[17:41:01.928] getGlobalsAndPackages() ... DONE
[17:41:01.928]  - globals found/used: [n=1] ‘FUN’
[17:41:01.928]  - needed namespaces: [n=0] 
[17:41:01.928] Finding globals ... DONE
[17:41:01.928]  - use_args: TRUE
[17:41:01.928]  - Getting '...' globals ...
[17:41:01.928] resolve() on list ...
[17:41:01.928]  recursive: 0
[17:41:01.928]  length: 1
[17:41:01.929]  elements: ‘...’
[17:41:01.929]  length: 0 (resolved future 1)
[17:41:01.929] resolve() on list ... DONE
[17:41:01.929]    - '...' content: [n=1] ‘y’
[17:41:01.929] List of 1
[17:41:01.929]  $ ...:List of 1
[17:41:01.929]   ..$ y: num [1:5] 2 4 6 8 10
[17:41:01.929]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:01.929]  - attr(*, "where")=List of 1
[17:41:01.929]   ..$ ...:<environment: 0x564f3114a028> 
[17:41:01.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:01.929]  - attr(*, "resolved")= logi TRUE
[17:41:01.929]  - attr(*, "total_size")= num NA
[17:41:01.932]  - Getting '...' globals ... DONE
[17:41:01.932] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:01.932] List of 2
[17:41:01.932]  $ ...future.FUN:function (x, y)  
[17:41:01.932]  $ ...          :List of 1
[17:41:01.932]   ..$ y: num [1:5] 2 4 6 8 10
[17:41:01.932]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:01.932]  - attr(*, "where")=List of 2
[17:41:01.932]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:01.932]   ..$ ...          :<environment: 0x564f3114a028> 
[17:41:01.932]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:01.932]  - attr(*, "resolved")= logi FALSE
[17:41:01.932]  - attr(*, "total_size")= num 4264
[17:41:01.935] Packages to be attached in all futures: [n=0] 
[17:41:01.935] getGlobalsAndPackagesXApply() ... DONE
[17:41:01.936] Number of futures (= number of chunks): 2
[17:41:01.936] Launching 2 futures (chunks) ...
[17:41:01.936] Chunk #1 of 2 ...
[17:41:01.936]  - Finding globals in 'X' for chunk #1 ...
[17:41:01.936] getGlobalsAndPackages() ...
[17:41:01.936] Searching for globals...
[17:41:01.936] 
[17:41:01.936] Searching for globals ... DONE
[17:41:01.936] - globals: [0] <none>
[17:41:01.937] getGlobalsAndPackages() ... DONE
[17:41:01.937]    + additional globals found: [n=0] 
[17:41:01.937]    + additional namespaces needed: [n=0] 
[17:41:01.937]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:01.937]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:01.937]  - seeds: <none>
[17:41:01.937] getGlobalsAndPackages() ...
[17:41:01.937] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.937] Resolving globals: FALSE
[17:41:01.937] Tweak future expression to call with '...' arguments ...
[17:41:01.938] {
[17:41:01.938]     do.call(function(...) {
[17:41:01.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.938]             on.exit(options(oopts), add = TRUE)
[17:41:01.938]         }
[17:41:01.938]         {
[17:41:01.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.938]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.938]             })
[17:41:01.938]         }
[17:41:01.938]     }, args = future.call.arguments)
[17:41:01.938] }
[17:41:01.938] Tweak future expression to call with '...' arguments ... DONE
[17:41:01.938] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.938] 
[17:41:01.938] getGlobalsAndPackages() ... DONE
[17:41:01.939] run() for ‘Future’ ...
[17:41:01.939] - state: ‘created’
[17:41:01.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:01.960] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:01.960]   - Field: ‘node’
[17:41:01.961]   - Field: ‘label’
[17:41:01.961]   - Field: ‘local’
[17:41:01.961]   - Field: ‘owner’
[17:41:01.961]   - Field: ‘envir’
[17:41:01.961]   - Field: ‘workers’
[17:41:01.961]   - Field: ‘packages’
[17:41:01.961]   - Field: ‘gc’
[17:41:01.961]   - Field: ‘conditions’
[17:41:01.961]   - Field: ‘persistent’
[17:41:01.961]   - Field: ‘expr’
[17:41:01.962]   - Field: ‘uuid’
[17:41:01.962]   - Field: ‘seed’
[17:41:01.962]   - Field: ‘version’
[17:41:01.962]   - Field: ‘result’
[17:41:01.962]   - Field: ‘asynchronous’
[17:41:01.962]   - Field: ‘calls’
[17:41:01.962]   - Field: ‘globals’
[17:41:01.962]   - Field: ‘stdout’
[17:41:01.962]   - Field: ‘earlySignal’
[17:41:01.962]   - Field: ‘lazy’
[17:41:01.962]   - Field: ‘state’
[17:41:01.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:01.963] - Launch lazy future ...
[17:41:01.963] Packages needed by the future expression (n = 0): <none>
[17:41:01.963] Packages needed by future strategies (n = 0): <none>
[17:41:01.963] {
[17:41:01.963]     {
[17:41:01.963]         {
[17:41:01.963]             ...future.startTime <- base::Sys.time()
[17:41:01.963]             {
[17:41:01.963]                 {
[17:41:01.963]                   {
[17:41:01.963]                     {
[17:41:01.963]                       base::local({
[17:41:01.963]                         has_future <- base::requireNamespace("future", 
[17:41:01.963]                           quietly = TRUE)
[17:41:01.963]                         if (has_future) {
[17:41:01.963]                           ns <- base::getNamespace("future")
[17:41:01.963]                           version <- ns[[".package"]][["version"]]
[17:41:01.963]                           if (is.null(version)) 
[17:41:01.963]                             version <- utils::packageVersion("future")
[17:41:01.963]                         }
[17:41:01.963]                         else {
[17:41:01.963]                           version <- NULL
[17:41:01.963]                         }
[17:41:01.963]                         if (!has_future || version < "1.8.0") {
[17:41:01.963]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:01.963]                             "", base::R.version$version.string), 
[17:41:01.963]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:01.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:01.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:01.963]                               "release", "version")], collapse = " "), 
[17:41:01.963]                             hostname = base::Sys.info()[["nodename"]])
[17:41:01.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:01.963]                             info)
[17:41:01.963]                           info <- base::paste(info, collapse = "; ")
[17:41:01.963]                           if (!has_future) {
[17:41:01.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:01.963]                               info)
[17:41:01.963]                           }
[17:41:01.963]                           else {
[17:41:01.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:01.963]                               info, version)
[17:41:01.963]                           }
[17:41:01.963]                           base::stop(msg)
[17:41:01.963]                         }
[17:41:01.963]                       })
[17:41:01.963]                     }
[17:41:01.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:01.963]                     base::options(mc.cores = 1L)
[17:41:01.963]                   }
[17:41:01.963]                   options(future.plan = NULL)
[17:41:01.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:01.963]                 }
[17:41:01.963]                 ...future.workdir <- getwd()
[17:41:01.963]             }
[17:41:01.963]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:01.963]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:01.963]         }
[17:41:01.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:01.963]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:01.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:01.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:01.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:01.963]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:01.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:01.963]             base::names(...future.oldOptions))
[17:41:01.963]     }
[17:41:01.963]     if (FALSE) {
[17:41:01.963]     }
[17:41:01.963]     else {
[17:41:01.963]         if (TRUE) {
[17:41:01.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:01.963]                 open = "w")
[17:41:01.963]         }
[17:41:01.963]         else {
[17:41:01.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:01.963]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:01.963]         }
[17:41:01.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:01.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:01.963]             base::sink(type = "output", split = FALSE)
[17:41:01.963]             base::close(...future.stdout)
[17:41:01.963]         }, add = TRUE)
[17:41:01.963]     }
[17:41:01.963]     ...future.frame <- base::sys.nframe()
[17:41:01.963]     ...future.conditions <- base::list()
[17:41:01.963]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:01.963]     if (FALSE) {
[17:41:01.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:01.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:01.963]     }
[17:41:01.963]     ...future.result <- base::tryCatch({
[17:41:01.963]         base::withCallingHandlers({
[17:41:01.963]             ...future.value <- base::withVisible(base::local({
[17:41:01.963]                 ...future.makeSendCondition <- local({
[17:41:01.963]                   sendCondition <- NULL
[17:41:01.963]                   function(frame = 1L) {
[17:41:01.963]                     if (is.function(sendCondition)) 
[17:41:01.963]                       return(sendCondition)
[17:41:01.963]                     ns <- getNamespace("parallel")
[17:41:01.963]                     if (exists("sendData", mode = "function", 
[17:41:01.963]                       envir = ns)) {
[17:41:01.963]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:01.963]                         envir = ns)
[17:41:01.963]                       envir <- sys.frame(frame)
[17:41:01.963]                       master <- NULL
[17:41:01.963]                       while (!identical(envir, .GlobalEnv) && 
[17:41:01.963]                         !identical(envir, emptyenv())) {
[17:41:01.963]                         if (exists("master", mode = "list", envir = envir, 
[17:41:01.963]                           inherits = FALSE)) {
[17:41:01.963]                           master <- get("master", mode = "list", 
[17:41:01.963]                             envir = envir, inherits = FALSE)
[17:41:01.963]                           if (inherits(master, c("SOCKnode", 
[17:41:01.963]                             "SOCK0node"))) {
[17:41:01.963]                             sendCondition <<- function(cond) {
[17:41:01.963]                               data <- list(type = "VALUE", value = cond, 
[17:41:01.963]                                 success = TRUE)
[17:41:01.963]                               parallel_sendData(master, data)
[17:41:01.963]                             }
[17:41:01.963]                             return(sendCondition)
[17:41:01.963]                           }
[17:41:01.963]                         }
[17:41:01.963]                         frame <- frame + 1L
[17:41:01.963]                         envir <- sys.frame(frame)
[17:41:01.963]                       }
[17:41:01.963]                     }
[17:41:01.963]                     sendCondition <<- function(cond) NULL
[17:41:01.963]                   }
[17:41:01.963]                 })
[17:41:01.963]                 withCallingHandlers({
[17:41:01.963]                   {
[17:41:01.963]                     do.call(function(...) {
[17:41:01.963]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.963]                       if (!identical(...future.globals.maxSize.org, 
[17:41:01.963]                         ...future.globals.maxSize)) {
[17:41:01.963]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.963]                         on.exit(options(oopts), add = TRUE)
[17:41:01.963]                       }
[17:41:01.963]                       {
[17:41:01.963]                         lapply(seq_along(...future.elements_ii), 
[17:41:01.963]                           FUN = function(jj) {
[17:41:01.963]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.963]                             ...future.FUN(...future.X_jj, ...)
[17:41:01.963]                           })
[17:41:01.963]                       }
[17:41:01.963]                     }, args = future.call.arguments)
[17:41:01.963]                   }
[17:41:01.963]                 }, immediateCondition = function(cond) {
[17:41:01.963]                   sendCondition <- ...future.makeSendCondition()
[17:41:01.963]                   sendCondition(cond)
[17:41:01.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.963]                   {
[17:41:01.963]                     inherits <- base::inherits
[17:41:01.963]                     invokeRestart <- base::invokeRestart
[17:41:01.963]                     is.null <- base::is.null
[17:41:01.963]                     muffled <- FALSE
[17:41:01.963]                     if (inherits(cond, "message")) {
[17:41:01.963]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:01.963]                       if (muffled) 
[17:41:01.963]                         invokeRestart("muffleMessage")
[17:41:01.963]                     }
[17:41:01.963]                     else if (inherits(cond, "warning")) {
[17:41:01.963]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:01.963]                       if (muffled) 
[17:41:01.963]                         invokeRestart("muffleWarning")
[17:41:01.963]                     }
[17:41:01.963]                     else if (inherits(cond, "condition")) {
[17:41:01.963]                       if (!is.null(pattern)) {
[17:41:01.963]                         computeRestarts <- base::computeRestarts
[17:41:01.963]                         grepl <- base::grepl
[17:41:01.963]                         restarts <- computeRestarts(cond)
[17:41:01.963]                         for (restart in restarts) {
[17:41:01.963]                           name <- restart$name
[17:41:01.963]                           if (is.null(name)) 
[17:41:01.963]                             next
[17:41:01.963]                           if (!grepl(pattern, name)) 
[17:41:01.963]                             next
[17:41:01.963]                           invokeRestart(restart)
[17:41:01.963]                           muffled <- TRUE
[17:41:01.963]                           break
[17:41:01.963]                         }
[17:41:01.963]                       }
[17:41:01.963]                     }
[17:41:01.963]                     invisible(muffled)
[17:41:01.963]                   }
[17:41:01.963]                   muffleCondition(cond)
[17:41:01.963]                 })
[17:41:01.963]             }))
[17:41:01.963]             future::FutureResult(value = ...future.value$value, 
[17:41:01.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.963]                   ...future.rng), globalenv = if (FALSE) 
[17:41:01.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:01.963]                     ...future.globalenv.names))
[17:41:01.963]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:01.963]         }, condition = base::local({
[17:41:01.963]             c <- base::c
[17:41:01.963]             inherits <- base::inherits
[17:41:01.963]             invokeRestart <- base::invokeRestart
[17:41:01.963]             length <- base::length
[17:41:01.963]             list <- base::list
[17:41:01.963]             seq.int <- base::seq.int
[17:41:01.963]             signalCondition <- base::signalCondition
[17:41:01.963]             sys.calls <- base::sys.calls
[17:41:01.963]             `[[` <- base::`[[`
[17:41:01.963]             `+` <- base::`+`
[17:41:01.963]             `<<-` <- base::`<<-`
[17:41:01.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:01.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:01.963]                   3L)]
[17:41:01.963]             }
[17:41:01.963]             function(cond) {
[17:41:01.963]                 is_error <- inherits(cond, "error")
[17:41:01.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:01.963]                   NULL)
[17:41:01.963]                 if (is_error) {
[17:41:01.963]                   sessionInformation <- function() {
[17:41:01.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:01.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:01.963]                       search = base::search(), system = base::Sys.info())
[17:41:01.963]                   }
[17:41:01.963]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:01.963]                     cond$call), session = sessionInformation(), 
[17:41:01.963]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:01.963]                   signalCondition(cond)
[17:41:01.963]                 }
[17:41:01.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:01.963]                 "immediateCondition"))) {
[17:41:01.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:01.963]                   ...future.conditions[[length(...future.conditions) + 
[17:41:01.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:01.963]                   if (TRUE && !signal) {
[17:41:01.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.963]                     {
[17:41:01.963]                       inherits <- base::inherits
[17:41:01.963]                       invokeRestart <- base::invokeRestart
[17:41:01.963]                       is.null <- base::is.null
[17:41:01.963]                       muffled <- FALSE
[17:41:01.963]                       if (inherits(cond, "message")) {
[17:41:01.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.963]                         if (muffled) 
[17:41:01.963]                           invokeRestart("muffleMessage")
[17:41:01.963]                       }
[17:41:01.963]                       else if (inherits(cond, "warning")) {
[17:41:01.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.963]                         if (muffled) 
[17:41:01.963]                           invokeRestart("muffleWarning")
[17:41:01.963]                       }
[17:41:01.963]                       else if (inherits(cond, "condition")) {
[17:41:01.963]                         if (!is.null(pattern)) {
[17:41:01.963]                           computeRestarts <- base::computeRestarts
[17:41:01.963]                           grepl <- base::grepl
[17:41:01.963]                           restarts <- computeRestarts(cond)
[17:41:01.963]                           for (restart in restarts) {
[17:41:01.963]                             name <- restart$name
[17:41:01.963]                             if (is.null(name)) 
[17:41:01.963]                               next
[17:41:01.963]                             if (!grepl(pattern, name)) 
[17:41:01.963]                               next
[17:41:01.963]                             invokeRestart(restart)
[17:41:01.963]                             muffled <- TRUE
[17:41:01.963]                             break
[17:41:01.963]                           }
[17:41:01.963]                         }
[17:41:01.963]                       }
[17:41:01.963]                       invisible(muffled)
[17:41:01.963]                     }
[17:41:01.963]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.963]                   }
[17:41:01.963]                 }
[17:41:01.963]                 else {
[17:41:01.963]                   if (TRUE) {
[17:41:01.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:01.963]                     {
[17:41:01.963]                       inherits <- base::inherits
[17:41:01.963]                       invokeRestart <- base::invokeRestart
[17:41:01.963]                       is.null <- base::is.null
[17:41:01.963]                       muffled <- FALSE
[17:41:01.963]                       if (inherits(cond, "message")) {
[17:41:01.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:01.963]                         if (muffled) 
[17:41:01.963]                           invokeRestart("muffleMessage")
[17:41:01.963]                       }
[17:41:01.963]                       else if (inherits(cond, "warning")) {
[17:41:01.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:01.963]                         if (muffled) 
[17:41:01.963]                           invokeRestart("muffleWarning")
[17:41:01.963]                       }
[17:41:01.963]                       else if (inherits(cond, "condition")) {
[17:41:01.963]                         if (!is.null(pattern)) {
[17:41:01.963]                           computeRestarts <- base::computeRestarts
[17:41:01.963]                           grepl <- base::grepl
[17:41:01.963]                           restarts <- computeRestarts(cond)
[17:41:01.963]                           for (restart in restarts) {
[17:41:01.963]                             name <- restart$name
[17:41:01.963]                             if (is.null(name)) 
[17:41:01.963]                               next
[17:41:01.963]                             if (!grepl(pattern, name)) 
[17:41:01.963]                               next
[17:41:01.963]                             invokeRestart(restart)
[17:41:01.963]                             muffled <- TRUE
[17:41:01.963]                             break
[17:41:01.963]                           }
[17:41:01.963]                         }
[17:41:01.963]                       }
[17:41:01.963]                       invisible(muffled)
[17:41:01.963]                     }
[17:41:01.963]                     muffleCondition(cond, pattern = "^muffle")
[17:41:01.963]                   }
[17:41:01.963]                 }
[17:41:01.963]             }
[17:41:01.963]         }))
[17:41:01.963]     }, error = function(ex) {
[17:41:01.963]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:01.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:01.963]                 ...future.rng), started = ...future.startTime, 
[17:41:01.963]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:01.963]             version = "1.8"), class = "FutureResult")
[17:41:01.963]     }, finally = {
[17:41:01.963]         if (!identical(...future.workdir, getwd())) 
[17:41:01.963]             setwd(...future.workdir)
[17:41:01.963]         {
[17:41:01.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:01.963]                 ...future.oldOptions$nwarnings <- NULL
[17:41:01.963]             }
[17:41:01.963]             base::options(...future.oldOptions)
[17:41:01.963]             if (.Platform$OS.type == "windows") {
[17:41:01.963]                 old_names <- names(...future.oldEnvVars)
[17:41:01.963]                 envs <- base::Sys.getenv()
[17:41:01.963]                 names <- names(envs)
[17:41:01.963]                 common <- intersect(names, old_names)
[17:41:01.963]                 added <- setdiff(names, old_names)
[17:41:01.963]                 removed <- setdiff(old_names, names)
[17:41:01.963]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:01.963]                   envs[common]]
[17:41:01.963]                 NAMES <- toupper(changed)
[17:41:01.963]                 args <- list()
[17:41:01.963]                 for (kk in seq_along(NAMES)) {
[17:41:01.963]                   name <- changed[[kk]]
[17:41:01.963]                   NAME <- NAMES[[kk]]
[17:41:01.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.963]                     next
[17:41:01.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.963]                 }
[17:41:01.963]                 NAMES <- toupper(added)
[17:41:01.963]                 for (kk in seq_along(NAMES)) {
[17:41:01.963]                   name <- added[[kk]]
[17:41:01.963]                   NAME <- NAMES[[kk]]
[17:41:01.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.963]                     next
[17:41:01.963]                   args[[name]] <- ""
[17:41:01.963]                 }
[17:41:01.963]                 NAMES <- toupper(removed)
[17:41:01.963]                 for (kk in seq_along(NAMES)) {
[17:41:01.963]                   name <- removed[[kk]]
[17:41:01.963]                   NAME <- NAMES[[kk]]
[17:41:01.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:01.963]                     next
[17:41:01.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:01.963]                 }
[17:41:01.963]                 if (length(args) > 0) 
[17:41:01.963]                   base::do.call(base::Sys.setenv, args = args)
[17:41:01.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:01.963]             }
[17:41:01.963]             else {
[17:41:01.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:01.963]             }
[17:41:01.963]             {
[17:41:01.963]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:01.963]                   0L) {
[17:41:01.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:01.963]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:01.963]                   base::options(opts)
[17:41:01.963]                 }
[17:41:01.963]                 {
[17:41:01.963]                   {
[17:41:01.963]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:01.963]                     NULL
[17:41:01.963]                   }
[17:41:01.963]                   options(future.plan = NULL)
[17:41:01.963]                   if (is.na(NA_character_)) 
[17:41:01.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:01.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:01.963]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:01.963]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:01.963]                     envir = parent.frame()) 
[17:41:01.963]                   {
[17:41:01.963]                     if (is.function(workers)) 
[17:41:01.963]                       workers <- workers()
[17:41:01.963]                     workers <- structure(as.integer(workers), 
[17:41:01.963]                       class = class(workers))
[17:41:01.963]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:01.963]                       workers >= 1)
[17:41:01.963]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:01.963]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:01.963]                     }
[17:41:01.963]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:01.963]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:01.963]                       envir = envir)
[17:41:01.963]                     if (!future$lazy) 
[17:41:01.963]                       future <- run(future)
[17:41:01.963]                     invisible(future)
[17:41:01.963]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:01.963]                 }
[17:41:01.963]             }
[17:41:01.963]         }
[17:41:01.963]     })
[17:41:01.963]     if (TRUE) {
[17:41:01.963]         base::sink(type = "output", split = FALSE)
[17:41:01.963]         if (TRUE) {
[17:41:01.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:01.963]         }
[17:41:01.963]         else {
[17:41:01.963]             ...future.result["stdout"] <- base::list(NULL)
[17:41:01.963]         }
[17:41:01.963]         base::close(...future.stdout)
[17:41:01.963]         ...future.stdout <- NULL
[17:41:01.963]     }
[17:41:01.963]     ...future.result$conditions <- ...future.conditions
[17:41:01.963]     ...future.result$finished <- base::Sys.time()
[17:41:01.963]     ...future.result
[17:41:01.963] }
[17:41:01.966] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[17:41:01.966] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[17:41:01.967] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:41:01.967] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:41:01.967] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:41:01.967] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:41:01.968] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:41:01.968] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:01.968] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.968] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:01.969] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:01.969] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[17:41:01.969] MultisessionFuture started
[17:41:01.969] - Launch lazy future ... done
[17:41:01.969] run() for ‘MultisessionFuture’ ... done
[17:41:01.969] Created future:
[17:41:01.970] MultisessionFuture:
[17:41:01.970] Label: ‘future_sapply-1’
[17:41:01.970] Expression:
[17:41:01.970] {
[17:41:01.970]     do.call(function(...) {
[17:41:01.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.970]             on.exit(options(oopts), add = TRUE)
[17:41:01.970]         }
[17:41:01.970]         {
[17:41:01.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.970]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.970]             })
[17:41:01.970]         }
[17:41:01.970]     }, args = future.call.arguments)
[17:41:01.970] }
[17:41:01.970] Lazy evaluation: FALSE
[17:41:01.970] Asynchronous evaluation: TRUE
[17:41:01.970] Local evaluation: TRUE
[17:41:01.970] Environment: R_GlobalEnv
[17:41:01.970] Capture standard output: TRUE
[17:41:01.970] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:01.970] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:01.970] Packages: <none>
[17:41:01.970] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:01.970] Resolved: FALSE
[17:41:01.970] Value: <not collected>
[17:41:01.970] Conditions captured: <none>
[17:41:01.970] Early signaling: FALSE
[17:41:01.970] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:01.970] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.981] Chunk #1 of 2 ... DONE
[17:41:01.981] Chunk #2 of 2 ...
[17:41:01.981]  - Finding globals in 'X' for chunk #2 ...
[17:41:01.981] getGlobalsAndPackages() ...
[17:41:01.982] Searching for globals...
[17:41:01.982] 
[17:41:01.982] Searching for globals ... DONE
[17:41:01.982] - globals: [0] <none>
[17:41:01.982] getGlobalsAndPackages() ... DONE
[17:41:01.982]    + additional globals found: [n=0] 
[17:41:01.982]    + additional namespaces needed: [n=0] 
[17:41:01.982]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:01.982]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:01.983]  - seeds: <none>
[17:41:01.983] getGlobalsAndPackages() ...
[17:41:01.983] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.983] Resolving globals: FALSE
[17:41:01.983] Tweak future expression to call with '...' arguments ...
[17:41:01.983] {
[17:41:01.983]     do.call(function(...) {
[17:41:01.983]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:01.983]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:01.983]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:01.983]             on.exit(options(oopts), add = TRUE)
[17:41:01.983]         }
[17:41:01.983]         {
[17:41:01.983]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:01.983]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:01.983]                 ...future.FUN(...future.X_jj, ...)
[17:41:01.983]             })
[17:41:01.983]         }
[17:41:01.983]     }, args = future.call.arguments)
[17:41:01.983] }
[17:41:01.983] Tweak future expression to call with '...' arguments ... DONE
[17:41:01.984] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:01.984] 
[17:41:01.984] getGlobalsAndPackages() ... DONE
[17:41:01.984] run() for ‘Future’ ...
[17:41:01.984] - state: ‘created’
[17:41:01.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:01.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:01.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:01.999]   - Field: ‘node’
[17:41:02.000]   - Field: ‘label’
[17:41:02.000]   - Field: ‘local’
[17:41:02.000]   - Field: ‘owner’
[17:41:02.000]   - Field: ‘envir’
[17:41:02.000]   - Field: ‘workers’
[17:41:02.000]   - Field: ‘packages’
[17:41:02.000]   - Field: ‘gc’
[17:41:02.000]   - Field: ‘conditions’
[17:41:02.000]   - Field: ‘persistent’
[17:41:02.000]   - Field: ‘expr’
[17:41:02.001]   - Field: ‘uuid’
[17:41:02.001]   - Field: ‘seed’
[17:41:02.001]   - Field: ‘version’
[17:41:02.001]   - Field: ‘result’
[17:41:02.001]   - Field: ‘asynchronous’
[17:41:02.001]   - Field: ‘calls’
[17:41:02.001]   - Field: ‘globals’
[17:41:02.001]   - Field: ‘stdout’
[17:41:02.001]   - Field: ‘earlySignal’
[17:41:02.001]   - Field: ‘lazy’
[17:41:02.001]   - Field: ‘state’
[17:41:02.002] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:02.002] - Launch lazy future ...
[17:41:02.002] Packages needed by the future expression (n = 0): <none>
[17:41:02.002] Packages needed by future strategies (n = 0): <none>
[17:41:02.003] {
[17:41:02.003]     {
[17:41:02.003]         {
[17:41:02.003]             ...future.startTime <- base::Sys.time()
[17:41:02.003]             {
[17:41:02.003]                 {
[17:41:02.003]                   {
[17:41:02.003]                     {
[17:41:02.003]                       base::local({
[17:41:02.003]                         has_future <- base::requireNamespace("future", 
[17:41:02.003]                           quietly = TRUE)
[17:41:02.003]                         if (has_future) {
[17:41:02.003]                           ns <- base::getNamespace("future")
[17:41:02.003]                           version <- ns[[".package"]][["version"]]
[17:41:02.003]                           if (is.null(version)) 
[17:41:02.003]                             version <- utils::packageVersion("future")
[17:41:02.003]                         }
[17:41:02.003]                         else {
[17:41:02.003]                           version <- NULL
[17:41:02.003]                         }
[17:41:02.003]                         if (!has_future || version < "1.8.0") {
[17:41:02.003]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:02.003]                             "", base::R.version$version.string), 
[17:41:02.003]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:02.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:02.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:02.003]                               "release", "version")], collapse = " "), 
[17:41:02.003]                             hostname = base::Sys.info()[["nodename"]])
[17:41:02.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:02.003]                             info)
[17:41:02.003]                           info <- base::paste(info, collapse = "; ")
[17:41:02.003]                           if (!has_future) {
[17:41:02.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:02.003]                               info)
[17:41:02.003]                           }
[17:41:02.003]                           else {
[17:41:02.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:02.003]                               info, version)
[17:41:02.003]                           }
[17:41:02.003]                           base::stop(msg)
[17:41:02.003]                         }
[17:41:02.003]                       })
[17:41:02.003]                     }
[17:41:02.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:02.003]                     base::options(mc.cores = 1L)
[17:41:02.003]                   }
[17:41:02.003]                   options(future.plan = NULL)
[17:41:02.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:02.003]                 }
[17:41:02.003]                 ...future.workdir <- getwd()
[17:41:02.003]             }
[17:41:02.003]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:02.003]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:02.003]         }
[17:41:02.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:02.003]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:02.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:02.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:02.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:02.003]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:02.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:02.003]             base::names(...future.oldOptions))
[17:41:02.003]     }
[17:41:02.003]     if (FALSE) {
[17:41:02.003]     }
[17:41:02.003]     else {
[17:41:02.003]         if (TRUE) {
[17:41:02.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:02.003]                 open = "w")
[17:41:02.003]         }
[17:41:02.003]         else {
[17:41:02.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:02.003]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:02.003]         }
[17:41:02.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:02.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:02.003]             base::sink(type = "output", split = FALSE)
[17:41:02.003]             base::close(...future.stdout)
[17:41:02.003]         }, add = TRUE)
[17:41:02.003]     }
[17:41:02.003]     ...future.frame <- base::sys.nframe()
[17:41:02.003]     ...future.conditions <- base::list()
[17:41:02.003]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:02.003]     if (FALSE) {
[17:41:02.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:02.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:02.003]     }
[17:41:02.003]     ...future.result <- base::tryCatch({
[17:41:02.003]         base::withCallingHandlers({
[17:41:02.003]             ...future.value <- base::withVisible(base::local({
[17:41:02.003]                 ...future.makeSendCondition <- local({
[17:41:02.003]                   sendCondition <- NULL
[17:41:02.003]                   function(frame = 1L) {
[17:41:02.003]                     if (is.function(sendCondition)) 
[17:41:02.003]                       return(sendCondition)
[17:41:02.003]                     ns <- getNamespace("parallel")
[17:41:02.003]                     if (exists("sendData", mode = "function", 
[17:41:02.003]                       envir = ns)) {
[17:41:02.003]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:02.003]                         envir = ns)
[17:41:02.003]                       envir <- sys.frame(frame)
[17:41:02.003]                       master <- NULL
[17:41:02.003]                       while (!identical(envir, .GlobalEnv) && 
[17:41:02.003]                         !identical(envir, emptyenv())) {
[17:41:02.003]                         if (exists("master", mode = "list", envir = envir, 
[17:41:02.003]                           inherits = FALSE)) {
[17:41:02.003]                           master <- get("master", mode = "list", 
[17:41:02.003]                             envir = envir, inherits = FALSE)
[17:41:02.003]                           if (inherits(master, c("SOCKnode", 
[17:41:02.003]                             "SOCK0node"))) {
[17:41:02.003]                             sendCondition <<- function(cond) {
[17:41:02.003]                               data <- list(type = "VALUE", value = cond, 
[17:41:02.003]                                 success = TRUE)
[17:41:02.003]                               parallel_sendData(master, data)
[17:41:02.003]                             }
[17:41:02.003]                             return(sendCondition)
[17:41:02.003]                           }
[17:41:02.003]                         }
[17:41:02.003]                         frame <- frame + 1L
[17:41:02.003]                         envir <- sys.frame(frame)
[17:41:02.003]                       }
[17:41:02.003]                     }
[17:41:02.003]                     sendCondition <<- function(cond) NULL
[17:41:02.003]                   }
[17:41:02.003]                 })
[17:41:02.003]                 withCallingHandlers({
[17:41:02.003]                   {
[17:41:02.003]                     do.call(function(...) {
[17:41:02.003]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.003]                       if (!identical(...future.globals.maxSize.org, 
[17:41:02.003]                         ...future.globals.maxSize)) {
[17:41:02.003]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.003]                         on.exit(options(oopts), add = TRUE)
[17:41:02.003]                       }
[17:41:02.003]                       {
[17:41:02.003]                         lapply(seq_along(...future.elements_ii), 
[17:41:02.003]                           FUN = function(jj) {
[17:41:02.003]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.003]                             ...future.FUN(...future.X_jj, ...)
[17:41:02.003]                           })
[17:41:02.003]                       }
[17:41:02.003]                     }, args = future.call.arguments)
[17:41:02.003]                   }
[17:41:02.003]                 }, immediateCondition = function(cond) {
[17:41:02.003]                   sendCondition <- ...future.makeSendCondition()
[17:41:02.003]                   sendCondition(cond)
[17:41:02.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.003]                   {
[17:41:02.003]                     inherits <- base::inherits
[17:41:02.003]                     invokeRestart <- base::invokeRestart
[17:41:02.003]                     is.null <- base::is.null
[17:41:02.003]                     muffled <- FALSE
[17:41:02.003]                     if (inherits(cond, "message")) {
[17:41:02.003]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:02.003]                       if (muffled) 
[17:41:02.003]                         invokeRestart("muffleMessage")
[17:41:02.003]                     }
[17:41:02.003]                     else if (inherits(cond, "warning")) {
[17:41:02.003]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:02.003]                       if (muffled) 
[17:41:02.003]                         invokeRestart("muffleWarning")
[17:41:02.003]                     }
[17:41:02.003]                     else if (inherits(cond, "condition")) {
[17:41:02.003]                       if (!is.null(pattern)) {
[17:41:02.003]                         computeRestarts <- base::computeRestarts
[17:41:02.003]                         grepl <- base::grepl
[17:41:02.003]                         restarts <- computeRestarts(cond)
[17:41:02.003]                         for (restart in restarts) {
[17:41:02.003]                           name <- restart$name
[17:41:02.003]                           if (is.null(name)) 
[17:41:02.003]                             next
[17:41:02.003]                           if (!grepl(pattern, name)) 
[17:41:02.003]                             next
[17:41:02.003]                           invokeRestart(restart)
[17:41:02.003]                           muffled <- TRUE
[17:41:02.003]                           break
[17:41:02.003]                         }
[17:41:02.003]                       }
[17:41:02.003]                     }
[17:41:02.003]                     invisible(muffled)
[17:41:02.003]                   }
[17:41:02.003]                   muffleCondition(cond)
[17:41:02.003]                 })
[17:41:02.003]             }))
[17:41:02.003]             future::FutureResult(value = ...future.value$value, 
[17:41:02.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.003]                   ...future.rng), globalenv = if (FALSE) 
[17:41:02.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:02.003]                     ...future.globalenv.names))
[17:41:02.003]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:02.003]         }, condition = base::local({
[17:41:02.003]             c <- base::c
[17:41:02.003]             inherits <- base::inherits
[17:41:02.003]             invokeRestart <- base::invokeRestart
[17:41:02.003]             length <- base::length
[17:41:02.003]             list <- base::list
[17:41:02.003]             seq.int <- base::seq.int
[17:41:02.003]             signalCondition <- base::signalCondition
[17:41:02.003]             sys.calls <- base::sys.calls
[17:41:02.003]             `[[` <- base::`[[`
[17:41:02.003]             `+` <- base::`+`
[17:41:02.003]             `<<-` <- base::`<<-`
[17:41:02.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:02.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:02.003]                   3L)]
[17:41:02.003]             }
[17:41:02.003]             function(cond) {
[17:41:02.003]                 is_error <- inherits(cond, "error")
[17:41:02.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:02.003]                   NULL)
[17:41:02.003]                 if (is_error) {
[17:41:02.003]                   sessionInformation <- function() {
[17:41:02.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:02.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:02.003]                       search = base::search(), system = base::Sys.info())
[17:41:02.003]                   }
[17:41:02.003]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:02.003]                     cond$call), session = sessionInformation(), 
[17:41:02.003]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:02.003]                   signalCondition(cond)
[17:41:02.003]                 }
[17:41:02.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:02.003]                 "immediateCondition"))) {
[17:41:02.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:02.003]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:02.003]                   if (TRUE && !signal) {
[17:41:02.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.003]                     {
[17:41:02.003]                       inherits <- base::inherits
[17:41:02.003]                       invokeRestart <- base::invokeRestart
[17:41:02.003]                       is.null <- base::is.null
[17:41:02.003]                       muffled <- FALSE
[17:41:02.003]                       if (inherits(cond, "message")) {
[17:41:02.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.003]                         if (muffled) 
[17:41:02.003]                           invokeRestart("muffleMessage")
[17:41:02.003]                       }
[17:41:02.003]                       else if (inherits(cond, "warning")) {
[17:41:02.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.003]                         if (muffled) 
[17:41:02.003]                           invokeRestart("muffleWarning")
[17:41:02.003]                       }
[17:41:02.003]                       else if (inherits(cond, "condition")) {
[17:41:02.003]                         if (!is.null(pattern)) {
[17:41:02.003]                           computeRestarts <- base::computeRestarts
[17:41:02.003]                           grepl <- base::grepl
[17:41:02.003]                           restarts <- computeRestarts(cond)
[17:41:02.003]                           for (restart in restarts) {
[17:41:02.003]                             name <- restart$name
[17:41:02.003]                             if (is.null(name)) 
[17:41:02.003]                               next
[17:41:02.003]                             if (!grepl(pattern, name)) 
[17:41:02.003]                               next
[17:41:02.003]                             invokeRestart(restart)
[17:41:02.003]                             muffled <- TRUE
[17:41:02.003]                             break
[17:41:02.003]                           }
[17:41:02.003]                         }
[17:41:02.003]                       }
[17:41:02.003]                       invisible(muffled)
[17:41:02.003]                     }
[17:41:02.003]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.003]                   }
[17:41:02.003]                 }
[17:41:02.003]                 else {
[17:41:02.003]                   if (TRUE) {
[17:41:02.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.003]                     {
[17:41:02.003]                       inherits <- base::inherits
[17:41:02.003]                       invokeRestart <- base::invokeRestart
[17:41:02.003]                       is.null <- base::is.null
[17:41:02.003]                       muffled <- FALSE
[17:41:02.003]                       if (inherits(cond, "message")) {
[17:41:02.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.003]                         if (muffled) 
[17:41:02.003]                           invokeRestart("muffleMessage")
[17:41:02.003]                       }
[17:41:02.003]                       else if (inherits(cond, "warning")) {
[17:41:02.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.003]                         if (muffled) 
[17:41:02.003]                           invokeRestart("muffleWarning")
[17:41:02.003]                       }
[17:41:02.003]                       else if (inherits(cond, "condition")) {
[17:41:02.003]                         if (!is.null(pattern)) {
[17:41:02.003]                           computeRestarts <- base::computeRestarts
[17:41:02.003]                           grepl <- base::grepl
[17:41:02.003]                           restarts <- computeRestarts(cond)
[17:41:02.003]                           for (restart in restarts) {
[17:41:02.003]                             name <- restart$name
[17:41:02.003]                             if (is.null(name)) 
[17:41:02.003]                               next
[17:41:02.003]                             if (!grepl(pattern, name)) 
[17:41:02.003]                               next
[17:41:02.003]                             invokeRestart(restart)
[17:41:02.003]                             muffled <- TRUE
[17:41:02.003]                             break
[17:41:02.003]                           }
[17:41:02.003]                         }
[17:41:02.003]                       }
[17:41:02.003]                       invisible(muffled)
[17:41:02.003]                     }
[17:41:02.003]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.003]                   }
[17:41:02.003]                 }
[17:41:02.003]             }
[17:41:02.003]         }))
[17:41:02.003]     }, error = function(ex) {
[17:41:02.003]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:02.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.003]                 ...future.rng), started = ...future.startTime, 
[17:41:02.003]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:02.003]             version = "1.8"), class = "FutureResult")
[17:41:02.003]     }, finally = {
[17:41:02.003]         if (!identical(...future.workdir, getwd())) 
[17:41:02.003]             setwd(...future.workdir)
[17:41:02.003]         {
[17:41:02.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:02.003]                 ...future.oldOptions$nwarnings <- NULL
[17:41:02.003]             }
[17:41:02.003]             base::options(...future.oldOptions)
[17:41:02.003]             if (.Platform$OS.type == "windows") {
[17:41:02.003]                 old_names <- names(...future.oldEnvVars)
[17:41:02.003]                 envs <- base::Sys.getenv()
[17:41:02.003]                 names <- names(envs)
[17:41:02.003]                 common <- intersect(names, old_names)
[17:41:02.003]                 added <- setdiff(names, old_names)
[17:41:02.003]                 removed <- setdiff(old_names, names)
[17:41:02.003]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:02.003]                   envs[common]]
[17:41:02.003]                 NAMES <- toupper(changed)
[17:41:02.003]                 args <- list()
[17:41:02.003]                 for (kk in seq_along(NAMES)) {
[17:41:02.003]                   name <- changed[[kk]]
[17:41:02.003]                   NAME <- NAMES[[kk]]
[17:41:02.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.003]                     next
[17:41:02.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.003]                 }
[17:41:02.003]                 NAMES <- toupper(added)
[17:41:02.003]                 for (kk in seq_along(NAMES)) {
[17:41:02.003]                   name <- added[[kk]]
[17:41:02.003]                   NAME <- NAMES[[kk]]
[17:41:02.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.003]                     next
[17:41:02.003]                   args[[name]] <- ""
[17:41:02.003]                 }
[17:41:02.003]                 NAMES <- toupper(removed)
[17:41:02.003]                 for (kk in seq_along(NAMES)) {
[17:41:02.003]                   name <- removed[[kk]]
[17:41:02.003]                   NAME <- NAMES[[kk]]
[17:41:02.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.003]                     next
[17:41:02.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.003]                 }
[17:41:02.003]                 if (length(args) > 0) 
[17:41:02.003]                   base::do.call(base::Sys.setenv, args = args)
[17:41:02.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:02.003]             }
[17:41:02.003]             else {
[17:41:02.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:02.003]             }
[17:41:02.003]             {
[17:41:02.003]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:02.003]                   0L) {
[17:41:02.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:02.003]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:02.003]                   base::options(opts)
[17:41:02.003]                 }
[17:41:02.003]                 {
[17:41:02.003]                   {
[17:41:02.003]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:02.003]                     NULL
[17:41:02.003]                   }
[17:41:02.003]                   options(future.plan = NULL)
[17:41:02.003]                   if (is.na(NA_character_)) 
[17:41:02.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:02.003]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:02.003]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:02.003]                     envir = parent.frame()) 
[17:41:02.003]                   {
[17:41:02.003]                     if (is.function(workers)) 
[17:41:02.003]                       workers <- workers()
[17:41:02.003]                     workers <- structure(as.integer(workers), 
[17:41:02.003]                       class = class(workers))
[17:41:02.003]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:02.003]                       workers >= 1)
[17:41:02.003]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:02.003]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:02.003]                     }
[17:41:02.003]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:02.003]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:02.003]                       envir = envir)
[17:41:02.003]                     if (!future$lazy) 
[17:41:02.003]                       future <- run(future)
[17:41:02.003]                     invisible(future)
[17:41:02.003]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:02.003]                 }
[17:41:02.003]             }
[17:41:02.003]         }
[17:41:02.003]     })
[17:41:02.003]     if (TRUE) {
[17:41:02.003]         base::sink(type = "output", split = FALSE)
[17:41:02.003]         if (TRUE) {
[17:41:02.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:02.003]         }
[17:41:02.003]         else {
[17:41:02.003]             ...future.result["stdout"] <- base::list(NULL)
[17:41:02.003]         }
[17:41:02.003]         base::close(...future.stdout)
[17:41:02.003]         ...future.stdout <- NULL
[17:41:02.003]     }
[17:41:02.003]     ...future.result$conditions <- ...future.conditions
[17:41:02.003]     ...future.result$finished <- base::Sys.time()
[17:41:02.003]     ...future.result
[17:41:02.003] }
[17:41:02.006] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[17:41:02.006] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[17:41:02.006] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:41:02.006] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:41:02.007] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:41:02.007] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:02.007] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:02.008] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:02.008] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.008] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:02.008] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.009] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[17:41:02.009] MultisessionFuture started
[17:41:02.009] - Launch lazy future ... done
[17:41:02.010] run() for ‘MultisessionFuture’ ... done
[17:41:02.010] Created future:
[17:41:02.010] MultisessionFuture:
[17:41:02.010] Label: ‘future_sapply-2’
[17:41:02.010] Expression:
[17:41:02.010] {
[17:41:02.010]     do.call(function(...) {
[17:41:02.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.010]             on.exit(options(oopts), add = TRUE)
[17:41:02.010]         }
[17:41:02.010]         {
[17:41:02.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.010]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.010]             })
[17:41:02.010]         }
[17:41:02.010]     }, args = future.call.arguments)
[17:41:02.010] }
[17:41:02.010] Lazy evaluation: FALSE
[17:41:02.010] Asynchronous evaluation: TRUE
[17:41:02.010] Local evaluation: TRUE
[17:41:02.010] Environment: R_GlobalEnv
[17:41:02.010] Capture standard output: TRUE
[17:41:02.010] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:02.010] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:02.010] Packages: <none>
[17:41:02.010] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:02.010] Resolved: FALSE
[17:41:02.010] Value: <not collected>
[17:41:02.010] Conditions captured: <none>
[17:41:02.010] Early signaling: FALSE
[17:41:02.010] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:02.010] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.021] Chunk #2 of 2 ... DONE
[17:41:02.022] Launching 2 futures (chunks) ... DONE
[17:41:02.022] Resolving 2 futures (chunks) ...
[17:41:02.022] resolve() on list ...
[17:41:02.022]  recursive: 0
[17:41:02.022]  length: 2
[17:41:02.022] 
[17:41:02.023] receiveMessageFromWorker() for ClusterFuture ...
[17:41:02.023] - Validating connection of MultisessionFuture
[17:41:02.023] - received message: FutureResult
[17:41:02.023] - Received FutureResult
[17:41:02.023] - Erased future from FutureRegistry
[17:41:02.023] result() for ClusterFuture ...
[17:41:02.023] - result already collected: FutureResult
[17:41:02.023] result() for ClusterFuture ... done
[17:41:02.024] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:02.024] Future #1
[17:41:02.024] result() for ClusterFuture ...
[17:41:02.024] - result already collected: FutureResult
[17:41:02.024] result() for ClusterFuture ... done
[17:41:02.024] result() for ClusterFuture ...
[17:41:02.024] - result already collected: FutureResult
[17:41:02.024] result() for ClusterFuture ... done
[17:41:02.024] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:02.024] - nx: 2
[17:41:02.024] - relay: TRUE
[17:41:02.025] - stdout: TRUE
[17:41:02.025] - signal: TRUE
[17:41:02.025] - resignal: FALSE
[17:41:02.025] - force: TRUE
[17:41:02.025] - relayed: [n=2] FALSE, FALSE
[17:41:02.025] - queued futures: [n=2] FALSE, FALSE
[17:41:02.025]  - until=1
[17:41:02.025]  - relaying element #1
[17:41:02.025] result() for ClusterFuture ...
[17:41:02.025] - result already collected: FutureResult
[17:41:02.025] result() for ClusterFuture ... done
[17:41:02.025] result() for ClusterFuture ...
[17:41:02.026] - result already collected: FutureResult
[17:41:02.026] result() for ClusterFuture ... done
[17:41:02.026] result() for ClusterFuture ...
[17:41:02.026] - result already collected: FutureResult
[17:41:02.026] result() for ClusterFuture ... done
[17:41:02.026] result() for ClusterFuture ...
[17:41:02.026] - result already collected: FutureResult
[17:41:02.026] result() for ClusterFuture ... done
[17:41:02.026] - relayed: [n=2] TRUE, FALSE
[17:41:02.026] - queued futures: [n=2] TRUE, FALSE
[17:41:02.026] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:02.027]  length: 1 (resolved future 1)
[17:41:02.057] receiveMessageFromWorker() for ClusterFuture ...
[17:41:02.057] - Validating connection of MultisessionFuture
[17:41:02.057] - received message: FutureResult
[17:41:02.057] - Received FutureResult
[17:41:02.057] - Erased future from FutureRegistry
[17:41:02.057] result() for ClusterFuture ...
[17:41:02.057] - result already collected: FutureResult
[17:41:02.057] result() for ClusterFuture ... done
[17:41:02.058] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:02.058] Future #2
[17:41:02.058] result() for ClusterFuture ...
[17:41:02.058] - result already collected: FutureResult
[17:41:02.058] result() for ClusterFuture ... done
[17:41:02.058] result() for ClusterFuture ...
[17:41:02.058] - result already collected: FutureResult
[17:41:02.058] result() for ClusterFuture ... done
[17:41:02.058] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:02.058] - nx: 2
[17:41:02.058] - relay: TRUE
[17:41:02.059] - stdout: TRUE
[17:41:02.059] - signal: TRUE
[17:41:02.059] - resignal: FALSE
[17:41:02.059] - force: TRUE
[17:41:02.059] - relayed: [n=2] TRUE, FALSE
[17:41:02.059] - queued futures: [n=2] TRUE, FALSE
[17:41:02.059]  - until=2
[17:41:02.059]  - relaying element #2
[17:41:02.059] result() for ClusterFuture ...
[17:41:02.059] - result already collected: FutureResult
[17:41:02.059] result() for ClusterFuture ... done
[17:41:02.060] result() for ClusterFuture ...
[17:41:02.060] - result already collected: FutureResult
[17:41:02.060] result() for ClusterFuture ... done
[17:41:02.060] result() for ClusterFuture ...
[17:41:02.060] - result already collected: FutureResult
[17:41:02.060] result() for ClusterFuture ... done
[17:41:02.060] result() for ClusterFuture ...
[17:41:02.060] - result already collected: FutureResult
[17:41:02.060] result() for ClusterFuture ... done
[17:41:02.060] - relayed: [n=2] TRUE, TRUE
[17:41:02.060] - queued futures: [n=2] TRUE, TRUE
[17:41:02.061] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:02.061]  length: 0 (resolved future 2)
[17:41:02.061] Relaying remaining futures
[17:41:02.061] signalConditionsASAP(NULL, pos=0) ...
[17:41:02.061] - nx: 2
[17:41:02.061] - relay: TRUE
[17:41:02.061] - stdout: TRUE
[17:41:02.061] - signal: TRUE
[17:41:02.061] - resignal: FALSE
[17:41:02.061] - force: TRUE
[17:41:02.061] - relayed: [n=2] TRUE, TRUE
[17:41:02.061] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:02.062] - relayed: [n=2] TRUE, TRUE
[17:41:02.062] - queued futures: [n=2] TRUE, TRUE
[17:41:02.062] signalConditionsASAP(NULL, pos=0) ... done
[17:41:02.062] resolve() on list ... DONE
[17:41:02.062] result() for ClusterFuture ...
[17:41:02.062] - result already collected: FutureResult
[17:41:02.062] result() for ClusterFuture ... done
[17:41:02.062] result() for ClusterFuture ...
[17:41:02.062] - result already collected: FutureResult
[17:41:02.062] result() for ClusterFuture ... done
[17:41:02.063] result() for ClusterFuture ...
[17:41:02.063] - result already collected: FutureResult
[17:41:02.063] result() for ClusterFuture ... done
[17:41:02.063] result() for ClusterFuture ...
[17:41:02.063] - result already collected: FutureResult
[17:41:02.063] result() for ClusterFuture ... done
[17:41:02.063]  - Number of value chunks collected: 2
[17:41:02.063] Resolving 2 futures (chunks) ... DONE
[17:41:02.063] Reducing values from 2 chunks ...
[17:41:02.063]  - Number of values collected after concatenation: 4
[17:41:02.063]  - Number of values expected: 4
[17:41:02.064] Reducing values from 2 chunks ... DONE
[17:41:02.064] future_lapply() ... DONE
[17:41:02.064] future_lapply() ...
[17:41:02.069] Number of chunks: 2
[17:41:02.069] getGlobalsAndPackagesXApply() ...
[17:41:02.070]  - future.globals: TRUE
[17:41:02.070] getGlobalsAndPackages() ...
[17:41:02.070] Searching for globals...
[17:41:02.073] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:41:02.074] Searching for globals ... DONE
[17:41:02.074] Resolving globals: FALSE
[17:41:02.074] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:41:02.075] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:41:02.075] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:02.075] - packages: [1] ‘future.apply’
[17:41:02.075] getGlobalsAndPackages() ... DONE
[17:41:02.075]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:02.076]  - needed namespaces: [n=1] ‘future.apply’
[17:41:02.076] Finding globals ... DONE
[17:41:02.076]  - use_args: TRUE
[17:41:02.076]  - Getting '...' globals ...
[17:41:02.076] resolve() on list ...
[17:41:02.076]  recursive: 0
[17:41:02.076]  length: 1
[17:41:02.076]  elements: ‘...’
[17:41:02.076]  length: 0 (resolved future 1)
[17:41:02.077] resolve() on list ... DONE
[17:41:02.077]    - '...' content: [n=1] ‘y’
[17:41:02.077] List of 1
[17:41:02.077]  $ ...:List of 1
[17:41:02.077]   ..$ y: num [1:5] 2 4 6 8 10
[17:41:02.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:02.077]  - attr(*, "where")=List of 1
[17:41:02.077]   ..$ ...:<environment: 0x564f3148aa78> 
[17:41:02.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:02.077]  - attr(*, "resolved")= logi TRUE
[17:41:02.077]  - attr(*, "total_size")= num NA
[17:41:02.080]  - Getting '...' globals ... DONE
[17:41:02.080] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:02.080] List of 8
[17:41:02.080]  $ ...future.FUN:function (x, ...)  
[17:41:02.080]  $ x_FUN        :function (x, y)  
[17:41:02.080]  $ times        : int 15
[17:41:02.080]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:02.080]  $ stop_if_not  :function (...)  
[17:41:02.080]  $ dim          : int [1:2] 3 5
[17:41:02.080]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:41:02.080]  $ ...          :List of 1
[17:41:02.080]   ..$ y: num [1:5] 2 4 6 8 10
[17:41:02.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:02.080]  - attr(*, "where")=List of 8
[17:41:02.080]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:02.080]   ..$ ...          :<environment: 0x564f3148aa78> 
[17:41:02.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:02.080]  - attr(*, "resolved")= logi FALSE
[17:41:02.080]  - attr(*, "total_size")= num 98600
[17:41:02.086] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:41:02.086] getGlobalsAndPackagesXApply() ... DONE
[17:41:02.086] Number of futures (= number of chunks): 2
[17:41:02.086] Launching 2 futures (chunks) ...
[17:41:02.087] Chunk #1 of 2 ...
[17:41:02.087]  - Finding globals in 'X' for chunk #1 ...
[17:41:02.087] getGlobalsAndPackages() ...
[17:41:02.087] Searching for globals...
[17:41:02.087] 
[17:41:02.087] Searching for globals ... DONE
[17:41:02.087] - globals: [0] <none>
[17:41:02.087] getGlobalsAndPackages() ... DONE
[17:41:02.087]    + additional globals found: [n=0] 
[17:41:02.088]    + additional namespaces needed: [n=0] 
[17:41:02.088]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:02.088]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:02.088]  - seeds: <none>
[17:41:02.088] getGlobalsAndPackages() ...
[17:41:02.088] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.088] Resolving globals: FALSE
[17:41:02.088] Tweak future expression to call with '...' arguments ...
[17:41:02.088] {
[17:41:02.088]     do.call(function(...) {
[17:41:02.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.088]             on.exit(options(oopts), add = TRUE)
[17:41:02.088]         }
[17:41:02.088]         {
[17:41:02.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.088]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.088]             })
[17:41:02.088]         }
[17:41:02.088]     }, args = future.call.arguments)
[17:41:02.088] }
[17:41:02.089] Tweak future expression to call with '...' arguments ... DONE
[17:41:02.089] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.089] - packages: [1] ‘future.apply’
[17:41:02.089] getGlobalsAndPackages() ... DONE
[17:41:02.090] run() for ‘Future’ ...
[17:41:02.090] - state: ‘created’
[17:41:02.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:02.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:02.105]   - Field: ‘node’
[17:41:02.105]   - Field: ‘label’
[17:41:02.105]   - Field: ‘local’
[17:41:02.105]   - Field: ‘owner’
[17:41:02.105]   - Field: ‘envir’
[17:41:02.105]   - Field: ‘workers’
[17:41:02.107]   - Field: ‘packages’
[17:41:02.108]   - Field: ‘gc’
[17:41:02.108]   - Field: ‘conditions’
[17:41:02.108]   - Field: ‘persistent’
[17:41:02.108]   - Field: ‘expr’
[17:41:02.108]   - Field: ‘uuid’
[17:41:02.108]   - Field: ‘seed’
[17:41:02.108]   - Field: ‘version’
[17:41:02.108]   - Field: ‘result’
[17:41:02.109]   - Field: ‘asynchronous’
[17:41:02.109]   - Field: ‘calls’
[17:41:02.109]   - Field: ‘globals’
[17:41:02.109]   - Field: ‘stdout’
[17:41:02.109]   - Field: ‘earlySignal’
[17:41:02.109]   - Field: ‘lazy’
[17:41:02.109]   - Field: ‘state’
[17:41:02.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:02.109] - Launch lazy future ...
[17:41:02.110] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:02.110] Packages needed by future strategies (n = 0): <none>
[17:41:02.110] {
[17:41:02.110]     {
[17:41:02.110]         {
[17:41:02.110]             ...future.startTime <- base::Sys.time()
[17:41:02.110]             {
[17:41:02.110]                 {
[17:41:02.110]                   {
[17:41:02.110]                     {
[17:41:02.110]                       {
[17:41:02.110]                         base::local({
[17:41:02.110]                           has_future <- base::requireNamespace("future", 
[17:41:02.110]                             quietly = TRUE)
[17:41:02.110]                           if (has_future) {
[17:41:02.110]                             ns <- base::getNamespace("future")
[17:41:02.110]                             version <- ns[[".package"]][["version"]]
[17:41:02.110]                             if (is.null(version)) 
[17:41:02.110]                               version <- utils::packageVersion("future")
[17:41:02.110]                           }
[17:41:02.110]                           else {
[17:41:02.110]                             version <- NULL
[17:41:02.110]                           }
[17:41:02.110]                           if (!has_future || version < "1.8.0") {
[17:41:02.110]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:02.110]                               "", base::R.version$version.string), 
[17:41:02.110]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:02.110]                                 base::R.version$platform, 8 * 
[17:41:02.110]                                   base::.Machine$sizeof.pointer), 
[17:41:02.110]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:02.110]                                 "release", "version")], collapse = " "), 
[17:41:02.110]                               hostname = base::Sys.info()[["nodename"]])
[17:41:02.110]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:02.110]                               info)
[17:41:02.110]                             info <- base::paste(info, collapse = "; ")
[17:41:02.110]                             if (!has_future) {
[17:41:02.110]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:02.110]                                 info)
[17:41:02.110]                             }
[17:41:02.110]                             else {
[17:41:02.110]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:02.110]                                 info, version)
[17:41:02.110]                             }
[17:41:02.110]                             base::stop(msg)
[17:41:02.110]                           }
[17:41:02.110]                         })
[17:41:02.110]                       }
[17:41:02.110]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:02.110]                       base::options(mc.cores = 1L)
[17:41:02.110]                     }
[17:41:02.110]                     base::local({
[17:41:02.110]                       for (pkg in "future.apply") {
[17:41:02.110]                         base::loadNamespace(pkg)
[17:41:02.110]                         base::library(pkg, character.only = TRUE)
[17:41:02.110]                       }
[17:41:02.110]                     })
[17:41:02.110]                   }
[17:41:02.110]                   options(future.plan = NULL)
[17:41:02.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:02.110]                 }
[17:41:02.110]                 ...future.workdir <- getwd()
[17:41:02.110]             }
[17:41:02.110]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:02.110]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:02.110]         }
[17:41:02.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:02.110]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:02.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:02.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:02.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:02.110]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:02.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:02.110]             base::names(...future.oldOptions))
[17:41:02.110]     }
[17:41:02.110]     if (FALSE) {
[17:41:02.110]     }
[17:41:02.110]     else {
[17:41:02.110]         if (TRUE) {
[17:41:02.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:02.110]                 open = "w")
[17:41:02.110]         }
[17:41:02.110]         else {
[17:41:02.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:02.110]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:02.110]         }
[17:41:02.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:02.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:02.110]             base::sink(type = "output", split = FALSE)
[17:41:02.110]             base::close(...future.stdout)
[17:41:02.110]         }, add = TRUE)
[17:41:02.110]     }
[17:41:02.110]     ...future.frame <- base::sys.nframe()
[17:41:02.110]     ...future.conditions <- base::list()
[17:41:02.110]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:02.110]     if (FALSE) {
[17:41:02.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:02.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:02.110]     }
[17:41:02.110]     ...future.result <- base::tryCatch({
[17:41:02.110]         base::withCallingHandlers({
[17:41:02.110]             ...future.value <- base::withVisible(base::local({
[17:41:02.110]                 ...future.makeSendCondition <- local({
[17:41:02.110]                   sendCondition <- NULL
[17:41:02.110]                   function(frame = 1L) {
[17:41:02.110]                     if (is.function(sendCondition)) 
[17:41:02.110]                       return(sendCondition)
[17:41:02.110]                     ns <- getNamespace("parallel")
[17:41:02.110]                     if (exists("sendData", mode = "function", 
[17:41:02.110]                       envir = ns)) {
[17:41:02.110]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:02.110]                         envir = ns)
[17:41:02.110]                       envir <- sys.frame(frame)
[17:41:02.110]                       master <- NULL
[17:41:02.110]                       while (!identical(envir, .GlobalEnv) && 
[17:41:02.110]                         !identical(envir, emptyenv())) {
[17:41:02.110]                         if (exists("master", mode = "list", envir = envir, 
[17:41:02.110]                           inherits = FALSE)) {
[17:41:02.110]                           master <- get("master", mode = "list", 
[17:41:02.110]                             envir = envir, inherits = FALSE)
[17:41:02.110]                           if (inherits(master, c("SOCKnode", 
[17:41:02.110]                             "SOCK0node"))) {
[17:41:02.110]                             sendCondition <<- function(cond) {
[17:41:02.110]                               data <- list(type = "VALUE", value = cond, 
[17:41:02.110]                                 success = TRUE)
[17:41:02.110]                               parallel_sendData(master, data)
[17:41:02.110]                             }
[17:41:02.110]                             return(sendCondition)
[17:41:02.110]                           }
[17:41:02.110]                         }
[17:41:02.110]                         frame <- frame + 1L
[17:41:02.110]                         envir <- sys.frame(frame)
[17:41:02.110]                       }
[17:41:02.110]                     }
[17:41:02.110]                     sendCondition <<- function(cond) NULL
[17:41:02.110]                   }
[17:41:02.110]                 })
[17:41:02.110]                 withCallingHandlers({
[17:41:02.110]                   {
[17:41:02.110]                     do.call(function(...) {
[17:41:02.110]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.110]                       if (!identical(...future.globals.maxSize.org, 
[17:41:02.110]                         ...future.globals.maxSize)) {
[17:41:02.110]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.110]                         on.exit(options(oopts), add = TRUE)
[17:41:02.110]                       }
[17:41:02.110]                       {
[17:41:02.110]                         lapply(seq_along(...future.elements_ii), 
[17:41:02.110]                           FUN = function(jj) {
[17:41:02.110]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.110]                             ...future.FUN(...future.X_jj, ...)
[17:41:02.110]                           })
[17:41:02.110]                       }
[17:41:02.110]                     }, args = future.call.arguments)
[17:41:02.110]                   }
[17:41:02.110]                 }, immediateCondition = function(cond) {
[17:41:02.110]                   sendCondition <- ...future.makeSendCondition()
[17:41:02.110]                   sendCondition(cond)
[17:41:02.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.110]                   {
[17:41:02.110]                     inherits <- base::inherits
[17:41:02.110]                     invokeRestart <- base::invokeRestart
[17:41:02.110]                     is.null <- base::is.null
[17:41:02.110]                     muffled <- FALSE
[17:41:02.110]                     if (inherits(cond, "message")) {
[17:41:02.110]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:02.110]                       if (muffled) 
[17:41:02.110]                         invokeRestart("muffleMessage")
[17:41:02.110]                     }
[17:41:02.110]                     else if (inherits(cond, "warning")) {
[17:41:02.110]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:02.110]                       if (muffled) 
[17:41:02.110]                         invokeRestart("muffleWarning")
[17:41:02.110]                     }
[17:41:02.110]                     else if (inherits(cond, "condition")) {
[17:41:02.110]                       if (!is.null(pattern)) {
[17:41:02.110]                         computeRestarts <- base::computeRestarts
[17:41:02.110]                         grepl <- base::grepl
[17:41:02.110]                         restarts <- computeRestarts(cond)
[17:41:02.110]                         for (restart in restarts) {
[17:41:02.110]                           name <- restart$name
[17:41:02.110]                           if (is.null(name)) 
[17:41:02.110]                             next
[17:41:02.110]                           if (!grepl(pattern, name)) 
[17:41:02.110]                             next
[17:41:02.110]                           invokeRestart(restart)
[17:41:02.110]                           muffled <- TRUE
[17:41:02.110]                           break
[17:41:02.110]                         }
[17:41:02.110]                       }
[17:41:02.110]                     }
[17:41:02.110]                     invisible(muffled)
[17:41:02.110]                   }
[17:41:02.110]                   muffleCondition(cond)
[17:41:02.110]                 })
[17:41:02.110]             }))
[17:41:02.110]             future::FutureResult(value = ...future.value$value, 
[17:41:02.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.110]                   ...future.rng), globalenv = if (FALSE) 
[17:41:02.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:02.110]                     ...future.globalenv.names))
[17:41:02.110]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:02.110]         }, condition = base::local({
[17:41:02.110]             c <- base::c
[17:41:02.110]             inherits <- base::inherits
[17:41:02.110]             invokeRestart <- base::invokeRestart
[17:41:02.110]             length <- base::length
[17:41:02.110]             list <- base::list
[17:41:02.110]             seq.int <- base::seq.int
[17:41:02.110]             signalCondition <- base::signalCondition
[17:41:02.110]             sys.calls <- base::sys.calls
[17:41:02.110]             `[[` <- base::`[[`
[17:41:02.110]             `+` <- base::`+`
[17:41:02.110]             `<<-` <- base::`<<-`
[17:41:02.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:02.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:02.110]                   3L)]
[17:41:02.110]             }
[17:41:02.110]             function(cond) {
[17:41:02.110]                 is_error <- inherits(cond, "error")
[17:41:02.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:02.110]                   NULL)
[17:41:02.110]                 if (is_error) {
[17:41:02.110]                   sessionInformation <- function() {
[17:41:02.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:02.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:02.110]                       search = base::search(), system = base::Sys.info())
[17:41:02.110]                   }
[17:41:02.110]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:02.110]                     cond$call), session = sessionInformation(), 
[17:41:02.110]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:02.110]                   signalCondition(cond)
[17:41:02.110]                 }
[17:41:02.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:02.110]                 "immediateCondition"))) {
[17:41:02.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:02.110]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:02.110]                   if (TRUE && !signal) {
[17:41:02.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.110]                     {
[17:41:02.110]                       inherits <- base::inherits
[17:41:02.110]                       invokeRestart <- base::invokeRestart
[17:41:02.110]                       is.null <- base::is.null
[17:41:02.110]                       muffled <- FALSE
[17:41:02.110]                       if (inherits(cond, "message")) {
[17:41:02.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.110]                         if (muffled) 
[17:41:02.110]                           invokeRestart("muffleMessage")
[17:41:02.110]                       }
[17:41:02.110]                       else if (inherits(cond, "warning")) {
[17:41:02.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.110]                         if (muffled) 
[17:41:02.110]                           invokeRestart("muffleWarning")
[17:41:02.110]                       }
[17:41:02.110]                       else if (inherits(cond, "condition")) {
[17:41:02.110]                         if (!is.null(pattern)) {
[17:41:02.110]                           computeRestarts <- base::computeRestarts
[17:41:02.110]                           grepl <- base::grepl
[17:41:02.110]                           restarts <- computeRestarts(cond)
[17:41:02.110]                           for (restart in restarts) {
[17:41:02.110]                             name <- restart$name
[17:41:02.110]                             if (is.null(name)) 
[17:41:02.110]                               next
[17:41:02.110]                             if (!grepl(pattern, name)) 
[17:41:02.110]                               next
[17:41:02.110]                             invokeRestart(restart)
[17:41:02.110]                             muffled <- TRUE
[17:41:02.110]                             break
[17:41:02.110]                           }
[17:41:02.110]                         }
[17:41:02.110]                       }
[17:41:02.110]                       invisible(muffled)
[17:41:02.110]                     }
[17:41:02.110]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.110]                   }
[17:41:02.110]                 }
[17:41:02.110]                 else {
[17:41:02.110]                   if (TRUE) {
[17:41:02.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.110]                     {
[17:41:02.110]                       inherits <- base::inherits
[17:41:02.110]                       invokeRestart <- base::invokeRestart
[17:41:02.110]                       is.null <- base::is.null
[17:41:02.110]                       muffled <- FALSE
[17:41:02.110]                       if (inherits(cond, "message")) {
[17:41:02.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.110]                         if (muffled) 
[17:41:02.110]                           invokeRestart("muffleMessage")
[17:41:02.110]                       }
[17:41:02.110]                       else if (inherits(cond, "warning")) {
[17:41:02.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.110]                         if (muffled) 
[17:41:02.110]                           invokeRestart("muffleWarning")
[17:41:02.110]                       }
[17:41:02.110]                       else if (inherits(cond, "condition")) {
[17:41:02.110]                         if (!is.null(pattern)) {
[17:41:02.110]                           computeRestarts <- base::computeRestarts
[17:41:02.110]                           grepl <- base::grepl
[17:41:02.110]                           restarts <- computeRestarts(cond)
[17:41:02.110]                           for (restart in restarts) {
[17:41:02.110]                             name <- restart$name
[17:41:02.110]                             if (is.null(name)) 
[17:41:02.110]                               next
[17:41:02.110]                             if (!grepl(pattern, name)) 
[17:41:02.110]                               next
[17:41:02.110]                             invokeRestart(restart)
[17:41:02.110]                             muffled <- TRUE
[17:41:02.110]                             break
[17:41:02.110]                           }
[17:41:02.110]                         }
[17:41:02.110]                       }
[17:41:02.110]                       invisible(muffled)
[17:41:02.110]                     }
[17:41:02.110]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.110]                   }
[17:41:02.110]                 }
[17:41:02.110]             }
[17:41:02.110]         }))
[17:41:02.110]     }, error = function(ex) {
[17:41:02.110]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:02.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.110]                 ...future.rng), started = ...future.startTime, 
[17:41:02.110]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:02.110]             version = "1.8"), class = "FutureResult")
[17:41:02.110]     }, finally = {
[17:41:02.110]         if (!identical(...future.workdir, getwd())) 
[17:41:02.110]             setwd(...future.workdir)
[17:41:02.110]         {
[17:41:02.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:02.110]                 ...future.oldOptions$nwarnings <- NULL
[17:41:02.110]             }
[17:41:02.110]             base::options(...future.oldOptions)
[17:41:02.110]             if (.Platform$OS.type == "windows") {
[17:41:02.110]                 old_names <- names(...future.oldEnvVars)
[17:41:02.110]                 envs <- base::Sys.getenv()
[17:41:02.110]                 names <- names(envs)
[17:41:02.110]                 common <- intersect(names, old_names)
[17:41:02.110]                 added <- setdiff(names, old_names)
[17:41:02.110]                 removed <- setdiff(old_names, names)
[17:41:02.110]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:02.110]                   envs[common]]
[17:41:02.110]                 NAMES <- toupper(changed)
[17:41:02.110]                 args <- list()
[17:41:02.110]                 for (kk in seq_along(NAMES)) {
[17:41:02.110]                   name <- changed[[kk]]
[17:41:02.110]                   NAME <- NAMES[[kk]]
[17:41:02.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.110]                     next
[17:41:02.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.110]                 }
[17:41:02.110]                 NAMES <- toupper(added)
[17:41:02.110]                 for (kk in seq_along(NAMES)) {
[17:41:02.110]                   name <- added[[kk]]
[17:41:02.110]                   NAME <- NAMES[[kk]]
[17:41:02.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.110]                     next
[17:41:02.110]                   args[[name]] <- ""
[17:41:02.110]                 }
[17:41:02.110]                 NAMES <- toupper(removed)
[17:41:02.110]                 for (kk in seq_along(NAMES)) {
[17:41:02.110]                   name <- removed[[kk]]
[17:41:02.110]                   NAME <- NAMES[[kk]]
[17:41:02.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.110]                     next
[17:41:02.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.110]                 }
[17:41:02.110]                 if (length(args) > 0) 
[17:41:02.110]                   base::do.call(base::Sys.setenv, args = args)
[17:41:02.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:02.110]             }
[17:41:02.110]             else {
[17:41:02.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:02.110]             }
[17:41:02.110]             {
[17:41:02.110]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:02.110]                   0L) {
[17:41:02.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:02.110]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:02.110]                   base::options(opts)
[17:41:02.110]                 }
[17:41:02.110]                 {
[17:41:02.110]                   {
[17:41:02.110]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:02.110]                     NULL
[17:41:02.110]                   }
[17:41:02.110]                   options(future.plan = NULL)
[17:41:02.110]                   if (is.na(NA_character_)) 
[17:41:02.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:02.110]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:02.110]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:02.110]                     envir = parent.frame()) 
[17:41:02.110]                   {
[17:41:02.110]                     if (is.function(workers)) 
[17:41:02.110]                       workers <- workers()
[17:41:02.110]                     workers <- structure(as.integer(workers), 
[17:41:02.110]                       class = class(workers))
[17:41:02.110]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:02.110]                       workers >= 1)
[17:41:02.110]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:02.110]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:02.110]                     }
[17:41:02.110]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:02.110]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:02.110]                       envir = envir)
[17:41:02.110]                     if (!future$lazy) 
[17:41:02.110]                       future <- run(future)
[17:41:02.110]                     invisible(future)
[17:41:02.110]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:02.110]                 }
[17:41:02.110]             }
[17:41:02.110]         }
[17:41:02.110]     })
[17:41:02.110]     if (TRUE) {
[17:41:02.110]         base::sink(type = "output", split = FALSE)
[17:41:02.110]         if (TRUE) {
[17:41:02.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:02.110]         }
[17:41:02.110]         else {
[17:41:02.110]             ...future.result["stdout"] <- base::list(NULL)
[17:41:02.110]         }
[17:41:02.110]         base::close(...future.stdout)
[17:41:02.110]         ...future.stdout <- NULL
[17:41:02.110]     }
[17:41:02.110]     ...future.result$conditions <- ...future.conditions
[17:41:02.110]     ...future.result$finished <- base::Sys.time()
[17:41:02.110]     ...future.result
[17:41:02.110] }
[17:41:02.113] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[17:41:02.113] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:02.155] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:02.155] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[17:41:02.156] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:41:02.156] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:02.156] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:02.157] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:02.199] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:02.199] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:02.243] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:02.243] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:41:02.244] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:41:02.244] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:41:02.244] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:41:02.245] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:41:02.245] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:41:02.245] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:41:02.245] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:41:02.246] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:02.246] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:02.246] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:02.246] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:02.247] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[17:41:02.247] MultisessionFuture started
[17:41:02.247] - Launch lazy future ... done
[17:41:02.248] run() for ‘MultisessionFuture’ ... done
[17:41:02.248] Created future:
[17:41:02.248] MultisessionFuture:
[17:41:02.248] Label: ‘future_vapply-1’
[17:41:02.248] Expression:
[17:41:02.248] {
[17:41:02.248]     do.call(function(...) {
[17:41:02.248]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.248]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.248]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.248]             on.exit(options(oopts), add = TRUE)
[17:41:02.248]         }
[17:41:02.248]         {
[17:41:02.248]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.248]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.248]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.248]             })
[17:41:02.248]         }
[17:41:02.248]     }, args = future.call.arguments)
[17:41:02.248] }
[17:41:02.248] Lazy evaluation: FALSE
[17:41:02.248] Asynchronous evaluation: TRUE
[17:41:02.248] Local evaluation: TRUE
[17:41:02.248] Environment: R_GlobalEnv
[17:41:02.248] Capture standard output: TRUE
[17:41:02.248] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:02.248] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:02.248] Packages: 1 packages (‘future.apply’)
[17:41:02.248] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:02.248] Resolved: FALSE
[17:41:02.248] Value: <not collected>
[17:41:02.248] Conditions captured: <none>
[17:41:02.248] Early signaling: FALSE
[17:41:02.248] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:02.248] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.259] Chunk #1 of 2 ... DONE
[17:41:02.260] Chunk #2 of 2 ...
[17:41:02.260]  - Finding globals in 'X' for chunk #2 ...
[17:41:02.260] getGlobalsAndPackages() ...
[17:41:02.260] Searching for globals...
[17:41:02.260] 
[17:41:02.260] Searching for globals ... DONE
[17:41:02.260] - globals: [0] <none>
[17:41:02.261] getGlobalsAndPackages() ... DONE
[17:41:02.261]    + additional globals found: [n=0] 
[17:41:02.261]    + additional namespaces needed: [n=0] 
[17:41:02.261]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:02.261]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:02.261]  - seeds: <none>
[17:41:02.261] getGlobalsAndPackages() ...
[17:41:02.261] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.261] Resolving globals: FALSE
[17:41:02.261] Tweak future expression to call with '...' arguments ...
[17:41:02.262] {
[17:41:02.262]     do.call(function(...) {
[17:41:02.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.262]             on.exit(options(oopts), add = TRUE)
[17:41:02.262]         }
[17:41:02.262]         {
[17:41:02.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.262]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.262]             })
[17:41:02.262]         }
[17:41:02.262]     }, args = future.call.arguments)
[17:41:02.262] }
[17:41:02.262] Tweak future expression to call with '...' arguments ... DONE
[17:41:02.262] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.262] - packages: [1] ‘future.apply’
[17:41:02.263] getGlobalsAndPackages() ... DONE
[17:41:02.263] run() for ‘Future’ ...
[17:41:02.263] - state: ‘created’
[17:41:02.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:02.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:02.278]   - Field: ‘node’
[17:41:02.278]   - Field: ‘label’
[17:41:02.278]   - Field: ‘local’
[17:41:02.278]   - Field: ‘owner’
[17:41:02.278]   - Field: ‘envir’
[17:41:02.279]   - Field: ‘workers’
[17:41:02.279]   - Field: ‘packages’
[17:41:02.279]   - Field: ‘gc’
[17:41:02.279]   - Field: ‘conditions’
[17:41:02.279]   - Field: ‘persistent’
[17:41:02.279]   - Field: ‘expr’
[17:41:02.279]   - Field: ‘uuid’
[17:41:02.279]   - Field: ‘seed’
[17:41:02.279]   - Field: ‘version’
[17:41:02.279]   - Field: ‘result’
[17:41:02.279]   - Field: ‘asynchronous’
[17:41:02.280]   - Field: ‘calls’
[17:41:02.280]   - Field: ‘globals’
[17:41:02.280]   - Field: ‘stdout’
[17:41:02.280]   - Field: ‘earlySignal’
[17:41:02.280]   - Field: ‘lazy’
[17:41:02.280]   - Field: ‘state’
[17:41:02.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:02.280] - Launch lazy future ...
[17:41:02.281] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:02.281] Packages needed by future strategies (n = 0): <none>
[17:41:02.281] {
[17:41:02.281]     {
[17:41:02.281]         {
[17:41:02.281]             ...future.startTime <- base::Sys.time()
[17:41:02.281]             {
[17:41:02.281]                 {
[17:41:02.281]                   {
[17:41:02.281]                     {
[17:41:02.281]                       {
[17:41:02.281]                         base::local({
[17:41:02.281]                           has_future <- base::requireNamespace("future", 
[17:41:02.281]                             quietly = TRUE)
[17:41:02.281]                           if (has_future) {
[17:41:02.281]                             ns <- base::getNamespace("future")
[17:41:02.281]                             version <- ns[[".package"]][["version"]]
[17:41:02.281]                             if (is.null(version)) 
[17:41:02.281]                               version <- utils::packageVersion("future")
[17:41:02.281]                           }
[17:41:02.281]                           else {
[17:41:02.281]                             version <- NULL
[17:41:02.281]                           }
[17:41:02.281]                           if (!has_future || version < "1.8.0") {
[17:41:02.281]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:02.281]                               "", base::R.version$version.string), 
[17:41:02.281]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:02.281]                                 base::R.version$platform, 8 * 
[17:41:02.281]                                   base::.Machine$sizeof.pointer), 
[17:41:02.281]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:02.281]                                 "release", "version")], collapse = " "), 
[17:41:02.281]                               hostname = base::Sys.info()[["nodename"]])
[17:41:02.281]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:02.281]                               info)
[17:41:02.281]                             info <- base::paste(info, collapse = "; ")
[17:41:02.281]                             if (!has_future) {
[17:41:02.281]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:02.281]                                 info)
[17:41:02.281]                             }
[17:41:02.281]                             else {
[17:41:02.281]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:02.281]                                 info, version)
[17:41:02.281]                             }
[17:41:02.281]                             base::stop(msg)
[17:41:02.281]                           }
[17:41:02.281]                         })
[17:41:02.281]                       }
[17:41:02.281]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:02.281]                       base::options(mc.cores = 1L)
[17:41:02.281]                     }
[17:41:02.281]                     base::local({
[17:41:02.281]                       for (pkg in "future.apply") {
[17:41:02.281]                         base::loadNamespace(pkg)
[17:41:02.281]                         base::library(pkg, character.only = TRUE)
[17:41:02.281]                       }
[17:41:02.281]                     })
[17:41:02.281]                   }
[17:41:02.281]                   options(future.plan = NULL)
[17:41:02.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:02.281]                 }
[17:41:02.281]                 ...future.workdir <- getwd()
[17:41:02.281]             }
[17:41:02.281]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:02.281]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:02.281]         }
[17:41:02.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:02.281]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:02.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:02.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:02.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:02.281]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:02.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:02.281]             base::names(...future.oldOptions))
[17:41:02.281]     }
[17:41:02.281]     if (FALSE) {
[17:41:02.281]     }
[17:41:02.281]     else {
[17:41:02.281]         if (TRUE) {
[17:41:02.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:02.281]                 open = "w")
[17:41:02.281]         }
[17:41:02.281]         else {
[17:41:02.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:02.281]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:02.281]         }
[17:41:02.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:02.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:02.281]             base::sink(type = "output", split = FALSE)
[17:41:02.281]             base::close(...future.stdout)
[17:41:02.281]         }, add = TRUE)
[17:41:02.281]     }
[17:41:02.281]     ...future.frame <- base::sys.nframe()
[17:41:02.281]     ...future.conditions <- base::list()
[17:41:02.281]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:02.281]     if (FALSE) {
[17:41:02.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:02.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:02.281]     }
[17:41:02.281]     ...future.result <- base::tryCatch({
[17:41:02.281]         base::withCallingHandlers({
[17:41:02.281]             ...future.value <- base::withVisible(base::local({
[17:41:02.281]                 ...future.makeSendCondition <- local({
[17:41:02.281]                   sendCondition <- NULL
[17:41:02.281]                   function(frame = 1L) {
[17:41:02.281]                     if (is.function(sendCondition)) 
[17:41:02.281]                       return(sendCondition)
[17:41:02.281]                     ns <- getNamespace("parallel")
[17:41:02.281]                     if (exists("sendData", mode = "function", 
[17:41:02.281]                       envir = ns)) {
[17:41:02.281]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:02.281]                         envir = ns)
[17:41:02.281]                       envir <- sys.frame(frame)
[17:41:02.281]                       master <- NULL
[17:41:02.281]                       while (!identical(envir, .GlobalEnv) && 
[17:41:02.281]                         !identical(envir, emptyenv())) {
[17:41:02.281]                         if (exists("master", mode = "list", envir = envir, 
[17:41:02.281]                           inherits = FALSE)) {
[17:41:02.281]                           master <- get("master", mode = "list", 
[17:41:02.281]                             envir = envir, inherits = FALSE)
[17:41:02.281]                           if (inherits(master, c("SOCKnode", 
[17:41:02.281]                             "SOCK0node"))) {
[17:41:02.281]                             sendCondition <<- function(cond) {
[17:41:02.281]                               data <- list(type = "VALUE", value = cond, 
[17:41:02.281]                                 success = TRUE)
[17:41:02.281]                               parallel_sendData(master, data)
[17:41:02.281]                             }
[17:41:02.281]                             return(sendCondition)
[17:41:02.281]                           }
[17:41:02.281]                         }
[17:41:02.281]                         frame <- frame + 1L
[17:41:02.281]                         envir <- sys.frame(frame)
[17:41:02.281]                       }
[17:41:02.281]                     }
[17:41:02.281]                     sendCondition <<- function(cond) NULL
[17:41:02.281]                   }
[17:41:02.281]                 })
[17:41:02.281]                 withCallingHandlers({
[17:41:02.281]                   {
[17:41:02.281]                     do.call(function(...) {
[17:41:02.281]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.281]                       if (!identical(...future.globals.maxSize.org, 
[17:41:02.281]                         ...future.globals.maxSize)) {
[17:41:02.281]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.281]                         on.exit(options(oopts), add = TRUE)
[17:41:02.281]                       }
[17:41:02.281]                       {
[17:41:02.281]                         lapply(seq_along(...future.elements_ii), 
[17:41:02.281]                           FUN = function(jj) {
[17:41:02.281]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.281]                             ...future.FUN(...future.X_jj, ...)
[17:41:02.281]                           })
[17:41:02.281]                       }
[17:41:02.281]                     }, args = future.call.arguments)
[17:41:02.281]                   }
[17:41:02.281]                 }, immediateCondition = function(cond) {
[17:41:02.281]                   sendCondition <- ...future.makeSendCondition()
[17:41:02.281]                   sendCondition(cond)
[17:41:02.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.281]                   {
[17:41:02.281]                     inherits <- base::inherits
[17:41:02.281]                     invokeRestart <- base::invokeRestart
[17:41:02.281]                     is.null <- base::is.null
[17:41:02.281]                     muffled <- FALSE
[17:41:02.281]                     if (inherits(cond, "message")) {
[17:41:02.281]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:02.281]                       if (muffled) 
[17:41:02.281]                         invokeRestart("muffleMessage")
[17:41:02.281]                     }
[17:41:02.281]                     else if (inherits(cond, "warning")) {
[17:41:02.281]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:02.281]                       if (muffled) 
[17:41:02.281]                         invokeRestart("muffleWarning")
[17:41:02.281]                     }
[17:41:02.281]                     else if (inherits(cond, "condition")) {
[17:41:02.281]                       if (!is.null(pattern)) {
[17:41:02.281]                         computeRestarts <- base::computeRestarts
[17:41:02.281]                         grepl <- base::grepl
[17:41:02.281]                         restarts <- computeRestarts(cond)
[17:41:02.281]                         for (restart in restarts) {
[17:41:02.281]                           name <- restart$name
[17:41:02.281]                           if (is.null(name)) 
[17:41:02.281]                             next
[17:41:02.281]                           if (!grepl(pattern, name)) 
[17:41:02.281]                             next
[17:41:02.281]                           invokeRestart(restart)
[17:41:02.281]                           muffled <- TRUE
[17:41:02.281]                           break
[17:41:02.281]                         }
[17:41:02.281]                       }
[17:41:02.281]                     }
[17:41:02.281]                     invisible(muffled)
[17:41:02.281]                   }
[17:41:02.281]                   muffleCondition(cond)
[17:41:02.281]                 })
[17:41:02.281]             }))
[17:41:02.281]             future::FutureResult(value = ...future.value$value, 
[17:41:02.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.281]                   ...future.rng), globalenv = if (FALSE) 
[17:41:02.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:02.281]                     ...future.globalenv.names))
[17:41:02.281]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:02.281]         }, condition = base::local({
[17:41:02.281]             c <- base::c
[17:41:02.281]             inherits <- base::inherits
[17:41:02.281]             invokeRestart <- base::invokeRestart
[17:41:02.281]             length <- base::length
[17:41:02.281]             list <- base::list
[17:41:02.281]             seq.int <- base::seq.int
[17:41:02.281]             signalCondition <- base::signalCondition
[17:41:02.281]             sys.calls <- base::sys.calls
[17:41:02.281]             `[[` <- base::`[[`
[17:41:02.281]             `+` <- base::`+`
[17:41:02.281]             `<<-` <- base::`<<-`
[17:41:02.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:02.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:02.281]                   3L)]
[17:41:02.281]             }
[17:41:02.281]             function(cond) {
[17:41:02.281]                 is_error <- inherits(cond, "error")
[17:41:02.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:02.281]                   NULL)
[17:41:02.281]                 if (is_error) {
[17:41:02.281]                   sessionInformation <- function() {
[17:41:02.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:02.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:02.281]                       search = base::search(), system = base::Sys.info())
[17:41:02.281]                   }
[17:41:02.281]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:02.281]                     cond$call), session = sessionInformation(), 
[17:41:02.281]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:02.281]                   signalCondition(cond)
[17:41:02.281]                 }
[17:41:02.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:02.281]                 "immediateCondition"))) {
[17:41:02.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:02.281]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:02.281]                   if (TRUE && !signal) {
[17:41:02.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.281]                     {
[17:41:02.281]                       inherits <- base::inherits
[17:41:02.281]                       invokeRestart <- base::invokeRestart
[17:41:02.281]                       is.null <- base::is.null
[17:41:02.281]                       muffled <- FALSE
[17:41:02.281]                       if (inherits(cond, "message")) {
[17:41:02.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.281]                         if (muffled) 
[17:41:02.281]                           invokeRestart("muffleMessage")
[17:41:02.281]                       }
[17:41:02.281]                       else if (inherits(cond, "warning")) {
[17:41:02.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.281]                         if (muffled) 
[17:41:02.281]                           invokeRestart("muffleWarning")
[17:41:02.281]                       }
[17:41:02.281]                       else if (inherits(cond, "condition")) {
[17:41:02.281]                         if (!is.null(pattern)) {
[17:41:02.281]                           computeRestarts <- base::computeRestarts
[17:41:02.281]                           grepl <- base::grepl
[17:41:02.281]                           restarts <- computeRestarts(cond)
[17:41:02.281]                           for (restart in restarts) {
[17:41:02.281]                             name <- restart$name
[17:41:02.281]                             if (is.null(name)) 
[17:41:02.281]                               next
[17:41:02.281]                             if (!grepl(pattern, name)) 
[17:41:02.281]                               next
[17:41:02.281]                             invokeRestart(restart)
[17:41:02.281]                             muffled <- TRUE
[17:41:02.281]                             break
[17:41:02.281]                           }
[17:41:02.281]                         }
[17:41:02.281]                       }
[17:41:02.281]                       invisible(muffled)
[17:41:02.281]                     }
[17:41:02.281]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.281]                   }
[17:41:02.281]                 }
[17:41:02.281]                 else {
[17:41:02.281]                   if (TRUE) {
[17:41:02.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.281]                     {
[17:41:02.281]                       inherits <- base::inherits
[17:41:02.281]                       invokeRestart <- base::invokeRestart
[17:41:02.281]                       is.null <- base::is.null
[17:41:02.281]                       muffled <- FALSE
[17:41:02.281]                       if (inherits(cond, "message")) {
[17:41:02.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.281]                         if (muffled) 
[17:41:02.281]                           invokeRestart("muffleMessage")
[17:41:02.281]                       }
[17:41:02.281]                       else if (inherits(cond, "warning")) {
[17:41:02.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.281]                         if (muffled) 
[17:41:02.281]                           invokeRestart("muffleWarning")
[17:41:02.281]                       }
[17:41:02.281]                       else if (inherits(cond, "condition")) {
[17:41:02.281]                         if (!is.null(pattern)) {
[17:41:02.281]                           computeRestarts <- base::computeRestarts
[17:41:02.281]                           grepl <- base::grepl
[17:41:02.281]                           restarts <- computeRestarts(cond)
[17:41:02.281]                           for (restart in restarts) {
[17:41:02.281]                             name <- restart$name
[17:41:02.281]                             if (is.null(name)) 
[17:41:02.281]                               next
[17:41:02.281]                             if (!grepl(pattern, name)) 
[17:41:02.281]                               next
[17:41:02.281]                             invokeRestart(restart)
[17:41:02.281]                             muffled <- TRUE
[17:41:02.281]                             break
[17:41:02.281]                           }
[17:41:02.281]                         }
[17:41:02.281]                       }
[17:41:02.281]                       invisible(muffled)
[17:41:02.281]                     }
[17:41:02.281]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.281]                   }
[17:41:02.281]                 }
[17:41:02.281]             }
[17:41:02.281]         }))
[17:41:02.281]     }, error = function(ex) {
[17:41:02.281]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:02.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.281]                 ...future.rng), started = ...future.startTime, 
[17:41:02.281]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:02.281]             version = "1.8"), class = "FutureResult")
[17:41:02.281]     }, finally = {
[17:41:02.281]         if (!identical(...future.workdir, getwd())) 
[17:41:02.281]             setwd(...future.workdir)
[17:41:02.281]         {
[17:41:02.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:02.281]                 ...future.oldOptions$nwarnings <- NULL
[17:41:02.281]             }
[17:41:02.281]             base::options(...future.oldOptions)
[17:41:02.281]             if (.Platform$OS.type == "windows") {
[17:41:02.281]                 old_names <- names(...future.oldEnvVars)
[17:41:02.281]                 envs <- base::Sys.getenv()
[17:41:02.281]                 names <- names(envs)
[17:41:02.281]                 common <- intersect(names, old_names)
[17:41:02.281]                 added <- setdiff(names, old_names)
[17:41:02.281]                 removed <- setdiff(old_names, names)
[17:41:02.281]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:02.281]                   envs[common]]
[17:41:02.281]                 NAMES <- toupper(changed)
[17:41:02.281]                 args <- list()
[17:41:02.281]                 for (kk in seq_along(NAMES)) {
[17:41:02.281]                   name <- changed[[kk]]
[17:41:02.281]                   NAME <- NAMES[[kk]]
[17:41:02.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.281]                     next
[17:41:02.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.281]                 }
[17:41:02.281]                 NAMES <- toupper(added)
[17:41:02.281]                 for (kk in seq_along(NAMES)) {
[17:41:02.281]                   name <- added[[kk]]
[17:41:02.281]                   NAME <- NAMES[[kk]]
[17:41:02.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.281]                     next
[17:41:02.281]                   args[[name]] <- ""
[17:41:02.281]                 }
[17:41:02.281]                 NAMES <- toupper(removed)
[17:41:02.281]                 for (kk in seq_along(NAMES)) {
[17:41:02.281]                   name <- removed[[kk]]
[17:41:02.281]                   NAME <- NAMES[[kk]]
[17:41:02.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.281]                     next
[17:41:02.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.281]                 }
[17:41:02.281]                 if (length(args) > 0) 
[17:41:02.281]                   base::do.call(base::Sys.setenv, args = args)
[17:41:02.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:02.281]             }
[17:41:02.281]             else {
[17:41:02.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:02.281]             }
[17:41:02.281]             {
[17:41:02.281]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:02.281]                   0L) {
[17:41:02.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:02.281]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:02.281]                   base::options(opts)
[17:41:02.281]                 }
[17:41:02.281]                 {
[17:41:02.281]                   {
[17:41:02.281]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:02.281]                     NULL
[17:41:02.281]                   }
[17:41:02.281]                   options(future.plan = NULL)
[17:41:02.281]                   if (is.na(NA_character_)) 
[17:41:02.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:02.281]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:02.281]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:02.281]                     envir = parent.frame()) 
[17:41:02.281]                   {
[17:41:02.281]                     if (is.function(workers)) 
[17:41:02.281]                       workers <- workers()
[17:41:02.281]                     workers <- structure(as.integer(workers), 
[17:41:02.281]                       class = class(workers))
[17:41:02.281]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:02.281]                       workers >= 1)
[17:41:02.281]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:02.281]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:02.281]                     }
[17:41:02.281]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:02.281]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:02.281]                       envir = envir)
[17:41:02.281]                     if (!future$lazy) 
[17:41:02.281]                       future <- run(future)
[17:41:02.281]                     invisible(future)
[17:41:02.281]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:02.281]                 }
[17:41:02.281]             }
[17:41:02.281]         }
[17:41:02.281]     })
[17:41:02.281]     if (TRUE) {
[17:41:02.281]         base::sink(type = "output", split = FALSE)
[17:41:02.281]         if (TRUE) {
[17:41:02.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:02.281]         }
[17:41:02.281]         else {
[17:41:02.281]             ...future.result["stdout"] <- base::list(NULL)
[17:41:02.281]         }
[17:41:02.281]         base::close(...future.stdout)
[17:41:02.281]         ...future.stdout <- NULL
[17:41:02.281]     }
[17:41:02.281]     ...future.result$conditions <- ...future.conditions
[17:41:02.281]     ...future.result$finished <- base::Sys.time()
[17:41:02.281]     ...future.result
[17:41:02.281] }
[17:41:02.284] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[17:41:02.284] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:02.327] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:02.327] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[17:41:02.328] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:41:02.328] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:02.329] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:02.329] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:02.371] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:02.371] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:02.415] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:02.415] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:41:02.416] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:41:02.416] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:41:02.416] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:41:02.417] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:41:02.417] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:41:02.417] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:02.417] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:02.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:02.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.418] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:02.418] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.419] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[17:41:02.419] MultisessionFuture started
[17:41:02.419] - Launch lazy future ... done
[17:41:02.420] run() for ‘MultisessionFuture’ ... done
[17:41:02.420] Created future:
[17:41:02.420] MultisessionFuture:
[17:41:02.420] Label: ‘future_vapply-2’
[17:41:02.420] Expression:
[17:41:02.420] {
[17:41:02.420]     do.call(function(...) {
[17:41:02.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.420]             on.exit(options(oopts), add = TRUE)
[17:41:02.420]         }
[17:41:02.420]         {
[17:41:02.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.420]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.420]             })
[17:41:02.420]         }
[17:41:02.420]     }, args = future.call.arguments)
[17:41:02.420] }
[17:41:02.420] Lazy evaluation: FALSE
[17:41:02.420] Asynchronous evaluation: TRUE
[17:41:02.420] Local evaluation: TRUE
[17:41:02.420] Environment: R_GlobalEnv
[17:41:02.420] Capture standard output: TRUE
[17:41:02.420] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:02.420] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:02.420] Packages: 1 packages (‘future.apply’)
[17:41:02.420] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:02.420] Resolved: FALSE
[17:41:02.420] Value: <not collected>
[17:41:02.420] Conditions captured: <none>
[17:41:02.420] Early signaling: FALSE
[17:41:02.420] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:02.420] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.432] Chunk #2 of 2 ... DONE
[17:41:02.432] Launching 2 futures (chunks) ... DONE
[17:41:02.432] Resolving 2 futures (chunks) ...
[17:41:02.432] resolve() on list ...
[17:41:02.432]  recursive: 0
[17:41:02.432]  length: 2
[17:41:02.432] 
[17:41:02.433] receiveMessageFromWorker() for ClusterFuture ...
[17:41:02.433] - Validating connection of MultisessionFuture
[17:41:02.433] - received message: FutureResult
[17:41:02.434] - Received FutureResult
[17:41:02.434] - Erased future from FutureRegistry
[17:41:02.434] result() for ClusterFuture ...
[17:41:02.434] - result already collected: FutureResult
[17:41:02.434] result() for ClusterFuture ... done
[17:41:02.434] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:02.434] Future #1
[17:41:02.434] result() for ClusterFuture ...
[17:41:02.434] - result already collected: FutureResult
[17:41:02.434] result() for ClusterFuture ... done
[17:41:02.434] result() for ClusterFuture ...
[17:41:02.435] - result already collected: FutureResult
[17:41:02.435] result() for ClusterFuture ... done
[17:41:02.435] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:02.435] - nx: 2
[17:41:02.435] - relay: TRUE
[17:41:02.435] - stdout: TRUE
[17:41:02.435] - signal: TRUE
[17:41:02.435] - resignal: FALSE
[17:41:02.435] - force: TRUE
[17:41:02.435] - relayed: [n=2] FALSE, FALSE
[17:41:02.435] - queued futures: [n=2] FALSE, FALSE
[17:41:02.436]  - until=1
[17:41:02.436]  - relaying element #1
[17:41:02.436] result() for ClusterFuture ...
[17:41:02.436] - result already collected: FutureResult
[17:41:02.436] result() for ClusterFuture ... done
[17:41:02.436] result() for ClusterFuture ...
[17:41:02.436] - result already collected: FutureResult
[17:41:02.436] result() for ClusterFuture ... done
[17:41:02.436] result() for ClusterFuture ...
[17:41:02.436] - result already collected: FutureResult
[17:41:02.436] result() for ClusterFuture ... done
[17:41:02.437] result() for ClusterFuture ...
[17:41:02.437] - result already collected: FutureResult
[17:41:02.437] result() for ClusterFuture ... done
[17:41:02.437] - relayed: [n=2] TRUE, FALSE
[17:41:02.437] - queued futures: [n=2] TRUE, FALSE
[17:41:02.437] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:02.437]  length: 1 (resolved future 1)
[17:41:02.468] receiveMessageFromWorker() for ClusterFuture ...
[17:41:02.468] - Validating connection of MultisessionFuture
[17:41:02.469] - received message: FutureResult
[17:41:02.469] - Received FutureResult
[17:41:02.469] - Erased future from FutureRegistry
[17:41:02.469] result() for ClusterFuture ...
[17:41:02.469] - result already collected: FutureResult
[17:41:02.469] result() for ClusterFuture ... done
[17:41:02.469] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:02.469] Future #2
[17:41:02.469] result() for ClusterFuture ...
[17:41:02.470] - result already collected: FutureResult
[17:41:02.470] result() for ClusterFuture ... done
[17:41:02.470] result() for ClusterFuture ...
[17:41:02.470] - result already collected: FutureResult
[17:41:02.470] result() for ClusterFuture ... done
[17:41:02.470] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:02.470] - nx: 2
[17:41:02.470] - relay: TRUE
[17:41:02.470] - stdout: TRUE
[17:41:02.470] - signal: TRUE
[17:41:02.470] - resignal: FALSE
[17:41:02.471] - force: TRUE
[17:41:02.471] - relayed: [n=2] TRUE, FALSE
[17:41:02.471] - queued futures: [n=2] TRUE, FALSE
[17:41:02.471]  - until=2
[17:41:02.471]  - relaying element #2
[17:41:02.471] result() for ClusterFuture ...
[17:41:02.471] - result already collected: FutureResult
[17:41:02.471] result() for ClusterFuture ... done
[17:41:02.471] result() for ClusterFuture ...
[17:41:02.471] - result already collected: FutureResult
[17:41:02.471] result() for ClusterFuture ... done
[17:41:02.472] result() for ClusterFuture ...
[17:41:02.472] - result already collected: FutureResult
[17:41:02.472] result() for ClusterFuture ... done
[17:41:02.472] result() for ClusterFuture ...
[17:41:02.472] - result already collected: FutureResult
[17:41:02.472] result() for ClusterFuture ... done
[17:41:02.472] - relayed: [n=2] TRUE, TRUE
[17:41:02.472] - queued futures: [n=2] TRUE, TRUE
[17:41:02.472] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:02.472]  length: 0 (resolved future 2)
[17:41:02.473] Relaying remaining futures
[17:41:02.473] signalConditionsASAP(NULL, pos=0) ...
[17:41:02.473] - nx: 2
[17:41:02.473] - relay: TRUE
[17:41:02.473] - stdout: TRUE
[17:41:02.473] - signal: TRUE
[17:41:02.473] - resignal: FALSE
[17:41:02.473] - force: TRUE
[17:41:02.473] - relayed: [n=2] TRUE, TRUE
[17:41:02.473] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:02.473] - relayed: [n=2] TRUE, TRUE
[17:41:02.473] - queued futures: [n=2] TRUE, TRUE
[17:41:02.474] signalConditionsASAP(NULL, pos=0) ... done
[17:41:02.474] resolve() on list ... DONE
[17:41:02.474] result() for ClusterFuture ...
[17:41:02.474] - result already collected: FutureResult
[17:41:02.474] result() for ClusterFuture ... done
[17:41:02.474] result() for ClusterFuture ...
[17:41:02.474] - result already collected: FutureResult
[17:41:02.474] result() for ClusterFuture ... done
[17:41:02.474] result() for ClusterFuture ...
[17:41:02.474] - result already collected: FutureResult
[17:41:02.474] result() for ClusterFuture ... done
[17:41:02.474] result() for ClusterFuture ...
[17:41:02.475] - result already collected: FutureResult
[17:41:02.475] result() for ClusterFuture ... done
[17:41:02.475]  - Number of value chunks collected: 2
[17:41:02.475] Resolving 2 futures (chunks) ... DONE
[17:41:02.475] Reducing values from 2 chunks ...
[17:41:02.475]  - Number of values collected after concatenation: 4
[17:41:02.475]  - Number of values expected: 4
[17:41:02.475] Reducing values from 2 chunks ... DONE
[17:41:02.475] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:41:02.477] future_lapply() ...
[17:41:02.482] Number of chunks: 2
[17:41:02.482] getGlobalsAndPackagesXApply() ...
[17:41:02.483]  - future.globals: TRUE
[17:41:02.483] getGlobalsAndPackages() ...
[17:41:02.483] Searching for globals...
[17:41:02.486] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:41:02.486] Searching for globals ... DONE
[17:41:02.486] Resolving globals: FALSE
[17:41:02.487] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:41:02.487] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:41:02.487] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:02.488] - packages: [1] ‘future.apply’
[17:41:02.488] getGlobalsAndPackages() ... DONE
[17:41:02.488]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:02.488]  - needed namespaces: [n=1] ‘future.apply’
[17:41:02.488] Finding globals ... DONE
[17:41:02.488]  - use_args: TRUE
[17:41:02.488]  - Getting '...' globals ...
[17:41:02.488] resolve() on list ...
[17:41:02.489]  recursive: 0
[17:41:02.489]  length: 1
[17:41:02.489]  elements: ‘...’
[17:41:02.489]  length: 0 (resolved future 1)
[17:41:02.489] resolve() on list ... DONE
[17:41:02.489]    - '...' content: [n=0] 
[17:41:02.489] List of 1
[17:41:02.489]  $ ...: list()
[17:41:02.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:02.489]  - attr(*, "where")=List of 1
[17:41:02.489]   ..$ ...:<environment: 0x564f31afc1d8> 
[17:41:02.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:02.489]  - attr(*, "resolved")= logi TRUE
[17:41:02.489]  - attr(*, "total_size")= num NA
[17:41:02.492]  - Getting '...' globals ... DONE
[17:41:02.492] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:02.492] List of 8
[17:41:02.492]  $ ...future.FUN:function (x, ...)  
[17:41:02.492]  $ x_FUN        :function (x)  
[17:41:02.492]  $ times        : int 1
[17:41:02.492]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:02.492]  $ stop_if_not  :function (...)  
[17:41:02.492]  $ dim          : NULL
[17:41:02.492]  $ valid_types  : chr "logical"
[17:41:02.492]  $ ...          : list()
[17:41:02.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:02.492]  - attr(*, "where")=List of 8
[17:41:02.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:02.492]   ..$ ...          :<environment: 0x564f31afc1d8> 
[17:41:02.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:02.492]  - attr(*, "resolved")= logi FALSE
[17:41:02.492]  - attr(*, "total_size")= num 94200
[17:41:02.497] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:41:02.497] getGlobalsAndPackagesXApply() ... DONE
[17:41:02.497] Number of futures (= number of chunks): 2
[17:41:02.498] Launching 2 futures (chunks) ...
[17:41:02.498] Chunk #1 of 2 ...
[17:41:02.498]  - Finding globals in 'X' for chunk #1 ...
[17:41:02.498] getGlobalsAndPackages() ...
[17:41:02.498] Searching for globals...
[17:41:02.498] 
[17:41:02.498] Searching for globals ... DONE
[17:41:02.498] - globals: [0] <none>
[17:41:02.498] getGlobalsAndPackages() ... DONE
[17:41:02.499]    + additional globals found: [n=0] 
[17:41:02.499]    + additional namespaces needed: [n=0] 
[17:41:02.499]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:02.499]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[17:41:02.499]  - seeds: <none>
[17:41:02.499] getGlobalsAndPackages() ...
[17:41:02.499] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.499] Resolving globals: FALSE
[17:41:02.499] Tweak future expression to call with '...' arguments ...
[17:41:02.500] {
[17:41:02.500]     do.call(function(...) {
[17:41:02.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.500]             on.exit(options(oopts), add = TRUE)
[17:41:02.500]         }
[17:41:02.500]         {
[17:41:02.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.500]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.500]             })
[17:41:02.500]         }
[17:41:02.500]     }, args = future.call.arguments)
[17:41:02.500] }
[17:41:02.500] Tweak future expression to call with '...' arguments ... DONE
[17:41:02.500] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.500] - packages: [1] ‘future.apply’
[17:41:02.501] getGlobalsAndPackages() ... DONE
[17:41:02.501] run() for ‘Future’ ...
[17:41:02.501] - state: ‘created’
[17:41:02.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:02.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:02.523]   - Field: ‘node’
[17:41:02.523]   - Field: ‘label’
[17:41:02.523]   - Field: ‘local’
[17:41:02.523]   - Field: ‘owner’
[17:41:02.523]   - Field: ‘envir’
[17:41:02.523]   - Field: ‘workers’
[17:41:02.523]   - Field: ‘packages’
[17:41:02.524]   - Field: ‘gc’
[17:41:02.524]   - Field: ‘conditions’
[17:41:02.524]   - Field: ‘persistent’
[17:41:02.524]   - Field: ‘expr’
[17:41:02.524]   - Field: ‘uuid’
[17:41:02.524]   - Field: ‘seed’
[17:41:02.524]   - Field: ‘version’
[17:41:02.524]   - Field: ‘result’
[17:41:02.524]   - Field: ‘asynchronous’
[17:41:02.524]   - Field: ‘calls’
[17:41:02.524]   - Field: ‘globals’
[17:41:02.525]   - Field: ‘stdout’
[17:41:02.525]   - Field: ‘earlySignal’
[17:41:02.525]   - Field: ‘lazy’
[17:41:02.525]   - Field: ‘state’
[17:41:02.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:02.525] - Launch lazy future ...
[17:41:02.525] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:02.525] Packages needed by future strategies (n = 0): <none>
[17:41:02.526] {
[17:41:02.526]     {
[17:41:02.526]         {
[17:41:02.526]             ...future.startTime <- base::Sys.time()
[17:41:02.526]             {
[17:41:02.526]                 {
[17:41:02.526]                   {
[17:41:02.526]                     {
[17:41:02.526]                       {
[17:41:02.526]                         base::local({
[17:41:02.526]                           has_future <- base::requireNamespace("future", 
[17:41:02.526]                             quietly = TRUE)
[17:41:02.526]                           if (has_future) {
[17:41:02.526]                             ns <- base::getNamespace("future")
[17:41:02.526]                             version <- ns[[".package"]][["version"]]
[17:41:02.526]                             if (is.null(version)) 
[17:41:02.526]                               version <- utils::packageVersion("future")
[17:41:02.526]                           }
[17:41:02.526]                           else {
[17:41:02.526]                             version <- NULL
[17:41:02.526]                           }
[17:41:02.526]                           if (!has_future || version < "1.8.0") {
[17:41:02.526]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:02.526]                               "", base::R.version$version.string), 
[17:41:02.526]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:02.526]                                 base::R.version$platform, 8 * 
[17:41:02.526]                                   base::.Machine$sizeof.pointer), 
[17:41:02.526]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:02.526]                                 "release", "version")], collapse = " "), 
[17:41:02.526]                               hostname = base::Sys.info()[["nodename"]])
[17:41:02.526]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:02.526]                               info)
[17:41:02.526]                             info <- base::paste(info, collapse = "; ")
[17:41:02.526]                             if (!has_future) {
[17:41:02.526]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:02.526]                                 info)
[17:41:02.526]                             }
[17:41:02.526]                             else {
[17:41:02.526]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:02.526]                                 info, version)
[17:41:02.526]                             }
[17:41:02.526]                             base::stop(msg)
[17:41:02.526]                           }
[17:41:02.526]                         })
[17:41:02.526]                       }
[17:41:02.526]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:02.526]                       base::options(mc.cores = 1L)
[17:41:02.526]                     }
[17:41:02.526]                     base::local({
[17:41:02.526]                       for (pkg in "future.apply") {
[17:41:02.526]                         base::loadNamespace(pkg)
[17:41:02.526]                         base::library(pkg, character.only = TRUE)
[17:41:02.526]                       }
[17:41:02.526]                     })
[17:41:02.526]                   }
[17:41:02.526]                   options(future.plan = NULL)
[17:41:02.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:02.526]                 }
[17:41:02.526]                 ...future.workdir <- getwd()
[17:41:02.526]             }
[17:41:02.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:02.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:02.526]         }
[17:41:02.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:02.526]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[17:41:02.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:02.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:02.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:02.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:02.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:02.526]             base::names(...future.oldOptions))
[17:41:02.526]     }
[17:41:02.526]     if (FALSE) {
[17:41:02.526]     }
[17:41:02.526]     else {
[17:41:02.526]         if (TRUE) {
[17:41:02.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:02.526]                 open = "w")
[17:41:02.526]         }
[17:41:02.526]         else {
[17:41:02.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:02.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:02.526]         }
[17:41:02.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:02.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:02.526]             base::sink(type = "output", split = FALSE)
[17:41:02.526]             base::close(...future.stdout)
[17:41:02.526]         }, add = TRUE)
[17:41:02.526]     }
[17:41:02.526]     ...future.frame <- base::sys.nframe()
[17:41:02.526]     ...future.conditions <- base::list()
[17:41:02.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:02.526]     if (FALSE) {
[17:41:02.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:02.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:02.526]     }
[17:41:02.526]     ...future.result <- base::tryCatch({
[17:41:02.526]         base::withCallingHandlers({
[17:41:02.526]             ...future.value <- base::withVisible(base::local({
[17:41:02.526]                 ...future.makeSendCondition <- local({
[17:41:02.526]                   sendCondition <- NULL
[17:41:02.526]                   function(frame = 1L) {
[17:41:02.526]                     if (is.function(sendCondition)) 
[17:41:02.526]                       return(sendCondition)
[17:41:02.526]                     ns <- getNamespace("parallel")
[17:41:02.526]                     if (exists("sendData", mode = "function", 
[17:41:02.526]                       envir = ns)) {
[17:41:02.526]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:02.526]                         envir = ns)
[17:41:02.526]                       envir <- sys.frame(frame)
[17:41:02.526]                       master <- NULL
[17:41:02.526]                       while (!identical(envir, .GlobalEnv) && 
[17:41:02.526]                         !identical(envir, emptyenv())) {
[17:41:02.526]                         if (exists("master", mode = "list", envir = envir, 
[17:41:02.526]                           inherits = FALSE)) {
[17:41:02.526]                           master <- get("master", mode = "list", 
[17:41:02.526]                             envir = envir, inherits = FALSE)
[17:41:02.526]                           if (inherits(master, c("SOCKnode", 
[17:41:02.526]                             "SOCK0node"))) {
[17:41:02.526]                             sendCondition <<- function(cond) {
[17:41:02.526]                               data <- list(type = "VALUE", value = cond, 
[17:41:02.526]                                 success = TRUE)
[17:41:02.526]                               parallel_sendData(master, data)
[17:41:02.526]                             }
[17:41:02.526]                             return(sendCondition)
[17:41:02.526]                           }
[17:41:02.526]                         }
[17:41:02.526]                         frame <- frame + 1L
[17:41:02.526]                         envir <- sys.frame(frame)
[17:41:02.526]                       }
[17:41:02.526]                     }
[17:41:02.526]                     sendCondition <<- function(cond) NULL
[17:41:02.526]                   }
[17:41:02.526]                 })
[17:41:02.526]                 withCallingHandlers({
[17:41:02.526]                   {
[17:41:02.526]                     do.call(function(...) {
[17:41:02.526]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.526]                       if (!identical(...future.globals.maxSize.org, 
[17:41:02.526]                         ...future.globals.maxSize)) {
[17:41:02.526]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.526]                         on.exit(options(oopts), add = TRUE)
[17:41:02.526]                       }
[17:41:02.526]                       {
[17:41:02.526]                         lapply(seq_along(...future.elements_ii), 
[17:41:02.526]                           FUN = function(jj) {
[17:41:02.526]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.526]                             ...future.FUN(...future.X_jj, ...)
[17:41:02.526]                           })
[17:41:02.526]                       }
[17:41:02.526]                     }, args = future.call.arguments)
[17:41:02.526]                   }
[17:41:02.526]                 }, immediateCondition = function(cond) {
[17:41:02.526]                   sendCondition <- ...future.makeSendCondition()
[17:41:02.526]                   sendCondition(cond)
[17:41:02.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.526]                   {
[17:41:02.526]                     inherits <- base::inherits
[17:41:02.526]                     invokeRestart <- base::invokeRestart
[17:41:02.526]                     is.null <- base::is.null
[17:41:02.526]                     muffled <- FALSE
[17:41:02.526]                     if (inherits(cond, "message")) {
[17:41:02.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:02.526]                       if (muffled) 
[17:41:02.526]                         invokeRestart("muffleMessage")
[17:41:02.526]                     }
[17:41:02.526]                     else if (inherits(cond, "warning")) {
[17:41:02.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:02.526]                       if (muffled) 
[17:41:02.526]                         invokeRestart("muffleWarning")
[17:41:02.526]                     }
[17:41:02.526]                     else if (inherits(cond, "condition")) {
[17:41:02.526]                       if (!is.null(pattern)) {
[17:41:02.526]                         computeRestarts <- base::computeRestarts
[17:41:02.526]                         grepl <- base::grepl
[17:41:02.526]                         restarts <- computeRestarts(cond)
[17:41:02.526]                         for (restart in restarts) {
[17:41:02.526]                           name <- restart$name
[17:41:02.526]                           if (is.null(name)) 
[17:41:02.526]                             next
[17:41:02.526]                           if (!grepl(pattern, name)) 
[17:41:02.526]                             next
[17:41:02.526]                           invokeRestart(restart)
[17:41:02.526]                           muffled <- TRUE
[17:41:02.526]                           break
[17:41:02.526]                         }
[17:41:02.526]                       }
[17:41:02.526]                     }
[17:41:02.526]                     invisible(muffled)
[17:41:02.526]                   }
[17:41:02.526]                   muffleCondition(cond)
[17:41:02.526]                 })
[17:41:02.526]             }))
[17:41:02.526]             future::FutureResult(value = ...future.value$value, 
[17:41:02.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.526]                   ...future.rng), globalenv = if (FALSE) 
[17:41:02.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:02.526]                     ...future.globalenv.names))
[17:41:02.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:02.526]         }, condition = base::local({
[17:41:02.526]             c <- base::c
[17:41:02.526]             inherits <- base::inherits
[17:41:02.526]             invokeRestart <- base::invokeRestart
[17:41:02.526]             length <- base::length
[17:41:02.526]             list <- base::list
[17:41:02.526]             seq.int <- base::seq.int
[17:41:02.526]             signalCondition <- base::signalCondition
[17:41:02.526]             sys.calls <- base::sys.calls
[17:41:02.526]             `[[` <- base::`[[`
[17:41:02.526]             `+` <- base::`+`
[17:41:02.526]             `<<-` <- base::`<<-`
[17:41:02.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:02.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:02.526]                   3L)]
[17:41:02.526]             }
[17:41:02.526]             function(cond) {
[17:41:02.526]                 is_error <- inherits(cond, "error")
[17:41:02.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:02.526]                   NULL)
[17:41:02.526]                 if (is_error) {
[17:41:02.526]                   sessionInformation <- function() {
[17:41:02.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:02.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:02.526]                       search = base::search(), system = base::Sys.info())
[17:41:02.526]                   }
[17:41:02.526]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:02.526]                     cond$call), session = sessionInformation(), 
[17:41:02.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:02.526]                   signalCondition(cond)
[17:41:02.526]                 }
[17:41:02.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:02.526]                 "immediateCondition"))) {
[17:41:02.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:02.526]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:02.526]                   if (TRUE && !signal) {
[17:41:02.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.526]                     {
[17:41:02.526]                       inherits <- base::inherits
[17:41:02.526]                       invokeRestart <- base::invokeRestart
[17:41:02.526]                       is.null <- base::is.null
[17:41:02.526]                       muffled <- FALSE
[17:41:02.526]                       if (inherits(cond, "message")) {
[17:41:02.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.526]                         if (muffled) 
[17:41:02.526]                           invokeRestart("muffleMessage")
[17:41:02.526]                       }
[17:41:02.526]                       else if (inherits(cond, "warning")) {
[17:41:02.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.526]                         if (muffled) 
[17:41:02.526]                           invokeRestart("muffleWarning")
[17:41:02.526]                       }
[17:41:02.526]                       else if (inherits(cond, "condition")) {
[17:41:02.526]                         if (!is.null(pattern)) {
[17:41:02.526]                           computeRestarts <- base::computeRestarts
[17:41:02.526]                           grepl <- base::grepl
[17:41:02.526]                           restarts <- computeRestarts(cond)
[17:41:02.526]                           for (restart in restarts) {
[17:41:02.526]                             name <- restart$name
[17:41:02.526]                             if (is.null(name)) 
[17:41:02.526]                               next
[17:41:02.526]                             if (!grepl(pattern, name)) 
[17:41:02.526]                               next
[17:41:02.526]                             invokeRestart(restart)
[17:41:02.526]                             muffled <- TRUE
[17:41:02.526]                             break
[17:41:02.526]                           }
[17:41:02.526]                         }
[17:41:02.526]                       }
[17:41:02.526]                       invisible(muffled)
[17:41:02.526]                     }
[17:41:02.526]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.526]                   }
[17:41:02.526]                 }
[17:41:02.526]                 else {
[17:41:02.526]                   if (TRUE) {
[17:41:02.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.526]                     {
[17:41:02.526]                       inherits <- base::inherits
[17:41:02.526]                       invokeRestart <- base::invokeRestart
[17:41:02.526]                       is.null <- base::is.null
[17:41:02.526]                       muffled <- FALSE
[17:41:02.526]                       if (inherits(cond, "message")) {
[17:41:02.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.526]                         if (muffled) 
[17:41:02.526]                           invokeRestart("muffleMessage")
[17:41:02.526]                       }
[17:41:02.526]                       else if (inherits(cond, "warning")) {
[17:41:02.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.526]                         if (muffled) 
[17:41:02.526]                           invokeRestart("muffleWarning")
[17:41:02.526]                       }
[17:41:02.526]                       else if (inherits(cond, "condition")) {
[17:41:02.526]                         if (!is.null(pattern)) {
[17:41:02.526]                           computeRestarts <- base::computeRestarts
[17:41:02.526]                           grepl <- base::grepl
[17:41:02.526]                           restarts <- computeRestarts(cond)
[17:41:02.526]                           for (restart in restarts) {
[17:41:02.526]                             name <- restart$name
[17:41:02.526]                             if (is.null(name)) 
[17:41:02.526]                               next
[17:41:02.526]                             if (!grepl(pattern, name)) 
[17:41:02.526]                               next
[17:41:02.526]                             invokeRestart(restart)
[17:41:02.526]                             muffled <- TRUE
[17:41:02.526]                             break
[17:41:02.526]                           }
[17:41:02.526]                         }
[17:41:02.526]                       }
[17:41:02.526]                       invisible(muffled)
[17:41:02.526]                     }
[17:41:02.526]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.526]                   }
[17:41:02.526]                 }
[17:41:02.526]             }
[17:41:02.526]         }))
[17:41:02.526]     }, error = function(ex) {
[17:41:02.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:02.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.526]                 ...future.rng), started = ...future.startTime, 
[17:41:02.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:02.526]             version = "1.8"), class = "FutureResult")
[17:41:02.526]     }, finally = {
[17:41:02.526]         if (!identical(...future.workdir, getwd())) 
[17:41:02.526]             setwd(...future.workdir)
[17:41:02.526]         {
[17:41:02.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:02.526]                 ...future.oldOptions$nwarnings <- NULL
[17:41:02.526]             }
[17:41:02.526]             base::options(...future.oldOptions)
[17:41:02.526]             if (.Platform$OS.type == "windows") {
[17:41:02.526]                 old_names <- names(...future.oldEnvVars)
[17:41:02.526]                 envs <- base::Sys.getenv()
[17:41:02.526]                 names <- names(envs)
[17:41:02.526]                 common <- intersect(names, old_names)
[17:41:02.526]                 added <- setdiff(names, old_names)
[17:41:02.526]                 removed <- setdiff(old_names, names)
[17:41:02.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:02.526]                   envs[common]]
[17:41:02.526]                 NAMES <- toupper(changed)
[17:41:02.526]                 args <- list()
[17:41:02.526]                 for (kk in seq_along(NAMES)) {
[17:41:02.526]                   name <- changed[[kk]]
[17:41:02.526]                   NAME <- NAMES[[kk]]
[17:41:02.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.526]                     next
[17:41:02.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.526]                 }
[17:41:02.526]                 NAMES <- toupper(added)
[17:41:02.526]                 for (kk in seq_along(NAMES)) {
[17:41:02.526]                   name <- added[[kk]]
[17:41:02.526]                   NAME <- NAMES[[kk]]
[17:41:02.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.526]                     next
[17:41:02.526]                   args[[name]] <- ""
[17:41:02.526]                 }
[17:41:02.526]                 NAMES <- toupper(removed)
[17:41:02.526]                 for (kk in seq_along(NAMES)) {
[17:41:02.526]                   name <- removed[[kk]]
[17:41:02.526]                   NAME <- NAMES[[kk]]
[17:41:02.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.526]                     next
[17:41:02.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.526]                 }
[17:41:02.526]                 if (length(args) > 0) 
[17:41:02.526]                   base::do.call(base::Sys.setenv, args = args)
[17:41:02.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:02.526]             }
[17:41:02.526]             else {
[17:41:02.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:02.526]             }
[17:41:02.526]             {
[17:41:02.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:02.526]                   0L) {
[17:41:02.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:02.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:02.526]                   base::options(opts)
[17:41:02.526]                 }
[17:41:02.526]                 {
[17:41:02.526]                   {
[17:41:02.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:02.526]                     NULL
[17:41:02.526]                   }
[17:41:02.526]                   options(future.plan = NULL)
[17:41:02.526]                   if (is.na(NA_character_)) 
[17:41:02.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:02.526]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:02.526]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:02.526]                     envir = parent.frame()) 
[17:41:02.526]                   {
[17:41:02.526]                     if (is.function(workers)) 
[17:41:02.526]                       workers <- workers()
[17:41:02.526]                     workers <- structure(as.integer(workers), 
[17:41:02.526]                       class = class(workers))
[17:41:02.526]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:02.526]                       workers >= 1)
[17:41:02.526]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:02.526]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:02.526]                     }
[17:41:02.526]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:02.526]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:02.526]                       envir = envir)
[17:41:02.526]                     if (!future$lazy) 
[17:41:02.526]                       future <- run(future)
[17:41:02.526]                     invisible(future)
[17:41:02.526]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:02.526]                 }
[17:41:02.526]             }
[17:41:02.526]         }
[17:41:02.526]     })
[17:41:02.526]     if (TRUE) {
[17:41:02.526]         base::sink(type = "output", split = FALSE)
[17:41:02.526]         if (TRUE) {
[17:41:02.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:02.526]         }
[17:41:02.526]         else {
[17:41:02.526]             ...future.result["stdout"] <- base::list(NULL)
[17:41:02.526]         }
[17:41:02.526]         base::close(...future.stdout)
[17:41:02.526]         ...future.stdout <- NULL
[17:41:02.526]     }
[17:41:02.526]     ...future.result$conditions <- ...future.conditions
[17:41:02.526]     ...future.result$finished <- base::Sys.time()
[17:41:02.526]     ...future.result
[17:41:02.526] }
[17:41:02.529] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[17:41:02.529] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:02.571] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:02.572] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:41:02.572] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:41:02.572] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:02.572] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:02.573] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:02.615] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:02.615] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:02.659] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:02.659] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:41:02.660] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:41:02.660] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[17:41:02.660] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[17:41:02.660] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:02.661] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:02.661] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[17:41:02.661] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[17:41:02.661] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:02.662] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:02.662] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:02.662] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:02.662] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[17:41:02.663] MultisessionFuture started
[17:41:02.663] - Launch lazy future ... done
[17:41:02.663] run() for ‘MultisessionFuture’ ... done
[17:41:02.663] Created future:
[17:41:02.663] MultisessionFuture:
[17:41:02.663] Label: ‘future_vapply-1’
[17:41:02.663] Expression:
[17:41:02.663] {
[17:41:02.663]     do.call(function(...) {
[17:41:02.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.663]             on.exit(options(oopts), add = TRUE)
[17:41:02.663]         }
[17:41:02.663]         {
[17:41:02.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.663]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.663]             })
[17:41:02.663]         }
[17:41:02.663]     }, args = future.call.arguments)
[17:41:02.663] }
[17:41:02.663] Lazy evaluation: FALSE
[17:41:02.663] Asynchronous evaluation: TRUE
[17:41:02.663] Local evaluation: TRUE
[17:41:02.663] Environment: R_GlobalEnv
[17:41:02.663] Capture standard output: TRUE
[17:41:02.663] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:02.663] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:02.663] Packages: 1 packages (‘future.apply’)
[17:41:02.663] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:02.663] Resolved: FALSE
[17:41:02.663] Value: <not collected>
[17:41:02.663] Conditions captured: <none>
[17:41:02.663] Early signaling: FALSE
[17:41:02.663] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:02.663] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.675] Chunk #1 of 2 ... DONE
[17:41:02.675] Chunk #2 of 2 ...
[17:41:02.675]  - Finding globals in 'X' for chunk #2 ...
[17:41:02.676] getGlobalsAndPackages() ...
[17:41:02.676] Searching for globals...
[17:41:02.676] 
[17:41:02.676] Searching for globals ... DONE
[17:41:02.676] - globals: [0] <none>
[17:41:02.676] getGlobalsAndPackages() ... DONE
[17:41:02.676]    + additional globals found: [n=0] 
[17:41:02.676]    + additional namespaces needed: [n=0] 
[17:41:02.676]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:02.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:41:02.677]  - seeds: <none>
[17:41:02.677] getGlobalsAndPackages() ...
[17:41:02.677] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.677] Resolving globals: FALSE
[17:41:02.677] Tweak future expression to call with '...' arguments ...
[17:41:02.677] {
[17:41:02.677]     do.call(function(...) {
[17:41:02.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.677]             on.exit(options(oopts), add = TRUE)
[17:41:02.677]         }
[17:41:02.677]         {
[17:41:02.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.677]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.677]             })
[17:41:02.677]         }
[17:41:02.677]     }, args = future.call.arguments)
[17:41:02.677] }
[17:41:02.677] Tweak future expression to call with '...' arguments ... DONE
[17:41:02.678] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.678] - packages: [1] ‘future.apply’
[17:41:02.678] getGlobalsAndPackages() ... DONE
[17:41:02.679] run() for ‘Future’ ...
[17:41:02.679] - state: ‘created’
[17:41:02.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:02.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:02.693]   - Field: ‘node’
[17:41:02.694]   - Field: ‘label’
[17:41:02.694]   - Field: ‘local’
[17:41:02.694]   - Field: ‘owner’
[17:41:02.694]   - Field: ‘envir’
[17:41:02.694]   - Field: ‘workers’
[17:41:02.694]   - Field: ‘packages’
[17:41:02.694]   - Field: ‘gc’
[17:41:02.694]   - Field: ‘conditions’
[17:41:02.694]   - Field: ‘persistent’
[17:41:02.694]   - Field: ‘expr’
[17:41:02.694]   - Field: ‘uuid’
[17:41:02.695]   - Field: ‘seed’
[17:41:02.695]   - Field: ‘version’
[17:41:02.695]   - Field: ‘result’
[17:41:02.695]   - Field: ‘asynchronous’
[17:41:02.695]   - Field: ‘calls’
[17:41:02.695]   - Field: ‘globals’
[17:41:02.695]   - Field: ‘stdout’
[17:41:02.695]   - Field: ‘earlySignal’
[17:41:02.695]   - Field: ‘lazy’
[17:41:02.695]   - Field: ‘state’
[17:41:02.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:02.696] - Launch lazy future ...
[17:41:02.696] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:02.696] Packages needed by future strategies (n = 0): <none>
[17:41:02.697] {
[17:41:02.697]     {
[17:41:02.697]         {
[17:41:02.697]             ...future.startTime <- base::Sys.time()
[17:41:02.697]             {
[17:41:02.697]                 {
[17:41:02.697]                   {
[17:41:02.697]                     {
[17:41:02.697]                       {
[17:41:02.697]                         base::local({
[17:41:02.697]                           has_future <- base::requireNamespace("future", 
[17:41:02.697]                             quietly = TRUE)
[17:41:02.697]                           if (has_future) {
[17:41:02.697]                             ns <- base::getNamespace("future")
[17:41:02.697]                             version <- ns[[".package"]][["version"]]
[17:41:02.697]                             if (is.null(version)) 
[17:41:02.697]                               version <- utils::packageVersion("future")
[17:41:02.697]                           }
[17:41:02.697]                           else {
[17:41:02.697]                             version <- NULL
[17:41:02.697]                           }
[17:41:02.697]                           if (!has_future || version < "1.8.0") {
[17:41:02.697]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:02.697]                               "", base::R.version$version.string), 
[17:41:02.697]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:02.697]                                 base::R.version$platform, 8 * 
[17:41:02.697]                                   base::.Machine$sizeof.pointer), 
[17:41:02.697]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:02.697]                                 "release", "version")], collapse = " "), 
[17:41:02.697]                               hostname = base::Sys.info()[["nodename"]])
[17:41:02.697]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:02.697]                               info)
[17:41:02.697]                             info <- base::paste(info, collapse = "; ")
[17:41:02.697]                             if (!has_future) {
[17:41:02.697]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:02.697]                                 info)
[17:41:02.697]                             }
[17:41:02.697]                             else {
[17:41:02.697]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:02.697]                                 info, version)
[17:41:02.697]                             }
[17:41:02.697]                             base::stop(msg)
[17:41:02.697]                           }
[17:41:02.697]                         })
[17:41:02.697]                       }
[17:41:02.697]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:02.697]                       base::options(mc.cores = 1L)
[17:41:02.697]                     }
[17:41:02.697]                     base::local({
[17:41:02.697]                       for (pkg in "future.apply") {
[17:41:02.697]                         base::loadNamespace(pkg)
[17:41:02.697]                         base::library(pkg, character.only = TRUE)
[17:41:02.697]                       }
[17:41:02.697]                     })
[17:41:02.697]                   }
[17:41:02.697]                   options(future.plan = NULL)
[17:41:02.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:02.697]                 }
[17:41:02.697]                 ...future.workdir <- getwd()
[17:41:02.697]             }
[17:41:02.697]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:02.697]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:02.697]         }
[17:41:02.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:02.697]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:41:02.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:02.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:02.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:02.697]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:02.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:02.697]             base::names(...future.oldOptions))
[17:41:02.697]     }
[17:41:02.697]     if (FALSE) {
[17:41:02.697]     }
[17:41:02.697]     else {
[17:41:02.697]         if (TRUE) {
[17:41:02.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:02.697]                 open = "w")
[17:41:02.697]         }
[17:41:02.697]         else {
[17:41:02.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:02.697]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:02.697]         }
[17:41:02.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:02.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:02.697]             base::sink(type = "output", split = FALSE)
[17:41:02.697]             base::close(...future.stdout)
[17:41:02.697]         }, add = TRUE)
[17:41:02.697]     }
[17:41:02.697]     ...future.frame <- base::sys.nframe()
[17:41:02.697]     ...future.conditions <- base::list()
[17:41:02.697]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:02.697]     if (FALSE) {
[17:41:02.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:02.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:02.697]     }
[17:41:02.697]     ...future.result <- base::tryCatch({
[17:41:02.697]         base::withCallingHandlers({
[17:41:02.697]             ...future.value <- base::withVisible(base::local({
[17:41:02.697]                 ...future.makeSendCondition <- local({
[17:41:02.697]                   sendCondition <- NULL
[17:41:02.697]                   function(frame = 1L) {
[17:41:02.697]                     if (is.function(sendCondition)) 
[17:41:02.697]                       return(sendCondition)
[17:41:02.697]                     ns <- getNamespace("parallel")
[17:41:02.697]                     if (exists("sendData", mode = "function", 
[17:41:02.697]                       envir = ns)) {
[17:41:02.697]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:02.697]                         envir = ns)
[17:41:02.697]                       envir <- sys.frame(frame)
[17:41:02.697]                       master <- NULL
[17:41:02.697]                       while (!identical(envir, .GlobalEnv) && 
[17:41:02.697]                         !identical(envir, emptyenv())) {
[17:41:02.697]                         if (exists("master", mode = "list", envir = envir, 
[17:41:02.697]                           inherits = FALSE)) {
[17:41:02.697]                           master <- get("master", mode = "list", 
[17:41:02.697]                             envir = envir, inherits = FALSE)
[17:41:02.697]                           if (inherits(master, c("SOCKnode", 
[17:41:02.697]                             "SOCK0node"))) {
[17:41:02.697]                             sendCondition <<- function(cond) {
[17:41:02.697]                               data <- list(type = "VALUE", value = cond, 
[17:41:02.697]                                 success = TRUE)
[17:41:02.697]                               parallel_sendData(master, data)
[17:41:02.697]                             }
[17:41:02.697]                             return(sendCondition)
[17:41:02.697]                           }
[17:41:02.697]                         }
[17:41:02.697]                         frame <- frame + 1L
[17:41:02.697]                         envir <- sys.frame(frame)
[17:41:02.697]                       }
[17:41:02.697]                     }
[17:41:02.697]                     sendCondition <<- function(cond) NULL
[17:41:02.697]                   }
[17:41:02.697]                 })
[17:41:02.697]                 withCallingHandlers({
[17:41:02.697]                   {
[17:41:02.697]                     do.call(function(...) {
[17:41:02.697]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.697]                       if (!identical(...future.globals.maxSize.org, 
[17:41:02.697]                         ...future.globals.maxSize)) {
[17:41:02.697]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.697]                         on.exit(options(oopts), add = TRUE)
[17:41:02.697]                       }
[17:41:02.697]                       {
[17:41:02.697]                         lapply(seq_along(...future.elements_ii), 
[17:41:02.697]                           FUN = function(jj) {
[17:41:02.697]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.697]                             ...future.FUN(...future.X_jj, ...)
[17:41:02.697]                           })
[17:41:02.697]                       }
[17:41:02.697]                     }, args = future.call.arguments)
[17:41:02.697]                   }
[17:41:02.697]                 }, immediateCondition = function(cond) {
[17:41:02.697]                   sendCondition <- ...future.makeSendCondition()
[17:41:02.697]                   sendCondition(cond)
[17:41:02.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.697]                   {
[17:41:02.697]                     inherits <- base::inherits
[17:41:02.697]                     invokeRestart <- base::invokeRestart
[17:41:02.697]                     is.null <- base::is.null
[17:41:02.697]                     muffled <- FALSE
[17:41:02.697]                     if (inherits(cond, "message")) {
[17:41:02.697]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:02.697]                       if (muffled) 
[17:41:02.697]                         invokeRestart("muffleMessage")
[17:41:02.697]                     }
[17:41:02.697]                     else if (inherits(cond, "warning")) {
[17:41:02.697]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:02.697]                       if (muffled) 
[17:41:02.697]                         invokeRestart("muffleWarning")
[17:41:02.697]                     }
[17:41:02.697]                     else if (inherits(cond, "condition")) {
[17:41:02.697]                       if (!is.null(pattern)) {
[17:41:02.697]                         computeRestarts <- base::computeRestarts
[17:41:02.697]                         grepl <- base::grepl
[17:41:02.697]                         restarts <- computeRestarts(cond)
[17:41:02.697]                         for (restart in restarts) {
[17:41:02.697]                           name <- restart$name
[17:41:02.697]                           if (is.null(name)) 
[17:41:02.697]                             next
[17:41:02.697]                           if (!grepl(pattern, name)) 
[17:41:02.697]                             next
[17:41:02.697]                           invokeRestart(restart)
[17:41:02.697]                           muffled <- TRUE
[17:41:02.697]                           break
[17:41:02.697]                         }
[17:41:02.697]                       }
[17:41:02.697]                     }
[17:41:02.697]                     invisible(muffled)
[17:41:02.697]                   }
[17:41:02.697]                   muffleCondition(cond)
[17:41:02.697]                 })
[17:41:02.697]             }))
[17:41:02.697]             future::FutureResult(value = ...future.value$value, 
[17:41:02.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.697]                   ...future.rng), globalenv = if (FALSE) 
[17:41:02.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:02.697]                     ...future.globalenv.names))
[17:41:02.697]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:02.697]         }, condition = base::local({
[17:41:02.697]             c <- base::c
[17:41:02.697]             inherits <- base::inherits
[17:41:02.697]             invokeRestart <- base::invokeRestart
[17:41:02.697]             length <- base::length
[17:41:02.697]             list <- base::list
[17:41:02.697]             seq.int <- base::seq.int
[17:41:02.697]             signalCondition <- base::signalCondition
[17:41:02.697]             sys.calls <- base::sys.calls
[17:41:02.697]             `[[` <- base::`[[`
[17:41:02.697]             `+` <- base::`+`
[17:41:02.697]             `<<-` <- base::`<<-`
[17:41:02.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:02.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:02.697]                   3L)]
[17:41:02.697]             }
[17:41:02.697]             function(cond) {
[17:41:02.697]                 is_error <- inherits(cond, "error")
[17:41:02.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:02.697]                   NULL)
[17:41:02.697]                 if (is_error) {
[17:41:02.697]                   sessionInformation <- function() {
[17:41:02.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:02.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:02.697]                       search = base::search(), system = base::Sys.info())
[17:41:02.697]                   }
[17:41:02.697]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:02.697]                     cond$call), session = sessionInformation(), 
[17:41:02.697]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:02.697]                   signalCondition(cond)
[17:41:02.697]                 }
[17:41:02.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:02.697]                 "immediateCondition"))) {
[17:41:02.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:02.697]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:02.697]                   if (TRUE && !signal) {
[17:41:02.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.697]                     {
[17:41:02.697]                       inherits <- base::inherits
[17:41:02.697]                       invokeRestart <- base::invokeRestart
[17:41:02.697]                       is.null <- base::is.null
[17:41:02.697]                       muffled <- FALSE
[17:41:02.697]                       if (inherits(cond, "message")) {
[17:41:02.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.697]                         if (muffled) 
[17:41:02.697]                           invokeRestart("muffleMessage")
[17:41:02.697]                       }
[17:41:02.697]                       else if (inherits(cond, "warning")) {
[17:41:02.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.697]                         if (muffled) 
[17:41:02.697]                           invokeRestart("muffleWarning")
[17:41:02.697]                       }
[17:41:02.697]                       else if (inherits(cond, "condition")) {
[17:41:02.697]                         if (!is.null(pattern)) {
[17:41:02.697]                           computeRestarts <- base::computeRestarts
[17:41:02.697]                           grepl <- base::grepl
[17:41:02.697]                           restarts <- computeRestarts(cond)
[17:41:02.697]                           for (restart in restarts) {
[17:41:02.697]                             name <- restart$name
[17:41:02.697]                             if (is.null(name)) 
[17:41:02.697]                               next
[17:41:02.697]                             if (!grepl(pattern, name)) 
[17:41:02.697]                               next
[17:41:02.697]                             invokeRestart(restart)
[17:41:02.697]                             muffled <- TRUE
[17:41:02.697]                             break
[17:41:02.697]                           }
[17:41:02.697]                         }
[17:41:02.697]                       }
[17:41:02.697]                       invisible(muffled)
[17:41:02.697]                     }
[17:41:02.697]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.697]                   }
[17:41:02.697]                 }
[17:41:02.697]                 else {
[17:41:02.697]                   if (TRUE) {
[17:41:02.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.697]                     {
[17:41:02.697]                       inherits <- base::inherits
[17:41:02.697]                       invokeRestart <- base::invokeRestart
[17:41:02.697]                       is.null <- base::is.null
[17:41:02.697]                       muffled <- FALSE
[17:41:02.697]                       if (inherits(cond, "message")) {
[17:41:02.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.697]                         if (muffled) 
[17:41:02.697]                           invokeRestart("muffleMessage")
[17:41:02.697]                       }
[17:41:02.697]                       else if (inherits(cond, "warning")) {
[17:41:02.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.697]                         if (muffled) 
[17:41:02.697]                           invokeRestart("muffleWarning")
[17:41:02.697]                       }
[17:41:02.697]                       else if (inherits(cond, "condition")) {
[17:41:02.697]                         if (!is.null(pattern)) {
[17:41:02.697]                           computeRestarts <- base::computeRestarts
[17:41:02.697]                           grepl <- base::grepl
[17:41:02.697]                           restarts <- computeRestarts(cond)
[17:41:02.697]                           for (restart in restarts) {
[17:41:02.697]                             name <- restart$name
[17:41:02.697]                             if (is.null(name)) 
[17:41:02.697]                               next
[17:41:02.697]                             if (!grepl(pattern, name)) 
[17:41:02.697]                               next
[17:41:02.697]                             invokeRestart(restart)
[17:41:02.697]                             muffled <- TRUE
[17:41:02.697]                             break
[17:41:02.697]                           }
[17:41:02.697]                         }
[17:41:02.697]                       }
[17:41:02.697]                       invisible(muffled)
[17:41:02.697]                     }
[17:41:02.697]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.697]                   }
[17:41:02.697]                 }
[17:41:02.697]             }
[17:41:02.697]         }))
[17:41:02.697]     }, error = function(ex) {
[17:41:02.697]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:02.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.697]                 ...future.rng), started = ...future.startTime, 
[17:41:02.697]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:02.697]             version = "1.8"), class = "FutureResult")
[17:41:02.697]     }, finally = {
[17:41:02.697]         if (!identical(...future.workdir, getwd())) 
[17:41:02.697]             setwd(...future.workdir)
[17:41:02.697]         {
[17:41:02.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:02.697]                 ...future.oldOptions$nwarnings <- NULL
[17:41:02.697]             }
[17:41:02.697]             base::options(...future.oldOptions)
[17:41:02.697]             if (.Platform$OS.type == "windows") {
[17:41:02.697]                 old_names <- names(...future.oldEnvVars)
[17:41:02.697]                 envs <- base::Sys.getenv()
[17:41:02.697]                 names <- names(envs)
[17:41:02.697]                 common <- intersect(names, old_names)
[17:41:02.697]                 added <- setdiff(names, old_names)
[17:41:02.697]                 removed <- setdiff(old_names, names)
[17:41:02.697]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:02.697]                   envs[common]]
[17:41:02.697]                 NAMES <- toupper(changed)
[17:41:02.697]                 args <- list()
[17:41:02.697]                 for (kk in seq_along(NAMES)) {
[17:41:02.697]                   name <- changed[[kk]]
[17:41:02.697]                   NAME <- NAMES[[kk]]
[17:41:02.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.697]                     next
[17:41:02.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.697]                 }
[17:41:02.697]                 NAMES <- toupper(added)
[17:41:02.697]                 for (kk in seq_along(NAMES)) {
[17:41:02.697]                   name <- added[[kk]]
[17:41:02.697]                   NAME <- NAMES[[kk]]
[17:41:02.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.697]                     next
[17:41:02.697]                   args[[name]] <- ""
[17:41:02.697]                 }
[17:41:02.697]                 NAMES <- toupper(removed)
[17:41:02.697]                 for (kk in seq_along(NAMES)) {
[17:41:02.697]                   name <- removed[[kk]]
[17:41:02.697]                   NAME <- NAMES[[kk]]
[17:41:02.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.697]                     next
[17:41:02.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.697]                 }
[17:41:02.697]                 if (length(args) > 0) 
[17:41:02.697]                   base::do.call(base::Sys.setenv, args = args)
[17:41:02.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:02.697]             }
[17:41:02.697]             else {
[17:41:02.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:02.697]             }
[17:41:02.697]             {
[17:41:02.697]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:02.697]                   0L) {
[17:41:02.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:02.697]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:02.697]                   base::options(opts)
[17:41:02.697]                 }
[17:41:02.697]                 {
[17:41:02.697]                   {
[17:41:02.697]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:02.697]                     NULL
[17:41:02.697]                   }
[17:41:02.697]                   options(future.plan = NULL)
[17:41:02.697]                   if (is.na(NA_character_)) 
[17:41:02.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:02.697]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:02.697]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:02.697]                     envir = parent.frame()) 
[17:41:02.697]                   {
[17:41:02.697]                     if (is.function(workers)) 
[17:41:02.697]                       workers <- workers()
[17:41:02.697]                     workers <- structure(as.integer(workers), 
[17:41:02.697]                       class = class(workers))
[17:41:02.697]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:02.697]                       workers >= 1)
[17:41:02.697]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:02.697]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:02.697]                     }
[17:41:02.697]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:02.697]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:02.697]                       envir = envir)
[17:41:02.697]                     if (!future$lazy) 
[17:41:02.697]                       future <- run(future)
[17:41:02.697]                     invisible(future)
[17:41:02.697]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:02.697]                 }
[17:41:02.697]             }
[17:41:02.697]         }
[17:41:02.697]     })
[17:41:02.697]     if (TRUE) {
[17:41:02.697]         base::sink(type = "output", split = FALSE)
[17:41:02.697]         if (TRUE) {
[17:41:02.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:02.697]         }
[17:41:02.697]         else {
[17:41:02.697]             ...future.result["stdout"] <- base::list(NULL)
[17:41:02.697]         }
[17:41:02.697]         base::close(...future.stdout)
[17:41:02.697]         ...future.stdout <- NULL
[17:41:02.697]     }
[17:41:02.697]     ...future.result$conditions <- ...future.conditions
[17:41:02.697]     ...future.result$finished <- base::Sys.time()
[17:41:02.697]     ...future.result
[17:41:02.697] }
[17:41:02.700] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[17:41:02.700] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:02.743] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:02.743] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:41:02.744] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:41:02.744] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:02.744] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:02.744] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:02.787] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:02.787] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:02.831] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:02.831] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:41:02.832] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.832] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[17:41:02.832] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[17:41:02.833] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:02.833] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.833] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[17:41:02.833] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[17:41:02.834] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:02.834] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.834] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:02.834] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:02.834] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[17:41:02.835] MultisessionFuture started
[17:41:02.835] - Launch lazy future ... done
[17:41:02.835] run() for ‘MultisessionFuture’ ... done
[17:41:02.835] Created future:
[17:41:02.836] MultisessionFuture:
[17:41:02.836] Label: ‘future_vapply-2’
[17:41:02.836] Expression:
[17:41:02.836] {
[17:41:02.836]     do.call(function(...) {
[17:41:02.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.836]             on.exit(options(oopts), add = TRUE)
[17:41:02.836]         }
[17:41:02.836]         {
[17:41:02.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.836]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.836]             })
[17:41:02.836]         }
[17:41:02.836]     }, args = future.call.arguments)
[17:41:02.836] }
[17:41:02.836] Lazy evaluation: FALSE
[17:41:02.836] Asynchronous evaluation: TRUE
[17:41:02.836] Local evaluation: TRUE
[17:41:02.836] Environment: R_GlobalEnv
[17:41:02.836] Capture standard output: TRUE
[17:41:02.836] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:02.836] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:02.836] Packages: 1 packages (‘future.apply’)
[17:41:02.836] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:02.836] Resolved: FALSE
[17:41:02.836] Value: <not collected>
[17:41:02.836] Conditions captured: <none>
[17:41:02.836] Early signaling: FALSE
[17:41:02.836] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:02.836] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.847] Chunk #2 of 2 ... DONE
[17:41:02.847] Launching 2 futures (chunks) ... DONE
[17:41:02.848] Resolving 2 futures (chunks) ...
[17:41:02.848] resolve() on list ...
[17:41:02.848]  recursive: 0
[17:41:02.848]  length: 2
[17:41:02.848] 
[17:41:02.848] receiveMessageFromWorker() for ClusterFuture ...
[17:41:02.849] - Validating connection of MultisessionFuture
[17:41:02.849] - received message: FutureResult
[17:41:02.849] - Received FutureResult
[17:41:02.849] - Erased future from FutureRegistry
[17:41:02.849] result() for ClusterFuture ...
[17:41:02.849] - result already collected: FutureResult
[17:41:02.849] result() for ClusterFuture ... done
[17:41:02.849] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:02.849] Future #1
[17:41:02.850] result() for ClusterFuture ...
[17:41:02.850] - result already collected: FutureResult
[17:41:02.850] result() for ClusterFuture ... done
[17:41:02.850] result() for ClusterFuture ...
[17:41:02.850] - result already collected: FutureResult
[17:41:02.850] result() for ClusterFuture ... done
[17:41:02.850] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:02.850] - nx: 2
[17:41:02.850] - relay: TRUE
[17:41:02.850] - stdout: TRUE
[17:41:02.850] - signal: TRUE
[17:41:02.850] - resignal: FALSE
[17:41:02.851] - force: TRUE
[17:41:02.851] - relayed: [n=2] FALSE, FALSE
[17:41:02.851] - queued futures: [n=2] FALSE, FALSE
[17:41:02.851]  - until=1
[17:41:02.851]  - relaying element #1
[17:41:02.851] result() for ClusterFuture ...
[17:41:02.851] - result already collected: FutureResult
[17:41:02.851] result() for ClusterFuture ... done
[17:41:02.851] result() for ClusterFuture ...
[17:41:02.851] - result already collected: FutureResult
[17:41:02.851] result() for ClusterFuture ... done
[17:41:02.852] result() for ClusterFuture ...
[17:41:02.852] - result already collected: FutureResult
[17:41:02.852] result() for ClusterFuture ... done
[17:41:02.852] result() for ClusterFuture ...
[17:41:02.852] - result already collected: FutureResult
[17:41:02.852] result() for ClusterFuture ... done
[17:41:02.852] - relayed: [n=2] TRUE, FALSE
[17:41:02.852] - queued futures: [n=2] TRUE, FALSE
[17:41:02.852] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:02.852]  length: 1 (resolved future 1)
[17:41:02.894] receiveMessageFromWorker() for ClusterFuture ...
[17:41:02.894] - Validating connection of MultisessionFuture
[17:41:02.894] - received message: FutureResult
[17:41:02.895] - Received FutureResult
[17:41:02.895] - Erased future from FutureRegistry
[17:41:02.895] result() for ClusterFuture ...
[17:41:02.895] - result already collected: FutureResult
[17:41:02.895] result() for ClusterFuture ... done
[17:41:02.895] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:02.895] Future #2
[17:41:02.895] result() for ClusterFuture ...
[17:41:02.895] - result already collected: FutureResult
[17:41:02.895] result() for ClusterFuture ... done
[17:41:02.895] result() for ClusterFuture ...
[17:41:02.896] - result already collected: FutureResult
[17:41:02.896] result() for ClusterFuture ... done
[17:41:02.896] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:02.896] - nx: 2
[17:41:02.896] - relay: TRUE
[17:41:02.896] - stdout: TRUE
[17:41:02.896] - signal: TRUE
[17:41:02.896] - resignal: FALSE
[17:41:02.896] - force: TRUE
[17:41:02.896] - relayed: [n=2] TRUE, FALSE
[17:41:02.896] - queued futures: [n=2] TRUE, FALSE
[17:41:02.897]  - until=2
[17:41:02.897]  - relaying element #2
[17:41:02.897] result() for ClusterFuture ...
[17:41:02.897] - result already collected: FutureResult
[17:41:02.897] result() for ClusterFuture ... done
[17:41:02.897] result() for ClusterFuture ...
[17:41:02.897] - result already collected: FutureResult
[17:41:02.897] result() for ClusterFuture ... done
[17:41:02.897] result() for ClusterFuture ...
[17:41:02.897] - result already collected: FutureResult
[17:41:02.897] result() for ClusterFuture ... done
[17:41:02.898] result() for ClusterFuture ...
[17:41:02.898] - result already collected: FutureResult
[17:41:02.898] result() for ClusterFuture ... done
[17:41:02.898] - relayed: [n=2] TRUE, TRUE
[17:41:02.898] - queued futures: [n=2] TRUE, TRUE
[17:41:02.898] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:02.898]  length: 0 (resolved future 2)
[17:41:02.898] Relaying remaining futures
[17:41:02.898] signalConditionsASAP(NULL, pos=0) ...
[17:41:02.898] - nx: 2
[17:41:02.898] - relay: TRUE
[17:41:02.898] - stdout: TRUE
[17:41:02.899] - signal: TRUE
[17:41:02.899] - resignal: FALSE
[17:41:02.899] - force: TRUE
[17:41:02.899] - relayed: [n=2] TRUE, TRUE
[17:41:02.899] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:02.899] - relayed: [n=2] TRUE, TRUE
[17:41:02.899] - queued futures: [n=2] TRUE, TRUE
[17:41:02.899] signalConditionsASAP(NULL, pos=0) ... done
[17:41:02.899] resolve() on list ... DONE
[17:41:02.899] result() for ClusterFuture ...
[17:41:02.900] - result already collected: FutureResult
[17:41:02.900] result() for ClusterFuture ... done
[17:41:02.900] result() for ClusterFuture ...
[17:41:02.900] - result already collected: FutureResult
[17:41:02.900] result() for ClusterFuture ... done
[17:41:02.900] result() for ClusterFuture ...
[17:41:02.900] - result already collected: FutureResult
[17:41:02.900] result() for ClusterFuture ... done
[17:41:02.900] result() for ClusterFuture ...
[17:41:02.900] - result already collected: FutureResult
[17:41:02.900] result() for ClusterFuture ... done
[17:41:02.901]  - Number of value chunks collected: 2
[17:41:02.901] Resolving 2 futures (chunks) ... DONE
[17:41:02.901] Reducing values from 2 chunks ...
[17:41:02.901]  - Number of values collected after concatenation: 11
[17:41:02.901]  - Number of values expected: 11
[17:41:02.901] Reducing values from 2 chunks ... DONE
[17:41:02.901] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:41:02.902] future_lapply() ...
[17:41:02.907] Number of chunks: 2
[17:41:02.908] getGlobalsAndPackagesXApply() ...
[17:41:02.908]  - future.globals: TRUE
[17:41:02.908] getGlobalsAndPackages() ...
[17:41:02.908] Searching for globals...
[17:41:02.911] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:41:02.911] Searching for globals ... DONE
[17:41:02.911] Resolving globals: FALSE
[17:41:02.912] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:41:02.912] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:41:02.913] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:02.913] - packages: [1] ‘future.apply’
[17:41:02.913] getGlobalsAndPackages() ... DONE
[17:41:02.913]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:02.913]  - needed namespaces: [n=1] ‘future.apply’
[17:41:02.913] Finding globals ... DONE
[17:41:02.913]  - use_args: TRUE
[17:41:02.913]  - Getting '...' globals ...
[17:41:02.914] resolve() on list ...
[17:41:02.914]  recursive: 0
[17:41:02.914]  length: 1
[17:41:02.914]  elements: ‘...’
[17:41:02.914]  length: 0 (resolved future 1)
[17:41:02.914] resolve() on list ... DONE
[17:41:02.914]    - '...' content: [n=0] 
[17:41:02.914] List of 1
[17:41:02.914]  $ ...: list()
[17:41:02.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:02.914]  - attr(*, "where")=List of 1
[17:41:02.914]   ..$ ...:<environment: 0x564f31531da0> 
[17:41:02.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:02.914]  - attr(*, "resolved")= logi TRUE
[17:41:02.914]  - attr(*, "total_size")= num NA
[17:41:02.917]  - Getting '...' globals ... DONE
[17:41:02.917] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:02.917] List of 8
[17:41:02.917]  $ ...future.FUN:function (x, ...)  
[17:41:02.917]  $ x_FUN        :function (x)  
[17:41:02.917]  $ times        : int 1
[17:41:02.917]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:02.917]  $ stop_if_not  :function (...)  
[17:41:02.917]  $ dim          : NULL
[17:41:02.917]  $ valid_types  : chr [1:2] "logical" "integer"
[17:41:02.917]  $ ...          : list()
[17:41:02.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:02.917]  - attr(*, "where")=List of 8
[17:41:02.917]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:02.917]   ..$ ...          :<environment: 0x564f31531da0> 
[17:41:02.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:02.917]  - attr(*, "resolved")= logi FALSE
[17:41:02.917]  - attr(*, "total_size")= num 94264
[17:41:02.922] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:41:02.922] getGlobalsAndPackagesXApply() ... DONE
[17:41:02.923] Number of futures (= number of chunks): 2
[17:41:02.923] Launching 2 futures (chunks) ...
[17:41:02.923] Chunk #1 of 2 ...
[17:41:02.923]  - Finding globals in 'X' for chunk #1 ...
[17:41:02.923] getGlobalsAndPackages() ...
[17:41:02.923] Searching for globals...
[17:41:02.923] 
[17:41:02.924] Searching for globals ... DONE
[17:41:02.924] - globals: [0] <none>
[17:41:02.924] getGlobalsAndPackages() ... DONE
[17:41:02.924]    + additional globals found: [n=0] 
[17:41:02.924]    + additional namespaces needed: [n=0] 
[17:41:02.924]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:02.924]  - seeds: <none>
[17:41:02.924] getGlobalsAndPackages() ...
[17:41:02.924] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.924] Resolving globals: FALSE
[17:41:02.924] Tweak future expression to call with '...' arguments ...
[17:41:02.925] {
[17:41:02.925]     do.call(function(...) {
[17:41:02.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:02.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.925]             on.exit(options(oopts), add = TRUE)
[17:41:02.925]         }
[17:41:02.925]         {
[17:41:02.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:02.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.925]                 ...future.FUN(...future.X_jj, ...)
[17:41:02.925]             })
[17:41:02.925]         }
[17:41:02.925]     }, args = future.call.arguments)
[17:41:02.925] }
[17:41:02.925] Tweak future expression to call with '...' arguments ... DONE
[17:41:02.925] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:02.925] - packages: [1] ‘future.apply’
[17:41:02.926] getGlobalsAndPackages() ... DONE
[17:41:02.929] run() for ‘Future’ ...
[17:41:02.929] - state: ‘created’
[17:41:02.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:02.943] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:02.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:02.944]   - Field: ‘node’
[17:41:02.944]   - Field: ‘label’
[17:41:02.944]   - Field: ‘local’
[17:41:02.944]   - Field: ‘owner’
[17:41:02.944]   - Field: ‘envir’
[17:41:02.944]   - Field: ‘workers’
[17:41:02.944]   - Field: ‘packages’
[17:41:02.944]   - Field: ‘gc’
[17:41:02.944]   - Field: ‘conditions’
[17:41:02.944]   - Field: ‘persistent’
[17:41:02.944]   - Field: ‘expr’
[17:41:02.945]   - Field: ‘uuid’
[17:41:02.945]   - Field: ‘seed’
[17:41:02.945]   - Field: ‘version’
[17:41:02.945]   - Field: ‘result’
[17:41:02.945]   - Field: ‘asynchronous’
[17:41:02.945]   - Field: ‘calls’
[17:41:02.945]   - Field: ‘globals’
[17:41:02.945]   - Field: ‘stdout’
[17:41:02.945]   - Field: ‘earlySignal’
[17:41:02.945]   - Field: ‘lazy’
[17:41:02.945]   - Field: ‘state’
[17:41:02.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:02.946] - Launch lazy future ...
[17:41:02.946] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:02.946] Packages needed by future strategies (n = 0): <none>
[17:41:02.947] {
[17:41:02.947]     {
[17:41:02.947]         {
[17:41:02.947]             ...future.startTime <- base::Sys.time()
[17:41:02.947]             {
[17:41:02.947]                 {
[17:41:02.947]                   {
[17:41:02.947]                     {
[17:41:02.947]                       {
[17:41:02.947]                         base::local({
[17:41:02.947]                           has_future <- base::requireNamespace("future", 
[17:41:02.947]                             quietly = TRUE)
[17:41:02.947]                           if (has_future) {
[17:41:02.947]                             ns <- base::getNamespace("future")
[17:41:02.947]                             version <- ns[[".package"]][["version"]]
[17:41:02.947]                             if (is.null(version)) 
[17:41:02.947]                               version <- utils::packageVersion("future")
[17:41:02.947]                           }
[17:41:02.947]                           else {
[17:41:02.947]                             version <- NULL
[17:41:02.947]                           }
[17:41:02.947]                           if (!has_future || version < "1.8.0") {
[17:41:02.947]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:02.947]                               "", base::R.version$version.string), 
[17:41:02.947]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:02.947]                                 base::R.version$platform, 8 * 
[17:41:02.947]                                   base::.Machine$sizeof.pointer), 
[17:41:02.947]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:02.947]                                 "release", "version")], collapse = " "), 
[17:41:02.947]                               hostname = base::Sys.info()[["nodename"]])
[17:41:02.947]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:02.947]                               info)
[17:41:02.947]                             info <- base::paste(info, collapse = "; ")
[17:41:02.947]                             if (!has_future) {
[17:41:02.947]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:02.947]                                 info)
[17:41:02.947]                             }
[17:41:02.947]                             else {
[17:41:02.947]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:02.947]                                 info, version)
[17:41:02.947]                             }
[17:41:02.947]                             base::stop(msg)
[17:41:02.947]                           }
[17:41:02.947]                         })
[17:41:02.947]                       }
[17:41:02.947]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:02.947]                       base::options(mc.cores = 1L)
[17:41:02.947]                     }
[17:41:02.947]                     base::local({
[17:41:02.947]                       for (pkg in "future.apply") {
[17:41:02.947]                         base::loadNamespace(pkg)
[17:41:02.947]                         base::library(pkg, character.only = TRUE)
[17:41:02.947]                       }
[17:41:02.947]                     })
[17:41:02.947]                   }
[17:41:02.947]                   options(future.plan = NULL)
[17:41:02.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:02.947]                 }
[17:41:02.947]                 ...future.workdir <- getwd()
[17:41:02.947]             }
[17:41:02.947]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:02.947]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:02.947]         }
[17:41:02.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:02.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:02.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:02.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:02.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:02.947]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:02.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:02.947]             base::names(...future.oldOptions))
[17:41:02.947]     }
[17:41:02.947]     if (FALSE) {
[17:41:02.947]     }
[17:41:02.947]     else {
[17:41:02.947]         if (TRUE) {
[17:41:02.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:02.947]                 open = "w")
[17:41:02.947]         }
[17:41:02.947]         else {
[17:41:02.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:02.947]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:02.947]         }
[17:41:02.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:02.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:02.947]             base::sink(type = "output", split = FALSE)
[17:41:02.947]             base::close(...future.stdout)
[17:41:02.947]         }, add = TRUE)
[17:41:02.947]     }
[17:41:02.947]     ...future.frame <- base::sys.nframe()
[17:41:02.947]     ...future.conditions <- base::list()
[17:41:02.947]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:02.947]     if (FALSE) {
[17:41:02.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:02.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:02.947]     }
[17:41:02.947]     ...future.result <- base::tryCatch({
[17:41:02.947]         base::withCallingHandlers({
[17:41:02.947]             ...future.value <- base::withVisible(base::local({
[17:41:02.947]                 ...future.makeSendCondition <- local({
[17:41:02.947]                   sendCondition <- NULL
[17:41:02.947]                   function(frame = 1L) {
[17:41:02.947]                     if (is.function(sendCondition)) 
[17:41:02.947]                       return(sendCondition)
[17:41:02.947]                     ns <- getNamespace("parallel")
[17:41:02.947]                     if (exists("sendData", mode = "function", 
[17:41:02.947]                       envir = ns)) {
[17:41:02.947]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:02.947]                         envir = ns)
[17:41:02.947]                       envir <- sys.frame(frame)
[17:41:02.947]                       master <- NULL
[17:41:02.947]                       while (!identical(envir, .GlobalEnv) && 
[17:41:02.947]                         !identical(envir, emptyenv())) {
[17:41:02.947]                         if (exists("master", mode = "list", envir = envir, 
[17:41:02.947]                           inherits = FALSE)) {
[17:41:02.947]                           master <- get("master", mode = "list", 
[17:41:02.947]                             envir = envir, inherits = FALSE)
[17:41:02.947]                           if (inherits(master, c("SOCKnode", 
[17:41:02.947]                             "SOCK0node"))) {
[17:41:02.947]                             sendCondition <<- function(cond) {
[17:41:02.947]                               data <- list(type = "VALUE", value = cond, 
[17:41:02.947]                                 success = TRUE)
[17:41:02.947]                               parallel_sendData(master, data)
[17:41:02.947]                             }
[17:41:02.947]                             return(sendCondition)
[17:41:02.947]                           }
[17:41:02.947]                         }
[17:41:02.947]                         frame <- frame + 1L
[17:41:02.947]                         envir <- sys.frame(frame)
[17:41:02.947]                       }
[17:41:02.947]                     }
[17:41:02.947]                     sendCondition <<- function(cond) NULL
[17:41:02.947]                   }
[17:41:02.947]                 })
[17:41:02.947]                 withCallingHandlers({
[17:41:02.947]                   {
[17:41:02.947]                     do.call(function(...) {
[17:41:02.947]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:02.947]                       if (!identical(...future.globals.maxSize.org, 
[17:41:02.947]                         ...future.globals.maxSize)) {
[17:41:02.947]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:02.947]                         on.exit(options(oopts), add = TRUE)
[17:41:02.947]                       }
[17:41:02.947]                       {
[17:41:02.947]                         lapply(seq_along(...future.elements_ii), 
[17:41:02.947]                           FUN = function(jj) {
[17:41:02.947]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:02.947]                             ...future.FUN(...future.X_jj, ...)
[17:41:02.947]                           })
[17:41:02.947]                       }
[17:41:02.947]                     }, args = future.call.arguments)
[17:41:02.947]                   }
[17:41:02.947]                 }, immediateCondition = function(cond) {
[17:41:02.947]                   sendCondition <- ...future.makeSendCondition()
[17:41:02.947]                   sendCondition(cond)
[17:41:02.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.947]                   {
[17:41:02.947]                     inherits <- base::inherits
[17:41:02.947]                     invokeRestart <- base::invokeRestart
[17:41:02.947]                     is.null <- base::is.null
[17:41:02.947]                     muffled <- FALSE
[17:41:02.947]                     if (inherits(cond, "message")) {
[17:41:02.947]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:02.947]                       if (muffled) 
[17:41:02.947]                         invokeRestart("muffleMessage")
[17:41:02.947]                     }
[17:41:02.947]                     else if (inherits(cond, "warning")) {
[17:41:02.947]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:02.947]                       if (muffled) 
[17:41:02.947]                         invokeRestart("muffleWarning")
[17:41:02.947]                     }
[17:41:02.947]                     else if (inherits(cond, "condition")) {
[17:41:02.947]                       if (!is.null(pattern)) {
[17:41:02.947]                         computeRestarts <- base::computeRestarts
[17:41:02.947]                         grepl <- base::grepl
[17:41:02.947]                         restarts <- computeRestarts(cond)
[17:41:02.947]                         for (restart in restarts) {
[17:41:02.947]                           name <- restart$name
[17:41:02.947]                           if (is.null(name)) 
[17:41:02.947]                             next
[17:41:02.947]                           if (!grepl(pattern, name)) 
[17:41:02.947]                             next
[17:41:02.947]                           invokeRestart(restart)
[17:41:02.947]                           muffled <- TRUE
[17:41:02.947]                           break
[17:41:02.947]                         }
[17:41:02.947]                       }
[17:41:02.947]                     }
[17:41:02.947]                     invisible(muffled)
[17:41:02.947]                   }
[17:41:02.947]                   muffleCondition(cond)
[17:41:02.947]                 })
[17:41:02.947]             }))
[17:41:02.947]             future::FutureResult(value = ...future.value$value, 
[17:41:02.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.947]                   ...future.rng), globalenv = if (FALSE) 
[17:41:02.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:02.947]                     ...future.globalenv.names))
[17:41:02.947]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:02.947]         }, condition = base::local({
[17:41:02.947]             c <- base::c
[17:41:02.947]             inherits <- base::inherits
[17:41:02.947]             invokeRestart <- base::invokeRestart
[17:41:02.947]             length <- base::length
[17:41:02.947]             list <- base::list
[17:41:02.947]             seq.int <- base::seq.int
[17:41:02.947]             signalCondition <- base::signalCondition
[17:41:02.947]             sys.calls <- base::sys.calls
[17:41:02.947]             `[[` <- base::`[[`
[17:41:02.947]             `+` <- base::`+`
[17:41:02.947]             `<<-` <- base::`<<-`
[17:41:02.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:02.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:02.947]                   3L)]
[17:41:02.947]             }
[17:41:02.947]             function(cond) {
[17:41:02.947]                 is_error <- inherits(cond, "error")
[17:41:02.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:02.947]                   NULL)
[17:41:02.947]                 if (is_error) {
[17:41:02.947]                   sessionInformation <- function() {
[17:41:02.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:02.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:02.947]                       search = base::search(), system = base::Sys.info())
[17:41:02.947]                   }
[17:41:02.947]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:02.947]                     cond$call), session = sessionInformation(), 
[17:41:02.947]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:02.947]                   signalCondition(cond)
[17:41:02.947]                 }
[17:41:02.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:02.947]                 "immediateCondition"))) {
[17:41:02.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:02.947]                   ...future.conditions[[length(...future.conditions) + 
[17:41:02.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:02.947]                   if (TRUE && !signal) {
[17:41:02.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.947]                     {
[17:41:02.947]                       inherits <- base::inherits
[17:41:02.947]                       invokeRestart <- base::invokeRestart
[17:41:02.947]                       is.null <- base::is.null
[17:41:02.947]                       muffled <- FALSE
[17:41:02.947]                       if (inherits(cond, "message")) {
[17:41:02.947]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.947]                         if (muffled) 
[17:41:02.947]                           invokeRestart("muffleMessage")
[17:41:02.947]                       }
[17:41:02.947]                       else if (inherits(cond, "warning")) {
[17:41:02.947]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.947]                         if (muffled) 
[17:41:02.947]                           invokeRestart("muffleWarning")
[17:41:02.947]                       }
[17:41:02.947]                       else if (inherits(cond, "condition")) {
[17:41:02.947]                         if (!is.null(pattern)) {
[17:41:02.947]                           computeRestarts <- base::computeRestarts
[17:41:02.947]                           grepl <- base::grepl
[17:41:02.947]                           restarts <- computeRestarts(cond)
[17:41:02.947]                           for (restart in restarts) {
[17:41:02.947]                             name <- restart$name
[17:41:02.947]                             if (is.null(name)) 
[17:41:02.947]                               next
[17:41:02.947]                             if (!grepl(pattern, name)) 
[17:41:02.947]                               next
[17:41:02.947]                             invokeRestart(restart)
[17:41:02.947]                             muffled <- TRUE
[17:41:02.947]                             break
[17:41:02.947]                           }
[17:41:02.947]                         }
[17:41:02.947]                       }
[17:41:02.947]                       invisible(muffled)
[17:41:02.947]                     }
[17:41:02.947]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.947]                   }
[17:41:02.947]                 }
[17:41:02.947]                 else {
[17:41:02.947]                   if (TRUE) {
[17:41:02.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:02.947]                     {
[17:41:02.947]                       inherits <- base::inherits
[17:41:02.947]                       invokeRestart <- base::invokeRestart
[17:41:02.947]                       is.null <- base::is.null
[17:41:02.947]                       muffled <- FALSE
[17:41:02.947]                       if (inherits(cond, "message")) {
[17:41:02.947]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:02.947]                         if (muffled) 
[17:41:02.947]                           invokeRestart("muffleMessage")
[17:41:02.947]                       }
[17:41:02.947]                       else if (inherits(cond, "warning")) {
[17:41:02.947]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:02.947]                         if (muffled) 
[17:41:02.947]                           invokeRestart("muffleWarning")
[17:41:02.947]                       }
[17:41:02.947]                       else if (inherits(cond, "condition")) {
[17:41:02.947]                         if (!is.null(pattern)) {
[17:41:02.947]                           computeRestarts <- base::computeRestarts
[17:41:02.947]                           grepl <- base::grepl
[17:41:02.947]                           restarts <- computeRestarts(cond)
[17:41:02.947]                           for (restart in restarts) {
[17:41:02.947]                             name <- restart$name
[17:41:02.947]                             if (is.null(name)) 
[17:41:02.947]                               next
[17:41:02.947]                             if (!grepl(pattern, name)) 
[17:41:02.947]                               next
[17:41:02.947]                             invokeRestart(restart)
[17:41:02.947]                             muffled <- TRUE
[17:41:02.947]                             break
[17:41:02.947]                           }
[17:41:02.947]                         }
[17:41:02.947]                       }
[17:41:02.947]                       invisible(muffled)
[17:41:02.947]                     }
[17:41:02.947]                     muffleCondition(cond, pattern = "^muffle")
[17:41:02.947]                   }
[17:41:02.947]                 }
[17:41:02.947]             }
[17:41:02.947]         }))
[17:41:02.947]     }, error = function(ex) {
[17:41:02.947]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:02.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:02.947]                 ...future.rng), started = ...future.startTime, 
[17:41:02.947]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:02.947]             version = "1.8"), class = "FutureResult")
[17:41:02.947]     }, finally = {
[17:41:02.947]         if (!identical(...future.workdir, getwd())) 
[17:41:02.947]             setwd(...future.workdir)
[17:41:02.947]         {
[17:41:02.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:02.947]                 ...future.oldOptions$nwarnings <- NULL
[17:41:02.947]             }
[17:41:02.947]             base::options(...future.oldOptions)
[17:41:02.947]             if (.Platform$OS.type == "windows") {
[17:41:02.947]                 old_names <- names(...future.oldEnvVars)
[17:41:02.947]                 envs <- base::Sys.getenv()
[17:41:02.947]                 names <- names(envs)
[17:41:02.947]                 common <- intersect(names, old_names)
[17:41:02.947]                 added <- setdiff(names, old_names)
[17:41:02.947]                 removed <- setdiff(old_names, names)
[17:41:02.947]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:02.947]                   envs[common]]
[17:41:02.947]                 NAMES <- toupper(changed)
[17:41:02.947]                 args <- list()
[17:41:02.947]                 for (kk in seq_along(NAMES)) {
[17:41:02.947]                   name <- changed[[kk]]
[17:41:02.947]                   NAME <- NAMES[[kk]]
[17:41:02.947]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.947]                     next
[17:41:02.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.947]                 }
[17:41:02.947]                 NAMES <- toupper(added)
[17:41:02.947]                 for (kk in seq_along(NAMES)) {
[17:41:02.947]                   name <- added[[kk]]
[17:41:02.947]                   NAME <- NAMES[[kk]]
[17:41:02.947]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.947]                     next
[17:41:02.947]                   args[[name]] <- ""
[17:41:02.947]                 }
[17:41:02.947]                 NAMES <- toupper(removed)
[17:41:02.947]                 for (kk in seq_along(NAMES)) {
[17:41:02.947]                   name <- removed[[kk]]
[17:41:02.947]                   NAME <- NAMES[[kk]]
[17:41:02.947]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:02.947]                     next
[17:41:02.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:02.947]                 }
[17:41:02.947]                 if (length(args) > 0) 
[17:41:02.947]                   base::do.call(base::Sys.setenv, args = args)
[17:41:02.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:02.947]             }
[17:41:02.947]             else {
[17:41:02.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:02.947]             }
[17:41:02.947]             {
[17:41:02.947]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:02.947]                   0L) {
[17:41:02.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:02.947]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:02.947]                   base::options(opts)
[17:41:02.947]                 }
[17:41:02.947]                 {
[17:41:02.947]                   {
[17:41:02.947]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:02.947]                     NULL
[17:41:02.947]                   }
[17:41:02.947]                   options(future.plan = NULL)
[17:41:02.947]                   if (is.na(NA_character_)) 
[17:41:02.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:02.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:02.947]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:02.947]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:02.947]                     envir = parent.frame()) 
[17:41:02.947]                   {
[17:41:02.947]                     if (is.function(workers)) 
[17:41:02.947]                       workers <- workers()
[17:41:02.947]                     workers <- structure(as.integer(workers), 
[17:41:02.947]                       class = class(workers))
[17:41:02.947]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:02.947]                       workers >= 1)
[17:41:02.947]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:02.947]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:02.947]                     }
[17:41:02.947]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:02.947]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:02.947]                       envir = envir)
[17:41:02.947]                     if (!future$lazy) 
[17:41:02.947]                       future <- run(future)
[17:41:02.947]                     invisible(future)
[17:41:02.947]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:02.947]                 }
[17:41:02.947]             }
[17:41:02.947]         }
[17:41:02.947]     })
[17:41:02.947]     if (TRUE) {
[17:41:02.947]         base::sink(type = "output", split = FALSE)
[17:41:02.947]         if (TRUE) {
[17:41:02.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:02.947]         }
[17:41:02.947]         else {
[17:41:02.947]             ...future.result["stdout"] <- base::list(NULL)
[17:41:02.947]         }
[17:41:02.947]         base::close(...future.stdout)
[17:41:02.947]         ...future.stdout <- NULL
[17:41:02.947]     }
[17:41:02.947]     ...future.result$conditions <- ...future.conditions
[17:41:02.947]     ...future.result$finished <- base::Sys.time()
[17:41:02.947]     ...future.result
[17:41:02.947] }
[17:41:02.949] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[17:41:02.950] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:02.991] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:02.991] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:41:02.992] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:41:02.992] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:02.992] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:02.992] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:03.035] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:03.035] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:03.079] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:03.079] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:41:03.080] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.080] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:41:03.080] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:41:03.080] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:03.081] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.081] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:41:03.081] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:03.081] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:03.082] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.082] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:03.082] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.082] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[17:41:03.083] MultisessionFuture started
[17:41:03.083] - Launch lazy future ... done
[17:41:03.083] run() for ‘MultisessionFuture’ ... done
[17:41:03.084] Created future:
[17:41:03.084] MultisessionFuture:
[17:41:03.084] Label: ‘future_vapply-1’
[17:41:03.084] Expression:
[17:41:03.084] {
[17:41:03.084]     do.call(function(...) {
[17:41:03.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.084]             on.exit(options(oopts), add = TRUE)
[17:41:03.084]         }
[17:41:03.084]         {
[17:41:03.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.084]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.084]             })
[17:41:03.084]         }
[17:41:03.084]     }, args = future.call.arguments)
[17:41:03.084] }
[17:41:03.084] Lazy evaluation: FALSE
[17:41:03.084] Asynchronous evaluation: TRUE
[17:41:03.084] Local evaluation: TRUE
[17:41:03.084] Environment: R_GlobalEnv
[17:41:03.084] Capture standard output: TRUE
[17:41:03.084] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:03.084] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:03.084] Packages: 1 packages (‘future.apply’)
[17:41:03.084] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:03.084] Resolved: FALSE
[17:41:03.084] Value: <not collected>
[17:41:03.084] Conditions captured: <none>
[17:41:03.084] Early signaling: FALSE
[17:41:03.084] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:03.084] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.096] Chunk #1 of 2 ... DONE
[17:41:03.096] Chunk #2 of 2 ...
[17:41:03.096]  - Finding globals in 'X' for chunk #2 ...
[17:41:03.096] getGlobalsAndPackages() ...
[17:41:03.096] Searching for globals...
[17:41:03.096] 
[17:41:03.096] Searching for globals ... DONE
[17:41:03.097] - globals: [0] <none>
[17:41:03.097] getGlobalsAndPackages() ... DONE
[17:41:03.097]    + additional globals found: [n=0] 
[17:41:03.097]    + additional namespaces needed: [n=0] 
[17:41:03.097]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:03.097]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:03.097]  - seeds: <none>
[17:41:03.097] getGlobalsAndPackages() ...
[17:41:03.097] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:03.097] Resolving globals: FALSE
[17:41:03.098] Tweak future expression to call with '...' arguments ...
[17:41:03.098] {
[17:41:03.098]     do.call(function(...) {
[17:41:03.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.098]             on.exit(options(oopts), add = TRUE)
[17:41:03.098]         }
[17:41:03.098]         {
[17:41:03.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.098]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.098]             })
[17:41:03.098]         }
[17:41:03.098]     }, args = future.call.arguments)
[17:41:03.098] }
[17:41:03.098] Tweak future expression to call with '...' arguments ... DONE
[17:41:03.099] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:03.099] - packages: [1] ‘future.apply’
[17:41:03.099] getGlobalsAndPackages() ... DONE
[17:41:03.099] run() for ‘Future’ ...
[17:41:03.099] - state: ‘created’
[17:41:03.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:03.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:03.116]   - Field: ‘node’
[17:41:03.116]   - Field: ‘label’
[17:41:03.116]   - Field: ‘local’
[17:41:03.116]   - Field: ‘owner’
[17:41:03.116]   - Field: ‘envir’
[17:41:03.116]   - Field: ‘workers’
[17:41:03.116]   - Field: ‘packages’
[17:41:03.116]   - Field: ‘gc’
[17:41:03.117]   - Field: ‘conditions’
[17:41:03.117]   - Field: ‘persistent’
[17:41:03.117]   - Field: ‘expr’
[17:41:03.117]   - Field: ‘uuid’
[17:41:03.117]   - Field: ‘seed’
[17:41:03.117]   - Field: ‘version’
[17:41:03.117]   - Field: ‘result’
[17:41:03.117]   - Field: ‘asynchronous’
[17:41:03.117]   - Field: ‘calls’
[17:41:03.117]   - Field: ‘globals’
[17:41:03.117]   - Field: ‘stdout’
[17:41:03.117]   - Field: ‘earlySignal’
[17:41:03.118]   - Field: ‘lazy’
[17:41:03.118]   - Field: ‘state’
[17:41:03.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:03.118] - Launch lazy future ...
[17:41:03.118] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:03.118] Packages needed by future strategies (n = 0): <none>
[17:41:03.119] {
[17:41:03.119]     {
[17:41:03.119]         {
[17:41:03.119]             ...future.startTime <- base::Sys.time()
[17:41:03.119]             {
[17:41:03.119]                 {
[17:41:03.119]                   {
[17:41:03.119]                     {
[17:41:03.119]                       {
[17:41:03.119]                         base::local({
[17:41:03.119]                           has_future <- base::requireNamespace("future", 
[17:41:03.119]                             quietly = TRUE)
[17:41:03.119]                           if (has_future) {
[17:41:03.119]                             ns <- base::getNamespace("future")
[17:41:03.119]                             version <- ns[[".package"]][["version"]]
[17:41:03.119]                             if (is.null(version)) 
[17:41:03.119]                               version <- utils::packageVersion("future")
[17:41:03.119]                           }
[17:41:03.119]                           else {
[17:41:03.119]                             version <- NULL
[17:41:03.119]                           }
[17:41:03.119]                           if (!has_future || version < "1.8.0") {
[17:41:03.119]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:03.119]                               "", base::R.version$version.string), 
[17:41:03.119]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:03.119]                                 base::R.version$platform, 8 * 
[17:41:03.119]                                   base::.Machine$sizeof.pointer), 
[17:41:03.119]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:03.119]                                 "release", "version")], collapse = " "), 
[17:41:03.119]                               hostname = base::Sys.info()[["nodename"]])
[17:41:03.119]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:03.119]                               info)
[17:41:03.119]                             info <- base::paste(info, collapse = "; ")
[17:41:03.119]                             if (!has_future) {
[17:41:03.119]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:03.119]                                 info)
[17:41:03.119]                             }
[17:41:03.119]                             else {
[17:41:03.119]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:03.119]                                 info, version)
[17:41:03.119]                             }
[17:41:03.119]                             base::stop(msg)
[17:41:03.119]                           }
[17:41:03.119]                         })
[17:41:03.119]                       }
[17:41:03.119]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:03.119]                       base::options(mc.cores = 1L)
[17:41:03.119]                     }
[17:41:03.119]                     base::local({
[17:41:03.119]                       for (pkg in "future.apply") {
[17:41:03.119]                         base::loadNamespace(pkg)
[17:41:03.119]                         base::library(pkg, character.only = TRUE)
[17:41:03.119]                       }
[17:41:03.119]                     })
[17:41:03.119]                   }
[17:41:03.119]                   options(future.plan = NULL)
[17:41:03.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:03.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:03.119]                 }
[17:41:03.119]                 ...future.workdir <- getwd()
[17:41:03.119]             }
[17:41:03.119]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:03.119]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:03.119]         }
[17:41:03.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:03.119]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:03.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:03.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:03.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:03.119]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:03.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:03.119]             base::names(...future.oldOptions))
[17:41:03.119]     }
[17:41:03.119]     if (FALSE) {
[17:41:03.119]     }
[17:41:03.119]     else {
[17:41:03.119]         if (TRUE) {
[17:41:03.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:03.119]                 open = "w")
[17:41:03.119]         }
[17:41:03.119]         else {
[17:41:03.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:03.119]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:03.119]         }
[17:41:03.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:03.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:03.119]             base::sink(type = "output", split = FALSE)
[17:41:03.119]             base::close(...future.stdout)
[17:41:03.119]         }, add = TRUE)
[17:41:03.119]     }
[17:41:03.119]     ...future.frame <- base::sys.nframe()
[17:41:03.119]     ...future.conditions <- base::list()
[17:41:03.119]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:03.119]     if (FALSE) {
[17:41:03.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:03.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:03.119]     }
[17:41:03.119]     ...future.result <- base::tryCatch({
[17:41:03.119]         base::withCallingHandlers({
[17:41:03.119]             ...future.value <- base::withVisible(base::local({
[17:41:03.119]                 ...future.makeSendCondition <- local({
[17:41:03.119]                   sendCondition <- NULL
[17:41:03.119]                   function(frame = 1L) {
[17:41:03.119]                     if (is.function(sendCondition)) 
[17:41:03.119]                       return(sendCondition)
[17:41:03.119]                     ns <- getNamespace("parallel")
[17:41:03.119]                     if (exists("sendData", mode = "function", 
[17:41:03.119]                       envir = ns)) {
[17:41:03.119]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:03.119]                         envir = ns)
[17:41:03.119]                       envir <- sys.frame(frame)
[17:41:03.119]                       master <- NULL
[17:41:03.119]                       while (!identical(envir, .GlobalEnv) && 
[17:41:03.119]                         !identical(envir, emptyenv())) {
[17:41:03.119]                         if (exists("master", mode = "list", envir = envir, 
[17:41:03.119]                           inherits = FALSE)) {
[17:41:03.119]                           master <- get("master", mode = "list", 
[17:41:03.119]                             envir = envir, inherits = FALSE)
[17:41:03.119]                           if (inherits(master, c("SOCKnode", 
[17:41:03.119]                             "SOCK0node"))) {
[17:41:03.119]                             sendCondition <<- function(cond) {
[17:41:03.119]                               data <- list(type = "VALUE", value = cond, 
[17:41:03.119]                                 success = TRUE)
[17:41:03.119]                               parallel_sendData(master, data)
[17:41:03.119]                             }
[17:41:03.119]                             return(sendCondition)
[17:41:03.119]                           }
[17:41:03.119]                         }
[17:41:03.119]                         frame <- frame + 1L
[17:41:03.119]                         envir <- sys.frame(frame)
[17:41:03.119]                       }
[17:41:03.119]                     }
[17:41:03.119]                     sendCondition <<- function(cond) NULL
[17:41:03.119]                   }
[17:41:03.119]                 })
[17:41:03.119]                 withCallingHandlers({
[17:41:03.119]                   {
[17:41:03.119]                     do.call(function(...) {
[17:41:03.119]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.119]                       if (!identical(...future.globals.maxSize.org, 
[17:41:03.119]                         ...future.globals.maxSize)) {
[17:41:03.119]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.119]                         on.exit(options(oopts), add = TRUE)
[17:41:03.119]                       }
[17:41:03.119]                       {
[17:41:03.119]                         lapply(seq_along(...future.elements_ii), 
[17:41:03.119]                           FUN = function(jj) {
[17:41:03.119]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.119]                             ...future.FUN(...future.X_jj, ...)
[17:41:03.119]                           })
[17:41:03.119]                       }
[17:41:03.119]                     }, args = future.call.arguments)
[17:41:03.119]                   }
[17:41:03.119]                 }, immediateCondition = function(cond) {
[17:41:03.119]                   sendCondition <- ...future.makeSendCondition()
[17:41:03.119]                   sendCondition(cond)
[17:41:03.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.119]                   {
[17:41:03.119]                     inherits <- base::inherits
[17:41:03.119]                     invokeRestart <- base::invokeRestart
[17:41:03.119]                     is.null <- base::is.null
[17:41:03.119]                     muffled <- FALSE
[17:41:03.119]                     if (inherits(cond, "message")) {
[17:41:03.119]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:03.119]                       if (muffled) 
[17:41:03.119]                         invokeRestart("muffleMessage")
[17:41:03.119]                     }
[17:41:03.119]                     else if (inherits(cond, "warning")) {
[17:41:03.119]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:03.119]                       if (muffled) 
[17:41:03.119]                         invokeRestart("muffleWarning")
[17:41:03.119]                     }
[17:41:03.119]                     else if (inherits(cond, "condition")) {
[17:41:03.119]                       if (!is.null(pattern)) {
[17:41:03.119]                         computeRestarts <- base::computeRestarts
[17:41:03.119]                         grepl <- base::grepl
[17:41:03.119]                         restarts <- computeRestarts(cond)
[17:41:03.119]                         for (restart in restarts) {
[17:41:03.119]                           name <- restart$name
[17:41:03.119]                           if (is.null(name)) 
[17:41:03.119]                             next
[17:41:03.119]                           if (!grepl(pattern, name)) 
[17:41:03.119]                             next
[17:41:03.119]                           invokeRestart(restart)
[17:41:03.119]                           muffled <- TRUE
[17:41:03.119]                           break
[17:41:03.119]                         }
[17:41:03.119]                       }
[17:41:03.119]                     }
[17:41:03.119]                     invisible(muffled)
[17:41:03.119]                   }
[17:41:03.119]                   muffleCondition(cond)
[17:41:03.119]                 })
[17:41:03.119]             }))
[17:41:03.119]             future::FutureResult(value = ...future.value$value, 
[17:41:03.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:03.119]                   ...future.rng), globalenv = if (FALSE) 
[17:41:03.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:03.119]                     ...future.globalenv.names))
[17:41:03.119]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:03.119]         }, condition = base::local({
[17:41:03.119]             c <- base::c
[17:41:03.119]             inherits <- base::inherits
[17:41:03.119]             invokeRestart <- base::invokeRestart
[17:41:03.119]             length <- base::length
[17:41:03.119]             list <- base::list
[17:41:03.119]             seq.int <- base::seq.int
[17:41:03.119]             signalCondition <- base::signalCondition
[17:41:03.119]             sys.calls <- base::sys.calls
[17:41:03.119]             `[[` <- base::`[[`
[17:41:03.119]             `+` <- base::`+`
[17:41:03.119]             `<<-` <- base::`<<-`
[17:41:03.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:03.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:03.119]                   3L)]
[17:41:03.119]             }
[17:41:03.119]             function(cond) {
[17:41:03.119]                 is_error <- inherits(cond, "error")
[17:41:03.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:03.119]                   NULL)
[17:41:03.119]                 if (is_error) {
[17:41:03.119]                   sessionInformation <- function() {
[17:41:03.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:03.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:03.119]                       search = base::search(), system = base::Sys.info())
[17:41:03.119]                   }
[17:41:03.119]                   ...future.conditions[[length(...future.conditions) + 
[17:41:03.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:03.119]                     cond$call), session = sessionInformation(), 
[17:41:03.119]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:03.119]                   signalCondition(cond)
[17:41:03.119]                 }
[17:41:03.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:03.119]                 "immediateCondition"))) {
[17:41:03.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:03.119]                   ...future.conditions[[length(...future.conditions) + 
[17:41:03.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:03.119]                   if (TRUE && !signal) {
[17:41:03.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.119]                     {
[17:41:03.119]                       inherits <- base::inherits
[17:41:03.119]                       invokeRestart <- base::invokeRestart
[17:41:03.119]                       is.null <- base::is.null
[17:41:03.119]                       muffled <- FALSE
[17:41:03.119]                       if (inherits(cond, "message")) {
[17:41:03.119]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:03.119]                         if (muffled) 
[17:41:03.119]                           invokeRestart("muffleMessage")
[17:41:03.119]                       }
[17:41:03.119]                       else if (inherits(cond, "warning")) {
[17:41:03.119]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:03.119]                         if (muffled) 
[17:41:03.119]                           invokeRestart("muffleWarning")
[17:41:03.119]                       }
[17:41:03.119]                       else if (inherits(cond, "condition")) {
[17:41:03.119]                         if (!is.null(pattern)) {
[17:41:03.119]                           computeRestarts <- base::computeRestarts
[17:41:03.119]                           grepl <- base::grepl
[17:41:03.119]                           restarts <- computeRestarts(cond)
[17:41:03.119]                           for (restart in restarts) {
[17:41:03.119]                             name <- restart$name
[17:41:03.119]                             if (is.null(name)) 
[17:41:03.119]                               next
[17:41:03.119]                             if (!grepl(pattern, name)) 
[17:41:03.119]                               next
[17:41:03.119]                             invokeRestart(restart)
[17:41:03.119]                             muffled <- TRUE
[17:41:03.119]                             break
[17:41:03.119]                           }
[17:41:03.119]                         }
[17:41:03.119]                       }
[17:41:03.119]                       invisible(muffled)
[17:41:03.119]                     }
[17:41:03.119]                     muffleCondition(cond, pattern = "^muffle")
[17:41:03.119]                   }
[17:41:03.119]                 }
[17:41:03.119]                 else {
[17:41:03.119]                   if (TRUE) {
[17:41:03.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.119]                     {
[17:41:03.119]                       inherits <- base::inherits
[17:41:03.119]                       invokeRestart <- base::invokeRestart
[17:41:03.119]                       is.null <- base::is.null
[17:41:03.119]                       muffled <- FALSE
[17:41:03.119]                       if (inherits(cond, "message")) {
[17:41:03.119]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:03.119]                         if (muffled) 
[17:41:03.119]                           invokeRestart("muffleMessage")
[17:41:03.119]                       }
[17:41:03.119]                       else if (inherits(cond, "warning")) {
[17:41:03.119]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:03.119]                         if (muffled) 
[17:41:03.119]                           invokeRestart("muffleWarning")
[17:41:03.119]                       }
[17:41:03.119]                       else if (inherits(cond, "condition")) {
[17:41:03.119]                         if (!is.null(pattern)) {
[17:41:03.119]                           computeRestarts <- base::computeRestarts
[17:41:03.119]                           grepl <- base::grepl
[17:41:03.119]                           restarts <- computeRestarts(cond)
[17:41:03.119]                           for (restart in restarts) {
[17:41:03.119]                             name <- restart$name
[17:41:03.119]                             if (is.null(name)) 
[17:41:03.119]                               next
[17:41:03.119]                             if (!grepl(pattern, name)) 
[17:41:03.119]                               next
[17:41:03.119]                             invokeRestart(restart)
[17:41:03.119]                             muffled <- TRUE
[17:41:03.119]                             break
[17:41:03.119]                           }
[17:41:03.119]                         }
[17:41:03.119]                       }
[17:41:03.119]                       invisible(muffled)
[17:41:03.119]                     }
[17:41:03.119]                     muffleCondition(cond, pattern = "^muffle")
[17:41:03.119]                   }
[17:41:03.119]                 }
[17:41:03.119]             }
[17:41:03.119]         }))
[17:41:03.119]     }, error = function(ex) {
[17:41:03.119]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:03.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:03.119]                 ...future.rng), started = ...future.startTime, 
[17:41:03.119]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:03.119]             version = "1.8"), class = "FutureResult")
[17:41:03.119]     }, finally = {
[17:41:03.119]         if (!identical(...future.workdir, getwd())) 
[17:41:03.119]             setwd(...future.workdir)
[17:41:03.119]         {
[17:41:03.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:03.119]                 ...future.oldOptions$nwarnings <- NULL
[17:41:03.119]             }
[17:41:03.119]             base::options(...future.oldOptions)
[17:41:03.119]             if (.Platform$OS.type == "windows") {
[17:41:03.119]                 old_names <- names(...future.oldEnvVars)
[17:41:03.119]                 envs <- base::Sys.getenv()
[17:41:03.119]                 names <- names(envs)
[17:41:03.119]                 common <- intersect(names, old_names)
[17:41:03.119]                 added <- setdiff(names, old_names)
[17:41:03.119]                 removed <- setdiff(old_names, names)
[17:41:03.119]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:03.119]                   envs[common]]
[17:41:03.119]                 NAMES <- toupper(changed)
[17:41:03.119]                 args <- list()
[17:41:03.119]                 for (kk in seq_along(NAMES)) {
[17:41:03.119]                   name <- changed[[kk]]
[17:41:03.119]                   NAME <- NAMES[[kk]]
[17:41:03.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.119]                     next
[17:41:03.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:03.119]                 }
[17:41:03.119]                 NAMES <- toupper(added)
[17:41:03.119]                 for (kk in seq_along(NAMES)) {
[17:41:03.119]                   name <- added[[kk]]
[17:41:03.119]                   NAME <- NAMES[[kk]]
[17:41:03.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.119]                     next
[17:41:03.119]                   args[[name]] <- ""
[17:41:03.119]                 }
[17:41:03.119]                 NAMES <- toupper(removed)
[17:41:03.119]                 for (kk in seq_along(NAMES)) {
[17:41:03.119]                   name <- removed[[kk]]
[17:41:03.119]                   NAME <- NAMES[[kk]]
[17:41:03.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.119]                     next
[17:41:03.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:03.119]                 }
[17:41:03.119]                 if (length(args) > 0) 
[17:41:03.119]                   base::do.call(base::Sys.setenv, args = args)
[17:41:03.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:03.119]             }
[17:41:03.119]             else {
[17:41:03.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:03.119]             }
[17:41:03.119]             {
[17:41:03.119]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:03.119]                   0L) {
[17:41:03.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:03.119]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:03.119]                   base::options(opts)
[17:41:03.119]                 }
[17:41:03.119]                 {
[17:41:03.119]                   {
[17:41:03.119]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:03.119]                     NULL
[17:41:03.119]                   }
[17:41:03.119]                   options(future.plan = NULL)
[17:41:03.119]                   if (is.na(NA_character_)) 
[17:41:03.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:03.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:03.119]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:03.119]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:03.119]                     envir = parent.frame()) 
[17:41:03.119]                   {
[17:41:03.119]                     if (is.function(workers)) 
[17:41:03.119]                       workers <- workers()
[17:41:03.119]                     workers <- structure(as.integer(workers), 
[17:41:03.119]                       class = class(workers))
[17:41:03.119]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:03.119]                       workers >= 1)
[17:41:03.119]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:03.119]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:03.119]                     }
[17:41:03.119]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:03.119]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:03.119]                       envir = envir)
[17:41:03.119]                     if (!future$lazy) 
[17:41:03.119]                       future <- run(future)
[17:41:03.119]                     invisible(future)
[17:41:03.119]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:03.119]                 }
[17:41:03.119]             }
[17:41:03.119]         }
[17:41:03.119]     })
[17:41:03.119]     if (TRUE) {
[17:41:03.119]         base::sink(type = "output", split = FALSE)
[17:41:03.119]         if (TRUE) {
[17:41:03.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:03.119]         }
[17:41:03.119]         else {
[17:41:03.119]             ...future.result["stdout"] <- base::list(NULL)
[17:41:03.119]         }
[17:41:03.119]         base::close(...future.stdout)
[17:41:03.119]         ...future.stdout <- NULL
[17:41:03.119]     }
[17:41:03.119]     ...future.result$conditions <- ...future.conditions
[17:41:03.119]     ...future.result$finished <- base::Sys.time()
[17:41:03.119]     ...future.result
[17:41:03.119] }
[17:41:03.122] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[17:41:03.122] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:03.167] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:03.167] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:41:03.168] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:41:03.168] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:03.168] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:03.168] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:03.211] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:03.211] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:03.255] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:03.255] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:41:03.256] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.256] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:41:03.256] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:41:03.256] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:03.257] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.257] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:03.257] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:03.258] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:03.258] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.258] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:03.258] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.258] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[17:41:03.259] MultisessionFuture started
[17:41:03.259] - Launch lazy future ... done
[17:41:03.259] run() for ‘MultisessionFuture’ ... done
[17:41:03.260] Created future:
[17:41:03.260] MultisessionFuture:
[17:41:03.260] Label: ‘future_vapply-2’
[17:41:03.260] Expression:
[17:41:03.260] {
[17:41:03.260]     do.call(function(...) {
[17:41:03.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.260]             on.exit(options(oopts), add = TRUE)
[17:41:03.260]         }
[17:41:03.260]         {
[17:41:03.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.260]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.260]             })
[17:41:03.260]         }
[17:41:03.260]     }, args = future.call.arguments)
[17:41:03.260] }
[17:41:03.260] Lazy evaluation: FALSE
[17:41:03.260] Asynchronous evaluation: TRUE
[17:41:03.260] Local evaluation: TRUE
[17:41:03.260] Environment: R_GlobalEnv
[17:41:03.260] Capture standard output: TRUE
[17:41:03.260] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:03.260] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:03.260] Packages: 1 packages (‘future.apply’)
[17:41:03.260] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:03.260] Resolved: FALSE
[17:41:03.260] Value: <not collected>
[17:41:03.260] Conditions captured: <none>
[17:41:03.260] Early signaling: FALSE
[17:41:03.260] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:03.260] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.271] Chunk #2 of 2 ... DONE
[17:41:03.272] Launching 2 futures (chunks) ... DONE
[17:41:03.272] Resolving 2 futures (chunks) ...
[17:41:03.272] resolve() on list ...
[17:41:03.272]  recursive: 0
[17:41:03.272]  length: 2
[17:41:03.272] 
[17:41:03.273] receiveMessageFromWorker() for ClusterFuture ...
[17:41:03.273] - Validating connection of MultisessionFuture
[17:41:03.273] - received message: FutureResult
[17:41:03.273] - Received FutureResult
[17:41:03.273] - Erased future from FutureRegistry
[17:41:03.273] result() for ClusterFuture ...
[17:41:03.273] - result already collected: FutureResult
[17:41:03.273] result() for ClusterFuture ... done
[17:41:03.273] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:03.273] Future #1
[17:41:03.274] result() for ClusterFuture ...
[17:41:03.274] - result already collected: FutureResult
[17:41:03.274] result() for ClusterFuture ... done
[17:41:03.274] result() for ClusterFuture ...
[17:41:03.274] - result already collected: FutureResult
[17:41:03.274] result() for ClusterFuture ... done
[17:41:03.274] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:03.274] - nx: 2
[17:41:03.274] - relay: TRUE
[17:41:03.274] - stdout: TRUE
[17:41:03.274] - signal: TRUE
[17:41:03.275] - resignal: FALSE
[17:41:03.275] - force: TRUE
[17:41:03.275] - relayed: [n=2] FALSE, FALSE
[17:41:03.275] - queued futures: [n=2] FALSE, FALSE
[17:41:03.275]  - until=1
[17:41:03.275]  - relaying element #1
[17:41:03.275] result() for ClusterFuture ...
[17:41:03.275] - result already collected: FutureResult
[17:41:03.275] result() for ClusterFuture ... done
[17:41:03.275] result() for ClusterFuture ...
[17:41:03.275] - result already collected: FutureResult
[17:41:03.275] result() for ClusterFuture ... done
[17:41:03.276] result() for ClusterFuture ...
[17:41:03.276] - result already collected: FutureResult
[17:41:03.276] result() for ClusterFuture ... done
[17:41:03.276] result() for ClusterFuture ...
[17:41:03.276] - result already collected: FutureResult
[17:41:03.276] result() for ClusterFuture ... done
[17:41:03.276] - relayed: [n=2] TRUE, FALSE
[17:41:03.276] - queued futures: [n=2] TRUE, FALSE
[17:41:03.276] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:03.276]  length: 1 (resolved future 1)
[17:41:03.318] receiveMessageFromWorker() for ClusterFuture ...
[17:41:03.318] - Validating connection of MultisessionFuture
[17:41:03.318] - received message: FutureResult
[17:41:03.318] - Received FutureResult
[17:41:03.319] - Erased future from FutureRegistry
[17:41:03.319] result() for ClusterFuture ...
[17:41:03.319] - result already collected: FutureResult
[17:41:03.319] result() for ClusterFuture ... done
[17:41:03.319] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:03.319] Future #2
[17:41:03.319] result() for ClusterFuture ...
[17:41:03.319] - result already collected: FutureResult
[17:41:03.319] result() for ClusterFuture ... done
[17:41:03.319] result() for ClusterFuture ...
[17:41:03.319] - result already collected: FutureResult
[17:41:03.320] result() for ClusterFuture ... done
[17:41:03.320] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:03.320] - nx: 2
[17:41:03.320] - relay: TRUE
[17:41:03.320] - stdout: TRUE
[17:41:03.320] - signal: TRUE
[17:41:03.320] - resignal: FALSE
[17:41:03.320] - force: TRUE
[17:41:03.320] - relayed: [n=2] TRUE, FALSE
[17:41:03.320] - queued futures: [n=2] TRUE, FALSE
[17:41:03.320]  - until=2
[17:41:03.321]  - relaying element #2
[17:41:03.321] result() for ClusterFuture ...
[17:41:03.321] - result already collected: FutureResult
[17:41:03.321] result() for ClusterFuture ... done
[17:41:03.321] result() for ClusterFuture ...
[17:41:03.321] - result already collected: FutureResult
[17:41:03.321] result() for ClusterFuture ... done
[17:41:03.321] result() for ClusterFuture ...
[17:41:03.321] - result already collected: FutureResult
[17:41:03.321] result() for ClusterFuture ... done
[17:41:03.321] result() for ClusterFuture ...
[17:41:03.322] - result already collected: FutureResult
[17:41:03.322] result() for ClusterFuture ... done
[17:41:03.322] - relayed: [n=2] TRUE, TRUE
[17:41:03.322] - queued futures: [n=2] TRUE, TRUE
[17:41:03.322] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:41:03.322]  length: 0 (resolved future 2)
[17:41:03.322] Relaying remaining futures
[17:41:03.322] signalConditionsASAP(NULL, pos=0) ...
[17:41:03.322] - nx: 2
[17:41:03.322] - relay: TRUE
[17:41:03.322] - stdout: TRUE
[17:41:03.323] - signal: TRUE
[17:41:03.323] - resignal: FALSE
[17:41:03.323] - force: TRUE
[17:41:03.323] - relayed: [n=2] TRUE, TRUE
[17:41:03.323] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:03.323] - relayed: [n=2] TRUE, TRUE
[17:41:03.323] - queued futures: [n=2] TRUE, TRUE
[17:41:03.323] signalConditionsASAP(NULL, pos=0) ... done
[17:41:03.323] resolve() on list ... DONE
[17:41:03.323] result() for ClusterFuture ...
[17:41:03.323] - result already collected: FutureResult
[17:41:03.324] result() for ClusterFuture ... done
[17:41:03.324] result() for ClusterFuture ...
[17:41:03.324] - result already collected: FutureResult
[17:41:03.324] result() for ClusterFuture ... done
[17:41:03.324] result() for ClusterFuture ...
[17:41:03.324] - result already collected: FutureResult
[17:41:03.324] result() for ClusterFuture ... done
[17:41:03.324] result() for ClusterFuture ...
[17:41:03.324] - result already collected: FutureResult
[17:41:03.324] result() for ClusterFuture ... done
[17:41:03.324]  - Number of value chunks collected: 2
[17:41:03.325] Resolving 2 futures (chunks) ... DONE
[17:41:03.325] Reducing values from 2 chunks ...
[17:41:03.325]  - Number of values collected after concatenation: 3
[17:41:03.325]  - Number of values expected: 3
[17:41:03.325] Reducing values from 2 chunks ... DONE
[17:41:03.325] future_lapply() ... DONE
- exceptions ...
[17:41:03.325] future_lapply() ...
[17:41:03.330] Number of chunks: 2
[17:41:03.331] getGlobalsAndPackagesXApply() ...
[17:41:03.331]  - future.globals: TRUE
[17:41:03.331] getGlobalsAndPackages() ...
[17:41:03.331] Searching for globals...
[17:41:03.334] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:41:03.334] Searching for globals ... DONE
[17:41:03.334] Resolving globals: FALSE
[17:41:03.335] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:41:03.336] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:41:03.336] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:03.336] - packages: [1] ‘future.apply’
[17:41:03.336] getGlobalsAndPackages() ... DONE
[17:41:03.336]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:41:03.336]  - needed namespaces: [n=1] ‘future.apply’
[17:41:03.336] Finding globals ... DONE
[17:41:03.336]  - use_args: TRUE
[17:41:03.337]  - Getting '...' globals ...
[17:41:03.337] resolve() on list ...
[17:41:03.337]  recursive: 0
[17:41:03.337]  length: 1
[17:41:03.337]  elements: ‘...’
[17:41:03.337]  length: 0 (resolved future 1)
[17:41:03.337] resolve() on list ... DONE
[17:41:03.337]    - '...' content: [n=0] 
[17:41:03.337] List of 1
[17:41:03.337]  $ ...: list()
[17:41:03.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:03.337]  - attr(*, "where")=List of 1
[17:41:03.337]   ..$ ...:<environment: 0x564f310eb920> 
[17:41:03.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:03.337]  - attr(*, "resolved")= logi TRUE
[17:41:03.337]  - attr(*, "total_size")= num NA
[17:41:03.340]  - Getting '...' globals ... DONE
[17:41:03.340] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:41:03.340] List of 8
[17:41:03.340]  $ ...future.FUN:function (x, ...)  
[17:41:03.340]  $ x_FUN        :function (x)  
[17:41:03.340]  $ times        : int 2
[17:41:03.340]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:41:03.340]  $ stop_if_not  :function (...)  
[17:41:03.340]  $ dim          : NULL
[17:41:03.340]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:41:03.340]  $ ...          : list()
[17:41:03.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:03.340]  - attr(*, "where")=List of 8
[17:41:03.340]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ times        :<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ dim          :<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:41:03.340]   ..$ ...          :<environment: 0x564f310eb920> 
[17:41:03.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:03.340]  - attr(*, "resolved")= logi FALSE
[17:41:03.340]  - attr(*, "total_size")= num 95128
[17:41:03.346] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:41:03.346] getGlobalsAndPackagesXApply() ... DONE
[17:41:03.346] Number of futures (= number of chunks): 2
[17:41:03.346] Launching 2 futures (chunks) ...
[17:41:03.346] Chunk #1 of 2 ...
[17:41:03.346]  - Finding globals in 'X' for chunk #1 ...
[17:41:03.346] getGlobalsAndPackages() ...
[17:41:03.346] Searching for globals...
[17:41:03.349] 
[17:41:03.349] Searching for globals ... DONE
[17:41:03.350] - globals: [0] <none>
[17:41:03.350] getGlobalsAndPackages() ... DONE
[17:41:03.350]    + additional globals found: [n=0] 
[17:41:03.350]    + additional namespaces needed: [n=0] 
[17:41:03.350]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:03.350]  - seeds: <none>
[17:41:03.350] getGlobalsAndPackages() ...
[17:41:03.350] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:03.350] Resolving globals: FALSE
[17:41:03.350] Tweak future expression to call with '...' arguments ...
[17:41:03.351] {
[17:41:03.351]     do.call(function(...) {
[17:41:03.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.351]             on.exit(options(oopts), add = TRUE)
[17:41:03.351]         }
[17:41:03.351]         {
[17:41:03.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.351]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.351]             })
[17:41:03.351]         }
[17:41:03.351]     }, args = future.call.arguments)
[17:41:03.351] }
[17:41:03.351] Tweak future expression to call with '...' arguments ... DONE
[17:41:03.351] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:03.351] - packages: [1] ‘future.apply’
[17:41:03.352] getGlobalsAndPackages() ... DONE
[17:41:03.352] run() for ‘Future’ ...
[17:41:03.352] - state: ‘created’
[17:41:03.352] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:03.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:03.367]   - Field: ‘node’
[17:41:03.367]   - Field: ‘label’
[17:41:03.367]   - Field: ‘local’
[17:41:03.367]   - Field: ‘owner’
[17:41:03.367]   - Field: ‘envir’
[17:41:03.367]   - Field: ‘workers’
[17:41:03.367]   - Field: ‘packages’
[17:41:03.367]   - Field: ‘gc’
[17:41:03.368]   - Field: ‘conditions’
[17:41:03.368]   - Field: ‘persistent’
[17:41:03.368]   - Field: ‘expr’
[17:41:03.368]   - Field: ‘uuid’
[17:41:03.368]   - Field: ‘seed’
[17:41:03.368]   - Field: ‘version’
[17:41:03.368]   - Field: ‘result’
[17:41:03.368]   - Field: ‘asynchronous’
[17:41:03.368]   - Field: ‘calls’
[17:41:03.368]   - Field: ‘globals’
[17:41:03.368]   - Field: ‘stdout’
[17:41:03.369]   - Field: ‘earlySignal’
[17:41:03.369]   - Field: ‘lazy’
[17:41:03.369]   - Field: ‘state’
[17:41:03.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:03.369] - Launch lazy future ...
[17:41:03.369] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:03.369] Packages needed by future strategies (n = 0): <none>
[17:41:03.370] {
[17:41:03.370]     {
[17:41:03.370]         {
[17:41:03.370]             ...future.startTime <- base::Sys.time()
[17:41:03.370]             {
[17:41:03.370]                 {
[17:41:03.370]                   {
[17:41:03.370]                     {
[17:41:03.370]                       {
[17:41:03.370]                         base::local({
[17:41:03.370]                           has_future <- base::requireNamespace("future", 
[17:41:03.370]                             quietly = TRUE)
[17:41:03.370]                           if (has_future) {
[17:41:03.370]                             ns <- base::getNamespace("future")
[17:41:03.370]                             version <- ns[[".package"]][["version"]]
[17:41:03.370]                             if (is.null(version)) 
[17:41:03.370]                               version <- utils::packageVersion("future")
[17:41:03.370]                           }
[17:41:03.370]                           else {
[17:41:03.370]                             version <- NULL
[17:41:03.370]                           }
[17:41:03.370]                           if (!has_future || version < "1.8.0") {
[17:41:03.370]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:03.370]                               "", base::R.version$version.string), 
[17:41:03.370]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:03.370]                                 base::R.version$platform, 8 * 
[17:41:03.370]                                   base::.Machine$sizeof.pointer), 
[17:41:03.370]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:03.370]                                 "release", "version")], collapse = " "), 
[17:41:03.370]                               hostname = base::Sys.info()[["nodename"]])
[17:41:03.370]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:03.370]                               info)
[17:41:03.370]                             info <- base::paste(info, collapse = "; ")
[17:41:03.370]                             if (!has_future) {
[17:41:03.370]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:03.370]                                 info)
[17:41:03.370]                             }
[17:41:03.370]                             else {
[17:41:03.370]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:03.370]                                 info, version)
[17:41:03.370]                             }
[17:41:03.370]                             base::stop(msg)
[17:41:03.370]                           }
[17:41:03.370]                         })
[17:41:03.370]                       }
[17:41:03.370]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:03.370]                       base::options(mc.cores = 1L)
[17:41:03.370]                     }
[17:41:03.370]                     base::local({
[17:41:03.370]                       for (pkg in "future.apply") {
[17:41:03.370]                         base::loadNamespace(pkg)
[17:41:03.370]                         base::library(pkg, character.only = TRUE)
[17:41:03.370]                       }
[17:41:03.370]                     })
[17:41:03.370]                   }
[17:41:03.370]                   options(future.plan = NULL)
[17:41:03.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:03.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:03.370]                 }
[17:41:03.370]                 ...future.workdir <- getwd()
[17:41:03.370]             }
[17:41:03.370]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:03.370]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:03.370]         }
[17:41:03.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:03.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:03.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:03.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:03.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:03.370]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:03.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:03.370]             base::names(...future.oldOptions))
[17:41:03.370]     }
[17:41:03.370]     if (FALSE) {
[17:41:03.370]     }
[17:41:03.370]     else {
[17:41:03.370]         if (TRUE) {
[17:41:03.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:03.370]                 open = "w")
[17:41:03.370]         }
[17:41:03.370]         else {
[17:41:03.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:03.370]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:03.370]         }
[17:41:03.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:03.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:03.370]             base::sink(type = "output", split = FALSE)
[17:41:03.370]             base::close(...future.stdout)
[17:41:03.370]         }, add = TRUE)
[17:41:03.370]     }
[17:41:03.370]     ...future.frame <- base::sys.nframe()
[17:41:03.370]     ...future.conditions <- base::list()
[17:41:03.370]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:03.370]     if (FALSE) {
[17:41:03.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:03.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:03.370]     }
[17:41:03.370]     ...future.result <- base::tryCatch({
[17:41:03.370]         base::withCallingHandlers({
[17:41:03.370]             ...future.value <- base::withVisible(base::local({
[17:41:03.370]                 ...future.makeSendCondition <- local({
[17:41:03.370]                   sendCondition <- NULL
[17:41:03.370]                   function(frame = 1L) {
[17:41:03.370]                     if (is.function(sendCondition)) 
[17:41:03.370]                       return(sendCondition)
[17:41:03.370]                     ns <- getNamespace("parallel")
[17:41:03.370]                     if (exists("sendData", mode = "function", 
[17:41:03.370]                       envir = ns)) {
[17:41:03.370]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:03.370]                         envir = ns)
[17:41:03.370]                       envir <- sys.frame(frame)
[17:41:03.370]                       master <- NULL
[17:41:03.370]                       while (!identical(envir, .GlobalEnv) && 
[17:41:03.370]                         !identical(envir, emptyenv())) {
[17:41:03.370]                         if (exists("master", mode = "list", envir = envir, 
[17:41:03.370]                           inherits = FALSE)) {
[17:41:03.370]                           master <- get("master", mode = "list", 
[17:41:03.370]                             envir = envir, inherits = FALSE)
[17:41:03.370]                           if (inherits(master, c("SOCKnode", 
[17:41:03.370]                             "SOCK0node"))) {
[17:41:03.370]                             sendCondition <<- function(cond) {
[17:41:03.370]                               data <- list(type = "VALUE", value = cond, 
[17:41:03.370]                                 success = TRUE)
[17:41:03.370]                               parallel_sendData(master, data)
[17:41:03.370]                             }
[17:41:03.370]                             return(sendCondition)
[17:41:03.370]                           }
[17:41:03.370]                         }
[17:41:03.370]                         frame <- frame + 1L
[17:41:03.370]                         envir <- sys.frame(frame)
[17:41:03.370]                       }
[17:41:03.370]                     }
[17:41:03.370]                     sendCondition <<- function(cond) NULL
[17:41:03.370]                   }
[17:41:03.370]                 })
[17:41:03.370]                 withCallingHandlers({
[17:41:03.370]                   {
[17:41:03.370]                     do.call(function(...) {
[17:41:03.370]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.370]                       if (!identical(...future.globals.maxSize.org, 
[17:41:03.370]                         ...future.globals.maxSize)) {
[17:41:03.370]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.370]                         on.exit(options(oopts), add = TRUE)
[17:41:03.370]                       }
[17:41:03.370]                       {
[17:41:03.370]                         lapply(seq_along(...future.elements_ii), 
[17:41:03.370]                           FUN = function(jj) {
[17:41:03.370]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.370]                             ...future.FUN(...future.X_jj, ...)
[17:41:03.370]                           })
[17:41:03.370]                       }
[17:41:03.370]                     }, args = future.call.arguments)
[17:41:03.370]                   }
[17:41:03.370]                 }, immediateCondition = function(cond) {
[17:41:03.370]                   sendCondition <- ...future.makeSendCondition()
[17:41:03.370]                   sendCondition(cond)
[17:41:03.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.370]                   {
[17:41:03.370]                     inherits <- base::inherits
[17:41:03.370]                     invokeRestart <- base::invokeRestart
[17:41:03.370]                     is.null <- base::is.null
[17:41:03.370]                     muffled <- FALSE
[17:41:03.370]                     if (inherits(cond, "message")) {
[17:41:03.370]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:03.370]                       if (muffled) 
[17:41:03.370]                         invokeRestart("muffleMessage")
[17:41:03.370]                     }
[17:41:03.370]                     else if (inherits(cond, "warning")) {
[17:41:03.370]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:03.370]                       if (muffled) 
[17:41:03.370]                         invokeRestart("muffleWarning")
[17:41:03.370]                     }
[17:41:03.370]                     else if (inherits(cond, "condition")) {
[17:41:03.370]                       if (!is.null(pattern)) {
[17:41:03.370]                         computeRestarts <- base::computeRestarts
[17:41:03.370]                         grepl <- base::grepl
[17:41:03.370]                         restarts <- computeRestarts(cond)
[17:41:03.370]                         for (restart in restarts) {
[17:41:03.370]                           name <- restart$name
[17:41:03.370]                           if (is.null(name)) 
[17:41:03.370]                             next
[17:41:03.370]                           if (!grepl(pattern, name)) 
[17:41:03.370]                             next
[17:41:03.370]                           invokeRestart(restart)
[17:41:03.370]                           muffled <- TRUE
[17:41:03.370]                           break
[17:41:03.370]                         }
[17:41:03.370]                       }
[17:41:03.370]                     }
[17:41:03.370]                     invisible(muffled)
[17:41:03.370]                   }
[17:41:03.370]                   muffleCondition(cond)
[17:41:03.370]                 })
[17:41:03.370]             }))
[17:41:03.370]             future::FutureResult(value = ...future.value$value, 
[17:41:03.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:03.370]                   ...future.rng), globalenv = if (FALSE) 
[17:41:03.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:03.370]                     ...future.globalenv.names))
[17:41:03.370]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:03.370]         }, condition = base::local({
[17:41:03.370]             c <- base::c
[17:41:03.370]             inherits <- base::inherits
[17:41:03.370]             invokeRestart <- base::invokeRestart
[17:41:03.370]             length <- base::length
[17:41:03.370]             list <- base::list
[17:41:03.370]             seq.int <- base::seq.int
[17:41:03.370]             signalCondition <- base::signalCondition
[17:41:03.370]             sys.calls <- base::sys.calls
[17:41:03.370]             `[[` <- base::`[[`
[17:41:03.370]             `+` <- base::`+`
[17:41:03.370]             `<<-` <- base::`<<-`
[17:41:03.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:03.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:03.370]                   3L)]
[17:41:03.370]             }
[17:41:03.370]             function(cond) {
[17:41:03.370]                 is_error <- inherits(cond, "error")
[17:41:03.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:03.370]                   NULL)
[17:41:03.370]                 if (is_error) {
[17:41:03.370]                   sessionInformation <- function() {
[17:41:03.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:03.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:03.370]                       search = base::search(), system = base::Sys.info())
[17:41:03.370]                   }
[17:41:03.370]                   ...future.conditions[[length(...future.conditions) + 
[17:41:03.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:03.370]                     cond$call), session = sessionInformation(), 
[17:41:03.370]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:03.370]                   signalCondition(cond)
[17:41:03.370]                 }
[17:41:03.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:03.370]                 "immediateCondition"))) {
[17:41:03.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:03.370]                   ...future.conditions[[length(...future.conditions) + 
[17:41:03.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:03.370]                   if (TRUE && !signal) {
[17:41:03.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.370]                     {
[17:41:03.370]                       inherits <- base::inherits
[17:41:03.370]                       invokeRestart <- base::invokeRestart
[17:41:03.370]                       is.null <- base::is.null
[17:41:03.370]                       muffled <- FALSE
[17:41:03.370]                       if (inherits(cond, "message")) {
[17:41:03.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:03.370]                         if (muffled) 
[17:41:03.370]                           invokeRestart("muffleMessage")
[17:41:03.370]                       }
[17:41:03.370]                       else if (inherits(cond, "warning")) {
[17:41:03.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:03.370]                         if (muffled) 
[17:41:03.370]                           invokeRestart("muffleWarning")
[17:41:03.370]                       }
[17:41:03.370]                       else if (inherits(cond, "condition")) {
[17:41:03.370]                         if (!is.null(pattern)) {
[17:41:03.370]                           computeRestarts <- base::computeRestarts
[17:41:03.370]                           grepl <- base::grepl
[17:41:03.370]                           restarts <- computeRestarts(cond)
[17:41:03.370]                           for (restart in restarts) {
[17:41:03.370]                             name <- restart$name
[17:41:03.370]                             if (is.null(name)) 
[17:41:03.370]                               next
[17:41:03.370]                             if (!grepl(pattern, name)) 
[17:41:03.370]                               next
[17:41:03.370]                             invokeRestart(restart)
[17:41:03.370]                             muffled <- TRUE
[17:41:03.370]                             break
[17:41:03.370]                           }
[17:41:03.370]                         }
[17:41:03.370]                       }
[17:41:03.370]                       invisible(muffled)
[17:41:03.370]                     }
[17:41:03.370]                     muffleCondition(cond, pattern = "^muffle")
[17:41:03.370]                   }
[17:41:03.370]                 }
[17:41:03.370]                 else {
[17:41:03.370]                   if (TRUE) {
[17:41:03.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.370]                     {
[17:41:03.370]                       inherits <- base::inherits
[17:41:03.370]                       invokeRestart <- base::invokeRestart
[17:41:03.370]                       is.null <- base::is.null
[17:41:03.370]                       muffled <- FALSE
[17:41:03.370]                       if (inherits(cond, "message")) {
[17:41:03.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:03.370]                         if (muffled) 
[17:41:03.370]                           invokeRestart("muffleMessage")
[17:41:03.370]                       }
[17:41:03.370]                       else if (inherits(cond, "warning")) {
[17:41:03.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:03.370]                         if (muffled) 
[17:41:03.370]                           invokeRestart("muffleWarning")
[17:41:03.370]                       }
[17:41:03.370]                       else if (inherits(cond, "condition")) {
[17:41:03.370]                         if (!is.null(pattern)) {
[17:41:03.370]                           computeRestarts <- base::computeRestarts
[17:41:03.370]                           grepl <- base::grepl
[17:41:03.370]                           restarts <- computeRestarts(cond)
[17:41:03.370]                           for (restart in restarts) {
[17:41:03.370]                             name <- restart$name
[17:41:03.370]                             if (is.null(name)) 
[17:41:03.370]                               next
[17:41:03.370]                             if (!grepl(pattern, name)) 
[17:41:03.370]                               next
[17:41:03.370]                             invokeRestart(restart)
[17:41:03.370]                             muffled <- TRUE
[17:41:03.370]                             break
[17:41:03.370]                           }
[17:41:03.370]                         }
[17:41:03.370]                       }
[17:41:03.370]                       invisible(muffled)
[17:41:03.370]                     }
[17:41:03.370]                     muffleCondition(cond, pattern = "^muffle")
[17:41:03.370]                   }
[17:41:03.370]                 }
[17:41:03.370]             }
[17:41:03.370]         }))
[17:41:03.370]     }, error = function(ex) {
[17:41:03.370]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:03.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:03.370]                 ...future.rng), started = ...future.startTime, 
[17:41:03.370]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:03.370]             version = "1.8"), class = "FutureResult")
[17:41:03.370]     }, finally = {
[17:41:03.370]         if (!identical(...future.workdir, getwd())) 
[17:41:03.370]             setwd(...future.workdir)
[17:41:03.370]         {
[17:41:03.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:03.370]                 ...future.oldOptions$nwarnings <- NULL
[17:41:03.370]             }
[17:41:03.370]             base::options(...future.oldOptions)
[17:41:03.370]             if (.Platform$OS.type == "windows") {
[17:41:03.370]                 old_names <- names(...future.oldEnvVars)
[17:41:03.370]                 envs <- base::Sys.getenv()
[17:41:03.370]                 names <- names(envs)
[17:41:03.370]                 common <- intersect(names, old_names)
[17:41:03.370]                 added <- setdiff(names, old_names)
[17:41:03.370]                 removed <- setdiff(old_names, names)
[17:41:03.370]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:03.370]                   envs[common]]
[17:41:03.370]                 NAMES <- toupper(changed)
[17:41:03.370]                 args <- list()
[17:41:03.370]                 for (kk in seq_along(NAMES)) {
[17:41:03.370]                   name <- changed[[kk]]
[17:41:03.370]                   NAME <- NAMES[[kk]]
[17:41:03.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.370]                     next
[17:41:03.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:03.370]                 }
[17:41:03.370]                 NAMES <- toupper(added)
[17:41:03.370]                 for (kk in seq_along(NAMES)) {
[17:41:03.370]                   name <- added[[kk]]
[17:41:03.370]                   NAME <- NAMES[[kk]]
[17:41:03.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.370]                     next
[17:41:03.370]                   args[[name]] <- ""
[17:41:03.370]                 }
[17:41:03.370]                 NAMES <- toupper(removed)
[17:41:03.370]                 for (kk in seq_along(NAMES)) {
[17:41:03.370]                   name <- removed[[kk]]
[17:41:03.370]                   NAME <- NAMES[[kk]]
[17:41:03.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.370]                     next
[17:41:03.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:03.370]                 }
[17:41:03.370]                 if (length(args) > 0) 
[17:41:03.370]                   base::do.call(base::Sys.setenv, args = args)
[17:41:03.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:03.370]             }
[17:41:03.370]             else {
[17:41:03.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:03.370]             }
[17:41:03.370]             {
[17:41:03.370]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:03.370]                   0L) {
[17:41:03.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:03.370]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:03.370]                   base::options(opts)
[17:41:03.370]                 }
[17:41:03.370]                 {
[17:41:03.370]                   {
[17:41:03.370]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:03.370]                     NULL
[17:41:03.370]                   }
[17:41:03.370]                   options(future.plan = NULL)
[17:41:03.370]                   if (is.na(NA_character_)) 
[17:41:03.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:03.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:03.370]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:03.370]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:03.370]                     envir = parent.frame()) 
[17:41:03.370]                   {
[17:41:03.370]                     if (is.function(workers)) 
[17:41:03.370]                       workers <- workers()
[17:41:03.370]                     workers <- structure(as.integer(workers), 
[17:41:03.370]                       class = class(workers))
[17:41:03.370]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:03.370]                       workers >= 1)
[17:41:03.370]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:03.370]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:03.370]                     }
[17:41:03.370]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:03.370]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:03.370]                       envir = envir)
[17:41:03.370]                     if (!future$lazy) 
[17:41:03.370]                       future <- run(future)
[17:41:03.370]                     invisible(future)
[17:41:03.370]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:03.370]                 }
[17:41:03.370]             }
[17:41:03.370]         }
[17:41:03.370]     })
[17:41:03.370]     if (TRUE) {
[17:41:03.370]         base::sink(type = "output", split = FALSE)
[17:41:03.370]         if (TRUE) {
[17:41:03.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:03.370]         }
[17:41:03.370]         else {
[17:41:03.370]             ...future.result["stdout"] <- base::list(NULL)
[17:41:03.370]         }
[17:41:03.370]         base::close(...future.stdout)
[17:41:03.370]         ...future.stdout <- NULL
[17:41:03.370]     }
[17:41:03.370]     ...future.result$conditions <- ...future.conditions
[17:41:03.370]     ...future.result$finished <- base::Sys.time()
[17:41:03.370]     ...future.result
[17:41:03.370] }
[17:41:03.373] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[17:41:03.373] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:41:03.415] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:41:03.415] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[17:41:03.416] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[17:41:03.416] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:41:03.416] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:41:03.416] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:41:03.459] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:41:03.459] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:41:03.503] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:41:03.503] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:41:03.504] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.504] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:41:03.504] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:41:03.504] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:03.505] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.505] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:41:03.505] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:03.505] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:03.505] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:03.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:03.506] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[17:41:03.507] MultisessionFuture started
[17:41:03.507] - Launch lazy future ... done
[17:41:03.507] run() for ‘MultisessionFuture’ ... done
[17:41:03.507] Created future:
[17:41:03.507] MultisessionFuture:
[17:41:03.507] Label: ‘future_vapply-1’
[17:41:03.507] Expression:
[17:41:03.507] {
[17:41:03.507]     do.call(function(...) {
[17:41:03.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.507]             on.exit(options(oopts), add = TRUE)
[17:41:03.507]         }
[17:41:03.507]         {
[17:41:03.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.507]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.507]             })
[17:41:03.507]         }
[17:41:03.507]     }, args = future.call.arguments)
[17:41:03.507] }
[17:41:03.507] Lazy evaluation: FALSE
[17:41:03.507] Asynchronous evaluation: TRUE
[17:41:03.507] Local evaluation: TRUE
[17:41:03.507] Environment: R_GlobalEnv
[17:41:03.507] Capture standard output: TRUE
[17:41:03.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:03.507] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:03.507] Packages: 1 packages (‘future.apply’)
[17:41:03.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:03.507] Resolved: FALSE
[17:41:03.507] Value: <not collected>
[17:41:03.507] Conditions captured: <none>
[17:41:03.507] Early signaling: FALSE
[17:41:03.507] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:03.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.519] Chunk #1 of 2 ... DONE
[17:41:03.519] Chunk #2 of 2 ...
[17:41:03.519]  - Finding globals in 'X' for chunk #2 ...
[17:41:03.519] getGlobalsAndPackages() ...
[17:41:03.519] Searching for globals...
[17:41:03.520] 
[17:41:03.520] Searching for globals ... DONE
[17:41:03.520] - globals: [0] <none>
[17:41:03.520] getGlobalsAndPackages() ... DONE
[17:41:03.520]    + additional globals found: [n=0] 
[17:41:03.520]    + additional namespaces needed: [n=0] 
[17:41:03.520]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:03.520]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:03.520]  - seeds: <none>
[17:41:03.520] getGlobalsAndPackages() ...
[17:41:03.521] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:03.521] Resolving globals: FALSE
[17:41:03.521] Tweak future expression to call with '...' arguments ...
[17:41:03.521] {
[17:41:03.521]     do.call(function(...) {
[17:41:03.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.521]             on.exit(options(oopts), add = TRUE)
[17:41:03.521]         }
[17:41:03.521]         {
[17:41:03.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.521]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.521]             })
[17:41:03.521]         }
[17:41:03.521]     }, args = future.call.arguments)
[17:41:03.521] }
[17:41:03.521] Tweak future expression to call with '...' arguments ... DONE
[17:41:03.522] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:03.522] - packages: [1] ‘future.apply’
[17:41:03.522] getGlobalsAndPackages() ... DONE
[17:41:03.522] run() for ‘Future’ ...
[17:41:03.522] - state: ‘created’
[17:41:03.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:03.537] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:03.537]   - Field: ‘node’
[17:41:03.537]   - Field: ‘label’
[17:41:03.538]   - Field: ‘local’
[17:41:03.538]   - Field: ‘owner’
[17:41:03.538]   - Field: ‘envir’
[17:41:03.538]   - Field: ‘workers’
[17:41:03.538]   - Field: ‘packages’
[17:41:03.538]   - Field: ‘gc’
[17:41:03.538]   - Field: ‘conditions’
[17:41:03.538]   - Field: ‘persistent’
[17:41:03.538]   - Field: ‘expr’
[17:41:03.538]   - Field: ‘uuid’
[17:41:03.538]   - Field: ‘seed’
[17:41:03.539]   - Field: ‘version’
[17:41:03.539]   - Field: ‘result’
[17:41:03.539]   - Field: ‘asynchronous’
[17:41:03.539]   - Field: ‘calls’
[17:41:03.539]   - Field: ‘globals’
[17:41:03.539]   - Field: ‘stdout’
[17:41:03.539]   - Field: ‘earlySignal’
[17:41:03.539]   - Field: ‘lazy’
[17:41:03.539]   - Field: ‘state’
[17:41:03.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:03.540] - Launch lazy future ...
[17:41:03.540] Packages needed by the future expression (n = 1): ‘future.apply’
[17:41:03.540] Packages needed by future strategies (n = 0): <none>
[17:41:03.541] {
[17:41:03.541]     {
[17:41:03.541]         {
[17:41:03.541]             ...future.startTime <- base::Sys.time()
[17:41:03.541]             {
[17:41:03.541]                 {
[17:41:03.541]                   {
[17:41:03.541]                     {
[17:41:03.541]                       {
[17:41:03.541]                         base::local({
[17:41:03.541]                           has_future <- base::requireNamespace("future", 
[17:41:03.541]                             quietly = TRUE)
[17:41:03.541]                           if (has_future) {
[17:41:03.541]                             ns <- base::getNamespace("future")
[17:41:03.541]                             version <- ns[[".package"]][["version"]]
[17:41:03.541]                             if (is.null(version)) 
[17:41:03.541]                               version <- utils::packageVersion("future")
[17:41:03.541]                           }
[17:41:03.541]                           else {
[17:41:03.541]                             version <- NULL
[17:41:03.541]                           }
[17:41:03.541]                           if (!has_future || version < "1.8.0") {
[17:41:03.541]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:03.541]                               "", base::R.version$version.string), 
[17:41:03.541]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:03.541]                                 base::R.version$platform, 8 * 
[17:41:03.541]                                   base::.Machine$sizeof.pointer), 
[17:41:03.541]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:03.541]                                 "release", "version")], collapse = " "), 
[17:41:03.541]                               hostname = base::Sys.info()[["nodename"]])
[17:41:03.541]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:03.541]                               info)
[17:41:03.541]                             info <- base::paste(info, collapse = "; ")
[17:41:03.541]                             if (!has_future) {
[17:41:03.541]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:03.541]                                 info)
[17:41:03.541]                             }
[17:41:03.541]                             else {
[17:41:03.541]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:03.541]                                 info, version)
[17:41:03.541]                             }
[17:41:03.541]                             base::stop(msg)
[17:41:03.541]                           }
[17:41:03.541]                         })
[17:41:03.541]                       }
[17:41:03.541]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:03.541]                       base::options(mc.cores = 1L)
[17:41:03.541]                     }
[17:41:03.541]                     base::local({
[17:41:03.541]                       for (pkg in "future.apply") {
[17:41:03.541]                         base::loadNamespace(pkg)
[17:41:03.541]                         base::library(pkg, character.only = TRUE)
[17:41:03.541]                       }
[17:41:03.541]                     })
[17:41:03.541]                   }
[17:41:03.541]                   options(future.plan = NULL)
[17:41:03.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:03.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:03.541]                 }
[17:41:03.541]                 ...future.workdir <- getwd()
[17:41:03.541]             }
[17:41:03.541]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:03.541]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:03.541]         }
[17:41:03.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:03.541]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:03.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:03.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:03.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:03.541]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:03.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:03.541]             base::names(...future.oldOptions))
[17:41:03.541]     }
[17:41:03.541]     if (FALSE) {
[17:41:03.541]     }
[17:41:03.541]     else {
[17:41:03.541]         if (TRUE) {
[17:41:03.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:03.541]                 open = "w")
[17:41:03.541]         }
[17:41:03.541]         else {
[17:41:03.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:03.541]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:03.541]         }
[17:41:03.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:03.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:03.541]             base::sink(type = "output", split = FALSE)
[17:41:03.541]             base::close(...future.stdout)
[17:41:03.541]         }, add = TRUE)
[17:41:03.541]     }
[17:41:03.541]     ...future.frame <- base::sys.nframe()
[17:41:03.541]     ...future.conditions <- base::list()
[17:41:03.541]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:03.541]     if (FALSE) {
[17:41:03.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:03.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:03.541]     }
[17:41:03.541]     ...future.result <- base::tryCatch({
[17:41:03.541]         base::withCallingHandlers({
[17:41:03.541]             ...future.value <- base::withVisible(base::local({
[17:41:03.541]                 ...future.makeSendCondition <- local({
[17:41:03.541]                   sendCondition <- NULL
[17:41:03.541]                   function(frame = 1L) {
[17:41:03.541]                     if (is.function(sendCondition)) 
[17:41:03.541]                       return(sendCondition)
[17:41:03.541]                     ns <- getNamespace("parallel")
[17:41:03.541]                     if (exists("sendData", mode = "function", 
[17:41:03.541]                       envir = ns)) {
[17:41:03.541]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:03.541]                         envir = ns)
[17:41:03.541]                       envir <- sys.frame(frame)
[17:41:03.541]                       master <- NULL
[17:41:03.541]                       while (!identical(envir, .GlobalEnv) && 
[17:41:03.541]                         !identical(envir, emptyenv())) {
[17:41:03.541]                         if (exists("master", mode = "list", envir = envir, 
[17:41:03.541]                           inherits = FALSE)) {
[17:41:03.541]                           master <- get("master", mode = "list", 
[17:41:03.541]                             envir = envir, inherits = FALSE)
[17:41:03.541]                           if (inherits(master, c("SOCKnode", 
[17:41:03.541]                             "SOCK0node"))) {
[17:41:03.541]                             sendCondition <<- function(cond) {
[17:41:03.541]                               data <- list(type = "VALUE", value = cond, 
[17:41:03.541]                                 success = TRUE)
[17:41:03.541]                               parallel_sendData(master, data)
[17:41:03.541]                             }
[17:41:03.541]                             return(sendCondition)
[17:41:03.541]                           }
[17:41:03.541]                         }
[17:41:03.541]                         frame <- frame + 1L
[17:41:03.541]                         envir <- sys.frame(frame)
[17:41:03.541]                       }
[17:41:03.541]                     }
[17:41:03.541]                     sendCondition <<- function(cond) NULL
[17:41:03.541]                   }
[17:41:03.541]                 })
[17:41:03.541]                 withCallingHandlers({
[17:41:03.541]                   {
[17:41:03.541]                     do.call(function(...) {
[17:41:03.541]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.541]                       if (!identical(...future.globals.maxSize.org, 
[17:41:03.541]                         ...future.globals.maxSize)) {
[17:41:03.541]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.541]                         on.exit(options(oopts), add = TRUE)
[17:41:03.541]                       }
[17:41:03.541]                       {
[17:41:03.541]                         lapply(seq_along(...future.elements_ii), 
[17:41:03.541]                           FUN = function(jj) {
[17:41:03.541]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.541]                             ...future.FUN(...future.X_jj, ...)
[17:41:03.541]                           })
[17:41:03.541]                       }
[17:41:03.541]                     }, args = future.call.arguments)
[17:41:03.541]                   }
[17:41:03.541]                 }, immediateCondition = function(cond) {
[17:41:03.541]                   sendCondition <- ...future.makeSendCondition()
[17:41:03.541]                   sendCondition(cond)
[17:41:03.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.541]                   {
[17:41:03.541]                     inherits <- base::inherits
[17:41:03.541]                     invokeRestart <- base::invokeRestart
[17:41:03.541]                     is.null <- base::is.null
[17:41:03.541]                     muffled <- FALSE
[17:41:03.541]                     if (inherits(cond, "message")) {
[17:41:03.541]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:03.541]                       if (muffled) 
[17:41:03.541]                         invokeRestart("muffleMessage")
[17:41:03.541]                     }
[17:41:03.541]                     else if (inherits(cond, "warning")) {
[17:41:03.541]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:03.541]                       if (muffled) 
[17:41:03.541]                         invokeRestart("muffleWarning")
[17:41:03.541]                     }
[17:41:03.541]                     else if (inherits(cond, "condition")) {
[17:41:03.541]                       if (!is.null(pattern)) {
[17:41:03.541]                         computeRestarts <- base::computeRestarts
[17:41:03.541]                         grepl <- base::grepl
[17:41:03.541]                         restarts <- computeRestarts(cond)
[17:41:03.541]                         for (restart in restarts) {
[17:41:03.541]                           name <- restart$name
[17:41:03.541]                           if (is.null(name)) 
[17:41:03.541]                             next
[17:41:03.541]                           if (!grepl(pattern, name)) 
[17:41:03.541]                             next
[17:41:03.541]                           invokeRestart(restart)
[17:41:03.541]                           muffled <- TRUE
[17:41:03.541]                           break
[17:41:03.541]                         }
[17:41:03.541]                       }
[17:41:03.541]                     }
[17:41:03.541]                     invisible(muffled)
[17:41:03.541]                   }
[17:41:03.541]                   muffleCondition(cond)
[17:41:03.541]                 })
[17:41:03.541]             }))
[17:41:03.541]             future::FutureResult(value = ...future.value$value, 
[17:41:03.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:03.541]                   ...future.rng), globalenv = if (FALSE) 
[17:41:03.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:03.541]                     ...future.globalenv.names))
[17:41:03.541]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:03.541]         }, condition = base::local({
[17:41:03.541]             c <- base::c
[17:41:03.541]             inherits <- base::inherits
[17:41:03.541]             invokeRestart <- base::invokeRestart
[17:41:03.541]             length <- base::length
[17:41:03.541]             list <- base::list
[17:41:03.541]             seq.int <- base::seq.int
[17:41:03.541]             signalCondition <- base::signalCondition
[17:41:03.541]             sys.calls <- base::sys.calls
[17:41:03.541]             `[[` <- base::`[[`
[17:41:03.541]             `+` <- base::`+`
[17:41:03.541]             `<<-` <- base::`<<-`
[17:41:03.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:03.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:03.541]                   3L)]
[17:41:03.541]             }
[17:41:03.541]             function(cond) {
[17:41:03.541]                 is_error <- inherits(cond, "error")
[17:41:03.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:03.541]                   NULL)
[17:41:03.541]                 if (is_error) {
[17:41:03.541]                   sessionInformation <- function() {
[17:41:03.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:03.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:03.541]                       search = base::search(), system = base::Sys.info())
[17:41:03.541]                   }
[17:41:03.541]                   ...future.conditions[[length(...future.conditions) + 
[17:41:03.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:03.541]                     cond$call), session = sessionInformation(), 
[17:41:03.541]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:03.541]                   signalCondition(cond)
[17:41:03.541]                 }
[17:41:03.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:03.541]                 "immediateCondition"))) {
[17:41:03.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:03.541]                   ...future.conditions[[length(...future.conditions) + 
[17:41:03.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:03.541]                   if (TRUE && !signal) {
[17:41:03.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.541]                     {
[17:41:03.541]                       inherits <- base::inherits
[17:41:03.541]                       invokeRestart <- base::invokeRestart
[17:41:03.541]                       is.null <- base::is.null
[17:41:03.541]                       muffled <- FALSE
[17:41:03.541]                       if (inherits(cond, "message")) {
[17:41:03.541]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:03.541]                         if (muffled) 
[17:41:03.541]                           invokeRestart("muffleMessage")
[17:41:03.541]                       }
[17:41:03.541]                       else if (inherits(cond, "warning")) {
[17:41:03.541]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:03.541]                         if (muffled) 
[17:41:03.541]                           invokeRestart("muffleWarning")
[17:41:03.541]                       }
[17:41:03.541]                       else if (inherits(cond, "condition")) {
[17:41:03.541]                         if (!is.null(pattern)) {
[17:41:03.541]                           computeRestarts <- base::computeRestarts
[17:41:03.541]                           grepl <- base::grepl
[17:41:03.541]                           restarts <- computeRestarts(cond)
[17:41:03.541]                           for (restart in restarts) {
[17:41:03.541]                             name <- restart$name
[17:41:03.541]                             if (is.null(name)) 
[17:41:03.541]                               next
[17:41:03.541]                             if (!grepl(pattern, name)) 
[17:41:03.541]                               next
[17:41:03.541]                             invokeRestart(restart)
[17:41:03.541]                             muffled <- TRUE
[17:41:03.541]                             break
[17:41:03.541]                           }
[17:41:03.541]                         }
[17:41:03.541]                       }
[17:41:03.541]                       invisible(muffled)
[17:41:03.541]                     }
[17:41:03.541]                     muffleCondition(cond, pattern = "^muffle")
[17:41:03.541]                   }
[17:41:03.541]                 }
[17:41:03.541]                 else {
[17:41:03.541]                   if (TRUE) {
[17:41:03.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:03.541]                     {
[17:41:03.541]                       inherits <- base::inherits
[17:41:03.541]                       invokeRestart <- base::invokeRestart
[17:41:03.541]                       is.null <- base::is.null
[17:41:03.541]                       muffled <- FALSE
[17:41:03.541]                       if (inherits(cond, "message")) {
[17:41:03.541]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:03.541]                         if (muffled) 
[17:41:03.541]                           invokeRestart("muffleMessage")
[17:41:03.541]                       }
[17:41:03.541]                       else if (inherits(cond, "warning")) {
[17:41:03.541]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:03.541]                         if (muffled) 
[17:41:03.541]                           invokeRestart("muffleWarning")
[17:41:03.541]                       }
[17:41:03.541]                       else if (inherits(cond, "condition")) {
[17:41:03.541]                         if (!is.null(pattern)) {
[17:41:03.541]                           computeRestarts <- base::computeRestarts
[17:41:03.541]                           grepl <- base::grepl
[17:41:03.541]                           restarts <- computeRestarts(cond)
[17:41:03.541]                           for (restart in restarts) {
[17:41:03.541]                             name <- restart$name
[17:41:03.541]                             if (is.null(name)) 
[17:41:03.541]                               next
[17:41:03.541]                             if (!grepl(pattern, name)) 
[17:41:03.541]                               next
[17:41:03.541]                             invokeRestart(restart)
[17:41:03.541]                             muffled <- TRUE
[17:41:03.541]                             break
[17:41:03.541]                           }
[17:41:03.541]                         }
[17:41:03.541]                       }
[17:41:03.541]                       invisible(muffled)
[17:41:03.541]                     }
[17:41:03.541]                     muffleCondition(cond, pattern = "^muffle")
[17:41:03.541]                   }
[17:41:03.541]                 }
[17:41:03.541]             }
[17:41:03.541]         }))
[17:41:03.541]     }, error = function(ex) {
[17:41:03.541]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:03.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:03.541]                 ...future.rng), started = ...future.startTime, 
[17:41:03.541]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:03.541]             version = "1.8"), class = "FutureResult")
[17:41:03.541]     }, finally = {
[17:41:03.541]         if (!identical(...future.workdir, getwd())) 
[17:41:03.541]             setwd(...future.workdir)
[17:41:03.541]         {
[17:41:03.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:03.541]                 ...future.oldOptions$nwarnings <- NULL
[17:41:03.541]             }
[17:41:03.541]             base::options(...future.oldOptions)
[17:41:03.541]             if (.Platform$OS.type == "windows") {
[17:41:03.541]                 old_names <- names(...future.oldEnvVars)
[17:41:03.541]                 envs <- base::Sys.getenv()
[17:41:03.541]                 names <- names(envs)
[17:41:03.541]                 common <- intersect(names, old_names)
[17:41:03.541]                 added <- setdiff(names, old_names)
[17:41:03.541]                 removed <- setdiff(old_names, names)
[17:41:03.541]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:03.541]                   envs[common]]
[17:41:03.541]                 NAMES <- toupper(changed)
[17:41:03.541]                 args <- list()
[17:41:03.541]                 for (kk in seq_along(NAMES)) {
[17:41:03.541]                   name <- changed[[kk]]
[17:41:03.541]                   NAME <- NAMES[[kk]]
[17:41:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.541]                     next
[17:41:03.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:03.541]                 }
[17:41:03.541]                 NAMES <- toupper(added)
[17:41:03.541]                 for (kk in seq_along(NAMES)) {
[17:41:03.541]                   name <- added[[kk]]
[17:41:03.541]                   NAME <- NAMES[[kk]]
[17:41:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.541]                     next
[17:41:03.541]                   args[[name]] <- ""
[17:41:03.541]                 }
[17:41:03.541]                 NAMES <- toupper(removed)
[17:41:03.541]                 for (kk in seq_along(NAMES)) {
[17:41:03.541]                   name <- removed[[kk]]
[17:41:03.541]                   NAME <- NAMES[[kk]]
[17:41:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:03.541]                     next
[17:41:03.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:03.541]                 }
[17:41:03.541]                 if (length(args) > 0) 
[17:41:03.541]                   base::do.call(base::Sys.setenv, args = args)
[17:41:03.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:03.541]             }
[17:41:03.541]             else {
[17:41:03.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:03.541]             }
[17:41:03.541]             {
[17:41:03.541]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:03.541]                   0L) {
[17:41:03.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:03.541]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:03.541]                   base::options(opts)
[17:41:03.541]                 }
[17:41:03.541]                 {
[17:41:03.541]                   {
[17:41:03.541]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:03.541]                     NULL
[17:41:03.541]                   }
[17:41:03.541]                   options(future.plan = NULL)
[17:41:03.541]                   if (is.na(NA_character_)) 
[17:41:03.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:03.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:03.541]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:03.541]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:03.541]                     envir = parent.frame()) 
[17:41:03.541]                   {
[17:41:03.541]                     if (is.function(workers)) 
[17:41:03.541]                       workers <- workers()
[17:41:03.541]                     workers <- structure(as.integer(workers), 
[17:41:03.541]                       class = class(workers))
[17:41:03.541]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:03.541]                       workers >= 1)
[17:41:03.541]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:03.541]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:03.541]                     }
[17:41:03.541]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:03.541]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:03.541]                       envir = envir)
[17:41:03.541]                     if (!future$lazy) 
[17:41:03.541]                       future <- run(future)
[17:41:03.541]                     invisible(future)
[17:41:03.541]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:03.541]                 }
[17:41:03.541]             }
[17:41:03.541]         }
[17:41:03.541]     })
[17:41:03.541]     if (TRUE) {
[17:41:03.541]         base::sink(type = "output", split = FALSE)
[17:41:03.541]         if (TRUE) {
[17:41:03.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:03.541]         }
[17:41:03.541]         else {
[17:41:03.541]             ...future.result["stdout"] <- base::list(NULL)
[17:41:03.541]         }
[17:41:03.541]         base::close(...future.stdout)
[17:41:03.541]         ...future.stdout <- NULL
[17:41:03.541]     }
[17:41:03.541]     ...future.result$conditions <- ...future.conditions
[17:41:03.541]     ...future.result$finished <- base::Sys.time()
[17:41:03.541]     ...future.result
[17:41:03.541] }
[17:41:03.543] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[17:41:03.544] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:41:03.587] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:41:03.587] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[17:41:03.588] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[17:41:03.588] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:41:03.588] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:41:03.588] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:41:03.631] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:41:03.631] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:41:03.675] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:41:03.675] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:41:03.676] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.676] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:41:03.676] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:41:03.676] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:03.677] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.677] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:03.677] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:03.677] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:03.678] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.678] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:03.678] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:03.678] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[17:41:03.679] MultisessionFuture started
[17:41:03.679] - Launch lazy future ... done
[17:41:03.679] run() for ‘MultisessionFuture’ ... done
[17:41:03.679] Created future:
[17:41:03.679] MultisessionFuture:
[17:41:03.679] Label: ‘future_vapply-2’
[17:41:03.679] Expression:
[17:41:03.679] {
[17:41:03.679]     do.call(function(...) {
[17:41:03.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:03.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:03.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:03.679]             on.exit(options(oopts), add = TRUE)
[17:41:03.679]         }
[17:41:03.679]         {
[17:41:03.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:03.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:03.679]                 ...future.FUN(...future.X_jj, ...)
[17:41:03.679]             })
[17:41:03.679]         }
[17:41:03.679]     }, args = future.call.arguments)
[17:41:03.679] }
[17:41:03.679] Lazy evaluation: FALSE
[17:41:03.679] Asynchronous evaluation: TRUE
[17:41:03.679] Local evaluation: TRUE
[17:41:03.679] Environment: R_GlobalEnv
[17:41:03.679] Capture standard output: TRUE
[17:41:03.679] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:03.679] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:41:03.679] Packages: 1 packages (‘future.apply’)
[17:41:03.679] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:03.679] Resolved: FALSE
[17:41:03.679] Value: <not collected>
[17:41:03.679] Conditions captured: <none>
[17:41:03.679] Early signaling: FALSE
[17:41:03.679] Owner process: 0723f729-f707-4e2d-a6a5-05fc59f4c329
[17:41:03.679] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:03.691] Chunk #2 of 2 ... DONE
[17:41:03.691] Launching 2 futures (chunks) ... DONE
[17:41:03.691] Resolving 2 futures (chunks) ...
[17:41:03.692] resolve() on list ...
[17:41:03.692]  recursive: 0
[17:41:03.692]  length: 2
[17:41:03.692] 
[17:41:03.692] receiveMessageFromWorker() for ClusterFuture ...
[17:41:03.692] - Validating connection of MultisessionFuture
[17:41:03.693] - received message: FutureResult
[17:41:03.693] - Received FutureResult
[17:41:03.693] - Erased future from FutureRegistry
[17:41:03.693] result() for ClusterFuture ...
[17:41:03.693] - result already collected: FutureResult
[17:41:03.693] result() for ClusterFuture ... done
[17:41:03.693] signalConditions() ...
[17:41:03.693]  - include = ‘immediateCondition’
[17:41:03.694]  - exclude = 
[17:41:03.694]  - resignal = FALSE
[17:41:03.694]  - Number of conditions: 1
[17:41:03.694] signalConditions() ... done
[17:41:03.694] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:03.694] Future #1
[17:41:03.694] result() for ClusterFuture ...
[17:41:03.694] - result already collected: FutureResult
[17:41:03.694] result() for ClusterFuture ... done
[17:41:03.694] result() for ClusterFuture ...
[17:41:03.694] - result already collected: FutureResult
[17:41:03.695] result() for ClusterFuture ... done
[17:41:03.695] signalConditions() ...
[17:41:03.695]  - include = ‘immediateCondition’
[17:41:03.695]  - exclude = 
[17:41:03.695]  - resignal = FALSE
[17:41:03.695]  - Number of conditions: 1
[17:41:03.695] signalConditions() ... done
[17:41:03.695] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:03.695] - nx: 2
[17:41:03.695] - relay: TRUE
[17:41:03.695] - stdout: TRUE
[17:41:03.696] - signal: TRUE
[17:41:03.696] - resignal: FALSE
[17:41:03.696] - force: TRUE
[17:41:03.696] - relayed: [n=2] FALSE, FALSE
[17:41:03.696] - queued futures: [n=2] FALSE, FALSE
[17:41:03.696]  - until=1
[17:41:03.696]  - relaying element #1
[17:41:03.696] result() for ClusterFuture ...
[17:41:03.696] - result already collected: FutureResult
[17:41:03.696] result() for ClusterFuture ... done
[17:41:03.696] result() for ClusterFuture ...
[17:41:03.696] - result already collected: FutureResult
[17:41:03.697] result() for ClusterFuture ... done
[17:41:03.697] signalConditions() ...
[17:41:03.697]  - include = ‘immediateCondition’
[17:41:03.697]  - exclude = 
[17:41:03.697]  - resignal = FALSE
[17:41:03.697]  - Number of conditions: 1
[17:41:03.697] signalConditions() ... done
[17:41:03.697] result() for ClusterFuture ...
[17:41:03.697] - result already collected: FutureResult
[17:41:03.697] result() for ClusterFuture ... done
[17:41:03.697] signalConditions() ...
[17:41:03.697]  - include = ‘immediateCondition’
[17:41:03.698]  - exclude = 
[17:41:03.698]  - resignal = FALSE
[17:41:03.698]  - Number of conditions: 1
[17:41:03.698] signalConditions() ... done
[17:41:03.698] result() for ClusterFuture ...
[17:41:03.698] - result already collected: FutureResult
[17:41:03.698] result() for ClusterFuture ... done
[17:41:03.698] signalConditions() ...
[17:41:03.698]  - include = ‘condition’
[17:41:03.698]  - exclude = ‘immediateCondition’
[17:41:03.698]  - resignal = TRUE
[17:41:03.699]  - Number of conditions: 1
[17:41:03.699]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:41:03.699] signalConditions() ... done
[17:41:03.699] - relayed: [n=2] FALSE, FALSE
[17:41:03.699] - queued futures: [n=2] TRUE, FALSE
[17:41:03.699] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:03.699] plan(): Setting new future strategy stack:
[17:41:03.699] List of future strategies:
[17:41:03.699] 1. sequential:
[17:41:03.699]    - args: function (..., envir = parent.frame())
[17:41:03.699]    - tweaked: FALSE
[17:41:03.699]    - call: plan(sequential)
[17:41:03.700] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[17:41:03.701] plan(): Setting new future strategy stack:
[17:41:03.701] List of future strategies:
[17:41:03.701] 1. FutureStrategy:
[17:41:03.701]    - args: function (..., envir = parent.frame())
[17:41:03.701]    - tweaked: FALSE
[17:41:03.701]    - call: future::plan(oplan)
[17:41:03.702] plan(): nbrOfWorkers() = 1
> 
