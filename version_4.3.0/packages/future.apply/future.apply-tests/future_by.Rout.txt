
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:09:31.824] plan(): Setting new future strategy stack:
[16:09:31.825] List of future strategies:
[16:09:31.825] 1. sequential:
[16:09:31.825]    - args: function (..., envir = parent.frame())
[16:09:31.825]    - tweaked: FALSE
[16:09:31.825]    - call: future::plan("sequential")
[16:09:31.834] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[16:09:31.892] plan(): Setting new future strategy stack:
[16:09:31.892] List of future strategies:
[16:09:31.892] 1. sequential:
[16:09:31.892]    - args: function (..., envir = parent.frame())
[16:09:31.892]    - tweaked: FALSE
[16:09:31.892]    - call: plan(strategy)
[16:09:31.903] plan(): nbrOfWorkers() = 1
[16:09:31.903] future_by_internal() ...
[16:09:31.904] future_lapply() ...
[16:09:31.908] Number of chunks: 1
[16:09:31.908] getGlobalsAndPackagesXApply() ...
[16:09:31.908]  - future.globals: TRUE
[16:09:31.909] getGlobalsAndPackages() ...
[16:09:31.909] Searching for globals...
[16:09:31.911] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:31.911] Searching for globals ... DONE
[16:09:31.911] Resolving globals: FALSE
[16:09:31.912] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:31.913] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:31.913] - globals: [1] ‘FUN’
[16:09:31.913] 
[16:09:31.913] getGlobalsAndPackages() ... DONE
[16:09:31.913]  - globals found/used: [n=1] ‘FUN’
[16:09:31.913]  - needed namespaces: [n=0] 
[16:09:31.913] Finding globals ... DONE
[16:09:31.914]  - use_args: TRUE
[16:09:31.914]  - Getting '...' globals ...
[16:09:31.914] resolve() on list ...
[16:09:31.915]  recursive: 0
[16:09:31.915]  length: 1
[16:09:31.915]  elements: ‘...’
[16:09:31.915]  length: 0 (resolved future 1)
[16:09:31.915] resolve() on list ... DONE
[16:09:31.915]    - '...' content: [n=0] 
[16:09:31.915] List of 1
[16:09:31.915]  $ ...: list()
[16:09:31.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.915]  - attr(*, "where")=List of 1
[16:09:31.915]   ..$ ...:<environment: 0x5567e8e1f390> 
[16:09:31.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.915]  - attr(*, "resolved")= logi TRUE
[16:09:31.915]  - attr(*, "total_size")= num NA
[16:09:31.921]  - Getting '...' globals ... DONE
[16:09:31.921] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:31.922] List of 2
[16:09:31.922]  $ ...future.FUN:function (object, ...)  
[16:09:31.922]  $ ...          : list()
[16:09:31.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.922]  - attr(*, "where")=List of 2
[16:09:31.922]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:31.922]   ..$ ...          :<environment: 0x5567e8e1f390> 
[16:09:31.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.922]  - attr(*, "resolved")= logi FALSE
[16:09:31.922]  - attr(*, "total_size")= num 1240
[16:09:31.924] Packages to be attached in all futures: [n=0] 
[16:09:31.924] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.925] Number of futures (= number of chunks): 1
[16:09:31.925] Launching 1 futures (chunks) ...
[16:09:31.925] Chunk #1 of 1 ...
[16:09:31.925]  - Finding globals in 'X' for chunk #1 ...
[16:09:31.925] getGlobalsAndPackages() ...
[16:09:31.925] Searching for globals...
[16:09:31.926] 
[16:09:31.926] Searching for globals ... DONE
[16:09:31.926] - globals: [0] <none>
[16:09:31.926] getGlobalsAndPackages() ... DONE
[16:09:31.926]    + additional globals found: [n=0] 
[16:09:31.926]    + additional namespaces needed: [n=0] 
[16:09:31.926]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:31.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:31.927]  - seeds: <none>
[16:09:31.927] getGlobalsAndPackages() ...
[16:09:31.927] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.927] Resolving globals: FALSE
[16:09:31.927] Tweak future expression to call with '...' arguments ...
[16:09:31.927] {
[16:09:31.927]     do.call(function(...) {
[16:09:31.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.927]             on.exit(options(oopts), add = TRUE)
[16:09:31.927]         }
[16:09:31.927]         {
[16:09:31.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.927]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.927]             })
[16:09:31.927]         }
[16:09:31.927]     }, args = future.call.arguments)
[16:09:31.927] }
[16:09:31.928] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.928] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.928] 
[16:09:31.928] getGlobalsAndPackages() ... DONE
[16:09:31.929] run() for ‘Future’ ...
[16:09:31.929] - state: ‘created’
[16:09:31.929] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:31.930] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:31.930] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:31.930]   - Field: ‘label’
[16:09:31.930]   - Field: ‘local’
[16:09:31.930]   - Field: ‘owner’
[16:09:31.930]   - Field: ‘envir’
[16:09:31.930]   - Field: ‘packages’
[16:09:31.930]   - Field: ‘gc’
[16:09:31.930]   - Field: ‘conditions’
[16:09:31.930]   - Field: ‘expr’
[16:09:31.931]   - Field: ‘uuid’
[16:09:31.931]   - Field: ‘seed’
[16:09:31.931]   - Field: ‘version’
[16:09:31.931]   - Field: ‘result’
[16:09:31.931]   - Field: ‘asynchronous’
[16:09:31.931]   - Field: ‘calls’
[16:09:31.931]   - Field: ‘globals’
[16:09:31.931]   - Field: ‘stdout’
[16:09:31.931]   - Field: ‘earlySignal’
[16:09:31.931]   - Field: ‘lazy’
[16:09:31.931]   - Field: ‘state’
[16:09:31.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:31.932] - Launch lazy future ...
[16:09:31.932] Packages needed by the future expression (n = 0): <none>
[16:09:31.933] Packages needed by future strategies (n = 0): <none>
[16:09:31.933] {
[16:09:31.933]     {
[16:09:31.933]         {
[16:09:31.933]             ...future.startTime <- base::Sys.time()
[16:09:31.933]             {
[16:09:31.933]                 {
[16:09:31.933]                   {
[16:09:31.933]                     base::local({
[16:09:31.933]                       has_future <- base::requireNamespace("future", 
[16:09:31.933]                         quietly = TRUE)
[16:09:31.933]                       if (has_future) {
[16:09:31.933]                         ns <- base::getNamespace("future")
[16:09:31.933]                         version <- ns[[".package"]][["version"]]
[16:09:31.933]                         if (is.null(version)) 
[16:09:31.933]                           version <- utils::packageVersion("future")
[16:09:31.933]                       }
[16:09:31.933]                       else {
[16:09:31.933]                         version <- NULL
[16:09:31.933]                       }
[16:09:31.933]                       if (!has_future || version < "1.8.0") {
[16:09:31.933]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.933]                           "", base::R.version$version.string), 
[16:09:31.933]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:31.933]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.933]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.933]                             "release", "version")], collapse = " "), 
[16:09:31.933]                           hostname = base::Sys.info()[["nodename"]])
[16:09:31.933]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.933]                           info)
[16:09:31.933]                         info <- base::paste(info, collapse = "; ")
[16:09:31.933]                         if (!has_future) {
[16:09:31.933]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.933]                             info)
[16:09:31.933]                         }
[16:09:31.933]                         else {
[16:09:31.933]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.933]                             info, version)
[16:09:31.933]                         }
[16:09:31.933]                         base::stop(msg)
[16:09:31.933]                       }
[16:09:31.933]                     })
[16:09:31.933]                   }
[16:09:31.933]                   options(future.plan = NULL)
[16:09:31.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.933]                 }
[16:09:31.933]                 ...future.workdir <- getwd()
[16:09:31.933]             }
[16:09:31.933]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.933]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.933]         }
[16:09:31.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.933]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:31.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.933]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.933]             base::names(...future.oldOptions))
[16:09:31.933]     }
[16:09:31.933]     if (FALSE) {
[16:09:31.933]     }
[16:09:31.933]     else {
[16:09:31.933]         if (TRUE) {
[16:09:31.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.933]                 open = "w")
[16:09:31.933]         }
[16:09:31.933]         else {
[16:09:31.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.933]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.933]         }
[16:09:31.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.933]             base::sink(type = "output", split = FALSE)
[16:09:31.933]             base::close(...future.stdout)
[16:09:31.933]         }, add = TRUE)
[16:09:31.933]     }
[16:09:31.933]     ...future.frame <- base::sys.nframe()
[16:09:31.933]     ...future.conditions <- base::list()
[16:09:31.933]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.933]     if (FALSE) {
[16:09:31.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.933]     }
[16:09:31.933]     ...future.result <- base::tryCatch({
[16:09:31.933]         base::withCallingHandlers({
[16:09:31.933]             ...future.value <- base::withVisible(base::local({
[16:09:31.933]                 do.call(function(...) {
[16:09:31.933]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.933]                   if (!identical(...future.globals.maxSize.org, 
[16:09:31.933]                     ...future.globals.maxSize)) {
[16:09:31.933]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.933]                     on.exit(options(oopts), add = TRUE)
[16:09:31.933]                   }
[16:09:31.933]                   {
[16:09:31.933]                     lapply(seq_along(...future.elements_ii), 
[16:09:31.933]                       FUN = function(jj) {
[16:09:31.933]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.933]                         ...future.FUN(...future.X_jj, ...)
[16:09:31.933]                       })
[16:09:31.933]                   }
[16:09:31.933]                 }, args = future.call.arguments)
[16:09:31.933]             }))
[16:09:31.933]             future::FutureResult(value = ...future.value$value, 
[16:09:31.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.933]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.933]                     ...future.globalenv.names))
[16:09:31.933]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.933]         }, condition = base::local({
[16:09:31.933]             c <- base::c
[16:09:31.933]             inherits <- base::inherits
[16:09:31.933]             invokeRestart <- base::invokeRestart
[16:09:31.933]             length <- base::length
[16:09:31.933]             list <- base::list
[16:09:31.933]             seq.int <- base::seq.int
[16:09:31.933]             signalCondition <- base::signalCondition
[16:09:31.933]             sys.calls <- base::sys.calls
[16:09:31.933]             `[[` <- base::`[[`
[16:09:31.933]             `+` <- base::`+`
[16:09:31.933]             `<<-` <- base::`<<-`
[16:09:31.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.933]                   3L)]
[16:09:31.933]             }
[16:09:31.933]             function(cond) {
[16:09:31.933]                 is_error <- inherits(cond, "error")
[16:09:31.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.933]                   NULL)
[16:09:31.933]                 if (is_error) {
[16:09:31.933]                   sessionInformation <- function() {
[16:09:31.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.933]                       search = base::search(), system = base::Sys.info())
[16:09:31.933]                   }
[16:09:31.933]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.933]                     cond$call), session = sessionInformation(), 
[16:09:31.933]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.933]                   signalCondition(cond)
[16:09:31.933]                 }
[16:09:31.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:31.933]                 "immediateCondition"))) {
[16:09:31.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.933]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.933]                   if (TRUE && !signal) {
[16:09:31.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.933]                     {
[16:09:31.933]                       inherits <- base::inherits
[16:09:31.933]                       invokeRestart <- base::invokeRestart
[16:09:31.933]                       is.null <- base::is.null
[16:09:31.933]                       muffled <- FALSE
[16:09:31.933]                       if (inherits(cond, "message")) {
[16:09:31.933]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.933]                         if (muffled) 
[16:09:31.933]                           invokeRestart("muffleMessage")
[16:09:31.933]                       }
[16:09:31.933]                       else if (inherits(cond, "warning")) {
[16:09:31.933]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.933]                         if (muffled) 
[16:09:31.933]                           invokeRestart("muffleWarning")
[16:09:31.933]                       }
[16:09:31.933]                       else if (inherits(cond, "condition")) {
[16:09:31.933]                         if (!is.null(pattern)) {
[16:09:31.933]                           computeRestarts <- base::computeRestarts
[16:09:31.933]                           grepl <- base::grepl
[16:09:31.933]                           restarts <- computeRestarts(cond)
[16:09:31.933]                           for (restart in restarts) {
[16:09:31.933]                             name <- restart$name
[16:09:31.933]                             if (is.null(name)) 
[16:09:31.933]                               next
[16:09:31.933]                             if (!grepl(pattern, name)) 
[16:09:31.933]                               next
[16:09:31.933]                             invokeRestart(restart)
[16:09:31.933]                             muffled <- TRUE
[16:09:31.933]                             break
[16:09:31.933]                           }
[16:09:31.933]                         }
[16:09:31.933]                       }
[16:09:31.933]                       invisible(muffled)
[16:09:31.933]                     }
[16:09:31.933]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.933]                   }
[16:09:31.933]                 }
[16:09:31.933]                 else {
[16:09:31.933]                   if (TRUE) {
[16:09:31.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.933]                     {
[16:09:31.933]                       inherits <- base::inherits
[16:09:31.933]                       invokeRestart <- base::invokeRestart
[16:09:31.933]                       is.null <- base::is.null
[16:09:31.933]                       muffled <- FALSE
[16:09:31.933]                       if (inherits(cond, "message")) {
[16:09:31.933]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.933]                         if (muffled) 
[16:09:31.933]                           invokeRestart("muffleMessage")
[16:09:31.933]                       }
[16:09:31.933]                       else if (inherits(cond, "warning")) {
[16:09:31.933]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.933]                         if (muffled) 
[16:09:31.933]                           invokeRestart("muffleWarning")
[16:09:31.933]                       }
[16:09:31.933]                       else if (inherits(cond, "condition")) {
[16:09:31.933]                         if (!is.null(pattern)) {
[16:09:31.933]                           computeRestarts <- base::computeRestarts
[16:09:31.933]                           grepl <- base::grepl
[16:09:31.933]                           restarts <- computeRestarts(cond)
[16:09:31.933]                           for (restart in restarts) {
[16:09:31.933]                             name <- restart$name
[16:09:31.933]                             if (is.null(name)) 
[16:09:31.933]                               next
[16:09:31.933]                             if (!grepl(pattern, name)) 
[16:09:31.933]                               next
[16:09:31.933]                             invokeRestart(restart)
[16:09:31.933]                             muffled <- TRUE
[16:09:31.933]                             break
[16:09:31.933]                           }
[16:09:31.933]                         }
[16:09:31.933]                       }
[16:09:31.933]                       invisible(muffled)
[16:09:31.933]                     }
[16:09:31.933]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.933]                   }
[16:09:31.933]                 }
[16:09:31.933]             }
[16:09:31.933]         }))
[16:09:31.933]     }, error = function(ex) {
[16:09:31.933]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.933]                 ...future.rng), started = ...future.startTime, 
[16:09:31.933]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.933]             version = "1.8"), class = "FutureResult")
[16:09:31.933]     }, finally = {
[16:09:31.933]         if (!identical(...future.workdir, getwd())) 
[16:09:31.933]             setwd(...future.workdir)
[16:09:31.933]         {
[16:09:31.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.933]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.933]             }
[16:09:31.933]             base::options(...future.oldOptions)
[16:09:31.933]             if (.Platform$OS.type == "windows") {
[16:09:31.933]                 old_names <- names(...future.oldEnvVars)
[16:09:31.933]                 envs <- base::Sys.getenv()
[16:09:31.933]                 names <- names(envs)
[16:09:31.933]                 common <- intersect(names, old_names)
[16:09:31.933]                 added <- setdiff(names, old_names)
[16:09:31.933]                 removed <- setdiff(old_names, names)
[16:09:31.933]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.933]                   envs[common]]
[16:09:31.933]                 NAMES <- toupper(changed)
[16:09:31.933]                 args <- list()
[16:09:31.933]                 for (kk in seq_along(NAMES)) {
[16:09:31.933]                   name <- changed[[kk]]
[16:09:31.933]                   NAME <- NAMES[[kk]]
[16:09:31.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.933]                     next
[16:09:31.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.933]                 }
[16:09:31.933]                 NAMES <- toupper(added)
[16:09:31.933]                 for (kk in seq_along(NAMES)) {
[16:09:31.933]                   name <- added[[kk]]
[16:09:31.933]                   NAME <- NAMES[[kk]]
[16:09:31.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.933]                     next
[16:09:31.933]                   args[[name]] <- ""
[16:09:31.933]                 }
[16:09:31.933]                 NAMES <- toupper(removed)
[16:09:31.933]                 for (kk in seq_along(NAMES)) {
[16:09:31.933]                   name <- removed[[kk]]
[16:09:31.933]                   NAME <- NAMES[[kk]]
[16:09:31.933]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.933]                     next
[16:09:31.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.933]                 }
[16:09:31.933]                 if (length(args) > 0) 
[16:09:31.933]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.933]             }
[16:09:31.933]             else {
[16:09:31.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.933]             }
[16:09:31.933]             {
[16:09:31.933]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.933]                   0L) {
[16:09:31.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.933]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.933]                   base::options(opts)
[16:09:31.933]                 }
[16:09:31.933]                 {
[16:09:31.933]                   {
[16:09:31.933]                     NULL
[16:09:31.933]                     RNGkind("Mersenne-Twister")
[16:09:31.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:31.933]                       inherits = FALSE)
[16:09:31.933]                   }
[16:09:31.933]                   options(future.plan = NULL)
[16:09:31.933]                   if (is.na(NA_character_)) 
[16:09:31.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.933]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:31.933]                   {
[16:09:31.933]                     future <- SequentialFuture(..., envir = envir)
[16:09:31.933]                     if (!future$lazy) 
[16:09:31.933]                       future <- run(future)
[16:09:31.933]                     invisible(future)
[16:09:31.933]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.933]                 }
[16:09:31.933]             }
[16:09:31.933]         }
[16:09:31.933]     })
[16:09:31.933]     if (TRUE) {
[16:09:31.933]         base::sink(type = "output", split = FALSE)
[16:09:31.933]         if (TRUE) {
[16:09:31.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.933]         }
[16:09:31.933]         else {
[16:09:31.933]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.933]         }
[16:09:31.933]         base::close(...future.stdout)
[16:09:31.933]         ...future.stdout <- NULL
[16:09:31.933]     }
[16:09:31.933]     ...future.result$conditions <- ...future.conditions
[16:09:31.933]     ...future.result$finished <- base::Sys.time()
[16:09:31.933]     ...future.result
[16:09:31.933] }
[16:09:31.935] assign_globals() ...
[16:09:31.935] List of 5
[16:09:31.935]  $ ...future.FUN            :function (object, ...)  
[16:09:31.935]  $ future.call.arguments    : list()
[16:09:31.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.935]  $ ...future.elements_ii    :List of 3
[16:09:31.935]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:31.935]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:31.935]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:31.935]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:31.935]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:31.935]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:31.935]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:31.935]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:31.935]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:31.935]  $ ...future.seeds_ii       : NULL
[16:09:31.935]  $ ...future.globals.maxSize: NULL
[16:09:31.935]  - attr(*, "resolved")= logi FALSE
[16:09:31.935]  - attr(*, "total_size")= num 1240
[16:09:31.935]  - attr(*, "where")=List of 5
[16:09:31.935]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:31.935]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:31.935]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:31.935]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:31.935]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:31.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.935]  - attr(*, "already-done")= logi TRUE
[16:09:31.942] - copied ‘...future.FUN’ to environment
[16:09:31.943] - copied ‘future.call.arguments’ to environment
[16:09:31.943] - copied ‘...future.elements_ii’ to environment
[16:09:31.943] - copied ‘...future.seeds_ii’ to environment
[16:09:31.943] - copied ‘...future.globals.maxSize’ to environment
[16:09:31.943] assign_globals() ... done
[16:09:31.943] plan(): Setting new future strategy stack:
[16:09:31.943] List of future strategies:
[16:09:31.943] 1. sequential:
[16:09:31.943]    - args: function (..., envir = parent.frame())
[16:09:31.943]    - tweaked: FALSE
[16:09:31.943]    - call: NULL
[16:09:31.944] plan(): nbrOfWorkers() = 1
[16:09:31.946] plan(): Setting new future strategy stack:
[16:09:31.947] List of future strategies:
[16:09:31.947] 1. sequential:
[16:09:31.947]    - args: function (..., envir = parent.frame())
[16:09:31.947]    - tweaked: FALSE
[16:09:31.947]    - call: plan(strategy)
[16:09:31.948] plan(): nbrOfWorkers() = 1
[16:09:31.948] SequentialFuture started (and completed)
[16:09:31.948] - Launch lazy future ... done
[16:09:31.948] run() for ‘SequentialFuture’ ... done
[16:09:31.948] Created future:
[16:09:31.949] SequentialFuture:
[16:09:31.949] Label: ‘future_by-1’
[16:09:31.949] Expression:
[16:09:31.949] {
[16:09:31.949]     do.call(function(...) {
[16:09:31.949]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.949]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.949]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.949]             on.exit(options(oopts), add = TRUE)
[16:09:31.949]         }
[16:09:31.949]         {
[16:09:31.949]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.949]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.949]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.949]             })
[16:09:31.949]         }
[16:09:31.949]     }, args = future.call.arguments)
[16:09:31.949] }
[16:09:31.949] Lazy evaluation: FALSE
[16:09:31.949] Asynchronous evaluation: FALSE
[16:09:31.949] Local evaluation: TRUE
[16:09:31.949] Environment: R_GlobalEnv
[16:09:31.949] Capture standard output: TRUE
[16:09:31.949] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:31.949] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.949] Packages: <none>
[16:09:31.949] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:31.949] Resolved: TRUE
[16:09:31.949] Value: 4.62 KiB of class ‘list’
[16:09:31.949] Early signaling: FALSE
[16:09:31.949] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:31.949] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:31.950] Chunk #1 of 1 ... DONE
[16:09:31.950] Launching 1 futures (chunks) ... DONE
[16:09:31.950] Resolving 1 futures (chunks) ...
[16:09:31.950] resolve() on list ...
[16:09:31.951]  recursive: 0
[16:09:31.951]  length: 1
[16:09:31.951] 
[16:09:31.951] resolved() for ‘SequentialFuture’ ...
[16:09:31.951] - state: ‘finished’
[16:09:31.951] - run: TRUE
[16:09:31.951] - result: ‘FutureResult’
[16:09:31.951] resolved() for ‘SequentialFuture’ ... done
[16:09:31.951] Future #1
[16:09:31.952] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:31.952] - nx: 1
[16:09:31.952] - relay: TRUE
[16:09:31.952] - stdout: TRUE
[16:09:31.952] - signal: TRUE
[16:09:31.952] - resignal: FALSE
[16:09:31.952] - force: TRUE
[16:09:31.952] - relayed: [n=1] FALSE
[16:09:31.953] - queued futures: [n=1] FALSE
[16:09:31.953]  - until=1
[16:09:31.953]  - relaying element #1
[16:09:31.953] - relayed: [n=1] TRUE
[16:09:31.953] - queued futures: [n=1] TRUE
[16:09:31.953] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:31.953]  length: 0 (resolved future 1)
[16:09:31.953] Relaying remaining futures
[16:09:31.953] signalConditionsASAP(NULL, pos=0) ...
[16:09:31.954] - nx: 1
[16:09:31.954] - relay: TRUE
[16:09:31.954] - stdout: TRUE
[16:09:31.954] - signal: TRUE
[16:09:31.954] - resignal: FALSE
[16:09:31.954] - force: TRUE
[16:09:31.954] - relayed: [n=1] TRUE
[16:09:31.954] - queued futures: [n=1] TRUE
 - flush all
[16:09:31.954] - relayed: [n=1] TRUE
[16:09:31.954] - queued futures: [n=1] TRUE
[16:09:31.954] signalConditionsASAP(NULL, pos=0) ... done
[16:09:31.954] resolve() on list ... DONE
[16:09:31.955]  - Number of value chunks collected: 1
[16:09:31.955] Resolving 1 futures (chunks) ... DONE
[16:09:31.955] Reducing values from 1 chunks ...
[16:09:31.955]  - Number of values collected after concatenation: 3
[16:09:31.955]  - Number of values expected: 3
[16:09:31.955] Reducing values from 1 chunks ... DONE
[16:09:31.955] future_lapply() ... DONE
[16:09:31.955] future_by_internal() ... DONE
[16:09:31.956] future_by_internal() ...
[16:09:31.956] future_lapply() ...
[16:09:31.957] Number of chunks: 1
[16:09:31.957] getGlobalsAndPackagesXApply() ...
[16:09:31.957]  - future.globals: TRUE
[16:09:31.957] getGlobalsAndPackages() ...
[16:09:31.957] Searching for globals...
[16:09:31.958] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:31.958] Searching for globals ... DONE
[16:09:31.958] Resolving globals: FALSE
[16:09:31.959] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:31.959] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:31.959] - globals: [1] ‘FUN’
[16:09:31.959] 
[16:09:31.959] getGlobalsAndPackages() ... DONE
[16:09:31.959]  - globals found/used: [n=1] ‘FUN’
[16:09:31.959]  - needed namespaces: [n=0] 
[16:09:31.959] Finding globals ... DONE
[16:09:31.960]  - use_args: TRUE
[16:09:31.960]  - Getting '...' globals ...
[16:09:31.960] resolve() on list ...
[16:09:31.960]  recursive: 0
[16:09:31.960]  length: 1
[16:09:31.960]  elements: ‘...’
[16:09:31.960]  length: 0 (resolved future 1)
[16:09:31.960] resolve() on list ... DONE
[16:09:31.960]    - '...' content: [n=1] ‘digits’
[16:09:31.961] List of 1
[16:09:31.961]  $ ...:List of 1
[16:09:31.961]   ..$ digits: int 2
[16:09:31.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.961]  - attr(*, "where")=List of 1
[16:09:31.961]   ..$ ...:<environment: 0x5567e6f38788> 
[16:09:31.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.961]  - attr(*, "resolved")= logi TRUE
[16:09:31.961]  - attr(*, "total_size")= num NA
[16:09:31.963]  - Getting '...' globals ... DONE
[16:09:31.963] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:31.964] List of 2
[16:09:31.964]  $ ...future.FUN:function (object, ...)  
[16:09:31.964]  $ ...          :List of 1
[16:09:31.964]   ..$ digits: int 2
[16:09:31.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.964]  - attr(*, "where")=List of 2
[16:09:31.964]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:31.964]   ..$ ...          :<environment: 0x5567e6f38788> 
[16:09:31.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.964]  - attr(*, "resolved")= logi FALSE
[16:09:31.964]  - attr(*, "total_size")= num 1296
[16:09:31.966] Packages to be attached in all futures: [n=0] 
[16:09:31.967] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.967] Number of futures (= number of chunks): 1
[16:09:31.967] Launching 1 futures (chunks) ...
[16:09:31.967] Chunk #1 of 1 ...
[16:09:31.967]  - Finding globals in 'X' for chunk #1 ...
[16:09:31.967] getGlobalsAndPackages() ...
[16:09:31.967] Searching for globals...
[16:09:31.967] 
[16:09:31.968] Searching for globals ... DONE
[16:09:31.968] - globals: [0] <none>
[16:09:31.968] getGlobalsAndPackages() ... DONE
[16:09:31.968]    + additional globals found: [n=0] 
[16:09:31.968]    + additional namespaces needed: [n=0] 
[16:09:31.968]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:31.968]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[16:09:31.968]  - seeds: <none>
[16:09:31.969] getGlobalsAndPackages() ...
[16:09:31.969] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.970] Resolving globals: FALSE
[16:09:31.970] Tweak future expression to call with '...' arguments ...
[16:09:31.970] {
[16:09:31.970]     do.call(function(...) {
[16:09:31.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.970]             on.exit(options(oopts), add = TRUE)
[16:09:31.970]         }
[16:09:31.970]         {
[16:09:31.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.970]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.970]             })
[16:09:31.970]         }
[16:09:31.970]     }, args = future.call.arguments)
[16:09:31.970] }
[16:09:31.970] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.970] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.971] 
[16:09:31.971] getGlobalsAndPackages() ... DONE
[16:09:31.971] run() for ‘Future’ ...
[16:09:31.971] - state: ‘created’
[16:09:31.971] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:31.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:31.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:31.972]   - Field: ‘label’
[16:09:31.972]   - Field: ‘local’
[16:09:31.972]   - Field: ‘owner’
[16:09:31.972]   - Field: ‘envir’
[16:09:31.972]   - Field: ‘packages’
[16:09:31.972]   - Field: ‘gc’
[16:09:31.972]   - Field: ‘conditions’
[16:09:31.972]   - Field: ‘expr’
[16:09:31.972]   - Field: ‘uuid’
[16:09:31.972]   - Field: ‘seed’
[16:09:31.973]   - Field: ‘version’
[16:09:31.973]   - Field: ‘result’
[16:09:31.973]   - Field: ‘asynchronous’
[16:09:31.973]   - Field: ‘calls’
[16:09:31.973]   - Field: ‘globals’
[16:09:31.973]   - Field: ‘stdout’
[16:09:31.973]   - Field: ‘earlySignal’
[16:09:31.973]   - Field: ‘lazy’
[16:09:31.973]   - Field: ‘state’
[16:09:31.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:31.973] - Launch lazy future ...
[16:09:31.974] Packages needed by the future expression (n = 0): <none>
[16:09:31.974] Packages needed by future strategies (n = 0): <none>
[16:09:31.974] {
[16:09:31.974]     {
[16:09:31.974]         {
[16:09:31.974]             ...future.startTime <- base::Sys.time()
[16:09:31.974]             {
[16:09:31.974]                 {
[16:09:31.974]                   {
[16:09:31.974]                     base::local({
[16:09:31.974]                       has_future <- base::requireNamespace("future", 
[16:09:31.974]                         quietly = TRUE)
[16:09:31.974]                       if (has_future) {
[16:09:31.974]                         ns <- base::getNamespace("future")
[16:09:31.974]                         version <- ns[[".package"]][["version"]]
[16:09:31.974]                         if (is.null(version)) 
[16:09:31.974]                           version <- utils::packageVersion("future")
[16:09:31.974]                       }
[16:09:31.974]                       else {
[16:09:31.974]                         version <- NULL
[16:09:31.974]                       }
[16:09:31.974]                       if (!has_future || version < "1.8.0") {
[16:09:31.974]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.974]                           "", base::R.version$version.string), 
[16:09:31.974]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:31.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.974]                             "release", "version")], collapse = " "), 
[16:09:31.974]                           hostname = base::Sys.info()[["nodename"]])
[16:09:31.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.974]                           info)
[16:09:31.974]                         info <- base::paste(info, collapse = "; ")
[16:09:31.974]                         if (!has_future) {
[16:09:31.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.974]                             info)
[16:09:31.974]                         }
[16:09:31.974]                         else {
[16:09:31.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.974]                             info, version)
[16:09:31.974]                         }
[16:09:31.974]                         base::stop(msg)
[16:09:31.974]                       }
[16:09:31.974]                     })
[16:09:31.974]                   }
[16:09:31.974]                   options(future.plan = NULL)
[16:09:31.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.974]                 }
[16:09:31.974]                 ...future.workdir <- getwd()
[16:09:31.974]             }
[16:09:31.974]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.974]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.974]         }
[16:09:31.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.974]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[16:09:31.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.974]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.974]             base::names(...future.oldOptions))
[16:09:31.974]     }
[16:09:31.974]     if (FALSE) {
[16:09:31.974]     }
[16:09:31.974]     else {
[16:09:31.974]         if (TRUE) {
[16:09:31.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.974]                 open = "w")
[16:09:31.974]         }
[16:09:31.974]         else {
[16:09:31.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.974]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.974]         }
[16:09:31.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.974]             base::sink(type = "output", split = FALSE)
[16:09:31.974]             base::close(...future.stdout)
[16:09:31.974]         }, add = TRUE)
[16:09:31.974]     }
[16:09:31.974]     ...future.frame <- base::sys.nframe()
[16:09:31.974]     ...future.conditions <- base::list()
[16:09:31.974]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.974]     if (FALSE) {
[16:09:31.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.974]     }
[16:09:31.974]     ...future.result <- base::tryCatch({
[16:09:31.974]         base::withCallingHandlers({
[16:09:31.974]             ...future.value <- base::withVisible(base::local({
[16:09:31.974]                 do.call(function(...) {
[16:09:31.974]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.974]                   if (!identical(...future.globals.maxSize.org, 
[16:09:31.974]                     ...future.globals.maxSize)) {
[16:09:31.974]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.974]                     on.exit(options(oopts), add = TRUE)
[16:09:31.974]                   }
[16:09:31.974]                   {
[16:09:31.974]                     lapply(seq_along(...future.elements_ii), 
[16:09:31.974]                       FUN = function(jj) {
[16:09:31.974]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.974]                         ...future.FUN(...future.X_jj, ...)
[16:09:31.974]                       })
[16:09:31.974]                   }
[16:09:31.974]                 }, args = future.call.arguments)
[16:09:31.974]             }))
[16:09:31.974]             future::FutureResult(value = ...future.value$value, 
[16:09:31.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.974]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.974]                     ...future.globalenv.names))
[16:09:31.974]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.974]         }, condition = base::local({
[16:09:31.974]             c <- base::c
[16:09:31.974]             inherits <- base::inherits
[16:09:31.974]             invokeRestart <- base::invokeRestart
[16:09:31.974]             length <- base::length
[16:09:31.974]             list <- base::list
[16:09:31.974]             seq.int <- base::seq.int
[16:09:31.974]             signalCondition <- base::signalCondition
[16:09:31.974]             sys.calls <- base::sys.calls
[16:09:31.974]             `[[` <- base::`[[`
[16:09:31.974]             `+` <- base::`+`
[16:09:31.974]             `<<-` <- base::`<<-`
[16:09:31.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.974]                   3L)]
[16:09:31.974]             }
[16:09:31.974]             function(cond) {
[16:09:31.974]                 is_error <- inherits(cond, "error")
[16:09:31.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.974]                   NULL)
[16:09:31.974]                 if (is_error) {
[16:09:31.974]                   sessionInformation <- function() {
[16:09:31.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.974]                       search = base::search(), system = base::Sys.info())
[16:09:31.974]                   }
[16:09:31.974]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.974]                     cond$call), session = sessionInformation(), 
[16:09:31.974]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.974]                   signalCondition(cond)
[16:09:31.974]                 }
[16:09:31.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:31.974]                 "immediateCondition"))) {
[16:09:31.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.974]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.974]                   if (TRUE && !signal) {
[16:09:31.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.974]                     {
[16:09:31.974]                       inherits <- base::inherits
[16:09:31.974]                       invokeRestart <- base::invokeRestart
[16:09:31.974]                       is.null <- base::is.null
[16:09:31.974]                       muffled <- FALSE
[16:09:31.974]                       if (inherits(cond, "message")) {
[16:09:31.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.974]                         if (muffled) 
[16:09:31.974]                           invokeRestart("muffleMessage")
[16:09:31.974]                       }
[16:09:31.974]                       else if (inherits(cond, "warning")) {
[16:09:31.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.974]                         if (muffled) 
[16:09:31.974]                           invokeRestart("muffleWarning")
[16:09:31.974]                       }
[16:09:31.974]                       else if (inherits(cond, "condition")) {
[16:09:31.974]                         if (!is.null(pattern)) {
[16:09:31.974]                           computeRestarts <- base::computeRestarts
[16:09:31.974]                           grepl <- base::grepl
[16:09:31.974]                           restarts <- computeRestarts(cond)
[16:09:31.974]                           for (restart in restarts) {
[16:09:31.974]                             name <- restart$name
[16:09:31.974]                             if (is.null(name)) 
[16:09:31.974]                               next
[16:09:31.974]                             if (!grepl(pattern, name)) 
[16:09:31.974]                               next
[16:09:31.974]                             invokeRestart(restart)
[16:09:31.974]                             muffled <- TRUE
[16:09:31.974]                             break
[16:09:31.974]                           }
[16:09:31.974]                         }
[16:09:31.974]                       }
[16:09:31.974]                       invisible(muffled)
[16:09:31.974]                     }
[16:09:31.974]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.974]                   }
[16:09:31.974]                 }
[16:09:31.974]                 else {
[16:09:31.974]                   if (TRUE) {
[16:09:31.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.974]                     {
[16:09:31.974]                       inherits <- base::inherits
[16:09:31.974]                       invokeRestart <- base::invokeRestart
[16:09:31.974]                       is.null <- base::is.null
[16:09:31.974]                       muffled <- FALSE
[16:09:31.974]                       if (inherits(cond, "message")) {
[16:09:31.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.974]                         if (muffled) 
[16:09:31.974]                           invokeRestart("muffleMessage")
[16:09:31.974]                       }
[16:09:31.974]                       else if (inherits(cond, "warning")) {
[16:09:31.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.974]                         if (muffled) 
[16:09:31.974]                           invokeRestart("muffleWarning")
[16:09:31.974]                       }
[16:09:31.974]                       else if (inherits(cond, "condition")) {
[16:09:31.974]                         if (!is.null(pattern)) {
[16:09:31.974]                           computeRestarts <- base::computeRestarts
[16:09:31.974]                           grepl <- base::grepl
[16:09:31.974]                           restarts <- computeRestarts(cond)
[16:09:31.974]                           for (restart in restarts) {
[16:09:31.974]                             name <- restart$name
[16:09:31.974]                             if (is.null(name)) 
[16:09:31.974]                               next
[16:09:31.974]                             if (!grepl(pattern, name)) 
[16:09:31.974]                               next
[16:09:31.974]                             invokeRestart(restart)
[16:09:31.974]                             muffled <- TRUE
[16:09:31.974]                             break
[16:09:31.974]                           }
[16:09:31.974]                         }
[16:09:31.974]                       }
[16:09:31.974]                       invisible(muffled)
[16:09:31.974]                     }
[16:09:31.974]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.974]                   }
[16:09:31.974]                 }
[16:09:31.974]             }
[16:09:31.974]         }))
[16:09:31.974]     }, error = function(ex) {
[16:09:31.974]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.974]                 ...future.rng), started = ...future.startTime, 
[16:09:31.974]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.974]             version = "1.8"), class = "FutureResult")
[16:09:31.974]     }, finally = {
[16:09:31.974]         if (!identical(...future.workdir, getwd())) 
[16:09:31.974]             setwd(...future.workdir)
[16:09:31.974]         {
[16:09:31.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.974]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.974]             }
[16:09:31.974]             base::options(...future.oldOptions)
[16:09:31.974]             if (.Platform$OS.type == "windows") {
[16:09:31.974]                 old_names <- names(...future.oldEnvVars)
[16:09:31.974]                 envs <- base::Sys.getenv()
[16:09:31.974]                 names <- names(envs)
[16:09:31.974]                 common <- intersect(names, old_names)
[16:09:31.974]                 added <- setdiff(names, old_names)
[16:09:31.974]                 removed <- setdiff(old_names, names)
[16:09:31.974]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.974]                   envs[common]]
[16:09:31.974]                 NAMES <- toupper(changed)
[16:09:31.974]                 args <- list()
[16:09:31.974]                 for (kk in seq_along(NAMES)) {
[16:09:31.974]                   name <- changed[[kk]]
[16:09:31.974]                   NAME <- NAMES[[kk]]
[16:09:31.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.974]                     next
[16:09:31.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.974]                 }
[16:09:31.974]                 NAMES <- toupper(added)
[16:09:31.974]                 for (kk in seq_along(NAMES)) {
[16:09:31.974]                   name <- added[[kk]]
[16:09:31.974]                   NAME <- NAMES[[kk]]
[16:09:31.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.974]                     next
[16:09:31.974]                   args[[name]] <- ""
[16:09:31.974]                 }
[16:09:31.974]                 NAMES <- toupper(removed)
[16:09:31.974]                 for (kk in seq_along(NAMES)) {
[16:09:31.974]                   name <- removed[[kk]]
[16:09:31.974]                   NAME <- NAMES[[kk]]
[16:09:31.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.974]                     next
[16:09:31.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.974]                 }
[16:09:31.974]                 if (length(args) > 0) 
[16:09:31.974]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.974]             }
[16:09:31.974]             else {
[16:09:31.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.974]             }
[16:09:31.974]             {
[16:09:31.974]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.974]                   0L) {
[16:09:31.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.974]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.974]                   base::options(opts)
[16:09:31.974]                 }
[16:09:31.974]                 {
[16:09:31.974]                   {
[16:09:31.974]                     NULL
[16:09:31.974]                     RNGkind("Mersenne-Twister")
[16:09:31.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:31.974]                       inherits = FALSE)
[16:09:31.974]                   }
[16:09:31.974]                   options(future.plan = NULL)
[16:09:31.974]                   if (is.na(NA_character_)) 
[16:09:31.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.974]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:31.974]                   {
[16:09:31.974]                     future <- SequentialFuture(..., envir = envir)
[16:09:31.974]                     if (!future$lazy) 
[16:09:31.974]                       future <- run(future)
[16:09:31.974]                     invisible(future)
[16:09:31.974]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.974]                 }
[16:09:31.974]             }
[16:09:31.974]         }
[16:09:31.974]     })
[16:09:31.974]     if (TRUE) {
[16:09:31.974]         base::sink(type = "output", split = FALSE)
[16:09:31.974]         if (TRUE) {
[16:09:31.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.974]         }
[16:09:31.974]         else {
[16:09:31.974]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.974]         }
[16:09:31.974]         base::close(...future.stdout)
[16:09:31.974]         ...future.stdout <- NULL
[16:09:31.974]     }
[16:09:31.974]     ...future.result$conditions <- ...future.conditions
[16:09:31.974]     ...future.result$finished <- base::Sys.time()
[16:09:31.974]     ...future.result
[16:09:31.974] }
[16:09:31.976] assign_globals() ...
[16:09:31.976] List of 5
[16:09:31.976]  $ ...future.FUN            :function (object, ...)  
[16:09:31.976]  $ future.call.arguments    :List of 1
[16:09:31.976]   ..$ digits: int 2
[16:09:31.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.976]  $ ...future.elements_ii    :List of 6
[16:09:31.976]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:09:31.976]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:09:31.976]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:09:31.976]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:09:31.976]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:09:31.976]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:09:31.976]  $ ...future.seeds_ii       : NULL
[16:09:31.976]  $ ...future.globals.maxSize: NULL
[16:09:31.976]  - attr(*, "resolved")= logi FALSE
[16:09:31.976]  - attr(*, "total_size")= num 1296
[16:09:31.976]  - attr(*, "where")=List of 5
[16:09:31.976]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:31.976]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:31.976]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:31.976]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:31.976]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:31.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.976]  - attr(*, "already-done")= logi TRUE
[16:09:31.982] - copied ‘...future.FUN’ to environment
[16:09:31.982] - copied ‘future.call.arguments’ to environment
[16:09:31.982] - copied ‘...future.elements_ii’ to environment
[16:09:31.982] - copied ‘...future.seeds_ii’ to environment
[16:09:31.982] - copied ‘...future.globals.maxSize’ to environment
[16:09:31.982] assign_globals() ... done
[16:09:31.983] plan(): Setting new future strategy stack:
[16:09:31.983] List of future strategies:
[16:09:31.983] 1. sequential:
[16:09:31.983]    - args: function (..., envir = parent.frame())
[16:09:31.983]    - tweaked: FALSE
[16:09:31.983]    - call: NULL
[16:09:31.983] plan(): nbrOfWorkers() = 1
[16:09:31.984] plan(): Setting new future strategy stack:
[16:09:31.984] List of future strategies:
[16:09:31.984] 1. sequential:
[16:09:31.984]    - args: function (..., envir = parent.frame())
[16:09:31.984]    - tweaked: FALSE
[16:09:31.984]    - call: plan(strategy)
[16:09:31.985] plan(): nbrOfWorkers() = 1
[16:09:31.985] SequentialFuture started (and completed)
[16:09:31.985] - Launch lazy future ... done
[16:09:31.985] run() for ‘SequentialFuture’ ... done
[16:09:31.985] Created future:
[16:09:31.985] SequentialFuture:
[16:09:31.985] Label: ‘future_by-1’
[16:09:31.985] Expression:
[16:09:31.985] {
[16:09:31.985]     do.call(function(...) {
[16:09:31.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.985]             on.exit(options(oopts), add = TRUE)
[16:09:31.985]         }
[16:09:31.985]         {
[16:09:31.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.985]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.985]             })
[16:09:31.985]         }
[16:09:31.985]     }, args = future.call.arguments)
[16:09:31.985] }
[16:09:31.985] Lazy evaluation: FALSE
[16:09:31.985] Asynchronous evaluation: FALSE
[16:09:31.985] Local evaluation: TRUE
[16:09:31.985] Environment: R_GlobalEnv
[16:09:31.985] Capture standard output: TRUE
[16:09:31.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:31.985] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.985] Packages: <none>
[16:09:31.985] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:31.985] Resolved: TRUE
[16:09:31.985] Value: 5.48 KiB of class ‘list’
[16:09:31.985] Early signaling: FALSE
[16:09:31.985] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:31.985] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:31.986] Chunk #1 of 1 ... DONE
[16:09:31.986] Launching 1 futures (chunks) ... DONE
[16:09:31.987] Resolving 1 futures (chunks) ...
[16:09:31.987] resolve() on list ...
[16:09:31.987]  recursive: 0
[16:09:31.987]  length: 1
[16:09:31.987] 
[16:09:31.987] resolved() for ‘SequentialFuture’ ...
[16:09:31.987] - state: ‘finished’
[16:09:31.987] - run: TRUE
[16:09:31.987] - result: ‘FutureResult’
[16:09:31.987] resolved() for ‘SequentialFuture’ ... done
[16:09:31.987] Future #1
[16:09:31.988] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:31.988] - nx: 1
[16:09:31.988] - relay: TRUE
[16:09:31.988] - stdout: TRUE
[16:09:31.988] - signal: TRUE
[16:09:31.988] - resignal: FALSE
[16:09:31.988] - force: TRUE
[16:09:31.988] - relayed: [n=1] FALSE
[16:09:31.988] - queued futures: [n=1] FALSE
[16:09:31.988]  - until=1
[16:09:31.988]  - relaying element #1
[16:09:31.989] - relayed: [n=1] TRUE
[16:09:31.989] - queued futures: [n=1] TRUE
[16:09:31.989] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:31.989]  length: 0 (resolved future 1)
[16:09:31.989] Relaying remaining futures
[16:09:31.989] signalConditionsASAP(NULL, pos=0) ...
[16:09:31.989] - nx: 1
[16:09:31.989] - relay: TRUE
[16:09:31.989] - stdout: TRUE
[16:09:31.989] - signal: TRUE
[16:09:31.989] - resignal: FALSE
[16:09:31.989] - force: TRUE
[16:09:31.990] - relayed: [n=1] TRUE
[16:09:31.990] - queued futures: [n=1] TRUE
 - flush all
[16:09:31.990] - relayed: [n=1] TRUE
[16:09:31.991] - queued futures: [n=1] TRUE
[16:09:31.991] signalConditionsASAP(NULL, pos=0) ... done
[16:09:31.991] resolve() on list ... DONE
[16:09:31.991]  - Number of value chunks collected: 1
[16:09:31.991] Resolving 1 futures (chunks) ... DONE
[16:09:31.991] Reducing values from 1 chunks ...
[16:09:31.991]  - Number of values collected after concatenation: 6
[16:09:31.992]  - Number of values expected: 6
[16:09:31.992] Reducing values from 1 chunks ... DONE
[16:09:31.992] future_lapply() ... DONE
[16:09:31.992] future_by_internal() ... DONE
[16:09:31.995] future_by_internal() ...
[16:09:31.995] future_lapply() ...
[16:09:31.996] Number of chunks: 1
[16:09:31.996] getGlobalsAndPackagesXApply() ...
[16:09:31.996]  - future.globals: TRUE
[16:09:31.996] getGlobalsAndPackages() ...
[16:09:31.997] Searching for globals...
[16:09:31.998] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:31.998] Searching for globals ... DONE
[16:09:31.998] Resolving globals: FALSE
[16:09:31.999] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:09:31.999] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:09:31.999] - globals: [1] ‘FUN’
[16:09:31.999] - packages: [1] ‘stats’
[16:09:31.999] getGlobalsAndPackages() ... DONE
[16:09:31.999]  - globals found/used: [n=1] ‘FUN’
[16:09:31.999]  - needed namespaces: [n=1] ‘stats’
[16:09:32.000] Finding globals ... DONE
[16:09:32.000]  - use_args: TRUE
[16:09:32.000]  - Getting '...' globals ...
[16:09:32.000] resolve() on list ...
[16:09:32.000]  recursive: 0
[16:09:32.000]  length: 1
[16:09:32.000]  elements: ‘...’
[16:09:32.000]  length: 0 (resolved future 1)
[16:09:32.000] resolve() on list ... DONE
[16:09:32.001]    - '...' content: [n=1] ‘singular.ok’
[16:09:32.001] List of 1
[16:09:32.001]  $ ...:List of 1
[16:09:32.001]   ..$ singular.ok: logi FALSE
[16:09:32.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.001]  - attr(*, "where")=List of 1
[16:09:32.001]   ..$ ...:<environment: 0x5567e6e01f68> 
[16:09:32.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.001]  - attr(*, "resolved")= logi TRUE
[16:09:32.001]  - attr(*, "total_size")= num NA
[16:09:32.003]  - Getting '...' globals ... DONE
[16:09:32.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.004] List of 2
[16:09:32.004]  $ ...future.FUN:function (x, ...)  
[16:09:32.004]  $ ...          :List of 1
[16:09:32.004]   ..$ singular.ok: logi FALSE
[16:09:32.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.004]  - attr(*, "where")=List of 2
[16:09:32.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.004]   ..$ ...          :<environment: 0x5567e6e01f68> 
[16:09:32.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.004]  - attr(*, "resolved")= logi FALSE
[16:09:32.004]  - attr(*, "total_size")= num 5384
[16:09:32.007] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.007] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.007] Number of futures (= number of chunks): 1
[16:09:32.007] Launching 1 futures (chunks) ...
[16:09:32.007] Chunk #1 of 1 ...
[16:09:32.007]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.007] getGlobalsAndPackages() ...
[16:09:32.007] Searching for globals...
[16:09:32.008] 
[16:09:32.008] Searching for globals ... DONE
[16:09:32.008] - globals: [0] <none>
[16:09:32.008] getGlobalsAndPackages() ... DONE
[16:09:32.008]    + additional globals found: [n=0] 
[16:09:32.008]    + additional namespaces needed: [n=0] 
[16:09:32.008]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.009]  - seeds: <none>
[16:09:32.009] getGlobalsAndPackages() ...
[16:09:32.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.009] Resolving globals: FALSE
[16:09:32.010] Tweak future expression to call with '...' arguments ...
[16:09:32.010] {
[16:09:32.010]     do.call(function(...) {
[16:09:32.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.010]             on.exit(options(oopts), add = TRUE)
[16:09:32.010]         }
[16:09:32.010]         {
[16:09:32.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.010]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.010]             })
[16:09:32.010]         }
[16:09:32.010]     }, args = future.call.arguments)
[16:09:32.010] }
[16:09:32.010] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.011] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.011] 
[16:09:32.011] getGlobalsAndPackages() ... DONE
[16:09:32.011] run() for ‘Future’ ...
[16:09:32.011] - state: ‘created’
[16:09:32.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.012]   - Field: ‘label’
[16:09:32.012]   - Field: ‘local’
[16:09:32.012]   - Field: ‘owner’
[16:09:32.012]   - Field: ‘envir’
[16:09:32.012]   - Field: ‘packages’
[16:09:32.012]   - Field: ‘gc’
[16:09:32.012]   - Field: ‘conditions’
[16:09:32.012]   - Field: ‘expr’
[16:09:32.013]   - Field: ‘uuid’
[16:09:32.013]   - Field: ‘seed’
[16:09:32.013]   - Field: ‘version’
[16:09:32.013]   - Field: ‘result’
[16:09:32.013]   - Field: ‘asynchronous’
[16:09:32.013]   - Field: ‘calls’
[16:09:32.013]   - Field: ‘globals’
[16:09:32.013]   - Field: ‘stdout’
[16:09:32.013]   - Field: ‘earlySignal’
[16:09:32.013]   - Field: ‘lazy’
[16:09:32.013]   - Field: ‘state’
[16:09:32.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.014] - Launch lazy future ...
[16:09:32.014] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.014] Packages needed by future strategies (n = 0): <none>
[16:09:32.014] {
[16:09:32.014]     {
[16:09:32.014]         {
[16:09:32.014]             ...future.startTime <- base::Sys.time()
[16:09:32.014]             {
[16:09:32.014]                 {
[16:09:32.014]                   {
[16:09:32.014]                     {
[16:09:32.014]                       base::local({
[16:09:32.014]                         has_future <- base::requireNamespace("future", 
[16:09:32.014]                           quietly = TRUE)
[16:09:32.014]                         if (has_future) {
[16:09:32.014]                           ns <- base::getNamespace("future")
[16:09:32.014]                           version <- ns[[".package"]][["version"]]
[16:09:32.014]                           if (is.null(version)) 
[16:09:32.014]                             version <- utils::packageVersion("future")
[16:09:32.014]                         }
[16:09:32.014]                         else {
[16:09:32.014]                           version <- NULL
[16:09:32.014]                         }
[16:09:32.014]                         if (!has_future || version < "1.8.0") {
[16:09:32.014]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.014]                             "", base::R.version$version.string), 
[16:09:32.014]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.014]                               "release", "version")], collapse = " "), 
[16:09:32.014]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.014]                             info)
[16:09:32.014]                           info <- base::paste(info, collapse = "; ")
[16:09:32.014]                           if (!has_future) {
[16:09:32.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.014]                               info)
[16:09:32.014]                           }
[16:09:32.014]                           else {
[16:09:32.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.014]                               info, version)
[16:09:32.014]                           }
[16:09:32.014]                           base::stop(msg)
[16:09:32.014]                         }
[16:09:32.014]                       })
[16:09:32.014]                     }
[16:09:32.014]                     base::local({
[16:09:32.014]                       for (pkg in "stats") {
[16:09:32.014]                         base::loadNamespace(pkg)
[16:09:32.014]                         base::library(pkg, character.only = TRUE)
[16:09:32.014]                       }
[16:09:32.014]                     })
[16:09:32.014]                   }
[16:09:32.014]                   options(future.plan = NULL)
[16:09:32.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.014]                 }
[16:09:32.014]                 ...future.workdir <- getwd()
[16:09:32.014]             }
[16:09:32.014]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.014]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.014]         }
[16:09:32.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.014]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.014]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.014]             base::names(...future.oldOptions))
[16:09:32.014]     }
[16:09:32.014]     if (FALSE) {
[16:09:32.014]     }
[16:09:32.014]     else {
[16:09:32.014]         if (TRUE) {
[16:09:32.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.014]                 open = "w")
[16:09:32.014]         }
[16:09:32.014]         else {
[16:09:32.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.014]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.014]         }
[16:09:32.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.014]             base::sink(type = "output", split = FALSE)
[16:09:32.014]             base::close(...future.stdout)
[16:09:32.014]         }, add = TRUE)
[16:09:32.014]     }
[16:09:32.014]     ...future.frame <- base::sys.nframe()
[16:09:32.014]     ...future.conditions <- base::list()
[16:09:32.014]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.014]     if (FALSE) {
[16:09:32.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.014]     }
[16:09:32.014]     ...future.result <- base::tryCatch({
[16:09:32.014]         base::withCallingHandlers({
[16:09:32.014]             ...future.value <- base::withVisible(base::local({
[16:09:32.014]                 do.call(function(...) {
[16:09:32.014]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.014]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.014]                     ...future.globals.maxSize)) {
[16:09:32.014]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.014]                     on.exit(options(oopts), add = TRUE)
[16:09:32.014]                   }
[16:09:32.014]                   {
[16:09:32.014]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.014]                       FUN = function(jj) {
[16:09:32.014]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.014]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.014]                       })
[16:09:32.014]                   }
[16:09:32.014]                 }, args = future.call.arguments)
[16:09:32.014]             }))
[16:09:32.014]             future::FutureResult(value = ...future.value$value, 
[16:09:32.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.014]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.014]                     ...future.globalenv.names))
[16:09:32.014]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.014]         }, condition = base::local({
[16:09:32.014]             c <- base::c
[16:09:32.014]             inherits <- base::inherits
[16:09:32.014]             invokeRestart <- base::invokeRestart
[16:09:32.014]             length <- base::length
[16:09:32.014]             list <- base::list
[16:09:32.014]             seq.int <- base::seq.int
[16:09:32.014]             signalCondition <- base::signalCondition
[16:09:32.014]             sys.calls <- base::sys.calls
[16:09:32.014]             `[[` <- base::`[[`
[16:09:32.014]             `+` <- base::`+`
[16:09:32.014]             `<<-` <- base::`<<-`
[16:09:32.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.014]                   3L)]
[16:09:32.014]             }
[16:09:32.014]             function(cond) {
[16:09:32.014]                 is_error <- inherits(cond, "error")
[16:09:32.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.014]                   NULL)
[16:09:32.014]                 if (is_error) {
[16:09:32.014]                   sessionInformation <- function() {
[16:09:32.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.014]                       search = base::search(), system = base::Sys.info())
[16:09:32.014]                   }
[16:09:32.014]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.014]                     cond$call), session = sessionInformation(), 
[16:09:32.014]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.014]                   signalCondition(cond)
[16:09:32.014]                 }
[16:09:32.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.014]                 "immediateCondition"))) {
[16:09:32.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.014]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.014]                   if (TRUE && !signal) {
[16:09:32.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.014]                     {
[16:09:32.014]                       inherits <- base::inherits
[16:09:32.014]                       invokeRestart <- base::invokeRestart
[16:09:32.014]                       is.null <- base::is.null
[16:09:32.014]                       muffled <- FALSE
[16:09:32.014]                       if (inherits(cond, "message")) {
[16:09:32.014]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.014]                         if (muffled) 
[16:09:32.014]                           invokeRestart("muffleMessage")
[16:09:32.014]                       }
[16:09:32.014]                       else if (inherits(cond, "warning")) {
[16:09:32.014]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.014]                         if (muffled) 
[16:09:32.014]                           invokeRestart("muffleWarning")
[16:09:32.014]                       }
[16:09:32.014]                       else if (inherits(cond, "condition")) {
[16:09:32.014]                         if (!is.null(pattern)) {
[16:09:32.014]                           computeRestarts <- base::computeRestarts
[16:09:32.014]                           grepl <- base::grepl
[16:09:32.014]                           restarts <- computeRestarts(cond)
[16:09:32.014]                           for (restart in restarts) {
[16:09:32.014]                             name <- restart$name
[16:09:32.014]                             if (is.null(name)) 
[16:09:32.014]                               next
[16:09:32.014]                             if (!grepl(pattern, name)) 
[16:09:32.014]                               next
[16:09:32.014]                             invokeRestart(restart)
[16:09:32.014]                             muffled <- TRUE
[16:09:32.014]                             break
[16:09:32.014]                           }
[16:09:32.014]                         }
[16:09:32.014]                       }
[16:09:32.014]                       invisible(muffled)
[16:09:32.014]                     }
[16:09:32.014]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.014]                   }
[16:09:32.014]                 }
[16:09:32.014]                 else {
[16:09:32.014]                   if (TRUE) {
[16:09:32.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.014]                     {
[16:09:32.014]                       inherits <- base::inherits
[16:09:32.014]                       invokeRestart <- base::invokeRestart
[16:09:32.014]                       is.null <- base::is.null
[16:09:32.014]                       muffled <- FALSE
[16:09:32.014]                       if (inherits(cond, "message")) {
[16:09:32.014]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.014]                         if (muffled) 
[16:09:32.014]                           invokeRestart("muffleMessage")
[16:09:32.014]                       }
[16:09:32.014]                       else if (inherits(cond, "warning")) {
[16:09:32.014]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.014]                         if (muffled) 
[16:09:32.014]                           invokeRestart("muffleWarning")
[16:09:32.014]                       }
[16:09:32.014]                       else if (inherits(cond, "condition")) {
[16:09:32.014]                         if (!is.null(pattern)) {
[16:09:32.014]                           computeRestarts <- base::computeRestarts
[16:09:32.014]                           grepl <- base::grepl
[16:09:32.014]                           restarts <- computeRestarts(cond)
[16:09:32.014]                           for (restart in restarts) {
[16:09:32.014]                             name <- restart$name
[16:09:32.014]                             if (is.null(name)) 
[16:09:32.014]                               next
[16:09:32.014]                             if (!grepl(pattern, name)) 
[16:09:32.014]                               next
[16:09:32.014]                             invokeRestart(restart)
[16:09:32.014]                             muffled <- TRUE
[16:09:32.014]                             break
[16:09:32.014]                           }
[16:09:32.014]                         }
[16:09:32.014]                       }
[16:09:32.014]                       invisible(muffled)
[16:09:32.014]                     }
[16:09:32.014]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.014]                   }
[16:09:32.014]                 }
[16:09:32.014]             }
[16:09:32.014]         }))
[16:09:32.014]     }, error = function(ex) {
[16:09:32.014]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.014]                 ...future.rng), started = ...future.startTime, 
[16:09:32.014]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.014]             version = "1.8"), class = "FutureResult")
[16:09:32.014]     }, finally = {
[16:09:32.014]         if (!identical(...future.workdir, getwd())) 
[16:09:32.014]             setwd(...future.workdir)
[16:09:32.014]         {
[16:09:32.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.014]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.014]             }
[16:09:32.014]             base::options(...future.oldOptions)
[16:09:32.014]             if (.Platform$OS.type == "windows") {
[16:09:32.014]                 old_names <- names(...future.oldEnvVars)
[16:09:32.014]                 envs <- base::Sys.getenv()
[16:09:32.014]                 names <- names(envs)
[16:09:32.014]                 common <- intersect(names, old_names)
[16:09:32.014]                 added <- setdiff(names, old_names)
[16:09:32.014]                 removed <- setdiff(old_names, names)
[16:09:32.014]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.014]                   envs[common]]
[16:09:32.014]                 NAMES <- toupper(changed)
[16:09:32.014]                 args <- list()
[16:09:32.014]                 for (kk in seq_along(NAMES)) {
[16:09:32.014]                   name <- changed[[kk]]
[16:09:32.014]                   NAME <- NAMES[[kk]]
[16:09:32.014]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.014]                     next
[16:09:32.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.014]                 }
[16:09:32.014]                 NAMES <- toupper(added)
[16:09:32.014]                 for (kk in seq_along(NAMES)) {
[16:09:32.014]                   name <- added[[kk]]
[16:09:32.014]                   NAME <- NAMES[[kk]]
[16:09:32.014]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.014]                     next
[16:09:32.014]                   args[[name]] <- ""
[16:09:32.014]                 }
[16:09:32.014]                 NAMES <- toupper(removed)
[16:09:32.014]                 for (kk in seq_along(NAMES)) {
[16:09:32.014]                   name <- removed[[kk]]
[16:09:32.014]                   NAME <- NAMES[[kk]]
[16:09:32.014]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.014]                     next
[16:09:32.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.014]                 }
[16:09:32.014]                 if (length(args) > 0) 
[16:09:32.014]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.014]             }
[16:09:32.014]             else {
[16:09:32.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.014]             }
[16:09:32.014]             {
[16:09:32.014]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.014]                   0L) {
[16:09:32.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.014]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.014]                   base::options(opts)
[16:09:32.014]                 }
[16:09:32.014]                 {
[16:09:32.014]                   {
[16:09:32.014]                     NULL
[16:09:32.014]                     RNGkind("Mersenne-Twister")
[16:09:32.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.014]                       inherits = FALSE)
[16:09:32.014]                   }
[16:09:32.014]                   options(future.plan = NULL)
[16:09:32.014]                   if (is.na(NA_character_)) 
[16:09:32.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.014]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.014]                   {
[16:09:32.014]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.014]                     if (!future$lazy) 
[16:09:32.014]                       future <- run(future)
[16:09:32.014]                     invisible(future)
[16:09:32.014]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.014]                 }
[16:09:32.014]             }
[16:09:32.014]         }
[16:09:32.014]     })
[16:09:32.014]     if (TRUE) {
[16:09:32.014]         base::sink(type = "output", split = FALSE)
[16:09:32.014]         if (TRUE) {
[16:09:32.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.014]         }
[16:09:32.014]         else {
[16:09:32.014]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.014]         }
[16:09:32.014]         base::close(...future.stdout)
[16:09:32.014]         ...future.stdout <- NULL
[16:09:32.014]     }
[16:09:32.014]     ...future.result$conditions <- ...future.conditions
[16:09:32.014]     ...future.result$finished <- base::Sys.time()
[16:09:32.014]     ...future.result
[16:09:32.014] }
[16:09:32.016] assign_globals() ...
[16:09:32.016] List of 5
[16:09:32.016]  $ ...future.FUN            :function (x, ...)  
[16:09:32.016]  $ future.call.arguments    :List of 1
[16:09:32.016]   ..$ singular.ok: logi FALSE
[16:09:32.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.016]  $ ...future.elements_ii    :List of 3
[16:09:32.016]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.016]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.016]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.016]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.016]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.016]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.016]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.016]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.016]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.016]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.016]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.016]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.016]  $ ...future.seeds_ii       : NULL
[16:09:32.016]  $ ...future.globals.maxSize: NULL
[16:09:32.016]  - attr(*, "resolved")= logi FALSE
[16:09:32.016]  - attr(*, "total_size")= num 5384
[16:09:32.016]  - attr(*, "where")=List of 5
[16:09:32.016]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.016]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.016]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.016]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.016]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.016]  - attr(*, "already-done")= logi TRUE
[16:09:32.024] - reassign environment for ‘...future.FUN’
[16:09:32.025] - copied ‘...future.FUN’ to environment
[16:09:32.025] - copied ‘future.call.arguments’ to environment
[16:09:32.025] - copied ‘...future.elements_ii’ to environment
[16:09:32.025] - copied ‘...future.seeds_ii’ to environment
[16:09:32.025] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.025] assign_globals() ... done
[16:09:32.025] plan(): Setting new future strategy stack:
[16:09:32.026] List of future strategies:
[16:09:32.026] 1. sequential:
[16:09:32.026]    - args: function (..., envir = parent.frame())
[16:09:32.026]    - tweaked: FALSE
[16:09:32.026]    - call: NULL
[16:09:32.026] plan(): nbrOfWorkers() = 1
[16:09:32.028] plan(): Setting new future strategy stack:
[16:09:32.029] List of future strategies:
[16:09:32.029] 1. sequential:
[16:09:32.029]    - args: function (..., envir = parent.frame())
[16:09:32.029]    - tweaked: FALSE
[16:09:32.029]    - call: plan(strategy)
[16:09:32.029] plan(): nbrOfWorkers() = 1
[16:09:32.029] SequentialFuture started (and completed)
[16:09:32.029] - Launch lazy future ... done
[16:09:32.029] run() for ‘SequentialFuture’ ... done
[16:09:32.029] Created future:
[16:09:32.029] SequentialFuture:
[16:09:32.029] Label: ‘future_by-1’
[16:09:32.029] Expression:
[16:09:32.029] {
[16:09:32.029]     do.call(function(...) {
[16:09:32.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.029]             on.exit(options(oopts), add = TRUE)
[16:09:32.029]         }
[16:09:32.029]         {
[16:09:32.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.029]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.029]             })
[16:09:32.029]         }
[16:09:32.029]     }, args = future.call.arguments)
[16:09:32.029] }
[16:09:32.029] Lazy evaluation: FALSE
[16:09:32.029] Asynchronous evaluation: FALSE
[16:09:32.029] Local evaluation: TRUE
[16:09:32.029] Environment: R_GlobalEnv
[16:09:32.029] Capture standard output: TRUE
[16:09:32.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.029] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.029] Packages: 1 packages (‘stats’)
[16:09:32.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.029] Resolved: TRUE
[16:09:32.029] Value: 26.06 KiB of class ‘list’
[16:09:32.029] Early signaling: FALSE
[16:09:32.029] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.029] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.032] Chunk #1 of 1 ... DONE
[16:09:32.032] Launching 1 futures (chunks) ... DONE
[16:09:32.032] Resolving 1 futures (chunks) ...
[16:09:32.032] resolve() on list ...
[16:09:32.032]  recursive: 0
[16:09:32.032]  length: 1
[16:09:32.032] 
[16:09:32.033] resolved() for ‘SequentialFuture’ ...
[16:09:32.033] - state: ‘finished’
[16:09:32.033] - run: TRUE
[16:09:32.033] - result: ‘FutureResult’
[16:09:32.033] resolved() for ‘SequentialFuture’ ... done
[16:09:32.033] Future #1
[16:09:32.033] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.033] - nx: 1
[16:09:32.033] - relay: TRUE
[16:09:32.033] - stdout: TRUE
[16:09:32.034] - signal: TRUE
[16:09:32.034] - resignal: FALSE
[16:09:32.034] - force: TRUE
[16:09:32.034] - relayed: [n=1] FALSE
[16:09:32.034] - queued futures: [n=1] FALSE
[16:09:32.034]  - until=1
[16:09:32.034]  - relaying element #1
[16:09:32.034] - relayed: [n=1] TRUE
[16:09:32.034] - queued futures: [n=1] TRUE
[16:09:32.034] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.034]  length: 0 (resolved future 1)
[16:09:32.035] Relaying remaining futures
[16:09:32.035] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.035] - nx: 1
[16:09:32.035] - relay: TRUE
[16:09:32.035] - stdout: TRUE
[16:09:32.035] - signal: TRUE
[16:09:32.035] - resignal: FALSE
[16:09:32.035] - force: TRUE
[16:09:32.035] - relayed: [n=1] TRUE
[16:09:32.035] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.035] - relayed: [n=1] TRUE
[16:09:32.035] - queued futures: [n=1] TRUE
[16:09:32.036] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.036] resolve() on list ... DONE
[16:09:32.036]  - Number of value chunks collected: 1
[16:09:32.036] Resolving 1 futures (chunks) ... DONE
[16:09:32.036] Reducing values from 1 chunks ...
[16:09:32.036]  - Number of values collected after concatenation: 3
[16:09:32.036]  - Number of values expected: 3
[16:09:32.036] Reducing values from 1 chunks ... DONE
[16:09:32.036] future_lapply() ... DONE
[16:09:32.036] future_by_internal() ... DONE
[16:09:32.040] future_by_internal() ...
[16:09:32.041] future_lapply() ...
[16:09:32.041] Number of chunks: 1
[16:09:32.041] getGlobalsAndPackagesXApply() ...
[16:09:32.042]  - future.globals: TRUE
[16:09:32.042] getGlobalsAndPackages() ...
[16:09:32.042] Searching for globals...
[16:09:32.043] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.043] Searching for globals ... DONE
[16:09:32.043] Resolving globals: FALSE
[16:09:32.044] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:09:32.044] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:09:32.044] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.045] - packages: [1] ‘stats’
[16:09:32.045] getGlobalsAndPackages() ... DONE
[16:09:32.045]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.045]  - needed namespaces: [n=1] ‘stats’
[16:09:32.045] Finding globals ... DONE
[16:09:32.045]  - use_args: TRUE
[16:09:32.045]  - Getting '...' globals ...
[16:09:32.045] resolve() on list ...
[16:09:32.045]  recursive: 0
[16:09:32.046]  length: 1
[16:09:32.046]  elements: ‘...’
[16:09:32.046]  length: 0 (resolved future 1)
[16:09:32.046] resolve() on list ... DONE
[16:09:32.046]    - '...' content: [n=0] 
[16:09:32.046] List of 1
[16:09:32.046]  $ ...: list()
[16:09:32.046]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.046]  - attr(*, "where")=List of 1
[16:09:32.046]   ..$ ...:<environment: 0x5567e8d4bb48> 
[16:09:32.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.046]  - attr(*, "resolved")= logi TRUE
[16:09:32.046]  - attr(*, "total_size")= num NA
[16:09:32.049]  - Getting '...' globals ... DONE
[16:09:32.049] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:09:32.050] List of 4
[16:09:32.050]  $ ...future.FUN:function (x)  
[16:09:32.050]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.050]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.050]  $ ...          : list()
[16:09:32.050]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.050]  - attr(*, "where")=List of 4
[16:09:32.050]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.050]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:09:32.050]   ..$ wool         :<environment: R_EmptyEnv> 
[16:09:32.050]   ..$ ...          :<environment: 0x5567e8d4bb48> 
[16:09:32.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.050]  - attr(*, "resolved")= logi FALSE
[16:09:32.050]  - attr(*, "total_size")= num 2320
[16:09:32.053] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.053] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.053] Number of futures (= number of chunks): 1
[16:09:32.054] Launching 1 futures (chunks) ...
[16:09:32.054] Chunk #1 of 1 ...
[16:09:32.054]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.054] getGlobalsAndPackages() ...
[16:09:32.054] Searching for globals...
[16:09:32.054] 
[16:09:32.055] Searching for globals ... DONE
[16:09:32.055] - globals: [0] <none>
[16:09:32.055] getGlobalsAndPackages() ... DONE
[16:09:32.055]    + additional globals found: [n=0] 
[16:09:32.055]    + additional namespaces needed: [n=0] 
[16:09:32.055]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.055]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.055]  - seeds: <none>
[16:09:32.055] getGlobalsAndPackages() ...
[16:09:32.055] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.055] Resolving globals: FALSE
[16:09:32.056] Tweak future expression to call with '...' arguments ...
[16:09:32.056] {
[16:09:32.056]     do.call(function(...) {
[16:09:32.056]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.056]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.056]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.056]             on.exit(options(oopts), add = TRUE)
[16:09:32.056]         }
[16:09:32.056]         {
[16:09:32.056]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.056]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.056]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.056]             })
[16:09:32.056]         }
[16:09:32.056]     }, args = future.call.arguments)
[16:09:32.056] }
[16:09:32.056] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.056] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.056] 
[16:09:32.057] getGlobalsAndPackages() ... DONE
[16:09:32.057] run() for ‘Future’ ...
[16:09:32.057] - state: ‘created’
[16:09:32.057] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.057] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.057]   - Field: ‘label’
[16:09:32.058]   - Field: ‘local’
[16:09:32.058]   - Field: ‘owner’
[16:09:32.058]   - Field: ‘envir’
[16:09:32.058]   - Field: ‘packages’
[16:09:32.058]   - Field: ‘gc’
[16:09:32.058]   - Field: ‘conditions’
[16:09:32.058]   - Field: ‘expr’
[16:09:32.058]   - Field: ‘uuid’
[16:09:32.058]   - Field: ‘seed’
[16:09:32.058]   - Field: ‘version’
[16:09:32.058]   - Field: ‘result’
[16:09:32.058]   - Field: ‘asynchronous’
[16:09:32.059]   - Field: ‘calls’
[16:09:32.059]   - Field: ‘globals’
[16:09:32.059]   - Field: ‘stdout’
[16:09:32.059]   - Field: ‘earlySignal’
[16:09:32.059]   - Field: ‘lazy’
[16:09:32.059]   - Field: ‘state’
[16:09:32.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.059] - Launch lazy future ...
[16:09:32.059] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.059] Packages needed by future strategies (n = 0): <none>
[16:09:32.060] {
[16:09:32.060]     {
[16:09:32.060]         {
[16:09:32.060]             ...future.startTime <- base::Sys.time()
[16:09:32.060]             {
[16:09:32.060]                 {
[16:09:32.060]                   {
[16:09:32.060]                     {
[16:09:32.060]                       base::local({
[16:09:32.060]                         has_future <- base::requireNamespace("future", 
[16:09:32.060]                           quietly = TRUE)
[16:09:32.060]                         if (has_future) {
[16:09:32.060]                           ns <- base::getNamespace("future")
[16:09:32.060]                           version <- ns[[".package"]][["version"]]
[16:09:32.060]                           if (is.null(version)) 
[16:09:32.060]                             version <- utils::packageVersion("future")
[16:09:32.060]                         }
[16:09:32.060]                         else {
[16:09:32.060]                           version <- NULL
[16:09:32.060]                         }
[16:09:32.060]                         if (!has_future || version < "1.8.0") {
[16:09:32.060]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.060]                             "", base::R.version$version.string), 
[16:09:32.060]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.060]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.060]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.060]                               "release", "version")], collapse = " "), 
[16:09:32.060]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.060]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.060]                             info)
[16:09:32.060]                           info <- base::paste(info, collapse = "; ")
[16:09:32.060]                           if (!has_future) {
[16:09:32.060]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.060]                               info)
[16:09:32.060]                           }
[16:09:32.060]                           else {
[16:09:32.060]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.060]                               info, version)
[16:09:32.060]                           }
[16:09:32.060]                           base::stop(msg)
[16:09:32.060]                         }
[16:09:32.060]                       })
[16:09:32.060]                     }
[16:09:32.060]                     base::local({
[16:09:32.060]                       for (pkg in "stats") {
[16:09:32.060]                         base::loadNamespace(pkg)
[16:09:32.060]                         base::library(pkg, character.only = TRUE)
[16:09:32.060]                       }
[16:09:32.060]                     })
[16:09:32.060]                   }
[16:09:32.060]                   options(future.plan = NULL)
[16:09:32.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.060]                 }
[16:09:32.060]                 ...future.workdir <- getwd()
[16:09:32.060]             }
[16:09:32.060]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.060]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.060]         }
[16:09:32.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.060]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.060]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.060]             base::names(...future.oldOptions))
[16:09:32.060]     }
[16:09:32.060]     if (FALSE) {
[16:09:32.060]     }
[16:09:32.060]     else {
[16:09:32.060]         if (TRUE) {
[16:09:32.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.060]                 open = "w")
[16:09:32.060]         }
[16:09:32.060]         else {
[16:09:32.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.060]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.060]         }
[16:09:32.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.060]             base::sink(type = "output", split = FALSE)
[16:09:32.060]             base::close(...future.stdout)
[16:09:32.060]         }, add = TRUE)
[16:09:32.060]     }
[16:09:32.060]     ...future.frame <- base::sys.nframe()
[16:09:32.060]     ...future.conditions <- base::list()
[16:09:32.060]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.060]     if (FALSE) {
[16:09:32.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.060]     }
[16:09:32.060]     ...future.result <- base::tryCatch({
[16:09:32.060]         base::withCallingHandlers({
[16:09:32.060]             ...future.value <- base::withVisible(base::local({
[16:09:32.060]                 do.call(function(...) {
[16:09:32.060]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.060]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.060]                     ...future.globals.maxSize)) {
[16:09:32.060]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.060]                     on.exit(options(oopts), add = TRUE)
[16:09:32.060]                   }
[16:09:32.060]                   {
[16:09:32.060]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.060]                       FUN = function(jj) {
[16:09:32.060]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.060]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.060]                       })
[16:09:32.060]                   }
[16:09:32.060]                 }, args = future.call.arguments)
[16:09:32.060]             }))
[16:09:32.060]             future::FutureResult(value = ...future.value$value, 
[16:09:32.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.060]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.060]                     ...future.globalenv.names))
[16:09:32.060]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.060]         }, condition = base::local({
[16:09:32.060]             c <- base::c
[16:09:32.060]             inherits <- base::inherits
[16:09:32.060]             invokeRestart <- base::invokeRestart
[16:09:32.060]             length <- base::length
[16:09:32.060]             list <- base::list
[16:09:32.060]             seq.int <- base::seq.int
[16:09:32.060]             signalCondition <- base::signalCondition
[16:09:32.060]             sys.calls <- base::sys.calls
[16:09:32.060]             `[[` <- base::`[[`
[16:09:32.060]             `+` <- base::`+`
[16:09:32.060]             `<<-` <- base::`<<-`
[16:09:32.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.060]                   3L)]
[16:09:32.060]             }
[16:09:32.060]             function(cond) {
[16:09:32.060]                 is_error <- inherits(cond, "error")
[16:09:32.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.060]                   NULL)
[16:09:32.060]                 if (is_error) {
[16:09:32.060]                   sessionInformation <- function() {
[16:09:32.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.060]                       search = base::search(), system = base::Sys.info())
[16:09:32.060]                   }
[16:09:32.060]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.060]                     cond$call), session = sessionInformation(), 
[16:09:32.060]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.060]                   signalCondition(cond)
[16:09:32.060]                 }
[16:09:32.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.060]                 "immediateCondition"))) {
[16:09:32.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.060]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.060]                   if (TRUE && !signal) {
[16:09:32.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.060]                     {
[16:09:32.060]                       inherits <- base::inherits
[16:09:32.060]                       invokeRestart <- base::invokeRestart
[16:09:32.060]                       is.null <- base::is.null
[16:09:32.060]                       muffled <- FALSE
[16:09:32.060]                       if (inherits(cond, "message")) {
[16:09:32.060]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.060]                         if (muffled) 
[16:09:32.060]                           invokeRestart("muffleMessage")
[16:09:32.060]                       }
[16:09:32.060]                       else if (inherits(cond, "warning")) {
[16:09:32.060]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.060]                         if (muffled) 
[16:09:32.060]                           invokeRestart("muffleWarning")
[16:09:32.060]                       }
[16:09:32.060]                       else if (inherits(cond, "condition")) {
[16:09:32.060]                         if (!is.null(pattern)) {
[16:09:32.060]                           computeRestarts <- base::computeRestarts
[16:09:32.060]                           grepl <- base::grepl
[16:09:32.060]                           restarts <- computeRestarts(cond)
[16:09:32.060]                           for (restart in restarts) {
[16:09:32.060]                             name <- restart$name
[16:09:32.060]                             if (is.null(name)) 
[16:09:32.060]                               next
[16:09:32.060]                             if (!grepl(pattern, name)) 
[16:09:32.060]                               next
[16:09:32.060]                             invokeRestart(restart)
[16:09:32.060]                             muffled <- TRUE
[16:09:32.060]                             break
[16:09:32.060]                           }
[16:09:32.060]                         }
[16:09:32.060]                       }
[16:09:32.060]                       invisible(muffled)
[16:09:32.060]                     }
[16:09:32.060]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.060]                   }
[16:09:32.060]                 }
[16:09:32.060]                 else {
[16:09:32.060]                   if (TRUE) {
[16:09:32.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.060]                     {
[16:09:32.060]                       inherits <- base::inherits
[16:09:32.060]                       invokeRestart <- base::invokeRestart
[16:09:32.060]                       is.null <- base::is.null
[16:09:32.060]                       muffled <- FALSE
[16:09:32.060]                       if (inherits(cond, "message")) {
[16:09:32.060]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.060]                         if (muffled) 
[16:09:32.060]                           invokeRestart("muffleMessage")
[16:09:32.060]                       }
[16:09:32.060]                       else if (inherits(cond, "warning")) {
[16:09:32.060]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.060]                         if (muffled) 
[16:09:32.060]                           invokeRestart("muffleWarning")
[16:09:32.060]                       }
[16:09:32.060]                       else if (inherits(cond, "condition")) {
[16:09:32.060]                         if (!is.null(pattern)) {
[16:09:32.060]                           computeRestarts <- base::computeRestarts
[16:09:32.060]                           grepl <- base::grepl
[16:09:32.060]                           restarts <- computeRestarts(cond)
[16:09:32.060]                           for (restart in restarts) {
[16:09:32.060]                             name <- restart$name
[16:09:32.060]                             if (is.null(name)) 
[16:09:32.060]                               next
[16:09:32.060]                             if (!grepl(pattern, name)) 
[16:09:32.060]                               next
[16:09:32.060]                             invokeRestart(restart)
[16:09:32.060]                             muffled <- TRUE
[16:09:32.060]                             break
[16:09:32.060]                           }
[16:09:32.060]                         }
[16:09:32.060]                       }
[16:09:32.060]                       invisible(muffled)
[16:09:32.060]                     }
[16:09:32.060]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.060]                   }
[16:09:32.060]                 }
[16:09:32.060]             }
[16:09:32.060]         }))
[16:09:32.060]     }, error = function(ex) {
[16:09:32.060]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.060]                 ...future.rng), started = ...future.startTime, 
[16:09:32.060]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.060]             version = "1.8"), class = "FutureResult")
[16:09:32.060]     }, finally = {
[16:09:32.060]         if (!identical(...future.workdir, getwd())) 
[16:09:32.060]             setwd(...future.workdir)
[16:09:32.060]         {
[16:09:32.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.060]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.060]             }
[16:09:32.060]             base::options(...future.oldOptions)
[16:09:32.060]             if (.Platform$OS.type == "windows") {
[16:09:32.060]                 old_names <- names(...future.oldEnvVars)
[16:09:32.060]                 envs <- base::Sys.getenv()
[16:09:32.060]                 names <- names(envs)
[16:09:32.060]                 common <- intersect(names, old_names)
[16:09:32.060]                 added <- setdiff(names, old_names)
[16:09:32.060]                 removed <- setdiff(old_names, names)
[16:09:32.060]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.060]                   envs[common]]
[16:09:32.060]                 NAMES <- toupper(changed)
[16:09:32.060]                 args <- list()
[16:09:32.060]                 for (kk in seq_along(NAMES)) {
[16:09:32.060]                   name <- changed[[kk]]
[16:09:32.060]                   NAME <- NAMES[[kk]]
[16:09:32.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.060]                     next
[16:09:32.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.060]                 }
[16:09:32.060]                 NAMES <- toupper(added)
[16:09:32.060]                 for (kk in seq_along(NAMES)) {
[16:09:32.060]                   name <- added[[kk]]
[16:09:32.060]                   NAME <- NAMES[[kk]]
[16:09:32.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.060]                     next
[16:09:32.060]                   args[[name]] <- ""
[16:09:32.060]                 }
[16:09:32.060]                 NAMES <- toupper(removed)
[16:09:32.060]                 for (kk in seq_along(NAMES)) {
[16:09:32.060]                   name <- removed[[kk]]
[16:09:32.060]                   NAME <- NAMES[[kk]]
[16:09:32.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.060]                     next
[16:09:32.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.060]                 }
[16:09:32.060]                 if (length(args) > 0) 
[16:09:32.060]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.060]             }
[16:09:32.060]             else {
[16:09:32.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.060]             }
[16:09:32.060]             {
[16:09:32.060]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.060]                   0L) {
[16:09:32.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.060]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.060]                   base::options(opts)
[16:09:32.060]                 }
[16:09:32.060]                 {
[16:09:32.060]                   {
[16:09:32.060]                     NULL
[16:09:32.060]                     RNGkind("Mersenne-Twister")
[16:09:32.060]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.060]                       inherits = FALSE)
[16:09:32.060]                   }
[16:09:32.060]                   options(future.plan = NULL)
[16:09:32.060]                   if (is.na(NA_character_)) 
[16:09:32.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.060]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.060]                   {
[16:09:32.060]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.060]                     if (!future$lazy) 
[16:09:32.060]                       future <- run(future)
[16:09:32.060]                     invisible(future)
[16:09:32.060]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.060]                 }
[16:09:32.060]             }
[16:09:32.060]         }
[16:09:32.060]     })
[16:09:32.060]     if (TRUE) {
[16:09:32.060]         base::sink(type = "output", split = FALSE)
[16:09:32.060]         if (TRUE) {
[16:09:32.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.060]         }
[16:09:32.060]         else {
[16:09:32.060]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.060]         }
[16:09:32.060]         base::close(...future.stdout)
[16:09:32.060]         ...future.stdout <- NULL
[16:09:32.060]     }
[16:09:32.060]     ...future.result$conditions <- ...future.conditions
[16:09:32.060]     ...future.result$finished <- base::Sys.time()
[16:09:32.060]     ...future.result
[16:09:32.060] }
[16:09:32.062] assign_globals() ...
[16:09:32.062] List of 7
[16:09:32.062]  $ ...future.FUN            :function (x)  
[16:09:32.062]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.062]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.062]  $ future.call.arguments    : list()
[16:09:32.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.062]  $ ...future.elements_ii    :List of 3
[16:09:32.062]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.062]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.062]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.062]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.062]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.062]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.062]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.062]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.062]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.062]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.062]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.062]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.062]  $ ...future.seeds_ii       : NULL
[16:09:32.062]  $ ...future.globals.maxSize: NULL
[16:09:32.062]  - attr(*, "resolved")= logi FALSE
[16:09:32.062]  - attr(*, "total_size")= num 2320
[16:09:32.062]  - attr(*, "where")=List of 7
[16:09:32.062]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.062]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:09:32.062]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:09:32.062]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.062]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.062]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.062]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.062]  - attr(*, "already-done")= logi TRUE
[16:09:32.072] - reassign environment for ‘...future.FUN’
[16:09:32.072] - copied ‘...future.FUN’ to environment
[16:09:32.072] - copied ‘breaks’ to environment
[16:09:32.072] - copied ‘wool’ to environment
[16:09:32.072] - copied ‘future.call.arguments’ to environment
[16:09:32.072] - copied ‘...future.elements_ii’ to environment
[16:09:32.072] - copied ‘...future.seeds_ii’ to environment
[16:09:32.072] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.072] assign_globals() ... done
[16:09:32.073] plan(): Setting new future strategy stack:
[16:09:32.073] List of future strategies:
[16:09:32.073] 1. sequential:
[16:09:32.073]    - args: function (..., envir = parent.frame())
[16:09:32.073]    - tweaked: FALSE
[16:09:32.073]    - call: NULL
[16:09:32.073] plan(): nbrOfWorkers() = 1
[16:09:32.076] plan(): Setting new future strategy stack:
[16:09:32.076] List of future strategies:
[16:09:32.076] 1. sequential:
[16:09:32.076]    - args: function (..., envir = parent.frame())
[16:09:32.076]    - tweaked: FALSE
[16:09:32.076]    - call: plan(strategy)
[16:09:32.076] plan(): nbrOfWorkers() = 1
[16:09:32.076] SequentialFuture started (and completed)
[16:09:32.077] - Launch lazy future ... done
[16:09:32.077] run() for ‘SequentialFuture’ ... done
[16:09:32.077] Created future:
[16:09:32.077] SequentialFuture:
[16:09:32.077] Label: ‘future_by-1’
[16:09:32.077] Expression:
[16:09:32.077] {
[16:09:32.077]     do.call(function(...) {
[16:09:32.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.077]             on.exit(options(oopts), add = TRUE)
[16:09:32.077]         }
[16:09:32.077]         {
[16:09:32.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.077]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.077]             })
[16:09:32.077]         }
[16:09:32.077]     }, args = future.call.arguments)
[16:09:32.077] }
[16:09:32.077] Lazy evaluation: FALSE
[16:09:32.077] Asynchronous evaluation: FALSE
[16:09:32.077] Local evaluation: TRUE
[16:09:32.077] Environment: 0x5567e8ced478
[16:09:32.077] Capture standard output: TRUE
[16:09:32.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.077] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:09:32.077] Packages: 1 packages (‘stats’)
[16:09:32.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.077] Resolved: TRUE
[16:09:32.077] Value: 25.57 KiB of class ‘list’
[16:09:32.077] Early signaling: FALSE
[16:09:32.077] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.077] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.078] Chunk #1 of 1 ... DONE
[16:09:32.078] Launching 1 futures (chunks) ... DONE
[16:09:32.078] Resolving 1 futures (chunks) ...
[16:09:32.079] resolve() on list ...
[16:09:32.079]  recursive: 0
[16:09:32.079]  length: 1
[16:09:32.079] 
[16:09:32.079] resolved() for ‘SequentialFuture’ ...
[16:09:32.079] - state: ‘finished’
[16:09:32.079] - run: TRUE
[16:09:32.079] - result: ‘FutureResult’
[16:09:32.079] resolved() for ‘SequentialFuture’ ... done
[16:09:32.079] Future #1
[16:09:32.079] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.080] - nx: 1
[16:09:32.080] - relay: TRUE
[16:09:32.080] - stdout: TRUE
[16:09:32.080] - signal: TRUE
[16:09:32.080] - resignal: FALSE
[16:09:32.080] - force: TRUE
[16:09:32.080] - relayed: [n=1] FALSE
[16:09:32.080] - queued futures: [n=1] FALSE
[16:09:32.080]  - until=1
[16:09:32.080]  - relaying element #1
[16:09:32.080] - relayed: [n=1] TRUE
[16:09:32.081] - queued futures: [n=1] TRUE
[16:09:32.081] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.081]  length: 0 (resolved future 1)
[16:09:32.081] Relaying remaining futures
[16:09:32.081] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.081] - nx: 1
[16:09:32.081] - relay: TRUE
[16:09:32.081] - stdout: TRUE
[16:09:32.081] - signal: TRUE
[16:09:32.081] - resignal: FALSE
[16:09:32.081] - force: TRUE
[16:09:32.081] - relayed: [n=1] TRUE
[16:09:32.082] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.082] - relayed: [n=1] TRUE
[16:09:32.082] - queued futures: [n=1] TRUE
[16:09:32.082] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.082] resolve() on list ... DONE
[16:09:32.082]  - Number of value chunks collected: 1
[16:09:32.082] Resolving 1 futures (chunks) ... DONE
[16:09:32.082] Reducing values from 1 chunks ...
[16:09:32.082]  - Number of values collected after concatenation: 3
[16:09:32.082]  - Number of values expected: 3
[16:09:32.082] Reducing values from 1 chunks ... DONE
[16:09:32.083] future_lapply() ... DONE
[16:09:32.083] future_by_internal() ... DONE
[16:09:32.083] future_by_internal() ...
[16:09:32.083] future_lapply() ...
[16:09:32.084] Number of chunks: 1
[16:09:32.084] getGlobalsAndPackagesXApply() ...
[16:09:32.084]  - future.globals: TRUE
[16:09:32.084] getGlobalsAndPackages() ...
[16:09:32.084] Searching for globals...
[16:09:32.085] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.085] Searching for globals ... DONE
[16:09:32.085] Resolving globals: FALSE
[16:09:32.086] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.086] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.086] - globals: [1] ‘FUN’
[16:09:32.086] 
[16:09:32.086] getGlobalsAndPackages() ... DONE
[16:09:32.086]  - globals found/used: [n=1] ‘FUN’
[16:09:32.087]  - needed namespaces: [n=0] 
[16:09:32.087] Finding globals ... DONE
[16:09:32.087]  - use_args: TRUE
[16:09:32.088]  - Getting '...' globals ...
[16:09:32.088] resolve() on list ...
[16:09:32.088]  recursive: 0
[16:09:32.088]  length: 1
[16:09:32.088]  elements: ‘...’
[16:09:32.088]  length: 0 (resolved future 1)
[16:09:32.088] resolve() on list ... DONE
[16:09:32.088]    - '...' content: [n=0] 
[16:09:32.088] List of 1
[16:09:32.088]  $ ...: list()
[16:09:32.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.088]  - attr(*, "where")=List of 1
[16:09:32.088]   ..$ ...:<environment: 0x5567e9323430> 
[16:09:32.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.088]  - attr(*, "resolved")= logi TRUE
[16:09:32.088]  - attr(*, "total_size")= num NA
[16:09:32.091]  - Getting '...' globals ... DONE
[16:09:32.091] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.091] List of 2
[16:09:32.091]  $ ...future.FUN:function (object, ...)  
[16:09:32.091]  $ ...          : list()
[16:09:32.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.091]  - attr(*, "where")=List of 2
[16:09:32.091]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.091]   ..$ ...          :<environment: 0x5567e9323430> 
[16:09:32.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.091]  - attr(*, "resolved")= logi FALSE
[16:09:32.091]  - attr(*, "total_size")= num 1240
[16:09:32.093] Packages to be attached in all futures: [n=0] 
[16:09:32.094] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.094] Number of futures (= number of chunks): 1
[16:09:32.094] Launching 1 futures (chunks) ...
[16:09:32.094] Chunk #1 of 1 ...
[16:09:32.094]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.094] getGlobalsAndPackages() ...
[16:09:32.094] Searching for globals...
[16:09:32.095] 
[16:09:32.095] Searching for globals ... DONE
[16:09:32.095] - globals: [0] <none>
[16:09:32.095] getGlobalsAndPackages() ... DONE
[16:09:32.095]    + additional globals found: [n=0] 
[16:09:32.095]    + additional namespaces needed: [n=0] 
[16:09:32.095]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.095]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.095]  - seeds: <none>
[16:09:32.096] getGlobalsAndPackages() ...
[16:09:32.096] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.096] Resolving globals: FALSE
[16:09:32.096] Tweak future expression to call with '...' arguments ...
[16:09:32.096] {
[16:09:32.096]     do.call(function(...) {
[16:09:32.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.096]             on.exit(options(oopts), add = TRUE)
[16:09:32.096]         }
[16:09:32.096]         {
[16:09:32.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.096]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.096]             })
[16:09:32.096]         }
[16:09:32.096]     }, args = future.call.arguments)
[16:09:32.096] }
[16:09:32.096] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.096] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.097] 
[16:09:32.097] getGlobalsAndPackages() ... DONE
[16:09:32.097] run() for ‘Future’ ...
[16:09:32.097] - state: ‘created’
[16:09:32.097] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.097] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.098]   - Field: ‘label’
[16:09:32.098]   - Field: ‘local’
[16:09:32.098]   - Field: ‘owner’
[16:09:32.098]   - Field: ‘envir’
[16:09:32.098]   - Field: ‘packages’
[16:09:32.098]   - Field: ‘gc’
[16:09:32.098]   - Field: ‘conditions’
[16:09:32.098]   - Field: ‘expr’
[16:09:32.098]   - Field: ‘uuid’
[16:09:32.098]   - Field: ‘seed’
[16:09:32.098]   - Field: ‘version’
[16:09:32.099]   - Field: ‘result’
[16:09:32.099]   - Field: ‘asynchronous’
[16:09:32.099]   - Field: ‘calls’
[16:09:32.099]   - Field: ‘globals’
[16:09:32.099]   - Field: ‘stdout’
[16:09:32.099]   - Field: ‘earlySignal’
[16:09:32.099]   - Field: ‘lazy’
[16:09:32.099]   - Field: ‘state’
[16:09:32.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.099] - Launch lazy future ...
[16:09:32.100] Packages needed by the future expression (n = 0): <none>
[16:09:32.100] Packages needed by future strategies (n = 0): <none>
[16:09:32.100] {
[16:09:32.100]     {
[16:09:32.100]         {
[16:09:32.100]             ...future.startTime <- base::Sys.time()
[16:09:32.100]             {
[16:09:32.100]                 {
[16:09:32.100]                   {
[16:09:32.100]                     base::local({
[16:09:32.100]                       has_future <- base::requireNamespace("future", 
[16:09:32.100]                         quietly = TRUE)
[16:09:32.100]                       if (has_future) {
[16:09:32.100]                         ns <- base::getNamespace("future")
[16:09:32.100]                         version <- ns[[".package"]][["version"]]
[16:09:32.100]                         if (is.null(version)) 
[16:09:32.100]                           version <- utils::packageVersion("future")
[16:09:32.100]                       }
[16:09:32.100]                       else {
[16:09:32.100]                         version <- NULL
[16:09:32.100]                       }
[16:09:32.100]                       if (!has_future || version < "1.8.0") {
[16:09:32.100]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.100]                           "", base::R.version$version.string), 
[16:09:32.100]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.100]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.100]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.100]                             "release", "version")], collapse = " "), 
[16:09:32.100]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.100]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.100]                           info)
[16:09:32.100]                         info <- base::paste(info, collapse = "; ")
[16:09:32.100]                         if (!has_future) {
[16:09:32.100]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.100]                             info)
[16:09:32.100]                         }
[16:09:32.100]                         else {
[16:09:32.100]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.100]                             info, version)
[16:09:32.100]                         }
[16:09:32.100]                         base::stop(msg)
[16:09:32.100]                       }
[16:09:32.100]                     })
[16:09:32.100]                   }
[16:09:32.100]                   options(future.plan = NULL)
[16:09:32.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.100]                 }
[16:09:32.100]                 ...future.workdir <- getwd()
[16:09:32.100]             }
[16:09:32.100]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.100]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.100]         }
[16:09:32.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.100]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.100]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.100]             base::names(...future.oldOptions))
[16:09:32.100]     }
[16:09:32.100]     if (FALSE) {
[16:09:32.100]     }
[16:09:32.100]     else {
[16:09:32.100]         if (TRUE) {
[16:09:32.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.100]                 open = "w")
[16:09:32.100]         }
[16:09:32.100]         else {
[16:09:32.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.100]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.100]         }
[16:09:32.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.100]             base::sink(type = "output", split = FALSE)
[16:09:32.100]             base::close(...future.stdout)
[16:09:32.100]         }, add = TRUE)
[16:09:32.100]     }
[16:09:32.100]     ...future.frame <- base::sys.nframe()
[16:09:32.100]     ...future.conditions <- base::list()
[16:09:32.100]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.100]     if (FALSE) {
[16:09:32.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.100]     }
[16:09:32.100]     ...future.result <- base::tryCatch({
[16:09:32.100]         base::withCallingHandlers({
[16:09:32.100]             ...future.value <- base::withVisible(base::local({
[16:09:32.100]                 do.call(function(...) {
[16:09:32.100]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.100]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.100]                     ...future.globals.maxSize)) {
[16:09:32.100]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.100]                     on.exit(options(oopts), add = TRUE)
[16:09:32.100]                   }
[16:09:32.100]                   {
[16:09:32.100]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.100]                       FUN = function(jj) {
[16:09:32.100]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.100]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.100]                       })
[16:09:32.100]                   }
[16:09:32.100]                 }, args = future.call.arguments)
[16:09:32.100]             }))
[16:09:32.100]             future::FutureResult(value = ...future.value$value, 
[16:09:32.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.100]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.100]                     ...future.globalenv.names))
[16:09:32.100]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.100]         }, condition = base::local({
[16:09:32.100]             c <- base::c
[16:09:32.100]             inherits <- base::inherits
[16:09:32.100]             invokeRestart <- base::invokeRestart
[16:09:32.100]             length <- base::length
[16:09:32.100]             list <- base::list
[16:09:32.100]             seq.int <- base::seq.int
[16:09:32.100]             signalCondition <- base::signalCondition
[16:09:32.100]             sys.calls <- base::sys.calls
[16:09:32.100]             `[[` <- base::`[[`
[16:09:32.100]             `+` <- base::`+`
[16:09:32.100]             `<<-` <- base::`<<-`
[16:09:32.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.100]                   3L)]
[16:09:32.100]             }
[16:09:32.100]             function(cond) {
[16:09:32.100]                 is_error <- inherits(cond, "error")
[16:09:32.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.100]                   NULL)
[16:09:32.100]                 if (is_error) {
[16:09:32.100]                   sessionInformation <- function() {
[16:09:32.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.100]                       search = base::search(), system = base::Sys.info())
[16:09:32.100]                   }
[16:09:32.100]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.100]                     cond$call), session = sessionInformation(), 
[16:09:32.100]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.100]                   signalCondition(cond)
[16:09:32.100]                 }
[16:09:32.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.100]                 "immediateCondition"))) {
[16:09:32.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.100]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.100]                   if (TRUE && !signal) {
[16:09:32.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.100]                     {
[16:09:32.100]                       inherits <- base::inherits
[16:09:32.100]                       invokeRestart <- base::invokeRestart
[16:09:32.100]                       is.null <- base::is.null
[16:09:32.100]                       muffled <- FALSE
[16:09:32.100]                       if (inherits(cond, "message")) {
[16:09:32.100]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.100]                         if (muffled) 
[16:09:32.100]                           invokeRestart("muffleMessage")
[16:09:32.100]                       }
[16:09:32.100]                       else if (inherits(cond, "warning")) {
[16:09:32.100]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.100]                         if (muffled) 
[16:09:32.100]                           invokeRestart("muffleWarning")
[16:09:32.100]                       }
[16:09:32.100]                       else if (inherits(cond, "condition")) {
[16:09:32.100]                         if (!is.null(pattern)) {
[16:09:32.100]                           computeRestarts <- base::computeRestarts
[16:09:32.100]                           grepl <- base::grepl
[16:09:32.100]                           restarts <- computeRestarts(cond)
[16:09:32.100]                           for (restart in restarts) {
[16:09:32.100]                             name <- restart$name
[16:09:32.100]                             if (is.null(name)) 
[16:09:32.100]                               next
[16:09:32.100]                             if (!grepl(pattern, name)) 
[16:09:32.100]                               next
[16:09:32.100]                             invokeRestart(restart)
[16:09:32.100]                             muffled <- TRUE
[16:09:32.100]                             break
[16:09:32.100]                           }
[16:09:32.100]                         }
[16:09:32.100]                       }
[16:09:32.100]                       invisible(muffled)
[16:09:32.100]                     }
[16:09:32.100]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.100]                   }
[16:09:32.100]                 }
[16:09:32.100]                 else {
[16:09:32.100]                   if (TRUE) {
[16:09:32.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.100]                     {
[16:09:32.100]                       inherits <- base::inherits
[16:09:32.100]                       invokeRestart <- base::invokeRestart
[16:09:32.100]                       is.null <- base::is.null
[16:09:32.100]                       muffled <- FALSE
[16:09:32.100]                       if (inherits(cond, "message")) {
[16:09:32.100]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.100]                         if (muffled) 
[16:09:32.100]                           invokeRestart("muffleMessage")
[16:09:32.100]                       }
[16:09:32.100]                       else if (inherits(cond, "warning")) {
[16:09:32.100]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.100]                         if (muffled) 
[16:09:32.100]                           invokeRestart("muffleWarning")
[16:09:32.100]                       }
[16:09:32.100]                       else if (inherits(cond, "condition")) {
[16:09:32.100]                         if (!is.null(pattern)) {
[16:09:32.100]                           computeRestarts <- base::computeRestarts
[16:09:32.100]                           grepl <- base::grepl
[16:09:32.100]                           restarts <- computeRestarts(cond)
[16:09:32.100]                           for (restart in restarts) {
[16:09:32.100]                             name <- restart$name
[16:09:32.100]                             if (is.null(name)) 
[16:09:32.100]                               next
[16:09:32.100]                             if (!grepl(pattern, name)) 
[16:09:32.100]                               next
[16:09:32.100]                             invokeRestart(restart)
[16:09:32.100]                             muffled <- TRUE
[16:09:32.100]                             break
[16:09:32.100]                           }
[16:09:32.100]                         }
[16:09:32.100]                       }
[16:09:32.100]                       invisible(muffled)
[16:09:32.100]                     }
[16:09:32.100]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.100]                   }
[16:09:32.100]                 }
[16:09:32.100]             }
[16:09:32.100]         }))
[16:09:32.100]     }, error = function(ex) {
[16:09:32.100]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.100]                 ...future.rng), started = ...future.startTime, 
[16:09:32.100]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.100]             version = "1.8"), class = "FutureResult")
[16:09:32.100]     }, finally = {
[16:09:32.100]         if (!identical(...future.workdir, getwd())) 
[16:09:32.100]             setwd(...future.workdir)
[16:09:32.100]         {
[16:09:32.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.100]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.100]             }
[16:09:32.100]             base::options(...future.oldOptions)
[16:09:32.100]             if (.Platform$OS.type == "windows") {
[16:09:32.100]                 old_names <- names(...future.oldEnvVars)
[16:09:32.100]                 envs <- base::Sys.getenv()
[16:09:32.100]                 names <- names(envs)
[16:09:32.100]                 common <- intersect(names, old_names)
[16:09:32.100]                 added <- setdiff(names, old_names)
[16:09:32.100]                 removed <- setdiff(old_names, names)
[16:09:32.100]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.100]                   envs[common]]
[16:09:32.100]                 NAMES <- toupper(changed)
[16:09:32.100]                 args <- list()
[16:09:32.100]                 for (kk in seq_along(NAMES)) {
[16:09:32.100]                   name <- changed[[kk]]
[16:09:32.100]                   NAME <- NAMES[[kk]]
[16:09:32.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.100]                     next
[16:09:32.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.100]                 }
[16:09:32.100]                 NAMES <- toupper(added)
[16:09:32.100]                 for (kk in seq_along(NAMES)) {
[16:09:32.100]                   name <- added[[kk]]
[16:09:32.100]                   NAME <- NAMES[[kk]]
[16:09:32.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.100]                     next
[16:09:32.100]                   args[[name]] <- ""
[16:09:32.100]                 }
[16:09:32.100]                 NAMES <- toupper(removed)
[16:09:32.100]                 for (kk in seq_along(NAMES)) {
[16:09:32.100]                   name <- removed[[kk]]
[16:09:32.100]                   NAME <- NAMES[[kk]]
[16:09:32.100]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.100]                     next
[16:09:32.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.100]                 }
[16:09:32.100]                 if (length(args) > 0) 
[16:09:32.100]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.100]             }
[16:09:32.100]             else {
[16:09:32.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.100]             }
[16:09:32.100]             {
[16:09:32.100]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.100]                   0L) {
[16:09:32.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.100]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.100]                   base::options(opts)
[16:09:32.100]                 }
[16:09:32.100]                 {
[16:09:32.100]                   {
[16:09:32.100]                     NULL
[16:09:32.100]                     RNGkind("Mersenne-Twister")
[16:09:32.100]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.100]                       inherits = FALSE)
[16:09:32.100]                   }
[16:09:32.100]                   options(future.plan = NULL)
[16:09:32.100]                   if (is.na(NA_character_)) 
[16:09:32.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.100]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.100]                   {
[16:09:32.100]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.100]                     if (!future$lazy) 
[16:09:32.100]                       future <- run(future)
[16:09:32.100]                     invisible(future)
[16:09:32.100]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.100]                 }
[16:09:32.100]             }
[16:09:32.100]         }
[16:09:32.100]     })
[16:09:32.100]     if (TRUE) {
[16:09:32.100]         base::sink(type = "output", split = FALSE)
[16:09:32.100]         if (TRUE) {
[16:09:32.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.100]         }
[16:09:32.100]         else {
[16:09:32.100]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.100]         }
[16:09:32.100]         base::close(...future.stdout)
[16:09:32.100]         ...future.stdout <- NULL
[16:09:32.100]     }
[16:09:32.100]     ...future.result$conditions <- ...future.conditions
[16:09:32.100]     ...future.result$finished <- base::Sys.time()
[16:09:32.100]     ...future.result
[16:09:32.100] }
[16:09:32.102] assign_globals() ...
[16:09:32.102] List of 5
[16:09:32.102]  $ ...future.FUN            :function (object, ...)  
[16:09:32.102]  $ future.call.arguments    : list()
[16:09:32.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.102]  $ ...future.elements_ii    :List of 3
[16:09:32.102]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.102]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.102]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.102]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.102]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.102]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.102]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.102]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.102]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.102]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.102]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.102]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.102]  $ ...future.seeds_ii       : NULL
[16:09:32.102]  $ ...future.globals.maxSize: NULL
[16:09:32.102]  - attr(*, "resolved")= logi FALSE
[16:09:32.102]  - attr(*, "total_size")= num 1240
[16:09:32.102]  - attr(*, "where")=List of 5
[16:09:32.102]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.102]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.102]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.102]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.102]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.102]  - attr(*, "already-done")= logi TRUE
[16:09:32.111] - copied ‘...future.FUN’ to environment
[16:09:32.111] - copied ‘future.call.arguments’ to environment
[16:09:32.111] - copied ‘...future.elements_ii’ to environment
[16:09:32.111] - copied ‘...future.seeds_ii’ to environment
[16:09:32.111] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.111] assign_globals() ... done
[16:09:32.111] plan(): Setting new future strategy stack:
[16:09:32.111] List of future strategies:
[16:09:32.111] 1. sequential:
[16:09:32.111]    - args: function (..., envir = parent.frame())
[16:09:32.111]    - tweaked: FALSE
[16:09:32.111]    - call: NULL
[16:09:32.112] plan(): nbrOfWorkers() = 1
[16:09:32.114] plan(): Setting new future strategy stack:
[16:09:32.114] List of future strategies:
[16:09:32.114] 1. sequential:
[16:09:32.114]    - args: function (..., envir = parent.frame())
[16:09:32.114]    - tweaked: FALSE
[16:09:32.114]    - call: plan(strategy)
[16:09:32.114] plan(): nbrOfWorkers() = 1
[16:09:32.114] SequentialFuture started (and completed)
[16:09:32.115] - Launch lazy future ... done
[16:09:32.115] run() for ‘SequentialFuture’ ... done
[16:09:32.115] Created future:
[16:09:32.115] SequentialFuture:
[16:09:32.115] Label: ‘future_by-1’
[16:09:32.115] Expression:
[16:09:32.115] {
[16:09:32.115]     do.call(function(...) {
[16:09:32.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.115]             on.exit(options(oopts), add = TRUE)
[16:09:32.115]         }
[16:09:32.115]         {
[16:09:32.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.115]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.115]             })
[16:09:32.115]         }
[16:09:32.115]     }, args = future.call.arguments)
[16:09:32.115] }
[16:09:32.115] Lazy evaluation: FALSE
[16:09:32.115] Asynchronous evaluation: FALSE
[16:09:32.115] Local evaluation: TRUE
[16:09:32.115] Environment: 0x5567e92c4258
[16:09:32.115] Capture standard output: TRUE
[16:09:32.115] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.115] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.115] Packages: <none>
[16:09:32.115] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.115] Resolved: TRUE
[16:09:32.115] Value: 5.37 KiB of class ‘list’
[16:09:32.115] Early signaling: FALSE
[16:09:32.115] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.115] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.116] Chunk #1 of 1 ... DONE
[16:09:32.116] Launching 1 futures (chunks) ... DONE
[16:09:32.116] Resolving 1 futures (chunks) ...
[16:09:32.116] resolve() on list ...
[16:09:32.116]  recursive: 0
[16:09:32.116]  length: 1
[16:09:32.117] 
[16:09:32.117] resolved() for ‘SequentialFuture’ ...
[16:09:32.117] - state: ‘finished’
[16:09:32.117] - run: TRUE
[16:09:32.117] - result: ‘FutureResult’
[16:09:32.117] resolved() for ‘SequentialFuture’ ... done
[16:09:32.117] Future #1
[16:09:32.117] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.117] - nx: 1
[16:09:32.117] - relay: TRUE
[16:09:32.117] - stdout: TRUE
[16:09:32.118] - signal: TRUE
[16:09:32.118] - resignal: FALSE
[16:09:32.118] - force: TRUE
[16:09:32.118] - relayed: [n=1] FALSE
[16:09:32.118] - queued futures: [n=1] FALSE
[16:09:32.118]  - until=1
[16:09:32.118]  - relaying element #1
[16:09:32.118] - relayed: [n=1] TRUE
[16:09:32.118] - queued futures: [n=1] TRUE
[16:09:32.118] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.118]  length: 0 (resolved future 1)
[16:09:32.119] Relaying remaining futures
[16:09:32.119] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.119] - nx: 1
[16:09:32.119] - relay: TRUE
[16:09:32.119] - stdout: TRUE
[16:09:32.119] - signal: TRUE
[16:09:32.119] - resignal: FALSE
[16:09:32.119] - force: TRUE
[16:09:32.119] - relayed: [n=1] TRUE
[16:09:32.119] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.119] - relayed: [n=1] TRUE
[16:09:32.119] - queued futures: [n=1] TRUE
[16:09:32.120] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.120] resolve() on list ... DONE
[16:09:32.120]  - Number of value chunks collected: 1
[16:09:32.120] Resolving 1 futures (chunks) ... DONE
[16:09:32.120] Reducing values from 1 chunks ...
[16:09:32.120]  - Number of values collected after concatenation: 3
[16:09:32.120]  - Number of values expected: 3
[16:09:32.120] Reducing values from 1 chunks ... DONE
[16:09:32.120] future_lapply() ... DONE
[16:09:32.120] future_by_internal() ... DONE
[16:09:32.122] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:09:32.123] future_lapply() ...
[16:09:32.123] Number of chunks: 1
[16:09:32.123] getGlobalsAndPackagesXApply() ...
[16:09:32.123]  - future.globals: TRUE
[16:09:32.124] getGlobalsAndPackages() ...
[16:09:32.124] Searching for globals...
[16:09:32.126] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.126] Searching for globals ... DONE
[16:09:32.126] Resolving globals: FALSE
[16:09:32.126] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.126] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.127] - globals: [1] ‘FUN’
[16:09:32.127] 
[16:09:32.127] getGlobalsAndPackages() ... DONE
[16:09:32.127]  - globals found/used: [n=1] ‘FUN’
[16:09:32.127]  - needed namespaces: [n=0] 
[16:09:32.127] Finding globals ... DONE
[16:09:32.127]  - use_args: TRUE
[16:09:32.127]  - Getting '...' globals ...
[16:09:32.127] resolve() on list ...
[16:09:32.128]  recursive: 0
[16:09:32.128]  length: 1
[16:09:32.128]  elements: ‘...’
[16:09:32.128]  length: 0 (resolved future 1)
[16:09:32.128] resolve() on list ... DONE
[16:09:32.128]    - '...' content: [n=0] 
[16:09:32.128] List of 1
[16:09:32.128]  $ ...: list()
[16:09:32.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.128]  - attr(*, "where")=List of 1
[16:09:32.128]   ..$ ...:<environment: 0x5567e9419720> 
[16:09:32.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.128]  - attr(*, "resolved")= logi TRUE
[16:09:32.128]  - attr(*, "total_size")= num NA
[16:09:32.130]  - Getting '...' globals ... DONE
[16:09:32.131] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.131] List of 2
[16:09:32.131]  $ ...future.FUN:function (object, ...)  
[16:09:32.131]  $ ...          : list()
[16:09:32.131]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.131]  - attr(*, "where")=List of 2
[16:09:32.131]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.131]   ..$ ...          :<environment: 0x5567e9419720> 
[16:09:32.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.131]  - attr(*, "resolved")= logi FALSE
[16:09:32.131]  - attr(*, "total_size")= num 1240
[16:09:32.133] Packages to be attached in all futures: [n=0] 
[16:09:32.133] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.134] Number of futures (= number of chunks): 1
[16:09:32.134] Launching 1 futures (chunks) ...
[16:09:32.134] Chunk #1 of 1 ...
[16:09:32.134]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.134] getGlobalsAndPackages() ...
[16:09:32.134] Searching for globals...
[16:09:32.134] 
[16:09:32.135] Searching for globals ... DONE
[16:09:32.135] - globals: [0] <none>
[16:09:32.135] getGlobalsAndPackages() ... DONE
[16:09:32.135]    + additional globals found: [n=0] 
[16:09:32.135]    + additional namespaces needed: [n=0] 
[16:09:32.135]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.135]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.135]  - seeds: <none>
[16:09:32.135] getGlobalsAndPackages() ...
[16:09:32.135] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.136] Resolving globals: FALSE
[16:09:32.136] Tweak future expression to call with '...' arguments ...
[16:09:32.136] {
[16:09:32.136]     do.call(function(...) {
[16:09:32.136]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.136]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.136]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.136]             on.exit(options(oopts), add = TRUE)
[16:09:32.136]         }
[16:09:32.136]         {
[16:09:32.136]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.136]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.136]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.136]             })
[16:09:32.136]         }
[16:09:32.136]     }, args = future.call.arguments)
[16:09:32.136] }
[16:09:32.136] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.136] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.136] 
[16:09:32.137] getGlobalsAndPackages() ... DONE
[16:09:32.137] run() for ‘Future’ ...
[16:09:32.137] - state: ‘created’
[16:09:32.137] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.138]   - Field: ‘label’
[16:09:32.138]   - Field: ‘local’
[16:09:32.138]   - Field: ‘owner’
[16:09:32.138]   - Field: ‘envir’
[16:09:32.138]   - Field: ‘packages’
[16:09:32.138]   - Field: ‘gc’
[16:09:32.138]   - Field: ‘conditions’
[16:09:32.138]   - Field: ‘expr’
[16:09:32.138]   - Field: ‘uuid’
[16:09:32.138]   - Field: ‘seed’
[16:09:32.138]   - Field: ‘version’
[16:09:32.139]   - Field: ‘result’
[16:09:32.139]   - Field: ‘asynchronous’
[16:09:32.139]   - Field: ‘calls’
[16:09:32.139]   - Field: ‘globals’
[16:09:32.139]   - Field: ‘stdout’
[16:09:32.139]   - Field: ‘earlySignal’
[16:09:32.139]   - Field: ‘lazy’
[16:09:32.139]   - Field: ‘state’
[16:09:32.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.139] - Launch lazy future ...
[16:09:32.139] Packages needed by the future expression (n = 0): <none>
[16:09:32.140] Packages needed by future strategies (n = 0): <none>
[16:09:32.140] {
[16:09:32.140]     {
[16:09:32.140]         {
[16:09:32.140]             ...future.startTime <- base::Sys.time()
[16:09:32.140]             {
[16:09:32.140]                 {
[16:09:32.140]                   {
[16:09:32.140]                     base::local({
[16:09:32.140]                       has_future <- base::requireNamespace("future", 
[16:09:32.140]                         quietly = TRUE)
[16:09:32.140]                       if (has_future) {
[16:09:32.140]                         ns <- base::getNamespace("future")
[16:09:32.140]                         version <- ns[[".package"]][["version"]]
[16:09:32.140]                         if (is.null(version)) 
[16:09:32.140]                           version <- utils::packageVersion("future")
[16:09:32.140]                       }
[16:09:32.140]                       else {
[16:09:32.140]                         version <- NULL
[16:09:32.140]                       }
[16:09:32.140]                       if (!has_future || version < "1.8.0") {
[16:09:32.140]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.140]                           "", base::R.version$version.string), 
[16:09:32.140]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.140]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.140]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.140]                             "release", "version")], collapse = " "), 
[16:09:32.140]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.140]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.140]                           info)
[16:09:32.140]                         info <- base::paste(info, collapse = "; ")
[16:09:32.140]                         if (!has_future) {
[16:09:32.140]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.140]                             info)
[16:09:32.140]                         }
[16:09:32.140]                         else {
[16:09:32.140]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.140]                             info, version)
[16:09:32.140]                         }
[16:09:32.140]                         base::stop(msg)
[16:09:32.140]                       }
[16:09:32.140]                     })
[16:09:32.140]                   }
[16:09:32.140]                   options(future.plan = NULL)
[16:09:32.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.140]                 }
[16:09:32.140]                 ...future.workdir <- getwd()
[16:09:32.140]             }
[16:09:32.140]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.140]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.140]         }
[16:09:32.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.140]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.140]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.140]             base::names(...future.oldOptions))
[16:09:32.140]     }
[16:09:32.140]     if (FALSE) {
[16:09:32.140]     }
[16:09:32.140]     else {
[16:09:32.140]         if (TRUE) {
[16:09:32.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.140]                 open = "w")
[16:09:32.140]         }
[16:09:32.140]         else {
[16:09:32.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.140]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.140]         }
[16:09:32.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.140]             base::sink(type = "output", split = FALSE)
[16:09:32.140]             base::close(...future.stdout)
[16:09:32.140]         }, add = TRUE)
[16:09:32.140]     }
[16:09:32.140]     ...future.frame <- base::sys.nframe()
[16:09:32.140]     ...future.conditions <- base::list()
[16:09:32.140]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.140]     if (FALSE) {
[16:09:32.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.140]     }
[16:09:32.140]     ...future.result <- base::tryCatch({
[16:09:32.140]         base::withCallingHandlers({
[16:09:32.140]             ...future.value <- base::withVisible(base::local({
[16:09:32.140]                 do.call(function(...) {
[16:09:32.140]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.140]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.140]                     ...future.globals.maxSize)) {
[16:09:32.140]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.140]                     on.exit(options(oopts), add = TRUE)
[16:09:32.140]                   }
[16:09:32.140]                   {
[16:09:32.140]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.140]                       FUN = function(jj) {
[16:09:32.140]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.140]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.140]                       })
[16:09:32.140]                   }
[16:09:32.140]                 }, args = future.call.arguments)
[16:09:32.140]             }))
[16:09:32.140]             future::FutureResult(value = ...future.value$value, 
[16:09:32.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.140]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.140]                     ...future.globalenv.names))
[16:09:32.140]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.140]         }, condition = base::local({
[16:09:32.140]             c <- base::c
[16:09:32.140]             inherits <- base::inherits
[16:09:32.140]             invokeRestart <- base::invokeRestart
[16:09:32.140]             length <- base::length
[16:09:32.140]             list <- base::list
[16:09:32.140]             seq.int <- base::seq.int
[16:09:32.140]             signalCondition <- base::signalCondition
[16:09:32.140]             sys.calls <- base::sys.calls
[16:09:32.140]             `[[` <- base::`[[`
[16:09:32.140]             `+` <- base::`+`
[16:09:32.140]             `<<-` <- base::`<<-`
[16:09:32.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.140]                   3L)]
[16:09:32.140]             }
[16:09:32.140]             function(cond) {
[16:09:32.140]                 is_error <- inherits(cond, "error")
[16:09:32.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.140]                   NULL)
[16:09:32.140]                 if (is_error) {
[16:09:32.140]                   sessionInformation <- function() {
[16:09:32.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.140]                       search = base::search(), system = base::Sys.info())
[16:09:32.140]                   }
[16:09:32.140]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.140]                     cond$call), session = sessionInformation(), 
[16:09:32.140]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.140]                   signalCondition(cond)
[16:09:32.140]                 }
[16:09:32.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.140]                 "immediateCondition"))) {
[16:09:32.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.140]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.140]                   if (TRUE && !signal) {
[16:09:32.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.140]                     {
[16:09:32.140]                       inherits <- base::inherits
[16:09:32.140]                       invokeRestart <- base::invokeRestart
[16:09:32.140]                       is.null <- base::is.null
[16:09:32.140]                       muffled <- FALSE
[16:09:32.140]                       if (inherits(cond, "message")) {
[16:09:32.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.140]                         if (muffled) 
[16:09:32.140]                           invokeRestart("muffleMessage")
[16:09:32.140]                       }
[16:09:32.140]                       else if (inherits(cond, "warning")) {
[16:09:32.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.140]                         if (muffled) 
[16:09:32.140]                           invokeRestart("muffleWarning")
[16:09:32.140]                       }
[16:09:32.140]                       else if (inherits(cond, "condition")) {
[16:09:32.140]                         if (!is.null(pattern)) {
[16:09:32.140]                           computeRestarts <- base::computeRestarts
[16:09:32.140]                           grepl <- base::grepl
[16:09:32.140]                           restarts <- computeRestarts(cond)
[16:09:32.140]                           for (restart in restarts) {
[16:09:32.140]                             name <- restart$name
[16:09:32.140]                             if (is.null(name)) 
[16:09:32.140]                               next
[16:09:32.140]                             if (!grepl(pattern, name)) 
[16:09:32.140]                               next
[16:09:32.140]                             invokeRestart(restart)
[16:09:32.140]                             muffled <- TRUE
[16:09:32.140]                             break
[16:09:32.140]                           }
[16:09:32.140]                         }
[16:09:32.140]                       }
[16:09:32.140]                       invisible(muffled)
[16:09:32.140]                     }
[16:09:32.140]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.140]                   }
[16:09:32.140]                 }
[16:09:32.140]                 else {
[16:09:32.140]                   if (TRUE) {
[16:09:32.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.140]                     {
[16:09:32.140]                       inherits <- base::inherits
[16:09:32.140]                       invokeRestart <- base::invokeRestart
[16:09:32.140]                       is.null <- base::is.null
[16:09:32.140]                       muffled <- FALSE
[16:09:32.140]                       if (inherits(cond, "message")) {
[16:09:32.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.140]                         if (muffled) 
[16:09:32.140]                           invokeRestart("muffleMessage")
[16:09:32.140]                       }
[16:09:32.140]                       else if (inherits(cond, "warning")) {
[16:09:32.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.140]                         if (muffled) 
[16:09:32.140]                           invokeRestart("muffleWarning")
[16:09:32.140]                       }
[16:09:32.140]                       else if (inherits(cond, "condition")) {
[16:09:32.140]                         if (!is.null(pattern)) {
[16:09:32.140]                           computeRestarts <- base::computeRestarts
[16:09:32.140]                           grepl <- base::grepl
[16:09:32.140]                           restarts <- computeRestarts(cond)
[16:09:32.140]                           for (restart in restarts) {
[16:09:32.140]                             name <- restart$name
[16:09:32.140]                             if (is.null(name)) 
[16:09:32.140]                               next
[16:09:32.140]                             if (!grepl(pattern, name)) 
[16:09:32.140]                               next
[16:09:32.140]                             invokeRestart(restart)
[16:09:32.140]                             muffled <- TRUE
[16:09:32.140]                             break
[16:09:32.140]                           }
[16:09:32.140]                         }
[16:09:32.140]                       }
[16:09:32.140]                       invisible(muffled)
[16:09:32.140]                     }
[16:09:32.140]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.140]                   }
[16:09:32.140]                 }
[16:09:32.140]             }
[16:09:32.140]         }))
[16:09:32.140]     }, error = function(ex) {
[16:09:32.140]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.140]                 ...future.rng), started = ...future.startTime, 
[16:09:32.140]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.140]             version = "1.8"), class = "FutureResult")
[16:09:32.140]     }, finally = {
[16:09:32.140]         if (!identical(...future.workdir, getwd())) 
[16:09:32.140]             setwd(...future.workdir)
[16:09:32.140]         {
[16:09:32.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.140]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.140]             }
[16:09:32.140]             base::options(...future.oldOptions)
[16:09:32.140]             if (.Platform$OS.type == "windows") {
[16:09:32.140]                 old_names <- names(...future.oldEnvVars)
[16:09:32.140]                 envs <- base::Sys.getenv()
[16:09:32.140]                 names <- names(envs)
[16:09:32.140]                 common <- intersect(names, old_names)
[16:09:32.140]                 added <- setdiff(names, old_names)
[16:09:32.140]                 removed <- setdiff(old_names, names)
[16:09:32.140]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.140]                   envs[common]]
[16:09:32.140]                 NAMES <- toupper(changed)
[16:09:32.140]                 args <- list()
[16:09:32.140]                 for (kk in seq_along(NAMES)) {
[16:09:32.140]                   name <- changed[[kk]]
[16:09:32.140]                   NAME <- NAMES[[kk]]
[16:09:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.140]                     next
[16:09:32.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.140]                 }
[16:09:32.140]                 NAMES <- toupper(added)
[16:09:32.140]                 for (kk in seq_along(NAMES)) {
[16:09:32.140]                   name <- added[[kk]]
[16:09:32.140]                   NAME <- NAMES[[kk]]
[16:09:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.140]                     next
[16:09:32.140]                   args[[name]] <- ""
[16:09:32.140]                 }
[16:09:32.140]                 NAMES <- toupper(removed)
[16:09:32.140]                 for (kk in seq_along(NAMES)) {
[16:09:32.140]                   name <- removed[[kk]]
[16:09:32.140]                   NAME <- NAMES[[kk]]
[16:09:32.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.140]                     next
[16:09:32.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.140]                 }
[16:09:32.140]                 if (length(args) > 0) 
[16:09:32.140]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.140]             }
[16:09:32.140]             else {
[16:09:32.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.140]             }
[16:09:32.140]             {
[16:09:32.140]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.140]                   0L) {
[16:09:32.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.140]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.140]                   base::options(opts)
[16:09:32.140]                 }
[16:09:32.140]                 {
[16:09:32.140]                   {
[16:09:32.140]                     NULL
[16:09:32.140]                     RNGkind("Mersenne-Twister")
[16:09:32.140]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.140]                       inherits = FALSE)
[16:09:32.140]                   }
[16:09:32.140]                   options(future.plan = NULL)
[16:09:32.140]                   if (is.na(NA_character_)) 
[16:09:32.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.140]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.140]                   {
[16:09:32.140]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.140]                     if (!future$lazy) 
[16:09:32.140]                       future <- run(future)
[16:09:32.140]                     invisible(future)
[16:09:32.140]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.140]                 }
[16:09:32.140]             }
[16:09:32.140]         }
[16:09:32.140]     })
[16:09:32.140]     if (TRUE) {
[16:09:32.140]         base::sink(type = "output", split = FALSE)
[16:09:32.140]         if (TRUE) {
[16:09:32.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.140]         }
[16:09:32.140]         else {
[16:09:32.140]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.140]         }
[16:09:32.140]         base::close(...future.stdout)
[16:09:32.140]         ...future.stdout <- NULL
[16:09:32.140]     }
[16:09:32.140]     ...future.result$conditions <- ...future.conditions
[16:09:32.140]     ...future.result$finished <- base::Sys.time()
[16:09:32.140]     ...future.result
[16:09:32.140] }
[16:09:32.142] assign_globals() ...
[16:09:32.142] List of 5
[16:09:32.142]  $ ...future.FUN            :function (object, ...)  
[16:09:32.142]  $ future.call.arguments    : list()
[16:09:32.142]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.142]  $ ...future.elements_ii    :List of 3
[16:09:32.142]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.142]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.142]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.142]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.142]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.142]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.142]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.142]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.142]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.142]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.142]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.142]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.142]  $ ...future.seeds_ii       : NULL
[16:09:32.142]  $ ...future.globals.maxSize: NULL
[16:09:32.142]  - attr(*, "resolved")= logi FALSE
[16:09:32.142]  - attr(*, "total_size")= num 1240
[16:09:32.142]  - attr(*, "where")=List of 5
[16:09:32.142]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.142]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.142]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.142]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.142]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.142]  - attr(*, "already-done")= logi TRUE
[16:09:32.151] - copied ‘...future.FUN’ to environment
[16:09:32.151] - copied ‘future.call.arguments’ to environment
[16:09:32.151] - copied ‘...future.elements_ii’ to environment
[16:09:32.151] - copied ‘...future.seeds_ii’ to environment
[16:09:32.151] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.151] assign_globals() ... done
[16:09:32.152] plan(): Setting new future strategy stack:
[16:09:32.152] List of future strategies:
[16:09:32.152] 1. sequential:
[16:09:32.152]    - args: function (..., envir = parent.frame())
[16:09:32.152]    - tweaked: FALSE
[16:09:32.152]    - call: NULL
[16:09:32.152] plan(): nbrOfWorkers() = 1
[16:09:32.154] plan(): Setting new future strategy stack:
[16:09:32.154] List of future strategies:
[16:09:32.154] 1. sequential:
[16:09:32.154]    - args: function (..., envir = parent.frame())
[16:09:32.154]    - tweaked: FALSE
[16:09:32.154]    - call: plan(strategy)
[16:09:32.155] plan(): nbrOfWorkers() = 1
[16:09:32.155] SequentialFuture started (and completed)
[16:09:32.155] - Launch lazy future ... done
[16:09:32.155] run() for ‘SequentialFuture’ ... done
[16:09:32.155] Created future:
[16:09:32.155] SequentialFuture:
[16:09:32.155] Label: ‘future_by-1’
[16:09:32.155] Expression:
[16:09:32.155] {
[16:09:32.155]     do.call(function(...) {
[16:09:32.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.155]             on.exit(options(oopts), add = TRUE)
[16:09:32.155]         }
[16:09:32.155]         {
[16:09:32.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.155]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.155]             })
[16:09:32.155]         }
[16:09:32.155]     }, args = future.call.arguments)
[16:09:32.155] }
[16:09:32.155] Lazy evaluation: FALSE
[16:09:32.155] Asynchronous evaluation: FALSE
[16:09:32.155] Local evaluation: TRUE
[16:09:32.155] Environment: 0x5567e929e798
[16:09:32.155] Capture standard output: TRUE
[16:09:32.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.155] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.155] Packages: <none>
[16:09:32.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.155] Resolved: TRUE
[16:09:32.155] Value: 5.37 KiB of class ‘list’
[16:09:32.155] Early signaling: FALSE
[16:09:32.155] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.155] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.156] Chunk #1 of 1 ... DONE
[16:09:32.156] Launching 1 futures (chunks) ... DONE
[16:09:32.157] Resolving 1 futures (chunks) ...
[16:09:32.157] resolve() on list ...
[16:09:32.157]  recursive: 0
[16:09:32.157]  length: 1
[16:09:32.157] 
[16:09:32.157] resolved() for ‘SequentialFuture’ ...
[16:09:32.157] - state: ‘finished’
[16:09:32.157] - run: TRUE
[16:09:32.157] - result: ‘FutureResult’
[16:09:32.157] resolved() for ‘SequentialFuture’ ... done
[16:09:32.157] Future #1
[16:09:32.158] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.158] - nx: 1
[16:09:32.158] - relay: TRUE
[16:09:32.158] - stdout: TRUE
[16:09:32.158] - signal: TRUE
[16:09:32.158] - resignal: FALSE
[16:09:32.158] - force: TRUE
[16:09:32.158] - relayed: [n=1] FALSE
[16:09:32.158] - queued futures: [n=1] FALSE
[16:09:32.158]  - until=1
[16:09:32.158]  - relaying element #1
[16:09:32.159] - relayed: [n=1] TRUE
[16:09:32.159] - queued futures: [n=1] TRUE
[16:09:32.159] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.159]  length: 0 (resolved future 1)
[16:09:32.159] Relaying remaining futures
[16:09:32.159] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.159] - nx: 1
[16:09:32.159] - relay: TRUE
[16:09:32.159] - stdout: TRUE
[16:09:32.159] - signal: TRUE
[16:09:32.159] - resignal: FALSE
[16:09:32.160] - force: TRUE
[16:09:32.160] - relayed: [n=1] TRUE
[16:09:32.160] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.160] - relayed: [n=1] TRUE
[16:09:32.160] - queued futures: [n=1] TRUE
[16:09:32.160] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.160] resolve() on list ... DONE
[16:09:32.160]  - Number of value chunks collected: 1
[16:09:32.160] Resolving 1 futures (chunks) ... DONE
[16:09:32.160] Reducing values from 1 chunks ...
[16:09:32.160]  - Number of values collected after concatenation: 3
[16:09:32.161]  - Number of values expected: 3
[16:09:32.161] Reducing values from 1 chunks ... DONE
[16:09:32.161] future_lapply() ... DONE
[16:09:32.161] future_by_internal() ... DONE
[16:09:32.162] future_by_internal() ...
- plan('multicore') ...
[16:09:32.162] plan(): Setting new future strategy stack:
[16:09:32.162] List of future strategies:
[16:09:32.162] 1. multicore:
[16:09:32.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.162]    - tweaked: FALSE
[16:09:32.162]    - call: plan(strategy)
[16:09:32.167] plan(): nbrOfWorkers() = 1
[16:09:32.168] future_by_internal() ...
[16:09:32.168] future_lapply() ...
[16:09:32.172] Number of chunks: 1
[16:09:32.172] getGlobalsAndPackagesXApply() ...
[16:09:32.172]  - future.globals: TRUE
[16:09:32.172] getGlobalsAndPackages() ...
[16:09:32.172] Searching for globals...
[16:09:32.173] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.173] Searching for globals ... DONE
[16:09:32.173] Resolving globals: FALSE
[16:09:32.174] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.174] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.174] - globals: [1] ‘FUN’
[16:09:32.174] 
[16:09:32.174] getGlobalsAndPackages() ... DONE
[16:09:32.174]  - globals found/used: [n=1] ‘FUN’
[16:09:32.175]  - needed namespaces: [n=0] 
[16:09:32.175] Finding globals ... DONE
[16:09:32.175]  - use_args: TRUE
[16:09:32.175]  - Getting '...' globals ...
[16:09:32.175] resolve() on list ...
[16:09:32.175]  recursive: 0
[16:09:32.175]  length: 1
[16:09:32.175]  elements: ‘...’
[16:09:32.176]  length: 0 (resolved future 1)
[16:09:32.176] resolve() on list ... DONE
[16:09:32.176]    - '...' content: [n=0] 
[16:09:32.176] List of 1
[16:09:32.176]  $ ...: list()
[16:09:32.176]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.176]  - attr(*, "where")=List of 1
[16:09:32.176]   ..$ ...:<environment: 0x5567e7c575b0> 
[16:09:32.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.176]  - attr(*, "resolved")= logi TRUE
[16:09:32.176]  - attr(*, "total_size")= num NA
[16:09:32.178]  - Getting '...' globals ... DONE
[16:09:32.179] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.179] List of 2
[16:09:32.179]  $ ...future.FUN:function (object, ...)  
[16:09:32.179]  $ ...          : list()
[16:09:32.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.179]  - attr(*, "where")=List of 2
[16:09:32.179]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.179]   ..$ ...          :<environment: 0x5567e7c575b0> 
[16:09:32.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.179]  - attr(*, "resolved")= logi FALSE
[16:09:32.179]  - attr(*, "total_size")= num 1240
[16:09:32.181] Packages to be attached in all futures: [n=0] 
[16:09:32.182] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.182] Number of futures (= number of chunks): 1
[16:09:32.182] Launching 1 futures (chunks) ...
[16:09:32.182] Chunk #1 of 1 ...
[16:09:32.182]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.182] getGlobalsAndPackages() ...
[16:09:32.182] Searching for globals...
[16:09:32.183] 
[16:09:32.183] Searching for globals ... DONE
[16:09:32.183] - globals: [0] <none>
[16:09:32.183] getGlobalsAndPackages() ... DONE
[16:09:32.183]    + additional globals found: [n=0] 
[16:09:32.183]    + additional namespaces needed: [n=0] 
[16:09:32.183]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.183]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.184]  - seeds: <none>
[16:09:32.184] getGlobalsAndPackages() ...
[16:09:32.184] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.184] Resolving globals: FALSE
[16:09:32.184] Tweak future expression to call with '...' arguments ...
[16:09:32.184] {
[16:09:32.184]     do.call(function(...) {
[16:09:32.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.184]             on.exit(options(oopts), add = TRUE)
[16:09:32.184]         }
[16:09:32.184]         {
[16:09:32.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.184]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.184]             })
[16:09:32.184]         }
[16:09:32.184]     }, args = future.call.arguments)
[16:09:32.184] }
[16:09:32.184] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.185] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.185] 
[16:09:32.185] getGlobalsAndPackages() ... DONE
[16:09:32.185] run() for ‘Future’ ...
[16:09:32.185] - state: ‘created’
[16:09:32.185] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.189] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.189]   - Field: ‘label’
[16:09:32.189]   - Field: ‘local’
[16:09:32.190]   - Field: ‘owner’
[16:09:32.190]   - Field: ‘envir’
[16:09:32.190]   - Field: ‘packages’
[16:09:32.190]   - Field: ‘gc’
[16:09:32.190]   - Field: ‘conditions’
[16:09:32.190]   - Field: ‘expr’
[16:09:32.190]   - Field: ‘uuid’
[16:09:32.190]   - Field: ‘seed’
[16:09:32.190]   - Field: ‘version’
[16:09:32.192]   - Field: ‘result’
[16:09:32.192]   - Field: ‘asynchronous’
[16:09:32.192]   - Field: ‘calls’
[16:09:32.192]   - Field: ‘globals’
[16:09:32.193]   - Field: ‘stdout’
[16:09:32.193]   - Field: ‘earlySignal’
[16:09:32.193]   - Field: ‘lazy’
[16:09:32.193]   - Field: ‘state’
[16:09:32.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.193] - Launch lazy future ...
[16:09:32.193] Packages needed by the future expression (n = 0): <none>
[16:09:32.193] Packages needed by future strategies (n = 0): <none>
[16:09:32.194] {
[16:09:32.194]     {
[16:09:32.194]         {
[16:09:32.194]             ...future.startTime <- base::Sys.time()
[16:09:32.194]             {
[16:09:32.194]                 {
[16:09:32.194]                   {
[16:09:32.194]                     base::local({
[16:09:32.194]                       has_future <- base::requireNamespace("future", 
[16:09:32.194]                         quietly = TRUE)
[16:09:32.194]                       if (has_future) {
[16:09:32.194]                         ns <- base::getNamespace("future")
[16:09:32.194]                         version <- ns[[".package"]][["version"]]
[16:09:32.194]                         if (is.null(version)) 
[16:09:32.194]                           version <- utils::packageVersion("future")
[16:09:32.194]                       }
[16:09:32.194]                       else {
[16:09:32.194]                         version <- NULL
[16:09:32.194]                       }
[16:09:32.194]                       if (!has_future || version < "1.8.0") {
[16:09:32.194]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.194]                           "", base::R.version$version.string), 
[16:09:32.194]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.194]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.194]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.194]                             "release", "version")], collapse = " "), 
[16:09:32.194]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.194]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.194]                           info)
[16:09:32.194]                         info <- base::paste(info, collapse = "; ")
[16:09:32.194]                         if (!has_future) {
[16:09:32.194]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.194]                             info)
[16:09:32.194]                         }
[16:09:32.194]                         else {
[16:09:32.194]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.194]                             info, version)
[16:09:32.194]                         }
[16:09:32.194]                         base::stop(msg)
[16:09:32.194]                       }
[16:09:32.194]                     })
[16:09:32.194]                   }
[16:09:32.194]                   options(future.plan = NULL)
[16:09:32.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.194]                 }
[16:09:32.194]                 ...future.workdir <- getwd()
[16:09:32.194]             }
[16:09:32.194]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.194]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.194]         }
[16:09:32.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.194]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.194]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.194]             base::names(...future.oldOptions))
[16:09:32.194]     }
[16:09:32.194]     if (FALSE) {
[16:09:32.194]     }
[16:09:32.194]     else {
[16:09:32.194]         if (TRUE) {
[16:09:32.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.194]                 open = "w")
[16:09:32.194]         }
[16:09:32.194]         else {
[16:09:32.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.194]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.194]         }
[16:09:32.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.194]             base::sink(type = "output", split = FALSE)
[16:09:32.194]             base::close(...future.stdout)
[16:09:32.194]         }, add = TRUE)
[16:09:32.194]     }
[16:09:32.194]     ...future.frame <- base::sys.nframe()
[16:09:32.194]     ...future.conditions <- base::list()
[16:09:32.194]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.194]     if (FALSE) {
[16:09:32.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.194]     }
[16:09:32.194]     ...future.result <- base::tryCatch({
[16:09:32.194]         base::withCallingHandlers({
[16:09:32.194]             ...future.value <- base::withVisible(base::local({
[16:09:32.194]                 do.call(function(...) {
[16:09:32.194]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.194]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.194]                     ...future.globals.maxSize)) {
[16:09:32.194]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.194]                     on.exit(options(oopts), add = TRUE)
[16:09:32.194]                   }
[16:09:32.194]                   {
[16:09:32.194]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.194]                       FUN = function(jj) {
[16:09:32.194]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.194]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.194]                       })
[16:09:32.194]                   }
[16:09:32.194]                 }, args = future.call.arguments)
[16:09:32.194]             }))
[16:09:32.194]             future::FutureResult(value = ...future.value$value, 
[16:09:32.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.194]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.194]                     ...future.globalenv.names))
[16:09:32.194]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.194]         }, condition = base::local({
[16:09:32.194]             c <- base::c
[16:09:32.194]             inherits <- base::inherits
[16:09:32.194]             invokeRestart <- base::invokeRestart
[16:09:32.194]             length <- base::length
[16:09:32.194]             list <- base::list
[16:09:32.194]             seq.int <- base::seq.int
[16:09:32.194]             signalCondition <- base::signalCondition
[16:09:32.194]             sys.calls <- base::sys.calls
[16:09:32.194]             `[[` <- base::`[[`
[16:09:32.194]             `+` <- base::`+`
[16:09:32.194]             `<<-` <- base::`<<-`
[16:09:32.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.194]                   3L)]
[16:09:32.194]             }
[16:09:32.194]             function(cond) {
[16:09:32.194]                 is_error <- inherits(cond, "error")
[16:09:32.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.194]                   NULL)
[16:09:32.194]                 if (is_error) {
[16:09:32.194]                   sessionInformation <- function() {
[16:09:32.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.194]                       search = base::search(), system = base::Sys.info())
[16:09:32.194]                   }
[16:09:32.194]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.194]                     cond$call), session = sessionInformation(), 
[16:09:32.194]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.194]                   signalCondition(cond)
[16:09:32.194]                 }
[16:09:32.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.194]                 "immediateCondition"))) {
[16:09:32.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.194]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.194]                   if (TRUE && !signal) {
[16:09:32.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.194]                     {
[16:09:32.194]                       inherits <- base::inherits
[16:09:32.194]                       invokeRestart <- base::invokeRestart
[16:09:32.194]                       is.null <- base::is.null
[16:09:32.194]                       muffled <- FALSE
[16:09:32.194]                       if (inherits(cond, "message")) {
[16:09:32.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.194]                         if (muffled) 
[16:09:32.194]                           invokeRestart("muffleMessage")
[16:09:32.194]                       }
[16:09:32.194]                       else if (inherits(cond, "warning")) {
[16:09:32.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.194]                         if (muffled) 
[16:09:32.194]                           invokeRestart("muffleWarning")
[16:09:32.194]                       }
[16:09:32.194]                       else if (inherits(cond, "condition")) {
[16:09:32.194]                         if (!is.null(pattern)) {
[16:09:32.194]                           computeRestarts <- base::computeRestarts
[16:09:32.194]                           grepl <- base::grepl
[16:09:32.194]                           restarts <- computeRestarts(cond)
[16:09:32.194]                           for (restart in restarts) {
[16:09:32.194]                             name <- restart$name
[16:09:32.194]                             if (is.null(name)) 
[16:09:32.194]                               next
[16:09:32.194]                             if (!grepl(pattern, name)) 
[16:09:32.194]                               next
[16:09:32.194]                             invokeRestart(restart)
[16:09:32.194]                             muffled <- TRUE
[16:09:32.194]                             break
[16:09:32.194]                           }
[16:09:32.194]                         }
[16:09:32.194]                       }
[16:09:32.194]                       invisible(muffled)
[16:09:32.194]                     }
[16:09:32.194]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.194]                   }
[16:09:32.194]                 }
[16:09:32.194]                 else {
[16:09:32.194]                   if (TRUE) {
[16:09:32.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.194]                     {
[16:09:32.194]                       inherits <- base::inherits
[16:09:32.194]                       invokeRestart <- base::invokeRestart
[16:09:32.194]                       is.null <- base::is.null
[16:09:32.194]                       muffled <- FALSE
[16:09:32.194]                       if (inherits(cond, "message")) {
[16:09:32.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.194]                         if (muffled) 
[16:09:32.194]                           invokeRestart("muffleMessage")
[16:09:32.194]                       }
[16:09:32.194]                       else if (inherits(cond, "warning")) {
[16:09:32.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.194]                         if (muffled) 
[16:09:32.194]                           invokeRestart("muffleWarning")
[16:09:32.194]                       }
[16:09:32.194]                       else if (inherits(cond, "condition")) {
[16:09:32.194]                         if (!is.null(pattern)) {
[16:09:32.194]                           computeRestarts <- base::computeRestarts
[16:09:32.194]                           grepl <- base::grepl
[16:09:32.194]                           restarts <- computeRestarts(cond)
[16:09:32.194]                           for (restart in restarts) {
[16:09:32.194]                             name <- restart$name
[16:09:32.194]                             if (is.null(name)) 
[16:09:32.194]                               next
[16:09:32.194]                             if (!grepl(pattern, name)) 
[16:09:32.194]                               next
[16:09:32.194]                             invokeRestart(restart)
[16:09:32.194]                             muffled <- TRUE
[16:09:32.194]                             break
[16:09:32.194]                           }
[16:09:32.194]                         }
[16:09:32.194]                       }
[16:09:32.194]                       invisible(muffled)
[16:09:32.194]                     }
[16:09:32.194]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.194]                   }
[16:09:32.194]                 }
[16:09:32.194]             }
[16:09:32.194]         }))
[16:09:32.194]     }, error = function(ex) {
[16:09:32.194]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.194]                 ...future.rng), started = ...future.startTime, 
[16:09:32.194]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.194]             version = "1.8"), class = "FutureResult")
[16:09:32.194]     }, finally = {
[16:09:32.194]         if (!identical(...future.workdir, getwd())) 
[16:09:32.194]             setwd(...future.workdir)
[16:09:32.194]         {
[16:09:32.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.194]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.194]             }
[16:09:32.194]             base::options(...future.oldOptions)
[16:09:32.194]             if (.Platform$OS.type == "windows") {
[16:09:32.194]                 old_names <- names(...future.oldEnvVars)
[16:09:32.194]                 envs <- base::Sys.getenv()
[16:09:32.194]                 names <- names(envs)
[16:09:32.194]                 common <- intersect(names, old_names)
[16:09:32.194]                 added <- setdiff(names, old_names)
[16:09:32.194]                 removed <- setdiff(old_names, names)
[16:09:32.194]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.194]                   envs[common]]
[16:09:32.194]                 NAMES <- toupper(changed)
[16:09:32.194]                 args <- list()
[16:09:32.194]                 for (kk in seq_along(NAMES)) {
[16:09:32.194]                   name <- changed[[kk]]
[16:09:32.194]                   NAME <- NAMES[[kk]]
[16:09:32.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.194]                     next
[16:09:32.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.194]                 }
[16:09:32.194]                 NAMES <- toupper(added)
[16:09:32.194]                 for (kk in seq_along(NAMES)) {
[16:09:32.194]                   name <- added[[kk]]
[16:09:32.194]                   NAME <- NAMES[[kk]]
[16:09:32.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.194]                     next
[16:09:32.194]                   args[[name]] <- ""
[16:09:32.194]                 }
[16:09:32.194]                 NAMES <- toupper(removed)
[16:09:32.194]                 for (kk in seq_along(NAMES)) {
[16:09:32.194]                   name <- removed[[kk]]
[16:09:32.194]                   NAME <- NAMES[[kk]]
[16:09:32.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.194]                     next
[16:09:32.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.194]                 }
[16:09:32.194]                 if (length(args) > 0) 
[16:09:32.194]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.194]             }
[16:09:32.194]             else {
[16:09:32.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.194]             }
[16:09:32.194]             {
[16:09:32.194]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.194]                   0L) {
[16:09:32.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.194]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.194]                   base::options(opts)
[16:09:32.194]                 }
[16:09:32.194]                 {
[16:09:32.194]                   {
[16:09:32.194]                     NULL
[16:09:32.194]                     RNGkind("Mersenne-Twister")
[16:09:32.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.194]                       inherits = FALSE)
[16:09:32.194]                   }
[16:09:32.194]                   options(future.plan = NULL)
[16:09:32.194]                   if (is.na(NA_character_)) 
[16:09:32.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.194]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:32.194]                     envir = parent.frame()) 
[16:09:32.194]                   {
[16:09:32.194]                     default_workers <- missing(workers)
[16:09:32.194]                     if (is.function(workers)) 
[16:09:32.194]                       workers <- workers()
[16:09:32.194]                     workers <- structure(as.integer(workers), 
[16:09:32.194]                       class = class(workers))
[16:09:32.194]                     stop_if_not(is.finite(workers), workers >= 
[16:09:32.194]                       1L)
[16:09:32.194]                     if ((workers == 1L && !inherits(workers, 
[16:09:32.194]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:32.194]                       if (default_workers) 
[16:09:32.194]                         supportsMulticore(warn = TRUE)
[16:09:32.194]                       return(sequential(..., envir = envir))
[16:09:32.194]                     }
[16:09:32.194]                     oopts <- options(mc.cores = workers)
[16:09:32.194]                     on.exit(options(oopts))
[16:09:32.194]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:32.194]                       envir = envir)
[16:09:32.194]                     if (!future$lazy) 
[16:09:32.194]                       future <- run(future)
[16:09:32.194]                     invisible(future)
[16:09:32.194]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.194]                 }
[16:09:32.194]             }
[16:09:32.194]         }
[16:09:32.194]     })
[16:09:32.194]     if (TRUE) {
[16:09:32.194]         base::sink(type = "output", split = FALSE)
[16:09:32.194]         if (TRUE) {
[16:09:32.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.194]         }
[16:09:32.194]         else {
[16:09:32.194]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.194]         }
[16:09:32.194]         base::close(...future.stdout)
[16:09:32.194]         ...future.stdout <- NULL
[16:09:32.194]     }
[16:09:32.194]     ...future.result$conditions <- ...future.conditions
[16:09:32.194]     ...future.result$finished <- base::Sys.time()
[16:09:32.194]     ...future.result
[16:09:32.194] }
[16:09:32.196] assign_globals() ...
[16:09:32.196] List of 5
[16:09:32.196]  $ ...future.FUN            :function (object, ...)  
[16:09:32.196]  $ future.call.arguments    : list()
[16:09:32.196]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.196]  $ ...future.elements_ii    :List of 3
[16:09:32.196]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.196]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.196]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.196]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.196]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.196]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.196]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.196]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.196]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.196]  $ ...future.seeds_ii       : NULL
[16:09:32.196]  $ ...future.globals.maxSize: NULL
[16:09:32.196]  - attr(*, "resolved")= logi FALSE
[16:09:32.196]  - attr(*, "total_size")= num 1240
[16:09:32.196]  - attr(*, "where")=List of 5
[16:09:32.196]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.196]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.196]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.196]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.196]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.196]  - attr(*, "already-done")= logi TRUE
[16:09:32.203] - copied ‘...future.FUN’ to environment
[16:09:32.203] - copied ‘future.call.arguments’ to environment
[16:09:32.203] - copied ‘...future.elements_ii’ to environment
[16:09:32.203] - copied ‘...future.seeds_ii’ to environment
[16:09:32.203] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.203] assign_globals() ... done
[16:09:32.204] plan(): Setting new future strategy stack:
[16:09:32.204] List of future strategies:
[16:09:32.204] 1. sequential:
[16:09:32.204]    - args: function (..., envir = parent.frame())
[16:09:32.204]    - tweaked: FALSE
[16:09:32.204]    - call: NULL
[16:09:32.204] plan(): nbrOfWorkers() = 1
[16:09:32.206] plan(): Setting new future strategy stack:
[16:09:32.206] List of future strategies:
[16:09:32.206] 1. multicore:
[16:09:32.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.206]    - tweaked: FALSE
[16:09:32.206]    - call: plan(strategy)
[16:09:32.210] plan(): nbrOfWorkers() = 1
[16:09:32.210] SequentialFuture started (and completed)
[16:09:32.210] - Launch lazy future ... done
[16:09:32.210] run() for ‘SequentialFuture’ ... done
[16:09:32.210] Created future:
[16:09:32.210] SequentialFuture:
[16:09:32.210] Label: ‘future_by-1’
[16:09:32.210] Expression:
[16:09:32.210] {
[16:09:32.210]     do.call(function(...) {
[16:09:32.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.210]             on.exit(options(oopts), add = TRUE)
[16:09:32.210]         }
[16:09:32.210]         {
[16:09:32.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.210]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.210]             })
[16:09:32.210]         }
[16:09:32.210]     }, args = future.call.arguments)
[16:09:32.210] }
[16:09:32.210] Lazy evaluation: FALSE
[16:09:32.210] Asynchronous evaluation: FALSE
[16:09:32.210] Local evaluation: TRUE
[16:09:32.210] Environment: R_GlobalEnv
[16:09:32.210] Capture standard output: TRUE
[16:09:32.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.210] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.210] Packages: <none>
[16:09:32.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.210] Resolved: TRUE
[16:09:32.210] Value: 4.62 KiB of class ‘list’
[16:09:32.210] Early signaling: FALSE
[16:09:32.210] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.210] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.211] Chunk #1 of 1 ... DONE
[16:09:32.212] Launching 1 futures (chunks) ... DONE
[16:09:32.212] Resolving 1 futures (chunks) ...
[16:09:32.212] resolve() on list ...
[16:09:32.212]  recursive: 0
[16:09:32.212]  length: 1
[16:09:32.212] 
[16:09:32.212] resolved() for ‘SequentialFuture’ ...
[16:09:32.212] - state: ‘finished’
[16:09:32.212] - run: TRUE
[16:09:32.212] - result: ‘FutureResult’
[16:09:32.213] resolved() for ‘SequentialFuture’ ... done
[16:09:32.213] Future #1
[16:09:32.213] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.213] - nx: 1
[16:09:32.213] - relay: TRUE
[16:09:32.213] - stdout: TRUE
[16:09:32.213] - signal: TRUE
[16:09:32.213] - resignal: FALSE
[16:09:32.213] - force: TRUE
[16:09:32.213] - relayed: [n=1] FALSE
[16:09:32.213] - queued futures: [n=1] FALSE
[16:09:32.214]  - until=1
[16:09:32.214]  - relaying element #1
[16:09:32.214] - relayed: [n=1] TRUE
[16:09:32.214] - queued futures: [n=1] TRUE
[16:09:32.216] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.216]  length: 0 (resolved future 1)
[16:09:32.216] Relaying remaining futures
[16:09:32.216] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.216] - nx: 1
[16:09:32.216] - relay: TRUE
[16:09:32.216] - stdout: TRUE
[16:09:32.216] - signal: TRUE
[16:09:32.216] - resignal: FALSE
[16:09:32.216] - force: TRUE
[16:09:32.216] - relayed: [n=1] TRUE
[16:09:32.217] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.217] - relayed: [n=1] TRUE
[16:09:32.217] - queued futures: [n=1] TRUE
[16:09:32.217] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.217] resolve() on list ... DONE
[16:09:32.217]  - Number of value chunks collected: 1
[16:09:32.217] Resolving 1 futures (chunks) ... DONE
[16:09:32.217] Reducing values from 1 chunks ...
[16:09:32.217]  - Number of values collected after concatenation: 3
[16:09:32.217]  - Number of values expected: 3
[16:09:32.218] Reducing values from 1 chunks ... DONE
[16:09:32.218] future_lapply() ... DONE
[16:09:32.218] future_by_internal() ... DONE
[16:09:32.218] future_by_internal() ...
[16:09:32.218] future_lapply() ...
[16:09:32.222] Number of chunks: 1
[16:09:32.222] getGlobalsAndPackagesXApply() ...
[16:09:32.222]  - future.globals: TRUE
[16:09:32.222] getGlobalsAndPackages() ...
[16:09:32.222] Searching for globals...
[16:09:32.223] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.223] Searching for globals ... DONE
[16:09:32.223] Resolving globals: FALSE
[16:09:32.224] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.224] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.224] - globals: [1] ‘FUN’
[16:09:32.224] 
[16:09:32.224] getGlobalsAndPackages() ... DONE
[16:09:32.225]  - globals found/used: [n=1] ‘FUN’
[16:09:32.225]  - needed namespaces: [n=0] 
[16:09:32.225] Finding globals ... DONE
[16:09:32.225]  - use_args: TRUE
[16:09:32.225]  - Getting '...' globals ...
[16:09:32.225] resolve() on list ...
[16:09:32.225]  recursive: 0
[16:09:32.225]  length: 1
[16:09:32.225]  elements: ‘...’
[16:09:32.226]  length: 0 (resolved future 1)
[16:09:32.226] resolve() on list ... DONE
[16:09:32.226]    - '...' content: [n=1] ‘digits’
[16:09:32.226] List of 1
[16:09:32.226]  $ ...:List of 1
[16:09:32.226]   ..$ digits: int 2
[16:09:32.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.226]  - attr(*, "where")=List of 1
[16:09:32.226]   ..$ ...:<environment: 0x5567e7837e70> 
[16:09:32.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.226]  - attr(*, "resolved")= logi TRUE
[16:09:32.226]  - attr(*, "total_size")= num NA
[16:09:32.229]  - Getting '...' globals ... DONE
[16:09:32.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.229] List of 2
[16:09:32.229]  $ ...future.FUN:function (object, ...)  
[16:09:32.229]  $ ...          :List of 1
[16:09:32.229]   ..$ digits: int 2
[16:09:32.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.229]  - attr(*, "where")=List of 2
[16:09:32.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.229]   ..$ ...          :<environment: 0x5567e7837e70> 
[16:09:32.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.229]  - attr(*, "resolved")= logi FALSE
[16:09:32.229]  - attr(*, "total_size")= num 1296
[16:09:32.232] Packages to be attached in all futures: [n=0] 
[16:09:32.232] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.232] Number of futures (= number of chunks): 1
[16:09:32.232] Launching 1 futures (chunks) ...
[16:09:32.233] Chunk #1 of 1 ...
[16:09:32.233]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.233] getGlobalsAndPackages() ...
[16:09:32.233] Searching for globals...
[16:09:32.233] 
[16:09:32.233] Searching for globals ... DONE
[16:09:32.233] - globals: [0] <none>
[16:09:32.233] getGlobalsAndPackages() ... DONE
[16:09:32.233]    + additional globals found: [n=0] 
[16:09:32.234]    + additional namespaces needed: [n=0] 
[16:09:32.234]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.234]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[16:09:32.234]  - seeds: <none>
[16:09:32.234] getGlobalsAndPackages() ...
[16:09:32.234] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.234] Resolving globals: FALSE
[16:09:32.234] Tweak future expression to call with '...' arguments ...
[16:09:32.234] {
[16:09:32.234]     do.call(function(...) {
[16:09:32.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.234]             on.exit(options(oopts), add = TRUE)
[16:09:32.234]         }
[16:09:32.234]         {
[16:09:32.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.234]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.234]             })
[16:09:32.234]         }
[16:09:32.234]     }, args = future.call.arguments)
[16:09:32.234] }
[16:09:32.235] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.235] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.235] 
[16:09:32.235] getGlobalsAndPackages() ... DONE
[16:09:32.235] run() for ‘Future’ ...
[16:09:32.236] - state: ‘created’
[16:09:32.237] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.241] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.241]   - Field: ‘label’
[16:09:32.242]   - Field: ‘local’
[16:09:32.242]   - Field: ‘owner’
[16:09:32.242]   - Field: ‘envir’
[16:09:32.242]   - Field: ‘packages’
[16:09:32.242]   - Field: ‘gc’
[16:09:32.242]   - Field: ‘conditions’
[16:09:32.242]   - Field: ‘expr’
[16:09:32.242]   - Field: ‘uuid’
[16:09:32.242]   - Field: ‘seed’
[16:09:32.243]   - Field: ‘version’
[16:09:32.243]   - Field: ‘result’
[16:09:32.243]   - Field: ‘asynchronous’
[16:09:32.243]   - Field: ‘calls’
[16:09:32.243]   - Field: ‘globals’
[16:09:32.243]   - Field: ‘stdout’
[16:09:32.243]   - Field: ‘earlySignal’
[16:09:32.243]   - Field: ‘lazy’
[16:09:32.243]   - Field: ‘state’
[16:09:32.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.244] - Launch lazy future ...
[16:09:32.244] Packages needed by the future expression (n = 0): <none>
[16:09:32.244] Packages needed by future strategies (n = 0): <none>
[16:09:32.244] {
[16:09:32.244]     {
[16:09:32.244]         {
[16:09:32.244]             ...future.startTime <- base::Sys.time()
[16:09:32.244]             {
[16:09:32.244]                 {
[16:09:32.244]                   {
[16:09:32.244]                     base::local({
[16:09:32.244]                       has_future <- base::requireNamespace("future", 
[16:09:32.244]                         quietly = TRUE)
[16:09:32.244]                       if (has_future) {
[16:09:32.244]                         ns <- base::getNamespace("future")
[16:09:32.244]                         version <- ns[[".package"]][["version"]]
[16:09:32.244]                         if (is.null(version)) 
[16:09:32.244]                           version <- utils::packageVersion("future")
[16:09:32.244]                       }
[16:09:32.244]                       else {
[16:09:32.244]                         version <- NULL
[16:09:32.244]                       }
[16:09:32.244]                       if (!has_future || version < "1.8.0") {
[16:09:32.244]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.244]                           "", base::R.version$version.string), 
[16:09:32.244]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.244]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.244]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.244]                             "release", "version")], collapse = " "), 
[16:09:32.244]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.244]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.244]                           info)
[16:09:32.244]                         info <- base::paste(info, collapse = "; ")
[16:09:32.244]                         if (!has_future) {
[16:09:32.244]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.244]                             info)
[16:09:32.244]                         }
[16:09:32.244]                         else {
[16:09:32.244]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.244]                             info, version)
[16:09:32.244]                         }
[16:09:32.244]                         base::stop(msg)
[16:09:32.244]                       }
[16:09:32.244]                     })
[16:09:32.244]                   }
[16:09:32.244]                   options(future.plan = NULL)
[16:09:32.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.244]                 }
[16:09:32.244]                 ...future.workdir <- getwd()
[16:09:32.244]             }
[16:09:32.244]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.244]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.244]         }
[16:09:32.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.244]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[16:09:32.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.244]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.244]             base::names(...future.oldOptions))
[16:09:32.244]     }
[16:09:32.244]     if (FALSE) {
[16:09:32.244]     }
[16:09:32.244]     else {
[16:09:32.244]         if (TRUE) {
[16:09:32.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.244]                 open = "w")
[16:09:32.244]         }
[16:09:32.244]         else {
[16:09:32.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.244]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.244]         }
[16:09:32.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.244]             base::sink(type = "output", split = FALSE)
[16:09:32.244]             base::close(...future.stdout)
[16:09:32.244]         }, add = TRUE)
[16:09:32.244]     }
[16:09:32.244]     ...future.frame <- base::sys.nframe()
[16:09:32.244]     ...future.conditions <- base::list()
[16:09:32.244]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.244]     if (FALSE) {
[16:09:32.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.244]     }
[16:09:32.244]     ...future.result <- base::tryCatch({
[16:09:32.244]         base::withCallingHandlers({
[16:09:32.244]             ...future.value <- base::withVisible(base::local({
[16:09:32.244]                 do.call(function(...) {
[16:09:32.244]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.244]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.244]                     ...future.globals.maxSize)) {
[16:09:32.244]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.244]                     on.exit(options(oopts), add = TRUE)
[16:09:32.244]                   }
[16:09:32.244]                   {
[16:09:32.244]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.244]                       FUN = function(jj) {
[16:09:32.244]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.244]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.244]                       })
[16:09:32.244]                   }
[16:09:32.244]                 }, args = future.call.arguments)
[16:09:32.244]             }))
[16:09:32.244]             future::FutureResult(value = ...future.value$value, 
[16:09:32.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.244]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.244]                     ...future.globalenv.names))
[16:09:32.244]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.244]         }, condition = base::local({
[16:09:32.244]             c <- base::c
[16:09:32.244]             inherits <- base::inherits
[16:09:32.244]             invokeRestart <- base::invokeRestart
[16:09:32.244]             length <- base::length
[16:09:32.244]             list <- base::list
[16:09:32.244]             seq.int <- base::seq.int
[16:09:32.244]             signalCondition <- base::signalCondition
[16:09:32.244]             sys.calls <- base::sys.calls
[16:09:32.244]             `[[` <- base::`[[`
[16:09:32.244]             `+` <- base::`+`
[16:09:32.244]             `<<-` <- base::`<<-`
[16:09:32.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.244]                   3L)]
[16:09:32.244]             }
[16:09:32.244]             function(cond) {
[16:09:32.244]                 is_error <- inherits(cond, "error")
[16:09:32.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.244]                   NULL)
[16:09:32.244]                 if (is_error) {
[16:09:32.244]                   sessionInformation <- function() {
[16:09:32.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.244]                       search = base::search(), system = base::Sys.info())
[16:09:32.244]                   }
[16:09:32.244]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.244]                     cond$call), session = sessionInformation(), 
[16:09:32.244]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.244]                   signalCondition(cond)
[16:09:32.244]                 }
[16:09:32.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.244]                 "immediateCondition"))) {
[16:09:32.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.244]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.244]                   if (TRUE && !signal) {
[16:09:32.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.244]                     {
[16:09:32.244]                       inherits <- base::inherits
[16:09:32.244]                       invokeRestart <- base::invokeRestart
[16:09:32.244]                       is.null <- base::is.null
[16:09:32.244]                       muffled <- FALSE
[16:09:32.244]                       if (inherits(cond, "message")) {
[16:09:32.244]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.244]                         if (muffled) 
[16:09:32.244]                           invokeRestart("muffleMessage")
[16:09:32.244]                       }
[16:09:32.244]                       else if (inherits(cond, "warning")) {
[16:09:32.244]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.244]                         if (muffled) 
[16:09:32.244]                           invokeRestart("muffleWarning")
[16:09:32.244]                       }
[16:09:32.244]                       else if (inherits(cond, "condition")) {
[16:09:32.244]                         if (!is.null(pattern)) {
[16:09:32.244]                           computeRestarts <- base::computeRestarts
[16:09:32.244]                           grepl <- base::grepl
[16:09:32.244]                           restarts <- computeRestarts(cond)
[16:09:32.244]                           for (restart in restarts) {
[16:09:32.244]                             name <- restart$name
[16:09:32.244]                             if (is.null(name)) 
[16:09:32.244]                               next
[16:09:32.244]                             if (!grepl(pattern, name)) 
[16:09:32.244]                               next
[16:09:32.244]                             invokeRestart(restart)
[16:09:32.244]                             muffled <- TRUE
[16:09:32.244]                             break
[16:09:32.244]                           }
[16:09:32.244]                         }
[16:09:32.244]                       }
[16:09:32.244]                       invisible(muffled)
[16:09:32.244]                     }
[16:09:32.244]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.244]                   }
[16:09:32.244]                 }
[16:09:32.244]                 else {
[16:09:32.244]                   if (TRUE) {
[16:09:32.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.244]                     {
[16:09:32.244]                       inherits <- base::inherits
[16:09:32.244]                       invokeRestart <- base::invokeRestart
[16:09:32.244]                       is.null <- base::is.null
[16:09:32.244]                       muffled <- FALSE
[16:09:32.244]                       if (inherits(cond, "message")) {
[16:09:32.244]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.244]                         if (muffled) 
[16:09:32.244]                           invokeRestart("muffleMessage")
[16:09:32.244]                       }
[16:09:32.244]                       else if (inherits(cond, "warning")) {
[16:09:32.244]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.244]                         if (muffled) 
[16:09:32.244]                           invokeRestart("muffleWarning")
[16:09:32.244]                       }
[16:09:32.244]                       else if (inherits(cond, "condition")) {
[16:09:32.244]                         if (!is.null(pattern)) {
[16:09:32.244]                           computeRestarts <- base::computeRestarts
[16:09:32.244]                           grepl <- base::grepl
[16:09:32.244]                           restarts <- computeRestarts(cond)
[16:09:32.244]                           for (restart in restarts) {
[16:09:32.244]                             name <- restart$name
[16:09:32.244]                             if (is.null(name)) 
[16:09:32.244]                               next
[16:09:32.244]                             if (!grepl(pattern, name)) 
[16:09:32.244]                               next
[16:09:32.244]                             invokeRestart(restart)
[16:09:32.244]                             muffled <- TRUE
[16:09:32.244]                             break
[16:09:32.244]                           }
[16:09:32.244]                         }
[16:09:32.244]                       }
[16:09:32.244]                       invisible(muffled)
[16:09:32.244]                     }
[16:09:32.244]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.244]                   }
[16:09:32.244]                 }
[16:09:32.244]             }
[16:09:32.244]         }))
[16:09:32.244]     }, error = function(ex) {
[16:09:32.244]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.244]                 ...future.rng), started = ...future.startTime, 
[16:09:32.244]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.244]             version = "1.8"), class = "FutureResult")
[16:09:32.244]     }, finally = {
[16:09:32.244]         if (!identical(...future.workdir, getwd())) 
[16:09:32.244]             setwd(...future.workdir)
[16:09:32.244]         {
[16:09:32.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.244]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.244]             }
[16:09:32.244]             base::options(...future.oldOptions)
[16:09:32.244]             if (.Platform$OS.type == "windows") {
[16:09:32.244]                 old_names <- names(...future.oldEnvVars)
[16:09:32.244]                 envs <- base::Sys.getenv()
[16:09:32.244]                 names <- names(envs)
[16:09:32.244]                 common <- intersect(names, old_names)
[16:09:32.244]                 added <- setdiff(names, old_names)
[16:09:32.244]                 removed <- setdiff(old_names, names)
[16:09:32.244]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.244]                   envs[common]]
[16:09:32.244]                 NAMES <- toupper(changed)
[16:09:32.244]                 args <- list()
[16:09:32.244]                 for (kk in seq_along(NAMES)) {
[16:09:32.244]                   name <- changed[[kk]]
[16:09:32.244]                   NAME <- NAMES[[kk]]
[16:09:32.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.244]                     next
[16:09:32.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.244]                 }
[16:09:32.244]                 NAMES <- toupper(added)
[16:09:32.244]                 for (kk in seq_along(NAMES)) {
[16:09:32.244]                   name <- added[[kk]]
[16:09:32.244]                   NAME <- NAMES[[kk]]
[16:09:32.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.244]                     next
[16:09:32.244]                   args[[name]] <- ""
[16:09:32.244]                 }
[16:09:32.244]                 NAMES <- toupper(removed)
[16:09:32.244]                 for (kk in seq_along(NAMES)) {
[16:09:32.244]                   name <- removed[[kk]]
[16:09:32.244]                   NAME <- NAMES[[kk]]
[16:09:32.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.244]                     next
[16:09:32.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.244]                 }
[16:09:32.244]                 if (length(args) > 0) 
[16:09:32.244]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.244]             }
[16:09:32.244]             else {
[16:09:32.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.244]             }
[16:09:32.244]             {
[16:09:32.244]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.244]                   0L) {
[16:09:32.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.244]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.244]                   base::options(opts)
[16:09:32.244]                 }
[16:09:32.244]                 {
[16:09:32.244]                   {
[16:09:32.244]                     NULL
[16:09:32.244]                     RNGkind("Mersenne-Twister")
[16:09:32.244]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.244]                       inherits = FALSE)
[16:09:32.244]                   }
[16:09:32.244]                   options(future.plan = NULL)
[16:09:32.244]                   if (is.na(NA_character_)) 
[16:09:32.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.244]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:32.244]                     envir = parent.frame()) 
[16:09:32.244]                   {
[16:09:32.244]                     default_workers <- missing(workers)
[16:09:32.244]                     if (is.function(workers)) 
[16:09:32.244]                       workers <- workers()
[16:09:32.244]                     workers <- structure(as.integer(workers), 
[16:09:32.244]                       class = class(workers))
[16:09:32.244]                     stop_if_not(is.finite(workers), workers >= 
[16:09:32.244]                       1L)
[16:09:32.244]                     if ((workers == 1L && !inherits(workers, 
[16:09:32.244]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:32.244]                       if (default_workers) 
[16:09:32.244]                         supportsMulticore(warn = TRUE)
[16:09:32.244]                       return(sequential(..., envir = envir))
[16:09:32.244]                     }
[16:09:32.244]                     oopts <- options(mc.cores = workers)
[16:09:32.244]                     on.exit(options(oopts))
[16:09:32.244]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:32.244]                       envir = envir)
[16:09:32.244]                     if (!future$lazy) 
[16:09:32.244]                       future <- run(future)
[16:09:32.244]                     invisible(future)
[16:09:32.244]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.244]                 }
[16:09:32.244]             }
[16:09:32.244]         }
[16:09:32.244]     })
[16:09:32.244]     if (TRUE) {
[16:09:32.244]         base::sink(type = "output", split = FALSE)
[16:09:32.244]         if (TRUE) {
[16:09:32.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.244]         }
[16:09:32.244]         else {
[16:09:32.244]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.244]         }
[16:09:32.244]         base::close(...future.stdout)
[16:09:32.244]         ...future.stdout <- NULL
[16:09:32.244]     }
[16:09:32.244]     ...future.result$conditions <- ...future.conditions
[16:09:32.244]     ...future.result$finished <- base::Sys.time()
[16:09:32.244]     ...future.result
[16:09:32.244] }
[16:09:32.246] assign_globals() ...
[16:09:32.246] List of 5
[16:09:32.246]  $ ...future.FUN            :function (object, ...)  
[16:09:32.246]  $ future.call.arguments    :List of 1
[16:09:32.246]   ..$ digits: int 2
[16:09:32.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.246]  $ ...future.elements_ii    :List of 6
[16:09:32.246]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:09:32.246]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:09:32.246]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:09:32.246]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:09:32.246]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:09:32.246]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:09:32.246]  $ ...future.seeds_ii       : NULL
[16:09:32.246]  $ ...future.globals.maxSize: NULL
[16:09:32.246]  - attr(*, "resolved")= logi FALSE
[16:09:32.246]  - attr(*, "total_size")= num 1296
[16:09:32.246]  - attr(*, "where")=List of 5
[16:09:32.246]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.246]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.246]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.246]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.246]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.246]  - attr(*, "already-done")= logi TRUE
[16:09:32.253] - copied ‘...future.FUN’ to environment
[16:09:32.253] - copied ‘future.call.arguments’ to environment
[16:09:32.253] - copied ‘...future.elements_ii’ to environment
[16:09:32.253] - copied ‘...future.seeds_ii’ to environment
[16:09:32.253] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.253] assign_globals() ... done
[16:09:32.253] plan(): Setting new future strategy stack:
[16:09:32.254] List of future strategies:
[16:09:32.254] 1. sequential:
[16:09:32.254]    - args: function (..., envir = parent.frame())
[16:09:32.254]    - tweaked: FALSE
[16:09:32.254]    - call: NULL
[16:09:32.254] plan(): nbrOfWorkers() = 1
[16:09:32.255] plan(): Setting new future strategy stack:
[16:09:32.255] List of future strategies:
[16:09:32.255] 1. multicore:
[16:09:32.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.255]    - tweaked: FALSE
[16:09:32.255]    - call: plan(strategy)
[16:09:32.259] plan(): nbrOfWorkers() = 1
[16:09:32.259] SequentialFuture started (and completed)
[16:09:32.259] - Launch lazy future ... done
[16:09:32.259] run() for ‘SequentialFuture’ ... done
[16:09:32.259] Created future:
[16:09:32.259] SequentialFuture:
[16:09:32.259] Label: ‘future_by-1’
[16:09:32.259] Expression:
[16:09:32.259] {
[16:09:32.259]     do.call(function(...) {
[16:09:32.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.259]             on.exit(options(oopts), add = TRUE)
[16:09:32.259]         }
[16:09:32.259]         {
[16:09:32.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.259]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.259]             })
[16:09:32.259]         }
[16:09:32.259]     }, args = future.call.arguments)
[16:09:32.259] }
[16:09:32.259] Lazy evaluation: FALSE
[16:09:32.259] Asynchronous evaluation: FALSE
[16:09:32.259] Local evaluation: TRUE
[16:09:32.259] Environment: R_GlobalEnv
[16:09:32.259] Capture standard output: TRUE
[16:09:32.259] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.259] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.259] Packages: <none>
[16:09:32.259] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.259] Resolved: TRUE
[16:09:32.259] Value: 5.48 KiB of class ‘list’
[16:09:32.259] Early signaling: FALSE
[16:09:32.259] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.259] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.260] Chunk #1 of 1 ... DONE
[16:09:32.260] Launching 1 futures (chunks) ... DONE
[16:09:32.261] Resolving 1 futures (chunks) ...
[16:09:32.261] resolve() on list ...
[16:09:32.261]  recursive: 0
[16:09:32.261]  length: 1
[16:09:32.261] 
[16:09:32.261] resolved() for ‘SequentialFuture’ ...
[16:09:32.261] - state: ‘finished’
[16:09:32.261] - run: TRUE
[16:09:32.261] - result: ‘FutureResult’
[16:09:32.261] resolved() for ‘SequentialFuture’ ... done
[16:09:32.286] Future #1
[16:09:32.286] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.286] - nx: 1
[16:09:32.287] - relay: TRUE
[16:09:32.287] - stdout: TRUE
[16:09:32.287] - signal: TRUE
[16:09:32.287] - resignal: FALSE
[16:09:32.287] - force: TRUE
[16:09:32.287] - relayed: [n=1] FALSE
[16:09:32.287] - queued futures: [n=1] FALSE
[16:09:32.287]  - until=1
[16:09:32.287]  - relaying element #1
[16:09:32.288] - relayed: [n=1] TRUE
[16:09:32.288] - queued futures: [n=1] TRUE
[16:09:32.288] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.288]  length: 0 (resolved future 1)
[16:09:32.288] Relaying remaining futures
[16:09:32.288] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.288] - nx: 1
[16:09:32.288] - relay: TRUE
[16:09:32.288] - stdout: TRUE
[16:09:32.288] - signal: TRUE
[16:09:32.289] - resignal: FALSE
[16:09:32.289] - force: TRUE
[16:09:32.289] - relayed: [n=1] TRUE
[16:09:32.289] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.289] - relayed: [n=1] TRUE
[16:09:32.289] - queued futures: [n=1] TRUE
[16:09:32.289] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.289] resolve() on list ... DONE
[16:09:32.289]  - Number of value chunks collected: 1
[16:09:32.289] Resolving 1 futures (chunks) ... DONE
[16:09:32.289] Reducing values from 1 chunks ...
[16:09:32.290]  - Number of values collected after concatenation: 6
[16:09:32.290]  - Number of values expected: 6
[16:09:32.290] Reducing values from 1 chunks ... DONE
[16:09:32.290] future_lapply() ... DONE
[16:09:32.290] future_by_internal() ... DONE
[16:09:32.291] future_by_internal() ...
[16:09:32.291] future_lapply() ...
[16:09:32.295] Number of chunks: 1
[16:09:32.295] getGlobalsAndPackagesXApply() ...
[16:09:32.295]  - future.globals: TRUE
[16:09:32.296] getGlobalsAndPackages() ...
[16:09:32.296] Searching for globals...
[16:09:32.297] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.297] Searching for globals ... DONE
[16:09:32.297] Resolving globals: FALSE
[16:09:32.298] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:09:32.298] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:09:32.298] - globals: [1] ‘FUN’
[16:09:32.298] - packages: [1] ‘stats’
[16:09:32.298] getGlobalsAndPackages() ... DONE
[16:09:32.299]  - globals found/used: [n=1] ‘FUN’
[16:09:32.299]  - needed namespaces: [n=1] ‘stats’
[16:09:32.299] Finding globals ... DONE
[16:09:32.299]  - use_args: TRUE
[16:09:32.299]  - Getting '...' globals ...
[16:09:32.299] resolve() on list ...
[16:09:32.299]  recursive: 0
[16:09:32.299]  length: 1
[16:09:32.299]  elements: ‘...’
[16:09:32.300]  length: 0 (resolved future 1)
[16:09:32.300] resolve() on list ... DONE
[16:09:32.300]    - '...' content: [n=1] ‘singular.ok’
[16:09:32.300] List of 1
[16:09:32.300]  $ ...:List of 1
[16:09:32.300]   ..$ singular.ok: logi FALSE
[16:09:32.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.300]  - attr(*, "where")=List of 1
[16:09:32.300]   ..$ ...:<environment: 0x5567e740b928> 
[16:09:32.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.300]  - attr(*, "resolved")= logi TRUE
[16:09:32.300]  - attr(*, "total_size")= num NA
[16:09:32.303]  - Getting '...' globals ... DONE
[16:09:32.303] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.303] List of 2
[16:09:32.303]  $ ...future.FUN:function (x, ...)  
[16:09:32.303]  $ ...          :List of 1
[16:09:32.303]   ..$ singular.ok: logi FALSE
[16:09:32.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.303]  - attr(*, "where")=List of 2
[16:09:32.303]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.303]   ..$ ...          :<environment: 0x5567e740b928> 
[16:09:32.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.303]  - attr(*, "resolved")= logi FALSE
[16:09:32.303]  - attr(*, "total_size")= num 5384
[16:09:32.306] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.306] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.306] Number of futures (= number of chunks): 1
[16:09:32.306] Launching 1 futures (chunks) ...
[16:09:32.306] Chunk #1 of 1 ...
[16:09:32.307]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.307] getGlobalsAndPackages() ...
[16:09:32.307] Searching for globals...
[16:09:32.307] 
[16:09:32.307] Searching for globals ... DONE
[16:09:32.307] - globals: [0] <none>
[16:09:32.308] getGlobalsAndPackages() ... DONE
[16:09:32.308]    + additional globals found: [n=0] 
[16:09:32.308]    + additional namespaces needed: [n=0] 
[16:09:32.308]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.308]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.309]  - seeds: <none>
[16:09:32.309] getGlobalsAndPackages() ...
[16:09:32.309] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.309] Resolving globals: FALSE
[16:09:32.309] Tweak future expression to call with '...' arguments ...
[16:09:32.309] {
[16:09:32.309]     do.call(function(...) {
[16:09:32.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.309]             on.exit(options(oopts), add = TRUE)
[16:09:32.309]         }
[16:09:32.309]         {
[16:09:32.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.309]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.309]             })
[16:09:32.309]         }
[16:09:32.309]     }, args = future.call.arguments)
[16:09:32.309] }
[16:09:32.310] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.310] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.310] 
[16:09:32.310] getGlobalsAndPackages() ... DONE
[16:09:32.311] run() for ‘Future’ ...
[16:09:32.311] - state: ‘created’
[16:09:32.311] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.314] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.314]   - Field: ‘label’
[16:09:32.315]   - Field: ‘local’
[16:09:32.315]   - Field: ‘owner’
[16:09:32.315]   - Field: ‘envir’
[16:09:32.315]   - Field: ‘packages’
[16:09:32.315]   - Field: ‘gc’
[16:09:32.315]   - Field: ‘conditions’
[16:09:32.315]   - Field: ‘expr’
[16:09:32.315]   - Field: ‘uuid’
[16:09:32.315]   - Field: ‘seed’
[16:09:32.315]   - Field: ‘version’
[16:09:32.315]   - Field: ‘result’
[16:09:32.316]   - Field: ‘asynchronous’
[16:09:32.316]   - Field: ‘calls’
[16:09:32.316]   - Field: ‘globals’
[16:09:32.316]   - Field: ‘stdout’
[16:09:32.316]   - Field: ‘earlySignal’
[16:09:32.316]   - Field: ‘lazy’
[16:09:32.316]   - Field: ‘state’
[16:09:32.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.316] - Launch lazy future ...
[16:09:32.316] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.317] Packages needed by future strategies (n = 0): <none>
[16:09:32.317] {
[16:09:32.317]     {
[16:09:32.317]         {
[16:09:32.317]             ...future.startTime <- base::Sys.time()
[16:09:32.317]             {
[16:09:32.317]                 {
[16:09:32.317]                   {
[16:09:32.317]                     {
[16:09:32.317]                       base::local({
[16:09:32.317]                         has_future <- base::requireNamespace("future", 
[16:09:32.317]                           quietly = TRUE)
[16:09:32.317]                         if (has_future) {
[16:09:32.317]                           ns <- base::getNamespace("future")
[16:09:32.317]                           version <- ns[[".package"]][["version"]]
[16:09:32.317]                           if (is.null(version)) 
[16:09:32.317]                             version <- utils::packageVersion("future")
[16:09:32.317]                         }
[16:09:32.317]                         else {
[16:09:32.317]                           version <- NULL
[16:09:32.317]                         }
[16:09:32.317]                         if (!has_future || version < "1.8.0") {
[16:09:32.317]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.317]                             "", base::R.version$version.string), 
[16:09:32.317]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.317]                               "release", "version")], collapse = " "), 
[16:09:32.317]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.317]                             info)
[16:09:32.317]                           info <- base::paste(info, collapse = "; ")
[16:09:32.317]                           if (!has_future) {
[16:09:32.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.317]                               info)
[16:09:32.317]                           }
[16:09:32.317]                           else {
[16:09:32.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.317]                               info, version)
[16:09:32.317]                           }
[16:09:32.317]                           base::stop(msg)
[16:09:32.317]                         }
[16:09:32.317]                       })
[16:09:32.317]                     }
[16:09:32.317]                     base::local({
[16:09:32.317]                       for (pkg in "stats") {
[16:09:32.317]                         base::loadNamespace(pkg)
[16:09:32.317]                         base::library(pkg, character.only = TRUE)
[16:09:32.317]                       }
[16:09:32.317]                     })
[16:09:32.317]                   }
[16:09:32.317]                   options(future.plan = NULL)
[16:09:32.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.317]                 }
[16:09:32.317]                 ...future.workdir <- getwd()
[16:09:32.317]             }
[16:09:32.317]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.317]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.317]         }
[16:09:32.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.317]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.317]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.317]             base::names(...future.oldOptions))
[16:09:32.317]     }
[16:09:32.317]     if (FALSE) {
[16:09:32.317]     }
[16:09:32.317]     else {
[16:09:32.317]         if (TRUE) {
[16:09:32.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.317]                 open = "w")
[16:09:32.317]         }
[16:09:32.317]         else {
[16:09:32.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.317]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.317]         }
[16:09:32.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.317]             base::sink(type = "output", split = FALSE)
[16:09:32.317]             base::close(...future.stdout)
[16:09:32.317]         }, add = TRUE)
[16:09:32.317]     }
[16:09:32.317]     ...future.frame <- base::sys.nframe()
[16:09:32.317]     ...future.conditions <- base::list()
[16:09:32.317]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.317]     if (FALSE) {
[16:09:32.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.317]     }
[16:09:32.317]     ...future.result <- base::tryCatch({
[16:09:32.317]         base::withCallingHandlers({
[16:09:32.317]             ...future.value <- base::withVisible(base::local({
[16:09:32.317]                 do.call(function(...) {
[16:09:32.317]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.317]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.317]                     ...future.globals.maxSize)) {
[16:09:32.317]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.317]                     on.exit(options(oopts), add = TRUE)
[16:09:32.317]                   }
[16:09:32.317]                   {
[16:09:32.317]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.317]                       FUN = function(jj) {
[16:09:32.317]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.317]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.317]                       })
[16:09:32.317]                   }
[16:09:32.317]                 }, args = future.call.arguments)
[16:09:32.317]             }))
[16:09:32.317]             future::FutureResult(value = ...future.value$value, 
[16:09:32.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.317]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.317]                     ...future.globalenv.names))
[16:09:32.317]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.317]         }, condition = base::local({
[16:09:32.317]             c <- base::c
[16:09:32.317]             inherits <- base::inherits
[16:09:32.317]             invokeRestart <- base::invokeRestart
[16:09:32.317]             length <- base::length
[16:09:32.317]             list <- base::list
[16:09:32.317]             seq.int <- base::seq.int
[16:09:32.317]             signalCondition <- base::signalCondition
[16:09:32.317]             sys.calls <- base::sys.calls
[16:09:32.317]             `[[` <- base::`[[`
[16:09:32.317]             `+` <- base::`+`
[16:09:32.317]             `<<-` <- base::`<<-`
[16:09:32.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.317]                   3L)]
[16:09:32.317]             }
[16:09:32.317]             function(cond) {
[16:09:32.317]                 is_error <- inherits(cond, "error")
[16:09:32.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.317]                   NULL)
[16:09:32.317]                 if (is_error) {
[16:09:32.317]                   sessionInformation <- function() {
[16:09:32.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.317]                       search = base::search(), system = base::Sys.info())
[16:09:32.317]                   }
[16:09:32.317]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.317]                     cond$call), session = sessionInformation(), 
[16:09:32.317]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.317]                   signalCondition(cond)
[16:09:32.317]                 }
[16:09:32.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.317]                 "immediateCondition"))) {
[16:09:32.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.317]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.317]                   if (TRUE && !signal) {
[16:09:32.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.317]                     {
[16:09:32.317]                       inherits <- base::inherits
[16:09:32.317]                       invokeRestart <- base::invokeRestart
[16:09:32.317]                       is.null <- base::is.null
[16:09:32.317]                       muffled <- FALSE
[16:09:32.317]                       if (inherits(cond, "message")) {
[16:09:32.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.317]                         if (muffled) 
[16:09:32.317]                           invokeRestart("muffleMessage")
[16:09:32.317]                       }
[16:09:32.317]                       else if (inherits(cond, "warning")) {
[16:09:32.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.317]                         if (muffled) 
[16:09:32.317]                           invokeRestart("muffleWarning")
[16:09:32.317]                       }
[16:09:32.317]                       else if (inherits(cond, "condition")) {
[16:09:32.317]                         if (!is.null(pattern)) {
[16:09:32.317]                           computeRestarts <- base::computeRestarts
[16:09:32.317]                           grepl <- base::grepl
[16:09:32.317]                           restarts <- computeRestarts(cond)
[16:09:32.317]                           for (restart in restarts) {
[16:09:32.317]                             name <- restart$name
[16:09:32.317]                             if (is.null(name)) 
[16:09:32.317]                               next
[16:09:32.317]                             if (!grepl(pattern, name)) 
[16:09:32.317]                               next
[16:09:32.317]                             invokeRestart(restart)
[16:09:32.317]                             muffled <- TRUE
[16:09:32.317]                             break
[16:09:32.317]                           }
[16:09:32.317]                         }
[16:09:32.317]                       }
[16:09:32.317]                       invisible(muffled)
[16:09:32.317]                     }
[16:09:32.317]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.317]                   }
[16:09:32.317]                 }
[16:09:32.317]                 else {
[16:09:32.317]                   if (TRUE) {
[16:09:32.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.317]                     {
[16:09:32.317]                       inherits <- base::inherits
[16:09:32.317]                       invokeRestart <- base::invokeRestart
[16:09:32.317]                       is.null <- base::is.null
[16:09:32.317]                       muffled <- FALSE
[16:09:32.317]                       if (inherits(cond, "message")) {
[16:09:32.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.317]                         if (muffled) 
[16:09:32.317]                           invokeRestart("muffleMessage")
[16:09:32.317]                       }
[16:09:32.317]                       else if (inherits(cond, "warning")) {
[16:09:32.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.317]                         if (muffled) 
[16:09:32.317]                           invokeRestart("muffleWarning")
[16:09:32.317]                       }
[16:09:32.317]                       else if (inherits(cond, "condition")) {
[16:09:32.317]                         if (!is.null(pattern)) {
[16:09:32.317]                           computeRestarts <- base::computeRestarts
[16:09:32.317]                           grepl <- base::grepl
[16:09:32.317]                           restarts <- computeRestarts(cond)
[16:09:32.317]                           for (restart in restarts) {
[16:09:32.317]                             name <- restart$name
[16:09:32.317]                             if (is.null(name)) 
[16:09:32.317]                               next
[16:09:32.317]                             if (!grepl(pattern, name)) 
[16:09:32.317]                               next
[16:09:32.317]                             invokeRestart(restart)
[16:09:32.317]                             muffled <- TRUE
[16:09:32.317]                             break
[16:09:32.317]                           }
[16:09:32.317]                         }
[16:09:32.317]                       }
[16:09:32.317]                       invisible(muffled)
[16:09:32.317]                     }
[16:09:32.317]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.317]                   }
[16:09:32.317]                 }
[16:09:32.317]             }
[16:09:32.317]         }))
[16:09:32.317]     }, error = function(ex) {
[16:09:32.317]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.317]                 ...future.rng), started = ...future.startTime, 
[16:09:32.317]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.317]             version = "1.8"), class = "FutureResult")
[16:09:32.317]     }, finally = {
[16:09:32.317]         if (!identical(...future.workdir, getwd())) 
[16:09:32.317]             setwd(...future.workdir)
[16:09:32.317]         {
[16:09:32.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.317]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.317]             }
[16:09:32.317]             base::options(...future.oldOptions)
[16:09:32.317]             if (.Platform$OS.type == "windows") {
[16:09:32.317]                 old_names <- names(...future.oldEnvVars)
[16:09:32.317]                 envs <- base::Sys.getenv()
[16:09:32.317]                 names <- names(envs)
[16:09:32.317]                 common <- intersect(names, old_names)
[16:09:32.317]                 added <- setdiff(names, old_names)
[16:09:32.317]                 removed <- setdiff(old_names, names)
[16:09:32.317]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.317]                   envs[common]]
[16:09:32.317]                 NAMES <- toupper(changed)
[16:09:32.317]                 args <- list()
[16:09:32.317]                 for (kk in seq_along(NAMES)) {
[16:09:32.317]                   name <- changed[[kk]]
[16:09:32.317]                   NAME <- NAMES[[kk]]
[16:09:32.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.317]                     next
[16:09:32.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.317]                 }
[16:09:32.317]                 NAMES <- toupper(added)
[16:09:32.317]                 for (kk in seq_along(NAMES)) {
[16:09:32.317]                   name <- added[[kk]]
[16:09:32.317]                   NAME <- NAMES[[kk]]
[16:09:32.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.317]                     next
[16:09:32.317]                   args[[name]] <- ""
[16:09:32.317]                 }
[16:09:32.317]                 NAMES <- toupper(removed)
[16:09:32.317]                 for (kk in seq_along(NAMES)) {
[16:09:32.317]                   name <- removed[[kk]]
[16:09:32.317]                   NAME <- NAMES[[kk]]
[16:09:32.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.317]                     next
[16:09:32.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.317]                 }
[16:09:32.317]                 if (length(args) > 0) 
[16:09:32.317]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.317]             }
[16:09:32.317]             else {
[16:09:32.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.317]             }
[16:09:32.317]             {
[16:09:32.317]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.317]                   0L) {
[16:09:32.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.317]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.317]                   base::options(opts)
[16:09:32.317]                 }
[16:09:32.317]                 {
[16:09:32.317]                   {
[16:09:32.317]                     NULL
[16:09:32.317]                     RNGkind("Mersenne-Twister")
[16:09:32.317]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.317]                       inherits = FALSE)
[16:09:32.317]                   }
[16:09:32.317]                   options(future.plan = NULL)
[16:09:32.317]                   if (is.na(NA_character_)) 
[16:09:32.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.317]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:32.317]                     envir = parent.frame()) 
[16:09:32.317]                   {
[16:09:32.317]                     default_workers <- missing(workers)
[16:09:32.317]                     if (is.function(workers)) 
[16:09:32.317]                       workers <- workers()
[16:09:32.317]                     workers <- structure(as.integer(workers), 
[16:09:32.317]                       class = class(workers))
[16:09:32.317]                     stop_if_not(is.finite(workers), workers >= 
[16:09:32.317]                       1L)
[16:09:32.317]                     if ((workers == 1L && !inherits(workers, 
[16:09:32.317]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:32.317]                       if (default_workers) 
[16:09:32.317]                         supportsMulticore(warn = TRUE)
[16:09:32.317]                       return(sequential(..., envir = envir))
[16:09:32.317]                     }
[16:09:32.317]                     oopts <- options(mc.cores = workers)
[16:09:32.317]                     on.exit(options(oopts))
[16:09:32.317]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:32.317]                       envir = envir)
[16:09:32.317]                     if (!future$lazy) 
[16:09:32.317]                       future <- run(future)
[16:09:32.317]                     invisible(future)
[16:09:32.317]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.317]                 }
[16:09:32.317]             }
[16:09:32.317]         }
[16:09:32.317]     })
[16:09:32.317]     if (TRUE) {
[16:09:32.317]         base::sink(type = "output", split = FALSE)
[16:09:32.317]         if (TRUE) {
[16:09:32.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.317]         }
[16:09:32.317]         else {
[16:09:32.317]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.317]         }
[16:09:32.317]         base::close(...future.stdout)
[16:09:32.317]         ...future.stdout <- NULL
[16:09:32.317]     }
[16:09:32.317]     ...future.result$conditions <- ...future.conditions
[16:09:32.317]     ...future.result$finished <- base::Sys.time()
[16:09:32.317]     ...future.result
[16:09:32.317] }
[16:09:32.319] assign_globals() ...
[16:09:32.319] List of 5
[16:09:32.319]  $ ...future.FUN            :function (x, ...)  
[16:09:32.319]  $ future.call.arguments    :List of 1
[16:09:32.319]   ..$ singular.ok: logi FALSE
[16:09:32.319]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.319]  $ ...future.elements_ii    :List of 3
[16:09:32.319]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.319]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.319]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.319]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.319]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.319]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.319]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.319]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.319]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.319]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.319]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.319]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.319]  $ ...future.seeds_ii       : NULL
[16:09:32.319]  $ ...future.globals.maxSize: NULL
[16:09:32.319]  - attr(*, "resolved")= logi FALSE
[16:09:32.319]  - attr(*, "total_size")= num 5384
[16:09:32.319]  - attr(*, "where")=List of 5
[16:09:32.319]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.319]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.319]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.319]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.319]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.319]  - attr(*, "already-done")= logi TRUE
[16:09:32.327] - reassign environment for ‘...future.FUN’
[16:09:32.327] - copied ‘...future.FUN’ to environment
[16:09:32.328] - copied ‘future.call.arguments’ to environment
[16:09:32.328] - copied ‘...future.elements_ii’ to environment
[16:09:32.328] - copied ‘...future.seeds_ii’ to environment
[16:09:32.328] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.328] assign_globals() ... done
[16:09:32.328] plan(): Setting new future strategy stack:
[16:09:32.328] List of future strategies:
[16:09:32.328] 1. sequential:
[16:09:32.328]    - args: function (..., envir = parent.frame())
[16:09:32.328]    - tweaked: FALSE
[16:09:32.328]    - call: NULL
[16:09:32.329] plan(): nbrOfWorkers() = 1
[16:09:32.331] plan(): Setting new future strategy stack:
[16:09:32.332] List of future strategies:
[16:09:32.332] 1. multicore:
[16:09:32.332]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.332]    - tweaked: FALSE
[16:09:32.332]    - call: plan(strategy)
[16:09:32.336] plan(): nbrOfWorkers() = 1
[16:09:32.336] SequentialFuture started (and completed)
[16:09:32.336] - Launch lazy future ... done
[16:09:32.336] run() for ‘SequentialFuture’ ... done
[16:09:32.336] Created future:
[16:09:32.337] SequentialFuture:
[16:09:32.337] Label: ‘future_by-1’
[16:09:32.337] Expression:
[16:09:32.337] {
[16:09:32.337]     do.call(function(...) {
[16:09:32.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.337]             on.exit(options(oopts), add = TRUE)
[16:09:32.337]         }
[16:09:32.337]         {
[16:09:32.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.337]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.337]             })
[16:09:32.337]         }
[16:09:32.337]     }, args = future.call.arguments)
[16:09:32.337] }
[16:09:32.337] Lazy evaluation: FALSE
[16:09:32.337] Asynchronous evaluation: FALSE
[16:09:32.337] Local evaluation: TRUE
[16:09:32.337] Environment: R_GlobalEnv
[16:09:32.337] Capture standard output: TRUE
[16:09:32.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.337] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.337] Packages: 1 packages (‘stats’)
[16:09:32.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.337] Resolved: TRUE
[16:09:32.337] Value: 26.06 KiB of class ‘list’
[16:09:32.337] Early signaling: FALSE
[16:09:32.337] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.337] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.338] Chunk #1 of 1 ... DONE
[16:09:32.338] Launching 1 futures (chunks) ... DONE
[16:09:32.338] Resolving 1 futures (chunks) ...
[16:09:32.338] resolve() on list ...
[16:09:32.338]  recursive: 0
[16:09:32.338]  length: 1
[16:09:32.339] 
[16:09:32.339] resolved() for ‘SequentialFuture’ ...
[16:09:32.339] - state: ‘finished’
[16:09:32.339] - run: TRUE
[16:09:32.339] - result: ‘FutureResult’
[16:09:32.339] resolved() for ‘SequentialFuture’ ... done
[16:09:32.339] Future #1
[16:09:32.339] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.339] - nx: 1
[16:09:32.339] - relay: TRUE
[16:09:32.340] - stdout: TRUE
[16:09:32.340] - signal: TRUE
[16:09:32.340] - resignal: FALSE
[16:09:32.340] - force: TRUE
[16:09:32.340] - relayed: [n=1] FALSE
[16:09:32.340] - queued futures: [n=1] FALSE
[16:09:32.340]  - until=1
[16:09:32.340]  - relaying element #1
[16:09:32.340] - relayed: [n=1] TRUE
[16:09:32.340] - queued futures: [n=1] TRUE
[16:09:32.340] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.341]  length: 0 (resolved future 1)
[16:09:32.341] Relaying remaining futures
[16:09:32.341] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.341] - nx: 1
[16:09:32.341] - relay: TRUE
[16:09:32.341] - stdout: TRUE
[16:09:32.341] - signal: TRUE
[16:09:32.341] - resignal: FALSE
[16:09:32.341] - force: TRUE
[16:09:32.341] - relayed: [n=1] TRUE
[16:09:32.341] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.341] - relayed: [n=1] TRUE
[16:09:32.342] - queued futures: [n=1] TRUE
[16:09:32.342] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.342] resolve() on list ... DONE
[16:09:32.342]  - Number of value chunks collected: 1
[16:09:32.342] Resolving 1 futures (chunks) ... DONE
[16:09:32.342] Reducing values from 1 chunks ...
[16:09:32.342]  - Number of values collected after concatenation: 3
[16:09:32.342]  - Number of values expected: 3
[16:09:32.342] Reducing values from 1 chunks ... DONE
[16:09:32.342] future_lapply() ... DONE
[16:09:32.342] future_by_internal() ... DONE
[16:09:32.346] future_by_internal() ...
[16:09:32.347] future_lapply() ...
[16:09:32.350] Number of chunks: 1
[16:09:32.350] getGlobalsAndPackagesXApply() ...
[16:09:32.351]  - future.globals: TRUE
[16:09:32.351] getGlobalsAndPackages() ...
[16:09:32.351] Searching for globals...
[16:09:32.352] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.353] Searching for globals ... DONE
[16:09:32.353] Resolving globals: FALSE
[16:09:32.353] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:09:32.353] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:09:32.354] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.354] - packages: [1] ‘stats’
[16:09:32.354] getGlobalsAndPackages() ... DONE
[16:09:32.354]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.354]  - needed namespaces: [n=1] ‘stats’
[16:09:32.354] Finding globals ... DONE
[16:09:32.354]  - use_args: TRUE
[16:09:32.354]  - Getting '...' globals ...
[16:09:32.355] resolve() on list ...
[16:09:32.355]  recursive: 0
[16:09:32.355]  length: 1
[16:09:32.355]  elements: ‘...’
[16:09:32.355]  length: 0 (resolved future 1)
[16:09:32.355] resolve() on list ... DONE
[16:09:32.355]    - '...' content: [n=0] 
[16:09:32.355] List of 1
[16:09:32.355]  $ ...: list()
[16:09:32.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.355]  - attr(*, "where")=List of 1
[16:09:32.355]   ..$ ...:<environment: 0x5567e8d45a78> 
[16:09:32.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.355]  - attr(*, "resolved")= logi TRUE
[16:09:32.355]  - attr(*, "total_size")= num NA
[16:09:32.359]  - Getting '...' globals ... DONE
[16:09:32.359] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:09:32.359] List of 4
[16:09:32.359]  $ ...future.FUN:function (x)  
[16:09:32.359]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.359]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.359]  $ ...          : list()
[16:09:32.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.359]  - attr(*, "where")=List of 4
[16:09:32.359]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.359]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:09:32.359]   ..$ wool         :<environment: R_EmptyEnv> 
[16:09:32.359]   ..$ ...          :<environment: 0x5567e8d45a78> 
[16:09:32.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.359]  - attr(*, "resolved")= logi FALSE
[16:09:32.359]  - attr(*, "total_size")= num 2320
[16:09:32.363] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.363] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.363] Number of futures (= number of chunks): 1
[16:09:32.363] Launching 1 futures (chunks) ...
[16:09:32.363] Chunk #1 of 1 ...
[16:09:32.363]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.363] getGlobalsAndPackages() ...
[16:09:32.363] Searching for globals...
[16:09:32.364] 
[16:09:32.364] Searching for globals ... DONE
[16:09:32.364] - globals: [0] <none>
[16:09:32.364] getGlobalsAndPackages() ... DONE
[16:09:32.364]    + additional globals found: [n=0] 
[16:09:32.364]    + additional namespaces needed: [n=0] 
[16:09:32.364]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.365]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.365]  - seeds: <none>
[16:09:32.365] getGlobalsAndPackages() ...
[16:09:32.365] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.365] Resolving globals: FALSE
[16:09:32.365] Tweak future expression to call with '...' arguments ...
[16:09:32.365] {
[16:09:32.365]     do.call(function(...) {
[16:09:32.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.365]             on.exit(options(oopts), add = TRUE)
[16:09:32.365]         }
[16:09:32.365]         {
[16:09:32.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.365]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.365]             })
[16:09:32.365]         }
[16:09:32.365]     }, args = future.call.arguments)
[16:09:32.365] }
[16:09:32.365] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.366] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.366] 
[16:09:32.366] getGlobalsAndPackages() ... DONE
[16:09:32.366] run() for ‘Future’ ...
[16:09:32.366] - state: ‘created’
[16:09:32.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.370] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.370] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.370]   - Field: ‘label’
[16:09:32.370]   - Field: ‘local’
[16:09:32.370]   - Field: ‘owner’
[16:09:32.370]   - Field: ‘envir’
[16:09:32.371]   - Field: ‘packages’
[16:09:32.371]   - Field: ‘gc’
[16:09:32.371]   - Field: ‘conditions’
[16:09:32.371]   - Field: ‘expr’
[16:09:32.371]   - Field: ‘uuid’
[16:09:32.371]   - Field: ‘seed’
[16:09:32.371]   - Field: ‘version’
[16:09:32.371]   - Field: ‘result’
[16:09:32.371]   - Field: ‘asynchronous’
[16:09:32.371]   - Field: ‘calls’
[16:09:32.371]   - Field: ‘globals’
[16:09:32.372]   - Field: ‘stdout’
[16:09:32.372]   - Field: ‘earlySignal’
[16:09:32.372]   - Field: ‘lazy’
[16:09:32.372]   - Field: ‘state’
[16:09:32.372] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.372] - Launch lazy future ...
[16:09:32.372] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.372] Packages needed by future strategies (n = 0): <none>
[16:09:32.373] {
[16:09:32.373]     {
[16:09:32.373]         {
[16:09:32.373]             ...future.startTime <- base::Sys.time()
[16:09:32.373]             {
[16:09:32.373]                 {
[16:09:32.373]                   {
[16:09:32.373]                     {
[16:09:32.373]                       base::local({
[16:09:32.373]                         has_future <- base::requireNamespace("future", 
[16:09:32.373]                           quietly = TRUE)
[16:09:32.373]                         if (has_future) {
[16:09:32.373]                           ns <- base::getNamespace("future")
[16:09:32.373]                           version <- ns[[".package"]][["version"]]
[16:09:32.373]                           if (is.null(version)) 
[16:09:32.373]                             version <- utils::packageVersion("future")
[16:09:32.373]                         }
[16:09:32.373]                         else {
[16:09:32.373]                           version <- NULL
[16:09:32.373]                         }
[16:09:32.373]                         if (!has_future || version < "1.8.0") {
[16:09:32.373]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.373]                             "", base::R.version$version.string), 
[16:09:32.373]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.373]                               "release", "version")], collapse = " "), 
[16:09:32.373]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.373]                             info)
[16:09:32.373]                           info <- base::paste(info, collapse = "; ")
[16:09:32.373]                           if (!has_future) {
[16:09:32.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.373]                               info)
[16:09:32.373]                           }
[16:09:32.373]                           else {
[16:09:32.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.373]                               info, version)
[16:09:32.373]                           }
[16:09:32.373]                           base::stop(msg)
[16:09:32.373]                         }
[16:09:32.373]                       })
[16:09:32.373]                     }
[16:09:32.373]                     base::local({
[16:09:32.373]                       for (pkg in "stats") {
[16:09:32.373]                         base::loadNamespace(pkg)
[16:09:32.373]                         base::library(pkg, character.only = TRUE)
[16:09:32.373]                       }
[16:09:32.373]                     })
[16:09:32.373]                   }
[16:09:32.373]                   options(future.plan = NULL)
[16:09:32.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.373]                 }
[16:09:32.373]                 ...future.workdir <- getwd()
[16:09:32.373]             }
[16:09:32.373]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.373]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.373]         }
[16:09:32.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.373]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.373]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.373]             base::names(...future.oldOptions))
[16:09:32.373]     }
[16:09:32.373]     if (FALSE) {
[16:09:32.373]     }
[16:09:32.373]     else {
[16:09:32.373]         if (TRUE) {
[16:09:32.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.373]                 open = "w")
[16:09:32.373]         }
[16:09:32.373]         else {
[16:09:32.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.373]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.373]         }
[16:09:32.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.373]             base::sink(type = "output", split = FALSE)
[16:09:32.373]             base::close(...future.stdout)
[16:09:32.373]         }, add = TRUE)
[16:09:32.373]     }
[16:09:32.373]     ...future.frame <- base::sys.nframe()
[16:09:32.373]     ...future.conditions <- base::list()
[16:09:32.373]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.373]     if (FALSE) {
[16:09:32.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.373]     }
[16:09:32.373]     ...future.result <- base::tryCatch({
[16:09:32.373]         base::withCallingHandlers({
[16:09:32.373]             ...future.value <- base::withVisible(base::local({
[16:09:32.373]                 do.call(function(...) {
[16:09:32.373]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.373]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.373]                     ...future.globals.maxSize)) {
[16:09:32.373]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.373]                     on.exit(options(oopts), add = TRUE)
[16:09:32.373]                   }
[16:09:32.373]                   {
[16:09:32.373]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.373]                       FUN = function(jj) {
[16:09:32.373]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.373]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.373]                       })
[16:09:32.373]                   }
[16:09:32.373]                 }, args = future.call.arguments)
[16:09:32.373]             }))
[16:09:32.373]             future::FutureResult(value = ...future.value$value, 
[16:09:32.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.373]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.373]                     ...future.globalenv.names))
[16:09:32.373]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.373]         }, condition = base::local({
[16:09:32.373]             c <- base::c
[16:09:32.373]             inherits <- base::inherits
[16:09:32.373]             invokeRestart <- base::invokeRestart
[16:09:32.373]             length <- base::length
[16:09:32.373]             list <- base::list
[16:09:32.373]             seq.int <- base::seq.int
[16:09:32.373]             signalCondition <- base::signalCondition
[16:09:32.373]             sys.calls <- base::sys.calls
[16:09:32.373]             `[[` <- base::`[[`
[16:09:32.373]             `+` <- base::`+`
[16:09:32.373]             `<<-` <- base::`<<-`
[16:09:32.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.373]                   3L)]
[16:09:32.373]             }
[16:09:32.373]             function(cond) {
[16:09:32.373]                 is_error <- inherits(cond, "error")
[16:09:32.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.373]                   NULL)
[16:09:32.373]                 if (is_error) {
[16:09:32.373]                   sessionInformation <- function() {
[16:09:32.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.373]                       search = base::search(), system = base::Sys.info())
[16:09:32.373]                   }
[16:09:32.373]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.373]                     cond$call), session = sessionInformation(), 
[16:09:32.373]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.373]                   signalCondition(cond)
[16:09:32.373]                 }
[16:09:32.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.373]                 "immediateCondition"))) {
[16:09:32.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.373]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.373]                   if (TRUE && !signal) {
[16:09:32.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.373]                     {
[16:09:32.373]                       inherits <- base::inherits
[16:09:32.373]                       invokeRestart <- base::invokeRestart
[16:09:32.373]                       is.null <- base::is.null
[16:09:32.373]                       muffled <- FALSE
[16:09:32.373]                       if (inherits(cond, "message")) {
[16:09:32.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.373]                         if (muffled) 
[16:09:32.373]                           invokeRestart("muffleMessage")
[16:09:32.373]                       }
[16:09:32.373]                       else if (inherits(cond, "warning")) {
[16:09:32.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.373]                         if (muffled) 
[16:09:32.373]                           invokeRestart("muffleWarning")
[16:09:32.373]                       }
[16:09:32.373]                       else if (inherits(cond, "condition")) {
[16:09:32.373]                         if (!is.null(pattern)) {
[16:09:32.373]                           computeRestarts <- base::computeRestarts
[16:09:32.373]                           grepl <- base::grepl
[16:09:32.373]                           restarts <- computeRestarts(cond)
[16:09:32.373]                           for (restart in restarts) {
[16:09:32.373]                             name <- restart$name
[16:09:32.373]                             if (is.null(name)) 
[16:09:32.373]                               next
[16:09:32.373]                             if (!grepl(pattern, name)) 
[16:09:32.373]                               next
[16:09:32.373]                             invokeRestart(restart)
[16:09:32.373]                             muffled <- TRUE
[16:09:32.373]                             break
[16:09:32.373]                           }
[16:09:32.373]                         }
[16:09:32.373]                       }
[16:09:32.373]                       invisible(muffled)
[16:09:32.373]                     }
[16:09:32.373]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.373]                   }
[16:09:32.373]                 }
[16:09:32.373]                 else {
[16:09:32.373]                   if (TRUE) {
[16:09:32.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.373]                     {
[16:09:32.373]                       inherits <- base::inherits
[16:09:32.373]                       invokeRestart <- base::invokeRestart
[16:09:32.373]                       is.null <- base::is.null
[16:09:32.373]                       muffled <- FALSE
[16:09:32.373]                       if (inherits(cond, "message")) {
[16:09:32.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.373]                         if (muffled) 
[16:09:32.373]                           invokeRestart("muffleMessage")
[16:09:32.373]                       }
[16:09:32.373]                       else if (inherits(cond, "warning")) {
[16:09:32.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.373]                         if (muffled) 
[16:09:32.373]                           invokeRestart("muffleWarning")
[16:09:32.373]                       }
[16:09:32.373]                       else if (inherits(cond, "condition")) {
[16:09:32.373]                         if (!is.null(pattern)) {
[16:09:32.373]                           computeRestarts <- base::computeRestarts
[16:09:32.373]                           grepl <- base::grepl
[16:09:32.373]                           restarts <- computeRestarts(cond)
[16:09:32.373]                           for (restart in restarts) {
[16:09:32.373]                             name <- restart$name
[16:09:32.373]                             if (is.null(name)) 
[16:09:32.373]                               next
[16:09:32.373]                             if (!grepl(pattern, name)) 
[16:09:32.373]                               next
[16:09:32.373]                             invokeRestart(restart)
[16:09:32.373]                             muffled <- TRUE
[16:09:32.373]                             break
[16:09:32.373]                           }
[16:09:32.373]                         }
[16:09:32.373]                       }
[16:09:32.373]                       invisible(muffled)
[16:09:32.373]                     }
[16:09:32.373]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.373]                   }
[16:09:32.373]                 }
[16:09:32.373]             }
[16:09:32.373]         }))
[16:09:32.373]     }, error = function(ex) {
[16:09:32.373]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.373]                 ...future.rng), started = ...future.startTime, 
[16:09:32.373]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.373]             version = "1.8"), class = "FutureResult")
[16:09:32.373]     }, finally = {
[16:09:32.373]         if (!identical(...future.workdir, getwd())) 
[16:09:32.373]             setwd(...future.workdir)
[16:09:32.373]         {
[16:09:32.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.373]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.373]             }
[16:09:32.373]             base::options(...future.oldOptions)
[16:09:32.373]             if (.Platform$OS.type == "windows") {
[16:09:32.373]                 old_names <- names(...future.oldEnvVars)
[16:09:32.373]                 envs <- base::Sys.getenv()
[16:09:32.373]                 names <- names(envs)
[16:09:32.373]                 common <- intersect(names, old_names)
[16:09:32.373]                 added <- setdiff(names, old_names)
[16:09:32.373]                 removed <- setdiff(old_names, names)
[16:09:32.373]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.373]                   envs[common]]
[16:09:32.373]                 NAMES <- toupper(changed)
[16:09:32.373]                 args <- list()
[16:09:32.373]                 for (kk in seq_along(NAMES)) {
[16:09:32.373]                   name <- changed[[kk]]
[16:09:32.373]                   NAME <- NAMES[[kk]]
[16:09:32.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.373]                     next
[16:09:32.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.373]                 }
[16:09:32.373]                 NAMES <- toupper(added)
[16:09:32.373]                 for (kk in seq_along(NAMES)) {
[16:09:32.373]                   name <- added[[kk]]
[16:09:32.373]                   NAME <- NAMES[[kk]]
[16:09:32.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.373]                     next
[16:09:32.373]                   args[[name]] <- ""
[16:09:32.373]                 }
[16:09:32.373]                 NAMES <- toupper(removed)
[16:09:32.373]                 for (kk in seq_along(NAMES)) {
[16:09:32.373]                   name <- removed[[kk]]
[16:09:32.373]                   NAME <- NAMES[[kk]]
[16:09:32.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.373]                     next
[16:09:32.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.373]                 }
[16:09:32.373]                 if (length(args) > 0) 
[16:09:32.373]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.373]             }
[16:09:32.373]             else {
[16:09:32.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.373]             }
[16:09:32.373]             {
[16:09:32.373]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.373]                   0L) {
[16:09:32.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.373]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.373]                   base::options(opts)
[16:09:32.373]                 }
[16:09:32.373]                 {
[16:09:32.373]                   {
[16:09:32.373]                     NULL
[16:09:32.373]                     RNGkind("Mersenne-Twister")
[16:09:32.373]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.373]                       inherits = FALSE)
[16:09:32.373]                   }
[16:09:32.373]                   options(future.plan = NULL)
[16:09:32.373]                   if (is.na(NA_character_)) 
[16:09:32.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.373]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:32.373]                     envir = parent.frame()) 
[16:09:32.373]                   {
[16:09:32.373]                     default_workers <- missing(workers)
[16:09:32.373]                     if (is.function(workers)) 
[16:09:32.373]                       workers <- workers()
[16:09:32.373]                     workers <- structure(as.integer(workers), 
[16:09:32.373]                       class = class(workers))
[16:09:32.373]                     stop_if_not(is.finite(workers), workers >= 
[16:09:32.373]                       1L)
[16:09:32.373]                     if ((workers == 1L && !inherits(workers, 
[16:09:32.373]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:32.373]                       if (default_workers) 
[16:09:32.373]                         supportsMulticore(warn = TRUE)
[16:09:32.373]                       return(sequential(..., envir = envir))
[16:09:32.373]                     }
[16:09:32.373]                     oopts <- options(mc.cores = workers)
[16:09:32.373]                     on.exit(options(oopts))
[16:09:32.373]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:32.373]                       envir = envir)
[16:09:32.373]                     if (!future$lazy) 
[16:09:32.373]                       future <- run(future)
[16:09:32.373]                     invisible(future)
[16:09:32.373]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.373]                 }
[16:09:32.373]             }
[16:09:32.373]         }
[16:09:32.373]     })
[16:09:32.373]     if (TRUE) {
[16:09:32.373]         base::sink(type = "output", split = FALSE)
[16:09:32.373]         if (TRUE) {
[16:09:32.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.373]         }
[16:09:32.373]         else {
[16:09:32.373]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.373]         }
[16:09:32.373]         base::close(...future.stdout)
[16:09:32.373]         ...future.stdout <- NULL
[16:09:32.373]     }
[16:09:32.373]     ...future.result$conditions <- ...future.conditions
[16:09:32.373]     ...future.result$finished <- base::Sys.time()
[16:09:32.373]     ...future.result
[16:09:32.373] }
[16:09:32.375] assign_globals() ...
[16:09:32.375] List of 7
[16:09:32.375]  $ ...future.FUN            :function (x)  
[16:09:32.375]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.375]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.375]  $ future.call.arguments    : list()
[16:09:32.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.375]  $ ...future.elements_ii    :List of 3
[16:09:32.375]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.375]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.375]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.375]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.375]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.375]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.375]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.375]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.375]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.375]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.375]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.375]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.375]  $ ...future.seeds_ii       : NULL
[16:09:32.375]  $ ...future.globals.maxSize: NULL
[16:09:32.375]  - attr(*, "resolved")= logi FALSE
[16:09:32.375]  - attr(*, "total_size")= num 2320
[16:09:32.375]  - attr(*, "where")=List of 7
[16:09:32.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.375]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:09:32.375]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:09:32.375]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.375]  - attr(*, "already-done")= logi TRUE
[16:09:32.385] - reassign environment for ‘...future.FUN’
[16:09:32.385] - copied ‘...future.FUN’ to environment
[16:09:32.385] - copied ‘breaks’ to environment
[16:09:32.385] - copied ‘wool’ to environment
[16:09:32.386] - copied ‘future.call.arguments’ to environment
[16:09:32.386] - copied ‘...future.elements_ii’ to environment
[16:09:32.386] - copied ‘...future.seeds_ii’ to environment
[16:09:32.386] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.386] assign_globals() ... done
[16:09:32.386] plan(): Setting new future strategy stack:
[16:09:32.386] List of future strategies:
[16:09:32.386] 1. sequential:
[16:09:32.386]    - args: function (..., envir = parent.frame())
[16:09:32.386]    - tweaked: FALSE
[16:09:32.386]    - call: NULL
[16:09:32.387] plan(): nbrOfWorkers() = 1
[16:09:32.389] plan(): Setting new future strategy stack:
[16:09:32.389] List of future strategies:
[16:09:32.389] 1. multicore:
[16:09:32.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.389]    - tweaked: FALSE
[16:09:32.389]    - call: plan(strategy)
[16:09:32.393] plan(): nbrOfWorkers() = 1
[16:09:32.393] SequentialFuture started (and completed)
[16:09:32.393] - Launch lazy future ... done
[16:09:32.393] run() for ‘SequentialFuture’ ... done
[16:09:32.393] Created future:
[16:09:32.393] SequentialFuture:
[16:09:32.393] Label: ‘future_by-1’
[16:09:32.393] Expression:
[16:09:32.393] {
[16:09:32.393]     do.call(function(...) {
[16:09:32.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.393]             on.exit(options(oopts), add = TRUE)
[16:09:32.393]         }
[16:09:32.393]         {
[16:09:32.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.393]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.393]             })
[16:09:32.393]         }
[16:09:32.393]     }, args = future.call.arguments)
[16:09:32.393] }
[16:09:32.393] Lazy evaluation: FALSE
[16:09:32.393] Asynchronous evaluation: FALSE
[16:09:32.393] Local evaluation: TRUE
[16:09:32.393] Environment: 0x5567e8cdd6e0
[16:09:32.393] Capture standard output: TRUE
[16:09:32.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.393] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:09:32.393] Packages: 1 packages (‘stats’)
[16:09:32.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.393] Resolved: TRUE
[16:09:32.393] Value: 25.57 KiB of class ‘list’
[16:09:32.393] Early signaling: FALSE
[16:09:32.393] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.393] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.395] Chunk #1 of 1 ... DONE
[16:09:32.395] Launching 1 futures (chunks) ... DONE
[16:09:32.395] Resolving 1 futures (chunks) ...
[16:09:32.395] resolve() on list ...
[16:09:32.395]  recursive: 0
[16:09:32.395]  length: 1
[16:09:32.395] 
[16:09:32.395] resolved() for ‘SequentialFuture’ ...
[16:09:32.396] - state: ‘finished’
[16:09:32.396] - run: TRUE
[16:09:32.396] - result: ‘FutureResult’
[16:09:32.396] resolved() for ‘SequentialFuture’ ... done
[16:09:32.396] Future #1
[16:09:32.396] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.396] - nx: 1
[16:09:32.396] - relay: TRUE
[16:09:32.396] - stdout: TRUE
[16:09:32.396] - signal: TRUE
[16:09:32.397] - resignal: FALSE
[16:09:32.397] - force: TRUE
[16:09:32.397] - relayed: [n=1] FALSE
[16:09:32.397] - queued futures: [n=1] FALSE
[16:09:32.397]  - until=1
[16:09:32.397]  - relaying element #1
[16:09:32.397] - relayed: [n=1] TRUE
[16:09:32.397] - queued futures: [n=1] TRUE
[16:09:32.397] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.397]  length: 0 (resolved future 1)
[16:09:32.398] Relaying remaining futures
[16:09:32.398] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.398] - nx: 1
[16:09:32.398] - relay: TRUE
[16:09:32.398] - stdout: TRUE
[16:09:32.398] - signal: TRUE
[16:09:32.398] - resignal: FALSE
[16:09:32.398] - force: TRUE
[16:09:32.398] - relayed: [n=1] TRUE
[16:09:32.398] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.398] - relayed: [n=1] TRUE
[16:09:32.398] - queued futures: [n=1] TRUE
[16:09:32.399] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.399] resolve() on list ... DONE
[16:09:32.399]  - Number of value chunks collected: 1
[16:09:32.399] Resolving 1 futures (chunks) ... DONE
[16:09:32.399] Reducing values from 1 chunks ...
[16:09:32.399]  - Number of values collected after concatenation: 3
[16:09:32.399]  - Number of values expected: 3
[16:09:32.399] Reducing values from 1 chunks ... DONE
[16:09:32.399] future_lapply() ... DONE
[16:09:32.399] future_by_internal() ... DONE
[16:09:32.400] future_by_internal() ...
[16:09:32.400] future_lapply() ...
[16:09:32.404] Number of chunks: 1
[16:09:32.404] getGlobalsAndPackagesXApply() ...
[16:09:32.405]  - future.globals: TRUE
[16:09:32.405] getGlobalsAndPackages() ...
[16:09:32.405] Searching for globals...
[16:09:32.406] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.406] Searching for globals ... DONE
[16:09:32.406] Resolving globals: FALSE
[16:09:32.406] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.407] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.407] - globals: [1] ‘FUN’
[16:09:32.407] 
[16:09:32.407] getGlobalsAndPackages() ... DONE
[16:09:32.407]  - globals found/used: [n=1] ‘FUN’
[16:09:32.407]  - needed namespaces: [n=0] 
[16:09:32.407] Finding globals ... DONE
[16:09:32.407]  - use_args: TRUE
[16:09:32.407]  - Getting '...' globals ...
[16:09:32.408] resolve() on list ...
[16:09:32.408]  recursive: 0
[16:09:32.408]  length: 1
[16:09:32.408]  elements: ‘...’
[16:09:32.408]  length: 0 (resolved future 1)
[16:09:32.408] resolve() on list ... DONE
[16:09:32.408]    - '...' content: [n=0] 
[16:09:32.408] List of 1
[16:09:32.408]  $ ...: list()
[16:09:32.408]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.408]  - attr(*, "where")=List of 1
[16:09:32.408]   ..$ ...:<environment: 0x5567e954f6c8> 
[16:09:32.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.408]  - attr(*, "resolved")= logi TRUE
[16:09:32.408]  - attr(*, "total_size")= num NA
[16:09:32.411]  - Getting '...' globals ... DONE
[16:09:32.411] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.411] List of 2
[16:09:32.411]  $ ...future.FUN:function (object, ...)  
[16:09:32.411]  $ ...          : list()
[16:09:32.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.411]  - attr(*, "where")=List of 2
[16:09:32.411]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.411]   ..$ ...          :<environment: 0x5567e954f6c8> 
[16:09:32.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.411]  - attr(*, "resolved")= logi FALSE
[16:09:32.411]  - attr(*, "total_size")= num 1240
[16:09:32.413] Packages to be attached in all futures: [n=0] 
[16:09:32.414] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.414] Number of futures (= number of chunks): 1
[16:09:32.414] Launching 1 futures (chunks) ...
[16:09:32.414] Chunk #1 of 1 ...
[16:09:32.414]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.414] getGlobalsAndPackages() ...
[16:09:32.414] Searching for globals...
[16:09:32.415] 
[16:09:32.415] Searching for globals ... DONE
[16:09:32.415] - globals: [0] <none>
[16:09:32.415] getGlobalsAndPackages() ... DONE
[16:09:32.415]    + additional globals found: [n=0] 
[16:09:32.415]    + additional namespaces needed: [n=0] 
[16:09:32.415]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.415]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.415]  - seeds: <none>
[16:09:32.415] getGlobalsAndPackages() ...
[16:09:32.416] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.416] Resolving globals: FALSE
[16:09:32.416] Tweak future expression to call with '...' arguments ...
[16:09:32.416] {
[16:09:32.416]     do.call(function(...) {
[16:09:32.416]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.416]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.416]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.416]             on.exit(options(oopts), add = TRUE)
[16:09:32.416]         }
[16:09:32.416]         {
[16:09:32.416]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.416]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.416]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.416]             })
[16:09:32.416]         }
[16:09:32.416]     }, args = future.call.arguments)
[16:09:32.416] }
[16:09:32.416] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.416] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.417] 
[16:09:32.417] getGlobalsAndPackages() ... DONE
[16:09:32.417] run() for ‘Future’ ...
[16:09:32.417] - state: ‘created’
[16:09:32.417] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.421] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.421] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.421]   - Field: ‘label’
[16:09:32.421]   - Field: ‘local’
[16:09:32.421]   - Field: ‘owner’
[16:09:32.421]   - Field: ‘envir’
[16:09:32.421]   - Field: ‘packages’
[16:09:32.421]   - Field: ‘gc’
[16:09:32.421]   - Field: ‘conditions’
[16:09:32.421]   - Field: ‘expr’
[16:09:32.422]   - Field: ‘uuid’
[16:09:32.422]   - Field: ‘seed’
[16:09:32.422]   - Field: ‘version’
[16:09:32.422]   - Field: ‘result’
[16:09:32.422]   - Field: ‘asynchronous’
[16:09:32.422]   - Field: ‘calls’
[16:09:32.422]   - Field: ‘globals’
[16:09:32.422]   - Field: ‘stdout’
[16:09:32.422]   - Field: ‘earlySignal’
[16:09:32.422]   - Field: ‘lazy’
[16:09:32.422]   - Field: ‘state’
[16:09:32.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.423] - Launch lazy future ...
[16:09:32.423] Packages needed by the future expression (n = 0): <none>
[16:09:32.423] Packages needed by future strategies (n = 0): <none>
[16:09:32.423] {
[16:09:32.423]     {
[16:09:32.423]         {
[16:09:32.423]             ...future.startTime <- base::Sys.time()
[16:09:32.423]             {
[16:09:32.423]                 {
[16:09:32.423]                   {
[16:09:32.423]                     base::local({
[16:09:32.423]                       has_future <- base::requireNamespace("future", 
[16:09:32.423]                         quietly = TRUE)
[16:09:32.423]                       if (has_future) {
[16:09:32.423]                         ns <- base::getNamespace("future")
[16:09:32.423]                         version <- ns[[".package"]][["version"]]
[16:09:32.423]                         if (is.null(version)) 
[16:09:32.423]                           version <- utils::packageVersion("future")
[16:09:32.423]                       }
[16:09:32.423]                       else {
[16:09:32.423]                         version <- NULL
[16:09:32.423]                       }
[16:09:32.423]                       if (!has_future || version < "1.8.0") {
[16:09:32.423]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.423]                           "", base::R.version$version.string), 
[16:09:32.423]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.423]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.423]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.423]                             "release", "version")], collapse = " "), 
[16:09:32.423]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.423]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.423]                           info)
[16:09:32.423]                         info <- base::paste(info, collapse = "; ")
[16:09:32.423]                         if (!has_future) {
[16:09:32.423]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.423]                             info)
[16:09:32.423]                         }
[16:09:32.423]                         else {
[16:09:32.423]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.423]                             info, version)
[16:09:32.423]                         }
[16:09:32.423]                         base::stop(msg)
[16:09:32.423]                       }
[16:09:32.423]                     })
[16:09:32.423]                   }
[16:09:32.423]                   options(future.plan = NULL)
[16:09:32.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.423]                 }
[16:09:32.423]                 ...future.workdir <- getwd()
[16:09:32.423]             }
[16:09:32.423]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.423]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.423]         }
[16:09:32.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.423]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.423]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.423]             base::names(...future.oldOptions))
[16:09:32.423]     }
[16:09:32.423]     if (FALSE) {
[16:09:32.423]     }
[16:09:32.423]     else {
[16:09:32.423]         if (TRUE) {
[16:09:32.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.423]                 open = "w")
[16:09:32.423]         }
[16:09:32.423]         else {
[16:09:32.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.423]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.423]         }
[16:09:32.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.423]             base::sink(type = "output", split = FALSE)
[16:09:32.423]             base::close(...future.stdout)
[16:09:32.423]         }, add = TRUE)
[16:09:32.423]     }
[16:09:32.423]     ...future.frame <- base::sys.nframe()
[16:09:32.423]     ...future.conditions <- base::list()
[16:09:32.423]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.423]     if (FALSE) {
[16:09:32.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.423]     }
[16:09:32.423]     ...future.result <- base::tryCatch({
[16:09:32.423]         base::withCallingHandlers({
[16:09:32.423]             ...future.value <- base::withVisible(base::local({
[16:09:32.423]                 do.call(function(...) {
[16:09:32.423]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.423]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.423]                     ...future.globals.maxSize)) {
[16:09:32.423]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.423]                     on.exit(options(oopts), add = TRUE)
[16:09:32.423]                   }
[16:09:32.423]                   {
[16:09:32.423]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.423]                       FUN = function(jj) {
[16:09:32.423]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.423]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.423]                       })
[16:09:32.423]                   }
[16:09:32.423]                 }, args = future.call.arguments)
[16:09:32.423]             }))
[16:09:32.423]             future::FutureResult(value = ...future.value$value, 
[16:09:32.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.423]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.423]                     ...future.globalenv.names))
[16:09:32.423]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.423]         }, condition = base::local({
[16:09:32.423]             c <- base::c
[16:09:32.423]             inherits <- base::inherits
[16:09:32.423]             invokeRestart <- base::invokeRestart
[16:09:32.423]             length <- base::length
[16:09:32.423]             list <- base::list
[16:09:32.423]             seq.int <- base::seq.int
[16:09:32.423]             signalCondition <- base::signalCondition
[16:09:32.423]             sys.calls <- base::sys.calls
[16:09:32.423]             `[[` <- base::`[[`
[16:09:32.423]             `+` <- base::`+`
[16:09:32.423]             `<<-` <- base::`<<-`
[16:09:32.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.423]                   3L)]
[16:09:32.423]             }
[16:09:32.423]             function(cond) {
[16:09:32.423]                 is_error <- inherits(cond, "error")
[16:09:32.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.423]                   NULL)
[16:09:32.423]                 if (is_error) {
[16:09:32.423]                   sessionInformation <- function() {
[16:09:32.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.423]                       search = base::search(), system = base::Sys.info())
[16:09:32.423]                   }
[16:09:32.423]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.423]                     cond$call), session = sessionInformation(), 
[16:09:32.423]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.423]                   signalCondition(cond)
[16:09:32.423]                 }
[16:09:32.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.423]                 "immediateCondition"))) {
[16:09:32.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.423]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.423]                   if (TRUE && !signal) {
[16:09:32.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.423]                     {
[16:09:32.423]                       inherits <- base::inherits
[16:09:32.423]                       invokeRestart <- base::invokeRestart
[16:09:32.423]                       is.null <- base::is.null
[16:09:32.423]                       muffled <- FALSE
[16:09:32.423]                       if (inherits(cond, "message")) {
[16:09:32.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.423]                         if (muffled) 
[16:09:32.423]                           invokeRestart("muffleMessage")
[16:09:32.423]                       }
[16:09:32.423]                       else if (inherits(cond, "warning")) {
[16:09:32.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.423]                         if (muffled) 
[16:09:32.423]                           invokeRestart("muffleWarning")
[16:09:32.423]                       }
[16:09:32.423]                       else if (inherits(cond, "condition")) {
[16:09:32.423]                         if (!is.null(pattern)) {
[16:09:32.423]                           computeRestarts <- base::computeRestarts
[16:09:32.423]                           grepl <- base::grepl
[16:09:32.423]                           restarts <- computeRestarts(cond)
[16:09:32.423]                           for (restart in restarts) {
[16:09:32.423]                             name <- restart$name
[16:09:32.423]                             if (is.null(name)) 
[16:09:32.423]                               next
[16:09:32.423]                             if (!grepl(pattern, name)) 
[16:09:32.423]                               next
[16:09:32.423]                             invokeRestart(restart)
[16:09:32.423]                             muffled <- TRUE
[16:09:32.423]                             break
[16:09:32.423]                           }
[16:09:32.423]                         }
[16:09:32.423]                       }
[16:09:32.423]                       invisible(muffled)
[16:09:32.423]                     }
[16:09:32.423]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.423]                   }
[16:09:32.423]                 }
[16:09:32.423]                 else {
[16:09:32.423]                   if (TRUE) {
[16:09:32.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.423]                     {
[16:09:32.423]                       inherits <- base::inherits
[16:09:32.423]                       invokeRestart <- base::invokeRestart
[16:09:32.423]                       is.null <- base::is.null
[16:09:32.423]                       muffled <- FALSE
[16:09:32.423]                       if (inherits(cond, "message")) {
[16:09:32.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.423]                         if (muffled) 
[16:09:32.423]                           invokeRestart("muffleMessage")
[16:09:32.423]                       }
[16:09:32.423]                       else if (inherits(cond, "warning")) {
[16:09:32.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.423]                         if (muffled) 
[16:09:32.423]                           invokeRestart("muffleWarning")
[16:09:32.423]                       }
[16:09:32.423]                       else if (inherits(cond, "condition")) {
[16:09:32.423]                         if (!is.null(pattern)) {
[16:09:32.423]                           computeRestarts <- base::computeRestarts
[16:09:32.423]                           grepl <- base::grepl
[16:09:32.423]                           restarts <- computeRestarts(cond)
[16:09:32.423]                           for (restart in restarts) {
[16:09:32.423]                             name <- restart$name
[16:09:32.423]                             if (is.null(name)) 
[16:09:32.423]                               next
[16:09:32.423]                             if (!grepl(pattern, name)) 
[16:09:32.423]                               next
[16:09:32.423]                             invokeRestart(restart)
[16:09:32.423]                             muffled <- TRUE
[16:09:32.423]                             break
[16:09:32.423]                           }
[16:09:32.423]                         }
[16:09:32.423]                       }
[16:09:32.423]                       invisible(muffled)
[16:09:32.423]                     }
[16:09:32.423]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.423]                   }
[16:09:32.423]                 }
[16:09:32.423]             }
[16:09:32.423]         }))
[16:09:32.423]     }, error = function(ex) {
[16:09:32.423]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.423]                 ...future.rng), started = ...future.startTime, 
[16:09:32.423]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.423]             version = "1.8"), class = "FutureResult")
[16:09:32.423]     }, finally = {
[16:09:32.423]         if (!identical(...future.workdir, getwd())) 
[16:09:32.423]             setwd(...future.workdir)
[16:09:32.423]         {
[16:09:32.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.423]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.423]             }
[16:09:32.423]             base::options(...future.oldOptions)
[16:09:32.423]             if (.Platform$OS.type == "windows") {
[16:09:32.423]                 old_names <- names(...future.oldEnvVars)
[16:09:32.423]                 envs <- base::Sys.getenv()
[16:09:32.423]                 names <- names(envs)
[16:09:32.423]                 common <- intersect(names, old_names)
[16:09:32.423]                 added <- setdiff(names, old_names)
[16:09:32.423]                 removed <- setdiff(old_names, names)
[16:09:32.423]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.423]                   envs[common]]
[16:09:32.423]                 NAMES <- toupper(changed)
[16:09:32.423]                 args <- list()
[16:09:32.423]                 for (kk in seq_along(NAMES)) {
[16:09:32.423]                   name <- changed[[kk]]
[16:09:32.423]                   NAME <- NAMES[[kk]]
[16:09:32.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.423]                     next
[16:09:32.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.423]                 }
[16:09:32.423]                 NAMES <- toupper(added)
[16:09:32.423]                 for (kk in seq_along(NAMES)) {
[16:09:32.423]                   name <- added[[kk]]
[16:09:32.423]                   NAME <- NAMES[[kk]]
[16:09:32.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.423]                     next
[16:09:32.423]                   args[[name]] <- ""
[16:09:32.423]                 }
[16:09:32.423]                 NAMES <- toupper(removed)
[16:09:32.423]                 for (kk in seq_along(NAMES)) {
[16:09:32.423]                   name <- removed[[kk]]
[16:09:32.423]                   NAME <- NAMES[[kk]]
[16:09:32.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.423]                     next
[16:09:32.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.423]                 }
[16:09:32.423]                 if (length(args) > 0) 
[16:09:32.423]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.423]             }
[16:09:32.423]             else {
[16:09:32.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.423]             }
[16:09:32.423]             {
[16:09:32.423]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.423]                   0L) {
[16:09:32.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.423]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.423]                   base::options(opts)
[16:09:32.423]                 }
[16:09:32.423]                 {
[16:09:32.423]                   {
[16:09:32.423]                     NULL
[16:09:32.423]                     RNGkind("Mersenne-Twister")
[16:09:32.423]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.423]                       inherits = FALSE)
[16:09:32.423]                   }
[16:09:32.423]                   options(future.plan = NULL)
[16:09:32.423]                   if (is.na(NA_character_)) 
[16:09:32.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.423]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:32.423]                     envir = parent.frame()) 
[16:09:32.423]                   {
[16:09:32.423]                     default_workers <- missing(workers)
[16:09:32.423]                     if (is.function(workers)) 
[16:09:32.423]                       workers <- workers()
[16:09:32.423]                     workers <- structure(as.integer(workers), 
[16:09:32.423]                       class = class(workers))
[16:09:32.423]                     stop_if_not(is.finite(workers), workers >= 
[16:09:32.423]                       1L)
[16:09:32.423]                     if ((workers == 1L && !inherits(workers, 
[16:09:32.423]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:32.423]                       if (default_workers) 
[16:09:32.423]                         supportsMulticore(warn = TRUE)
[16:09:32.423]                       return(sequential(..., envir = envir))
[16:09:32.423]                     }
[16:09:32.423]                     oopts <- options(mc.cores = workers)
[16:09:32.423]                     on.exit(options(oopts))
[16:09:32.423]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:32.423]                       envir = envir)
[16:09:32.423]                     if (!future$lazy) 
[16:09:32.423]                       future <- run(future)
[16:09:32.423]                     invisible(future)
[16:09:32.423]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.423]                 }
[16:09:32.423]             }
[16:09:32.423]         }
[16:09:32.423]     })
[16:09:32.423]     if (TRUE) {
[16:09:32.423]         base::sink(type = "output", split = FALSE)
[16:09:32.423]         if (TRUE) {
[16:09:32.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.423]         }
[16:09:32.423]         else {
[16:09:32.423]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.423]         }
[16:09:32.423]         base::close(...future.stdout)
[16:09:32.423]         ...future.stdout <- NULL
[16:09:32.423]     }
[16:09:32.423]     ...future.result$conditions <- ...future.conditions
[16:09:32.423]     ...future.result$finished <- base::Sys.time()
[16:09:32.423]     ...future.result
[16:09:32.423] }
[16:09:32.425] assign_globals() ...
[16:09:32.425] List of 5
[16:09:32.425]  $ ...future.FUN            :function (object, ...)  
[16:09:32.425]  $ future.call.arguments    : list()
[16:09:32.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.425]  $ ...future.elements_ii    :List of 3
[16:09:32.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.425]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.425]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.425]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.425]  $ ...future.seeds_ii       : NULL
[16:09:32.425]  $ ...future.globals.maxSize: NULL
[16:09:32.425]  - attr(*, "resolved")= logi FALSE
[16:09:32.425]  - attr(*, "total_size")= num 1240
[16:09:32.425]  - attr(*, "where")=List of 5
[16:09:32.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.425]  - attr(*, "already-done")= logi TRUE
[16:09:32.434] - copied ‘...future.FUN’ to environment
[16:09:32.434] - copied ‘future.call.arguments’ to environment
[16:09:32.435] - copied ‘...future.elements_ii’ to environment
[16:09:32.435] - copied ‘...future.seeds_ii’ to environment
[16:09:32.435] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.435] assign_globals() ... done
[16:09:32.435] plan(): Setting new future strategy stack:
[16:09:32.435] List of future strategies:
[16:09:32.435] 1. sequential:
[16:09:32.435]    - args: function (..., envir = parent.frame())
[16:09:32.435]    - tweaked: FALSE
[16:09:32.435]    - call: NULL
[16:09:32.435] plan(): nbrOfWorkers() = 1
[16:09:32.438] plan(): Setting new future strategy stack:
[16:09:32.438] List of future strategies:
[16:09:32.438] 1. multicore:
[16:09:32.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.438]    - tweaked: FALSE
[16:09:32.438]    - call: plan(strategy)
[16:09:32.441] plan(): nbrOfWorkers() = 1
[16:09:32.441] SequentialFuture started (and completed)
[16:09:32.441] - Launch lazy future ... done
[16:09:32.441] run() for ‘SequentialFuture’ ... done
[16:09:32.441] Created future:
[16:09:32.442] SequentialFuture:
[16:09:32.442] Label: ‘future_by-1’
[16:09:32.442] Expression:
[16:09:32.442] {
[16:09:32.442]     do.call(function(...) {
[16:09:32.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.442]             on.exit(options(oopts), add = TRUE)
[16:09:32.442]         }
[16:09:32.442]         {
[16:09:32.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.442]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.442]             })
[16:09:32.442]         }
[16:09:32.442]     }, args = future.call.arguments)
[16:09:32.442] }
[16:09:32.442] Lazy evaluation: FALSE
[16:09:32.442] Asynchronous evaluation: FALSE
[16:09:32.442] Local evaluation: TRUE
[16:09:32.442] Environment: 0x5567e941aa98
[16:09:32.442] Capture standard output: TRUE
[16:09:32.442] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.442] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.442] Packages: <none>
[16:09:32.442] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.442] Resolved: TRUE
[16:09:32.442] Value: 5.37 KiB of class ‘list’
[16:09:32.442] Early signaling: FALSE
[16:09:32.442] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.442] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.443] Chunk #1 of 1 ... DONE
[16:09:32.443] Launching 1 futures (chunks) ... DONE
[16:09:32.443] Resolving 1 futures (chunks) ...
[16:09:32.443] resolve() on list ...
[16:09:32.443]  recursive: 0
[16:09:32.443]  length: 1
[16:09:32.443] 
[16:09:32.443] resolved() for ‘SequentialFuture’ ...
[16:09:32.443] - state: ‘finished’
[16:09:32.444] - run: TRUE
[16:09:32.444] - result: ‘FutureResult’
[16:09:32.444] resolved() for ‘SequentialFuture’ ... done
[16:09:32.444] Future #1
[16:09:32.444] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.444] - nx: 1
[16:09:32.444] - relay: TRUE
[16:09:32.444] - stdout: TRUE
[16:09:32.444] - signal: TRUE
[16:09:32.444] - resignal: FALSE
[16:09:32.445] - force: TRUE
[16:09:32.445] - relayed: [n=1] FALSE
[16:09:32.445] - queued futures: [n=1] FALSE
[16:09:32.445]  - until=1
[16:09:32.445]  - relaying element #1
[16:09:32.445] - relayed: [n=1] TRUE
[16:09:32.445] - queued futures: [n=1] TRUE
[16:09:32.445] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.445]  length: 0 (resolved future 1)
[16:09:32.445] Relaying remaining futures
[16:09:32.445] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.446] - nx: 1
[16:09:32.446] - relay: TRUE
[16:09:32.446] - stdout: TRUE
[16:09:32.446] - signal: TRUE
[16:09:32.446] - resignal: FALSE
[16:09:32.446] - force: TRUE
[16:09:32.446] - relayed: [n=1] TRUE
[16:09:32.446] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.446] - relayed: [n=1] TRUE
[16:09:32.446] - queued futures: [n=1] TRUE
[16:09:32.446] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.446] resolve() on list ... DONE
[16:09:32.447]  - Number of value chunks collected: 1
[16:09:32.447] Resolving 1 futures (chunks) ... DONE
[16:09:32.447] Reducing values from 1 chunks ...
[16:09:32.447]  - Number of values collected after concatenation: 3
[16:09:32.447]  - Number of values expected: 3
[16:09:32.447] Reducing values from 1 chunks ... DONE
[16:09:32.447] future_lapply() ... DONE
[16:09:32.447] future_by_internal() ... DONE
[16:09:32.448] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:09:32.449] future_lapply() ...
[16:09:32.453] Number of chunks: 1
[16:09:32.453] getGlobalsAndPackagesXApply() ...
[16:09:32.453]  - future.globals: TRUE
[16:09:32.453] getGlobalsAndPackages() ...
[16:09:32.453] Searching for globals...
[16:09:32.454] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.454] Searching for globals ... DONE
[16:09:32.454] Resolving globals: FALSE
[16:09:32.455] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.455] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.455] - globals: [1] ‘FUN’
[16:09:32.455] 
[16:09:32.455] getGlobalsAndPackages() ... DONE
[16:09:32.455]  - globals found/used: [n=1] ‘FUN’
[16:09:32.456]  - needed namespaces: [n=0] 
[16:09:32.456] Finding globals ... DONE
[16:09:32.456]  - use_args: TRUE
[16:09:32.456]  - Getting '...' globals ...
[16:09:32.456] resolve() on list ...
[16:09:32.456]  recursive: 0
[16:09:32.456]  length: 1
[16:09:32.456]  elements: ‘...’
[16:09:32.456]  length: 0 (resolved future 1)
[16:09:32.457] resolve() on list ... DONE
[16:09:32.457]    - '...' content: [n=0] 
[16:09:32.457] List of 1
[16:09:32.457]  $ ...: list()
[16:09:32.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.457]  - attr(*, "where")=List of 1
[16:09:32.457]   ..$ ...:<environment: 0x5567e7c1a5b0> 
[16:09:32.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.457]  - attr(*, "resolved")= logi TRUE
[16:09:32.457]  - attr(*, "total_size")= num NA
[16:09:32.459]  - Getting '...' globals ... DONE
[16:09:32.459] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.459] List of 2
[16:09:32.459]  $ ...future.FUN:function (object, ...)  
[16:09:32.459]  $ ...          : list()
[16:09:32.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.459]  - attr(*, "where")=List of 2
[16:09:32.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.459]   ..$ ...          :<environment: 0x5567e7c1a5b0> 
[16:09:32.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.459]  - attr(*, "resolved")= logi FALSE
[16:09:32.459]  - attr(*, "total_size")= num 1240
[16:09:32.462] Packages to be attached in all futures: [n=0] 
[16:09:32.462] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.462] Number of futures (= number of chunks): 1
[16:09:32.462] Launching 1 futures (chunks) ...
[16:09:32.462] Chunk #1 of 1 ...
[16:09:32.462]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.462] getGlobalsAndPackages() ...
[16:09:32.463] Searching for globals...
[16:09:32.463] 
[16:09:32.463] Searching for globals ... DONE
[16:09:32.463] - globals: [0] <none>
[16:09:32.463] getGlobalsAndPackages() ... DONE
[16:09:32.463]    + additional globals found: [n=0] 
[16:09:32.463]    + additional namespaces needed: [n=0] 
[16:09:32.464]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.464]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.464]  - seeds: <none>
[16:09:32.464] getGlobalsAndPackages() ...
[16:09:32.464] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.464] Resolving globals: FALSE
[16:09:32.464] Tweak future expression to call with '...' arguments ...
[16:09:32.464] {
[16:09:32.464]     do.call(function(...) {
[16:09:32.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.464]             on.exit(options(oopts), add = TRUE)
[16:09:32.464]         }
[16:09:32.464]         {
[16:09:32.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.464]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.464]             })
[16:09:32.464]         }
[16:09:32.464]     }, args = future.call.arguments)
[16:09:32.464] }
[16:09:32.465] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.465] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.465] 
[16:09:32.465] getGlobalsAndPackages() ... DONE
[16:09:32.465] run() for ‘Future’ ...
[16:09:32.465] - state: ‘created’
[16:09:32.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.469] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.469]   - Field: ‘label’
[16:09:32.469]   - Field: ‘local’
[16:09:32.469]   - Field: ‘owner’
[16:09:32.469]   - Field: ‘envir’
[16:09:32.470]   - Field: ‘packages’
[16:09:32.470]   - Field: ‘gc’
[16:09:32.470]   - Field: ‘conditions’
[16:09:32.470]   - Field: ‘expr’
[16:09:32.470]   - Field: ‘uuid’
[16:09:32.470]   - Field: ‘seed’
[16:09:32.470]   - Field: ‘version’
[16:09:32.470]   - Field: ‘result’
[16:09:32.470]   - Field: ‘asynchronous’
[16:09:32.470]   - Field: ‘calls’
[16:09:32.470]   - Field: ‘globals’
[16:09:32.471]   - Field: ‘stdout’
[16:09:32.471]   - Field: ‘earlySignal’
[16:09:32.471]   - Field: ‘lazy’
[16:09:32.471]   - Field: ‘state’
[16:09:32.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.471] - Launch lazy future ...
[16:09:32.471] Packages needed by the future expression (n = 0): <none>
[16:09:32.471] Packages needed by future strategies (n = 0): <none>
[16:09:32.472] {
[16:09:32.472]     {
[16:09:32.472]         {
[16:09:32.472]             ...future.startTime <- base::Sys.time()
[16:09:32.472]             {
[16:09:32.472]                 {
[16:09:32.472]                   {
[16:09:32.472]                     base::local({
[16:09:32.472]                       has_future <- base::requireNamespace("future", 
[16:09:32.472]                         quietly = TRUE)
[16:09:32.472]                       if (has_future) {
[16:09:32.472]                         ns <- base::getNamespace("future")
[16:09:32.472]                         version <- ns[[".package"]][["version"]]
[16:09:32.472]                         if (is.null(version)) 
[16:09:32.472]                           version <- utils::packageVersion("future")
[16:09:32.472]                       }
[16:09:32.472]                       else {
[16:09:32.472]                         version <- NULL
[16:09:32.472]                       }
[16:09:32.472]                       if (!has_future || version < "1.8.0") {
[16:09:32.472]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.472]                           "", base::R.version$version.string), 
[16:09:32.472]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.472]                             "release", "version")], collapse = " "), 
[16:09:32.472]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.472]                           info)
[16:09:32.472]                         info <- base::paste(info, collapse = "; ")
[16:09:32.472]                         if (!has_future) {
[16:09:32.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.472]                             info)
[16:09:32.472]                         }
[16:09:32.472]                         else {
[16:09:32.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.472]                             info, version)
[16:09:32.472]                         }
[16:09:32.472]                         base::stop(msg)
[16:09:32.472]                       }
[16:09:32.472]                     })
[16:09:32.472]                   }
[16:09:32.472]                   options(future.plan = NULL)
[16:09:32.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.472]                 }
[16:09:32.472]                 ...future.workdir <- getwd()
[16:09:32.472]             }
[16:09:32.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.472]         }
[16:09:32.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.472]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.472]             base::names(...future.oldOptions))
[16:09:32.472]     }
[16:09:32.472]     if (FALSE) {
[16:09:32.472]     }
[16:09:32.472]     else {
[16:09:32.472]         if (TRUE) {
[16:09:32.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.472]                 open = "w")
[16:09:32.472]         }
[16:09:32.472]         else {
[16:09:32.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.472]         }
[16:09:32.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.472]             base::sink(type = "output", split = FALSE)
[16:09:32.472]             base::close(...future.stdout)
[16:09:32.472]         }, add = TRUE)
[16:09:32.472]     }
[16:09:32.472]     ...future.frame <- base::sys.nframe()
[16:09:32.472]     ...future.conditions <- base::list()
[16:09:32.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.472]     if (FALSE) {
[16:09:32.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.472]     }
[16:09:32.472]     ...future.result <- base::tryCatch({
[16:09:32.472]         base::withCallingHandlers({
[16:09:32.472]             ...future.value <- base::withVisible(base::local({
[16:09:32.472]                 do.call(function(...) {
[16:09:32.472]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.472]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.472]                     ...future.globals.maxSize)) {
[16:09:32.472]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.472]                     on.exit(options(oopts), add = TRUE)
[16:09:32.472]                   }
[16:09:32.472]                   {
[16:09:32.472]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.472]                       FUN = function(jj) {
[16:09:32.472]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.472]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.472]                       })
[16:09:32.472]                   }
[16:09:32.472]                 }, args = future.call.arguments)
[16:09:32.472]             }))
[16:09:32.472]             future::FutureResult(value = ...future.value$value, 
[16:09:32.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.472]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.472]                     ...future.globalenv.names))
[16:09:32.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.472]         }, condition = base::local({
[16:09:32.472]             c <- base::c
[16:09:32.472]             inherits <- base::inherits
[16:09:32.472]             invokeRestart <- base::invokeRestart
[16:09:32.472]             length <- base::length
[16:09:32.472]             list <- base::list
[16:09:32.472]             seq.int <- base::seq.int
[16:09:32.472]             signalCondition <- base::signalCondition
[16:09:32.472]             sys.calls <- base::sys.calls
[16:09:32.472]             `[[` <- base::`[[`
[16:09:32.472]             `+` <- base::`+`
[16:09:32.472]             `<<-` <- base::`<<-`
[16:09:32.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.472]                   3L)]
[16:09:32.472]             }
[16:09:32.472]             function(cond) {
[16:09:32.472]                 is_error <- inherits(cond, "error")
[16:09:32.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.472]                   NULL)
[16:09:32.472]                 if (is_error) {
[16:09:32.472]                   sessionInformation <- function() {
[16:09:32.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.472]                       search = base::search(), system = base::Sys.info())
[16:09:32.472]                   }
[16:09:32.472]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.472]                     cond$call), session = sessionInformation(), 
[16:09:32.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.472]                   signalCondition(cond)
[16:09:32.472]                 }
[16:09:32.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.472]                 "immediateCondition"))) {
[16:09:32.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.472]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.472]                   if (TRUE && !signal) {
[16:09:32.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.472]                     {
[16:09:32.472]                       inherits <- base::inherits
[16:09:32.472]                       invokeRestart <- base::invokeRestart
[16:09:32.472]                       is.null <- base::is.null
[16:09:32.472]                       muffled <- FALSE
[16:09:32.472]                       if (inherits(cond, "message")) {
[16:09:32.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.472]                         if (muffled) 
[16:09:32.472]                           invokeRestart("muffleMessage")
[16:09:32.472]                       }
[16:09:32.472]                       else if (inherits(cond, "warning")) {
[16:09:32.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.472]                         if (muffled) 
[16:09:32.472]                           invokeRestart("muffleWarning")
[16:09:32.472]                       }
[16:09:32.472]                       else if (inherits(cond, "condition")) {
[16:09:32.472]                         if (!is.null(pattern)) {
[16:09:32.472]                           computeRestarts <- base::computeRestarts
[16:09:32.472]                           grepl <- base::grepl
[16:09:32.472]                           restarts <- computeRestarts(cond)
[16:09:32.472]                           for (restart in restarts) {
[16:09:32.472]                             name <- restart$name
[16:09:32.472]                             if (is.null(name)) 
[16:09:32.472]                               next
[16:09:32.472]                             if (!grepl(pattern, name)) 
[16:09:32.472]                               next
[16:09:32.472]                             invokeRestart(restart)
[16:09:32.472]                             muffled <- TRUE
[16:09:32.472]                             break
[16:09:32.472]                           }
[16:09:32.472]                         }
[16:09:32.472]                       }
[16:09:32.472]                       invisible(muffled)
[16:09:32.472]                     }
[16:09:32.472]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.472]                   }
[16:09:32.472]                 }
[16:09:32.472]                 else {
[16:09:32.472]                   if (TRUE) {
[16:09:32.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.472]                     {
[16:09:32.472]                       inherits <- base::inherits
[16:09:32.472]                       invokeRestart <- base::invokeRestart
[16:09:32.472]                       is.null <- base::is.null
[16:09:32.472]                       muffled <- FALSE
[16:09:32.472]                       if (inherits(cond, "message")) {
[16:09:32.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.472]                         if (muffled) 
[16:09:32.472]                           invokeRestart("muffleMessage")
[16:09:32.472]                       }
[16:09:32.472]                       else if (inherits(cond, "warning")) {
[16:09:32.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.472]                         if (muffled) 
[16:09:32.472]                           invokeRestart("muffleWarning")
[16:09:32.472]                       }
[16:09:32.472]                       else if (inherits(cond, "condition")) {
[16:09:32.472]                         if (!is.null(pattern)) {
[16:09:32.472]                           computeRestarts <- base::computeRestarts
[16:09:32.472]                           grepl <- base::grepl
[16:09:32.472]                           restarts <- computeRestarts(cond)
[16:09:32.472]                           for (restart in restarts) {
[16:09:32.472]                             name <- restart$name
[16:09:32.472]                             if (is.null(name)) 
[16:09:32.472]                               next
[16:09:32.472]                             if (!grepl(pattern, name)) 
[16:09:32.472]                               next
[16:09:32.472]                             invokeRestart(restart)
[16:09:32.472]                             muffled <- TRUE
[16:09:32.472]                             break
[16:09:32.472]                           }
[16:09:32.472]                         }
[16:09:32.472]                       }
[16:09:32.472]                       invisible(muffled)
[16:09:32.472]                     }
[16:09:32.472]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.472]                   }
[16:09:32.472]                 }
[16:09:32.472]             }
[16:09:32.472]         }))
[16:09:32.472]     }, error = function(ex) {
[16:09:32.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.472]                 ...future.rng), started = ...future.startTime, 
[16:09:32.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.472]             version = "1.8"), class = "FutureResult")
[16:09:32.472]     }, finally = {
[16:09:32.472]         if (!identical(...future.workdir, getwd())) 
[16:09:32.472]             setwd(...future.workdir)
[16:09:32.472]         {
[16:09:32.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.472]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.472]             }
[16:09:32.472]             base::options(...future.oldOptions)
[16:09:32.472]             if (.Platform$OS.type == "windows") {
[16:09:32.472]                 old_names <- names(...future.oldEnvVars)
[16:09:32.472]                 envs <- base::Sys.getenv()
[16:09:32.472]                 names <- names(envs)
[16:09:32.472]                 common <- intersect(names, old_names)
[16:09:32.472]                 added <- setdiff(names, old_names)
[16:09:32.472]                 removed <- setdiff(old_names, names)
[16:09:32.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.472]                   envs[common]]
[16:09:32.472]                 NAMES <- toupper(changed)
[16:09:32.472]                 args <- list()
[16:09:32.472]                 for (kk in seq_along(NAMES)) {
[16:09:32.472]                   name <- changed[[kk]]
[16:09:32.472]                   NAME <- NAMES[[kk]]
[16:09:32.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.472]                     next
[16:09:32.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.472]                 }
[16:09:32.472]                 NAMES <- toupper(added)
[16:09:32.472]                 for (kk in seq_along(NAMES)) {
[16:09:32.472]                   name <- added[[kk]]
[16:09:32.472]                   NAME <- NAMES[[kk]]
[16:09:32.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.472]                     next
[16:09:32.472]                   args[[name]] <- ""
[16:09:32.472]                 }
[16:09:32.472]                 NAMES <- toupper(removed)
[16:09:32.472]                 for (kk in seq_along(NAMES)) {
[16:09:32.472]                   name <- removed[[kk]]
[16:09:32.472]                   NAME <- NAMES[[kk]]
[16:09:32.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.472]                     next
[16:09:32.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.472]                 }
[16:09:32.472]                 if (length(args) > 0) 
[16:09:32.472]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.472]             }
[16:09:32.472]             else {
[16:09:32.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.472]             }
[16:09:32.472]             {
[16:09:32.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.472]                   0L) {
[16:09:32.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.472]                   base::options(opts)
[16:09:32.472]                 }
[16:09:32.472]                 {
[16:09:32.472]                   {
[16:09:32.472]                     NULL
[16:09:32.472]                     RNGkind("Mersenne-Twister")
[16:09:32.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.472]                       inherits = FALSE)
[16:09:32.472]                   }
[16:09:32.472]                   options(future.plan = NULL)
[16:09:32.472]                   if (is.na(NA_character_)) 
[16:09:32.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.472]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:32.472]                     envir = parent.frame()) 
[16:09:32.472]                   {
[16:09:32.472]                     default_workers <- missing(workers)
[16:09:32.472]                     if (is.function(workers)) 
[16:09:32.472]                       workers <- workers()
[16:09:32.472]                     workers <- structure(as.integer(workers), 
[16:09:32.472]                       class = class(workers))
[16:09:32.472]                     stop_if_not(is.finite(workers), workers >= 
[16:09:32.472]                       1L)
[16:09:32.472]                     if ((workers == 1L && !inherits(workers, 
[16:09:32.472]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:32.472]                       if (default_workers) 
[16:09:32.472]                         supportsMulticore(warn = TRUE)
[16:09:32.472]                       return(sequential(..., envir = envir))
[16:09:32.472]                     }
[16:09:32.472]                     oopts <- options(mc.cores = workers)
[16:09:32.472]                     on.exit(options(oopts))
[16:09:32.472]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:32.472]                       envir = envir)
[16:09:32.472]                     if (!future$lazy) 
[16:09:32.472]                       future <- run(future)
[16:09:32.472]                     invisible(future)
[16:09:32.472]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.472]                 }
[16:09:32.472]             }
[16:09:32.472]         }
[16:09:32.472]     })
[16:09:32.472]     if (TRUE) {
[16:09:32.472]         base::sink(type = "output", split = FALSE)
[16:09:32.472]         if (TRUE) {
[16:09:32.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.472]         }
[16:09:32.472]         else {
[16:09:32.472]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.472]         }
[16:09:32.472]         base::close(...future.stdout)
[16:09:32.472]         ...future.stdout <- NULL
[16:09:32.472]     }
[16:09:32.472]     ...future.result$conditions <- ...future.conditions
[16:09:32.472]     ...future.result$finished <- base::Sys.time()
[16:09:32.472]     ...future.result
[16:09:32.472] }
[16:09:32.473] assign_globals() ...
[16:09:32.474] List of 5
[16:09:32.474]  $ ...future.FUN            :function (object, ...)  
[16:09:32.474]  $ future.call.arguments    : list()
[16:09:32.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.474]  $ ...future.elements_ii    :List of 3
[16:09:32.474]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.474]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.474]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.474]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.474]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.474]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.474]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.474]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.474]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.474]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.474]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.474]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.474]  $ ...future.seeds_ii       : NULL
[16:09:32.474]  $ ...future.globals.maxSize: NULL
[16:09:32.474]  - attr(*, "resolved")= logi FALSE
[16:09:32.474]  - attr(*, "total_size")= num 1240
[16:09:32.474]  - attr(*, "where")=List of 5
[16:09:32.474]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.474]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.474]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.474]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.474]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.474]  - attr(*, "already-done")= logi TRUE
[16:09:32.483] - copied ‘...future.FUN’ to environment
[16:09:32.483] - copied ‘future.call.arguments’ to environment
[16:09:32.483] - copied ‘...future.elements_ii’ to environment
[16:09:32.483] - copied ‘...future.seeds_ii’ to environment
[16:09:32.483] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.483] assign_globals() ... done
[16:09:32.484] plan(): Setting new future strategy stack:
[16:09:32.484] List of future strategies:
[16:09:32.484] 1. sequential:
[16:09:32.484]    - args: function (..., envir = parent.frame())
[16:09:32.484]    - tweaked: FALSE
[16:09:32.484]    - call: NULL
[16:09:32.484] plan(): nbrOfWorkers() = 1
[16:09:32.486] plan(): Setting new future strategy stack:
[16:09:32.486] List of future strategies:
[16:09:32.486] 1. multicore:
[16:09:32.486]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:32.486]    - tweaked: FALSE
[16:09:32.486]    - call: plan(strategy)
[16:09:32.490] plan(): nbrOfWorkers() = 1
[16:09:32.490] SequentialFuture started (and completed)
[16:09:32.490] - Launch lazy future ... done
[16:09:32.490] run() for ‘SequentialFuture’ ... done
[16:09:32.490] Created future:
[16:09:32.490] SequentialFuture:
[16:09:32.490] Label: ‘future_by-1’
[16:09:32.490] Expression:
[16:09:32.490] {
[16:09:32.490]     do.call(function(...) {
[16:09:32.490]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.490]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.490]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.490]             on.exit(options(oopts), add = TRUE)
[16:09:32.490]         }
[16:09:32.490]         {
[16:09:32.490]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.490]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.490]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.490]             })
[16:09:32.490]         }
[16:09:32.490]     }, args = future.call.arguments)
[16:09:32.490] }
[16:09:32.490] Lazy evaluation: FALSE
[16:09:32.490] Asynchronous evaluation: FALSE
[16:09:32.490] Local evaluation: TRUE
[16:09:32.490] Environment: 0x5567e95cdcd0
[16:09:32.490] Capture standard output: TRUE
[16:09:32.490] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.490] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.490] Packages: <none>
[16:09:32.490] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.490] Resolved: TRUE
[16:09:32.490] Value: 5.37 KiB of class ‘list’
[16:09:32.490] Early signaling: FALSE
[16:09:32.490] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.490] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.491] Chunk #1 of 1 ... DONE
[16:09:32.491] Launching 1 futures (chunks) ... DONE
[16:09:32.492] Resolving 1 futures (chunks) ...
[16:09:32.492] resolve() on list ...
[16:09:32.492]  recursive: 0
[16:09:32.492]  length: 1
[16:09:32.492] 
[16:09:32.492] resolved() for ‘SequentialFuture’ ...
[16:09:32.492] - state: ‘finished’
[16:09:32.492] - run: TRUE
[16:09:32.492] - result: ‘FutureResult’
[16:09:32.492] resolved() for ‘SequentialFuture’ ... done
[16:09:32.493] Future #1
[16:09:32.493] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.493] - nx: 1
[16:09:32.493] - relay: TRUE
[16:09:32.493] - stdout: TRUE
[16:09:32.493] - signal: TRUE
[16:09:32.493] - resignal: FALSE
[16:09:32.493] - force: TRUE
[16:09:32.493] - relayed: [n=1] FALSE
[16:09:32.493] - queued futures: [n=1] FALSE
[16:09:32.493]  - until=1
[16:09:32.494]  - relaying element #1
[16:09:32.494] - relayed: [n=1] TRUE
[16:09:32.494] - queued futures: [n=1] TRUE
[16:09:32.494] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.494]  length: 0 (resolved future 1)
[16:09:32.494] Relaying remaining futures
[16:09:32.494] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.494] - nx: 1
[16:09:32.494] - relay: TRUE
[16:09:32.494] - stdout: TRUE
[16:09:32.494] - signal: TRUE
[16:09:32.495] - resignal: FALSE
[16:09:32.495] - force: TRUE
[16:09:32.495] - relayed: [n=1] TRUE
[16:09:32.495] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.495] - relayed: [n=1] TRUE
[16:09:32.495] - queued futures: [n=1] TRUE
[16:09:32.495] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.495] resolve() on list ... DONE
[16:09:32.495]  - Number of value chunks collected: 1
[16:09:32.496] Resolving 1 futures (chunks) ... DONE
[16:09:32.496] Reducing values from 1 chunks ...
[16:09:32.497]  - Number of values collected after concatenation: 3
[16:09:32.497]  - Number of values expected: 3
[16:09:32.497] Reducing values from 1 chunks ... DONE
[16:09:32.497] future_lapply() ... DONE
[16:09:32.497] future_by_internal() ... DONE
[16:09:32.498] future_by_internal() ...
- plan('multisession') ...
[16:09:32.498] plan(): Setting new future strategy stack:
[16:09:32.498] List of future strategies:
[16:09:32.498] 1. multisession:
[16:09:32.498]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.498]    - tweaked: FALSE
[16:09:32.498]    - call: plan(strategy)
[16:09:32.499] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:09:32.499] multisession:
[16:09:32.499] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.499] - tweaked: FALSE
[16:09:32.499] - call: plan(strategy)
[16:09:32.502] getGlobalsAndPackages() ...
[16:09:32.502] Not searching for globals
[16:09:32.503] - globals: [0] <none>
[16:09:32.503] getGlobalsAndPackages() ... DONE
[16:09:32.503] Packages needed by the future expression (n = 0): <none>
[16:09:32.503] Packages needed by future strategies (n = 0): <none>
[16:09:32.504] {
[16:09:32.504]     {
[16:09:32.504]         {
[16:09:32.504]             ...future.startTime <- base::Sys.time()
[16:09:32.504]             {
[16:09:32.504]                 {
[16:09:32.504]                   {
[16:09:32.504]                     base::local({
[16:09:32.504]                       has_future <- base::requireNamespace("future", 
[16:09:32.504]                         quietly = TRUE)
[16:09:32.504]                       if (has_future) {
[16:09:32.504]                         ns <- base::getNamespace("future")
[16:09:32.504]                         version <- ns[[".package"]][["version"]]
[16:09:32.504]                         if (is.null(version)) 
[16:09:32.504]                           version <- utils::packageVersion("future")
[16:09:32.504]                       }
[16:09:32.504]                       else {
[16:09:32.504]                         version <- NULL
[16:09:32.504]                       }
[16:09:32.504]                       if (!has_future || version < "1.8.0") {
[16:09:32.504]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.504]                           "", base::R.version$version.string), 
[16:09:32.504]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.504]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.504]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.504]                             "release", "version")], collapse = " "), 
[16:09:32.504]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.504]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.504]                           info)
[16:09:32.504]                         info <- base::paste(info, collapse = "; ")
[16:09:32.504]                         if (!has_future) {
[16:09:32.504]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.504]                             info)
[16:09:32.504]                         }
[16:09:32.504]                         else {
[16:09:32.504]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.504]                             info, version)
[16:09:32.504]                         }
[16:09:32.504]                         base::stop(msg)
[16:09:32.504]                       }
[16:09:32.504]                     })
[16:09:32.504]                   }
[16:09:32.504]                   options(future.plan = NULL)
[16:09:32.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.504]                 }
[16:09:32.504]                 ...future.workdir <- getwd()
[16:09:32.504]             }
[16:09:32.504]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.504]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.504]         }
[16:09:32.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:32.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.504]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.504]             base::names(...future.oldOptions))
[16:09:32.504]     }
[16:09:32.504]     if (FALSE) {
[16:09:32.504]     }
[16:09:32.504]     else {
[16:09:32.504]         if (TRUE) {
[16:09:32.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.504]                 open = "w")
[16:09:32.504]         }
[16:09:32.504]         else {
[16:09:32.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.504]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.504]         }
[16:09:32.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.504]             base::sink(type = "output", split = FALSE)
[16:09:32.504]             base::close(...future.stdout)
[16:09:32.504]         }, add = TRUE)
[16:09:32.504]     }
[16:09:32.504]     ...future.frame <- base::sys.nframe()
[16:09:32.504]     ...future.conditions <- base::list()
[16:09:32.504]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.504]     if (FALSE) {
[16:09:32.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.504]     }
[16:09:32.504]     ...future.result <- base::tryCatch({
[16:09:32.504]         base::withCallingHandlers({
[16:09:32.504]             ...future.value <- base::withVisible(base::local(NA))
[16:09:32.504]             future::FutureResult(value = ...future.value$value, 
[16:09:32.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.504]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.504]                     ...future.globalenv.names))
[16:09:32.504]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.504]         }, condition = base::local({
[16:09:32.504]             c <- base::c
[16:09:32.504]             inherits <- base::inherits
[16:09:32.504]             invokeRestart <- base::invokeRestart
[16:09:32.504]             length <- base::length
[16:09:32.504]             list <- base::list
[16:09:32.504]             seq.int <- base::seq.int
[16:09:32.504]             signalCondition <- base::signalCondition
[16:09:32.504]             sys.calls <- base::sys.calls
[16:09:32.504]             `[[` <- base::`[[`
[16:09:32.504]             `+` <- base::`+`
[16:09:32.504]             `<<-` <- base::`<<-`
[16:09:32.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.504]                   3L)]
[16:09:32.504]             }
[16:09:32.504]             function(cond) {
[16:09:32.504]                 is_error <- inherits(cond, "error")
[16:09:32.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.504]                   NULL)
[16:09:32.504]                 if (is_error) {
[16:09:32.504]                   sessionInformation <- function() {
[16:09:32.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.504]                       search = base::search(), system = base::Sys.info())
[16:09:32.504]                   }
[16:09:32.504]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.504]                     cond$call), session = sessionInformation(), 
[16:09:32.504]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.504]                   signalCondition(cond)
[16:09:32.504]                 }
[16:09:32.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.504]                 "immediateCondition"))) {
[16:09:32.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.504]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.504]                   if (TRUE && !signal) {
[16:09:32.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.504]                     {
[16:09:32.504]                       inherits <- base::inherits
[16:09:32.504]                       invokeRestart <- base::invokeRestart
[16:09:32.504]                       is.null <- base::is.null
[16:09:32.504]                       muffled <- FALSE
[16:09:32.504]                       if (inherits(cond, "message")) {
[16:09:32.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.504]                         if (muffled) 
[16:09:32.504]                           invokeRestart("muffleMessage")
[16:09:32.504]                       }
[16:09:32.504]                       else if (inherits(cond, "warning")) {
[16:09:32.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.504]                         if (muffled) 
[16:09:32.504]                           invokeRestart("muffleWarning")
[16:09:32.504]                       }
[16:09:32.504]                       else if (inherits(cond, "condition")) {
[16:09:32.504]                         if (!is.null(pattern)) {
[16:09:32.504]                           computeRestarts <- base::computeRestarts
[16:09:32.504]                           grepl <- base::grepl
[16:09:32.504]                           restarts <- computeRestarts(cond)
[16:09:32.504]                           for (restart in restarts) {
[16:09:32.504]                             name <- restart$name
[16:09:32.504]                             if (is.null(name)) 
[16:09:32.504]                               next
[16:09:32.504]                             if (!grepl(pattern, name)) 
[16:09:32.504]                               next
[16:09:32.504]                             invokeRestart(restart)
[16:09:32.504]                             muffled <- TRUE
[16:09:32.504]                             break
[16:09:32.504]                           }
[16:09:32.504]                         }
[16:09:32.504]                       }
[16:09:32.504]                       invisible(muffled)
[16:09:32.504]                     }
[16:09:32.504]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.504]                   }
[16:09:32.504]                 }
[16:09:32.504]                 else {
[16:09:32.504]                   if (TRUE) {
[16:09:32.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.504]                     {
[16:09:32.504]                       inherits <- base::inherits
[16:09:32.504]                       invokeRestart <- base::invokeRestart
[16:09:32.504]                       is.null <- base::is.null
[16:09:32.504]                       muffled <- FALSE
[16:09:32.504]                       if (inherits(cond, "message")) {
[16:09:32.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.504]                         if (muffled) 
[16:09:32.504]                           invokeRestart("muffleMessage")
[16:09:32.504]                       }
[16:09:32.504]                       else if (inherits(cond, "warning")) {
[16:09:32.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.504]                         if (muffled) 
[16:09:32.504]                           invokeRestart("muffleWarning")
[16:09:32.504]                       }
[16:09:32.504]                       else if (inherits(cond, "condition")) {
[16:09:32.504]                         if (!is.null(pattern)) {
[16:09:32.504]                           computeRestarts <- base::computeRestarts
[16:09:32.504]                           grepl <- base::grepl
[16:09:32.504]                           restarts <- computeRestarts(cond)
[16:09:32.504]                           for (restart in restarts) {
[16:09:32.504]                             name <- restart$name
[16:09:32.504]                             if (is.null(name)) 
[16:09:32.504]                               next
[16:09:32.504]                             if (!grepl(pattern, name)) 
[16:09:32.504]                               next
[16:09:32.504]                             invokeRestart(restart)
[16:09:32.504]                             muffled <- TRUE
[16:09:32.504]                             break
[16:09:32.504]                           }
[16:09:32.504]                         }
[16:09:32.504]                       }
[16:09:32.504]                       invisible(muffled)
[16:09:32.504]                     }
[16:09:32.504]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.504]                   }
[16:09:32.504]                 }
[16:09:32.504]             }
[16:09:32.504]         }))
[16:09:32.504]     }, error = function(ex) {
[16:09:32.504]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.504]                 ...future.rng), started = ...future.startTime, 
[16:09:32.504]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.504]             version = "1.8"), class = "FutureResult")
[16:09:32.504]     }, finally = {
[16:09:32.504]         if (!identical(...future.workdir, getwd())) 
[16:09:32.504]             setwd(...future.workdir)
[16:09:32.504]         {
[16:09:32.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.504]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.504]             }
[16:09:32.504]             base::options(...future.oldOptions)
[16:09:32.504]             if (.Platform$OS.type == "windows") {
[16:09:32.504]                 old_names <- names(...future.oldEnvVars)
[16:09:32.504]                 envs <- base::Sys.getenv()
[16:09:32.504]                 names <- names(envs)
[16:09:32.504]                 common <- intersect(names, old_names)
[16:09:32.504]                 added <- setdiff(names, old_names)
[16:09:32.504]                 removed <- setdiff(old_names, names)
[16:09:32.504]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.504]                   envs[common]]
[16:09:32.504]                 NAMES <- toupper(changed)
[16:09:32.504]                 args <- list()
[16:09:32.504]                 for (kk in seq_along(NAMES)) {
[16:09:32.504]                   name <- changed[[kk]]
[16:09:32.504]                   NAME <- NAMES[[kk]]
[16:09:32.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.504]                     next
[16:09:32.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.504]                 }
[16:09:32.504]                 NAMES <- toupper(added)
[16:09:32.504]                 for (kk in seq_along(NAMES)) {
[16:09:32.504]                   name <- added[[kk]]
[16:09:32.504]                   NAME <- NAMES[[kk]]
[16:09:32.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.504]                     next
[16:09:32.504]                   args[[name]] <- ""
[16:09:32.504]                 }
[16:09:32.504]                 NAMES <- toupper(removed)
[16:09:32.504]                 for (kk in seq_along(NAMES)) {
[16:09:32.504]                   name <- removed[[kk]]
[16:09:32.504]                   NAME <- NAMES[[kk]]
[16:09:32.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.504]                     next
[16:09:32.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.504]                 }
[16:09:32.504]                 if (length(args) > 0) 
[16:09:32.504]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.504]             }
[16:09:32.504]             else {
[16:09:32.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.504]             }
[16:09:32.504]             {
[16:09:32.504]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.504]                   0L) {
[16:09:32.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.504]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.504]                   base::options(opts)
[16:09:32.504]                 }
[16:09:32.504]                 {
[16:09:32.504]                   {
[16:09:32.504]                     NULL
[16:09:32.504]                     RNGkind("Mersenne-Twister")
[16:09:32.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.504]                       inherits = FALSE)
[16:09:32.504]                   }
[16:09:32.504]                   options(future.plan = NULL)
[16:09:32.504]                   if (is.na(NA_character_)) 
[16:09:32.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.504]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.504]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.504]                     envir = parent.frame()) 
[16:09:32.504]                   {
[16:09:32.504]                     if (is.function(workers)) 
[16:09:32.504]                       workers <- workers()
[16:09:32.504]                     workers <- structure(as.integer(workers), 
[16:09:32.504]                       class = class(workers))
[16:09:32.504]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.504]                       workers >= 1)
[16:09:32.504]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.504]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.504]                     }
[16:09:32.504]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.504]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.504]                       envir = envir)
[16:09:32.504]                     if (!future$lazy) 
[16:09:32.504]                       future <- run(future)
[16:09:32.504]                     invisible(future)
[16:09:32.504]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.504]                 }
[16:09:32.504]             }
[16:09:32.504]         }
[16:09:32.504]     })
[16:09:32.504]     if (TRUE) {
[16:09:32.504]         base::sink(type = "output", split = FALSE)
[16:09:32.504]         if (TRUE) {
[16:09:32.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.504]         }
[16:09:32.504]         else {
[16:09:32.504]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.504]         }
[16:09:32.504]         base::close(...future.stdout)
[16:09:32.504]         ...future.stdout <- NULL
[16:09:32.504]     }
[16:09:32.504]     ...future.result$conditions <- ...future.conditions
[16:09:32.504]     ...future.result$finished <- base::Sys.time()
[16:09:32.504]     ...future.result
[16:09:32.504] }
[16:09:32.505] plan(): Setting new future strategy stack:
[16:09:32.505] List of future strategies:
[16:09:32.505] 1. sequential:
[16:09:32.505]    - args: function (..., envir = parent.frame())
[16:09:32.505]    - tweaked: FALSE
[16:09:32.505]    - call: NULL
[16:09:32.506] plan(): nbrOfWorkers() = 1
[16:09:32.506] plan(): Setting new future strategy stack:
[16:09:32.507] List of future strategies:
[16:09:32.507] 1. multisession:
[16:09:32.507]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.507]    - tweaked: FALSE
[16:09:32.507]    - call: plan(strategy)
[16:09:32.510] plan(): nbrOfWorkers() = 1
[16:09:32.510] SequentialFuture started (and completed)
[16:09:32.510] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:09:32.513] plan(): nbrOfWorkers() = 1
[16:09:32.514] future_by_internal() ...
[16:09:32.514] future_lapply() ...
[16:09:32.517] Number of chunks: 1
[16:09:32.517] getGlobalsAndPackagesXApply() ...
[16:09:32.517]  - future.globals: TRUE
[16:09:32.518] getGlobalsAndPackages() ...
[16:09:32.518] Searching for globals...
[16:09:32.519] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.519] Searching for globals ... DONE
[16:09:32.519] Resolving globals: FALSE
[16:09:32.519] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.519] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.520] - globals: [1] ‘FUN’
[16:09:32.520] 
[16:09:32.520] getGlobalsAndPackages() ... DONE
[16:09:32.520]  - globals found/used: [n=1] ‘FUN’
[16:09:32.520]  - needed namespaces: [n=0] 
[16:09:32.520] Finding globals ... DONE
[16:09:32.520]  - use_args: TRUE
[16:09:32.520]  - Getting '...' globals ...
[16:09:32.521] resolve() on list ...
[16:09:32.521]  recursive: 0
[16:09:32.521]  length: 1
[16:09:32.521]  elements: ‘...’
[16:09:32.521]  length: 0 (resolved future 1)
[16:09:32.521] resolve() on list ... DONE
[16:09:32.521]    - '...' content: [n=0] 
[16:09:32.521] List of 1
[16:09:32.521]  $ ...: list()
[16:09:32.521]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.521]  - attr(*, "where")=List of 1
[16:09:32.521]   ..$ ...:<environment: 0x5567e702cec8> 
[16:09:32.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.521]  - attr(*, "resolved")= logi TRUE
[16:09:32.521]  - attr(*, "total_size")= num NA
[16:09:32.524]  - Getting '...' globals ... DONE
[16:09:32.524] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.524] List of 2
[16:09:32.524]  $ ...future.FUN:function (object, ...)  
[16:09:32.524]  $ ...          : list()
[16:09:32.524]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.524]  - attr(*, "where")=List of 2
[16:09:32.524]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.524]   ..$ ...          :<environment: 0x5567e702cec8> 
[16:09:32.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.524]  - attr(*, "resolved")= logi FALSE
[16:09:32.524]  - attr(*, "total_size")= num 1240
[16:09:32.528] Packages to be attached in all futures: [n=0] 
[16:09:32.528] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.528] Number of futures (= number of chunks): 1
[16:09:32.528] Launching 1 futures (chunks) ...
[16:09:32.528] Chunk #1 of 1 ...
[16:09:32.528]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.528] getGlobalsAndPackages() ...
[16:09:32.529] Searching for globals...
[16:09:32.529] 
[16:09:32.529] Searching for globals ... DONE
[16:09:32.529] - globals: [0] <none>
[16:09:32.529] getGlobalsAndPackages() ... DONE
[16:09:32.529]    + additional globals found: [n=0] 
[16:09:32.529]    + additional namespaces needed: [n=0] 
[16:09:32.529]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.530]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.530]  - seeds: <none>
[16:09:32.530] getGlobalsAndPackages() ...
[16:09:32.530] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.530] Resolving globals: FALSE
[16:09:32.530] Tweak future expression to call with '...' arguments ...
[16:09:32.530] {
[16:09:32.530]     do.call(function(...) {
[16:09:32.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.530]             on.exit(options(oopts), add = TRUE)
[16:09:32.530]         }
[16:09:32.530]         {
[16:09:32.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.530]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.530]             })
[16:09:32.530]         }
[16:09:32.530]     }, args = future.call.arguments)
[16:09:32.530] }
[16:09:32.530] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.531] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.531] 
[16:09:32.531] getGlobalsAndPackages() ... DONE
[16:09:32.531] run() for ‘Future’ ...
[16:09:32.531] - state: ‘created’
[16:09:32.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.535] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.535]   - Field: ‘label’
[16:09:32.535]   - Field: ‘local’
[16:09:32.535]   - Field: ‘owner’
[16:09:32.535]   - Field: ‘envir’
[16:09:32.535]   - Field: ‘packages’
[16:09:32.535]   - Field: ‘gc’
[16:09:32.535]   - Field: ‘conditions’
[16:09:32.535]   - Field: ‘expr’
[16:09:32.536]   - Field: ‘uuid’
[16:09:32.536]   - Field: ‘seed’
[16:09:32.536]   - Field: ‘version’
[16:09:32.536]   - Field: ‘result’
[16:09:32.536]   - Field: ‘asynchronous’
[16:09:32.536]   - Field: ‘calls’
[16:09:32.536]   - Field: ‘globals’
[16:09:32.536]   - Field: ‘stdout’
[16:09:32.536]   - Field: ‘earlySignal’
[16:09:32.536]   - Field: ‘lazy’
[16:09:32.536]   - Field: ‘state’
[16:09:32.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.537] - Launch lazy future ...
[16:09:32.537] Packages needed by the future expression (n = 0): <none>
[16:09:32.537] Packages needed by future strategies (n = 0): <none>
[16:09:32.537] {
[16:09:32.537]     {
[16:09:32.537]         {
[16:09:32.537]             ...future.startTime <- base::Sys.time()
[16:09:32.537]             {
[16:09:32.537]                 {
[16:09:32.537]                   {
[16:09:32.537]                     base::local({
[16:09:32.537]                       has_future <- base::requireNamespace("future", 
[16:09:32.537]                         quietly = TRUE)
[16:09:32.537]                       if (has_future) {
[16:09:32.537]                         ns <- base::getNamespace("future")
[16:09:32.537]                         version <- ns[[".package"]][["version"]]
[16:09:32.537]                         if (is.null(version)) 
[16:09:32.537]                           version <- utils::packageVersion("future")
[16:09:32.537]                       }
[16:09:32.537]                       else {
[16:09:32.537]                         version <- NULL
[16:09:32.537]                       }
[16:09:32.537]                       if (!has_future || version < "1.8.0") {
[16:09:32.537]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.537]                           "", base::R.version$version.string), 
[16:09:32.537]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.537]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.537]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.537]                             "release", "version")], collapse = " "), 
[16:09:32.537]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.537]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.537]                           info)
[16:09:32.537]                         info <- base::paste(info, collapse = "; ")
[16:09:32.537]                         if (!has_future) {
[16:09:32.537]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.537]                             info)
[16:09:32.537]                         }
[16:09:32.537]                         else {
[16:09:32.537]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.537]                             info, version)
[16:09:32.537]                         }
[16:09:32.537]                         base::stop(msg)
[16:09:32.537]                       }
[16:09:32.537]                     })
[16:09:32.537]                   }
[16:09:32.537]                   options(future.plan = NULL)
[16:09:32.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.537]                 }
[16:09:32.537]                 ...future.workdir <- getwd()
[16:09:32.537]             }
[16:09:32.537]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.537]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.537]         }
[16:09:32.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.537]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.537]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.537]             base::names(...future.oldOptions))
[16:09:32.537]     }
[16:09:32.537]     if (FALSE) {
[16:09:32.537]     }
[16:09:32.537]     else {
[16:09:32.537]         if (TRUE) {
[16:09:32.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.537]                 open = "w")
[16:09:32.537]         }
[16:09:32.537]         else {
[16:09:32.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.537]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.537]         }
[16:09:32.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.537]             base::sink(type = "output", split = FALSE)
[16:09:32.537]             base::close(...future.stdout)
[16:09:32.537]         }, add = TRUE)
[16:09:32.537]     }
[16:09:32.537]     ...future.frame <- base::sys.nframe()
[16:09:32.537]     ...future.conditions <- base::list()
[16:09:32.537]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.537]     if (FALSE) {
[16:09:32.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.537]     }
[16:09:32.537]     ...future.result <- base::tryCatch({
[16:09:32.537]         base::withCallingHandlers({
[16:09:32.537]             ...future.value <- base::withVisible(base::local({
[16:09:32.537]                 do.call(function(...) {
[16:09:32.537]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.537]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.537]                     ...future.globals.maxSize)) {
[16:09:32.537]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.537]                     on.exit(options(oopts), add = TRUE)
[16:09:32.537]                   }
[16:09:32.537]                   {
[16:09:32.537]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.537]                       FUN = function(jj) {
[16:09:32.537]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.537]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.537]                       })
[16:09:32.537]                   }
[16:09:32.537]                 }, args = future.call.arguments)
[16:09:32.537]             }))
[16:09:32.537]             future::FutureResult(value = ...future.value$value, 
[16:09:32.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.537]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.537]                     ...future.globalenv.names))
[16:09:32.537]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.537]         }, condition = base::local({
[16:09:32.537]             c <- base::c
[16:09:32.537]             inherits <- base::inherits
[16:09:32.537]             invokeRestart <- base::invokeRestart
[16:09:32.537]             length <- base::length
[16:09:32.537]             list <- base::list
[16:09:32.537]             seq.int <- base::seq.int
[16:09:32.537]             signalCondition <- base::signalCondition
[16:09:32.537]             sys.calls <- base::sys.calls
[16:09:32.537]             `[[` <- base::`[[`
[16:09:32.537]             `+` <- base::`+`
[16:09:32.537]             `<<-` <- base::`<<-`
[16:09:32.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.537]                   3L)]
[16:09:32.537]             }
[16:09:32.537]             function(cond) {
[16:09:32.537]                 is_error <- inherits(cond, "error")
[16:09:32.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.537]                   NULL)
[16:09:32.537]                 if (is_error) {
[16:09:32.537]                   sessionInformation <- function() {
[16:09:32.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.537]                       search = base::search(), system = base::Sys.info())
[16:09:32.537]                   }
[16:09:32.537]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.537]                     cond$call), session = sessionInformation(), 
[16:09:32.537]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.537]                   signalCondition(cond)
[16:09:32.537]                 }
[16:09:32.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.537]                 "immediateCondition"))) {
[16:09:32.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.537]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.537]                   if (TRUE && !signal) {
[16:09:32.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.537]                     {
[16:09:32.537]                       inherits <- base::inherits
[16:09:32.537]                       invokeRestart <- base::invokeRestart
[16:09:32.537]                       is.null <- base::is.null
[16:09:32.537]                       muffled <- FALSE
[16:09:32.537]                       if (inherits(cond, "message")) {
[16:09:32.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.537]                         if (muffled) 
[16:09:32.537]                           invokeRestart("muffleMessage")
[16:09:32.537]                       }
[16:09:32.537]                       else if (inherits(cond, "warning")) {
[16:09:32.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.537]                         if (muffled) 
[16:09:32.537]                           invokeRestart("muffleWarning")
[16:09:32.537]                       }
[16:09:32.537]                       else if (inherits(cond, "condition")) {
[16:09:32.537]                         if (!is.null(pattern)) {
[16:09:32.537]                           computeRestarts <- base::computeRestarts
[16:09:32.537]                           grepl <- base::grepl
[16:09:32.537]                           restarts <- computeRestarts(cond)
[16:09:32.537]                           for (restart in restarts) {
[16:09:32.537]                             name <- restart$name
[16:09:32.537]                             if (is.null(name)) 
[16:09:32.537]                               next
[16:09:32.537]                             if (!grepl(pattern, name)) 
[16:09:32.537]                               next
[16:09:32.537]                             invokeRestart(restart)
[16:09:32.537]                             muffled <- TRUE
[16:09:32.537]                             break
[16:09:32.537]                           }
[16:09:32.537]                         }
[16:09:32.537]                       }
[16:09:32.537]                       invisible(muffled)
[16:09:32.537]                     }
[16:09:32.537]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.537]                   }
[16:09:32.537]                 }
[16:09:32.537]                 else {
[16:09:32.537]                   if (TRUE) {
[16:09:32.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.537]                     {
[16:09:32.537]                       inherits <- base::inherits
[16:09:32.537]                       invokeRestart <- base::invokeRestart
[16:09:32.537]                       is.null <- base::is.null
[16:09:32.537]                       muffled <- FALSE
[16:09:32.537]                       if (inherits(cond, "message")) {
[16:09:32.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.537]                         if (muffled) 
[16:09:32.537]                           invokeRestart("muffleMessage")
[16:09:32.537]                       }
[16:09:32.537]                       else if (inherits(cond, "warning")) {
[16:09:32.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.537]                         if (muffled) 
[16:09:32.537]                           invokeRestart("muffleWarning")
[16:09:32.537]                       }
[16:09:32.537]                       else if (inherits(cond, "condition")) {
[16:09:32.537]                         if (!is.null(pattern)) {
[16:09:32.537]                           computeRestarts <- base::computeRestarts
[16:09:32.537]                           grepl <- base::grepl
[16:09:32.537]                           restarts <- computeRestarts(cond)
[16:09:32.537]                           for (restart in restarts) {
[16:09:32.537]                             name <- restart$name
[16:09:32.537]                             if (is.null(name)) 
[16:09:32.537]                               next
[16:09:32.537]                             if (!grepl(pattern, name)) 
[16:09:32.537]                               next
[16:09:32.537]                             invokeRestart(restart)
[16:09:32.537]                             muffled <- TRUE
[16:09:32.537]                             break
[16:09:32.537]                           }
[16:09:32.537]                         }
[16:09:32.537]                       }
[16:09:32.537]                       invisible(muffled)
[16:09:32.537]                     }
[16:09:32.537]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.537]                   }
[16:09:32.537]                 }
[16:09:32.537]             }
[16:09:32.537]         }))
[16:09:32.537]     }, error = function(ex) {
[16:09:32.537]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.537]                 ...future.rng), started = ...future.startTime, 
[16:09:32.537]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.537]             version = "1.8"), class = "FutureResult")
[16:09:32.537]     }, finally = {
[16:09:32.537]         if (!identical(...future.workdir, getwd())) 
[16:09:32.537]             setwd(...future.workdir)
[16:09:32.537]         {
[16:09:32.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.537]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.537]             }
[16:09:32.537]             base::options(...future.oldOptions)
[16:09:32.537]             if (.Platform$OS.type == "windows") {
[16:09:32.537]                 old_names <- names(...future.oldEnvVars)
[16:09:32.537]                 envs <- base::Sys.getenv()
[16:09:32.537]                 names <- names(envs)
[16:09:32.537]                 common <- intersect(names, old_names)
[16:09:32.537]                 added <- setdiff(names, old_names)
[16:09:32.537]                 removed <- setdiff(old_names, names)
[16:09:32.537]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.537]                   envs[common]]
[16:09:32.537]                 NAMES <- toupper(changed)
[16:09:32.537]                 args <- list()
[16:09:32.537]                 for (kk in seq_along(NAMES)) {
[16:09:32.537]                   name <- changed[[kk]]
[16:09:32.537]                   NAME <- NAMES[[kk]]
[16:09:32.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.537]                     next
[16:09:32.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.537]                 }
[16:09:32.537]                 NAMES <- toupper(added)
[16:09:32.537]                 for (kk in seq_along(NAMES)) {
[16:09:32.537]                   name <- added[[kk]]
[16:09:32.537]                   NAME <- NAMES[[kk]]
[16:09:32.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.537]                     next
[16:09:32.537]                   args[[name]] <- ""
[16:09:32.537]                 }
[16:09:32.537]                 NAMES <- toupper(removed)
[16:09:32.537]                 for (kk in seq_along(NAMES)) {
[16:09:32.537]                   name <- removed[[kk]]
[16:09:32.537]                   NAME <- NAMES[[kk]]
[16:09:32.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.537]                     next
[16:09:32.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.537]                 }
[16:09:32.537]                 if (length(args) > 0) 
[16:09:32.537]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.537]             }
[16:09:32.537]             else {
[16:09:32.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.537]             }
[16:09:32.537]             {
[16:09:32.537]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.537]                   0L) {
[16:09:32.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.537]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.537]                   base::options(opts)
[16:09:32.537]                 }
[16:09:32.537]                 {
[16:09:32.537]                   {
[16:09:32.537]                     NULL
[16:09:32.537]                     RNGkind("Mersenne-Twister")
[16:09:32.537]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.537]                       inherits = FALSE)
[16:09:32.537]                   }
[16:09:32.537]                   options(future.plan = NULL)
[16:09:32.537]                   if (is.na(NA_character_)) 
[16:09:32.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.537]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.537]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.537]                     envir = parent.frame()) 
[16:09:32.537]                   {
[16:09:32.537]                     if (is.function(workers)) 
[16:09:32.537]                       workers <- workers()
[16:09:32.537]                     workers <- structure(as.integer(workers), 
[16:09:32.537]                       class = class(workers))
[16:09:32.537]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.537]                       workers >= 1)
[16:09:32.537]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.537]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.537]                     }
[16:09:32.537]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.537]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.537]                       envir = envir)
[16:09:32.537]                     if (!future$lazy) 
[16:09:32.537]                       future <- run(future)
[16:09:32.537]                     invisible(future)
[16:09:32.537]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.537]                 }
[16:09:32.537]             }
[16:09:32.537]         }
[16:09:32.537]     })
[16:09:32.537]     if (TRUE) {
[16:09:32.537]         base::sink(type = "output", split = FALSE)
[16:09:32.537]         if (TRUE) {
[16:09:32.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.537]         }
[16:09:32.537]         else {
[16:09:32.537]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.537]         }
[16:09:32.537]         base::close(...future.stdout)
[16:09:32.537]         ...future.stdout <- NULL
[16:09:32.537]     }
[16:09:32.537]     ...future.result$conditions <- ...future.conditions
[16:09:32.537]     ...future.result$finished <- base::Sys.time()
[16:09:32.537]     ...future.result
[16:09:32.537] }
[16:09:32.539] assign_globals() ...
[16:09:32.539] List of 5
[16:09:32.539]  $ ...future.FUN            :function (object, ...)  
[16:09:32.539]  $ future.call.arguments    : list()
[16:09:32.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.539]  $ ...future.elements_ii    :List of 3
[16:09:32.539]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.539]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.539]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.539]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.539]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.539]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.539]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.539]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.539]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.539]  $ ...future.seeds_ii       : NULL
[16:09:32.539]  $ ...future.globals.maxSize: NULL
[16:09:32.539]  - attr(*, "resolved")= logi FALSE
[16:09:32.539]  - attr(*, "total_size")= num 1240
[16:09:32.539]  - attr(*, "where")=List of 5
[16:09:32.539]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.539]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.539]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.539]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.539]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.539]  - attr(*, "already-done")= logi TRUE
[16:09:32.546] - copied ‘...future.FUN’ to environment
[16:09:32.546] - copied ‘future.call.arguments’ to environment
[16:09:32.546] - copied ‘...future.elements_ii’ to environment
[16:09:32.546] - copied ‘...future.seeds_ii’ to environment
[16:09:32.547] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.547] assign_globals() ... done
[16:09:32.547] plan(): Setting new future strategy stack:
[16:09:32.547] List of future strategies:
[16:09:32.547] 1. sequential:
[16:09:32.547]    - args: function (..., envir = parent.frame())
[16:09:32.547]    - tweaked: FALSE
[16:09:32.547]    - call: NULL
[16:09:32.547] plan(): nbrOfWorkers() = 1
[16:09:32.550] plan(): Setting new future strategy stack:
[16:09:32.550] List of future strategies:
[16:09:32.550] 1. multisession:
[16:09:32.550]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.550]    - tweaked: FALSE
[16:09:32.550]    - call: plan(strategy)
[16:09:32.554] plan(): nbrOfWorkers() = 1
[16:09:32.554] SequentialFuture started (and completed)
[16:09:32.554] - Launch lazy future ... done
[16:09:32.554] run() for ‘SequentialFuture’ ... done
[16:09:32.554] Created future:
[16:09:32.554] SequentialFuture:
[16:09:32.554] Label: ‘future_by-1’
[16:09:32.554] Expression:
[16:09:32.554] {
[16:09:32.554]     do.call(function(...) {
[16:09:32.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.554]             on.exit(options(oopts), add = TRUE)
[16:09:32.554]         }
[16:09:32.554]         {
[16:09:32.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.554]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.554]             })
[16:09:32.554]         }
[16:09:32.554]     }, args = future.call.arguments)
[16:09:32.554] }
[16:09:32.554] Lazy evaluation: FALSE
[16:09:32.554] Asynchronous evaluation: FALSE
[16:09:32.554] Local evaluation: TRUE
[16:09:32.554] Environment: R_GlobalEnv
[16:09:32.554] Capture standard output: TRUE
[16:09:32.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.554] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.554] Packages: <none>
[16:09:32.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.554] Resolved: TRUE
[16:09:32.554] Value: 4.62 KiB of class ‘list’
[16:09:32.554] Early signaling: FALSE
[16:09:32.554] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.554] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.555] Chunk #1 of 1 ... DONE
[16:09:32.556] Launching 1 futures (chunks) ... DONE
[16:09:32.556] Resolving 1 futures (chunks) ...
[16:09:32.556] resolve() on list ...
[16:09:32.556]  recursive: 0
[16:09:32.556]  length: 1
[16:09:32.556] 
[16:09:32.556] resolved() for ‘SequentialFuture’ ...
[16:09:32.556] - state: ‘finished’
[16:09:32.556] - run: TRUE
[16:09:32.556] - result: ‘FutureResult’
[16:09:32.557] resolved() for ‘SequentialFuture’ ... done
[16:09:32.557] Future #1
[16:09:32.557] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.557] - nx: 1
[16:09:32.557] - relay: TRUE
[16:09:32.557] - stdout: TRUE
[16:09:32.557] - signal: TRUE
[16:09:32.557] - resignal: FALSE
[16:09:32.557] - force: TRUE
[16:09:32.557] - relayed: [n=1] FALSE
[16:09:32.557] - queued futures: [n=1] FALSE
[16:09:32.557]  - until=1
[16:09:32.558]  - relaying element #1
[16:09:32.558] - relayed: [n=1] TRUE
[16:09:32.558] - queued futures: [n=1] TRUE
[16:09:32.558] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.558]  length: 0 (resolved future 1)
[16:09:32.558] Relaying remaining futures
[16:09:32.558] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.558] - nx: 1
[16:09:32.558] - relay: TRUE
[16:09:32.558] - stdout: TRUE
[16:09:32.558] - signal: TRUE
[16:09:32.559] - resignal: FALSE
[16:09:32.559] - force: TRUE
[16:09:32.559] - relayed: [n=1] TRUE
[16:09:32.559] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.559] - relayed: [n=1] TRUE
[16:09:32.559] - queued futures: [n=1] TRUE
[16:09:32.559] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.559] resolve() on list ... DONE
[16:09:32.559]  - Number of value chunks collected: 1
[16:09:32.559] Resolving 1 futures (chunks) ... DONE
[16:09:32.559] Reducing values from 1 chunks ...
[16:09:32.560]  - Number of values collected after concatenation: 3
[16:09:32.560]  - Number of values expected: 3
[16:09:32.560] Reducing values from 1 chunks ... DONE
[16:09:32.560] future_lapply() ... DONE
[16:09:32.560] future_by_internal() ... DONE
[16:09:32.560] future_by_internal() ...
[16:09:32.560] future_lapply() ...
[16:09:32.564] Number of chunks: 1
[16:09:32.564] getGlobalsAndPackagesXApply() ...
[16:09:32.564]  - future.globals: TRUE
[16:09:32.564] getGlobalsAndPackages() ...
[16:09:32.564] Searching for globals...
[16:09:32.565] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.565] Searching for globals ... DONE
[16:09:32.565] Resolving globals: FALSE
[16:09:32.566] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.566] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.566] - globals: [1] ‘FUN’
[16:09:32.566] 
[16:09:32.566] getGlobalsAndPackages() ... DONE
[16:09:32.566]  - globals found/used: [n=1] ‘FUN’
[16:09:32.567]  - needed namespaces: [n=0] 
[16:09:32.567] Finding globals ... DONE
[16:09:32.567]  - use_args: TRUE
[16:09:32.567]  - Getting '...' globals ...
[16:09:32.567] resolve() on list ...
[16:09:32.567]  recursive: 0
[16:09:32.567]  length: 1
[16:09:32.567]  elements: ‘...’
[16:09:32.567]  length: 0 (resolved future 1)
[16:09:32.567] resolve() on list ... DONE
[16:09:32.568]    - '...' content: [n=1] ‘digits’
[16:09:32.568] List of 1
[16:09:32.568]  $ ...:List of 1
[16:09:32.568]   ..$ digits: int 2
[16:09:32.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.568]  - attr(*, "where")=List of 1
[16:09:32.568]   ..$ ...:<environment: 0x5567e88bf340> 
[16:09:32.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.568]  - attr(*, "resolved")= logi TRUE
[16:09:32.568]  - attr(*, "total_size")= num NA
[16:09:32.570]  - Getting '...' globals ... DONE
[16:09:32.571] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.571] List of 2
[16:09:32.571]  $ ...future.FUN:function (object, ...)  
[16:09:32.571]  $ ...          :List of 1
[16:09:32.571]   ..$ digits: int 2
[16:09:32.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.571]  - attr(*, "where")=List of 2
[16:09:32.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.571]   ..$ ...          :<environment: 0x5567e88bf340> 
[16:09:32.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.571]  - attr(*, "resolved")= logi FALSE
[16:09:32.571]  - attr(*, "total_size")= num 1296
[16:09:32.575] Packages to be attached in all futures: [n=0] 
[16:09:32.575] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.575] Number of futures (= number of chunks): 1
[16:09:32.575] Launching 1 futures (chunks) ...
[16:09:32.575] Chunk #1 of 1 ...
[16:09:32.575]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.575] getGlobalsAndPackages() ...
[16:09:32.575] Searching for globals...
[16:09:32.576] 
[16:09:32.576] Searching for globals ... DONE
[16:09:32.576] - globals: [0] <none>
[16:09:32.576] getGlobalsAndPackages() ... DONE
[16:09:32.576]    + additional globals found: [n=0] 
[16:09:32.576]    + additional namespaces needed: [n=0] 
[16:09:32.576]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.576]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[16:09:32.576]  - seeds: <none>
[16:09:32.577] getGlobalsAndPackages() ...
[16:09:32.577] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.577] Resolving globals: FALSE
[16:09:32.577] Tweak future expression to call with '...' arguments ...
[16:09:32.577] {
[16:09:32.577]     do.call(function(...) {
[16:09:32.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.577]             on.exit(options(oopts), add = TRUE)
[16:09:32.577]         }
[16:09:32.577]         {
[16:09:32.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.577]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.577]             })
[16:09:32.577]         }
[16:09:32.577]     }, args = future.call.arguments)
[16:09:32.577] }
[16:09:32.577] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.578] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.578] 
[16:09:32.578] getGlobalsAndPackages() ... DONE
[16:09:32.578] run() for ‘Future’ ...
[16:09:32.578] - state: ‘created’
[16:09:32.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.581] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.582]   - Field: ‘label’
[16:09:32.582]   - Field: ‘local’
[16:09:32.582]   - Field: ‘owner’
[16:09:32.582]   - Field: ‘envir’
[16:09:32.582]   - Field: ‘packages’
[16:09:32.582]   - Field: ‘gc’
[16:09:32.582]   - Field: ‘conditions’
[16:09:32.582]   - Field: ‘expr’
[16:09:32.582]   - Field: ‘uuid’
[16:09:32.582]   - Field: ‘seed’
[16:09:32.582]   - Field: ‘version’
[16:09:32.583]   - Field: ‘result’
[16:09:32.583]   - Field: ‘asynchronous’
[16:09:32.583]   - Field: ‘calls’
[16:09:32.583]   - Field: ‘globals’
[16:09:32.583]   - Field: ‘stdout’
[16:09:32.583]   - Field: ‘earlySignal’
[16:09:32.583]   - Field: ‘lazy’
[16:09:32.583]   - Field: ‘state’
[16:09:32.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.583] - Launch lazy future ...
[16:09:32.584] Packages needed by the future expression (n = 0): <none>
[16:09:32.584] Packages needed by future strategies (n = 0): <none>
[16:09:32.584] {
[16:09:32.584]     {
[16:09:32.584]         {
[16:09:32.584]             ...future.startTime <- base::Sys.time()
[16:09:32.584]             {
[16:09:32.584]                 {
[16:09:32.584]                   {
[16:09:32.584]                     base::local({
[16:09:32.584]                       has_future <- base::requireNamespace("future", 
[16:09:32.584]                         quietly = TRUE)
[16:09:32.584]                       if (has_future) {
[16:09:32.584]                         ns <- base::getNamespace("future")
[16:09:32.584]                         version <- ns[[".package"]][["version"]]
[16:09:32.584]                         if (is.null(version)) 
[16:09:32.584]                           version <- utils::packageVersion("future")
[16:09:32.584]                       }
[16:09:32.584]                       else {
[16:09:32.584]                         version <- NULL
[16:09:32.584]                       }
[16:09:32.584]                       if (!has_future || version < "1.8.0") {
[16:09:32.584]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.584]                           "", base::R.version$version.string), 
[16:09:32.584]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.584]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.584]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.584]                             "release", "version")], collapse = " "), 
[16:09:32.584]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.584]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.584]                           info)
[16:09:32.584]                         info <- base::paste(info, collapse = "; ")
[16:09:32.584]                         if (!has_future) {
[16:09:32.584]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.584]                             info)
[16:09:32.584]                         }
[16:09:32.584]                         else {
[16:09:32.584]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.584]                             info, version)
[16:09:32.584]                         }
[16:09:32.584]                         base::stop(msg)
[16:09:32.584]                       }
[16:09:32.584]                     })
[16:09:32.584]                   }
[16:09:32.584]                   options(future.plan = NULL)
[16:09:32.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.584]                 }
[16:09:32.584]                 ...future.workdir <- getwd()
[16:09:32.584]             }
[16:09:32.584]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.584]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.584]         }
[16:09:32.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.584]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[16:09:32.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.584]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.584]             base::names(...future.oldOptions))
[16:09:32.584]     }
[16:09:32.584]     if (FALSE) {
[16:09:32.584]     }
[16:09:32.584]     else {
[16:09:32.584]         if (TRUE) {
[16:09:32.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.584]                 open = "w")
[16:09:32.584]         }
[16:09:32.584]         else {
[16:09:32.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.584]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.584]         }
[16:09:32.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.584]             base::sink(type = "output", split = FALSE)
[16:09:32.584]             base::close(...future.stdout)
[16:09:32.584]         }, add = TRUE)
[16:09:32.584]     }
[16:09:32.584]     ...future.frame <- base::sys.nframe()
[16:09:32.584]     ...future.conditions <- base::list()
[16:09:32.584]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.584]     if (FALSE) {
[16:09:32.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.584]     }
[16:09:32.584]     ...future.result <- base::tryCatch({
[16:09:32.584]         base::withCallingHandlers({
[16:09:32.584]             ...future.value <- base::withVisible(base::local({
[16:09:32.584]                 do.call(function(...) {
[16:09:32.584]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.584]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.584]                     ...future.globals.maxSize)) {
[16:09:32.584]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.584]                     on.exit(options(oopts), add = TRUE)
[16:09:32.584]                   }
[16:09:32.584]                   {
[16:09:32.584]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.584]                       FUN = function(jj) {
[16:09:32.584]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.584]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.584]                       })
[16:09:32.584]                   }
[16:09:32.584]                 }, args = future.call.arguments)
[16:09:32.584]             }))
[16:09:32.584]             future::FutureResult(value = ...future.value$value, 
[16:09:32.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.584]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.584]                     ...future.globalenv.names))
[16:09:32.584]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.584]         }, condition = base::local({
[16:09:32.584]             c <- base::c
[16:09:32.584]             inherits <- base::inherits
[16:09:32.584]             invokeRestart <- base::invokeRestart
[16:09:32.584]             length <- base::length
[16:09:32.584]             list <- base::list
[16:09:32.584]             seq.int <- base::seq.int
[16:09:32.584]             signalCondition <- base::signalCondition
[16:09:32.584]             sys.calls <- base::sys.calls
[16:09:32.584]             `[[` <- base::`[[`
[16:09:32.584]             `+` <- base::`+`
[16:09:32.584]             `<<-` <- base::`<<-`
[16:09:32.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.584]                   3L)]
[16:09:32.584]             }
[16:09:32.584]             function(cond) {
[16:09:32.584]                 is_error <- inherits(cond, "error")
[16:09:32.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.584]                   NULL)
[16:09:32.584]                 if (is_error) {
[16:09:32.584]                   sessionInformation <- function() {
[16:09:32.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.584]                       search = base::search(), system = base::Sys.info())
[16:09:32.584]                   }
[16:09:32.584]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.584]                     cond$call), session = sessionInformation(), 
[16:09:32.584]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.584]                   signalCondition(cond)
[16:09:32.584]                 }
[16:09:32.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.584]                 "immediateCondition"))) {
[16:09:32.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.584]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.584]                   if (TRUE && !signal) {
[16:09:32.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.584]                     {
[16:09:32.584]                       inherits <- base::inherits
[16:09:32.584]                       invokeRestart <- base::invokeRestart
[16:09:32.584]                       is.null <- base::is.null
[16:09:32.584]                       muffled <- FALSE
[16:09:32.584]                       if (inherits(cond, "message")) {
[16:09:32.584]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.584]                         if (muffled) 
[16:09:32.584]                           invokeRestart("muffleMessage")
[16:09:32.584]                       }
[16:09:32.584]                       else if (inherits(cond, "warning")) {
[16:09:32.584]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.584]                         if (muffled) 
[16:09:32.584]                           invokeRestart("muffleWarning")
[16:09:32.584]                       }
[16:09:32.584]                       else if (inherits(cond, "condition")) {
[16:09:32.584]                         if (!is.null(pattern)) {
[16:09:32.584]                           computeRestarts <- base::computeRestarts
[16:09:32.584]                           grepl <- base::grepl
[16:09:32.584]                           restarts <- computeRestarts(cond)
[16:09:32.584]                           for (restart in restarts) {
[16:09:32.584]                             name <- restart$name
[16:09:32.584]                             if (is.null(name)) 
[16:09:32.584]                               next
[16:09:32.584]                             if (!grepl(pattern, name)) 
[16:09:32.584]                               next
[16:09:32.584]                             invokeRestart(restart)
[16:09:32.584]                             muffled <- TRUE
[16:09:32.584]                             break
[16:09:32.584]                           }
[16:09:32.584]                         }
[16:09:32.584]                       }
[16:09:32.584]                       invisible(muffled)
[16:09:32.584]                     }
[16:09:32.584]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.584]                   }
[16:09:32.584]                 }
[16:09:32.584]                 else {
[16:09:32.584]                   if (TRUE) {
[16:09:32.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.584]                     {
[16:09:32.584]                       inherits <- base::inherits
[16:09:32.584]                       invokeRestart <- base::invokeRestart
[16:09:32.584]                       is.null <- base::is.null
[16:09:32.584]                       muffled <- FALSE
[16:09:32.584]                       if (inherits(cond, "message")) {
[16:09:32.584]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.584]                         if (muffled) 
[16:09:32.584]                           invokeRestart("muffleMessage")
[16:09:32.584]                       }
[16:09:32.584]                       else if (inherits(cond, "warning")) {
[16:09:32.584]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.584]                         if (muffled) 
[16:09:32.584]                           invokeRestart("muffleWarning")
[16:09:32.584]                       }
[16:09:32.584]                       else if (inherits(cond, "condition")) {
[16:09:32.584]                         if (!is.null(pattern)) {
[16:09:32.584]                           computeRestarts <- base::computeRestarts
[16:09:32.584]                           grepl <- base::grepl
[16:09:32.584]                           restarts <- computeRestarts(cond)
[16:09:32.584]                           for (restart in restarts) {
[16:09:32.584]                             name <- restart$name
[16:09:32.584]                             if (is.null(name)) 
[16:09:32.584]                               next
[16:09:32.584]                             if (!grepl(pattern, name)) 
[16:09:32.584]                               next
[16:09:32.584]                             invokeRestart(restart)
[16:09:32.584]                             muffled <- TRUE
[16:09:32.584]                             break
[16:09:32.584]                           }
[16:09:32.584]                         }
[16:09:32.584]                       }
[16:09:32.584]                       invisible(muffled)
[16:09:32.584]                     }
[16:09:32.584]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.584]                   }
[16:09:32.584]                 }
[16:09:32.584]             }
[16:09:32.584]         }))
[16:09:32.584]     }, error = function(ex) {
[16:09:32.584]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.584]                 ...future.rng), started = ...future.startTime, 
[16:09:32.584]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.584]             version = "1.8"), class = "FutureResult")
[16:09:32.584]     }, finally = {
[16:09:32.584]         if (!identical(...future.workdir, getwd())) 
[16:09:32.584]             setwd(...future.workdir)
[16:09:32.584]         {
[16:09:32.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.584]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.584]             }
[16:09:32.584]             base::options(...future.oldOptions)
[16:09:32.584]             if (.Platform$OS.type == "windows") {
[16:09:32.584]                 old_names <- names(...future.oldEnvVars)
[16:09:32.584]                 envs <- base::Sys.getenv()
[16:09:32.584]                 names <- names(envs)
[16:09:32.584]                 common <- intersect(names, old_names)
[16:09:32.584]                 added <- setdiff(names, old_names)
[16:09:32.584]                 removed <- setdiff(old_names, names)
[16:09:32.584]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.584]                   envs[common]]
[16:09:32.584]                 NAMES <- toupper(changed)
[16:09:32.584]                 args <- list()
[16:09:32.584]                 for (kk in seq_along(NAMES)) {
[16:09:32.584]                   name <- changed[[kk]]
[16:09:32.584]                   NAME <- NAMES[[kk]]
[16:09:32.584]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.584]                     next
[16:09:32.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.584]                 }
[16:09:32.584]                 NAMES <- toupper(added)
[16:09:32.584]                 for (kk in seq_along(NAMES)) {
[16:09:32.584]                   name <- added[[kk]]
[16:09:32.584]                   NAME <- NAMES[[kk]]
[16:09:32.584]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.584]                     next
[16:09:32.584]                   args[[name]] <- ""
[16:09:32.584]                 }
[16:09:32.584]                 NAMES <- toupper(removed)
[16:09:32.584]                 for (kk in seq_along(NAMES)) {
[16:09:32.584]                   name <- removed[[kk]]
[16:09:32.584]                   NAME <- NAMES[[kk]]
[16:09:32.584]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.584]                     next
[16:09:32.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.584]                 }
[16:09:32.584]                 if (length(args) > 0) 
[16:09:32.584]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.584]             }
[16:09:32.584]             else {
[16:09:32.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.584]             }
[16:09:32.584]             {
[16:09:32.584]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.584]                   0L) {
[16:09:32.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.584]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.584]                   base::options(opts)
[16:09:32.584]                 }
[16:09:32.584]                 {
[16:09:32.584]                   {
[16:09:32.584]                     NULL
[16:09:32.584]                     RNGkind("Mersenne-Twister")
[16:09:32.584]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.584]                       inherits = FALSE)
[16:09:32.584]                   }
[16:09:32.584]                   options(future.plan = NULL)
[16:09:32.584]                   if (is.na(NA_character_)) 
[16:09:32.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.584]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.584]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.584]                     envir = parent.frame()) 
[16:09:32.584]                   {
[16:09:32.584]                     if (is.function(workers)) 
[16:09:32.584]                       workers <- workers()
[16:09:32.584]                     workers <- structure(as.integer(workers), 
[16:09:32.584]                       class = class(workers))
[16:09:32.584]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.584]                       workers >= 1)
[16:09:32.584]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.584]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.584]                     }
[16:09:32.584]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.584]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.584]                       envir = envir)
[16:09:32.584]                     if (!future$lazy) 
[16:09:32.584]                       future <- run(future)
[16:09:32.584]                     invisible(future)
[16:09:32.584]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.584]                 }
[16:09:32.584]             }
[16:09:32.584]         }
[16:09:32.584]     })
[16:09:32.584]     if (TRUE) {
[16:09:32.584]         base::sink(type = "output", split = FALSE)
[16:09:32.584]         if (TRUE) {
[16:09:32.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.584]         }
[16:09:32.584]         else {
[16:09:32.584]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.584]         }
[16:09:32.584]         base::close(...future.stdout)
[16:09:32.584]         ...future.stdout <- NULL
[16:09:32.584]     }
[16:09:32.584]     ...future.result$conditions <- ...future.conditions
[16:09:32.584]     ...future.result$finished <- base::Sys.time()
[16:09:32.584]     ...future.result
[16:09:32.584] }
[16:09:32.586] assign_globals() ...
[16:09:32.586] List of 5
[16:09:32.586]  $ ...future.FUN            :function (object, ...)  
[16:09:32.586]  $ future.call.arguments    :List of 1
[16:09:32.586]   ..$ digits: int 2
[16:09:32.586]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.586]  $ ...future.elements_ii    :List of 6
[16:09:32.586]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:09:32.586]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:09:32.586]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:09:32.586]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:09:32.586]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:09:32.586]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:09:32.586]  $ ...future.seeds_ii       : NULL
[16:09:32.586]  $ ...future.globals.maxSize: NULL
[16:09:32.586]  - attr(*, "resolved")= logi FALSE
[16:09:32.586]  - attr(*, "total_size")= num 1296
[16:09:32.586]  - attr(*, "where")=List of 5
[16:09:32.586]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.586]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.586]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.586]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.586]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.586]  - attr(*, "already-done")= logi TRUE
[16:09:32.592] - copied ‘...future.FUN’ to environment
[16:09:32.592] - copied ‘future.call.arguments’ to environment
[16:09:32.592] - copied ‘...future.elements_ii’ to environment
[16:09:32.592] - copied ‘...future.seeds_ii’ to environment
[16:09:32.593] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.593] assign_globals() ... done
[16:09:32.593] plan(): Setting new future strategy stack:
[16:09:32.593] List of future strategies:
[16:09:32.593] 1. sequential:
[16:09:32.593]    - args: function (..., envir = parent.frame())
[16:09:32.593]    - tweaked: FALSE
[16:09:32.593]    - call: NULL
[16:09:32.593] plan(): nbrOfWorkers() = 1
[16:09:32.596] plan(): Setting new future strategy stack:
[16:09:32.596] List of future strategies:
[16:09:32.596] 1. multisession:
[16:09:32.596]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.596]    - tweaked: FALSE
[16:09:32.596]    - call: plan(strategy)
[16:09:32.599] plan(): nbrOfWorkers() = 1
[16:09:32.599] SequentialFuture started (and completed)
[16:09:32.599] - Launch lazy future ... done
[16:09:32.599] run() for ‘SequentialFuture’ ... done
[16:09:32.600] Created future:
[16:09:32.600] SequentialFuture:
[16:09:32.600] Label: ‘future_by-1’
[16:09:32.600] Expression:
[16:09:32.600] {
[16:09:32.600]     do.call(function(...) {
[16:09:32.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.600]             on.exit(options(oopts), add = TRUE)
[16:09:32.600]         }
[16:09:32.600]         {
[16:09:32.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.600]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.600]             })
[16:09:32.600]         }
[16:09:32.600]     }, args = future.call.arguments)
[16:09:32.600] }
[16:09:32.600] Lazy evaluation: FALSE
[16:09:32.600] Asynchronous evaluation: FALSE
[16:09:32.600] Local evaluation: TRUE
[16:09:32.600] Environment: R_GlobalEnv
[16:09:32.600] Capture standard output: TRUE
[16:09:32.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.600] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.600] Packages: <none>
[16:09:32.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.600] Resolved: TRUE
[16:09:32.600] Value: 5.48 KiB of class ‘list’
[16:09:32.600] Early signaling: FALSE
[16:09:32.600] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.600] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.601] Chunk #1 of 1 ... DONE
[16:09:32.601] Launching 1 futures (chunks) ... DONE
[16:09:32.601] Resolving 1 futures (chunks) ...
[16:09:32.601] resolve() on list ...
[16:09:32.601]  recursive: 0
[16:09:32.601]  length: 1
[16:09:32.601] 
[16:09:32.601] resolved() for ‘SequentialFuture’ ...
[16:09:32.601] - state: ‘finished’
[16:09:32.601] - run: TRUE
[16:09:32.602] - result: ‘FutureResult’
[16:09:32.602] resolved() for ‘SequentialFuture’ ... done
[16:09:32.602] Future #1
[16:09:32.602] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.602] - nx: 1
[16:09:32.602] - relay: TRUE
[16:09:32.602] - stdout: TRUE
[16:09:32.602] - signal: TRUE
[16:09:32.602] - resignal: FALSE
[16:09:32.602] - force: TRUE
[16:09:32.602] - relayed: [n=1] FALSE
[16:09:32.602] - queued futures: [n=1] FALSE
[16:09:32.603]  - until=1
[16:09:32.603]  - relaying element #1
[16:09:32.603] - relayed: [n=1] TRUE
[16:09:32.603] - queued futures: [n=1] TRUE
[16:09:32.603] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.603]  length: 0 (resolved future 1)
[16:09:32.603] Relaying remaining futures
[16:09:32.603] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.603] - nx: 1
[16:09:32.603] - relay: TRUE
[16:09:32.603] - stdout: TRUE
[16:09:32.604] - signal: TRUE
[16:09:32.604] - resignal: FALSE
[16:09:32.604] - force: TRUE
[16:09:32.604] - relayed: [n=1] TRUE
[16:09:32.604] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.604] - relayed: [n=1] TRUE
[16:09:32.604] - queued futures: [n=1] TRUE
[16:09:32.604] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.604] resolve() on list ... DONE
[16:09:32.604]  - Number of value chunks collected: 1
[16:09:32.605] Resolving 1 futures (chunks) ... DONE
[16:09:32.605] Reducing values from 1 chunks ...
[16:09:32.605]  - Number of values collected after concatenation: 6
[16:09:32.605]  - Number of values expected: 6
[16:09:32.605] Reducing values from 1 chunks ... DONE
[16:09:32.605] future_lapply() ... DONE
[16:09:32.605] future_by_internal() ... DONE
[16:09:32.606] future_by_internal() ...
[16:09:32.606] future_lapply() ...
[16:09:32.610] Number of chunks: 1
[16:09:32.610] getGlobalsAndPackagesXApply() ...
[16:09:32.610]  - future.globals: TRUE
[16:09:32.610] getGlobalsAndPackages() ...
[16:09:32.610] Searching for globals...
[16:09:32.612] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.612] Searching for globals ... DONE
[16:09:32.612] Resolving globals: FALSE
[16:09:32.613] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:09:32.613] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:09:32.613] - globals: [1] ‘FUN’
[16:09:32.613] - packages: [1] ‘stats’
[16:09:32.613] getGlobalsAndPackages() ... DONE
[16:09:32.613]  - globals found/used: [n=1] ‘FUN’
[16:09:32.613]  - needed namespaces: [n=1] ‘stats’
[16:09:32.614] Finding globals ... DONE
[16:09:32.614]  - use_args: TRUE
[16:09:32.614]  - Getting '...' globals ...
[16:09:32.614] resolve() on list ...
[16:09:32.614]  recursive: 0
[16:09:32.614]  length: 1
[16:09:32.614]  elements: ‘...’
[16:09:32.614]  length: 0 (resolved future 1)
[16:09:32.614] resolve() on list ... DONE
[16:09:32.615]    - '...' content: [n=1] ‘singular.ok’
[16:09:32.615] List of 1
[16:09:32.615]  $ ...:List of 1
[16:09:32.615]   ..$ singular.ok: logi FALSE
[16:09:32.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.615]  - attr(*, "where")=List of 1
[16:09:32.615]   ..$ ...:<environment: 0x5567e8a17e28> 
[16:09:32.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.615]  - attr(*, "resolved")= logi TRUE
[16:09:32.615]  - attr(*, "total_size")= num NA
[16:09:32.619]  - Getting '...' globals ... DONE
[16:09:32.619] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.620] List of 2
[16:09:32.620]  $ ...future.FUN:function (x, ...)  
[16:09:32.620]  $ ...          :List of 1
[16:09:32.620]   ..$ singular.ok: logi FALSE
[16:09:32.620]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.620]  - attr(*, "where")=List of 2
[16:09:32.620]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.620]   ..$ ...          :<environment: 0x5567e8a17e28> 
[16:09:32.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.620]  - attr(*, "resolved")= logi FALSE
[16:09:32.620]  - attr(*, "total_size")= num 5384
[16:09:32.623] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.623] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.623] Number of futures (= number of chunks): 1
[16:09:32.623] Launching 1 futures (chunks) ...
[16:09:32.623] Chunk #1 of 1 ...
[16:09:32.623]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.623] getGlobalsAndPackages() ...
[16:09:32.623] Searching for globals...
[16:09:32.624] 
[16:09:32.624] Searching for globals ... DONE
[16:09:32.624] - globals: [0] <none>
[16:09:32.624] getGlobalsAndPackages() ... DONE
[16:09:32.624]    + additional globals found: [n=0] 
[16:09:32.624]    + additional namespaces needed: [n=0] 
[16:09:32.625]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.625]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.625]  - seeds: <none>
[16:09:32.625] getGlobalsAndPackages() ...
[16:09:32.625] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.625] Resolving globals: FALSE
[16:09:32.625] Tweak future expression to call with '...' arguments ...
[16:09:32.625] {
[16:09:32.625]     do.call(function(...) {
[16:09:32.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.625]             on.exit(options(oopts), add = TRUE)
[16:09:32.625]         }
[16:09:32.625]         {
[16:09:32.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.625]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.625]             })
[16:09:32.625]         }
[16:09:32.625]     }, args = future.call.arguments)
[16:09:32.625] }
[16:09:32.625] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.626] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.626] 
[16:09:32.626] getGlobalsAndPackages() ... DONE
[16:09:32.626] run() for ‘Future’ ...
[16:09:32.626] - state: ‘created’
[16:09:32.627] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.630] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.630]   - Field: ‘label’
[16:09:32.630]   - Field: ‘local’
[16:09:32.630]   - Field: ‘owner’
[16:09:32.630]   - Field: ‘envir’
[16:09:32.631]   - Field: ‘packages’
[16:09:32.631]   - Field: ‘gc’
[16:09:32.631]   - Field: ‘conditions’
[16:09:32.631]   - Field: ‘expr’
[16:09:32.631]   - Field: ‘uuid’
[16:09:32.631]   - Field: ‘seed’
[16:09:32.631]   - Field: ‘version’
[16:09:32.631]   - Field: ‘result’
[16:09:32.631]   - Field: ‘asynchronous’
[16:09:32.631]   - Field: ‘calls’
[16:09:32.631]   - Field: ‘globals’
[16:09:32.631]   - Field: ‘stdout’
[16:09:32.632]   - Field: ‘earlySignal’
[16:09:32.632]   - Field: ‘lazy’
[16:09:32.632]   - Field: ‘state’
[16:09:32.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.632] - Launch lazy future ...
[16:09:32.632] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.632] Packages needed by future strategies (n = 0): <none>
[16:09:32.633] {
[16:09:32.633]     {
[16:09:32.633]         {
[16:09:32.633]             ...future.startTime <- base::Sys.time()
[16:09:32.633]             {
[16:09:32.633]                 {
[16:09:32.633]                   {
[16:09:32.633]                     {
[16:09:32.633]                       base::local({
[16:09:32.633]                         has_future <- base::requireNamespace("future", 
[16:09:32.633]                           quietly = TRUE)
[16:09:32.633]                         if (has_future) {
[16:09:32.633]                           ns <- base::getNamespace("future")
[16:09:32.633]                           version <- ns[[".package"]][["version"]]
[16:09:32.633]                           if (is.null(version)) 
[16:09:32.633]                             version <- utils::packageVersion("future")
[16:09:32.633]                         }
[16:09:32.633]                         else {
[16:09:32.633]                           version <- NULL
[16:09:32.633]                         }
[16:09:32.633]                         if (!has_future || version < "1.8.0") {
[16:09:32.633]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.633]                             "", base::R.version$version.string), 
[16:09:32.633]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.633]                               "release", "version")], collapse = " "), 
[16:09:32.633]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.633]                             info)
[16:09:32.633]                           info <- base::paste(info, collapse = "; ")
[16:09:32.633]                           if (!has_future) {
[16:09:32.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.633]                               info)
[16:09:32.633]                           }
[16:09:32.633]                           else {
[16:09:32.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.633]                               info, version)
[16:09:32.633]                           }
[16:09:32.633]                           base::stop(msg)
[16:09:32.633]                         }
[16:09:32.633]                       })
[16:09:32.633]                     }
[16:09:32.633]                     base::local({
[16:09:32.633]                       for (pkg in "stats") {
[16:09:32.633]                         base::loadNamespace(pkg)
[16:09:32.633]                         base::library(pkg, character.only = TRUE)
[16:09:32.633]                       }
[16:09:32.633]                     })
[16:09:32.633]                   }
[16:09:32.633]                   options(future.plan = NULL)
[16:09:32.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.633]                 }
[16:09:32.633]                 ...future.workdir <- getwd()
[16:09:32.633]             }
[16:09:32.633]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.633]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.633]         }
[16:09:32.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.633]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.633]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.633]             base::names(...future.oldOptions))
[16:09:32.633]     }
[16:09:32.633]     if (FALSE) {
[16:09:32.633]     }
[16:09:32.633]     else {
[16:09:32.633]         if (TRUE) {
[16:09:32.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.633]                 open = "w")
[16:09:32.633]         }
[16:09:32.633]         else {
[16:09:32.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.633]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.633]         }
[16:09:32.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.633]             base::sink(type = "output", split = FALSE)
[16:09:32.633]             base::close(...future.stdout)
[16:09:32.633]         }, add = TRUE)
[16:09:32.633]     }
[16:09:32.633]     ...future.frame <- base::sys.nframe()
[16:09:32.633]     ...future.conditions <- base::list()
[16:09:32.633]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.633]     if (FALSE) {
[16:09:32.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.633]     }
[16:09:32.633]     ...future.result <- base::tryCatch({
[16:09:32.633]         base::withCallingHandlers({
[16:09:32.633]             ...future.value <- base::withVisible(base::local({
[16:09:32.633]                 do.call(function(...) {
[16:09:32.633]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.633]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.633]                     ...future.globals.maxSize)) {
[16:09:32.633]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.633]                     on.exit(options(oopts), add = TRUE)
[16:09:32.633]                   }
[16:09:32.633]                   {
[16:09:32.633]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.633]                       FUN = function(jj) {
[16:09:32.633]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.633]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.633]                       })
[16:09:32.633]                   }
[16:09:32.633]                 }, args = future.call.arguments)
[16:09:32.633]             }))
[16:09:32.633]             future::FutureResult(value = ...future.value$value, 
[16:09:32.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.633]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.633]                     ...future.globalenv.names))
[16:09:32.633]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.633]         }, condition = base::local({
[16:09:32.633]             c <- base::c
[16:09:32.633]             inherits <- base::inherits
[16:09:32.633]             invokeRestart <- base::invokeRestart
[16:09:32.633]             length <- base::length
[16:09:32.633]             list <- base::list
[16:09:32.633]             seq.int <- base::seq.int
[16:09:32.633]             signalCondition <- base::signalCondition
[16:09:32.633]             sys.calls <- base::sys.calls
[16:09:32.633]             `[[` <- base::`[[`
[16:09:32.633]             `+` <- base::`+`
[16:09:32.633]             `<<-` <- base::`<<-`
[16:09:32.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.633]                   3L)]
[16:09:32.633]             }
[16:09:32.633]             function(cond) {
[16:09:32.633]                 is_error <- inherits(cond, "error")
[16:09:32.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.633]                   NULL)
[16:09:32.633]                 if (is_error) {
[16:09:32.633]                   sessionInformation <- function() {
[16:09:32.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.633]                       search = base::search(), system = base::Sys.info())
[16:09:32.633]                   }
[16:09:32.633]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.633]                     cond$call), session = sessionInformation(), 
[16:09:32.633]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.633]                   signalCondition(cond)
[16:09:32.633]                 }
[16:09:32.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.633]                 "immediateCondition"))) {
[16:09:32.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.633]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.633]                   if (TRUE && !signal) {
[16:09:32.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.633]                     {
[16:09:32.633]                       inherits <- base::inherits
[16:09:32.633]                       invokeRestart <- base::invokeRestart
[16:09:32.633]                       is.null <- base::is.null
[16:09:32.633]                       muffled <- FALSE
[16:09:32.633]                       if (inherits(cond, "message")) {
[16:09:32.633]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.633]                         if (muffled) 
[16:09:32.633]                           invokeRestart("muffleMessage")
[16:09:32.633]                       }
[16:09:32.633]                       else if (inherits(cond, "warning")) {
[16:09:32.633]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.633]                         if (muffled) 
[16:09:32.633]                           invokeRestart("muffleWarning")
[16:09:32.633]                       }
[16:09:32.633]                       else if (inherits(cond, "condition")) {
[16:09:32.633]                         if (!is.null(pattern)) {
[16:09:32.633]                           computeRestarts <- base::computeRestarts
[16:09:32.633]                           grepl <- base::grepl
[16:09:32.633]                           restarts <- computeRestarts(cond)
[16:09:32.633]                           for (restart in restarts) {
[16:09:32.633]                             name <- restart$name
[16:09:32.633]                             if (is.null(name)) 
[16:09:32.633]                               next
[16:09:32.633]                             if (!grepl(pattern, name)) 
[16:09:32.633]                               next
[16:09:32.633]                             invokeRestart(restart)
[16:09:32.633]                             muffled <- TRUE
[16:09:32.633]                             break
[16:09:32.633]                           }
[16:09:32.633]                         }
[16:09:32.633]                       }
[16:09:32.633]                       invisible(muffled)
[16:09:32.633]                     }
[16:09:32.633]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.633]                   }
[16:09:32.633]                 }
[16:09:32.633]                 else {
[16:09:32.633]                   if (TRUE) {
[16:09:32.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.633]                     {
[16:09:32.633]                       inherits <- base::inherits
[16:09:32.633]                       invokeRestart <- base::invokeRestart
[16:09:32.633]                       is.null <- base::is.null
[16:09:32.633]                       muffled <- FALSE
[16:09:32.633]                       if (inherits(cond, "message")) {
[16:09:32.633]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.633]                         if (muffled) 
[16:09:32.633]                           invokeRestart("muffleMessage")
[16:09:32.633]                       }
[16:09:32.633]                       else if (inherits(cond, "warning")) {
[16:09:32.633]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.633]                         if (muffled) 
[16:09:32.633]                           invokeRestart("muffleWarning")
[16:09:32.633]                       }
[16:09:32.633]                       else if (inherits(cond, "condition")) {
[16:09:32.633]                         if (!is.null(pattern)) {
[16:09:32.633]                           computeRestarts <- base::computeRestarts
[16:09:32.633]                           grepl <- base::grepl
[16:09:32.633]                           restarts <- computeRestarts(cond)
[16:09:32.633]                           for (restart in restarts) {
[16:09:32.633]                             name <- restart$name
[16:09:32.633]                             if (is.null(name)) 
[16:09:32.633]                               next
[16:09:32.633]                             if (!grepl(pattern, name)) 
[16:09:32.633]                               next
[16:09:32.633]                             invokeRestart(restart)
[16:09:32.633]                             muffled <- TRUE
[16:09:32.633]                             break
[16:09:32.633]                           }
[16:09:32.633]                         }
[16:09:32.633]                       }
[16:09:32.633]                       invisible(muffled)
[16:09:32.633]                     }
[16:09:32.633]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.633]                   }
[16:09:32.633]                 }
[16:09:32.633]             }
[16:09:32.633]         }))
[16:09:32.633]     }, error = function(ex) {
[16:09:32.633]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.633]                 ...future.rng), started = ...future.startTime, 
[16:09:32.633]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.633]             version = "1.8"), class = "FutureResult")
[16:09:32.633]     }, finally = {
[16:09:32.633]         if (!identical(...future.workdir, getwd())) 
[16:09:32.633]             setwd(...future.workdir)
[16:09:32.633]         {
[16:09:32.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.633]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.633]             }
[16:09:32.633]             base::options(...future.oldOptions)
[16:09:32.633]             if (.Platform$OS.type == "windows") {
[16:09:32.633]                 old_names <- names(...future.oldEnvVars)
[16:09:32.633]                 envs <- base::Sys.getenv()
[16:09:32.633]                 names <- names(envs)
[16:09:32.633]                 common <- intersect(names, old_names)
[16:09:32.633]                 added <- setdiff(names, old_names)
[16:09:32.633]                 removed <- setdiff(old_names, names)
[16:09:32.633]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.633]                   envs[common]]
[16:09:32.633]                 NAMES <- toupper(changed)
[16:09:32.633]                 args <- list()
[16:09:32.633]                 for (kk in seq_along(NAMES)) {
[16:09:32.633]                   name <- changed[[kk]]
[16:09:32.633]                   NAME <- NAMES[[kk]]
[16:09:32.633]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.633]                     next
[16:09:32.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.633]                 }
[16:09:32.633]                 NAMES <- toupper(added)
[16:09:32.633]                 for (kk in seq_along(NAMES)) {
[16:09:32.633]                   name <- added[[kk]]
[16:09:32.633]                   NAME <- NAMES[[kk]]
[16:09:32.633]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.633]                     next
[16:09:32.633]                   args[[name]] <- ""
[16:09:32.633]                 }
[16:09:32.633]                 NAMES <- toupper(removed)
[16:09:32.633]                 for (kk in seq_along(NAMES)) {
[16:09:32.633]                   name <- removed[[kk]]
[16:09:32.633]                   NAME <- NAMES[[kk]]
[16:09:32.633]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.633]                     next
[16:09:32.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.633]                 }
[16:09:32.633]                 if (length(args) > 0) 
[16:09:32.633]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.633]             }
[16:09:32.633]             else {
[16:09:32.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.633]             }
[16:09:32.633]             {
[16:09:32.633]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.633]                   0L) {
[16:09:32.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.633]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.633]                   base::options(opts)
[16:09:32.633]                 }
[16:09:32.633]                 {
[16:09:32.633]                   {
[16:09:32.633]                     NULL
[16:09:32.633]                     RNGkind("Mersenne-Twister")
[16:09:32.633]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.633]                       inherits = FALSE)
[16:09:32.633]                   }
[16:09:32.633]                   options(future.plan = NULL)
[16:09:32.633]                   if (is.na(NA_character_)) 
[16:09:32.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.633]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.633]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.633]                     envir = parent.frame()) 
[16:09:32.633]                   {
[16:09:32.633]                     if (is.function(workers)) 
[16:09:32.633]                       workers <- workers()
[16:09:32.633]                     workers <- structure(as.integer(workers), 
[16:09:32.633]                       class = class(workers))
[16:09:32.633]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.633]                       workers >= 1)
[16:09:32.633]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.633]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.633]                     }
[16:09:32.633]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.633]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.633]                       envir = envir)
[16:09:32.633]                     if (!future$lazy) 
[16:09:32.633]                       future <- run(future)
[16:09:32.633]                     invisible(future)
[16:09:32.633]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.633]                 }
[16:09:32.633]             }
[16:09:32.633]         }
[16:09:32.633]     })
[16:09:32.633]     if (TRUE) {
[16:09:32.633]         base::sink(type = "output", split = FALSE)
[16:09:32.633]         if (TRUE) {
[16:09:32.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.633]         }
[16:09:32.633]         else {
[16:09:32.633]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.633]         }
[16:09:32.633]         base::close(...future.stdout)
[16:09:32.633]         ...future.stdout <- NULL
[16:09:32.633]     }
[16:09:32.633]     ...future.result$conditions <- ...future.conditions
[16:09:32.633]     ...future.result$finished <- base::Sys.time()
[16:09:32.633]     ...future.result
[16:09:32.633] }
[16:09:32.635] assign_globals() ...
[16:09:32.635] List of 5
[16:09:32.635]  $ ...future.FUN            :function (x, ...)  
[16:09:32.635]  $ future.call.arguments    :List of 1
[16:09:32.635]   ..$ singular.ok: logi FALSE
[16:09:32.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.635]  $ ...future.elements_ii    :List of 3
[16:09:32.635]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.635]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.635]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.635]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.635]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.635]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.635]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.635]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.635]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.635]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.635]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.635]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.635]  $ ...future.seeds_ii       : NULL
[16:09:32.635]  $ ...future.globals.maxSize: NULL
[16:09:32.635]  - attr(*, "resolved")= logi FALSE
[16:09:32.635]  - attr(*, "total_size")= num 5384
[16:09:32.635]  - attr(*, "where")=List of 5
[16:09:32.635]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.635]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.635]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.635]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.635]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.635]  - attr(*, "already-done")= logi TRUE
[16:09:32.645] - reassign environment for ‘...future.FUN’
[16:09:32.645] - copied ‘...future.FUN’ to environment
[16:09:32.645] - copied ‘future.call.arguments’ to environment
[16:09:32.645] - copied ‘...future.elements_ii’ to environment
[16:09:32.645] - copied ‘...future.seeds_ii’ to environment
[16:09:32.645] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.645] assign_globals() ... done
[16:09:32.646] plan(): Setting new future strategy stack:
[16:09:32.646] List of future strategies:
[16:09:32.646] 1. sequential:
[16:09:32.646]    - args: function (..., envir = parent.frame())
[16:09:32.646]    - tweaked: FALSE
[16:09:32.646]    - call: NULL
[16:09:32.646] plan(): nbrOfWorkers() = 1
[16:09:32.649] plan(): Setting new future strategy stack:
[16:09:32.649] List of future strategies:
[16:09:32.649] 1. multisession:
[16:09:32.649]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.649]    - tweaked: FALSE
[16:09:32.649]    - call: plan(strategy)
[16:09:32.652] plan(): nbrOfWorkers() = 1
[16:09:32.653] SequentialFuture started (and completed)
[16:09:32.653] - Launch lazy future ... done
[16:09:32.653] run() for ‘SequentialFuture’ ... done
[16:09:32.653] Created future:
[16:09:32.653] SequentialFuture:
[16:09:32.653] Label: ‘future_by-1’
[16:09:32.653] Expression:
[16:09:32.653] {
[16:09:32.653]     do.call(function(...) {
[16:09:32.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.653]             on.exit(options(oopts), add = TRUE)
[16:09:32.653]         }
[16:09:32.653]         {
[16:09:32.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.653]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.653]             })
[16:09:32.653]         }
[16:09:32.653]     }, args = future.call.arguments)
[16:09:32.653] }
[16:09:32.653] Lazy evaluation: FALSE
[16:09:32.653] Asynchronous evaluation: FALSE
[16:09:32.653] Local evaluation: TRUE
[16:09:32.653] Environment: R_GlobalEnv
[16:09:32.653] Capture standard output: TRUE
[16:09:32.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.653] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.653] Packages: 1 packages (‘stats’)
[16:09:32.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.653] Resolved: TRUE
[16:09:32.653] Value: 26.06 KiB of class ‘list’
[16:09:32.653] Early signaling: FALSE
[16:09:32.653] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.653] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.654] Chunk #1 of 1 ... DONE
[16:09:32.655] Launching 1 futures (chunks) ... DONE
[16:09:32.655] Resolving 1 futures (chunks) ...
[16:09:32.655] resolve() on list ...
[16:09:32.655]  recursive: 0
[16:09:32.655]  length: 1
[16:09:32.655] 
[16:09:32.655] resolved() for ‘SequentialFuture’ ...
[16:09:32.655] - state: ‘finished’
[16:09:32.655] - run: TRUE
[16:09:32.655] - result: ‘FutureResult’
[16:09:32.655] resolved() for ‘SequentialFuture’ ... done
[16:09:32.656] Future #1
[16:09:32.656] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.656] - nx: 1
[16:09:32.656] - relay: TRUE
[16:09:32.656] - stdout: TRUE
[16:09:32.656] - signal: TRUE
[16:09:32.656] - resignal: FALSE
[16:09:32.656] - force: TRUE
[16:09:32.656] - relayed: [n=1] FALSE
[16:09:32.656] - queued futures: [n=1] FALSE
[16:09:32.656]  - until=1
[16:09:32.657]  - relaying element #1
[16:09:32.657] - relayed: [n=1] TRUE
[16:09:32.657] - queued futures: [n=1] TRUE
[16:09:32.657] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.657]  length: 0 (resolved future 1)
[16:09:32.657] Relaying remaining futures
[16:09:32.657] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.657] - nx: 1
[16:09:32.657] - relay: TRUE
[16:09:32.657] - stdout: TRUE
[16:09:32.658] - signal: TRUE
[16:09:32.658] - resignal: FALSE
[16:09:32.658] - force: TRUE
[16:09:32.658] - relayed: [n=1] TRUE
[16:09:32.658] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.658] - relayed: [n=1] TRUE
[16:09:32.658] - queued futures: [n=1] TRUE
[16:09:32.658] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.658] resolve() on list ... DONE
[16:09:32.658]  - Number of value chunks collected: 1
[16:09:32.658] Resolving 1 futures (chunks) ... DONE
[16:09:32.659] Reducing values from 1 chunks ...
[16:09:32.659]  - Number of values collected after concatenation: 3
[16:09:32.659]  - Number of values expected: 3
[16:09:32.659] Reducing values from 1 chunks ... DONE
[16:09:32.659] future_lapply() ... DONE
[16:09:32.659] future_by_internal() ... DONE
[16:09:32.664] future_by_internal() ...
[16:09:32.664] future_lapply() ...
[16:09:32.668] Number of chunks: 1
[16:09:32.668] getGlobalsAndPackagesXApply() ...
[16:09:32.668]  - future.globals: TRUE
[16:09:32.668] getGlobalsAndPackages() ...
[16:09:32.669] Searching for globals...
[16:09:32.670] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.670] Searching for globals ... DONE
[16:09:32.670] Resolving globals: FALSE
[16:09:32.671] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:09:32.671] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:09:32.671] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.671] - packages: [1] ‘stats’
[16:09:32.672] getGlobalsAndPackages() ... DONE
[16:09:32.672]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.672]  - needed namespaces: [n=1] ‘stats’
[16:09:32.672] Finding globals ... DONE
[16:09:32.672]  - use_args: TRUE
[16:09:32.672]  - Getting '...' globals ...
[16:09:32.672] resolve() on list ...
[16:09:32.672]  recursive: 0
[16:09:32.672]  length: 1
[16:09:32.673]  elements: ‘...’
[16:09:32.673]  length: 0 (resolved future 1)
[16:09:32.673] resolve() on list ... DONE
[16:09:32.673]    - '...' content: [n=0] 
[16:09:32.673] List of 1
[16:09:32.673]  $ ...: list()
[16:09:32.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.673]  - attr(*, "where")=List of 1
[16:09:32.673]   ..$ ...:<environment: 0x5567e76a9a60> 
[16:09:32.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.673]  - attr(*, "resolved")= logi TRUE
[16:09:32.673]  - attr(*, "total_size")= num NA
[16:09:32.675]  - Getting '...' globals ... DONE
[16:09:32.675] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:09:32.676] List of 4
[16:09:32.676]  $ ...future.FUN:function (x)  
[16:09:32.676]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.676]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.676]  $ ...          : list()
[16:09:32.676]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.676]  - attr(*, "where")=List of 4
[16:09:32.676]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.676]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:09:32.676]   ..$ wool         :<environment: R_EmptyEnv> 
[16:09:32.676]   ..$ ...          :<environment: 0x5567e76a9a60> 
[16:09:32.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.676]  - attr(*, "resolved")= logi FALSE
[16:09:32.676]  - attr(*, "total_size")= num 2320
[16:09:32.680] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.681] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.681] Number of futures (= number of chunks): 1
[16:09:32.681] Launching 1 futures (chunks) ...
[16:09:32.681] Chunk #1 of 1 ...
[16:09:32.681]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.681] getGlobalsAndPackages() ...
[16:09:32.681] Searching for globals...
[16:09:32.682] 
[16:09:32.682] Searching for globals ... DONE
[16:09:32.682] - globals: [0] <none>
[16:09:32.682] getGlobalsAndPackages() ... DONE
[16:09:32.682]    + additional globals found: [n=0] 
[16:09:32.682]    + additional namespaces needed: [n=0] 
[16:09:32.682]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.682]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.683]  - seeds: <none>
[16:09:32.683] getGlobalsAndPackages() ...
[16:09:32.683] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.683] Resolving globals: FALSE
[16:09:32.683] Tweak future expression to call with '...' arguments ...
[16:09:32.683] {
[16:09:32.683]     do.call(function(...) {
[16:09:32.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.683]             on.exit(options(oopts), add = TRUE)
[16:09:32.683]         }
[16:09:32.683]         {
[16:09:32.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.683]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.683]             })
[16:09:32.683]         }
[16:09:32.683]     }, args = future.call.arguments)
[16:09:32.683] }
[16:09:32.683] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.684] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.684] 
[16:09:32.684] getGlobalsAndPackages() ... DONE
[16:09:32.684] run() for ‘Future’ ...
[16:09:32.684] - state: ‘created’
[16:09:32.684] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.688] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.688]   - Field: ‘label’
[16:09:32.688]   - Field: ‘local’
[16:09:32.688]   - Field: ‘owner’
[16:09:32.688]   - Field: ‘envir’
[16:09:32.688]   - Field: ‘packages’
[16:09:32.688]   - Field: ‘gc’
[16:09:32.688]   - Field: ‘conditions’
[16:09:32.689]   - Field: ‘expr’
[16:09:32.689]   - Field: ‘uuid’
[16:09:32.689]   - Field: ‘seed’
[16:09:32.689]   - Field: ‘version’
[16:09:32.689]   - Field: ‘result’
[16:09:32.689]   - Field: ‘asynchronous’
[16:09:32.689]   - Field: ‘calls’
[16:09:32.689]   - Field: ‘globals’
[16:09:32.689]   - Field: ‘stdout’
[16:09:32.689]   - Field: ‘earlySignal’
[16:09:32.689]   - Field: ‘lazy’
[16:09:32.690]   - Field: ‘state’
[16:09:32.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.690] - Launch lazy future ...
[16:09:32.690] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.690] Packages needed by future strategies (n = 0): <none>
[16:09:32.691] {
[16:09:32.691]     {
[16:09:32.691]         {
[16:09:32.691]             ...future.startTime <- base::Sys.time()
[16:09:32.691]             {
[16:09:32.691]                 {
[16:09:32.691]                   {
[16:09:32.691]                     {
[16:09:32.691]                       base::local({
[16:09:32.691]                         has_future <- base::requireNamespace("future", 
[16:09:32.691]                           quietly = TRUE)
[16:09:32.691]                         if (has_future) {
[16:09:32.691]                           ns <- base::getNamespace("future")
[16:09:32.691]                           version <- ns[[".package"]][["version"]]
[16:09:32.691]                           if (is.null(version)) 
[16:09:32.691]                             version <- utils::packageVersion("future")
[16:09:32.691]                         }
[16:09:32.691]                         else {
[16:09:32.691]                           version <- NULL
[16:09:32.691]                         }
[16:09:32.691]                         if (!has_future || version < "1.8.0") {
[16:09:32.691]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.691]                             "", base::R.version$version.string), 
[16:09:32.691]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.691]                               "release", "version")], collapse = " "), 
[16:09:32.691]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.691]                             info)
[16:09:32.691]                           info <- base::paste(info, collapse = "; ")
[16:09:32.691]                           if (!has_future) {
[16:09:32.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.691]                               info)
[16:09:32.691]                           }
[16:09:32.691]                           else {
[16:09:32.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.691]                               info, version)
[16:09:32.691]                           }
[16:09:32.691]                           base::stop(msg)
[16:09:32.691]                         }
[16:09:32.691]                       })
[16:09:32.691]                     }
[16:09:32.691]                     base::local({
[16:09:32.691]                       for (pkg in "stats") {
[16:09:32.691]                         base::loadNamespace(pkg)
[16:09:32.691]                         base::library(pkg, character.only = TRUE)
[16:09:32.691]                       }
[16:09:32.691]                     })
[16:09:32.691]                   }
[16:09:32.691]                   options(future.plan = NULL)
[16:09:32.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.691]                 }
[16:09:32.691]                 ...future.workdir <- getwd()
[16:09:32.691]             }
[16:09:32.691]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.691]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.691]         }
[16:09:32.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.691]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.691]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.691]             base::names(...future.oldOptions))
[16:09:32.691]     }
[16:09:32.691]     if (FALSE) {
[16:09:32.691]     }
[16:09:32.691]     else {
[16:09:32.691]         if (TRUE) {
[16:09:32.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.691]                 open = "w")
[16:09:32.691]         }
[16:09:32.691]         else {
[16:09:32.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.691]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.691]         }
[16:09:32.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.691]             base::sink(type = "output", split = FALSE)
[16:09:32.691]             base::close(...future.stdout)
[16:09:32.691]         }, add = TRUE)
[16:09:32.691]     }
[16:09:32.691]     ...future.frame <- base::sys.nframe()
[16:09:32.691]     ...future.conditions <- base::list()
[16:09:32.691]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.691]     if (FALSE) {
[16:09:32.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.691]     }
[16:09:32.691]     ...future.result <- base::tryCatch({
[16:09:32.691]         base::withCallingHandlers({
[16:09:32.691]             ...future.value <- base::withVisible(base::local({
[16:09:32.691]                 do.call(function(...) {
[16:09:32.691]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.691]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.691]                     ...future.globals.maxSize)) {
[16:09:32.691]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.691]                     on.exit(options(oopts), add = TRUE)
[16:09:32.691]                   }
[16:09:32.691]                   {
[16:09:32.691]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.691]                       FUN = function(jj) {
[16:09:32.691]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.691]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.691]                       })
[16:09:32.691]                   }
[16:09:32.691]                 }, args = future.call.arguments)
[16:09:32.691]             }))
[16:09:32.691]             future::FutureResult(value = ...future.value$value, 
[16:09:32.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.691]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.691]                     ...future.globalenv.names))
[16:09:32.691]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.691]         }, condition = base::local({
[16:09:32.691]             c <- base::c
[16:09:32.691]             inherits <- base::inherits
[16:09:32.691]             invokeRestart <- base::invokeRestart
[16:09:32.691]             length <- base::length
[16:09:32.691]             list <- base::list
[16:09:32.691]             seq.int <- base::seq.int
[16:09:32.691]             signalCondition <- base::signalCondition
[16:09:32.691]             sys.calls <- base::sys.calls
[16:09:32.691]             `[[` <- base::`[[`
[16:09:32.691]             `+` <- base::`+`
[16:09:32.691]             `<<-` <- base::`<<-`
[16:09:32.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.691]                   3L)]
[16:09:32.691]             }
[16:09:32.691]             function(cond) {
[16:09:32.691]                 is_error <- inherits(cond, "error")
[16:09:32.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.691]                   NULL)
[16:09:32.691]                 if (is_error) {
[16:09:32.691]                   sessionInformation <- function() {
[16:09:32.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.691]                       search = base::search(), system = base::Sys.info())
[16:09:32.691]                   }
[16:09:32.691]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.691]                     cond$call), session = sessionInformation(), 
[16:09:32.691]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.691]                   signalCondition(cond)
[16:09:32.691]                 }
[16:09:32.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.691]                 "immediateCondition"))) {
[16:09:32.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.691]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.691]                   if (TRUE && !signal) {
[16:09:32.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.691]                     {
[16:09:32.691]                       inherits <- base::inherits
[16:09:32.691]                       invokeRestart <- base::invokeRestart
[16:09:32.691]                       is.null <- base::is.null
[16:09:32.691]                       muffled <- FALSE
[16:09:32.691]                       if (inherits(cond, "message")) {
[16:09:32.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.691]                         if (muffled) 
[16:09:32.691]                           invokeRestart("muffleMessage")
[16:09:32.691]                       }
[16:09:32.691]                       else if (inherits(cond, "warning")) {
[16:09:32.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.691]                         if (muffled) 
[16:09:32.691]                           invokeRestart("muffleWarning")
[16:09:32.691]                       }
[16:09:32.691]                       else if (inherits(cond, "condition")) {
[16:09:32.691]                         if (!is.null(pattern)) {
[16:09:32.691]                           computeRestarts <- base::computeRestarts
[16:09:32.691]                           grepl <- base::grepl
[16:09:32.691]                           restarts <- computeRestarts(cond)
[16:09:32.691]                           for (restart in restarts) {
[16:09:32.691]                             name <- restart$name
[16:09:32.691]                             if (is.null(name)) 
[16:09:32.691]                               next
[16:09:32.691]                             if (!grepl(pattern, name)) 
[16:09:32.691]                               next
[16:09:32.691]                             invokeRestart(restart)
[16:09:32.691]                             muffled <- TRUE
[16:09:32.691]                             break
[16:09:32.691]                           }
[16:09:32.691]                         }
[16:09:32.691]                       }
[16:09:32.691]                       invisible(muffled)
[16:09:32.691]                     }
[16:09:32.691]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.691]                   }
[16:09:32.691]                 }
[16:09:32.691]                 else {
[16:09:32.691]                   if (TRUE) {
[16:09:32.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.691]                     {
[16:09:32.691]                       inherits <- base::inherits
[16:09:32.691]                       invokeRestart <- base::invokeRestart
[16:09:32.691]                       is.null <- base::is.null
[16:09:32.691]                       muffled <- FALSE
[16:09:32.691]                       if (inherits(cond, "message")) {
[16:09:32.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.691]                         if (muffled) 
[16:09:32.691]                           invokeRestart("muffleMessage")
[16:09:32.691]                       }
[16:09:32.691]                       else if (inherits(cond, "warning")) {
[16:09:32.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.691]                         if (muffled) 
[16:09:32.691]                           invokeRestart("muffleWarning")
[16:09:32.691]                       }
[16:09:32.691]                       else if (inherits(cond, "condition")) {
[16:09:32.691]                         if (!is.null(pattern)) {
[16:09:32.691]                           computeRestarts <- base::computeRestarts
[16:09:32.691]                           grepl <- base::grepl
[16:09:32.691]                           restarts <- computeRestarts(cond)
[16:09:32.691]                           for (restart in restarts) {
[16:09:32.691]                             name <- restart$name
[16:09:32.691]                             if (is.null(name)) 
[16:09:32.691]                               next
[16:09:32.691]                             if (!grepl(pattern, name)) 
[16:09:32.691]                               next
[16:09:32.691]                             invokeRestart(restart)
[16:09:32.691]                             muffled <- TRUE
[16:09:32.691]                             break
[16:09:32.691]                           }
[16:09:32.691]                         }
[16:09:32.691]                       }
[16:09:32.691]                       invisible(muffled)
[16:09:32.691]                     }
[16:09:32.691]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.691]                   }
[16:09:32.691]                 }
[16:09:32.691]             }
[16:09:32.691]         }))
[16:09:32.691]     }, error = function(ex) {
[16:09:32.691]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.691]                 ...future.rng), started = ...future.startTime, 
[16:09:32.691]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.691]             version = "1.8"), class = "FutureResult")
[16:09:32.691]     }, finally = {
[16:09:32.691]         if (!identical(...future.workdir, getwd())) 
[16:09:32.691]             setwd(...future.workdir)
[16:09:32.691]         {
[16:09:32.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.691]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.691]             }
[16:09:32.691]             base::options(...future.oldOptions)
[16:09:32.691]             if (.Platform$OS.type == "windows") {
[16:09:32.691]                 old_names <- names(...future.oldEnvVars)
[16:09:32.691]                 envs <- base::Sys.getenv()
[16:09:32.691]                 names <- names(envs)
[16:09:32.691]                 common <- intersect(names, old_names)
[16:09:32.691]                 added <- setdiff(names, old_names)
[16:09:32.691]                 removed <- setdiff(old_names, names)
[16:09:32.691]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.691]                   envs[common]]
[16:09:32.691]                 NAMES <- toupper(changed)
[16:09:32.691]                 args <- list()
[16:09:32.691]                 for (kk in seq_along(NAMES)) {
[16:09:32.691]                   name <- changed[[kk]]
[16:09:32.691]                   NAME <- NAMES[[kk]]
[16:09:32.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.691]                     next
[16:09:32.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.691]                 }
[16:09:32.691]                 NAMES <- toupper(added)
[16:09:32.691]                 for (kk in seq_along(NAMES)) {
[16:09:32.691]                   name <- added[[kk]]
[16:09:32.691]                   NAME <- NAMES[[kk]]
[16:09:32.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.691]                     next
[16:09:32.691]                   args[[name]] <- ""
[16:09:32.691]                 }
[16:09:32.691]                 NAMES <- toupper(removed)
[16:09:32.691]                 for (kk in seq_along(NAMES)) {
[16:09:32.691]                   name <- removed[[kk]]
[16:09:32.691]                   NAME <- NAMES[[kk]]
[16:09:32.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.691]                     next
[16:09:32.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.691]                 }
[16:09:32.691]                 if (length(args) > 0) 
[16:09:32.691]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.691]             }
[16:09:32.691]             else {
[16:09:32.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.691]             }
[16:09:32.691]             {
[16:09:32.691]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.691]                   0L) {
[16:09:32.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.691]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.691]                   base::options(opts)
[16:09:32.691]                 }
[16:09:32.691]                 {
[16:09:32.691]                   {
[16:09:32.691]                     NULL
[16:09:32.691]                     RNGkind("Mersenne-Twister")
[16:09:32.691]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.691]                       inherits = FALSE)
[16:09:32.691]                   }
[16:09:32.691]                   options(future.plan = NULL)
[16:09:32.691]                   if (is.na(NA_character_)) 
[16:09:32.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.691]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.691]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.691]                     envir = parent.frame()) 
[16:09:32.691]                   {
[16:09:32.691]                     if (is.function(workers)) 
[16:09:32.691]                       workers <- workers()
[16:09:32.691]                     workers <- structure(as.integer(workers), 
[16:09:32.691]                       class = class(workers))
[16:09:32.691]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.691]                       workers >= 1)
[16:09:32.691]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.691]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.691]                     }
[16:09:32.691]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.691]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.691]                       envir = envir)
[16:09:32.691]                     if (!future$lazy) 
[16:09:32.691]                       future <- run(future)
[16:09:32.691]                     invisible(future)
[16:09:32.691]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.691]                 }
[16:09:32.691]             }
[16:09:32.691]         }
[16:09:32.691]     })
[16:09:32.691]     if (TRUE) {
[16:09:32.691]         base::sink(type = "output", split = FALSE)
[16:09:32.691]         if (TRUE) {
[16:09:32.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.691]         }
[16:09:32.691]         else {
[16:09:32.691]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.691]         }
[16:09:32.691]         base::close(...future.stdout)
[16:09:32.691]         ...future.stdout <- NULL
[16:09:32.691]     }
[16:09:32.691]     ...future.result$conditions <- ...future.conditions
[16:09:32.691]     ...future.result$finished <- base::Sys.time()
[16:09:32.691]     ...future.result
[16:09:32.691] }
[16:09:32.692] assign_globals() ...
[16:09:32.692] List of 7
[16:09:32.692]  $ ...future.FUN            :function (x)  
[16:09:32.692]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.692]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.692]  $ future.call.arguments    : list()
[16:09:32.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.692]  $ ...future.elements_ii    :List of 3
[16:09:32.692]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.692]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.692]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.692]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.692]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.692]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.692]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.692]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.692]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.692]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.692]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.692]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.692]  $ ...future.seeds_ii       : NULL
[16:09:32.692]  $ ...future.globals.maxSize: NULL
[16:09:32.692]  - attr(*, "resolved")= logi FALSE
[16:09:32.692]  - attr(*, "total_size")= num 2320
[16:09:32.692]  - attr(*, "where")=List of 7
[16:09:32.692]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.692]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:09:32.692]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:09:32.692]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.692]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.692]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.692]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.692]  - attr(*, "already-done")= logi TRUE
[16:09:32.703] - reassign environment for ‘...future.FUN’
[16:09:32.703] - copied ‘...future.FUN’ to environment
[16:09:32.704] - copied ‘breaks’ to environment
[16:09:32.704] - copied ‘wool’ to environment
[16:09:32.704] - copied ‘future.call.arguments’ to environment
[16:09:32.704] - copied ‘...future.elements_ii’ to environment
[16:09:32.704] - copied ‘...future.seeds_ii’ to environment
[16:09:32.704] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.704] assign_globals() ... done
[16:09:32.705] plan(): Setting new future strategy stack:
[16:09:32.705] List of future strategies:
[16:09:32.705] 1. sequential:
[16:09:32.705]    - args: function (..., envir = parent.frame())
[16:09:32.705]    - tweaked: FALSE
[16:09:32.705]    - call: NULL
[16:09:32.705] plan(): nbrOfWorkers() = 1
[16:09:32.708] plan(): Setting new future strategy stack:
[16:09:32.708] List of future strategies:
[16:09:32.708] 1. multisession:
[16:09:32.708]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.708]    - tweaked: FALSE
[16:09:32.708]    - call: plan(strategy)
[16:09:32.711] plan(): nbrOfWorkers() = 1
[16:09:32.711] SequentialFuture started (and completed)
[16:09:32.711] - Launch lazy future ... done
[16:09:32.712] run() for ‘SequentialFuture’ ... done
[16:09:32.712] Created future:
[16:09:32.712] SequentialFuture:
[16:09:32.712] Label: ‘future_by-1’
[16:09:32.712] Expression:
[16:09:32.712] {
[16:09:32.712]     do.call(function(...) {
[16:09:32.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.712]             on.exit(options(oopts), add = TRUE)
[16:09:32.712]         }
[16:09:32.712]         {
[16:09:32.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.712]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.712]             })
[16:09:32.712]         }
[16:09:32.712]     }, args = future.call.arguments)
[16:09:32.712] }
[16:09:32.712] Lazy evaluation: FALSE
[16:09:32.712] Asynchronous evaluation: FALSE
[16:09:32.712] Local evaluation: TRUE
[16:09:32.712] Environment: 0x5567e77860a0
[16:09:32.712] Capture standard output: TRUE
[16:09:32.712] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.712] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:09:32.712] Packages: 1 packages (‘stats’)
[16:09:32.712] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.712] Resolved: TRUE
[16:09:32.712] Value: 25.57 KiB of class ‘list’
[16:09:32.712] Early signaling: FALSE
[16:09:32.712] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.712] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.713] Chunk #1 of 1 ... DONE
[16:09:32.713] Launching 1 futures (chunks) ... DONE
[16:09:32.714] Resolving 1 futures (chunks) ...
[16:09:32.714] resolve() on list ...
[16:09:32.714]  recursive: 0
[16:09:32.714]  length: 1
[16:09:32.714] 
[16:09:32.714] resolved() for ‘SequentialFuture’ ...
[16:09:32.714] - state: ‘finished’
[16:09:32.714] - run: TRUE
[16:09:32.714] - result: ‘FutureResult’
[16:09:32.714] resolved() for ‘SequentialFuture’ ... done
[16:09:32.714] Future #1
[16:09:32.715] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.715] - nx: 1
[16:09:32.715] - relay: TRUE
[16:09:32.715] - stdout: TRUE
[16:09:32.715] - signal: TRUE
[16:09:32.715] - resignal: FALSE
[16:09:32.715] - force: TRUE
[16:09:32.715] - relayed: [n=1] FALSE
[16:09:32.715] - queued futures: [n=1] FALSE
[16:09:32.715]  - until=1
[16:09:32.715]  - relaying element #1
[16:09:32.716] - relayed: [n=1] TRUE
[16:09:32.716] - queued futures: [n=1] TRUE
[16:09:32.716] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.716]  length: 0 (resolved future 1)
[16:09:32.716] Relaying remaining futures
[16:09:32.716] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.716] - nx: 1
[16:09:32.716] - relay: TRUE
[16:09:32.716] - stdout: TRUE
[16:09:32.716] - signal: TRUE
[16:09:32.717] - resignal: FALSE
[16:09:32.717] - force: TRUE
[16:09:32.717] - relayed: [n=1] TRUE
[16:09:32.717] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.717] - relayed: [n=1] TRUE
[16:09:32.717] - queued futures: [n=1] TRUE
[16:09:32.717] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.717] resolve() on list ... DONE
[16:09:32.717]  - Number of value chunks collected: 1
[16:09:32.717] Resolving 1 futures (chunks) ... DONE
[16:09:32.718] Reducing values from 1 chunks ...
[16:09:32.718]  - Number of values collected after concatenation: 3
[16:09:32.718]  - Number of values expected: 3
[16:09:32.718] Reducing values from 1 chunks ... DONE
[16:09:32.718] future_lapply() ... DONE
[16:09:32.718] future_by_internal() ... DONE
[16:09:32.718] future_by_internal() ...
[16:09:32.719] future_lapply() ...
[16:09:32.722] Number of chunks: 1
[16:09:32.722] getGlobalsAndPackagesXApply() ...
[16:09:32.722]  - future.globals: TRUE
[16:09:32.722] getGlobalsAndPackages() ...
[16:09:32.722] Searching for globals...
[16:09:32.725] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.725] Searching for globals ... DONE
[16:09:32.725] Resolving globals: FALSE
[16:09:32.725] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.725] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.726] - globals: [1] ‘FUN’
[16:09:32.726] 
[16:09:32.726] getGlobalsAndPackages() ... DONE
[16:09:32.726]  - globals found/used: [n=1] ‘FUN’
[16:09:32.726]  - needed namespaces: [n=0] 
[16:09:32.726] Finding globals ... DONE
[16:09:32.726]  - use_args: TRUE
[16:09:32.726]  - Getting '...' globals ...
[16:09:32.727] resolve() on list ...
[16:09:32.727]  recursive: 0
[16:09:32.727]  length: 1
[16:09:32.727]  elements: ‘...’
[16:09:32.727]  length: 0 (resolved future 1)
[16:09:32.727] resolve() on list ... DONE
[16:09:32.727]    - '...' content: [n=0] 
[16:09:32.727] List of 1
[16:09:32.727]  $ ...: list()
[16:09:32.727]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.727]  - attr(*, "where")=List of 1
[16:09:32.727]   ..$ ...:<environment: 0x5567e91f4280> 
[16:09:32.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.727]  - attr(*, "resolved")= logi TRUE
[16:09:32.727]  - attr(*, "total_size")= num NA
[16:09:32.730]  - Getting '...' globals ... DONE
[16:09:32.730] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.730] List of 2
[16:09:32.730]  $ ...future.FUN:function (object, ...)  
[16:09:32.730]  $ ...          : list()
[16:09:32.730]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.730]  - attr(*, "where")=List of 2
[16:09:32.730]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.730]   ..$ ...          :<environment: 0x5567e91f4280> 
[16:09:32.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.730]  - attr(*, "resolved")= logi FALSE
[16:09:32.730]  - attr(*, "total_size")= num 1240
[16:09:32.733] Packages to be attached in all futures: [n=0] 
[16:09:32.733] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.733] Number of futures (= number of chunks): 1
[16:09:32.733] Launching 1 futures (chunks) ...
[16:09:32.733] Chunk #1 of 1 ...
[16:09:32.733]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.733] getGlobalsAndPackages() ...
[16:09:32.733] Searching for globals...
[16:09:32.734] 
[16:09:32.734] Searching for globals ... DONE
[16:09:32.734] - globals: [0] <none>
[16:09:32.734] getGlobalsAndPackages() ... DONE
[16:09:32.734]    + additional globals found: [n=0] 
[16:09:32.734]    + additional namespaces needed: [n=0] 
[16:09:32.734]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.734]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.734]  - seeds: <none>
[16:09:32.735] getGlobalsAndPackages() ...
[16:09:32.735] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.735] Resolving globals: FALSE
[16:09:32.735] Tweak future expression to call with '...' arguments ...
[16:09:32.735] {
[16:09:32.735]     do.call(function(...) {
[16:09:32.735]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.735]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.735]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.735]             on.exit(options(oopts), add = TRUE)
[16:09:32.735]         }
[16:09:32.735]         {
[16:09:32.735]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.735]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.735]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.735]             })
[16:09:32.735]         }
[16:09:32.735]     }, args = future.call.arguments)
[16:09:32.735] }
[16:09:32.735] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.736] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.736] 
[16:09:32.736] getGlobalsAndPackages() ... DONE
[16:09:32.736] run() for ‘Future’ ...
[16:09:32.736] - state: ‘created’
[16:09:32.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.739] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.740]   - Field: ‘label’
[16:09:32.740]   - Field: ‘local’
[16:09:32.740]   - Field: ‘owner’
[16:09:32.740]   - Field: ‘envir’
[16:09:32.740]   - Field: ‘packages’
[16:09:32.740]   - Field: ‘gc’
[16:09:32.740]   - Field: ‘conditions’
[16:09:32.740]   - Field: ‘expr’
[16:09:32.740]   - Field: ‘uuid’
[16:09:32.741]   - Field: ‘seed’
[16:09:32.741]   - Field: ‘version’
[16:09:32.741]   - Field: ‘result’
[16:09:32.741]   - Field: ‘asynchronous’
[16:09:32.741]   - Field: ‘calls’
[16:09:32.741]   - Field: ‘globals’
[16:09:32.741]   - Field: ‘stdout’
[16:09:32.741]   - Field: ‘earlySignal’
[16:09:32.741]   - Field: ‘lazy’
[16:09:32.741]   - Field: ‘state’
[16:09:32.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.742] - Launch lazy future ...
[16:09:32.742] Packages needed by the future expression (n = 0): <none>
[16:09:32.742] Packages needed by future strategies (n = 0): <none>
[16:09:32.742] {
[16:09:32.742]     {
[16:09:32.742]         {
[16:09:32.742]             ...future.startTime <- base::Sys.time()
[16:09:32.742]             {
[16:09:32.742]                 {
[16:09:32.742]                   {
[16:09:32.742]                     base::local({
[16:09:32.742]                       has_future <- base::requireNamespace("future", 
[16:09:32.742]                         quietly = TRUE)
[16:09:32.742]                       if (has_future) {
[16:09:32.742]                         ns <- base::getNamespace("future")
[16:09:32.742]                         version <- ns[[".package"]][["version"]]
[16:09:32.742]                         if (is.null(version)) 
[16:09:32.742]                           version <- utils::packageVersion("future")
[16:09:32.742]                       }
[16:09:32.742]                       else {
[16:09:32.742]                         version <- NULL
[16:09:32.742]                       }
[16:09:32.742]                       if (!has_future || version < "1.8.0") {
[16:09:32.742]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.742]                           "", base::R.version$version.string), 
[16:09:32.742]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.742]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.742]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.742]                             "release", "version")], collapse = " "), 
[16:09:32.742]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.742]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.742]                           info)
[16:09:32.742]                         info <- base::paste(info, collapse = "; ")
[16:09:32.742]                         if (!has_future) {
[16:09:32.742]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.742]                             info)
[16:09:32.742]                         }
[16:09:32.742]                         else {
[16:09:32.742]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.742]                             info, version)
[16:09:32.742]                         }
[16:09:32.742]                         base::stop(msg)
[16:09:32.742]                       }
[16:09:32.742]                     })
[16:09:32.742]                   }
[16:09:32.742]                   options(future.plan = NULL)
[16:09:32.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.742]                 }
[16:09:32.742]                 ...future.workdir <- getwd()
[16:09:32.742]             }
[16:09:32.742]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.742]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.742]         }
[16:09:32.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.742]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.742]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.742]             base::names(...future.oldOptions))
[16:09:32.742]     }
[16:09:32.742]     if (FALSE) {
[16:09:32.742]     }
[16:09:32.742]     else {
[16:09:32.742]         if (TRUE) {
[16:09:32.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.742]                 open = "w")
[16:09:32.742]         }
[16:09:32.742]         else {
[16:09:32.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.742]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.742]         }
[16:09:32.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.742]             base::sink(type = "output", split = FALSE)
[16:09:32.742]             base::close(...future.stdout)
[16:09:32.742]         }, add = TRUE)
[16:09:32.742]     }
[16:09:32.742]     ...future.frame <- base::sys.nframe()
[16:09:32.742]     ...future.conditions <- base::list()
[16:09:32.742]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.742]     if (FALSE) {
[16:09:32.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.742]     }
[16:09:32.742]     ...future.result <- base::tryCatch({
[16:09:32.742]         base::withCallingHandlers({
[16:09:32.742]             ...future.value <- base::withVisible(base::local({
[16:09:32.742]                 do.call(function(...) {
[16:09:32.742]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.742]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.742]                     ...future.globals.maxSize)) {
[16:09:32.742]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.742]                     on.exit(options(oopts), add = TRUE)
[16:09:32.742]                   }
[16:09:32.742]                   {
[16:09:32.742]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.742]                       FUN = function(jj) {
[16:09:32.742]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.742]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.742]                       })
[16:09:32.742]                   }
[16:09:32.742]                 }, args = future.call.arguments)
[16:09:32.742]             }))
[16:09:32.742]             future::FutureResult(value = ...future.value$value, 
[16:09:32.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.742]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.742]                     ...future.globalenv.names))
[16:09:32.742]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.742]         }, condition = base::local({
[16:09:32.742]             c <- base::c
[16:09:32.742]             inherits <- base::inherits
[16:09:32.742]             invokeRestart <- base::invokeRestart
[16:09:32.742]             length <- base::length
[16:09:32.742]             list <- base::list
[16:09:32.742]             seq.int <- base::seq.int
[16:09:32.742]             signalCondition <- base::signalCondition
[16:09:32.742]             sys.calls <- base::sys.calls
[16:09:32.742]             `[[` <- base::`[[`
[16:09:32.742]             `+` <- base::`+`
[16:09:32.742]             `<<-` <- base::`<<-`
[16:09:32.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.742]                   3L)]
[16:09:32.742]             }
[16:09:32.742]             function(cond) {
[16:09:32.742]                 is_error <- inherits(cond, "error")
[16:09:32.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.742]                   NULL)
[16:09:32.742]                 if (is_error) {
[16:09:32.742]                   sessionInformation <- function() {
[16:09:32.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.742]                       search = base::search(), system = base::Sys.info())
[16:09:32.742]                   }
[16:09:32.742]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.742]                     cond$call), session = sessionInformation(), 
[16:09:32.742]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.742]                   signalCondition(cond)
[16:09:32.742]                 }
[16:09:32.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.742]                 "immediateCondition"))) {
[16:09:32.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.742]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.742]                   if (TRUE && !signal) {
[16:09:32.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.742]                     {
[16:09:32.742]                       inherits <- base::inherits
[16:09:32.742]                       invokeRestart <- base::invokeRestart
[16:09:32.742]                       is.null <- base::is.null
[16:09:32.742]                       muffled <- FALSE
[16:09:32.742]                       if (inherits(cond, "message")) {
[16:09:32.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.742]                         if (muffled) 
[16:09:32.742]                           invokeRestart("muffleMessage")
[16:09:32.742]                       }
[16:09:32.742]                       else if (inherits(cond, "warning")) {
[16:09:32.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.742]                         if (muffled) 
[16:09:32.742]                           invokeRestart("muffleWarning")
[16:09:32.742]                       }
[16:09:32.742]                       else if (inherits(cond, "condition")) {
[16:09:32.742]                         if (!is.null(pattern)) {
[16:09:32.742]                           computeRestarts <- base::computeRestarts
[16:09:32.742]                           grepl <- base::grepl
[16:09:32.742]                           restarts <- computeRestarts(cond)
[16:09:32.742]                           for (restart in restarts) {
[16:09:32.742]                             name <- restart$name
[16:09:32.742]                             if (is.null(name)) 
[16:09:32.742]                               next
[16:09:32.742]                             if (!grepl(pattern, name)) 
[16:09:32.742]                               next
[16:09:32.742]                             invokeRestart(restart)
[16:09:32.742]                             muffled <- TRUE
[16:09:32.742]                             break
[16:09:32.742]                           }
[16:09:32.742]                         }
[16:09:32.742]                       }
[16:09:32.742]                       invisible(muffled)
[16:09:32.742]                     }
[16:09:32.742]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.742]                   }
[16:09:32.742]                 }
[16:09:32.742]                 else {
[16:09:32.742]                   if (TRUE) {
[16:09:32.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.742]                     {
[16:09:32.742]                       inherits <- base::inherits
[16:09:32.742]                       invokeRestart <- base::invokeRestart
[16:09:32.742]                       is.null <- base::is.null
[16:09:32.742]                       muffled <- FALSE
[16:09:32.742]                       if (inherits(cond, "message")) {
[16:09:32.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.742]                         if (muffled) 
[16:09:32.742]                           invokeRestart("muffleMessage")
[16:09:32.742]                       }
[16:09:32.742]                       else if (inherits(cond, "warning")) {
[16:09:32.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.742]                         if (muffled) 
[16:09:32.742]                           invokeRestart("muffleWarning")
[16:09:32.742]                       }
[16:09:32.742]                       else if (inherits(cond, "condition")) {
[16:09:32.742]                         if (!is.null(pattern)) {
[16:09:32.742]                           computeRestarts <- base::computeRestarts
[16:09:32.742]                           grepl <- base::grepl
[16:09:32.742]                           restarts <- computeRestarts(cond)
[16:09:32.742]                           for (restart in restarts) {
[16:09:32.742]                             name <- restart$name
[16:09:32.742]                             if (is.null(name)) 
[16:09:32.742]                               next
[16:09:32.742]                             if (!grepl(pattern, name)) 
[16:09:32.742]                               next
[16:09:32.742]                             invokeRestart(restart)
[16:09:32.742]                             muffled <- TRUE
[16:09:32.742]                             break
[16:09:32.742]                           }
[16:09:32.742]                         }
[16:09:32.742]                       }
[16:09:32.742]                       invisible(muffled)
[16:09:32.742]                     }
[16:09:32.742]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.742]                   }
[16:09:32.742]                 }
[16:09:32.742]             }
[16:09:32.742]         }))
[16:09:32.742]     }, error = function(ex) {
[16:09:32.742]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.742]                 ...future.rng), started = ...future.startTime, 
[16:09:32.742]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.742]             version = "1.8"), class = "FutureResult")
[16:09:32.742]     }, finally = {
[16:09:32.742]         if (!identical(...future.workdir, getwd())) 
[16:09:32.742]             setwd(...future.workdir)
[16:09:32.742]         {
[16:09:32.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.742]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.742]             }
[16:09:32.742]             base::options(...future.oldOptions)
[16:09:32.742]             if (.Platform$OS.type == "windows") {
[16:09:32.742]                 old_names <- names(...future.oldEnvVars)
[16:09:32.742]                 envs <- base::Sys.getenv()
[16:09:32.742]                 names <- names(envs)
[16:09:32.742]                 common <- intersect(names, old_names)
[16:09:32.742]                 added <- setdiff(names, old_names)
[16:09:32.742]                 removed <- setdiff(old_names, names)
[16:09:32.742]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.742]                   envs[common]]
[16:09:32.742]                 NAMES <- toupper(changed)
[16:09:32.742]                 args <- list()
[16:09:32.742]                 for (kk in seq_along(NAMES)) {
[16:09:32.742]                   name <- changed[[kk]]
[16:09:32.742]                   NAME <- NAMES[[kk]]
[16:09:32.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.742]                     next
[16:09:32.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.742]                 }
[16:09:32.742]                 NAMES <- toupper(added)
[16:09:32.742]                 for (kk in seq_along(NAMES)) {
[16:09:32.742]                   name <- added[[kk]]
[16:09:32.742]                   NAME <- NAMES[[kk]]
[16:09:32.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.742]                     next
[16:09:32.742]                   args[[name]] <- ""
[16:09:32.742]                 }
[16:09:32.742]                 NAMES <- toupper(removed)
[16:09:32.742]                 for (kk in seq_along(NAMES)) {
[16:09:32.742]                   name <- removed[[kk]]
[16:09:32.742]                   NAME <- NAMES[[kk]]
[16:09:32.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.742]                     next
[16:09:32.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.742]                 }
[16:09:32.742]                 if (length(args) > 0) 
[16:09:32.742]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.742]             }
[16:09:32.742]             else {
[16:09:32.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.742]             }
[16:09:32.742]             {
[16:09:32.742]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.742]                   0L) {
[16:09:32.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.742]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.742]                   base::options(opts)
[16:09:32.742]                 }
[16:09:32.742]                 {
[16:09:32.742]                   {
[16:09:32.742]                     NULL
[16:09:32.742]                     RNGkind("Mersenne-Twister")
[16:09:32.742]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.742]                       inherits = FALSE)
[16:09:32.742]                   }
[16:09:32.742]                   options(future.plan = NULL)
[16:09:32.742]                   if (is.na(NA_character_)) 
[16:09:32.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.742]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.742]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.742]                     envir = parent.frame()) 
[16:09:32.742]                   {
[16:09:32.742]                     if (is.function(workers)) 
[16:09:32.742]                       workers <- workers()
[16:09:32.742]                     workers <- structure(as.integer(workers), 
[16:09:32.742]                       class = class(workers))
[16:09:32.742]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.742]                       workers >= 1)
[16:09:32.742]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.742]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.742]                     }
[16:09:32.742]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.742]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.742]                       envir = envir)
[16:09:32.742]                     if (!future$lazy) 
[16:09:32.742]                       future <- run(future)
[16:09:32.742]                     invisible(future)
[16:09:32.742]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.742]                 }
[16:09:32.742]             }
[16:09:32.742]         }
[16:09:32.742]     })
[16:09:32.742]     if (TRUE) {
[16:09:32.742]         base::sink(type = "output", split = FALSE)
[16:09:32.742]         if (TRUE) {
[16:09:32.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.742]         }
[16:09:32.742]         else {
[16:09:32.742]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.742]         }
[16:09:32.742]         base::close(...future.stdout)
[16:09:32.742]         ...future.stdout <- NULL
[16:09:32.742]     }
[16:09:32.742]     ...future.result$conditions <- ...future.conditions
[16:09:32.742]     ...future.result$finished <- base::Sys.time()
[16:09:32.742]     ...future.result
[16:09:32.742] }
[16:09:32.744] assign_globals() ...
[16:09:32.744] List of 5
[16:09:32.744]  $ ...future.FUN            :function (object, ...)  
[16:09:32.744]  $ future.call.arguments    : list()
[16:09:32.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.744]  $ ...future.elements_ii    :List of 3
[16:09:32.744]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.744]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.744]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.744]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.744]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.744]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.744]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.744]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.744]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.744]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.744]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.744]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.744]  $ ...future.seeds_ii       : NULL
[16:09:32.744]  $ ...future.globals.maxSize: NULL
[16:09:32.744]  - attr(*, "resolved")= logi FALSE
[16:09:32.744]  - attr(*, "total_size")= num 1240
[16:09:32.744]  - attr(*, "where")=List of 5
[16:09:32.744]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.744]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.744]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.744]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.744]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.744]  - attr(*, "already-done")= logi TRUE
[16:09:32.754] - copied ‘...future.FUN’ to environment
[16:09:32.754] - copied ‘future.call.arguments’ to environment
[16:09:32.754] - copied ‘...future.elements_ii’ to environment
[16:09:32.754] - copied ‘...future.seeds_ii’ to environment
[16:09:32.754] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.754] assign_globals() ... done
[16:09:32.754] plan(): Setting new future strategy stack:
[16:09:32.754] List of future strategies:
[16:09:32.754] 1. sequential:
[16:09:32.754]    - args: function (..., envir = parent.frame())
[16:09:32.754]    - tweaked: FALSE
[16:09:32.754]    - call: NULL
[16:09:32.755] plan(): nbrOfWorkers() = 1
[16:09:32.757] plan(): Setting new future strategy stack:
[16:09:32.757] List of future strategies:
[16:09:32.757] 1. multisession:
[16:09:32.757]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.757]    - tweaked: FALSE
[16:09:32.757]    - call: plan(strategy)
[16:09:32.760] plan(): nbrOfWorkers() = 1
[16:09:32.761] SequentialFuture started (and completed)
[16:09:32.761] - Launch lazy future ... done
[16:09:32.761] run() for ‘SequentialFuture’ ... done
[16:09:32.761] Created future:
[16:09:32.761] SequentialFuture:
[16:09:32.761] Label: ‘future_by-1’
[16:09:32.761] Expression:
[16:09:32.761] {
[16:09:32.761]     do.call(function(...) {
[16:09:32.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.761]             on.exit(options(oopts), add = TRUE)
[16:09:32.761]         }
[16:09:32.761]         {
[16:09:32.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.761]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.761]             })
[16:09:32.761]         }
[16:09:32.761]     }, args = future.call.arguments)
[16:09:32.761] }
[16:09:32.761] Lazy evaluation: FALSE
[16:09:32.761] Asynchronous evaluation: FALSE
[16:09:32.761] Local evaluation: TRUE
[16:09:32.761] Environment: 0x5567e9181308
[16:09:32.761] Capture standard output: TRUE
[16:09:32.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.761] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.761] Packages: <none>
[16:09:32.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.761] Resolved: TRUE
[16:09:32.761] Value: 5.37 KiB of class ‘list’
[16:09:32.761] Early signaling: FALSE
[16:09:32.761] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.761] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.762] Chunk #1 of 1 ... DONE
[16:09:32.762] Launching 1 futures (chunks) ... DONE
[16:09:32.762] Resolving 1 futures (chunks) ...
[16:09:32.762] resolve() on list ...
[16:09:32.763]  recursive: 0
[16:09:32.763]  length: 1
[16:09:32.763] 
[16:09:32.763] resolved() for ‘SequentialFuture’ ...
[16:09:32.763] - state: ‘finished’
[16:09:32.763] - run: TRUE
[16:09:32.763] - result: ‘FutureResult’
[16:09:32.763] resolved() for ‘SequentialFuture’ ... done
[16:09:32.763] Future #1
[16:09:32.763] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.763] - nx: 1
[16:09:32.764] - relay: TRUE
[16:09:32.764] - stdout: TRUE
[16:09:32.764] - signal: TRUE
[16:09:32.764] - resignal: FALSE
[16:09:32.764] - force: TRUE
[16:09:32.764] - relayed: [n=1] FALSE
[16:09:32.764] - queued futures: [n=1] FALSE
[16:09:32.764]  - until=1
[16:09:32.764]  - relaying element #1
[16:09:32.764] - relayed: [n=1] TRUE
[16:09:32.765] - queued futures: [n=1] TRUE
[16:09:32.765] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.765]  length: 0 (resolved future 1)
[16:09:32.765] Relaying remaining futures
[16:09:32.765] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.767] - nx: 1
[16:09:32.767] - relay: TRUE
[16:09:32.767] - stdout: TRUE
[16:09:32.767] - signal: TRUE
[16:09:32.767] - resignal: FALSE
[16:09:32.767] - force: TRUE
[16:09:32.768] - relayed: [n=1] TRUE
[16:09:32.768] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.768] - relayed: [n=1] TRUE
[16:09:32.768] - queued futures: [n=1] TRUE
[16:09:32.768] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.768] resolve() on list ... DONE
[16:09:32.768]  - Number of value chunks collected: 1
[16:09:32.768] Resolving 1 futures (chunks) ... DONE
[16:09:32.768] Reducing values from 1 chunks ...
[16:09:32.769]  - Number of values collected after concatenation: 3
[16:09:32.769]  - Number of values expected: 3
[16:09:32.769] Reducing values from 1 chunks ... DONE
[16:09:32.769] future_lapply() ... DONE
[16:09:32.769] future_by_internal() ... DONE
[16:09:32.770] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:09:32.770] future_lapply() ...
[16:09:32.774] Number of chunks: 1
[16:09:32.774] getGlobalsAndPackagesXApply() ...
[16:09:32.774]  - future.globals: TRUE
[16:09:32.774] getGlobalsAndPackages() ...
[16:09:32.774] Searching for globals...
[16:09:32.775] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.775] Searching for globals ... DONE
[16:09:32.775] Resolving globals: FALSE
[16:09:32.776] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.776] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.776] - globals: [1] ‘FUN’
[16:09:32.776] 
[16:09:32.776] getGlobalsAndPackages() ... DONE
[16:09:32.776]  - globals found/used: [n=1] ‘FUN’
[16:09:32.776]  - needed namespaces: [n=0] 
[16:09:32.777] Finding globals ... DONE
[16:09:32.777]  - use_args: TRUE
[16:09:32.777]  - Getting '...' globals ...
[16:09:32.777] resolve() on list ...
[16:09:32.777]  recursive: 0
[16:09:32.777]  length: 1
[16:09:32.777]  elements: ‘...’
[16:09:32.777]  length: 0 (resolved future 1)
[16:09:32.777] resolve() on list ... DONE
[16:09:32.778]    - '...' content: [n=0] 
[16:09:32.778] List of 1
[16:09:32.778]  $ ...: list()
[16:09:32.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.778]  - attr(*, "where")=List of 1
[16:09:32.778]   ..$ ...:<environment: 0x5567e8da48a0> 
[16:09:32.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.778]  - attr(*, "resolved")= logi TRUE
[16:09:32.778]  - attr(*, "total_size")= num NA
[16:09:32.780]  - Getting '...' globals ... DONE
[16:09:32.780] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.780] List of 2
[16:09:32.780]  $ ...future.FUN:function (object, ...)  
[16:09:32.780]  $ ...          : list()
[16:09:32.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.780]  - attr(*, "where")=List of 2
[16:09:32.780]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.780]   ..$ ...          :<environment: 0x5567e8da48a0> 
[16:09:32.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.780]  - attr(*, "resolved")= logi FALSE
[16:09:32.780]  - attr(*, "total_size")= num 1240
[16:09:32.783] Packages to be attached in all futures: [n=0] 
[16:09:32.783] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.783] Number of futures (= number of chunks): 1
[16:09:32.783] Launching 1 futures (chunks) ...
[16:09:32.783] Chunk #1 of 1 ...
[16:09:32.783]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.783] getGlobalsAndPackages() ...
[16:09:32.783] Searching for globals...
[16:09:32.784] 
[16:09:32.784] Searching for globals ... DONE
[16:09:32.784] - globals: [0] <none>
[16:09:32.784] getGlobalsAndPackages() ... DONE
[16:09:32.784]    + additional globals found: [n=0] 
[16:09:32.784]    + additional namespaces needed: [n=0] 
[16:09:32.784]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.785]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.785]  - seeds: <none>
[16:09:32.785] getGlobalsAndPackages() ...
[16:09:32.785] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.785] Resolving globals: FALSE
[16:09:32.785] Tweak future expression to call with '...' arguments ...
[16:09:32.785] {
[16:09:32.785]     do.call(function(...) {
[16:09:32.785]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.785]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.785]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.785]             on.exit(options(oopts), add = TRUE)
[16:09:32.785]         }
[16:09:32.785]         {
[16:09:32.785]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.785]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.785]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.785]             })
[16:09:32.785]         }
[16:09:32.785]     }, args = future.call.arguments)
[16:09:32.785] }
[16:09:32.785] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.786] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.786] 
[16:09:32.786] getGlobalsAndPackages() ... DONE
[16:09:32.786] run() for ‘Future’ ...
[16:09:32.786] - state: ‘created’
[16:09:32.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:32.790] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.790]   - Field: ‘label’
[16:09:32.790]   - Field: ‘local’
[16:09:32.791]   - Field: ‘owner’
[16:09:32.791]   - Field: ‘envir’
[16:09:32.791]   - Field: ‘packages’
[16:09:32.791]   - Field: ‘gc’
[16:09:32.792]   - Field: ‘conditions’
[16:09:32.792]   - Field: ‘expr’
[16:09:32.792]   - Field: ‘uuid’
[16:09:32.792]   - Field: ‘seed’
[16:09:32.792]   - Field: ‘version’
[16:09:32.792]   - Field: ‘result’
[16:09:32.792]   - Field: ‘asynchronous’
[16:09:32.792]   - Field: ‘calls’
[16:09:32.792]   - Field: ‘globals’
[16:09:32.792]   - Field: ‘stdout’
[16:09:32.793]   - Field: ‘earlySignal’
[16:09:32.793]   - Field: ‘lazy’
[16:09:32.793]   - Field: ‘state’
[16:09:32.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.793] - Launch lazy future ...
[16:09:32.793] Packages needed by the future expression (n = 0): <none>
[16:09:32.793] Packages needed by future strategies (n = 0): <none>
[16:09:32.794] {
[16:09:32.794]     {
[16:09:32.794]         {
[16:09:32.794]             ...future.startTime <- base::Sys.time()
[16:09:32.794]             {
[16:09:32.794]                 {
[16:09:32.794]                   {
[16:09:32.794]                     base::local({
[16:09:32.794]                       has_future <- base::requireNamespace("future", 
[16:09:32.794]                         quietly = TRUE)
[16:09:32.794]                       if (has_future) {
[16:09:32.794]                         ns <- base::getNamespace("future")
[16:09:32.794]                         version <- ns[[".package"]][["version"]]
[16:09:32.794]                         if (is.null(version)) 
[16:09:32.794]                           version <- utils::packageVersion("future")
[16:09:32.794]                       }
[16:09:32.794]                       else {
[16:09:32.794]                         version <- NULL
[16:09:32.794]                       }
[16:09:32.794]                       if (!has_future || version < "1.8.0") {
[16:09:32.794]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.794]                           "", base::R.version$version.string), 
[16:09:32.794]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.794]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.794]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.794]                             "release", "version")], collapse = " "), 
[16:09:32.794]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.794]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.794]                           info)
[16:09:32.794]                         info <- base::paste(info, collapse = "; ")
[16:09:32.794]                         if (!has_future) {
[16:09:32.794]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.794]                             info)
[16:09:32.794]                         }
[16:09:32.794]                         else {
[16:09:32.794]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.794]                             info, version)
[16:09:32.794]                         }
[16:09:32.794]                         base::stop(msg)
[16:09:32.794]                       }
[16:09:32.794]                     })
[16:09:32.794]                   }
[16:09:32.794]                   options(future.plan = NULL)
[16:09:32.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.794]                 }
[16:09:32.794]                 ...future.workdir <- getwd()
[16:09:32.794]             }
[16:09:32.794]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.794]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.794]         }
[16:09:32.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.794]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.794]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.794]             base::names(...future.oldOptions))
[16:09:32.794]     }
[16:09:32.794]     if (FALSE) {
[16:09:32.794]     }
[16:09:32.794]     else {
[16:09:32.794]         if (TRUE) {
[16:09:32.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.794]                 open = "w")
[16:09:32.794]         }
[16:09:32.794]         else {
[16:09:32.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.794]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.794]         }
[16:09:32.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.794]             base::sink(type = "output", split = FALSE)
[16:09:32.794]             base::close(...future.stdout)
[16:09:32.794]         }, add = TRUE)
[16:09:32.794]     }
[16:09:32.794]     ...future.frame <- base::sys.nframe()
[16:09:32.794]     ...future.conditions <- base::list()
[16:09:32.794]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.794]     if (FALSE) {
[16:09:32.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.794]     }
[16:09:32.794]     ...future.result <- base::tryCatch({
[16:09:32.794]         base::withCallingHandlers({
[16:09:32.794]             ...future.value <- base::withVisible(base::local({
[16:09:32.794]                 do.call(function(...) {
[16:09:32.794]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.794]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.794]                     ...future.globals.maxSize)) {
[16:09:32.794]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.794]                     on.exit(options(oopts), add = TRUE)
[16:09:32.794]                   }
[16:09:32.794]                   {
[16:09:32.794]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.794]                       FUN = function(jj) {
[16:09:32.794]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.794]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.794]                       })
[16:09:32.794]                   }
[16:09:32.794]                 }, args = future.call.arguments)
[16:09:32.794]             }))
[16:09:32.794]             future::FutureResult(value = ...future.value$value, 
[16:09:32.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.794]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.794]                     ...future.globalenv.names))
[16:09:32.794]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.794]         }, condition = base::local({
[16:09:32.794]             c <- base::c
[16:09:32.794]             inherits <- base::inherits
[16:09:32.794]             invokeRestart <- base::invokeRestart
[16:09:32.794]             length <- base::length
[16:09:32.794]             list <- base::list
[16:09:32.794]             seq.int <- base::seq.int
[16:09:32.794]             signalCondition <- base::signalCondition
[16:09:32.794]             sys.calls <- base::sys.calls
[16:09:32.794]             `[[` <- base::`[[`
[16:09:32.794]             `+` <- base::`+`
[16:09:32.794]             `<<-` <- base::`<<-`
[16:09:32.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.794]                   3L)]
[16:09:32.794]             }
[16:09:32.794]             function(cond) {
[16:09:32.794]                 is_error <- inherits(cond, "error")
[16:09:32.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.794]                   NULL)
[16:09:32.794]                 if (is_error) {
[16:09:32.794]                   sessionInformation <- function() {
[16:09:32.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.794]                       search = base::search(), system = base::Sys.info())
[16:09:32.794]                   }
[16:09:32.794]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.794]                     cond$call), session = sessionInformation(), 
[16:09:32.794]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.794]                   signalCondition(cond)
[16:09:32.794]                 }
[16:09:32.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.794]                 "immediateCondition"))) {
[16:09:32.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.794]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.794]                   if (TRUE && !signal) {
[16:09:32.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.794]                     {
[16:09:32.794]                       inherits <- base::inherits
[16:09:32.794]                       invokeRestart <- base::invokeRestart
[16:09:32.794]                       is.null <- base::is.null
[16:09:32.794]                       muffled <- FALSE
[16:09:32.794]                       if (inherits(cond, "message")) {
[16:09:32.794]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.794]                         if (muffled) 
[16:09:32.794]                           invokeRestart("muffleMessage")
[16:09:32.794]                       }
[16:09:32.794]                       else if (inherits(cond, "warning")) {
[16:09:32.794]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.794]                         if (muffled) 
[16:09:32.794]                           invokeRestart("muffleWarning")
[16:09:32.794]                       }
[16:09:32.794]                       else if (inherits(cond, "condition")) {
[16:09:32.794]                         if (!is.null(pattern)) {
[16:09:32.794]                           computeRestarts <- base::computeRestarts
[16:09:32.794]                           grepl <- base::grepl
[16:09:32.794]                           restarts <- computeRestarts(cond)
[16:09:32.794]                           for (restart in restarts) {
[16:09:32.794]                             name <- restart$name
[16:09:32.794]                             if (is.null(name)) 
[16:09:32.794]                               next
[16:09:32.794]                             if (!grepl(pattern, name)) 
[16:09:32.794]                               next
[16:09:32.794]                             invokeRestart(restart)
[16:09:32.794]                             muffled <- TRUE
[16:09:32.794]                             break
[16:09:32.794]                           }
[16:09:32.794]                         }
[16:09:32.794]                       }
[16:09:32.794]                       invisible(muffled)
[16:09:32.794]                     }
[16:09:32.794]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.794]                   }
[16:09:32.794]                 }
[16:09:32.794]                 else {
[16:09:32.794]                   if (TRUE) {
[16:09:32.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.794]                     {
[16:09:32.794]                       inherits <- base::inherits
[16:09:32.794]                       invokeRestart <- base::invokeRestart
[16:09:32.794]                       is.null <- base::is.null
[16:09:32.794]                       muffled <- FALSE
[16:09:32.794]                       if (inherits(cond, "message")) {
[16:09:32.794]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.794]                         if (muffled) 
[16:09:32.794]                           invokeRestart("muffleMessage")
[16:09:32.794]                       }
[16:09:32.794]                       else if (inherits(cond, "warning")) {
[16:09:32.794]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.794]                         if (muffled) 
[16:09:32.794]                           invokeRestart("muffleWarning")
[16:09:32.794]                       }
[16:09:32.794]                       else if (inherits(cond, "condition")) {
[16:09:32.794]                         if (!is.null(pattern)) {
[16:09:32.794]                           computeRestarts <- base::computeRestarts
[16:09:32.794]                           grepl <- base::grepl
[16:09:32.794]                           restarts <- computeRestarts(cond)
[16:09:32.794]                           for (restart in restarts) {
[16:09:32.794]                             name <- restart$name
[16:09:32.794]                             if (is.null(name)) 
[16:09:32.794]                               next
[16:09:32.794]                             if (!grepl(pattern, name)) 
[16:09:32.794]                               next
[16:09:32.794]                             invokeRestart(restart)
[16:09:32.794]                             muffled <- TRUE
[16:09:32.794]                             break
[16:09:32.794]                           }
[16:09:32.794]                         }
[16:09:32.794]                       }
[16:09:32.794]                       invisible(muffled)
[16:09:32.794]                     }
[16:09:32.794]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.794]                   }
[16:09:32.794]                 }
[16:09:32.794]             }
[16:09:32.794]         }))
[16:09:32.794]     }, error = function(ex) {
[16:09:32.794]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.794]                 ...future.rng), started = ...future.startTime, 
[16:09:32.794]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.794]             version = "1.8"), class = "FutureResult")
[16:09:32.794]     }, finally = {
[16:09:32.794]         if (!identical(...future.workdir, getwd())) 
[16:09:32.794]             setwd(...future.workdir)
[16:09:32.794]         {
[16:09:32.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.794]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.794]             }
[16:09:32.794]             base::options(...future.oldOptions)
[16:09:32.794]             if (.Platform$OS.type == "windows") {
[16:09:32.794]                 old_names <- names(...future.oldEnvVars)
[16:09:32.794]                 envs <- base::Sys.getenv()
[16:09:32.794]                 names <- names(envs)
[16:09:32.794]                 common <- intersect(names, old_names)
[16:09:32.794]                 added <- setdiff(names, old_names)
[16:09:32.794]                 removed <- setdiff(old_names, names)
[16:09:32.794]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.794]                   envs[common]]
[16:09:32.794]                 NAMES <- toupper(changed)
[16:09:32.794]                 args <- list()
[16:09:32.794]                 for (kk in seq_along(NAMES)) {
[16:09:32.794]                   name <- changed[[kk]]
[16:09:32.794]                   NAME <- NAMES[[kk]]
[16:09:32.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.794]                     next
[16:09:32.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.794]                 }
[16:09:32.794]                 NAMES <- toupper(added)
[16:09:32.794]                 for (kk in seq_along(NAMES)) {
[16:09:32.794]                   name <- added[[kk]]
[16:09:32.794]                   NAME <- NAMES[[kk]]
[16:09:32.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.794]                     next
[16:09:32.794]                   args[[name]] <- ""
[16:09:32.794]                 }
[16:09:32.794]                 NAMES <- toupper(removed)
[16:09:32.794]                 for (kk in seq_along(NAMES)) {
[16:09:32.794]                   name <- removed[[kk]]
[16:09:32.794]                   NAME <- NAMES[[kk]]
[16:09:32.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.794]                     next
[16:09:32.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.794]                 }
[16:09:32.794]                 if (length(args) > 0) 
[16:09:32.794]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.794]             }
[16:09:32.794]             else {
[16:09:32.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.794]             }
[16:09:32.794]             {
[16:09:32.794]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.794]                   0L) {
[16:09:32.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.794]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.794]                   base::options(opts)
[16:09:32.794]                 }
[16:09:32.794]                 {
[16:09:32.794]                   {
[16:09:32.794]                     NULL
[16:09:32.794]                     RNGkind("Mersenne-Twister")
[16:09:32.794]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.794]                       inherits = FALSE)
[16:09:32.794]                   }
[16:09:32.794]                   options(future.plan = NULL)
[16:09:32.794]                   if (is.na(NA_character_)) 
[16:09:32.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.794]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:32.794]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:32.794]                     envir = parent.frame()) 
[16:09:32.794]                   {
[16:09:32.794]                     if (is.function(workers)) 
[16:09:32.794]                       workers <- workers()
[16:09:32.794]                     workers <- structure(as.integer(workers), 
[16:09:32.794]                       class = class(workers))
[16:09:32.794]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:32.794]                       workers >= 1)
[16:09:32.794]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:32.794]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:32.794]                     }
[16:09:32.794]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:32.794]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:32.794]                       envir = envir)
[16:09:32.794]                     if (!future$lazy) 
[16:09:32.794]                       future <- run(future)
[16:09:32.794]                     invisible(future)
[16:09:32.794]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.794]                 }
[16:09:32.794]             }
[16:09:32.794]         }
[16:09:32.794]     })
[16:09:32.794]     if (TRUE) {
[16:09:32.794]         base::sink(type = "output", split = FALSE)
[16:09:32.794]         if (TRUE) {
[16:09:32.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.794]         }
[16:09:32.794]         else {
[16:09:32.794]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.794]         }
[16:09:32.794]         base::close(...future.stdout)
[16:09:32.794]         ...future.stdout <- NULL
[16:09:32.794]     }
[16:09:32.794]     ...future.result$conditions <- ...future.conditions
[16:09:32.794]     ...future.result$finished <- base::Sys.time()
[16:09:32.794]     ...future.result
[16:09:32.794] }
[16:09:32.795] assign_globals() ...
[16:09:32.795] List of 5
[16:09:32.795]  $ ...future.FUN            :function (object, ...)  
[16:09:32.795]  $ future.call.arguments    : list()
[16:09:32.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.795]  $ ...future.elements_ii    :List of 3
[16:09:32.795]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.795]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.795]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.795]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.795]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.795]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.795]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.795]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.795]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.795]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.795]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.795]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.795]  $ ...future.seeds_ii       : NULL
[16:09:32.795]  $ ...future.globals.maxSize: NULL
[16:09:32.795]  - attr(*, "resolved")= logi FALSE
[16:09:32.795]  - attr(*, "total_size")= num 1240
[16:09:32.795]  - attr(*, "where")=List of 5
[16:09:32.795]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.795]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.795]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.795]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.795]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.795]  - attr(*, "already-done")= logi TRUE
[16:09:32.804] - copied ‘...future.FUN’ to environment
[16:09:32.804] - copied ‘future.call.arguments’ to environment
[16:09:32.804] - copied ‘...future.elements_ii’ to environment
[16:09:32.804] - copied ‘...future.seeds_ii’ to environment
[16:09:32.804] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.804] assign_globals() ... done
[16:09:32.805] plan(): Setting new future strategy stack:
[16:09:32.805] List of future strategies:
[16:09:32.805] 1. sequential:
[16:09:32.805]    - args: function (..., envir = parent.frame())
[16:09:32.805]    - tweaked: FALSE
[16:09:32.805]    - call: NULL
[16:09:32.805] plan(): nbrOfWorkers() = 1
[16:09:32.807] plan(): Setting new future strategy stack:
[16:09:32.807] List of future strategies:
[16:09:32.807] 1. multisession:
[16:09:32.807]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:32.807]    - tweaked: FALSE
[16:09:32.807]    - call: plan(strategy)
[16:09:32.810] plan(): nbrOfWorkers() = 1
[16:09:32.811] SequentialFuture started (and completed)
[16:09:32.811] - Launch lazy future ... done
[16:09:32.811] run() for ‘SequentialFuture’ ... done
[16:09:32.811] Created future:
[16:09:32.811] SequentialFuture:
[16:09:32.811] Label: ‘future_by-1’
[16:09:32.811] Expression:
[16:09:32.811] {
[16:09:32.811]     do.call(function(...) {
[16:09:32.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.811]             on.exit(options(oopts), add = TRUE)
[16:09:32.811]         }
[16:09:32.811]         {
[16:09:32.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.811]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.811]             })
[16:09:32.811]         }
[16:09:32.811]     }, args = future.call.arguments)
[16:09:32.811] }
[16:09:32.811] Lazy evaluation: FALSE
[16:09:32.811] Asynchronous evaluation: FALSE
[16:09:32.811] Local evaluation: TRUE
[16:09:32.811] Environment: 0x5567e7c53f28
[16:09:32.811] Capture standard output: TRUE
[16:09:32.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.811] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.811] Packages: <none>
[16:09:32.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.811] Resolved: TRUE
[16:09:32.811] Value: 5.37 KiB of class ‘list’
[16:09:32.811] Early signaling: FALSE
[16:09:32.811] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.811] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.812] Chunk #1 of 1 ... DONE
[16:09:32.812] Launching 1 futures (chunks) ... DONE
[16:09:32.812] Resolving 1 futures (chunks) ...
[16:09:32.813] resolve() on list ...
[16:09:32.813]  recursive: 0
[16:09:32.813]  length: 1
[16:09:32.813] 
[16:09:32.813] resolved() for ‘SequentialFuture’ ...
[16:09:32.813] - state: ‘finished’
[16:09:32.813] - run: TRUE
[16:09:32.813] - result: ‘FutureResult’
[16:09:32.813] resolved() for ‘SequentialFuture’ ... done
[16:09:32.813] Future #1
[16:09:32.814] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.815] - nx: 1
[16:09:32.815] - relay: TRUE
[16:09:32.815] - stdout: TRUE
[16:09:32.815] - signal: TRUE
[16:09:32.815] - resignal: FALSE
[16:09:32.815] - force: TRUE
[16:09:32.815] - relayed: [n=1] FALSE
[16:09:32.815] - queued futures: [n=1] FALSE
[16:09:32.815]  - until=1
[16:09:32.815]  - relaying element #1
[16:09:32.816] - relayed: [n=1] TRUE
[16:09:32.816] - queued futures: [n=1] TRUE
[16:09:32.816] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.816]  length: 0 (resolved future 1)
[16:09:32.816] Relaying remaining futures
[16:09:32.816] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.816] - nx: 1
[16:09:32.816] - relay: TRUE
[16:09:32.816] - stdout: TRUE
[16:09:32.817] - signal: TRUE
[16:09:32.817] - resignal: FALSE
[16:09:32.817] - force: TRUE
[16:09:32.817] - relayed: [n=1] TRUE
[16:09:32.817] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.817] - relayed: [n=1] TRUE
[16:09:32.817] - queued futures: [n=1] TRUE
[16:09:32.817] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.817] resolve() on list ... DONE
[16:09:32.817]  - Number of value chunks collected: 1
[16:09:32.817] Resolving 1 futures (chunks) ... DONE
[16:09:32.818] Reducing values from 1 chunks ...
[16:09:32.818]  - Number of values collected after concatenation: 3
[16:09:32.818]  - Number of values expected: 3
[16:09:32.818] Reducing values from 1 chunks ... DONE
[16:09:32.818] future_lapply() ... DONE
[16:09:32.818] future_by_internal() ... DONE
[16:09:32.819] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[16:09:32.820] plan(): Setting new future strategy stack:
[16:09:32.820] List of future strategies:
[16:09:32.820] 1. sequential:
[16:09:32.820]    - args: function (..., envir = parent.frame())
[16:09:32.820]    - tweaked: FALSE
[16:09:32.820]    - call: plan(strategy)
[16:09:32.820] plan(): nbrOfWorkers() = 1
[16:09:32.820] future_by_internal() ...
[16:09:32.821] future_lapply() ...
[16:09:32.821] Number of chunks: 1
[16:09:32.821] getGlobalsAndPackagesXApply() ...
[16:09:32.821]  - future.globals: TRUE
[16:09:32.821] getGlobalsAndPackages() ...
[16:09:32.821] Searching for globals...
[16:09:32.822] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.822] Searching for globals ... DONE
[16:09:32.822] Resolving globals: FALSE
[16:09:32.823] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.823] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.823] - globals: [1] ‘FUN’
[16:09:32.823] 
[16:09:32.823] getGlobalsAndPackages() ... DONE
[16:09:32.823]  - globals found/used: [n=1] ‘FUN’
[16:09:32.824]  - needed namespaces: [n=0] 
[16:09:32.824] Finding globals ... DONE
[16:09:32.824]  - use_args: TRUE
[16:09:32.824]  - Getting '...' globals ...
[16:09:32.824] resolve() on list ...
[16:09:32.824]  recursive: 0
[16:09:32.824]  length: 1
[16:09:32.824]  elements: ‘...’
[16:09:32.825]  length: 0 (resolved future 1)
[16:09:32.825] resolve() on list ... DONE
[16:09:32.825]    - '...' content: [n=0] 
[16:09:32.825] List of 1
[16:09:32.825]  $ ...: list()
[16:09:32.825]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.825]  - attr(*, "where")=List of 1
[16:09:32.825]   ..$ ...:<environment: 0x5567e7a64990> 
[16:09:32.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.825]  - attr(*, "resolved")= logi TRUE
[16:09:32.825]  - attr(*, "total_size")= num NA
[16:09:32.827]  - Getting '...' globals ... DONE
[16:09:32.827] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.827] List of 2
[16:09:32.827]  $ ...future.FUN:function (object, ...)  
[16:09:32.827]  $ ...          : list()
[16:09:32.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.827]  - attr(*, "where")=List of 2
[16:09:32.827]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.827]   ..$ ...          :<environment: 0x5567e7a64990> 
[16:09:32.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.827]  - attr(*, "resolved")= logi FALSE
[16:09:32.827]  - attr(*, "total_size")= num 1240
[16:09:32.830] Packages to be attached in all futures: [n=0] 
[16:09:32.830] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.830] Number of futures (= number of chunks): 1
[16:09:32.830] Launching 1 futures (chunks) ...
[16:09:32.830] Chunk #1 of 1 ...
[16:09:32.831]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.831] getGlobalsAndPackages() ...
[16:09:32.831] Searching for globals...
[16:09:32.831] 
[16:09:32.831] Searching for globals ... DONE
[16:09:32.831] - globals: [0] <none>
[16:09:32.831] getGlobalsAndPackages() ... DONE
[16:09:32.832]    + additional globals found: [n=0] 
[16:09:32.832]    + additional namespaces needed: [n=0] 
[16:09:32.832]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.832]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.832]  - seeds: <none>
[16:09:32.832] getGlobalsAndPackages() ...
[16:09:32.832] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.832] Resolving globals: FALSE
[16:09:32.832] Tweak future expression to call with '...' arguments ...
[16:09:32.832] {
[16:09:32.832]     do.call(function(...) {
[16:09:32.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.832]             on.exit(options(oopts), add = TRUE)
[16:09:32.832]         }
[16:09:32.832]         {
[16:09:32.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.832]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.832]             })
[16:09:32.832]         }
[16:09:32.832]     }, args = future.call.arguments)
[16:09:32.832] }
[16:09:32.833] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.833] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.834] 
[16:09:32.834] getGlobalsAndPackages() ... DONE
[16:09:32.834] run() for ‘Future’ ...
[16:09:32.835] - state: ‘created’
[16:09:32.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.835] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.835] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.835]   - Field: ‘label’
[16:09:32.835]   - Field: ‘local’
[16:09:32.835]   - Field: ‘owner’
[16:09:32.835]   - Field: ‘envir’
[16:09:32.836]   - Field: ‘packages’
[16:09:32.836]   - Field: ‘gc’
[16:09:32.836]   - Field: ‘conditions’
[16:09:32.836]   - Field: ‘expr’
[16:09:32.836]   - Field: ‘uuid’
[16:09:32.836]   - Field: ‘seed’
[16:09:32.836]   - Field: ‘version’
[16:09:32.836]   - Field: ‘result’
[16:09:32.836]   - Field: ‘asynchronous’
[16:09:32.836]   - Field: ‘calls’
[16:09:32.837]   - Field: ‘globals’
[16:09:32.837]   - Field: ‘stdout’
[16:09:32.837]   - Field: ‘earlySignal’
[16:09:32.837]   - Field: ‘lazy’
[16:09:32.837]   - Field: ‘state’
[16:09:32.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.837] - Launch lazy future ...
[16:09:32.837] Packages needed by the future expression (n = 0): <none>
[16:09:32.837] Packages needed by future strategies (n = 0): <none>
[16:09:32.838] {
[16:09:32.838]     {
[16:09:32.838]         {
[16:09:32.838]             ...future.startTime <- base::Sys.time()
[16:09:32.838]             {
[16:09:32.838]                 {
[16:09:32.838]                   {
[16:09:32.838]                     base::local({
[16:09:32.838]                       has_future <- base::requireNamespace("future", 
[16:09:32.838]                         quietly = TRUE)
[16:09:32.838]                       if (has_future) {
[16:09:32.838]                         ns <- base::getNamespace("future")
[16:09:32.838]                         version <- ns[[".package"]][["version"]]
[16:09:32.838]                         if (is.null(version)) 
[16:09:32.838]                           version <- utils::packageVersion("future")
[16:09:32.838]                       }
[16:09:32.838]                       else {
[16:09:32.838]                         version <- NULL
[16:09:32.838]                       }
[16:09:32.838]                       if (!has_future || version < "1.8.0") {
[16:09:32.838]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.838]                           "", base::R.version$version.string), 
[16:09:32.838]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.838]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.838]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.838]                             "release", "version")], collapse = " "), 
[16:09:32.838]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.838]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.838]                           info)
[16:09:32.838]                         info <- base::paste(info, collapse = "; ")
[16:09:32.838]                         if (!has_future) {
[16:09:32.838]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.838]                             info)
[16:09:32.838]                         }
[16:09:32.838]                         else {
[16:09:32.838]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.838]                             info, version)
[16:09:32.838]                         }
[16:09:32.838]                         base::stop(msg)
[16:09:32.838]                       }
[16:09:32.838]                     })
[16:09:32.838]                   }
[16:09:32.838]                   options(future.plan = NULL)
[16:09:32.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.838]                 }
[16:09:32.838]                 ...future.workdir <- getwd()
[16:09:32.838]             }
[16:09:32.838]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.838]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.838]         }
[16:09:32.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.838]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.838]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.838]             base::names(...future.oldOptions))
[16:09:32.838]     }
[16:09:32.838]     if (FALSE) {
[16:09:32.838]     }
[16:09:32.838]     else {
[16:09:32.838]         if (TRUE) {
[16:09:32.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.838]                 open = "w")
[16:09:32.838]         }
[16:09:32.838]         else {
[16:09:32.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.838]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.838]         }
[16:09:32.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.838]             base::sink(type = "output", split = FALSE)
[16:09:32.838]             base::close(...future.stdout)
[16:09:32.838]         }, add = TRUE)
[16:09:32.838]     }
[16:09:32.838]     ...future.frame <- base::sys.nframe()
[16:09:32.838]     ...future.conditions <- base::list()
[16:09:32.838]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.838]     if (FALSE) {
[16:09:32.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.838]     }
[16:09:32.838]     ...future.result <- base::tryCatch({
[16:09:32.838]         base::withCallingHandlers({
[16:09:32.838]             ...future.value <- base::withVisible(base::local({
[16:09:32.838]                 do.call(function(...) {
[16:09:32.838]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.838]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.838]                     ...future.globals.maxSize)) {
[16:09:32.838]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.838]                     on.exit(options(oopts), add = TRUE)
[16:09:32.838]                   }
[16:09:32.838]                   {
[16:09:32.838]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.838]                       FUN = function(jj) {
[16:09:32.838]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.838]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.838]                       })
[16:09:32.838]                   }
[16:09:32.838]                 }, args = future.call.arguments)
[16:09:32.838]             }))
[16:09:32.838]             future::FutureResult(value = ...future.value$value, 
[16:09:32.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.838]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.838]                     ...future.globalenv.names))
[16:09:32.838]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.838]         }, condition = base::local({
[16:09:32.838]             c <- base::c
[16:09:32.838]             inherits <- base::inherits
[16:09:32.838]             invokeRestart <- base::invokeRestart
[16:09:32.838]             length <- base::length
[16:09:32.838]             list <- base::list
[16:09:32.838]             seq.int <- base::seq.int
[16:09:32.838]             signalCondition <- base::signalCondition
[16:09:32.838]             sys.calls <- base::sys.calls
[16:09:32.838]             `[[` <- base::`[[`
[16:09:32.838]             `+` <- base::`+`
[16:09:32.838]             `<<-` <- base::`<<-`
[16:09:32.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.838]                   3L)]
[16:09:32.838]             }
[16:09:32.838]             function(cond) {
[16:09:32.838]                 is_error <- inherits(cond, "error")
[16:09:32.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.838]                   NULL)
[16:09:32.838]                 if (is_error) {
[16:09:32.838]                   sessionInformation <- function() {
[16:09:32.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.838]                       search = base::search(), system = base::Sys.info())
[16:09:32.838]                   }
[16:09:32.838]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.838]                     cond$call), session = sessionInformation(), 
[16:09:32.838]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.838]                   signalCondition(cond)
[16:09:32.838]                 }
[16:09:32.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.838]                 "immediateCondition"))) {
[16:09:32.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.838]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.838]                   if (TRUE && !signal) {
[16:09:32.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.838]                     {
[16:09:32.838]                       inherits <- base::inherits
[16:09:32.838]                       invokeRestart <- base::invokeRestart
[16:09:32.838]                       is.null <- base::is.null
[16:09:32.838]                       muffled <- FALSE
[16:09:32.838]                       if (inherits(cond, "message")) {
[16:09:32.838]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.838]                         if (muffled) 
[16:09:32.838]                           invokeRestart("muffleMessage")
[16:09:32.838]                       }
[16:09:32.838]                       else if (inherits(cond, "warning")) {
[16:09:32.838]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.838]                         if (muffled) 
[16:09:32.838]                           invokeRestart("muffleWarning")
[16:09:32.838]                       }
[16:09:32.838]                       else if (inherits(cond, "condition")) {
[16:09:32.838]                         if (!is.null(pattern)) {
[16:09:32.838]                           computeRestarts <- base::computeRestarts
[16:09:32.838]                           grepl <- base::grepl
[16:09:32.838]                           restarts <- computeRestarts(cond)
[16:09:32.838]                           for (restart in restarts) {
[16:09:32.838]                             name <- restart$name
[16:09:32.838]                             if (is.null(name)) 
[16:09:32.838]                               next
[16:09:32.838]                             if (!grepl(pattern, name)) 
[16:09:32.838]                               next
[16:09:32.838]                             invokeRestart(restart)
[16:09:32.838]                             muffled <- TRUE
[16:09:32.838]                             break
[16:09:32.838]                           }
[16:09:32.838]                         }
[16:09:32.838]                       }
[16:09:32.838]                       invisible(muffled)
[16:09:32.838]                     }
[16:09:32.838]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.838]                   }
[16:09:32.838]                 }
[16:09:32.838]                 else {
[16:09:32.838]                   if (TRUE) {
[16:09:32.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.838]                     {
[16:09:32.838]                       inherits <- base::inherits
[16:09:32.838]                       invokeRestart <- base::invokeRestart
[16:09:32.838]                       is.null <- base::is.null
[16:09:32.838]                       muffled <- FALSE
[16:09:32.838]                       if (inherits(cond, "message")) {
[16:09:32.838]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.838]                         if (muffled) 
[16:09:32.838]                           invokeRestart("muffleMessage")
[16:09:32.838]                       }
[16:09:32.838]                       else if (inherits(cond, "warning")) {
[16:09:32.838]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.838]                         if (muffled) 
[16:09:32.838]                           invokeRestart("muffleWarning")
[16:09:32.838]                       }
[16:09:32.838]                       else if (inherits(cond, "condition")) {
[16:09:32.838]                         if (!is.null(pattern)) {
[16:09:32.838]                           computeRestarts <- base::computeRestarts
[16:09:32.838]                           grepl <- base::grepl
[16:09:32.838]                           restarts <- computeRestarts(cond)
[16:09:32.838]                           for (restart in restarts) {
[16:09:32.838]                             name <- restart$name
[16:09:32.838]                             if (is.null(name)) 
[16:09:32.838]                               next
[16:09:32.838]                             if (!grepl(pattern, name)) 
[16:09:32.838]                               next
[16:09:32.838]                             invokeRestart(restart)
[16:09:32.838]                             muffled <- TRUE
[16:09:32.838]                             break
[16:09:32.838]                           }
[16:09:32.838]                         }
[16:09:32.838]                       }
[16:09:32.838]                       invisible(muffled)
[16:09:32.838]                     }
[16:09:32.838]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.838]                   }
[16:09:32.838]                 }
[16:09:32.838]             }
[16:09:32.838]         }))
[16:09:32.838]     }, error = function(ex) {
[16:09:32.838]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.838]                 ...future.rng), started = ...future.startTime, 
[16:09:32.838]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.838]             version = "1.8"), class = "FutureResult")
[16:09:32.838]     }, finally = {
[16:09:32.838]         if (!identical(...future.workdir, getwd())) 
[16:09:32.838]             setwd(...future.workdir)
[16:09:32.838]         {
[16:09:32.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.838]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.838]             }
[16:09:32.838]             base::options(...future.oldOptions)
[16:09:32.838]             if (.Platform$OS.type == "windows") {
[16:09:32.838]                 old_names <- names(...future.oldEnvVars)
[16:09:32.838]                 envs <- base::Sys.getenv()
[16:09:32.838]                 names <- names(envs)
[16:09:32.838]                 common <- intersect(names, old_names)
[16:09:32.838]                 added <- setdiff(names, old_names)
[16:09:32.838]                 removed <- setdiff(old_names, names)
[16:09:32.838]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.838]                   envs[common]]
[16:09:32.838]                 NAMES <- toupper(changed)
[16:09:32.838]                 args <- list()
[16:09:32.838]                 for (kk in seq_along(NAMES)) {
[16:09:32.838]                   name <- changed[[kk]]
[16:09:32.838]                   NAME <- NAMES[[kk]]
[16:09:32.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.838]                     next
[16:09:32.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.838]                 }
[16:09:32.838]                 NAMES <- toupper(added)
[16:09:32.838]                 for (kk in seq_along(NAMES)) {
[16:09:32.838]                   name <- added[[kk]]
[16:09:32.838]                   NAME <- NAMES[[kk]]
[16:09:32.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.838]                     next
[16:09:32.838]                   args[[name]] <- ""
[16:09:32.838]                 }
[16:09:32.838]                 NAMES <- toupper(removed)
[16:09:32.838]                 for (kk in seq_along(NAMES)) {
[16:09:32.838]                   name <- removed[[kk]]
[16:09:32.838]                   NAME <- NAMES[[kk]]
[16:09:32.838]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.838]                     next
[16:09:32.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.838]                 }
[16:09:32.838]                 if (length(args) > 0) 
[16:09:32.838]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.838]             }
[16:09:32.838]             else {
[16:09:32.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.838]             }
[16:09:32.838]             {
[16:09:32.838]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.838]                   0L) {
[16:09:32.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.838]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.838]                   base::options(opts)
[16:09:32.838]                 }
[16:09:32.838]                 {
[16:09:32.838]                   {
[16:09:32.838]                     NULL
[16:09:32.838]                     RNGkind("Mersenne-Twister")
[16:09:32.838]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.838]                       inherits = FALSE)
[16:09:32.838]                   }
[16:09:32.838]                   options(future.plan = NULL)
[16:09:32.838]                   if (is.na(NA_character_)) 
[16:09:32.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.838]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.838]                   {
[16:09:32.838]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.838]                     if (!future$lazy) 
[16:09:32.838]                       future <- run(future)
[16:09:32.838]                     invisible(future)
[16:09:32.838]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.838]                 }
[16:09:32.838]             }
[16:09:32.838]         }
[16:09:32.838]     })
[16:09:32.838]     if (TRUE) {
[16:09:32.838]         base::sink(type = "output", split = FALSE)
[16:09:32.838]         if (TRUE) {
[16:09:32.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.838]         }
[16:09:32.838]         else {
[16:09:32.838]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.838]         }
[16:09:32.838]         base::close(...future.stdout)
[16:09:32.838]         ...future.stdout <- NULL
[16:09:32.838]     }
[16:09:32.838]     ...future.result$conditions <- ...future.conditions
[16:09:32.838]     ...future.result$finished <- base::Sys.time()
[16:09:32.838]     ...future.result
[16:09:32.838] }
[16:09:32.839] assign_globals() ...
[16:09:32.839] List of 5
[16:09:32.839]  $ ...future.FUN            :function (object, ...)  
[16:09:32.839]  $ future.call.arguments    : list()
[16:09:32.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.839]  $ ...future.elements_ii    :List of 3
[16:09:32.839]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.839]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.839]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.839]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.839]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.839]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.839]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:32.839]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.839]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.839]  $ ...future.seeds_ii       : NULL
[16:09:32.839]  $ ...future.globals.maxSize: NULL
[16:09:32.839]  - attr(*, "resolved")= logi FALSE
[16:09:32.839]  - attr(*, "total_size")= num 1240
[16:09:32.839]  - attr(*, "where")=List of 5
[16:09:32.839]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.839]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.839]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.839]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.839]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.839]  - attr(*, "already-done")= logi TRUE
[16:09:32.846] - copied ‘...future.FUN’ to environment
[16:09:32.847] - copied ‘future.call.arguments’ to environment
[16:09:32.847] - copied ‘...future.elements_ii’ to environment
[16:09:32.847] - copied ‘...future.seeds_ii’ to environment
[16:09:32.847] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.847] assign_globals() ... done
[16:09:32.847] plan(): Setting new future strategy stack:
[16:09:32.847] List of future strategies:
[16:09:32.847] 1. sequential:
[16:09:32.847]    - args: function (..., envir = parent.frame())
[16:09:32.847]    - tweaked: FALSE
[16:09:32.847]    - call: NULL
[16:09:32.848] plan(): nbrOfWorkers() = 1
[16:09:32.850] plan(): Setting new future strategy stack:
[16:09:32.850] List of future strategies:
[16:09:32.850] 1. sequential:
[16:09:32.850]    - args: function (..., envir = parent.frame())
[16:09:32.850]    - tweaked: FALSE
[16:09:32.850]    - call: plan(strategy)
[16:09:32.850] plan(): nbrOfWorkers() = 1
[16:09:32.850] SequentialFuture started (and completed)
[16:09:32.851] - Launch lazy future ... done
[16:09:32.851] run() for ‘SequentialFuture’ ... done
[16:09:32.851] Created future:
[16:09:32.851] SequentialFuture:
[16:09:32.851] Label: ‘future_by-1’
[16:09:32.851] Expression:
[16:09:32.851] {
[16:09:32.851]     do.call(function(...) {
[16:09:32.851]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.851]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.851]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.851]             on.exit(options(oopts), add = TRUE)
[16:09:32.851]         }
[16:09:32.851]         {
[16:09:32.851]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.851]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.851]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.851]             })
[16:09:32.851]         }
[16:09:32.851]     }, args = future.call.arguments)
[16:09:32.851] }
[16:09:32.851] Lazy evaluation: FALSE
[16:09:32.851] Asynchronous evaluation: FALSE
[16:09:32.851] Local evaluation: TRUE
[16:09:32.851] Environment: R_GlobalEnv
[16:09:32.851] Capture standard output: TRUE
[16:09:32.851] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.851] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.851] Packages: <none>
[16:09:32.851] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.851] Resolved: TRUE
[16:09:32.851] Value: 4.62 KiB of class ‘list’
[16:09:32.851] Early signaling: FALSE
[16:09:32.851] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.851] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.852] Chunk #1 of 1 ... DONE
[16:09:32.852] Launching 1 futures (chunks) ... DONE
[16:09:32.852] Resolving 1 futures (chunks) ...
[16:09:32.853] resolve() on list ...
[16:09:32.853]  recursive: 0
[16:09:32.853]  length: 1
[16:09:32.853] 
[16:09:32.853] resolved() for ‘SequentialFuture’ ...
[16:09:32.853] - state: ‘finished’
[16:09:32.853] - run: TRUE
[16:09:32.853] - result: ‘FutureResult’
[16:09:32.853] resolved() for ‘SequentialFuture’ ... done
[16:09:32.853] Future #1
[16:09:32.854] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.854] - nx: 1
[16:09:32.854] - relay: TRUE
[16:09:32.854] - stdout: TRUE
[16:09:32.854] - signal: TRUE
[16:09:32.854] - resignal: FALSE
[16:09:32.854] - force: TRUE
[16:09:32.854] - relayed: [n=1] FALSE
[16:09:32.854] - queued futures: [n=1] FALSE
[16:09:32.854]  - until=1
[16:09:32.854]  - relaying element #1
[16:09:32.855] - relayed: [n=1] TRUE
[16:09:32.856] - queued futures: [n=1] TRUE
[16:09:32.856] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.856]  length: 0 (resolved future 1)
[16:09:32.856] Relaying remaining futures
[16:09:32.856] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.856] - nx: 1
[16:09:32.857] - relay: TRUE
[16:09:32.857] - stdout: TRUE
[16:09:32.857] - signal: TRUE
[16:09:32.857] - resignal: FALSE
[16:09:32.857] - force: TRUE
[16:09:32.857] - relayed: [n=1] TRUE
[16:09:32.857] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.857] - relayed: [n=1] TRUE
[16:09:32.857] - queued futures: [n=1] TRUE
[16:09:32.857] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.858] resolve() on list ... DONE
[16:09:32.858]  - Number of value chunks collected: 1
[16:09:32.858] Resolving 1 futures (chunks) ... DONE
[16:09:32.858] Reducing values from 1 chunks ...
[16:09:32.858]  - Number of values collected after concatenation: 3
[16:09:32.858]  - Number of values expected: 3
[16:09:32.858] Reducing values from 1 chunks ... DONE
[16:09:32.858] future_lapply() ... DONE
[16:09:32.858] future_by_internal() ... DONE
[16:09:32.859] future_by_internal() ...
[16:09:32.859] future_lapply() ...
[16:09:32.859] Number of chunks: 1
[16:09:32.860] getGlobalsAndPackagesXApply() ...
[16:09:32.860]  - future.globals: TRUE
[16:09:32.860] getGlobalsAndPackages() ...
[16:09:32.860] Searching for globals...
[16:09:32.861] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.861] Searching for globals ... DONE
[16:09:32.861] Resolving globals: FALSE
[16:09:32.861] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.862] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.862] - globals: [1] ‘FUN’
[16:09:32.862] 
[16:09:32.862] getGlobalsAndPackages() ... DONE
[16:09:32.862]  - globals found/used: [n=1] ‘FUN’
[16:09:32.862]  - needed namespaces: [n=0] 
[16:09:32.862] Finding globals ... DONE
[16:09:32.862]  - use_args: TRUE
[16:09:32.862]  - Getting '...' globals ...
[16:09:32.863] resolve() on list ...
[16:09:32.863]  recursive: 0
[16:09:32.863]  length: 1
[16:09:32.863]  elements: ‘...’
[16:09:32.863]  length: 0 (resolved future 1)
[16:09:32.863] resolve() on list ... DONE
[16:09:32.863]    - '...' content: [n=1] ‘digits’
[16:09:32.863] List of 1
[16:09:32.863]  $ ...:List of 1
[16:09:32.863]   ..$ digits: int 2
[16:09:32.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.863]  - attr(*, "where")=List of 1
[16:09:32.863]   ..$ ...:<environment: 0x5567e891bd70> 
[16:09:32.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.863]  - attr(*, "resolved")= logi TRUE
[16:09:32.863]  - attr(*, "total_size")= num NA
[16:09:32.866]  - Getting '...' globals ... DONE
[16:09:32.866] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.867] List of 2
[16:09:32.867]  $ ...future.FUN:function (object, ...)  
[16:09:32.867]  $ ...          :List of 1
[16:09:32.867]   ..$ digits: int 2
[16:09:32.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.867]  - attr(*, "where")=List of 2
[16:09:32.867]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.867]   ..$ ...          :<environment: 0x5567e891bd70> 
[16:09:32.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.867]  - attr(*, "resolved")= logi FALSE
[16:09:32.867]  - attr(*, "total_size")= num 1296
[16:09:32.870] Packages to be attached in all futures: [n=0] 
[16:09:32.870] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.870] Number of futures (= number of chunks): 1
[16:09:32.870] Launching 1 futures (chunks) ...
[16:09:32.870] Chunk #1 of 1 ...
[16:09:32.870]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.870] getGlobalsAndPackages() ...
[16:09:32.870] Searching for globals...
[16:09:32.871] 
[16:09:32.871] Searching for globals ... DONE
[16:09:32.871] - globals: [0] <none>
[16:09:32.871] getGlobalsAndPackages() ... DONE
[16:09:32.871]    + additional globals found: [n=0] 
[16:09:32.871]    + additional namespaces needed: [n=0] 
[16:09:32.871]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.871]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[16:09:32.871]  - seeds: <none>
[16:09:32.871] getGlobalsAndPackages() ...
[16:09:32.871] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.872] Resolving globals: FALSE
[16:09:32.872] Tweak future expression to call with '...' arguments ...
[16:09:32.872] {
[16:09:32.872]     do.call(function(...) {
[16:09:32.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.872]             on.exit(options(oopts), add = TRUE)
[16:09:32.872]         }
[16:09:32.872]         {
[16:09:32.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.872]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.872]             })
[16:09:32.872]         }
[16:09:32.872]     }, args = future.call.arguments)
[16:09:32.872] }
[16:09:32.872] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.872] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.873] 
[16:09:32.873] getGlobalsAndPackages() ... DONE
[16:09:32.873] run() for ‘Future’ ...
[16:09:32.873] - state: ‘created’
[16:09:32.873] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.873] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.874] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.874]   - Field: ‘label’
[16:09:32.874]   - Field: ‘local’
[16:09:32.874]   - Field: ‘owner’
[16:09:32.874]   - Field: ‘envir’
[16:09:32.874]   - Field: ‘packages’
[16:09:32.874]   - Field: ‘gc’
[16:09:32.874]   - Field: ‘conditions’
[16:09:32.874]   - Field: ‘expr’
[16:09:32.874]   - Field: ‘uuid’
[16:09:32.874]   - Field: ‘seed’
[16:09:32.875]   - Field: ‘version’
[16:09:32.875]   - Field: ‘result’
[16:09:32.875]   - Field: ‘asynchronous’
[16:09:32.876]   - Field: ‘calls’
[16:09:32.876]   - Field: ‘globals’
[16:09:32.876]   - Field: ‘stdout’
[16:09:32.877]   - Field: ‘earlySignal’
[16:09:32.877]   - Field: ‘lazy’
[16:09:32.877]   - Field: ‘state’
[16:09:32.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.877] - Launch lazy future ...
[16:09:32.877] Packages needed by the future expression (n = 0): <none>
[16:09:32.877] Packages needed by future strategies (n = 0): <none>
[16:09:32.878] {
[16:09:32.878]     {
[16:09:32.878]         {
[16:09:32.878]             ...future.startTime <- base::Sys.time()
[16:09:32.878]             {
[16:09:32.878]                 {
[16:09:32.878]                   {
[16:09:32.878]                     base::local({
[16:09:32.878]                       has_future <- base::requireNamespace("future", 
[16:09:32.878]                         quietly = TRUE)
[16:09:32.878]                       if (has_future) {
[16:09:32.878]                         ns <- base::getNamespace("future")
[16:09:32.878]                         version <- ns[[".package"]][["version"]]
[16:09:32.878]                         if (is.null(version)) 
[16:09:32.878]                           version <- utils::packageVersion("future")
[16:09:32.878]                       }
[16:09:32.878]                       else {
[16:09:32.878]                         version <- NULL
[16:09:32.878]                       }
[16:09:32.878]                       if (!has_future || version < "1.8.0") {
[16:09:32.878]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.878]                           "", base::R.version$version.string), 
[16:09:32.878]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:32.878]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.878]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.878]                             "release", "version")], collapse = " "), 
[16:09:32.878]                           hostname = base::Sys.info()[["nodename"]])
[16:09:32.878]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.878]                           info)
[16:09:32.878]                         info <- base::paste(info, collapse = "; ")
[16:09:32.878]                         if (!has_future) {
[16:09:32.878]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.878]                             info)
[16:09:32.878]                         }
[16:09:32.878]                         else {
[16:09:32.878]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.878]                             info, version)
[16:09:32.878]                         }
[16:09:32.878]                         base::stop(msg)
[16:09:32.878]                       }
[16:09:32.878]                     })
[16:09:32.878]                   }
[16:09:32.878]                   options(future.plan = NULL)
[16:09:32.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.878]                 }
[16:09:32.878]                 ...future.workdir <- getwd()
[16:09:32.878]             }
[16:09:32.878]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.878]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.878]         }
[16:09:32.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.878]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[16:09:32.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.878]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.878]             base::names(...future.oldOptions))
[16:09:32.878]     }
[16:09:32.878]     if (FALSE) {
[16:09:32.878]     }
[16:09:32.878]     else {
[16:09:32.878]         if (TRUE) {
[16:09:32.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.878]                 open = "w")
[16:09:32.878]         }
[16:09:32.878]         else {
[16:09:32.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.878]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.878]         }
[16:09:32.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.878]             base::sink(type = "output", split = FALSE)
[16:09:32.878]             base::close(...future.stdout)
[16:09:32.878]         }, add = TRUE)
[16:09:32.878]     }
[16:09:32.878]     ...future.frame <- base::sys.nframe()
[16:09:32.878]     ...future.conditions <- base::list()
[16:09:32.878]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.878]     if (FALSE) {
[16:09:32.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.878]     }
[16:09:32.878]     ...future.result <- base::tryCatch({
[16:09:32.878]         base::withCallingHandlers({
[16:09:32.878]             ...future.value <- base::withVisible(base::local({
[16:09:32.878]                 do.call(function(...) {
[16:09:32.878]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.878]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.878]                     ...future.globals.maxSize)) {
[16:09:32.878]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.878]                     on.exit(options(oopts), add = TRUE)
[16:09:32.878]                   }
[16:09:32.878]                   {
[16:09:32.878]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.878]                       FUN = function(jj) {
[16:09:32.878]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.878]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.878]                       })
[16:09:32.878]                   }
[16:09:32.878]                 }, args = future.call.arguments)
[16:09:32.878]             }))
[16:09:32.878]             future::FutureResult(value = ...future.value$value, 
[16:09:32.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.878]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.878]                     ...future.globalenv.names))
[16:09:32.878]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.878]         }, condition = base::local({
[16:09:32.878]             c <- base::c
[16:09:32.878]             inherits <- base::inherits
[16:09:32.878]             invokeRestart <- base::invokeRestart
[16:09:32.878]             length <- base::length
[16:09:32.878]             list <- base::list
[16:09:32.878]             seq.int <- base::seq.int
[16:09:32.878]             signalCondition <- base::signalCondition
[16:09:32.878]             sys.calls <- base::sys.calls
[16:09:32.878]             `[[` <- base::`[[`
[16:09:32.878]             `+` <- base::`+`
[16:09:32.878]             `<<-` <- base::`<<-`
[16:09:32.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.878]                   3L)]
[16:09:32.878]             }
[16:09:32.878]             function(cond) {
[16:09:32.878]                 is_error <- inherits(cond, "error")
[16:09:32.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.878]                   NULL)
[16:09:32.878]                 if (is_error) {
[16:09:32.878]                   sessionInformation <- function() {
[16:09:32.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.878]                       search = base::search(), system = base::Sys.info())
[16:09:32.878]                   }
[16:09:32.878]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.878]                     cond$call), session = sessionInformation(), 
[16:09:32.878]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.878]                   signalCondition(cond)
[16:09:32.878]                 }
[16:09:32.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.878]                 "immediateCondition"))) {
[16:09:32.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.878]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.878]                   if (TRUE && !signal) {
[16:09:32.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.878]                     {
[16:09:32.878]                       inherits <- base::inherits
[16:09:32.878]                       invokeRestart <- base::invokeRestart
[16:09:32.878]                       is.null <- base::is.null
[16:09:32.878]                       muffled <- FALSE
[16:09:32.878]                       if (inherits(cond, "message")) {
[16:09:32.878]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.878]                         if (muffled) 
[16:09:32.878]                           invokeRestart("muffleMessage")
[16:09:32.878]                       }
[16:09:32.878]                       else if (inherits(cond, "warning")) {
[16:09:32.878]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.878]                         if (muffled) 
[16:09:32.878]                           invokeRestart("muffleWarning")
[16:09:32.878]                       }
[16:09:32.878]                       else if (inherits(cond, "condition")) {
[16:09:32.878]                         if (!is.null(pattern)) {
[16:09:32.878]                           computeRestarts <- base::computeRestarts
[16:09:32.878]                           grepl <- base::grepl
[16:09:32.878]                           restarts <- computeRestarts(cond)
[16:09:32.878]                           for (restart in restarts) {
[16:09:32.878]                             name <- restart$name
[16:09:32.878]                             if (is.null(name)) 
[16:09:32.878]                               next
[16:09:32.878]                             if (!grepl(pattern, name)) 
[16:09:32.878]                               next
[16:09:32.878]                             invokeRestart(restart)
[16:09:32.878]                             muffled <- TRUE
[16:09:32.878]                             break
[16:09:32.878]                           }
[16:09:32.878]                         }
[16:09:32.878]                       }
[16:09:32.878]                       invisible(muffled)
[16:09:32.878]                     }
[16:09:32.878]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.878]                   }
[16:09:32.878]                 }
[16:09:32.878]                 else {
[16:09:32.878]                   if (TRUE) {
[16:09:32.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.878]                     {
[16:09:32.878]                       inherits <- base::inherits
[16:09:32.878]                       invokeRestart <- base::invokeRestart
[16:09:32.878]                       is.null <- base::is.null
[16:09:32.878]                       muffled <- FALSE
[16:09:32.878]                       if (inherits(cond, "message")) {
[16:09:32.878]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.878]                         if (muffled) 
[16:09:32.878]                           invokeRestart("muffleMessage")
[16:09:32.878]                       }
[16:09:32.878]                       else if (inherits(cond, "warning")) {
[16:09:32.878]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.878]                         if (muffled) 
[16:09:32.878]                           invokeRestart("muffleWarning")
[16:09:32.878]                       }
[16:09:32.878]                       else if (inherits(cond, "condition")) {
[16:09:32.878]                         if (!is.null(pattern)) {
[16:09:32.878]                           computeRestarts <- base::computeRestarts
[16:09:32.878]                           grepl <- base::grepl
[16:09:32.878]                           restarts <- computeRestarts(cond)
[16:09:32.878]                           for (restart in restarts) {
[16:09:32.878]                             name <- restart$name
[16:09:32.878]                             if (is.null(name)) 
[16:09:32.878]                               next
[16:09:32.878]                             if (!grepl(pattern, name)) 
[16:09:32.878]                               next
[16:09:32.878]                             invokeRestart(restart)
[16:09:32.878]                             muffled <- TRUE
[16:09:32.878]                             break
[16:09:32.878]                           }
[16:09:32.878]                         }
[16:09:32.878]                       }
[16:09:32.878]                       invisible(muffled)
[16:09:32.878]                     }
[16:09:32.878]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.878]                   }
[16:09:32.878]                 }
[16:09:32.878]             }
[16:09:32.878]         }))
[16:09:32.878]     }, error = function(ex) {
[16:09:32.878]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.878]                 ...future.rng), started = ...future.startTime, 
[16:09:32.878]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.878]             version = "1.8"), class = "FutureResult")
[16:09:32.878]     }, finally = {
[16:09:32.878]         if (!identical(...future.workdir, getwd())) 
[16:09:32.878]             setwd(...future.workdir)
[16:09:32.878]         {
[16:09:32.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.878]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.878]             }
[16:09:32.878]             base::options(...future.oldOptions)
[16:09:32.878]             if (.Platform$OS.type == "windows") {
[16:09:32.878]                 old_names <- names(...future.oldEnvVars)
[16:09:32.878]                 envs <- base::Sys.getenv()
[16:09:32.878]                 names <- names(envs)
[16:09:32.878]                 common <- intersect(names, old_names)
[16:09:32.878]                 added <- setdiff(names, old_names)
[16:09:32.878]                 removed <- setdiff(old_names, names)
[16:09:32.878]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.878]                   envs[common]]
[16:09:32.878]                 NAMES <- toupper(changed)
[16:09:32.878]                 args <- list()
[16:09:32.878]                 for (kk in seq_along(NAMES)) {
[16:09:32.878]                   name <- changed[[kk]]
[16:09:32.878]                   NAME <- NAMES[[kk]]
[16:09:32.878]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.878]                     next
[16:09:32.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.878]                 }
[16:09:32.878]                 NAMES <- toupper(added)
[16:09:32.878]                 for (kk in seq_along(NAMES)) {
[16:09:32.878]                   name <- added[[kk]]
[16:09:32.878]                   NAME <- NAMES[[kk]]
[16:09:32.878]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.878]                     next
[16:09:32.878]                   args[[name]] <- ""
[16:09:32.878]                 }
[16:09:32.878]                 NAMES <- toupper(removed)
[16:09:32.878]                 for (kk in seq_along(NAMES)) {
[16:09:32.878]                   name <- removed[[kk]]
[16:09:32.878]                   NAME <- NAMES[[kk]]
[16:09:32.878]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.878]                     next
[16:09:32.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.878]                 }
[16:09:32.878]                 if (length(args) > 0) 
[16:09:32.878]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.878]             }
[16:09:32.878]             else {
[16:09:32.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.878]             }
[16:09:32.878]             {
[16:09:32.878]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.878]                   0L) {
[16:09:32.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.878]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.878]                   base::options(opts)
[16:09:32.878]                 }
[16:09:32.878]                 {
[16:09:32.878]                   {
[16:09:32.878]                     NULL
[16:09:32.878]                     RNGkind("Mersenne-Twister")
[16:09:32.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.878]                       inherits = FALSE)
[16:09:32.878]                   }
[16:09:32.878]                   options(future.plan = NULL)
[16:09:32.878]                   if (is.na(NA_character_)) 
[16:09:32.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.878]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.878]                   {
[16:09:32.878]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.878]                     if (!future$lazy) 
[16:09:32.878]                       future <- run(future)
[16:09:32.878]                     invisible(future)
[16:09:32.878]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.878]                 }
[16:09:32.878]             }
[16:09:32.878]         }
[16:09:32.878]     })
[16:09:32.878]     if (TRUE) {
[16:09:32.878]         base::sink(type = "output", split = FALSE)
[16:09:32.878]         if (TRUE) {
[16:09:32.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.878]         }
[16:09:32.878]         else {
[16:09:32.878]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.878]         }
[16:09:32.878]         base::close(...future.stdout)
[16:09:32.878]         ...future.stdout <- NULL
[16:09:32.878]     }
[16:09:32.878]     ...future.result$conditions <- ...future.conditions
[16:09:32.878]     ...future.result$finished <- base::Sys.time()
[16:09:32.878]     ...future.result
[16:09:32.878] }
[16:09:32.879] assign_globals() ...
[16:09:32.880] List of 5
[16:09:32.880]  $ ...future.FUN            :function (object, ...)  
[16:09:32.880]  $ future.call.arguments    :List of 1
[16:09:32.880]   ..$ digits: int 2
[16:09:32.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.880]  $ ...future.elements_ii    :List of 6
[16:09:32.880]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:09:32.880]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:09:32.880]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:09:32.880]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:09:32.880]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:09:32.880]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:09:32.880]  $ ...future.seeds_ii       : NULL
[16:09:32.880]  $ ...future.globals.maxSize: NULL
[16:09:32.880]  - attr(*, "resolved")= logi FALSE
[16:09:32.880]  - attr(*, "total_size")= num 1296
[16:09:32.880]  - attr(*, "where")=List of 5
[16:09:32.880]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.880]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.880]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.880]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.880]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.880]  - attr(*, "already-done")= logi TRUE
[16:09:32.886] - copied ‘...future.FUN’ to environment
[16:09:32.886] - copied ‘future.call.arguments’ to environment
[16:09:32.886] - copied ‘...future.elements_ii’ to environment
[16:09:32.887] - copied ‘...future.seeds_ii’ to environment
[16:09:32.887] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.887] assign_globals() ... done
[16:09:32.887] plan(): Setting new future strategy stack:
[16:09:32.887] List of future strategies:
[16:09:32.887] 1. sequential:
[16:09:32.887]    - args: function (..., envir = parent.frame())
[16:09:32.887]    - tweaked: FALSE
[16:09:32.887]    - call: NULL
[16:09:32.887] plan(): nbrOfWorkers() = 1
[16:09:32.889] plan(): Setting new future strategy stack:
[16:09:32.889] List of future strategies:
[16:09:32.889] 1. sequential:
[16:09:32.889]    - args: function (..., envir = parent.frame())
[16:09:32.889]    - tweaked: FALSE
[16:09:32.889]    - call: plan(strategy)
[16:09:32.889] plan(): nbrOfWorkers() = 1
[16:09:32.889] SequentialFuture started (and completed)
[16:09:32.890] - Launch lazy future ... done
[16:09:32.890] run() for ‘SequentialFuture’ ... done
[16:09:32.890] Created future:
[16:09:32.890] SequentialFuture:
[16:09:32.890] Label: ‘future_by-1’
[16:09:32.890] Expression:
[16:09:32.890] {
[16:09:32.890]     do.call(function(...) {
[16:09:32.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.890]             on.exit(options(oopts), add = TRUE)
[16:09:32.890]         }
[16:09:32.890]         {
[16:09:32.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.890]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.890]             })
[16:09:32.890]         }
[16:09:32.890]     }, args = future.call.arguments)
[16:09:32.890] }
[16:09:32.890] Lazy evaluation: FALSE
[16:09:32.890] Asynchronous evaluation: FALSE
[16:09:32.890] Local evaluation: TRUE
[16:09:32.890] Environment: R_GlobalEnv
[16:09:32.890] Capture standard output: TRUE
[16:09:32.890] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.890] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.890] Packages: <none>
[16:09:32.890] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.890] Resolved: TRUE
[16:09:32.890] Value: 5.48 KiB of class ‘list’
[16:09:32.890] Early signaling: FALSE
[16:09:32.890] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.890] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.891] Chunk #1 of 1 ... DONE
[16:09:32.891] Launching 1 futures (chunks) ... DONE
[16:09:32.891] Resolving 1 futures (chunks) ...
[16:09:32.891] resolve() on list ...
[16:09:32.891]  recursive: 0
[16:09:32.891]  length: 1
[16:09:32.891] 
[16:09:32.892] resolved() for ‘SequentialFuture’ ...
[16:09:32.892] - state: ‘finished’
[16:09:32.892] - run: TRUE
[16:09:32.892] - result: ‘FutureResult’
[16:09:32.892] resolved() for ‘SequentialFuture’ ... done
[16:09:32.892] Future #1
[16:09:32.892] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.892] - nx: 1
[16:09:32.892] - relay: TRUE
[16:09:32.892] - stdout: TRUE
[16:09:32.893] - signal: TRUE
[16:09:32.893] - resignal: FALSE
[16:09:32.893] - force: TRUE
[16:09:32.893] - relayed: [n=1] FALSE
[16:09:32.893] - queued futures: [n=1] FALSE
[16:09:32.893]  - until=1
[16:09:32.893]  - relaying element #1
[16:09:32.893] - relayed: [n=1] TRUE
[16:09:32.893] - queued futures: [n=1] TRUE
[16:09:32.893] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.894]  length: 0 (resolved future 1)
[16:09:32.894] Relaying remaining futures
[16:09:32.894] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.894] - nx: 1
[16:09:32.894] - relay: TRUE
[16:09:32.894] - stdout: TRUE
[16:09:32.894] - signal: TRUE
[16:09:32.894] - resignal: FALSE
[16:09:32.894] - force: TRUE
[16:09:32.894] - relayed: [n=1] TRUE
[16:09:32.894] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.895] - relayed: [n=1] TRUE
[16:09:32.895] - queued futures: [n=1] TRUE
[16:09:32.895] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.895] resolve() on list ... DONE
[16:09:32.895]  - Number of value chunks collected: 1
[16:09:32.895] Resolving 1 futures (chunks) ... DONE
[16:09:32.895] Reducing values from 1 chunks ...
[16:09:32.895]  - Number of values collected after concatenation: 6
[16:09:32.895]  - Number of values expected: 6
[16:09:32.895] Reducing values from 1 chunks ... DONE
[16:09:32.895] future_lapply() ... DONE
[16:09:32.896] future_by_internal() ... DONE
[16:09:32.898] future_by_internal() ...
[16:09:32.899] future_lapply() ...
[16:09:32.900] Number of chunks: 1
[16:09:32.900] getGlobalsAndPackagesXApply() ...
[16:09:32.900]  - future.globals: TRUE
[16:09:32.900] getGlobalsAndPackages() ...
[16:09:32.900] Searching for globals...
[16:09:32.902] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.902] Searching for globals ... DONE
[16:09:32.902] Resolving globals: FALSE
[16:09:32.902] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:09:32.903] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:09:32.903] - globals: [1] ‘FUN’
[16:09:32.903] - packages: [1] ‘stats’
[16:09:32.903] getGlobalsAndPackages() ... DONE
[16:09:32.903]  - globals found/used: [n=1] ‘FUN’
[16:09:32.903]  - needed namespaces: [n=1] ‘stats’
[16:09:32.903] Finding globals ... DONE
[16:09:32.903]  - use_args: TRUE
[16:09:32.903]  - Getting '...' globals ...
[16:09:32.904] resolve() on list ...
[16:09:32.904]  recursive: 0
[16:09:32.904]  length: 1
[16:09:32.904]  elements: ‘...’
[16:09:32.904]  length: 0 (resolved future 1)
[16:09:32.904] resolve() on list ... DONE
[16:09:32.904]    - '...' content: [n=1] ‘singular.ok’
[16:09:32.904] List of 1
[16:09:32.904]  $ ...:List of 1
[16:09:32.904]   ..$ singular.ok: logi FALSE
[16:09:32.904]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.904]  - attr(*, "where")=List of 1
[16:09:32.904]   ..$ ...:<environment: 0x5567e93ccba8> 
[16:09:32.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.904]  - attr(*, "resolved")= logi TRUE
[16:09:32.904]  - attr(*, "total_size")= num NA
[16:09:32.907]  - Getting '...' globals ... DONE
[16:09:32.908] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:32.908] List of 2
[16:09:32.908]  $ ...future.FUN:function (x, ...)  
[16:09:32.908]  $ ...          :List of 1
[16:09:32.908]   ..$ singular.ok: logi FALSE
[16:09:32.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.908]  - attr(*, "where")=List of 2
[16:09:32.908]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.908]   ..$ ...          :<environment: 0x5567e93ccba8> 
[16:09:32.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.908]  - attr(*, "resolved")= logi FALSE
[16:09:32.908]  - attr(*, "total_size")= num 5384
[16:09:32.911] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.911] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.911] Number of futures (= number of chunks): 1
[16:09:32.911] Launching 1 futures (chunks) ...
[16:09:32.911] Chunk #1 of 1 ...
[16:09:32.911]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.911] getGlobalsAndPackages() ...
[16:09:32.912] Searching for globals...
[16:09:32.912] 
[16:09:32.912] Searching for globals ... DONE
[16:09:32.912] - globals: [0] <none>
[16:09:32.912] getGlobalsAndPackages() ... DONE
[16:09:32.912]    + additional globals found: [n=0] 
[16:09:32.912]    + additional namespaces needed: [n=0] 
[16:09:32.913]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.913]  - seeds: <none>
[16:09:32.913] getGlobalsAndPackages() ...
[16:09:32.913] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.913] Resolving globals: FALSE
[16:09:32.913] Tweak future expression to call with '...' arguments ...
[16:09:32.913] {
[16:09:32.913]     do.call(function(...) {
[16:09:32.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.913]             on.exit(options(oopts), add = TRUE)
[16:09:32.913]         }
[16:09:32.913]         {
[16:09:32.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.913]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.913]             })
[16:09:32.913]         }
[16:09:32.913]     }, args = future.call.arguments)
[16:09:32.913] }
[16:09:32.914] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.914] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.914] 
[16:09:32.914] getGlobalsAndPackages() ... DONE
[16:09:32.914] run() for ‘Future’ ...
[16:09:32.914] - state: ‘created’
[16:09:32.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.915] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.915]   - Field: ‘label’
[16:09:32.915]   - Field: ‘local’
[16:09:32.915]   - Field: ‘owner’
[16:09:32.915]   - Field: ‘envir’
[16:09:32.915]   - Field: ‘packages’
[16:09:32.916]   - Field: ‘gc’
[16:09:32.916]   - Field: ‘conditions’
[16:09:32.916]   - Field: ‘expr’
[16:09:32.916]   - Field: ‘uuid’
[16:09:32.916]   - Field: ‘seed’
[16:09:32.916]   - Field: ‘version’
[16:09:32.916]   - Field: ‘result’
[16:09:32.916]   - Field: ‘asynchronous’
[16:09:32.916]   - Field: ‘calls’
[16:09:32.916]   - Field: ‘globals’
[16:09:32.916]   - Field: ‘stdout’
[16:09:32.917]   - Field: ‘earlySignal’
[16:09:32.918]   - Field: ‘lazy’
[16:09:32.918]   - Field: ‘state’
[16:09:32.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.918] - Launch lazy future ...
[16:09:32.919] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.919] Packages needed by future strategies (n = 0): <none>
[16:09:32.919] {
[16:09:32.919]     {
[16:09:32.919]         {
[16:09:32.919]             ...future.startTime <- base::Sys.time()
[16:09:32.919]             {
[16:09:32.919]                 {
[16:09:32.919]                   {
[16:09:32.919]                     {
[16:09:32.919]                       base::local({
[16:09:32.919]                         has_future <- base::requireNamespace("future", 
[16:09:32.919]                           quietly = TRUE)
[16:09:32.919]                         if (has_future) {
[16:09:32.919]                           ns <- base::getNamespace("future")
[16:09:32.919]                           version <- ns[[".package"]][["version"]]
[16:09:32.919]                           if (is.null(version)) 
[16:09:32.919]                             version <- utils::packageVersion("future")
[16:09:32.919]                         }
[16:09:32.919]                         else {
[16:09:32.919]                           version <- NULL
[16:09:32.919]                         }
[16:09:32.919]                         if (!has_future || version < "1.8.0") {
[16:09:32.919]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.919]                             "", base::R.version$version.string), 
[16:09:32.919]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.919]                               "release", "version")], collapse = " "), 
[16:09:32.919]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.919]                             info)
[16:09:32.919]                           info <- base::paste(info, collapse = "; ")
[16:09:32.919]                           if (!has_future) {
[16:09:32.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.919]                               info)
[16:09:32.919]                           }
[16:09:32.919]                           else {
[16:09:32.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.919]                               info, version)
[16:09:32.919]                           }
[16:09:32.919]                           base::stop(msg)
[16:09:32.919]                         }
[16:09:32.919]                       })
[16:09:32.919]                     }
[16:09:32.919]                     base::local({
[16:09:32.919]                       for (pkg in "stats") {
[16:09:32.919]                         base::loadNamespace(pkg)
[16:09:32.919]                         base::library(pkg, character.only = TRUE)
[16:09:32.919]                       }
[16:09:32.919]                     })
[16:09:32.919]                   }
[16:09:32.919]                   options(future.plan = NULL)
[16:09:32.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.919]                 }
[16:09:32.919]                 ...future.workdir <- getwd()
[16:09:32.919]             }
[16:09:32.919]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.919]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.919]         }
[16:09:32.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.919]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.919]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.919]             base::names(...future.oldOptions))
[16:09:32.919]     }
[16:09:32.919]     if (FALSE) {
[16:09:32.919]     }
[16:09:32.919]     else {
[16:09:32.919]         if (TRUE) {
[16:09:32.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.919]                 open = "w")
[16:09:32.919]         }
[16:09:32.919]         else {
[16:09:32.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.919]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.919]         }
[16:09:32.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.919]             base::sink(type = "output", split = FALSE)
[16:09:32.919]             base::close(...future.stdout)
[16:09:32.919]         }, add = TRUE)
[16:09:32.919]     }
[16:09:32.919]     ...future.frame <- base::sys.nframe()
[16:09:32.919]     ...future.conditions <- base::list()
[16:09:32.919]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.919]     if (FALSE) {
[16:09:32.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.919]     }
[16:09:32.919]     ...future.result <- base::tryCatch({
[16:09:32.919]         base::withCallingHandlers({
[16:09:32.919]             ...future.value <- base::withVisible(base::local({
[16:09:32.919]                 do.call(function(...) {
[16:09:32.919]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.919]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.919]                     ...future.globals.maxSize)) {
[16:09:32.919]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.919]                     on.exit(options(oopts), add = TRUE)
[16:09:32.919]                   }
[16:09:32.919]                   {
[16:09:32.919]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.919]                       FUN = function(jj) {
[16:09:32.919]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.919]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.919]                       })
[16:09:32.919]                   }
[16:09:32.919]                 }, args = future.call.arguments)
[16:09:32.919]             }))
[16:09:32.919]             future::FutureResult(value = ...future.value$value, 
[16:09:32.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.919]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.919]                     ...future.globalenv.names))
[16:09:32.919]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.919]         }, condition = base::local({
[16:09:32.919]             c <- base::c
[16:09:32.919]             inherits <- base::inherits
[16:09:32.919]             invokeRestart <- base::invokeRestart
[16:09:32.919]             length <- base::length
[16:09:32.919]             list <- base::list
[16:09:32.919]             seq.int <- base::seq.int
[16:09:32.919]             signalCondition <- base::signalCondition
[16:09:32.919]             sys.calls <- base::sys.calls
[16:09:32.919]             `[[` <- base::`[[`
[16:09:32.919]             `+` <- base::`+`
[16:09:32.919]             `<<-` <- base::`<<-`
[16:09:32.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.919]                   3L)]
[16:09:32.919]             }
[16:09:32.919]             function(cond) {
[16:09:32.919]                 is_error <- inherits(cond, "error")
[16:09:32.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.919]                   NULL)
[16:09:32.919]                 if (is_error) {
[16:09:32.919]                   sessionInformation <- function() {
[16:09:32.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.919]                       search = base::search(), system = base::Sys.info())
[16:09:32.919]                   }
[16:09:32.919]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.919]                     cond$call), session = sessionInformation(), 
[16:09:32.919]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.919]                   signalCondition(cond)
[16:09:32.919]                 }
[16:09:32.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.919]                 "immediateCondition"))) {
[16:09:32.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.919]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.919]                   if (TRUE && !signal) {
[16:09:32.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.919]                     {
[16:09:32.919]                       inherits <- base::inherits
[16:09:32.919]                       invokeRestart <- base::invokeRestart
[16:09:32.919]                       is.null <- base::is.null
[16:09:32.919]                       muffled <- FALSE
[16:09:32.919]                       if (inherits(cond, "message")) {
[16:09:32.919]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.919]                         if (muffled) 
[16:09:32.919]                           invokeRestart("muffleMessage")
[16:09:32.919]                       }
[16:09:32.919]                       else if (inherits(cond, "warning")) {
[16:09:32.919]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.919]                         if (muffled) 
[16:09:32.919]                           invokeRestart("muffleWarning")
[16:09:32.919]                       }
[16:09:32.919]                       else if (inherits(cond, "condition")) {
[16:09:32.919]                         if (!is.null(pattern)) {
[16:09:32.919]                           computeRestarts <- base::computeRestarts
[16:09:32.919]                           grepl <- base::grepl
[16:09:32.919]                           restarts <- computeRestarts(cond)
[16:09:32.919]                           for (restart in restarts) {
[16:09:32.919]                             name <- restart$name
[16:09:32.919]                             if (is.null(name)) 
[16:09:32.919]                               next
[16:09:32.919]                             if (!grepl(pattern, name)) 
[16:09:32.919]                               next
[16:09:32.919]                             invokeRestart(restart)
[16:09:32.919]                             muffled <- TRUE
[16:09:32.919]                             break
[16:09:32.919]                           }
[16:09:32.919]                         }
[16:09:32.919]                       }
[16:09:32.919]                       invisible(muffled)
[16:09:32.919]                     }
[16:09:32.919]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.919]                   }
[16:09:32.919]                 }
[16:09:32.919]                 else {
[16:09:32.919]                   if (TRUE) {
[16:09:32.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.919]                     {
[16:09:32.919]                       inherits <- base::inherits
[16:09:32.919]                       invokeRestart <- base::invokeRestart
[16:09:32.919]                       is.null <- base::is.null
[16:09:32.919]                       muffled <- FALSE
[16:09:32.919]                       if (inherits(cond, "message")) {
[16:09:32.919]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.919]                         if (muffled) 
[16:09:32.919]                           invokeRestart("muffleMessage")
[16:09:32.919]                       }
[16:09:32.919]                       else if (inherits(cond, "warning")) {
[16:09:32.919]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.919]                         if (muffled) 
[16:09:32.919]                           invokeRestart("muffleWarning")
[16:09:32.919]                       }
[16:09:32.919]                       else if (inherits(cond, "condition")) {
[16:09:32.919]                         if (!is.null(pattern)) {
[16:09:32.919]                           computeRestarts <- base::computeRestarts
[16:09:32.919]                           grepl <- base::grepl
[16:09:32.919]                           restarts <- computeRestarts(cond)
[16:09:32.919]                           for (restart in restarts) {
[16:09:32.919]                             name <- restart$name
[16:09:32.919]                             if (is.null(name)) 
[16:09:32.919]                               next
[16:09:32.919]                             if (!grepl(pattern, name)) 
[16:09:32.919]                               next
[16:09:32.919]                             invokeRestart(restart)
[16:09:32.919]                             muffled <- TRUE
[16:09:32.919]                             break
[16:09:32.919]                           }
[16:09:32.919]                         }
[16:09:32.919]                       }
[16:09:32.919]                       invisible(muffled)
[16:09:32.919]                     }
[16:09:32.919]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.919]                   }
[16:09:32.919]                 }
[16:09:32.919]             }
[16:09:32.919]         }))
[16:09:32.919]     }, error = function(ex) {
[16:09:32.919]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.919]                 ...future.rng), started = ...future.startTime, 
[16:09:32.919]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.919]             version = "1.8"), class = "FutureResult")
[16:09:32.919]     }, finally = {
[16:09:32.919]         if (!identical(...future.workdir, getwd())) 
[16:09:32.919]             setwd(...future.workdir)
[16:09:32.919]         {
[16:09:32.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.919]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.919]             }
[16:09:32.919]             base::options(...future.oldOptions)
[16:09:32.919]             if (.Platform$OS.type == "windows") {
[16:09:32.919]                 old_names <- names(...future.oldEnvVars)
[16:09:32.919]                 envs <- base::Sys.getenv()
[16:09:32.919]                 names <- names(envs)
[16:09:32.919]                 common <- intersect(names, old_names)
[16:09:32.919]                 added <- setdiff(names, old_names)
[16:09:32.919]                 removed <- setdiff(old_names, names)
[16:09:32.919]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.919]                   envs[common]]
[16:09:32.919]                 NAMES <- toupper(changed)
[16:09:32.919]                 args <- list()
[16:09:32.919]                 for (kk in seq_along(NAMES)) {
[16:09:32.919]                   name <- changed[[kk]]
[16:09:32.919]                   NAME <- NAMES[[kk]]
[16:09:32.919]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.919]                     next
[16:09:32.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.919]                 }
[16:09:32.919]                 NAMES <- toupper(added)
[16:09:32.919]                 for (kk in seq_along(NAMES)) {
[16:09:32.919]                   name <- added[[kk]]
[16:09:32.919]                   NAME <- NAMES[[kk]]
[16:09:32.919]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.919]                     next
[16:09:32.919]                   args[[name]] <- ""
[16:09:32.919]                 }
[16:09:32.919]                 NAMES <- toupper(removed)
[16:09:32.919]                 for (kk in seq_along(NAMES)) {
[16:09:32.919]                   name <- removed[[kk]]
[16:09:32.919]                   NAME <- NAMES[[kk]]
[16:09:32.919]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.919]                     next
[16:09:32.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.919]                 }
[16:09:32.919]                 if (length(args) > 0) 
[16:09:32.919]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.919]             }
[16:09:32.919]             else {
[16:09:32.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.919]             }
[16:09:32.919]             {
[16:09:32.919]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.919]                   0L) {
[16:09:32.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.919]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.919]                   base::options(opts)
[16:09:32.919]                 }
[16:09:32.919]                 {
[16:09:32.919]                   {
[16:09:32.919]                     NULL
[16:09:32.919]                     RNGkind("Mersenne-Twister")
[16:09:32.919]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.919]                       inherits = FALSE)
[16:09:32.919]                   }
[16:09:32.919]                   options(future.plan = NULL)
[16:09:32.919]                   if (is.na(NA_character_)) 
[16:09:32.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.919]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.919]                   {
[16:09:32.919]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.919]                     if (!future$lazy) 
[16:09:32.919]                       future <- run(future)
[16:09:32.919]                     invisible(future)
[16:09:32.919]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.919]                 }
[16:09:32.919]             }
[16:09:32.919]         }
[16:09:32.919]     })
[16:09:32.919]     if (TRUE) {
[16:09:32.919]         base::sink(type = "output", split = FALSE)
[16:09:32.919]         if (TRUE) {
[16:09:32.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.919]         }
[16:09:32.919]         else {
[16:09:32.919]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.919]         }
[16:09:32.919]         base::close(...future.stdout)
[16:09:32.919]         ...future.stdout <- NULL
[16:09:32.919]     }
[16:09:32.919]     ...future.result$conditions <- ...future.conditions
[16:09:32.919]     ...future.result$finished <- base::Sys.time()
[16:09:32.919]     ...future.result
[16:09:32.919] }
[16:09:32.921] assign_globals() ...
[16:09:32.921] List of 5
[16:09:32.921]  $ ...future.FUN            :function (x, ...)  
[16:09:32.921]  $ future.call.arguments    :List of 1
[16:09:32.921]   ..$ singular.ok: logi FALSE
[16:09:32.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.921]  $ ...future.elements_ii    :List of 3
[16:09:32.921]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.921]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.921]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.921]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.921]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.921]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.921]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.921]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.921]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.921]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.921]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.921]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.921]  $ ...future.seeds_ii       : NULL
[16:09:32.921]  $ ...future.globals.maxSize: NULL
[16:09:32.921]  - attr(*, "resolved")= logi FALSE
[16:09:32.921]  - attr(*, "total_size")= num 5384
[16:09:32.921]  - attr(*, "where")=List of 5
[16:09:32.921]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.921]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.921]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.921]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.921]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.921]  - attr(*, "already-done")= logi TRUE
[16:09:32.930] - reassign environment for ‘...future.FUN’
[16:09:32.930] - copied ‘...future.FUN’ to environment
[16:09:32.930] - copied ‘future.call.arguments’ to environment
[16:09:32.931] - copied ‘...future.elements_ii’ to environment
[16:09:32.931] - copied ‘...future.seeds_ii’ to environment
[16:09:32.931] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.931] assign_globals() ... done
[16:09:32.931] plan(): Setting new future strategy stack:
[16:09:32.931] List of future strategies:
[16:09:32.931] 1. sequential:
[16:09:32.931]    - args: function (..., envir = parent.frame())
[16:09:32.931]    - tweaked: FALSE
[16:09:32.931]    - call: NULL
[16:09:32.932] plan(): nbrOfWorkers() = 1
[16:09:32.934] plan(): Setting new future strategy stack:
[16:09:32.935] List of future strategies:
[16:09:32.935] 1. sequential:
[16:09:32.935]    - args: function (..., envir = parent.frame())
[16:09:32.935]    - tweaked: FALSE
[16:09:32.935]    - call: plan(strategy)
[16:09:32.935] plan(): nbrOfWorkers() = 1
[16:09:32.935] SequentialFuture started (and completed)
[16:09:32.935] - Launch lazy future ... done
[16:09:32.935] run() for ‘SequentialFuture’ ... done
[16:09:32.935] Created future:
[16:09:32.936] SequentialFuture:
[16:09:32.936] Label: ‘future_by-1’
[16:09:32.936] Expression:
[16:09:32.936] {
[16:09:32.936]     do.call(function(...) {
[16:09:32.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.936]             on.exit(options(oopts), add = TRUE)
[16:09:32.936]         }
[16:09:32.936]         {
[16:09:32.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.936]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.936]             })
[16:09:32.936]         }
[16:09:32.936]     }, args = future.call.arguments)
[16:09:32.936] }
[16:09:32.936] Lazy evaluation: FALSE
[16:09:32.936] Asynchronous evaluation: FALSE
[16:09:32.936] Local evaluation: TRUE
[16:09:32.936] Environment: R_GlobalEnv
[16:09:32.936] Capture standard output: TRUE
[16:09:32.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.936] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:32.936] Packages: 1 packages (‘stats’)
[16:09:32.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.936] Resolved: TRUE
[16:09:32.936] Value: 26.06 KiB of class ‘list’
[16:09:32.936] Early signaling: FALSE
[16:09:32.936] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.936] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.937] Chunk #1 of 1 ... DONE
[16:09:32.937] Launching 1 futures (chunks) ... DONE
[16:09:32.937] Resolving 1 futures (chunks) ...
[16:09:32.937] resolve() on list ...
[16:09:32.937]  recursive: 0
[16:09:32.938]  length: 1
[16:09:32.938] 
[16:09:32.938] resolved() for ‘SequentialFuture’ ...
[16:09:32.938] - state: ‘finished’
[16:09:32.938] - run: TRUE
[16:09:32.938] - result: ‘FutureResult’
[16:09:32.938] resolved() for ‘SequentialFuture’ ... done
[16:09:32.938] Future #1
[16:09:32.938] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.940] - nx: 1
[16:09:32.940] - relay: TRUE
[16:09:32.940] - stdout: TRUE
[16:09:32.940] - signal: TRUE
[16:09:32.940] - resignal: FALSE
[16:09:32.940] - force: TRUE
[16:09:32.940] - relayed: [n=1] FALSE
[16:09:32.940] - queued futures: [n=1] FALSE
[16:09:32.941]  - until=1
[16:09:32.941]  - relaying element #1
[16:09:32.941] - relayed: [n=1] TRUE
[16:09:32.941] - queued futures: [n=1] TRUE
[16:09:32.941] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.941]  length: 0 (resolved future 1)
[16:09:32.941] Relaying remaining futures
[16:09:32.941] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.941] - nx: 1
[16:09:32.941] - relay: TRUE
[16:09:32.942] - stdout: TRUE
[16:09:32.942] - signal: TRUE
[16:09:32.942] - resignal: FALSE
[16:09:32.942] - force: TRUE
[16:09:32.942] - relayed: [n=1] TRUE
[16:09:32.942] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.942] - relayed: [n=1] TRUE
[16:09:32.942] - queued futures: [n=1] TRUE
[16:09:32.942] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.942] resolve() on list ... DONE
[16:09:32.943]  - Number of value chunks collected: 1
[16:09:32.943] Resolving 1 futures (chunks) ... DONE
[16:09:32.943] Reducing values from 1 chunks ...
[16:09:32.943]  - Number of values collected after concatenation: 3
[16:09:32.943]  - Number of values expected: 3
[16:09:32.943] Reducing values from 1 chunks ... DONE
[16:09:32.943] future_lapply() ... DONE
[16:09:32.943] future_by_internal() ... DONE
[16:09:32.947] future_by_internal() ...
[16:09:32.947] future_lapply() ...
[16:09:32.948] Number of chunks: 1
[16:09:32.948] getGlobalsAndPackagesXApply() ...
[16:09:32.948]  - future.globals: TRUE
[16:09:32.949] getGlobalsAndPackages() ...
[16:09:32.949] Searching for globals...
[16:09:32.950] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:32.950] Searching for globals ... DONE
[16:09:32.950] Resolving globals: FALSE
[16:09:32.951] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:09:32.951] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:09:32.951] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.951] - packages: [1] ‘stats’
[16:09:32.952] getGlobalsAndPackages() ... DONE
[16:09:32.952]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:32.952]  - needed namespaces: [n=1] ‘stats’
[16:09:32.952] Finding globals ... DONE
[16:09:32.952]  - use_args: TRUE
[16:09:32.952]  - Getting '...' globals ...
[16:09:32.952] resolve() on list ...
[16:09:32.952]  recursive: 0
[16:09:32.953]  length: 1
[16:09:32.953]  elements: ‘...’
[16:09:32.953]  length: 0 (resolved future 1)
[16:09:32.953] resolve() on list ... DONE
[16:09:32.953]    - '...' content: [n=0] 
[16:09:32.953] List of 1
[16:09:32.953]  $ ...: list()
[16:09:32.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.953]  - attr(*, "where")=List of 1
[16:09:32.953]   ..$ ...:<environment: 0x5567e731b2d8> 
[16:09:32.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.953]  - attr(*, "resolved")= logi TRUE
[16:09:32.953]  - attr(*, "total_size")= num NA
[16:09:32.955]  - Getting '...' globals ... DONE
[16:09:32.956] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:09:32.956] List of 4
[16:09:32.956]  $ ...future.FUN:function (x)  
[16:09:32.956]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.956]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.956]  $ ...          : list()
[16:09:32.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.956]  - attr(*, "where")=List of 4
[16:09:32.956]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:32.956]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:09:32.956]   ..$ wool         :<environment: R_EmptyEnv> 
[16:09:32.956]   ..$ ...          :<environment: 0x5567e731b2d8> 
[16:09:32.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.956]  - attr(*, "resolved")= logi FALSE
[16:09:32.956]  - attr(*, "total_size")= num 2320
[16:09:32.961] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:32.961] getGlobalsAndPackagesXApply() ... DONE
[16:09:32.961] Number of futures (= number of chunks): 1
[16:09:32.961] Launching 1 futures (chunks) ...
[16:09:32.961] Chunk #1 of 1 ...
[16:09:32.961]  - Finding globals in 'X' for chunk #1 ...
[16:09:32.961] getGlobalsAndPackages() ...
[16:09:32.962] Searching for globals...
[16:09:32.962] 
[16:09:32.962] Searching for globals ... DONE
[16:09:32.962] - globals: [0] <none>
[16:09:32.962] getGlobalsAndPackages() ... DONE
[16:09:32.962]    + additional globals found: [n=0] 
[16:09:32.962]    + additional namespaces needed: [n=0] 
[16:09:32.963]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:32.963]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:32.963]  - seeds: <none>
[16:09:32.963] getGlobalsAndPackages() ...
[16:09:32.963] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.963] Resolving globals: FALSE
[16:09:32.963] Tweak future expression to call with '...' arguments ...
[16:09:32.963] {
[16:09:32.963]     do.call(function(...) {
[16:09:32.963]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.963]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.963]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.963]             on.exit(options(oopts), add = TRUE)
[16:09:32.963]         }
[16:09:32.963]         {
[16:09:32.963]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.963]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.963]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.963]             })
[16:09:32.963]         }
[16:09:32.963]     }, args = future.call.arguments)
[16:09:32.963] }
[16:09:32.963] Tweak future expression to call with '...' arguments ... DONE
[16:09:32.964] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:32.964] 
[16:09:32.964] getGlobalsAndPackages() ... DONE
[16:09:32.964] run() for ‘Future’ ...
[16:09:32.964] - state: ‘created’
[16:09:32.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:32.965] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:32.965]   - Field: ‘label’
[16:09:32.965]   - Field: ‘local’
[16:09:32.965]   - Field: ‘owner’
[16:09:32.965]   - Field: ‘envir’
[16:09:32.965]   - Field: ‘packages’
[16:09:32.966]   - Field: ‘gc’
[16:09:32.966]   - Field: ‘conditions’
[16:09:32.966]   - Field: ‘expr’
[16:09:32.966]   - Field: ‘uuid’
[16:09:32.966]   - Field: ‘seed’
[16:09:32.966]   - Field: ‘version’
[16:09:32.966]   - Field: ‘result’
[16:09:32.966]   - Field: ‘asynchronous’
[16:09:32.966]   - Field: ‘calls’
[16:09:32.966]   - Field: ‘globals’
[16:09:32.966]   - Field: ‘stdout’
[16:09:32.966]   - Field: ‘earlySignal’
[16:09:32.967]   - Field: ‘lazy’
[16:09:32.967]   - Field: ‘state’
[16:09:32.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:32.967] - Launch lazy future ...
[16:09:32.967] Packages needed by the future expression (n = 1): ‘stats’
[16:09:32.967] Packages needed by future strategies (n = 0): <none>
[16:09:32.968] {
[16:09:32.968]     {
[16:09:32.968]         {
[16:09:32.968]             ...future.startTime <- base::Sys.time()
[16:09:32.968]             {
[16:09:32.968]                 {
[16:09:32.968]                   {
[16:09:32.968]                     {
[16:09:32.968]                       base::local({
[16:09:32.968]                         has_future <- base::requireNamespace("future", 
[16:09:32.968]                           quietly = TRUE)
[16:09:32.968]                         if (has_future) {
[16:09:32.968]                           ns <- base::getNamespace("future")
[16:09:32.968]                           version <- ns[[".package"]][["version"]]
[16:09:32.968]                           if (is.null(version)) 
[16:09:32.968]                             version <- utils::packageVersion("future")
[16:09:32.968]                         }
[16:09:32.968]                         else {
[16:09:32.968]                           version <- NULL
[16:09:32.968]                         }
[16:09:32.968]                         if (!has_future || version < "1.8.0") {
[16:09:32.968]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:32.968]                             "", base::R.version$version.string), 
[16:09:32.968]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:32.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:32.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:32.968]                               "release", "version")], collapse = " "), 
[16:09:32.968]                             hostname = base::Sys.info()[["nodename"]])
[16:09:32.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:32.968]                             info)
[16:09:32.968]                           info <- base::paste(info, collapse = "; ")
[16:09:32.968]                           if (!has_future) {
[16:09:32.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:32.968]                               info)
[16:09:32.968]                           }
[16:09:32.968]                           else {
[16:09:32.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:32.968]                               info, version)
[16:09:32.968]                           }
[16:09:32.968]                           base::stop(msg)
[16:09:32.968]                         }
[16:09:32.968]                       })
[16:09:32.968]                     }
[16:09:32.968]                     base::local({
[16:09:32.968]                       for (pkg in "stats") {
[16:09:32.968]                         base::loadNamespace(pkg)
[16:09:32.968]                         base::library(pkg, character.only = TRUE)
[16:09:32.968]                       }
[16:09:32.968]                     })
[16:09:32.968]                   }
[16:09:32.968]                   options(future.plan = NULL)
[16:09:32.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:32.968]                 }
[16:09:32.968]                 ...future.workdir <- getwd()
[16:09:32.968]             }
[16:09:32.968]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:32.968]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:32.968]         }
[16:09:32.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:32.968]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:32.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:32.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:32.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:32.968]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:32.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:32.968]             base::names(...future.oldOptions))
[16:09:32.968]     }
[16:09:32.968]     if (FALSE) {
[16:09:32.968]     }
[16:09:32.968]     else {
[16:09:32.968]         if (TRUE) {
[16:09:32.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:32.968]                 open = "w")
[16:09:32.968]         }
[16:09:32.968]         else {
[16:09:32.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:32.968]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:32.968]         }
[16:09:32.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:32.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:32.968]             base::sink(type = "output", split = FALSE)
[16:09:32.968]             base::close(...future.stdout)
[16:09:32.968]         }, add = TRUE)
[16:09:32.968]     }
[16:09:32.968]     ...future.frame <- base::sys.nframe()
[16:09:32.968]     ...future.conditions <- base::list()
[16:09:32.968]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:32.968]     if (FALSE) {
[16:09:32.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:32.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:32.968]     }
[16:09:32.968]     ...future.result <- base::tryCatch({
[16:09:32.968]         base::withCallingHandlers({
[16:09:32.968]             ...future.value <- base::withVisible(base::local({
[16:09:32.968]                 do.call(function(...) {
[16:09:32.968]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.968]                   if (!identical(...future.globals.maxSize.org, 
[16:09:32.968]                     ...future.globals.maxSize)) {
[16:09:32.968]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.968]                     on.exit(options(oopts), add = TRUE)
[16:09:32.968]                   }
[16:09:32.968]                   {
[16:09:32.968]                     lapply(seq_along(...future.elements_ii), 
[16:09:32.968]                       FUN = function(jj) {
[16:09:32.968]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.968]                         ...future.FUN(...future.X_jj, ...)
[16:09:32.968]                       })
[16:09:32.968]                   }
[16:09:32.968]                 }, args = future.call.arguments)
[16:09:32.968]             }))
[16:09:32.968]             future::FutureResult(value = ...future.value$value, 
[16:09:32.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.968]                   ...future.rng), globalenv = if (FALSE) 
[16:09:32.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:32.968]                     ...future.globalenv.names))
[16:09:32.968]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:32.968]         }, condition = base::local({
[16:09:32.968]             c <- base::c
[16:09:32.968]             inherits <- base::inherits
[16:09:32.968]             invokeRestart <- base::invokeRestart
[16:09:32.968]             length <- base::length
[16:09:32.968]             list <- base::list
[16:09:32.968]             seq.int <- base::seq.int
[16:09:32.968]             signalCondition <- base::signalCondition
[16:09:32.968]             sys.calls <- base::sys.calls
[16:09:32.968]             `[[` <- base::`[[`
[16:09:32.968]             `+` <- base::`+`
[16:09:32.968]             `<<-` <- base::`<<-`
[16:09:32.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:32.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:32.968]                   3L)]
[16:09:32.968]             }
[16:09:32.968]             function(cond) {
[16:09:32.968]                 is_error <- inherits(cond, "error")
[16:09:32.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:32.968]                   NULL)
[16:09:32.968]                 if (is_error) {
[16:09:32.968]                   sessionInformation <- function() {
[16:09:32.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:32.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:32.968]                       search = base::search(), system = base::Sys.info())
[16:09:32.968]                   }
[16:09:32.968]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:32.968]                     cond$call), session = sessionInformation(), 
[16:09:32.968]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:32.968]                   signalCondition(cond)
[16:09:32.968]                 }
[16:09:32.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:32.968]                 "immediateCondition"))) {
[16:09:32.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:32.968]                   ...future.conditions[[length(...future.conditions) + 
[16:09:32.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:32.968]                   if (TRUE && !signal) {
[16:09:32.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.968]                     {
[16:09:32.968]                       inherits <- base::inherits
[16:09:32.968]                       invokeRestart <- base::invokeRestart
[16:09:32.968]                       is.null <- base::is.null
[16:09:32.968]                       muffled <- FALSE
[16:09:32.968]                       if (inherits(cond, "message")) {
[16:09:32.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.968]                         if (muffled) 
[16:09:32.968]                           invokeRestart("muffleMessage")
[16:09:32.968]                       }
[16:09:32.968]                       else if (inherits(cond, "warning")) {
[16:09:32.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.968]                         if (muffled) 
[16:09:32.968]                           invokeRestart("muffleWarning")
[16:09:32.968]                       }
[16:09:32.968]                       else if (inherits(cond, "condition")) {
[16:09:32.968]                         if (!is.null(pattern)) {
[16:09:32.968]                           computeRestarts <- base::computeRestarts
[16:09:32.968]                           grepl <- base::grepl
[16:09:32.968]                           restarts <- computeRestarts(cond)
[16:09:32.968]                           for (restart in restarts) {
[16:09:32.968]                             name <- restart$name
[16:09:32.968]                             if (is.null(name)) 
[16:09:32.968]                               next
[16:09:32.968]                             if (!grepl(pattern, name)) 
[16:09:32.968]                               next
[16:09:32.968]                             invokeRestart(restart)
[16:09:32.968]                             muffled <- TRUE
[16:09:32.968]                             break
[16:09:32.968]                           }
[16:09:32.968]                         }
[16:09:32.968]                       }
[16:09:32.968]                       invisible(muffled)
[16:09:32.968]                     }
[16:09:32.968]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.968]                   }
[16:09:32.968]                 }
[16:09:32.968]                 else {
[16:09:32.968]                   if (TRUE) {
[16:09:32.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:32.968]                     {
[16:09:32.968]                       inherits <- base::inherits
[16:09:32.968]                       invokeRestart <- base::invokeRestart
[16:09:32.968]                       is.null <- base::is.null
[16:09:32.968]                       muffled <- FALSE
[16:09:32.968]                       if (inherits(cond, "message")) {
[16:09:32.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:32.968]                         if (muffled) 
[16:09:32.968]                           invokeRestart("muffleMessage")
[16:09:32.968]                       }
[16:09:32.968]                       else if (inherits(cond, "warning")) {
[16:09:32.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:32.968]                         if (muffled) 
[16:09:32.968]                           invokeRestart("muffleWarning")
[16:09:32.968]                       }
[16:09:32.968]                       else if (inherits(cond, "condition")) {
[16:09:32.968]                         if (!is.null(pattern)) {
[16:09:32.968]                           computeRestarts <- base::computeRestarts
[16:09:32.968]                           grepl <- base::grepl
[16:09:32.968]                           restarts <- computeRestarts(cond)
[16:09:32.968]                           for (restart in restarts) {
[16:09:32.968]                             name <- restart$name
[16:09:32.968]                             if (is.null(name)) 
[16:09:32.968]                               next
[16:09:32.968]                             if (!grepl(pattern, name)) 
[16:09:32.968]                               next
[16:09:32.968]                             invokeRestart(restart)
[16:09:32.968]                             muffled <- TRUE
[16:09:32.968]                             break
[16:09:32.968]                           }
[16:09:32.968]                         }
[16:09:32.968]                       }
[16:09:32.968]                       invisible(muffled)
[16:09:32.968]                     }
[16:09:32.968]                     muffleCondition(cond, pattern = "^muffle")
[16:09:32.968]                   }
[16:09:32.968]                 }
[16:09:32.968]             }
[16:09:32.968]         }))
[16:09:32.968]     }, error = function(ex) {
[16:09:32.968]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:32.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:32.968]                 ...future.rng), started = ...future.startTime, 
[16:09:32.968]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:32.968]             version = "1.8"), class = "FutureResult")
[16:09:32.968]     }, finally = {
[16:09:32.968]         if (!identical(...future.workdir, getwd())) 
[16:09:32.968]             setwd(...future.workdir)
[16:09:32.968]         {
[16:09:32.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:32.968]                 ...future.oldOptions$nwarnings <- NULL
[16:09:32.968]             }
[16:09:32.968]             base::options(...future.oldOptions)
[16:09:32.968]             if (.Platform$OS.type == "windows") {
[16:09:32.968]                 old_names <- names(...future.oldEnvVars)
[16:09:32.968]                 envs <- base::Sys.getenv()
[16:09:32.968]                 names <- names(envs)
[16:09:32.968]                 common <- intersect(names, old_names)
[16:09:32.968]                 added <- setdiff(names, old_names)
[16:09:32.968]                 removed <- setdiff(old_names, names)
[16:09:32.968]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:32.968]                   envs[common]]
[16:09:32.968]                 NAMES <- toupper(changed)
[16:09:32.968]                 args <- list()
[16:09:32.968]                 for (kk in seq_along(NAMES)) {
[16:09:32.968]                   name <- changed[[kk]]
[16:09:32.968]                   NAME <- NAMES[[kk]]
[16:09:32.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.968]                     next
[16:09:32.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.968]                 }
[16:09:32.968]                 NAMES <- toupper(added)
[16:09:32.968]                 for (kk in seq_along(NAMES)) {
[16:09:32.968]                   name <- added[[kk]]
[16:09:32.968]                   NAME <- NAMES[[kk]]
[16:09:32.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.968]                     next
[16:09:32.968]                   args[[name]] <- ""
[16:09:32.968]                 }
[16:09:32.968]                 NAMES <- toupper(removed)
[16:09:32.968]                 for (kk in seq_along(NAMES)) {
[16:09:32.968]                   name <- removed[[kk]]
[16:09:32.968]                   NAME <- NAMES[[kk]]
[16:09:32.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:32.968]                     next
[16:09:32.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:32.968]                 }
[16:09:32.968]                 if (length(args) > 0) 
[16:09:32.968]                   base::do.call(base::Sys.setenv, args = args)
[16:09:32.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:32.968]             }
[16:09:32.968]             else {
[16:09:32.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:32.968]             }
[16:09:32.968]             {
[16:09:32.968]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:32.968]                   0L) {
[16:09:32.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:32.968]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:32.968]                   base::options(opts)
[16:09:32.968]                 }
[16:09:32.968]                 {
[16:09:32.968]                   {
[16:09:32.968]                     NULL
[16:09:32.968]                     RNGkind("Mersenne-Twister")
[16:09:32.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:32.968]                       inherits = FALSE)
[16:09:32.968]                   }
[16:09:32.968]                   options(future.plan = NULL)
[16:09:32.968]                   if (is.na(NA_character_)) 
[16:09:32.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:32.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:32.968]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:32.968]                   {
[16:09:32.968]                     future <- SequentialFuture(..., envir = envir)
[16:09:32.968]                     if (!future$lazy) 
[16:09:32.968]                       future <- run(future)
[16:09:32.968]                     invisible(future)
[16:09:32.968]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:32.968]                 }
[16:09:32.968]             }
[16:09:32.968]         }
[16:09:32.968]     })
[16:09:32.968]     if (TRUE) {
[16:09:32.968]         base::sink(type = "output", split = FALSE)
[16:09:32.968]         if (TRUE) {
[16:09:32.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:32.968]         }
[16:09:32.968]         else {
[16:09:32.968]             ...future.result["stdout"] <- base::list(NULL)
[16:09:32.968]         }
[16:09:32.968]         base::close(...future.stdout)
[16:09:32.968]         ...future.stdout <- NULL
[16:09:32.968]     }
[16:09:32.968]     ...future.result$conditions <- ...future.conditions
[16:09:32.968]     ...future.result$finished <- base::Sys.time()
[16:09:32.968]     ...future.result
[16:09:32.968] }
[16:09:32.969] assign_globals() ...
[16:09:32.969] List of 7
[16:09:32.969]  $ ...future.FUN            :function (x)  
[16:09:32.969]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:32.969]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.969]  $ future.call.arguments    : list()
[16:09:32.969]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.969]  $ ...future.elements_ii    :List of 3
[16:09:32.969]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.969]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:32.969]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.969]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:32.969]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.969]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:32.969]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.969]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:32.969]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:32.969]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:32.969]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:32.969]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:32.969]  $ ...future.seeds_ii       : NULL
[16:09:32.969]  $ ...future.globals.maxSize: NULL
[16:09:32.969]  - attr(*, "resolved")= logi FALSE
[16:09:32.969]  - attr(*, "total_size")= num 2320
[16:09:32.969]  - attr(*, "where")=List of 7
[16:09:32.969]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:32.969]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:09:32.969]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:09:32.969]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:32.969]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:32.969]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:32.969]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:32.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.969]  - attr(*, "already-done")= logi TRUE
[16:09:32.980] - reassign environment for ‘...future.FUN’
[16:09:32.981] - copied ‘...future.FUN’ to environment
[16:09:32.981] - copied ‘breaks’ to environment
[16:09:32.981] - copied ‘wool’ to environment
[16:09:32.981] - copied ‘future.call.arguments’ to environment
[16:09:32.981] - copied ‘...future.elements_ii’ to environment
[16:09:32.981] - copied ‘...future.seeds_ii’ to environment
[16:09:32.981] - copied ‘...future.globals.maxSize’ to environment
[16:09:32.981] assign_globals() ... done
[16:09:32.982] plan(): Setting new future strategy stack:
[16:09:32.982] List of future strategies:
[16:09:32.982] 1. sequential:
[16:09:32.982]    - args: function (..., envir = parent.frame())
[16:09:32.982]    - tweaked: FALSE
[16:09:32.982]    - call: NULL
[16:09:32.982] plan(): nbrOfWorkers() = 1
[16:09:32.985] plan(): Setting new future strategy stack:
[16:09:32.985] List of future strategies:
[16:09:32.985] 1. sequential:
[16:09:32.985]    - args: function (..., envir = parent.frame())
[16:09:32.985]    - tweaked: FALSE
[16:09:32.985]    - call: plan(strategy)
[16:09:32.985] plan(): nbrOfWorkers() = 1
[16:09:32.985] SequentialFuture started (and completed)
[16:09:32.986] - Launch lazy future ... done
[16:09:32.986] run() for ‘SequentialFuture’ ... done
[16:09:32.986] Created future:
[16:09:32.986] SequentialFuture:
[16:09:32.986] Label: ‘future_by-1’
[16:09:32.986] Expression:
[16:09:32.986] {
[16:09:32.986]     do.call(function(...) {
[16:09:32.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:32.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:32.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:32.986]             on.exit(options(oopts), add = TRUE)
[16:09:32.986]         }
[16:09:32.986]         {
[16:09:32.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:32.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:32.986]                 ...future.FUN(...future.X_jj, ...)
[16:09:32.986]             })
[16:09:32.986]         }
[16:09:32.986]     }, args = future.call.arguments)
[16:09:32.986] }
[16:09:32.986] Lazy evaluation: FALSE
[16:09:32.986] Asynchronous evaluation: FALSE
[16:09:32.986] Local evaluation: TRUE
[16:09:32.986] Environment: 0x5567e6db5aa8
[16:09:32.986] Capture standard output: TRUE
[16:09:32.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:32.986] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:09:32.986] Packages: 1 packages (‘stats’)
[16:09:32.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:32.986] Resolved: TRUE
[16:09:32.986] Value: 25.57 KiB of class ‘list’
[16:09:32.986] Early signaling: FALSE
[16:09:32.986] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:32.986] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:32.987] Chunk #1 of 1 ... DONE
[16:09:32.987] Launching 1 futures (chunks) ... DONE
[16:09:32.988] Resolving 1 futures (chunks) ...
[16:09:32.988] resolve() on list ...
[16:09:32.988]  recursive: 0
[16:09:32.988]  length: 1
[16:09:32.988] 
[16:09:32.988] resolved() for ‘SequentialFuture’ ...
[16:09:32.988] - state: ‘finished’
[16:09:32.988] - run: TRUE
[16:09:32.988] - result: ‘FutureResult’
[16:09:32.988] resolved() for ‘SequentialFuture’ ... done
[16:09:32.989] Future #1
[16:09:32.989] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:32.989] - nx: 1
[16:09:32.989] - relay: TRUE
[16:09:32.989] - stdout: TRUE
[16:09:32.989] - signal: TRUE
[16:09:32.989] - resignal: FALSE
[16:09:32.989] - force: TRUE
[16:09:32.989] - relayed: [n=1] FALSE
[16:09:32.989] - queued futures: [n=1] FALSE
[16:09:32.989]  - until=1
[16:09:32.990]  - relaying element #1
[16:09:32.990] - relayed: [n=1] TRUE
[16:09:32.990] - queued futures: [n=1] TRUE
[16:09:32.990] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:32.990]  length: 0 (resolved future 1)
[16:09:32.990] Relaying remaining futures
[16:09:32.990] signalConditionsASAP(NULL, pos=0) ...
[16:09:32.990] - nx: 1
[16:09:32.990] - relay: TRUE
[16:09:32.990] - stdout: TRUE
[16:09:32.991] - signal: TRUE
[16:09:32.991] - resignal: FALSE
[16:09:32.991] - force: TRUE
[16:09:32.991] - relayed: [n=1] TRUE
[16:09:32.991] - queued futures: [n=1] TRUE
 - flush all
[16:09:32.991] - relayed: [n=1] TRUE
[16:09:32.991] - queued futures: [n=1] TRUE
[16:09:32.991] signalConditionsASAP(NULL, pos=0) ... done
[16:09:32.991] resolve() on list ... DONE
[16:09:32.991]  - Number of value chunks collected: 1
[16:09:32.991] Resolving 1 futures (chunks) ... DONE
[16:09:32.992] Reducing values from 1 chunks ...
[16:09:32.992]  - Number of values collected after concatenation: 3
[16:09:32.992]  - Number of values expected: 3
[16:09:32.992] Reducing values from 1 chunks ... DONE
[16:09:32.992] future_lapply() ... DONE
[16:09:32.992] future_by_internal() ... DONE
[16:09:32.992] future_by_internal() ...
[16:09:32.993] future_lapply() ...
[16:09:32.993] Number of chunks: 1
[16:09:32.993] getGlobalsAndPackagesXApply() ...
[16:09:32.993]  - future.globals: TRUE
[16:09:32.994] getGlobalsAndPackages() ...
[16:09:32.994] Searching for globals...
[16:09:32.995] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:32.995] Searching for globals ... DONE
[16:09:32.995] Resolving globals: FALSE
[16:09:32.995] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:32.995] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:32.996] - globals: [1] ‘FUN’
[16:09:32.997] 
[16:09:32.997] getGlobalsAndPackages() ... DONE
[16:09:32.997]  - globals found/used: [n=1] ‘FUN’
[16:09:32.997]  - needed namespaces: [n=0] 
[16:09:32.998] Finding globals ... DONE
[16:09:32.998]  - use_args: TRUE
[16:09:32.998]  - Getting '...' globals ...
[16:09:32.998] resolve() on list ...
[16:09:32.998]  recursive: 0
[16:09:32.998]  length: 1
[16:09:32.998]  elements: ‘...’
[16:09:32.998]  length: 0 (resolved future 1)
[16:09:32.999] resolve() on list ... DONE
[16:09:32.999]    - '...' content: [n=0] 
[16:09:32.999] List of 1
[16:09:32.999]  $ ...: list()
[16:09:32.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:32.999]  - attr(*, "where")=List of 1
[16:09:32.999]   ..$ ...:<environment: 0x5567e8f68be0> 
[16:09:32.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:32.999]  - attr(*, "resolved")= logi TRUE
[16:09:32.999]  - attr(*, "total_size")= num NA
[16:09:33.002]  - Getting '...' globals ... DONE
[16:09:33.002] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.002] List of 2
[16:09:33.002]  $ ...future.FUN:function (object, ...)  
[16:09:33.002]  $ ...          : list()
[16:09:33.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.002]  - attr(*, "where")=List of 2
[16:09:33.002]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.002]   ..$ ...          :<environment: 0x5567e8f68be0> 
[16:09:33.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.002]  - attr(*, "resolved")= logi FALSE
[16:09:33.002]  - attr(*, "total_size")= num 1240
[16:09:33.004] Packages to be attached in all futures: [n=0] 
[16:09:33.005] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.005] Number of futures (= number of chunks): 1
[16:09:33.005] Launching 1 futures (chunks) ...
[16:09:33.005] Chunk #1 of 1 ...
[16:09:33.005]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.005] getGlobalsAndPackages() ...
[16:09:33.005] Searching for globals...
[16:09:33.006] 
[16:09:33.006] Searching for globals ... DONE
[16:09:33.006] - globals: [0] <none>
[16:09:33.006] getGlobalsAndPackages() ... DONE
[16:09:33.006]    + additional globals found: [n=0] 
[16:09:33.006]    + additional namespaces needed: [n=0] 
[16:09:33.006]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.006]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:33.006]  - seeds: <none>
[16:09:33.007] getGlobalsAndPackages() ...
[16:09:33.007] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.007] Resolving globals: FALSE
[16:09:33.007] Tweak future expression to call with '...' arguments ...
[16:09:33.007] {
[16:09:33.007]     do.call(function(...) {
[16:09:33.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.007]             on.exit(options(oopts), add = TRUE)
[16:09:33.007]         }
[16:09:33.007]         {
[16:09:33.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.007]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.007]             })
[16:09:33.007]         }
[16:09:33.007]     }, args = future.call.arguments)
[16:09:33.007] }
[16:09:33.007] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.008] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.008] 
[16:09:33.008] getGlobalsAndPackages() ... DONE
[16:09:33.008] run() for ‘Future’ ...
[16:09:33.008] - state: ‘created’
[16:09:33.008] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:33.009] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:33.009] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:33.009]   - Field: ‘label’
[16:09:33.009]   - Field: ‘local’
[16:09:33.009]   - Field: ‘owner’
[16:09:33.009]   - Field: ‘envir’
[16:09:33.009]   - Field: ‘packages’
[16:09:33.009]   - Field: ‘gc’
[16:09:33.009]   - Field: ‘conditions’
[16:09:33.010]   - Field: ‘expr’
[16:09:33.010]   - Field: ‘uuid’
[16:09:33.010]   - Field: ‘seed’
[16:09:33.010]   - Field: ‘version’
[16:09:33.010]   - Field: ‘result’
[16:09:33.010]   - Field: ‘asynchronous’
[16:09:33.010]   - Field: ‘calls’
[16:09:33.010]   - Field: ‘globals’
[16:09:33.010]   - Field: ‘stdout’
[16:09:33.010]   - Field: ‘earlySignal’
[16:09:33.010]   - Field: ‘lazy’
[16:09:33.011]   - Field: ‘state’
[16:09:33.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:33.011] - Launch lazy future ...
[16:09:33.011] Packages needed by the future expression (n = 0): <none>
[16:09:33.011] Packages needed by future strategies (n = 0): <none>
[16:09:33.011] {
[16:09:33.011]     {
[16:09:33.011]         {
[16:09:33.011]             ...future.startTime <- base::Sys.time()
[16:09:33.011]             {
[16:09:33.011]                 {
[16:09:33.011]                   {
[16:09:33.011]                     base::local({
[16:09:33.011]                       has_future <- base::requireNamespace("future", 
[16:09:33.011]                         quietly = TRUE)
[16:09:33.011]                       if (has_future) {
[16:09:33.011]                         ns <- base::getNamespace("future")
[16:09:33.011]                         version <- ns[[".package"]][["version"]]
[16:09:33.011]                         if (is.null(version)) 
[16:09:33.011]                           version <- utils::packageVersion("future")
[16:09:33.011]                       }
[16:09:33.011]                       else {
[16:09:33.011]                         version <- NULL
[16:09:33.011]                       }
[16:09:33.011]                       if (!has_future || version < "1.8.0") {
[16:09:33.011]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.011]                           "", base::R.version$version.string), 
[16:09:33.011]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:33.011]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.011]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.011]                             "release", "version")], collapse = " "), 
[16:09:33.011]                           hostname = base::Sys.info()[["nodename"]])
[16:09:33.011]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.011]                           info)
[16:09:33.011]                         info <- base::paste(info, collapse = "; ")
[16:09:33.011]                         if (!has_future) {
[16:09:33.011]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.011]                             info)
[16:09:33.011]                         }
[16:09:33.011]                         else {
[16:09:33.011]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.011]                             info, version)
[16:09:33.011]                         }
[16:09:33.011]                         base::stop(msg)
[16:09:33.011]                       }
[16:09:33.011]                     })
[16:09:33.011]                   }
[16:09:33.011]                   options(future.plan = NULL)
[16:09:33.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.011]                 }
[16:09:33.011]                 ...future.workdir <- getwd()
[16:09:33.011]             }
[16:09:33.011]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.011]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.011]         }
[16:09:33.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.011]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:33.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.011]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.011]             base::names(...future.oldOptions))
[16:09:33.011]     }
[16:09:33.011]     if (FALSE) {
[16:09:33.011]     }
[16:09:33.011]     else {
[16:09:33.011]         if (TRUE) {
[16:09:33.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.011]                 open = "w")
[16:09:33.011]         }
[16:09:33.011]         else {
[16:09:33.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.011]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.011]         }
[16:09:33.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.011]             base::sink(type = "output", split = FALSE)
[16:09:33.011]             base::close(...future.stdout)
[16:09:33.011]         }, add = TRUE)
[16:09:33.011]     }
[16:09:33.011]     ...future.frame <- base::sys.nframe()
[16:09:33.011]     ...future.conditions <- base::list()
[16:09:33.011]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.011]     if (FALSE) {
[16:09:33.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.011]     }
[16:09:33.011]     ...future.result <- base::tryCatch({
[16:09:33.011]         base::withCallingHandlers({
[16:09:33.011]             ...future.value <- base::withVisible(base::local({
[16:09:33.011]                 do.call(function(...) {
[16:09:33.011]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.011]                   if (!identical(...future.globals.maxSize.org, 
[16:09:33.011]                     ...future.globals.maxSize)) {
[16:09:33.011]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.011]                     on.exit(options(oopts), add = TRUE)
[16:09:33.011]                   }
[16:09:33.011]                   {
[16:09:33.011]                     lapply(seq_along(...future.elements_ii), 
[16:09:33.011]                       FUN = function(jj) {
[16:09:33.011]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.011]                         ...future.FUN(...future.X_jj, ...)
[16:09:33.011]                       })
[16:09:33.011]                   }
[16:09:33.011]                 }, args = future.call.arguments)
[16:09:33.011]             }))
[16:09:33.011]             future::FutureResult(value = ...future.value$value, 
[16:09:33.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.011]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.011]                     ...future.globalenv.names))
[16:09:33.011]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.011]         }, condition = base::local({
[16:09:33.011]             c <- base::c
[16:09:33.011]             inherits <- base::inherits
[16:09:33.011]             invokeRestart <- base::invokeRestart
[16:09:33.011]             length <- base::length
[16:09:33.011]             list <- base::list
[16:09:33.011]             seq.int <- base::seq.int
[16:09:33.011]             signalCondition <- base::signalCondition
[16:09:33.011]             sys.calls <- base::sys.calls
[16:09:33.011]             `[[` <- base::`[[`
[16:09:33.011]             `+` <- base::`+`
[16:09:33.011]             `<<-` <- base::`<<-`
[16:09:33.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.011]                   3L)]
[16:09:33.011]             }
[16:09:33.011]             function(cond) {
[16:09:33.011]                 is_error <- inherits(cond, "error")
[16:09:33.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.011]                   NULL)
[16:09:33.011]                 if (is_error) {
[16:09:33.011]                   sessionInformation <- function() {
[16:09:33.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.011]                       search = base::search(), system = base::Sys.info())
[16:09:33.011]                   }
[16:09:33.011]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.011]                     cond$call), session = sessionInformation(), 
[16:09:33.011]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.011]                   signalCondition(cond)
[16:09:33.011]                 }
[16:09:33.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.011]                 "immediateCondition"))) {
[16:09:33.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.011]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.011]                   if (TRUE && !signal) {
[16:09:33.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.011]                     {
[16:09:33.011]                       inherits <- base::inherits
[16:09:33.011]                       invokeRestart <- base::invokeRestart
[16:09:33.011]                       is.null <- base::is.null
[16:09:33.011]                       muffled <- FALSE
[16:09:33.011]                       if (inherits(cond, "message")) {
[16:09:33.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.011]                         if (muffled) 
[16:09:33.011]                           invokeRestart("muffleMessage")
[16:09:33.011]                       }
[16:09:33.011]                       else if (inherits(cond, "warning")) {
[16:09:33.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.011]                         if (muffled) 
[16:09:33.011]                           invokeRestart("muffleWarning")
[16:09:33.011]                       }
[16:09:33.011]                       else if (inherits(cond, "condition")) {
[16:09:33.011]                         if (!is.null(pattern)) {
[16:09:33.011]                           computeRestarts <- base::computeRestarts
[16:09:33.011]                           grepl <- base::grepl
[16:09:33.011]                           restarts <- computeRestarts(cond)
[16:09:33.011]                           for (restart in restarts) {
[16:09:33.011]                             name <- restart$name
[16:09:33.011]                             if (is.null(name)) 
[16:09:33.011]                               next
[16:09:33.011]                             if (!grepl(pattern, name)) 
[16:09:33.011]                               next
[16:09:33.011]                             invokeRestart(restart)
[16:09:33.011]                             muffled <- TRUE
[16:09:33.011]                             break
[16:09:33.011]                           }
[16:09:33.011]                         }
[16:09:33.011]                       }
[16:09:33.011]                       invisible(muffled)
[16:09:33.011]                     }
[16:09:33.011]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.011]                   }
[16:09:33.011]                 }
[16:09:33.011]                 else {
[16:09:33.011]                   if (TRUE) {
[16:09:33.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.011]                     {
[16:09:33.011]                       inherits <- base::inherits
[16:09:33.011]                       invokeRestart <- base::invokeRestart
[16:09:33.011]                       is.null <- base::is.null
[16:09:33.011]                       muffled <- FALSE
[16:09:33.011]                       if (inherits(cond, "message")) {
[16:09:33.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.011]                         if (muffled) 
[16:09:33.011]                           invokeRestart("muffleMessage")
[16:09:33.011]                       }
[16:09:33.011]                       else if (inherits(cond, "warning")) {
[16:09:33.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.011]                         if (muffled) 
[16:09:33.011]                           invokeRestart("muffleWarning")
[16:09:33.011]                       }
[16:09:33.011]                       else if (inherits(cond, "condition")) {
[16:09:33.011]                         if (!is.null(pattern)) {
[16:09:33.011]                           computeRestarts <- base::computeRestarts
[16:09:33.011]                           grepl <- base::grepl
[16:09:33.011]                           restarts <- computeRestarts(cond)
[16:09:33.011]                           for (restart in restarts) {
[16:09:33.011]                             name <- restart$name
[16:09:33.011]                             if (is.null(name)) 
[16:09:33.011]                               next
[16:09:33.011]                             if (!grepl(pattern, name)) 
[16:09:33.011]                               next
[16:09:33.011]                             invokeRestart(restart)
[16:09:33.011]                             muffled <- TRUE
[16:09:33.011]                             break
[16:09:33.011]                           }
[16:09:33.011]                         }
[16:09:33.011]                       }
[16:09:33.011]                       invisible(muffled)
[16:09:33.011]                     }
[16:09:33.011]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.011]                   }
[16:09:33.011]                 }
[16:09:33.011]             }
[16:09:33.011]         }))
[16:09:33.011]     }, error = function(ex) {
[16:09:33.011]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.011]                 ...future.rng), started = ...future.startTime, 
[16:09:33.011]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.011]             version = "1.8"), class = "FutureResult")
[16:09:33.011]     }, finally = {
[16:09:33.011]         if (!identical(...future.workdir, getwd())) 
[16:09:33.011]             setwd(...future.workdir)
[16:09:33.011]         {
[16:09:33.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.011]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.011]             }
[16:09:33.011]             base::options(...future.oldOptions)
[16:09:33.011]             if (.Platform$OS.type == "windows") {
[16:09:33.011]                 old_names <- names(...future.oldEnvVars)
[16:09:33.011]                 envs <- base::Sys.getenv()
[16:09:33.011]                 names <- names(envs)
[16:09:33.011]                 common <- intersect(names, old_names)
[16:09:33.011]                 added <- setdiff(names, old_names)
[16:09:33.011]                 removed <- setdiff(old_names, names)
[16:09:33.011]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.011]                   envs[common]]
[16:09:33.011]                 NAMES <- toupper(changed)
[16:09:33.011]                 args <- list()
[16:09:33.011]                 for (kk in seq_along(NAMES)) {
[16:09:33.011]                   name <- changed[[kk]]
[16:09:33.011]                   NAME <- NAMES[[kk]]
[16:09:33.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.011]                     next
[16:09:33.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.011]                 }
[16:09:33.011]                 NAMES <- toupper(added)
[16:09:33.011]                 for (kk in seq_along(NAMES)) {
[16:09:33.011]                   name <- added[[kk]]
[16:09:33.011]                   NAME <- NAMES[[kk]]
[16:09:33.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.011]                     next
[16:09:33.011]                   args[[name]] <- ""
[16:09:33.011]                 }
[16:09:33.011]                 NAMES <- toupper(removed)
[16:09:33.011]                 for (kk in seq_along(NAMES)) {
[16:09:33.011]                   name <- removed[[kk]]
[16:09:33.011]                   NAME <- NAMES[[kk]]
[16:09:33.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.011]                     next
[16:09:33.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.011]                 }
[16:09:33.011]                 if (length(args) > 0) 
[16:09:33.011]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.011]             }
[16:09:33.011]             else {
[16:09:33.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.011]             }
[16:09:33.011]             {
[16:09:33.011]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.011]                   0L) {
[16:09:33.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.011]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.011]                   base::options(opts)
[16:09:33.011]                 }
[16:09:33.011]                 {
[16:09:33.011]                   {
[16:09:33.011]                     NULL
[16:09:33.011]                     RNGkind("Mersenne-Twister")
[16:09:33.011]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:33.011]                       inherits = FALSE)
[16:09:33.011]                   }
[16:09:33.011]                   options(future.plan = NULL)
[16:09:33.011]                   if (is.na(NA_character_)) 
[16:09:33.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.011]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:33.011]                   {
[16:09:33.011]                     future <- SequentialFuture(..., envir = envir)
[16:09:33.011]                     if (!future$lazy) 
[16:09:33.011]                       future <- run(future)
[16:09:33.011]                     invisible(future)
[16:09:33.011]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.011]                 }
[16:09:33.011]             }
[16:09:33.011]         }
[16:09:33.011]     })
[16:09:33.011]     if (TRUE) {
[16:09:33.011]         base::sink(type = "output", split = FALSE)
[16:09:33.011]         if (TRUE) {
[16:09:33.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.011]         }
[16:09:33.011]         else {
[16:09:33.011]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.011]         }
[16:09:33.011]         base::close(...future.stdout)
[16:09:33.011]         ...future.stdout <- NULL
[16:09:33.011]     }
[16:09:33.011]     ...future.result$conditions <- ...future.conditions
[16:09:33.011]     ...future.result$finished <- base::Sys.time()
[16:09:33.011]     ...future.result
[16:09:33.011] }
[16:09:33.013] assign_globals() ...
[16:09:33.013] List of 5
[16:09:33.013]  $ ...future.FUN            :function (object, ...)  
[16:09:33.013]  $ future.call.arguments    : list()
[16:09:33.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.013]  $ ...future.elements_ii    :List of 3
[16:09:33.013]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.013]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.013]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.013]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.013]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.013]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.013]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.013]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:33.013]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.013]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.013]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.013]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:33.013]  $ ...future.seeds_ii       : NULL
[16:09:33.013]  $ ...future.globals.maxSize: NULL
[16:09:33.013]  - attr(*, "resolved")= logi FALSE
[16:09:33.013]  - attr(*, "total_size")= num 1240
[16:09:33.013]  - attr(*, "where")=List of 5
[16:09:33.013]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.013]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.013]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.013]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.013]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.013]  - attr(*, "already-done")= logi TRUE
[16:09:33.024] - copied ‘...future.FUN’ to environment
[16:09:33.024] - copied ‘future.call.arguments’ to environment
[16:09:33.024] - copied ‘...future.elements_ii’ to environment
[16:09:33.024] - copied ‘...future.seeds_ii’ to environment
[16:09:33.024] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.024] assign_globals() ... done
[16:09:33.025] plan(): Setting new future strategy stack:
[16:09:33.025] List of future strategies:
[16:09:33.025] 1. sequential:
[16:09:33.025]    - args: function (..., envir = parent.frame())
[16:09:33.025]    - tweaked: FALSE
[16:09:33.025]    - call: NULL
[16:09:33.025] plan(): nbrOfWorkers() = 1
[16:09:33.027] plan(): Setting new future strategy stack:
[16:09:33.027] List of future strategies:
[16:09:33.027] 1. sequential:
[16:09:33.027]    - args: function (..., envir = parent.frame())
[16:09:33.027]    - tweaked: FALSE
[16:09:33.027]    - call: plan(strategy)
[16:09:33.028] plan(): nbrOfWorkers() = 1
[16:09:33.028] SequentialFuture started (and completed)
[16:09:33.028] - Launch lazy future ... done
[16:09:33.028] run() for ‘SequentialFuture’ ... done
[16:09:33.028] Created future:
[16:09:33.028] SequentialFuture:
[16:09:33.028] Label: ‘future_by-1’
[16:09:33.028] Expression:
[16:09:33.028] {
[16:09:33.028]     do.call(function(...) {
[16:09:33.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.028]             on.exit(options(oopts), add = TRUE)
[16:09:33.028]         }
[16:09:33.028]         {
[16:09:33.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.028]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.028]             })
[16:09:33.028]         }
[16:09:33.028]     }, args = future.call.arguments)
[16:09:33.028] }
[16:09:33.028] Lazy evaluation: FALSE
[16:09:33.028] Asynchronous evaluation: FALSE
[16:09:33.028] Local evaluation: TRUE
[16:09:33.028] Environment: 0x5567e8dd1668
[16:09:33.028] Capture standard output: TRUE
[16:09:33.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.028] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.028] Packages: <none>
[16:09:33.028] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.028] Resolved: TRUE
[16:09:33.028] Value: 5.37 KiB of class ‘list’
[16:09:33.028] Early signaling: FALSE
[16:09:33.028] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.028] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:33.030] Chunk #1 of 1 ... DONE
[16:09:33.030] Launching 1 futures (chunks) ... DONE
[16:09:33.030] Resolving 1 futures (chunks) ...
[16:09:33.030] resolve() on list ...
[16:09:33.030]  recursive: 0
[16:09:33.030]  length: 1
[16:09:33.030] 
[16:09:33.030] resolved() for ‘SequentialFuture’ ...
[16:09:33.030] - state: ‘finished’
[16:09:33.030] - run: TRUE
[16:09:33.030] - result: ‘FutureResult’
[16:09:33.031] resolved() for ‘SequentialFuture’ ... done
[16:09:33.031] Future #1
[16:09:33.031] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:33.031] - nx: 1
[16:09:33.031] - relay: TRUE
[16:09:33.031] - stdout: TRUE
[16:09:33.031] - signal: TRUE
[16:09:33.031] - resignal: FALSE
[16:09:33.031] - force: TRUE
[16:09:33.031] - relayed: [n=1] FALSE
[16:09:33.031] - queued futures: [n=1] FALSE
[16:09:33.032]  - until=1
[16:09:33.032]  - relaying element #1
[16:09:33.032] - relayed: [n=1] TRUE
[16:09:33.032] - queued futures: [n=1] TRUE
[16:09:33.032] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:33.032]  length: 0 (resolved future 1)
[16:09:33.032] Relaying remaining futures
[16:09:33.032] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.033] - nx: 1
[16:09:33.033] - relay: TRUE
[16:09:33.033] - stdout: TRUE
[16:09:33.033] - signal: TRUE
[16:09:33.033] - resignal: FALSE
[16:09:33.033] - force: TRUE
[16:09:33.033] - relayed: [n=1] TRUE
[16:09:33.033] - queued futures: [n=1] TRUE
 - flush all
[16:09:33.033] - relayed: [n=1] TRUE
[16:09:33.033] - queued futures: [n=1] TRUE
[16:09:33.033] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.034] resolve() on list ... DONE
[16:09:33.034]  - Number of value chunks collected: 1
[16:09:33.034] Resolving 1 futures (chunks) ... DONE
[16:09:33.034] Reducing values from 1 chunks ...
[16:09:33.034]  - Number of values collected after concatenation: 3
[16:09:33.034]  - Number of values expected: 3
[16:09:33.034] Reducing values from 1 chunks ... DONE
[16:09:33.034] future_lapply() ... DONE
[16:09:33.034] future_by_internal() ... DONE
[16:09:33.035] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:09:33.036] future_lapply() ...
[16:09:33.036] Number of chunks: 1
[16:09:33.036] getGlobalsAndPackagesXApply() ...
[16:09:33.036]  - future.globals: TRUE
[16:09:33.036] getGlobalsAndPackages() ...
[16:09:33.036] Searching for globals...
[16:09:33.039] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:33.039] Searching for globals ... DONE
[16:09:33.039] Resolving globals: FALSE
[16:09:33.039] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:33.040] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:33.040] - globals: [1] ‘FUN’
[16:09:33.040] 
[16:09:33.040] getGlobalsAndPackages() ... DONE
[16:09:33.040]  - globals found/used: [n=1] ‘FUN’
[16:09:33.040]  - needed namespaces: [n=0] 
[16:09:33.040] Finding globals ... DONE
[16:09:33.041]  - use_args: TRUE
[16:09:33.041]  - Getting '...' globals ...
[16:09:33.041] resolve() on list ...
[16:09:33.041]  recursive: 0
[16:09:33.041]  length: 1
[16:09:33.041]  elements: ‘...’
[16:09:33.041]  length: 0 (resolved future 1)
[16:09:33.041] resolve() on list ... DONE
[16:09:33.041]    - '...' content: [n=0] 
[16:09:33.042] List of 1
[16:09:33.042]  $ ...: list()
[16:09:33.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.042]  - attr(*, "where")=List of 1
[16:09:33.042]   ..$ ...:<environment: 0x5567e9242958> 
[16:09:33.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.042]  - attr(*, "resolved")= logi TRUE
[16:09:33.042]  - attr(*, "total_size")= num NA
[16:09:33.044]  - Getting '...' globals ... DONE
[16:09:33.044] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.044] List of 2
[16:09:33.044]  $ ...future.FUN:function (object, ...)  
[16:09:33.044]  $ ...          : list()
[16:09:33.044]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.044]  - attr(*, "where")=List of 2
[16:09:33.044]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.044]   ..$ ...          :<environment: 0x5567e9242958> 
[16:09:33.044]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.044]  - attr(*, "resolved")= logi FALSE
[16:09:33.044]  - attr(*, "total_size")= num 1240
[16:09:33.047] Packages to be attached in all futures: [n=0] 
[16:09:33.047] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.047] Number of futures (= number of chunks): 1
[16:09:33.047] Launching 1 futures (chunks) ...
[16:09:33.047] Chunk #1 of 1 ...
[16:09:33.047]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.048] getGlobalsAndPackages() ...
[16:09:33.048] Searching for globals...
[16:09:33.048] 
[16:09:33.048] Searching for globals ... DONE
[16:09:33.048] - globals: [0] <none>
[16:09:33.048] getGlobalsAndPackages() ... DONE
[16:09:33.048]    + additional globals found: [n=0] 
[16:09:33.049]    + additional namespaces needed: [n=0] 
[16:09:33.049]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.049]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:33.049]  - seeds: <none>
[16:09:33.049] getGlobalsAndPackages() ...
[16:09:33.049] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.049] Resolving globals: FALSE
[16:09:33.049] Tweak future expression to call with '...' arguments ...
[16:09:33.049] {
[16:09:33.049]     do.call(function(...) {
[16:09:33.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.049]             on.exit(options(oopts), add = TRUE)
[16:09:33.049]         }
[16:09:33.049]         {
[16:09:33.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.049]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.049]             })
[16:09:33.049]         }
[16:09:33.049]     }, args = future.call.arguments)
[16:09:33.049] }
[16:09:33.050] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.050] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.050] 
[16:09:33.050] getGlobalsAndPackages() ... DONE
[16:09:33.050] run() for ‘Future’ ...
[16:09:33.050] - state: ‘created’
[16:09:33.051] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:33.051] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:33.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:33.051]   - Field: ‘label’
[16:09:33.051]   - Field: ‘local’
[16:09:33.051]   - Field: ‘owner’
[16:09:33.051]   - Field: ‘envir’
[16:09:33.052]   - Field: ‘packages’
[16:09:33.052]   - Field: ‘gc’
[16:09:33.052]   - Field: ‘conditions’
[16:09:33.052]   - Field: ‘expr’
[16:09:33.052]   - Field: ‘uuid’
[16:09:33.052]   - Field: ‘seed’
[16:09:33.052]   - Field: ‘version’
[16:09:33.052]   - Field: ‘result’
[16:09:33.052]   - Field: ‘asynchronous’
[16:09:33.052]   - Field: ‘calls’
[16:09:33.052]   - Field: ‘globals’
[16:09:33.052]   - Field: ‘stdout’
[16:09:33.053]   - Field: ‘earlySignal’
[16:09:33.053]   - Field: ‘lazy’
[16:09:33.053]   - Field: ‘state’
[16:09:33.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:33.053] - Launch lazy future ...
[16:09:33.053] Packages needed by the future expression (n = 0): <none>
[16:09:33.053] Packages needed by future strategies (n = 0): <none>
[16:09:33.054] {
[16:09:33.054]     {
[16:09:33.054]         {
[16:09:33.054]             ...future.startTime <- base::Sys.time()
[16:09:33.054]             {
[16:09:33.054]                 {
[16:09:33.054]                   {
[16:09:33.054]                     base::local({
[16:09:33.054]                       has_future <- base::requireNamespace("future", 
[16:09:33.054]                         quietly = TRUE)
[16:09:33.054]                       if (has_future) {
[16:09:33.054]                         ns <- base::getNamespace("future")
[16:09:33.054]                         version <- ns[[".package"]][["version"]]
[16:09:33.054]                         if (is.null(version)) 
[16:09:33.054]                           version <- utils::packageVersion("future")
[16:09:33.054]                       }
[16:09:33.054]                       else {
[16:09:33.054]                         version <- NULL
[16:09:33.054]                       }
[16:09:33.054]                       if (!has_future || version < "1.8.0") {
[16:09:33.054]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.054]                           "", base::R.version$version.string), 
[16:09:33.054]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:33.054]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.054]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.054]                             "release", "version")], collapse = " "), 
[16:09:33.054]                           hostname = base::Sys.info()[["nodename"]])
[16:09:33.054]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.054]                           info)
[16:09:33.054]                         info <- base::paste(info, collapse = "; ")
[16:09:33.054]                         if (!has_future) {
[16:09:33.054]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.054]                             info)
[16:09:33.054]                         }
[16:09:33.054]                         else {
[16:09:33.054]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.054]                             info, version)
[16:09:33.054]                         }
[16:09:33.054]                         base::stop(msg)
[16:09:33.054]                       }
[16:09:33.054]                     })
[16:09:33.054]                   }
[16:09:33.054]                   options(future.plan = NULL)
[16:09:33.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.054]                 }
[16:09:33.054]                 ...future.workdir <- getwd()
[16:09:33.054]             }
[16:09:33.054]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.054]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.054]         }
[16:09:33.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.054]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:33.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.054]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.054]             base::names(...future.oldOptions))
[16:09:33.054]     }
[16:09:33.054]     if (FALSE) {
[16:09:33.054]     }
[16:09:33.054]     else {
[16:09:33.054]         if (TRUE) {
[16:09:33.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.054]                 open = "w")
[16:09:33.054]         }
[16:09:33.054]         else {
[16:09:33.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.054]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.054]         }
[16:09:33.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.054]             base::sink(type = "output", split = FALSE)
[16:09:33.054]             base::close(...future.stdout)
[16:09:33.054]         }, add = TRUE)
[16:09:33.054]     }
[16:09:33.054]     ...future.frame <- base::sys.nframe()
[16:09:33.054]     ...future.conditions <- base::list()
[16:09:33.054]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.054]     if (FALSE) {
[16:09:33.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.054]     }
[16:09:33.054]     ...future.result <- base::tryCatch({
[16:09:33.054]         base::withCallingHandlers({
[16:09:33.054]             ...future.value <- base::withVisible(base::local({
[16:09:33.054]                 do.call(function(...) {
[16:09:33.054]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.054]                   if (!identical(...future.globals.maxSize.org, 
[16:09:33.054]                     ...future.globals.maxSize)) {
[16:09:33.054]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.054]                     on.exit(options(oopts), add = TRUE)
[16:09:33.054]                   }
[16:09:33.054]                   {
[16:09:33.054]                     lapply(seq_along(...future.elements_ii), 
[16:09:33.054]                       FUN = function(jj) {
[16:09:33.054]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.054]                         ...future.FUN(...future.X_jj, ...)
[16:09:33.054]                       })
[16:09:33.054]                   }
[16:09:33.054]                 }, args = future.call.arguments)
[16:09:33.054]             }))
[16:09:33.054]             future::FutureResult(value = ...future.value$value, 
[16:09:33.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.054]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.054]                     ...future.globalenv.names))
[16:09:33.054]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.054]         }, condition = base::local({
[16:09:33.054]             c <- base::c
[16:09:33.054]             inherits <- base::inherits
[16:09:33.054]             invokeRestart <- base::invokeRestart
[16:09:33.054]             length <- base::length
[16:09:33.054]             list <- base::list
[16:09:33.054]             seq.int <- base::seq.int
[16:09:33.054]             signalCondition <- base::signalCondition
[16:09:33.054]             sys.calls <- base::sys.calls
[16:09:33.054]             `[[` <- base::`[[`
[16:09:33.054]             `+` <- base::`+`
[16:09:33.054]             `<<-` <- base::`<<-`
[16:09:33.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.054]                   3L)]
[16:09:33.054]             }
[16:09:33.054]             function(cond) {
[16:09:33.054]                 is_error <- inherits(cond, "error")
[16:09:33.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.054]                   NULL)
[16:09:33.054]                 if (is_error) {
[16:09:33.054]                   sessionInformation <- function() {
[16:09:33.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.054]                       search = base::search(), system = base::Sys.info())
[16:09:33.054]                   }
[16:09:33.054]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.054]                     cond$call), session = sessionInformation(), 
[16:09:33.054]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.054]                   signalCondition(cond)
[16:09:33.054]                 }
[16:09:33.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.054]                 "immediateCondition"))) {
[16:09:33.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.054]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.054]                   if (TRUE && !signal) {
[16:09:33.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.054]                     {
[16:09:33.054]                       inherits <- base::inherits
[16:09:33.054]                       invokeRestart <- base::invokeRestart
[16:09:33.054]                       is.null <- base::is.null
[16:09:33.054]                       muffled <- FALSE
[16:09:33.054]                       if (inherits(cond, "message")) {
[16:09:33.054]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.054]                         if (muffled) 
[16:09:33.054]                           invokeRestart("muffleMessage")
[16:09:33.054]                       }
[16:09:33.054]                       else if (inherits(cond, "warning")) {
[16:09:33.054]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.054]                         if (muffled) 
[16:09:33.054]                           invokeRestart("muffleWarning")
[16:09:33.054]                       }
[16:09:33.054]                       else if (inherits(cond, "condition")) {
[16:09:33.054]                         if (!is.null(pattern)) {
[16:09:33.054]                           computeRestarts <- base::computeRestarts
[16:09:33.054]                           grepl <- base::grepl
[16:09:33.054]                           restarts <- computeRestarts(cond)
[16:09:33.054]                           for (restart in restarts) {
[16:09:33.054]                             name <- restart$name
[16:09:33.054]                             if (is.null(name)) 
[16:09:33.054]                               next
[16:09:33.054]                             if (!grepl(pattern, name)) 
[16:09:33.054]                               next
[16:09:33.054]                             invokeRestart(restart)
[16:09:33.054]                             muffled <- TRUE
[16:09:33.054]                             break
[16:09:33.054]                           }
[16:09:33.054]                         }
[16:09:33.054]                       }
[16:09:33.054]                       invisible(muffled)
[16:09:33.054]                     }
[16:09:33.054]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.054]                   }
[16:09:33.054]                 }
[16:09:33.054]                 else {
[16:09:33.054]                   if (TRUE) {
[16:09:33.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.054]                     {
[16:09:33.054]                       inherits <- base::inherits
[16:09:33.054]                       invokeRestart <- base::invokeRestart
[16:09:33.054]                       is.null <- base::is.null
[16:09:33.054]                       muffled <- FALSE
[16:09:33.054]                       if (inherits(cond, "message")) {
[16:09:33.054]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.054]                         if (muffled) 
[16:09:33.054]                           invokeRestart("muffleMessage")
[16:09:33.054]                       }
[16:09:33.054]                       else if (inherits(cond, "warning")) {
[16:09:33.054]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.054]                         if (muffled) 
[16:09:33.054]                           invokeRestart("muffleWarning")
[16:09:33.054]                       }
[16:09:33.054]                       else if (inherits(cond, "condition")) {
[16:09:33.054]                         if (!is.null(pattern)) {
[16:09:33.054]                           computeRestarts <- base::computeRestarts
[16:09:33.054]                           grepl <- base::grepl
[16:09:33.054]                           restarts <- computeRestarts(cond)
[16:09:33.054]                           for (restart in restarts) {
[16:09:33.054]                             name <- restart$name
[16:09:33.054]                             if (is.null(name)) 
[16:09:33.054]                               next
[16:09:33.054]                             if (!grepl(pattern, name)) 
[16:09:33.054]                               next
[16:09:33.054]                             invokeRestart(restart)
[16:09:33.054]                             muffled <- TRUE
[16:09:33.054]                             break
[16:09:33.054]                           }
[16:09:33.054]                         }
[16:09:33.054]                       }
[16:09:33.054]                       invisible(muffled)
[16:09:33.054]                     }
[16:09:33.054]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.054]                   }
[16:09:33.054]                 }
[16:09:33.054]             }
[16:09:33.054]         }))
[16:09:33.054]     }, error = function(ex) {
[16:09:33.054]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.054]                 ...future.rng), started = ...future.startTime, 
[16:09:33.054]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.054]             version = "1.8"), class = "FutureResult")
[16:09:33.054]     }, finally = {
[16:09:33.054]         if (!identical(...future.workdir, getwd())) 
[16:09:33.054]             setwd(...future.workdir)
[16:09:33.054]         {
[16:09:33.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.054]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.054]             }
[16:09:33.054]             base::options(...future.oldOptions)
[16:09:33.054]             if (.Platform$OS.type == "windows") {
[16:09:33.054]                 old_names <- names(...future.oldEnvVars)
[16:09:33.054]                 envs <- base::Sys.getenv()
[16:09:33.054]                 names <- names(envs)
[16:09:33.054]                 common <- intersect(names, old_names)
[16:09:33.054]                 added <- setdiff(names, old_names)
[16:09:33.054]                 removed <- setdiff(old_names, names)
[16:09:33.054]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.054]                   envs[common]]
[16:09:33.054]                 NAMES <- toupper(changed)
[16:09:33.054]                 args <- list()
[16:09:33.054]                 for (kk in seq_along(NAMES)) {
[16:09:33.054]                   name <- changed[[kk]]
[16:09:33.054]                   NAME <- NAMES[[kk]]
[16:09:33.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.054]                     next
[16:09:33.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.054]                 }
[16:09:33.054]                 NAMES <- toupper(added)
[16:09:33.054]                 for (kk in seq_along(NAMES)) {
[16:09:33.054]                   name <- added[[kk]]
[16:09:33.054]                   NAME <- NAMES[[kk]]
[16:09:33.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.054]                     next
[16:09:33.054]                   args[[name]] <- ""
[16:09:33.054]                 }
[16:09:33.054]                 NAMES <- toupper(removed)
[16:09:33.054]                 for (kk in seq_along(NAMES)) {
[16:09:33.054]                   name <- removed[[kk]]
[16:09:33.054]                   NAME <- NAMES[[kk]]
[16:09:33.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.054]                     next
[16:09:33.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.054]                 }
[16:09:33.054]                 if (length(args) > 0) 
[16:09:33.054]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.054]             }
[16:09:33.054]             else {
[16:09:33.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.054]             }
[16:09:33.054]             {
[16:09:33.054]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.054]                   0L) {
[16:09:33.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.054]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.054]                   base::options(opts)
[16:09:33.054]                 }
[16:09:33.054]                 {
[16:09:33.054]                   {
[16:09:33.054]                     NULL
[16:09:33.054]                     RNGkind("Mersenne-Twister")
[16:09:33.054]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:33.054]                       inherits = FALSE)
[16:09:33.054]                   }
[16:09:33.054]                   options(future.plan = NULL)
[16:09:33.054]                   if (is.na(NA_character_)) 
[16:09:33.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.054]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:33.054]                   {
[16:09:33.054]                     future <- SequentialFuture(..., envir = envir)
[16:09:33.054]                     if (!future$lazy) 
[16:09:33.054]                       future <- run(future)
[16:09:33.054]                     invisible(future)
[16:09:33.054]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.054]                 }
[16:09:33.054]             }
[16:09:33.054]         }
[16:09:33.054]     })
[16:09:33.054]     if (TRUE) {
[16:09:33.054]         base::sink(type = "output", split = FALSE)
[16:09:33.054]         if (TRUE) {
[16:09:33.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.054]         }
[16:09:33.054]         else {
[16:09:33.054]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.054]         }
[16:09:33.054]         base::close(...future.stdout)
[16:09:33.054]         ...future.stdout <- NULL
[16:09:33.054]     }
[16:09:33.054]     ...future.result$conditions <- ...future.conditions
[16:09:33.054]     ...future.result$finished <- base::Sys.time()
[16:09:33.054]     ...future.result
[16:09:33.054] }
[16:09:33.055] assign_globals() ...
[16:09:33.055] List of 5
[16:09:33.055]  $ ...future.FUN            :function (object, ...)  
[16:09:33.055]  $ future.call.arguments    : list()
[16:09:33.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.055]  $ ...future.elements_ii    :List of 3
[16:09:33.055]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.055]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.055]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.055]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.055]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.055]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.055]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.055]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:33.055]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.055]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.055]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.055]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:33.055]  $ ...future.seeds_ii       : NULL
[16:09:33.055]  $ ...future.globals.maxSize: NULL
[16:09:33.055]  - attr(*, "resolved")= logi FALSE
[16:09:33.055]  - attr(*, "total_size")= num 1240
[16:09:33.055]  - attr(*, "where")=List of 5
[16:09:33.055]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.055]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.055]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.055]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.055]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.055]  - attr(*, "already-done")= logi TRUE
[16:09:33.065] - copied ‘...future.FUN’ to environment
[16:09:33.065] - copied ‘future.call.arguments’ to environment
[16:09:33.066] - copied ‘...future.elements_ii’ to environment
[16:09:33.066] - copied ‘...future.seeds_ii’ to environment
[16:09:33.066] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.066] assign_globals() ... done
[16:09:33.066] plan(): Setting new future strategy stack:
[16:09:33.066] List of future strategies:
[16:09:33.066] 1. sequential:
[16:09:33.066]    - args: function (..., envir = parent.frame())
[16:09:33.066]    - tweaked: FALSE
[16:09:33.066]    - call: NULL
[16:09:33.066] plan(): nbrOfWorkers() = 1
[16:09:33.069] plan(): Setting new future strategy stack:
[16:09:33.069] List of future strategies:
[16:09:33.069] 1. sequential:
[16:09:33.069]    - args: function (..., envir = parent.frame())
[16:09:33.069]    - tweaked: FALSE
[16:09:33.069]    - call: plan(strategy)
[16:09:33.069] plan(): nbrOfWorkers() = 1
[16:09:33.069] SequentialFuture started (and completed)
[16:09:33.069] - Launch lazy future ... done
[16:09:33.069] run() for ‘SequentialFuture’ ... done
[16:09:33.070] Created future:
[16:09:33.070] SequentialFuture:
[16:09:33.070] Label: ‘future_by-1’
[16:09:33.070] Expression:
[16:09:33.070] {
[16:09:33.070]     do.call(function(...) {
[16:09:33.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.070]             on.exit(options(oopts), add = TRUE)
[16:09:33.070]         }
[16:09:33.070]         {
[16:09:33.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.070]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.070]             })
[16:09:33.070]         }
[16:09:33.070]     }, args = future.call.arguments)
[16:09:33.070] }
[16:09:33.070] Lazy evaluation: FALSE
[16:09:33.070] Asynchronous evaluation: FALSE
[16:09:33.070] Local evaluation: TRUE
[16:09:33.070] Environment: 0x5567e91ff758
[16:09:33.070] Capture standard output: TRUE
[16:09:33.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.070] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.070] Packages: <none>
[16:09:33.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.070] Resolved: TRUE
[16:09:33.070] Value: 5.37 KiB of class ‘list’
[16:09:33.070] Early signaling: FALSE
[16:09:33.070] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.070] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:33.071] Chunk #1 of 1 ... DONE
[16:09:33.071] Launching 1 futures (chunks) ... DONE
[16:09:33.071] Resolving 1 futures (chunks) ...
[16:09:33.071] resolve() on list ...
[16:09:33.071]  recursive: 0
[16:09:33.071]  length: 1
[16:09:33.071] 
[16:09:33.071] resolved() for ‘SequentialFuture’ ...
[16:09:33.072] - state: ‘finished’
[16:09:33.072] - run: TRUE
[16:09:33.072] - result: ‘FutureResult’
[16:09:33.072] resolved() for ‘SequentialFuture’ ... done
[16:09:33.072] Future #1
[16:09:33.072] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:33.072] - nx: 1
[16:09:33.072] - relay: TRUE
[16:09:33.072] - stdout: TRUE
[16:09:33.072] - signal: TRUE
[16:09:33.072] - resignal: FALSE
[16:09:33.073] - force: TRUE
[16:09:33.073] - relayed: [n=1] FALSE
[16:09:33.073] - queued futures: [n=1] FALSE
[16:09:33.073]  - until=1
[16:09:33.073]  - relaying element #1
[16:09:33.073] - relayed: [n=1] TRUE
[16:09:33.073] - queued futures: [n=1] TRUE
[16:09:33.073] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:33.073]  length: 0 (resolved future 1)
[16:09:33.073] Relaying remaining futures
[16:09:33.074] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.074] - nx: 1
[16:09:33.074] - relay: TRUE
[16:09:33.074] - stdout: TRUE
[16:09:33.074] - signal: TRUE
[16:09:33.074] - resignal: FALSE
[16:09:33.074] - force: TRUE
[16:09:33.074] - relayed: [n=1] TRUE
[16:09:33.074] - queued futures: [n=1] TRUE
 - flush all
[16:09:33.074] - relayed: [n=1] TRUE
[16:09:33.074] - queued futures: [n=1] TRUE
[16:09:33.075] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.075] resolve() on list ... DONE
[16:09:33.075]  - Number of value chunks collected: 1
[16:09:33.075] Resolving 1 futures (chunks) ... DONE
[16:09:33.075] Reducing values from 1 chunks ...
[16:09:33.075]  - Number of values collected after concatenation: 3
[16:09:33.075]  - Number of values expected: 3
[16:09:33.075] Reducing values from 1 chunks ... DONE
[16:09:33.077] future_lapply() ... DONE
[16:09:33.077] future_by_internal() ... DONE
[16:09:33.077] future_by_internal() ...
- plan('multicore') ...
[16:09:33.078] plan(): Setting new future strategy stack:
[16:09:33.078] List of future strategies:
[16:09:33.078] 1. multicore:
[16:09:33.078]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.078]    - tweaked: FALSE
[16:09:33.078]    - call: plan(strategy)
[16:09:33.082] plan(): nbrOfWorkers() = 2
[16:09:33.082] future_by_internal() ...
[16:09:33.082] future_lapply() ...
[16:09:33.087] Number of chunks: 2
[16:09:33.087] getGlobalsAndPackagesXApply() ...
[16:09:33.087]  - future.globals: TRUE
[16:09:33.087] getGlobalsAndPackages() ...
[16:09:33.087] Searching for globals...
[16:09:33.088] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:33.088] Searching for globals ... DONE
[16:09:33.088] Resolving globals: FALSE
[16:09:33.089] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:33.089] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:33.089] - globals: [1] ‘FUN’
[16:09:33.089] 
[16:09:33.089] getGlobalsAndPackages() ... DONE
[16:09:33.089]  - globals found/used: [n=1] ‘FUN’
[16:09:33.089]  - needed namespaces: [n=0] 
[16:09:33.090] Finding globals ... DONE
[16:09:33.090]  - use_args: TRUE
[16:09:33.090]  - Getting '...' globals ...
[16:09:33.090] resolve() on list ...
[16:09:33.090]  recursive: 0
[16:09:33.090]  length: 1
[16:09:33.090]  elements: ‘...’
[16:09:33.090]  length: 0 (resolved future 1)
[16:09:33.090] resolve() on list ... DONE
[16:09:33.091]    - '...' content: [n=0] 
[16:09:33.091] List of 1
[16:09:33.091]  $ ...: list()
[16:09:33.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.091]  - attr(*, "where")=List of 1
[16:09:33.091]   ..$ ...:<environment: 0x5567e929cbc0> 
[16:09:33.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.091]  - attr(*, "resolved")= logi TRUE
[16:09:33.091]  - attr(*, "total_size")= num NA
[16:09:33.093]  - Getting '...' globals ... DONE
[16:09:33.093] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.093] List of 2
[16:09:33.093]  $ ...future.FUN:function (object, ...)  
[16:09:33.093]  $ ...          : list()
[16:09:33.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.093]  - attr(*, "where")=List of 2
[16:09:33.093]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.093]   ..$ ...          :<environment: 0x5567e929cbc0> 
[16:09:33.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.093]  - attr(*, "resolved")= logi FALSE
[16:09:33.093]  - attr(*, "total_size")= num 1240
[16:09:33.096] Packages to be attached in all futures: [n=0] 
[16:09:33.096] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.096] Number of futures (= number of chunks): 2
[16:09:33.096] Launching 2 futures (chunks) ...
[16:09:33.096] Chunk #1 of 2 ...
[16:09:33.096]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.096] getGlobalsAndPackages() ...
[16:09:33.097] Searching for globals...
[16:09:33.097] 
[16:09:33.097] Searching for globals ... DONE
[16:09:33.097] - globals: [0] <none>
[16:09:33.097] getGlobalsAndPackages() ... DONE
[16:09:33.097]    + additional globals found: [n=0] 
[16:09:33.097]    + additional namespaces needed: [n=0] 
[16:09:33.097]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.097]  - seeds: <none>
[16:09:33.098] getGlobalsAndPackages() ...
[16:09:33.098] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.098] Resolving globals: FALSE
[16:09:33.098] Tweak future expression to call with '...' arguments ...
[16:09:33.098] {
[16:09:33.098]     do.call(function(...) {
[16:09:33.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.098]             on.exit(options(oopts), add = TRUE)
[16:09:33.098]         }
[16:09:33.098]         {
[16:09:33.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.098]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.098]             })
[16:09:33.098]         }
[16:09:33.098]     }, args = future.call.arguments)
[16:09:33.098] }
[16:09:33.098] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.100] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.100] 
[16:09:33.100] getGlobalsAndPackages() ... DONE
[16:09:33.100] run() for ‘Future’ ...
[16:09:33.100] - state: ‘created’
[16:09:33.101] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.104] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.104]   - Field: ‘label’
[16:09:33.105]   - Field: ‘local’
[16:09:33.105]   - Field: ‘owner’
[16:09:33.105]   - Field: ‘envir’
[16:09:33.105]   - Field: ‘workers’
[16:09:33.105]   - Field: ‘packages’
[16:09:33.105]   - Field: ‘gc’
[16:09:33.105]   - Field: ‘job’
[16:09:33.105]   - Field: ‘conditions’
[16:09:33.105]   - Field: ‘expr’
[16:09:33.105]   - Field: ‘uuid’
[16:09:33.106]   - Field: ‘seed’
[16:09:33.106]   - Field: ‘version’
[16:09:33.106]   - Field: ‘result’
[16:09:33.106]   - Field: ‘asynchronous’
[16:09:33.106]   - Field: ‘calls’
[16:09:33.106]   - Field: ‘globals’
[16:09:33.106]   - Field: ‘stdout’
[16:09:33.106]   - Field: ‘earlySignal’
[16:09:33.106]   - Field: ‘lazy’
[16:09:33.106]   - Field: ‘state’
[16:09:33.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.107] - Launch lazy future ...
[16:09:33.108] Packages needed by the future expression (n = 0): <none>
[16:09:33.108] Packages needed by future strategies (n = 0): <none>
[16:09:33.108] {
[16:09:33.108]     {
[16:09:33.108]         {
[16:09:33.108]             ...future.startTime <- base::Sys.time()
[16:09:33.108]             {
[16:09:33.108]                 {
[16:09:33.108]                   {
[16:09:33.108]                     {
[16:09:33.108]                       base::local({
[16:09:33.108]                         has_future <- base::requireNamespace("future", 
[16:09:33.108]                           quietly = TRUE)
[16:09:33.108]                         if (has_future) {
[16:09:33.108]                           ns <- base::getNamespace("future")
[16:09:33.108]                           version <- ns[[".package"]][["version"]]
[16:09:33.108]                           if (is.null(version)) 
[16:09:33.108]                             version <- utils::packageVersion("future")
[16:09:33.108]                         }
[16:09:33.108]                         else {
[16:09:33.108]                           version <- NULL
[16:09:33.108]                         }
[16:09:33.108]                         if (!has_future || version < "1.8.0") {
[16:09:33.108]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.108]                             "", base::R.version$version.string), 
[16:09:33.108]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.108]                               "release", "version")], collapse = " "), 
[16:09:33.108]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.108]                             info)
[16:09:33.108]                           info <- base::paste(info, collapse = "; ")
[16:09:33.108]                           if (!has_future) {
[16:09:33.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.108]                               info)
[16:09:33.108]                           }
[16:09:33.108]                           else {
[16:09:33.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.108]                               info, version)
[16:09:33.108]                           }
[16:09:33.108]                           base::stop(msg)
[16:09:33.108]                         }
[16:09:33.108]                       })
[16:09:33.108]                     }
[16:09:33.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.108]                     base::options(mc.cores = 1L)
[16:09:33.108]                   }
[16:09:33.108]                   options(future.plan = NULL)
[16:09:33.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.108]                 }
[16:09:33.108]                 ...future.workdir <- getwd()
[16:09:33.108]             }
[16:09:33.108]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.108]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.108]         }
[16:09:33.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:33.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.108]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.108]             base::names(...future.oldOptions))
[16:09:33.108]     }
[16:09:33.108]     if (FALSE) {
[16:09:33.108]     }
[16:09:33.108]     else {
[16:09:33.108]         if (TRUE) {
[16:09:33.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.108]                 open = "w")
[16:09:33.108]         }
[16:09:33.108]         else {
[16:09:33.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.108]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.108]         }
[16:09:33.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.108]             base::sink(type = "output", split = FALSE)
[16:09:33.108]             base::close(...future.stdout)
[16:09:33.108]         }, add = TRUE)
[16:09:33.108]     }
[16:09:33.108]     ...future.frame <- base::sys.nframe()
[16:09:33.108]     ...future.conditions <- base::list()
[16:09:33.108]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.108]     if (FALSE) {
[16:09:33.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.108]     }
[16:09:33.108]     ...future.result <- base::tryCatch({
[16:09:33.108]         base::withCallingHandlers({
[16:09:33.108]             ...future.value <- base::withVisible(base::local({
[16:09:33.108]                 withCallingHandlers({
[16:09:33.108]                   {
[16:09:33.108]                     do.call(function(...) {
[16:09:33.108]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.108]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.108]                         ...future.globals.maxSize)) {
[16:09:33.108]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.108]                         on.exit(options(oopts), add = TRUE)
[16:09:33.108]                       }
[16:09:33.108]                       {
[16:09:33.108]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.108]                           FUN = function(jj) {
[16:09:33.108]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.108]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.108]                           })
[16:09:33.108]                       }
[16:09:33.108]                     }, args = future.call.arguments)
[16:09:33.108]                   }
[16:09:33.108]                 }, immediateCondition = function(cond) {
[16:09:33.108]                   save_rds <- function (object, pathname, ...) 
[16:09:33.108]                   {
[16:09:33.108]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.108]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.108]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.108]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.108]                         fi_tmp[["mtime"]])
[16:09:33.108]                     }
[16:09:33.108]                     tryCatch({
[16:09:33.108]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.108]                     }, error = function(ex) {
[16:09:33.108]                       msg <- conditionMessage(ex)
[16:09:33.108]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.108]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.108]                         fi_tmp[["mtime"]], msg)
[16:09:33.108]                       ex$message <- msg
[16:09:33.108]                       stop(ex)
[16:09:33.108]                     })
[16:09:33.108]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.108]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.108]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.108]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.108]                       fi <- file.info(pathname)
[16:09:33.108]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.108]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.108]                         fi[["size"]], fi[["mtime"]])
[16:09:33.108]                       stop(msg)
[16:09:33.108]                     }
[16:09:33.108]                     invisible(pathname)
[16:09:33.108]                   }
[16:09:33.108]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.108]                     rootPath = tempdir()) 
[16:09:33.108]                   {
[16:09:33.108]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.108]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.108]                       tmpdir = path, fileext = ".rds")
[16:09:33.108]                     save_rds(obj, file)
[16:09:33.108]                   }
[16:09:33.108]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.108]                   {
[16:09:33.108]                     inherits <- base::inherits
[16:09:33.108]                     invokeRestart <- base::invokeRestart
[16:09:33.108]                     is.null <- base::is.null
[16:09:33.108]                     muffled <- FALSE
[16:09:33.108]                     if (inherits(cond, "message")) {
[16:09:33.108]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.108]                       if (muffled) 
[16:09:33.108]                         invokeRestart("muffleMessage")
[16:09:33.108]                     }
[16:09:33.108]                     else if (inherits(cond, "warning")) {
[16:09:33.108]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.108]                       if (muffled) 
[16:09:33.108]                         invokeRestart("muffleWarning")
[16:09:33.108]                     }
[16:09:33.108]                     else if (inherits(cond, "condition")) {
[16:09:33.108]                       if (!is.null(pattern)) {
[16:09:33.108]                         computeRestarts <- base::computeRestarts
[16:09:33.108]                         grepl <- base::grepl
[16:09:33.108]                         restarts <- computeRestarts(cond)
[16:09:33.108]                         for (restart in restarts) {
[16:09:33.108]                           name <- restart$name
[16:09:33.108]                           if (is.null(name)) 
[16:09:33.108]                             next
[16:09:33.108]                           if (!grepl(pattern, name)) 
[16:09:33.108]                             next
[16:09:33.108]                           invokeRestart(restart)
[16:09:33.108]                           muffled <- TRUE
[16:09:33.108]                           break
[16:09:33.108]                         }
[16:09:33.108]                       }
[16:09:33.108]                     }
[16:09:33.108]                     invisible(muffled)
[16:09:33.108]                   }
[16:09:33.108]                   muffleCondition(cond)
[16:09:33.108]                 })
[16:09:33.108]             }))
[16:09:33.108]             future::FutureResult(value = ...future.value$value, 
[16:09:33.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.108]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.108]                     ...future.globalenv.names))
[16:09:33.108]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.108]         }, condition = base::local({
[16:09:33.108]             c <- base::c
[16:09:33.108]             inherits <- base::inherits
[16:09:33.108]             invokeRestart <- base::invokeRestart
[16:09:33.108]             length <- base::length
[16:09:33.108]             list <- base::list
[16:09:33.108]             seq.int <- base::seq.int
[16:09:33.108]             signalCondition <- base::signalCondition
[16:09:33.108]             sys.calls <- base::sys.calls
[16:09:33.108]             `[[` <- base::`[[`
[16:09:33.108]             `+` <- base::`+`
[16:09:33.108]             `<<-` <- base::`<<-`
[16:09:33.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.108]                   3L)]
[16:09:33.108]             }
[16:09:33.108]             function(cond) {
[16:09:33.108]                 is_error <- inherits(cond, "error")
[16:09:33.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.108]                   NULL)
[16:09:33.108]                 if (is_error) {
[16:09:33.108]                   sessionInformation <- function() {
[16:09:33.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.108]                       search = base::search(), system = base::Sys.info())
[16:09:33.108]                   }
[16:09:33.108]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.108]                     cond$call), session = sessionInformation(), 
[16:09:33.108]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.108]                   signalCondition(cond)
[16:09:33.108]                 }
[16:09:33.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.108]                 "immediateCondition"))) {
[16:09:33.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.108]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.108]                   if (TRUE && !signal) {
[16:09:33.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.108]                     {
[16:09:33.108]                       inherits <- base::inherits
[16:09:33.108]                       invokeRestart <- base::invokeRestart
[16:09:33.108]                       is.null <- base::is.null
[16:09:33.108]                       muffled <- FALSE
[16:09:33.108]                       if (inherits(cond, "message")) {
[16:09:33.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.108]                         if (muffled) 
[16:09:33.108]                           invokeRestart("muffleMessage")
[16:09:33.108]                       }
[16:09:33.108]                       else if (inherits(cond, "warning")) {
[16:09:33.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.108]                         if (muffled) 
[16:09:33.108]                           invokeRestart("muffleWarning")
[16:09:33.108]                       }
[16:09:33.108]                       else if (inherits(cond, "condition")) {
[16:09:33.108]                         if (!is.null(pattern)) {
[16:09:33.108]                           computeRestarts <- base::computeRestarts
[16:09:33.108]                           grepl <- base::grepl
[16:09:33.108]                           restarts <- computeRestarts(cond)
[16:09:33.108]                           for (restart in restarts) {
[16:09:33.108]                             name <- restart$name
[16:09:33.108]                             if (is.null(name)) 
[16:09:33.108]                               next
[16:09:33.108]                             if (!grepl(pattern, name)) 
[16:09:33.108]                               next
[16:09:33.108]                             invokeRestart(restart)
[16:09:33.108]                             muffled <- TRUE
[16:09:33.108]                             break
[16:09:33.108]                           }
[16:09:33.108]                         }
[16:09:33.108]                       }
[16:09:33.108]                       invisible(muffled)
[16:09:33.108]                     }
[16:09:33.108]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.108]                   }
[16:09:33.108]                 }
[16:09:33.108]                 else {
[16:09:33.108]                   if (TRUE) {
[16:09:33.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.108]                     {
[16:09:33.108]                       inherits <- base::inherits
[16:09:33.108]                       invokeRestart <- base::invokeRestart
[16:09:33.108]                       is.null <- base::is.null
[16:09:33.108]                       muffled <- FALSE
[16:09:33.108]                       if (inherits(cond, "message")) {
[16:09:33.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.108]                         if (muffled) 
[16:09:33.108]                           invokeRestart("muffleMessage")
[16:09:33.108]                       }
[16:09:33.108]                       else if (inherits(cond, "warning")) {
[16:09:33.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.108]                         if (muffled) 
[16:09:33.108]                           invokeRestart("muffleWarning")
[16:09:33.108]                       }
[16:09:33.108]                       else if (inherits(cond, "condition")) {
[16:09:33.108]                         if (!is.null(pattern)) {
[16:09:33.108]                           computeRestarts <- base::computeRestarts
[16:09:33.108]                           grepl <- base::grepl
[16:09:33.108]                           restarts <- computeRestarts(cond)
[16:09:33.108]                           for (restart in restarts) {
[16:09:33.108]                             name <- restart$name
[16:09:33.108]                             if (is.null(name)) 
[16:09:33.108]                               next
[16:09:33.108]                             if (!grepl(pattern, name)) 
[16:09:33.108]                               next
[16:09:33.108]                             invokeRestart(restart)
[16:09:33.108]                             muffled <- TRUE
[16:09:33.108]                             break
[16:09:33.108]                           }
[16:09:33.108]                         }
[16:09:33.108]                       }
[16:09:33.108]                       invisible(muffled)
[16:09:33.108]                     }
[16:09:33.108]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.108]                   }
[16:09:33.108]                 }
[16:09:33.108]             }
[16:09:33.108]         }))
[16:09:33.108]     }, error = function(ex) {
[16:09:33.108]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.108]                 ...future.rng), started = ...future.startTime, 
[16:09:33.108]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.108]             version = "1.8"), class = "FutureResult")
[16:09:33.108]     }, finally = {
[16:09:33.108]         if (!identical(...future.workdir, getwd())) 
[16:09:33.108]             setwd(...future.workdir)
[16:09:33.108]         {
[16:09:33.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.108]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.108]             }
[16:09:33.108]             base::options(...future.oldOptions)
[16:09:33.108]             if (.Platform$OS.type == "windows") {
[16:09:33.108]                 old_names <- names(...future.oldEnvVars)
[16:09:33.108]                 envs <- base::Sys.getenv()
[16:09:33.108]                 names <- names(envs)
[16:09:33.108]                 common <- intersect(names, old_names)
[16:09:33.108]                 added <- setdiff(names, old_names)
[16:09:33.108]                 removed <- setdiff(old_names, names)
[16:09:33.108]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.108]                   envs[common]]
[16:09:33.108]                 NAMES <- toupper(changed)
[16:09:33.108]                 args <- list()
[16:09:33.108]                 for (kk in seq_along(NAMES)) {
[16:09:33.108]                   name <- changed[[kk]]
[16:09:33.108]                   NAME <- NAMES[[kk]]
[16:09:33.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.108]                     next
[16:09:33.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.108]                 }
[16:09:33.108]                 NAMES <- toupper(added)
[16:09:33.108]                 for (kk in seq_along(NAMES)) {
[16:09:33.108]                   name <- added[[kk]]
[16:09:33.108]                   NAME <- NAMES[[kk]]
[16:09:33.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.108]                     next
[16:09:33.108]                   args[[name]] <- ""
[16:09:33.108]                 }
[16:09:33.108]                 NAMES <- toupper(removed)
[16:09:33.108]                 for (kk in seq_along(NAMES)) {
[16:09:33.108]                   name <- removed[[kk]]
[16:09:33.108]                   NAME <- NAMES[[kk]]
[16:09:33.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.108]                     next
[16:09:33.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.108]                 }
[16:09:33.108]                 if (length(args) > 0) 
[16:09:33.108]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.108]             }
[16:09:33.108]             else {
[16:09:33.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.108]             }
[16:09:33.108]             {
[16:09:33.108]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.108]                   0L) {
[16:09:33.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.108]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.108]                   base::options(opts)
[16:09:33.108]                 }
[16:09:33.108]                 {
[16:09:33.108]                   {
[16:09:33.108]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.108]                     NULL
[16:09:33.108]                   }
[16:09:33.108]                   options(future.plan = NULL)
[16:09:33.108]                   if (is.na(NA_character_)) 
[16:09:33.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.108]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.108]                     envir = parent.frame()) 
[16:09:33.108]                   {
[16:09:33.108]                     default_workers <- missing(workers)
[16:09:33.108]                     if (is.function(workers)) 
[16:09:33.108]                       workers <- workers()
[16:09:33.108]                     workers <- structure(as.integer(workers), 
[16:09:33.108]                       class = class(workers))
[16:09:33.108]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.108]                       1L)
[16:09:33.108]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.108]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.108]                       if (default_workers) 
[16:09:33.108]                         supportsMulticore(warn = TRUE)
[16:09:33.108]                       return(sequential(..., envir = envir))
[16:09:33.108]                     }
[16:09:33.108]                     oopts <- options(mc.cores = workers)
[16:09:33.108]                     on.exit(options(oopts))
[16:09:33.108]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.108]                       envir = envir)
[16:09:33.108]                     if (!future$lazy) 
[16:09:33.108]                       future <- run(future)
[16:09:33.108]                     invisible(future)
[16:09:33.108]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.108]                 }
[16:09:33.108]             }
[16:09:33.108]         }
[16:09:33.108]     })
[16:09:33.108]     if (TRUE) {
[16:09:33.108]         base::sink(type = "output", split = FALSE)
[16:09:33.108]         if (TRUE) {
[16:09:33.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.108]         }
[16:09:33.108]         else {
[16:09:33.108]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.108]         }
[16:09:33.108]         base::close(...future.stdout)
[16:09:33.108]         ...future.stdout <- NULL
[16:09:33.108]     }
[16:09:33.108]     ...future.result$conditions <- ...future.conditions
[16:09:33.108]     ...future.result$finished <- base::Sys.time()
[16:09:33.108]     ...future.result
[16:09:33.108] }
[16:09:33.111] assign_globals() ...
[16:09:33.111] List of 5
[16:09:33.111]  $ ...future.FUN            :function (object, ...)  
[16:09:33.111]  $ future.call.arguments    : list()
[16:09:33.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.111]  $ ...future.elements_ii    :List of 1
[16:09:33.111]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:33.111]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.111]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.111]  $ ...future.seeds_ii       : NULL
[16:09:33.111]  $ ...future.globals.maxSize: NULL
[16:09:33.111]  - attr(*, "where")=List of 5
[16:09:33.111]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.111]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.111]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.111]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.111]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.111]  - attr(*, "resolved")= logi FALSE
[16:09:33.111]  - attr(*, "total_size")= num 1240
[16:09:33.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.111]  - attr(*, "already-done")= logi TRUE
[16:09:33.116] - copied ‘...future.FUN’ to environment
[16:09:33.116] - copied ‘future.call.arguments’ to environment
[16:09:33.116] - copied ‘...future.elements_ii’ to environment
[16:09:33.116] - copied ‘...future.seeds_ii’ to environment
[16:09:33.116] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.116] assign_globals() ... done
[16:09:33.116] requestCore(): workers = 2
[16:09:33.119] MulticoreFuture started
[16:09:33.120] - Launch lazy future ... done
[16:09:33.120] plan(): Setting new future strategy stack:
[16:09:33.120] run() for ‘MulticoreFuture’ ... done
[16:09:33.120] Created future:
[16:09:33.120] List of future strategies:
[16:09:33.120] 1. sequential:
[16:09:33.120]    - args: function (..., envir = parent.frame())
[16:09:33.120]    - tweaked: FALSE
[16:09:33.120]    - call: NULL
[16:09:33.121] plan(): nbrOfWorkers() = 1
[16:09:33.124] plan(): Setting new future strategy stack:
[16:09:33.124] List of future strategies:
[16:09:33.124] 1. multicore:
[16:09:33.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.124]    - tweaked: FALSE
[16:09:33.124]    - call: plan(strategy)
[16:09:33.129] plan(): nbrOfWorkers() = 2
[16:09:33.121] MulticoreFuture:
[16:09:33.121] Label: ‘future_by-1’
[16:09:33.121] Expression:
[16:09:33.121] {
[16:09:33.121]     do.call(function(...) {
[16:09:33.121]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.121]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.121]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.121]             on.exit(options(oopts), add = TRUE)
[16:09:33.121]         }
[16:09:33.121]         {
[16:09:33.121]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.121]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.121]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.121]             })
[16:09:33.121]         }
[16:09:33.121]     }, args = future.call.arguments)
[16:09:33.121] }
[16:09:33.121] Lazy evaluation: FALSE
[16:09:33.121] Asynchronous evaluation: TRUE
[16:09:33.121] Local evaluation: TRUE
[16:09:33.121] Environment: R_GlobalEnv
[16:09:33.121] Capture standard output: TRUE
[16:09:33.121] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.121] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.121] Packages: <none>
[16:09:33.121] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.121] Resolved: TRUE
[16:09:33.121] Value: <not collected>
[16:09:33.121] Conditions captured: <none>
[16:09:33.121] Early signaling: FALSE
[16:09:33.121] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.121] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.130] Chunk #1 of 2 ... DONE
[16:09:33.131] Chunk #2 of 2 ...
[16:09:33.131]  - Finding globals in 'X' for chunk #2 ...
[16:09:33.131] getGlobalsAndPackages() ...
[16:09:33.131] Searching for globals...
[16:09:33.132] 
[16:09:33.132] Searching for globals ... DONE
[16:09:33.132] - globals: [0] <none>
[16:09:33.132] getGlobalsAndPackages() ... DONE
[16:09:33.133]    + additional globals found: [n=0] 
[16:09:33.133]    + additional namespaces needed: [n=0] 
[16:09:33.133]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:33.133]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:33.133]  - seeds: <none>
[16:09:33.134] getGlobalsAndPackages() ...
[16:09:33.134] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.134] Resolving globals: FALSE
[16:09:33.134] Tweak future expression to call with '...' arguments ...
[16:09:33.134] {
[16:09:33.134]     do.call(function(...) {
[16:09:33.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.134]             on.exit(options(oopts), add = TRUE)
[16:09:33.134]         }
[16:09:33.134]         {
[16:09:33.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.134]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.134]             })
[16:09:33.134]         }
[16:09:33.134]     }, args = future.call.arguments)
[16:09:33.134] }
[16:09:33.135] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.136] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.142] 
[16:09:33.142] getGlobalsAndPackages() ... DONE
[16:09:33.143] run() for ‘Future’ ...
[16:09:33.144] - state: ‘created’
[16:09:33.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.151]   - Field: ‘label’
[16:09:33.151]   - Field: ‘local’
[16:09:33.151]   - Field: ‘owner’
[16:09:33.151]   - Field: ‘envir’
[16:09:33.152]   - Field: ‘workers’
[16:09:33.152]   - Field: ‘packages’
[16:09:33.152]   - Field: ‘gc’
[16:09:33.153]   - Field: ‘job’
[16:09:33.153]   - Field: ‘conditions’
[16:09:33.153]   - Field: ‘expr’
[16:09:33.153]   - Field: ‘uuid’
[16:09:33.153]   - Field: ‘seed’
[16:09:33.154]   - Field: ‘version’
[16:09:33.154]   - Field: ‘result’
[16:09:33.154]   - Field: ‘asynchronous’
[16:09:33.154]   - Field: ‘calls’
[16:09:33.154]   - Field: ‘globals’
[16:09:33.154]   - Field: ‘stdout’
[16:09:33.154]   - Field: ‘earlySignal’
[16:09:33.155]   - Field: ‘lazy’
[16:09:33.155]   - Field: ‘state’
[16:09:33.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.155] - Launch lazy future ...
[16:09:33.155] Packages needed by the future expression (n = 0): <none>
[16:09:33.156] Packages needed by future strategies (n = 0): <none>
[16:09:33.156] {
[16:09:33.156]     {
[16:09:33.156]         {
[16:09:33.156]             ...future.startTime <- base::Sys.time()
[16:09:33.156]             {
[16:09:33.156]                 {
[16:09:33.156]                   {
[16:09:33.156]                     {
[16:09:33.156]                       base::local({
[16:09:33.156]                         has_future <- base::requireNamespace("future", 
[16:09:33.156]                           quietly = TRUE)
[16:09:33.156]                         if (has_future) {
[16:09:33.156]                           ns <- base::getNamespace("future")
[16:09:33.156]                           version <- ns[[".package"]][["version"]]
[16:09:33.156]                           if (is.null(version)) 
[16:09:33.156]                             version <- utils::packageVersion("future")
[16:09:33.156]                         }
[16:09:33.156]                         else {
[16:09:33.156]                           version <- NULL
[16:09:33.156]                         }
[16:09:33.156]                         if (!has_future || version < "1.8.0") {
[16:09:33.156]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.156]                             "", base::R.version$version.string), 
[16:09:33.156]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.156]                               "release", "version")], collapse = " "), 
[16:09:33.156]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.156]                             info)
[16:09:33.156]                           info <- base::paste(info, collapse = "; ")
[16:09:33.156]                           if (!has_future) {
[16:09:33.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.156]                               info)
[16:09:33.156]                           }
[16:09:33.156]                           else {
[16:09:33.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.156]                               info, version)
[16:09:33.156]                           }
[16:09:33.156]                           base::stop(msg)
[16:09:33.156]                         }
[16:09:33.156]                       })
[16:09:33.156]                     }
[16:09:33.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.156]                     base::options(mc.cores = 1L)
[16:09:33.156]                   }
[16:09:33.156]                   options(future.plan = NULL)
[16:09:33.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.156]                 }
[16:09:33.156]                 ...future.workdir <- getwd()
[16:09:33.156]             }
[16:09:33.156]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.156]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.156]         }
[16:09:33.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.156]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:33.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.156]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.156]             base::names(...future.oldOptions))
[16:09:33.156]     }
[16:09:33.156]     if (FALSE) {
[16:09:33.156]     }
[16:09:33.156]     else {
[16:09:33.156]         if (TRUE) {
[16:09:33.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.156]                 open = "w")
[16:09:33.156]         }
[16:09:33.156]         else {
[16:09:33.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.156]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.156]         }
[16:09:33.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.156]             base::sink(type = "output", split = FALSE)
[16:09:33.156]             base::close(...future.stdout)
[16:09:33.156]         }, add = TRUE)
[16:09:33.156]     }
[16:09:33.156]     ...future.frame <- base::sys.nframe()
[16:09:33.156]     ...future.conditions <- base::list()
[16:09:33.156]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.156]     if (FALSE) {
[16:09:33.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.156]     }
[16:09:33.156]     ...future.result <- base::tryCatch({
[16:09:33.156]         base::withCallingHandlers({
[16:09:33.156]             ...future.value <- base::withVisible(base::local({
[16:09:33.156]                 withCallingHandlers({
[16:09:33.156]                   {
[16:09:33.156]                     do.call(function(...) {
[16:09:33.156]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.156]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.156]                         ...future.globals.maxSize)) {
[16:09:33.156]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.156]                         on.exit(options(oopts), add = TRUE)
[16:09:33.156]                       }
[16:09:33.156]                       {
[16:09:33.156]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.156]                           FUN = function(jj) {
[16:09:33.156]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.156]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.156]                           })
[16:09:33.156]                       }
[16:09:33.156]                     }, args = future.call.arguments)
[16:09:33.156]                   }
[16:09:33.156]                 }, immediateCondition = function(cond) {
[16:09:33.156]                   save_rds <- function (object, pathname, ...) 
[16:09:33.156]                   {
[16:09:33.156]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.156]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.156]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.156]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.156]                         fi_tmp[["mtime"]])
[16:09:33.156]                     }
[16:09:33.156]                     tryCatch({
[16:09:33.156]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.156]                     }, error = function(ex) {
[16:09:33.156]                       msg <- conditionMessage(ex)
[16:09:33.156]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.156]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.156]                         fi_tmp[["mtime"]], msg)
[16:09:33.156]                       ex$message <- msg
[16:09:33.156]                       stop(ex)
[16:09:33.156]                     })
[16:09:33.156]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.156]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.156]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.156]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.156]                       fi <- file.info(pathname)
[16:09:33.156]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.156]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.156]                         fi[["size"]], fi[["mtime"]])
[16:09:33.156]                       stop(msg)
[16:09:33.156]                     }
[16:09:33.156]                     invisible(pathname)
[16:09:33.156]                   }
[16:09:33.156]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.156]                     rootPath = tempdir()) 
[16:09:33.156]                   {
[16:09:33.156]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.156]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.156]                       tmpdir = path, fileext = ".rds")
[16:09:33.156]                     save_rds(obj, file)
[16:09:33.156]                   }
[16:09:33.156]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.156]                   {
[16:09:33.156]                     inherits <- base::inherits
[16:09:33.156]                     invokeRestart <- base::invokeRestart
[16:09:33.156]                     is.null <- base::is.null
[16:09:33.156]                     muffled <- FALSE
[16:09:33.156]                     if (inherits(cond, "message")) {
[16:09:33.156]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.156]                       if (muffled) 
[16:09:33.156]                         invokeRestart("muffleMessage")
[16:09:33.156]                     }
[16:09:33.156]                     else if (inherits(cond, "warning")) {
[16:09:33.156]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.156]                       if (muffled) 
[16:09:33.156]                         invokeRestart("muffleWarning")
[16:09:33.156]                     }
[16:09:33.156]                     else if (inherits(cond, "condition")) {
[16:09:33.156]                       if (!is.null(pattern)) {
[16:09:33.156]                         computeRestarts <- base::computeRestarts
[16:09:33.156]                         grepl <- base::grepl
[16:09:33.156]                         restarts <- computeRestarts(cond)
[16:09:33.156]                         for (restart in restarts) {
[16:09:33.156]                           name <- restart$name
[16:09:33.156]                           if (is.null(name)) 
[16:09:33.156]                             next
[16:09:33.156]                           if (!grepl(pattern, name)) 
[16:09:33.156]                             next
[16:09:33.156]                           invokeRestart(restart)
[16:09:33.156]                           muffled <- TRUE
[16:09:33.156]                           break
[16:09:33.156]                         }
[16:09:33.156]                       }
[16:09:33.156]                     }
[16:09:33.156]                     invisible(muffled)
[16:09:33.156]                   }
[16:09:33.156]                   muffleCondition(cond)
[16:09:33.156]                 })
[16:09:33.156]             }))
[16:09:33.156]             future::FutureResult(value = ...future.value$value, 
[16:09:33.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.156]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.156]                     ...future.globalenv.names))
[16:09:33.156]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.156]         }, condition = base::local({
[16:09:33.156]             c <- base::c
[16:09:33.156]             inherits <- base::inherits
[16:09:33.156]             invokeRestart <- base::invokeRestart
[16:09:33.156]             length <- base::length
[16:09:33.156]             list <- base::list
[16:09:33.156]             seq.int <- base::seq.int
[16:09:33.156]             signalCondition <- base::signalCondition
[16:09:33.156]             sys.calls <- base::sys.calls
[16:09:33.156]             `[[` <- base::`[[`
[16:09:33.156]             `+` <- base::`+`
[16:09:33.156]             `<<-` <- base::`<<-`
[16:09:33.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.156]                   3L)]
[16:09:33.156]             }
[16:09:33.156]             function(cond) {
[16:09:33.156]                 is_error <- inherits(cond, "error")
[16:09:33.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.156]                   NULL)
[16:09:33.156]                 if (is_error) {
[16:09:33.156]                   sessionInformation <- function() {
[16:09:33.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.156]                       search = base::search(), system = base::Sys.info())
[16:09:33.156]                   }
[16:09:33.156]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.156]                     cond$call), session = sessionInformation(), 
[16:09:33.156]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.156]                   signalCondition(cond)
[16:09:33.156]                 }
[16:09:33.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.156]                 "immediateCondition"))) {
[16:09:33.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.156]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.156]                   if (TRUE && !signal) {
[16:09:33.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.156]                     {
[16:09:33.156]                       inherits <- base::inherits
[16:09:33.156]                       invokeRestart <- base::invokeRestart
[16:09:33.156]                       is.null <- base::is.null
[16:09:33.156]                       muffled <- FALSE
[16:09:33.156]                       if (inherits(cond, "message")) {
[16:09:33.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.156]                         if (muffled) 
[16:09:33.156]                           invokeRestart("muffleMessage")
[16:09:33.156]                       }
[16:09:33.156]                       else if (inherits(cond, "warning")) {
[16:09:33.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.156]                         if (muffled) 
[16:09:33.156]                           invokeRestart("muffleWarning")
[16:09:33.156]                       }
[16:09:33.156]                       else if (inherits(cond, "condition")) {
[16:09:33.156]                         if (!is.null(pattern)) {
[16:09:33.156]                           computeRestarts <- base::computeRestarts
[16:09:33.156]                           grepl <- base::grepl
[16:09:33.156]                           restarts <- computeRestarts(cond)
[16:09:33.156]                           for (restart in restarts) {
[16:09:33.156]                             name <- restart$name
[16:09:33.156]                             if (is.null(name)) 
[16:09:33.156]                               next
[16:09:33.156]                             if (!grepl(pattern, name)) 
[16:09:33.156]                               next
[16:09:33.156]                             invokeRestart(restart)
[16:09:33.156]                             muffled <- TRUE
[16:09:33.156]                             break
[16:09:33.156]                           }
[16:09:33.156]                         }
[16:09:33.156]                       }
[16:09:33.156]                       invisible(muffled)
[16:09:33.156]                     }
[16:09:33.156]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.156]                   }
[16:09:33.156]                 }
[16:09:33.156]                 else {
[16:09:33.156]                   if (TRUE) {
[16:09:33.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.156]                     {
[16:09:33.156]                       inherits <- base::inherits
[16:09:33.156]                       invokeRestart <- base::invokeRestart
[16:09:33.156]                       is.null <- base::is.null
[16:09:33.156]                       muffled <- FALSE
[16:09:33.156]                       if (inherits(cond, "message")) {
[16:09:33.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.156]                         if (muffled) 
[16:09:33.156]                           invokeRestart("muffleMessage")
[16:09:33.156]                       }
[16:09:33.156]                       else if (inherits(cond, "warning")) {
[16:09:33.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.156]                         if (muffled) 
[16:09:33.156]                           invokeRestart("muffleWarning")
[16:09:33.156]                       }
[16:09:33.156]                       else if (inherits(cond, "condition")) {
[16:09:33.156]                         if (!is.null(pattern)) {
[16:09:33.156]                           computeRestarts <- base::computeRestarts
[16:09:33.156]                           grepl <- base::grepl
[16:09:33.156]                           restarts <- computeRestarts(cond)
[16:09:33.156]                           for (restart in restarts) {
[16:09:33.156]                             name <- restart$name
[16:09:33.156]                             if (is.null(name)) 
[16:09:33.156]                               next
[16:09:33.156]                             if (!grepl(pattern, name)) 
[16:09:33.156]                               next
[16:09:33.156]                             invokeRestart(restart)
[16:09:33.156]                             muffled <- TRUE
[16:09:33.156]                             break
[16:09:33.156]                           }
[16:09:33.156]                         }
[16:09:33.156]                       }
[16:09:33.156]                       invisible(muffled)
[16:09:33.156]                     }
[16:09:33.156]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.156]                   }
[16:09:33.156]                 }
[16:09:33.156]             }
[16:09:33.156]         }))
[16:09:33.156]     }, error = function(ex) {
[16:09:33.156]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.156]                 ...future.rng), started = ...future.startTime, 
[16:09:33.156]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.156]             version = "1.8"), class = "FutureResult")
[16:09:33.156]     }, finally = {
[16:09:33.156]         if (!identical(...future.workdir, getwd())) 
[16:09:33.156]             setwd(...future.workdir)
[16:09:33.156]         {
[16:09:33.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.156]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.156]             }
[16:09:33.156]             base::options(...future.oldOptions)
[16:09:33.156]             if (.Platform$OS.type == "windows") {
[16:09:33.156]                 old_names <- names(...future.oldEnvVars)
[16:09:33.156]                 envs <- base::Sys.getenv()
[16:09:33.156]                 names <- names(envs)
[16:09:33.156]                 common <- intersect(names, old_names)
[16:09:33.156]                 added <- setdiff(names, old_names)
[16:09:33.156]                 removed <- setdiff(old_names, names)
[16:09:33.156]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.156]                   envs[common]]
[16:09:33.156]                 NAMES <- toupper(changed)
[16:09:33.156]                 args <- list()
[16:09:33.156]                 for (kk in seq_along(NAMES)) {
[16:09:33.156]                   name <- changed[[kk]]
[16:09:33.156]                   NAME <- NAMES[[kk]]
[16:09:33.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.156]                     next
[16:09:33.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.156]                 }
[16:09:33.156]                 NAMES <- toupper(added)
[16:09:33.156]                 for (kk in seq_along(NAMES)) {
[16:09:33.156]                   name <- added[[kk]]
[16:09:33.156]                   NAME <- NAMES[[kk]]
[16:09:33.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.156]                     next
[16:09:33.156]                   args[[name]] <- ""
[16:09:33.156]                 }
[16:09:33.156]                 NAMES <- toupper(removed)
[16:09:33.156]                 for (kk in seq_along(NAMES)) {
[16:09:33.156]                   name <- removed[[kk]]
[16:09:33.156]                   NAME <- NAMES[[kk]]
[16:09:33.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.156]                     next
[16:09:33.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.156]                 }
[16:09:33.156]                 if (length(args) > 0) 
[16:09:33.156]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.156]             }
[16:09:33.156]             else {
[16:09:33.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.156]             }
[16:09:33.156]             {
[16:09:33.156]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.156]                   0L) {
[16:09:33.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.156]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.156]                   base::options(opts)
[16:09:33.156]                 }
[16:09:33.156]                 {
[16:09:33.156]                   {
[16:09:33.156]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.156]                     NULL
[16:09:33.156]                   }
[16:09:33.156]                   options(future.plan = NULL)
[16:09:33.156]                   if (is.na(NA_character_)) 
[16:09:33.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.156]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.156]                     envir = parent.frame()) 
[16:09:33.156]                   {
[16:09:33.156]                     default_workers <- missing(workers)
[16:09:33.156]                     if (is.function(workers)) 
[16:09:33.156]                       workers <- workers()
[16:09:33.156]                     workers <- structure(as.integer(workers), 
[16:09:33.156]                       class = class(workers))
[16:09:33.156]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.156]                       1L)
[16:09:33.156]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.156]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.156]                       if (default_workers) 
[16:09:33.156]                         supportsMulticore(warn = TRUE)
[16:09:33.156]                       return(sequential(..., envir = envir))
[16:09:33.156]                     }
[16:09:33.156]                     oopts <- options(mc.cores = workers)
[16:09:33.156]                     on.exit(options(oopts))
[16:09:33.156]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.156]                       envir = envir)
[16:09:33.156]                     if (!future$lazy) 
[16:09:33.156]                       future <- run(future)
[16:09:33.156]                     invisible(future)
[16:09:33.156]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.156]                 }
[16:09:33.156]             }
[16:09:33.156]         }
[16:09:33.156]     })
[16:09:33.156]     if (TRUE) {
[16:09:33.156]         base::sink(type = "output", split = FALSE)
[16:09:33.156]         if (TRUE) {
[16:09:33.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.156]         }
[16:09:33.156]         else {
[16:09:33.156]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.156]         }
[16:09:33.156]         base::close(...future.stdout)
[16:09:33.156]         ...future.stdout <- NULL
[16:09:33.156]     }
[16:09:33.156]     ...future.result$conditions <- ...future.conditions
[16:09:33.156]     ...future.result$finished <- base::Sys.time()
[16:09:33.156]     ...future.result
[16:09:33.156] }
[16:09:33.159] assign_globals() ...
[16:09:33.159] List of 5
[16:09:33.159]  $ ...future.FUN            :function (object, ...)  
[16:09:33.159]  $ future.call.arguments    : list()
[16:09:33.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.159]  $ ...future.elements_ii    :List of 2
[16:09:33.159]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:33.159]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.159]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.159]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:09:33.159]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.159]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.159]  $ ...future.seeds_ii       : NULL
[16:09:33.159]  $ ...future.globals.maxSize: NULL
[16:09:33.159]  - attr(*, "resolved")= logi FALSE
[16:09:33.159]  - attr(*, "total_size")= num 1240
[16:09:33.159]  - attr(*, "where")=List of 5
[16:09:33.159]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.159]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.159]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.159]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.159]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.159]  - attr(*, "already-done")= logi TRUE
[16:09:33.168] - copied ‘...future.FUN’ to environment
[16:09:33.168] - copied ‘future.call.arguments’ to environment
[16:09:33.168] - copied ‘...future.elements_ii’ to environment
[16:09:33.168] - copied ‘...future.seeds_ii’ to environment
[16:09:33.168] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.169] assign_globals() ... done
[16:09:33.169] requestCore(): workers = 2
[16:09:33.173] MulticoreFuture started
[16:09:33.174] - Launch lazy future ... done
[16:09:33.174] run() for ‘MulticoreFuture’ ... done
[16:09:33.174] Created future:
[16:09:33.174] plan(): Setting new future strategy stack:
[16:09:33.175] List of future strategies:
[16:09:33.175] 1. sequential:
[16:09:33.175]    - args: function (..., envir = parent.frame())
[16:09:33.175]    - tweaked: FALSE
[16:09:33.175]    - call: NULL
[16:09:33.175] plan(): nbrOfWorkers() = 1
[16:09:33.183] plan(): Setting new future strategy stack:
[16:09:33.183] List of future strategies:
[16:09:33.183] 1. multicore:
[16:09:33.183]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.183]    - tweaked: FALSE
[16:09:33.183]    - call: plan(strategy)
[16:09:33.189] plan(): nbrOfWorkers() = 2
[16:09:33.174] MulticoreFuture:
[16:09:33.174] Label: ‘future_by-2’
[16:09:33.174] Expression:
[16:09:33.174] {
[16:09:33.174]     do.call(function(...) {
[16:09:33.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.174]             on.exit(options(oopts), add = TRUE)
[16:09:33.174]         }
[16:09:33.174]         {
[16:09:33.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.174]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.174]             })
[16:09:33.174]         }
[16:09:33.174]     }, args = future.call.arguments)
[16:09:33.174] }
[16:09:33.174] Lazy evaluation: FALSE
[16:09:33.174] Asynchronous evaluation: TRUE
[16:09:33.174] Local evaluation: TRUE
[16:09:33.174] Environment: R_GlobalEnv
[16:09:33.174] Capture standard output: TRUE
[16:09:33.174] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.174] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.174] Packages: <none>
[16:09:33.174] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.174] Resolved: TRUE
[16:09:33.174] Value: <not collected>
[16:09:33.174] Conditions captured: <none>
[16:09:33.174] Early signaling: FALSE
[16:09:33.174] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.174] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.191] Chunk #2 of 2 ... DONE
[16:09:33.191] Launching 2 futures (chunks) ... DONE
[16:09:33.191] Resolving 2 futures (chunks) ...
[16:09:33.191] resolve() on list ...
[16:09:33.191]  recursive: 0
[16:09:33.192]  length: 2
[16:09:33.192] 
[16:09:33.192] Future #1
[16:09:33.195] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:33.195] - nx: 2
[16:09:33.195] - relay: TRUE
[16:09:33.195] - stdout: TRUE
[16:09:33.195] - signal: TRUE
[16:09:33.196] - resignal: FALSE
[16:09:33.196] - force: TRUE
[16:09:33.196] - relayed: [n=2] FALSE, FALSE
[16:09:33.196] - queued futures: [n=2] FALSE, FALSE
[16:09:33.197]  - until=1
[16:09:33.197]  - relaying element #1
[16:09:33.197] - relayed: [n=2] TRUE, FALSE
[16:09:33.197] - queued futures: [n=2] TRUE, FALSE
[16:09:33.198] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:33.198]  length: 1 (resolved future 1)
[16:09:33.198] Future #2
[16:09:33.199] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:33.199] - nx: 2
[16:09:33.199] - relay: TRUE
[16:09:33.199] - stdout: TRUE
[16:09:33.200] - signal: TRUE
[16:09:33.200] - resignal: FALSE
[16:09:33.200] - force: TRUE
[16:09:33.200] - relayed: [n=2] TRUE, FALSE
[16:09:33.200] - queued futures: [n=2] TRUE, FALSE
[16:09:33.200]  - until=2
[16:09:33.200]  - relaying element #2
[16:09:33.201] - relayed: [n=2] TRUE, TRUE
[16:09:33.201] - queued futures: [n=2] TRUE, TRUE
[16:09:33.201] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:33.201]  length: 0 (resolved future 2)
[16:09:33.201] Relaying remaining futures
[16:09:33.201] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.201] - nx: 2
[16:09:33.202] - relay: TRUE
[16:09:33.202] - stdout: TRUE
[16:09:33.202] - signal: TRUE
[16:09:33.202] - resignal: FALSE
[16:09:33.202] - force: TRUE
[16:09:33.202] - relayed: [n=2] TRUE, TRUE
[16:09:33.202] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:33.202] - relayed: [n=2] TRUE, TRUE
[16:09:33.202] - queued futures: [n=2] TRUE, TRUE
[16:09:33.203] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.203] resolve() on list ... DONE
[16:09:33.203]  - Number of value chunks collected: 2
[16:09:33.203] Resolving 2 futures (chunks) ... DONE
[16:09:33.203] Reducing values from 2 chunks ...
[16:09:33.203]  - Number of values collected after concatenation: 3
[16:09:33.203]  - Number of values expected: 3
[16:09:33.203] Reducing values from 2 chunks ... DONE
[16:09:33.204] future_lapply() ... DONE
[16:09:33.204] future_by_internal() ... DONE
[16:09:33.204] future_by_internal() ...
[16:09:33.204] future_lapply() ...
[16:09:33.209] Number of chunks: 2
[16:09:33.209] getGlobalsAndPackagesXApply() ...
[16:09:33.209]  - future.globals: TRUE
[16:09:33.209] getGlobalsAndPackages() ...
[16:09:33.210] Searching for globals...
[16:09:33.211] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:33.211] Searching for globals ... DONE
[16:09:33.211] Resolving globals: FALSE
[16:09:33.211] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:33.212] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:33.212] - globals: [1] ‘FUN’
[16:09:33.212] 
[16:09:33.212] getGlobalsAndPackages() ... DONE
[16:09:33.212]  - globals found/used: [n=1] ‘FUN’
[16:09:33.212]  - needed namespaces: [n=0] 
[16:09:33.213] Finding globals ... DONE
[16:09:33.213]  - use_args: TRUE
[16:09:33.213]  - Getting '...' globals ...
[16:09:33.213] resolve() on list ...
[16:09:33.213]  recursive: 0
[16:09:33.213]  length: 1
[16:09:33.213]  elements: ‘...’
[16:09:33.213]  length: 0 (resolved future 1)
[16:09:33.214] resolve() on list ... DONE
[16:09:33.214]    - '...' content: [n=1] ‘digits’
[16:09:33.214] List of 1
[16:09:33.214]  $ ...:List of 1
[16:09:33.214]   ..$ digits: int 2
[16:09:33.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.214]  - attr(*, "where")=List of 1
[16:09:33.214]   ..$ ...:<environment: 0x5567e6de0860> 
[16:09:33.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.214]  - attr(*, "resolved")= logi TRUE
[16:09:33.214]  - attr(*, "total_size")= num NA
[16:09:33.221]  - Getting '...' globals ... DONE
[16:09:33.221] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.221] List of 2
[16:09:33.221]  $ ...future.FUN:function (object, ...)  
[16:09:33.221]  $ ...          :List of 1
[16:09:33.221]   ..$ digits: int 2
[16:09:33.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.221]  - attr(*, "where")=List of 2
[16:09:33.221]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.221]   ..$ ...          :<environment: 0x5567e6de0860> 
[16:09:33.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.221]  - attr(*, "resolved")= logi FALSE
[16:09:33.221]  - attr(*, "total_size")= num 1296
[16:09:33.225] Packages to be attached in all futures: [n=0] 
[16:09:33.225] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.225] Number of futures (= number of chunks): 2
[16:09:33.225] Launching 2 futures (chunks) ...
[16:09:33.225] Chunk #1 of 2 ...
[16:09:33.226]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.226] getGlobalsAndPackages() ...
[16:09:33.226] Searching for globals...
[16:09:33.226] 
[16:09:33.226] Searching for globals ... DONE
[16:09:33.226] - globals: [0] <none>
[16:09:33.226] getGlobalsAndPackages() ... DONE
[16:09:33.226]    + additional globals found: [n=0] 
[16:09:33.226]    + additional namespaces needed: [n=0] 
[16:09:33.227]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.227]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:33.227]  - seeds: <none>
[16:09:33.227] getGlobalsAndPackages() ...
[16:09:33.227] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.227] Resolving globals: FALSE
[16:09:33.227] Tweak future expression to call with '...' arguments ...
[16:09:33.227] {
[16:09:33.227]     do.call(function(...) {
[16:09:33.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.227]             on.exit(options(oopts), add = TRUE)
[16:09:33.227]         }
[16:09:33.227]         {
[16:09:33.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.227]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.227]             })
[16:09:33.227]         }
[16:09:33.227]     }, args = future.call.arguments)
[16:09:33.227] }
[16:09:33.228] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.228] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.228] 
[16:09:33.228] getGlobalsAndPackages() ... DONE
[16:09:33.228] run() for ‘Future’ ...
[16:09:33.229] - state: ‘created’
[16:09:33.229] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.232] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.233]   - Field: ‘label’
[16:09:33.233]   - Field: ‘local’
[16:09:33.233]   - Field: ‘owner’
[16:09:33.233]   - Field: ‘envir’
[16:09:33.233]   - Field: ‘workers’
[16:09:33.233]   - Field: ‘packages’
[16:09:33.233]   - Field: ‘gc’
[16:09:33.233]   - Field: ‘job’
[16:09:33.233]   - Field: ‘conditions’
[16:09:33.234]   - Field: ‘expr’
[16:09:33.234]   - Field: ‘uuid’
[16:09:33.234]   - Field: ‘seed’
[16:09:33.234]   - Field: ‘version’
[16:09:33.234]   - Field: ‘result’
[16:09:33.234]   - Field: ‘asynchronous’
[16:09:33.234]   - Field: ‘calls’
[16:09:33.234]   - Field: ‘globals’
[16:09:33.234]   - Field: ‘stdout’
[16:09:33.234]   - Field: ‘earlySignal’
[16:09:33.234]   - Field: ‘lazy’
[16:09:33.235]   - Field: ‘state’
[16:09:33.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.235] - Launch lazy future ...
[16:09:33.235] Packages needed by the future expression (n = 0): <none>
[16:09:33.235] Packages needed by future strategies (n = 0): <none>
[16:09:33.236] {
[16:09:33.236]     {
[16:09:33.236]         {
[16:09:33.236]             ...future.startTime <- base::Sys.time()
[16:09:33.236]             {
[16:09:33.236]                 {
[16:09:33.236]                   {
[16:09:33.236]                     {
[16:09:33.236]                       base::local({
[16:09:33.236]                         has_future <- base::requireNamespace("future", 
[16:09:33.236]                           quietly = TRUE)
[16:09:33.236]                         if (has_future) {
[16:09:33.236]                           ns <- base::getNamespace("future")
[16:09:33.236]                           version <- ns[[".package"]][["version"]]
[16:09:33.236]                           if (is.null(version)) 
[16:09:33.236]                             version <- utils::packageVersion("future")
[16:09:33.236]                         }
[16:09:33.236]                         else {
[16:09:33.236]                           version <- NULL
[16:09:33.236]                         }
[16:09:33.236]                         if (!has_future || version < "1.8.0") {
[16:09:33.236]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.236]                             "", base::R.version$version.string), 
[16:09:33.236]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.236]                               "release", "version")], collapse = " "), 
[16:09:33.236]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.236]                             info)
[16:09:33.236]                           info <- base::paste(info, collapse = "; ")
[16:09:33.236]                           if (!has_future) {
[16:09:33.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.236]                               info)
[16:09:33.236]                           }
[16:09:33.236]                           else {
[16:09:33.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.236]                               info, version)
[16:09:33.236]                           }
[16:09:33.236]                           base::stop(msg)
[16:09:33.236]                         }
[16:09:33.236]                       })
[16:09:33.236]                     }
[16:09:33.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.236]                     base::options(mc.cores = 1L)
[16:09:33.236]                   }
[16:09:33.236]                   options(future.plan = NULL)
[16:09:33.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.236]                 }
[16:09:33.236]                 ...future.workdir <- getwd()
[16:09:33.236]             }
[16:09:33.236]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.236]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.236]         }
[16:09:33.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.236]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:33.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.236]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.236]             base::names(...future.oldOptions))
[16:09:33.236]     }
[16:09:33.236]     if (FALSE) {
[16:09:33.236]     }
[16:09:33.236]     else {
[16:09:33.236]         if (TRUE) {
[16:09:33.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.236]                 open = "w")
[16:09:33.236]         }
[16:09:33.236]         else {
[16:09:33.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.236]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.236]         }
[16:09:33.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.236]             base::sink(type = "output", split = FALSE)
[16:09:33.236]             base::close(...future.stdout)
[16:09:33.236]         }, add = TRUE)
[16:09:33.236]     }
[16:09:33.236]     ...future.frame <- base::sys.nframe()
[16:09:33.236]     ...future.conditions <- base::list()
[16:09:33.236]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.236]     if (FALSE) {
[16:09:33.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.236]     }
[16:09:33.236]     ...future.result <- base::tryCatch({
[16:09:33.236]         base::withCallingHandlers({
[16:09:33.236]             ...future.value <- base::withVisible(base::local({
[16:09:33.236]                 withCallingHandlers({
[16:09:33.236]                   {
[16:09:33.236]                     do.call(function(...) {
[16:09:33.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.236]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.236]                         ...future.globals.maxSize)) {
[16:09:33.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.236]                         on.exit(options(oopts), add = TRUE)
[16:09:33.236]                       }
[16:09:33.236]                       {
[16:09:33.236]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.236]                           FUN = function(jj) {
[16:09:33.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.236]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.236]                           })
[16:09:33.236]                       }
[16:09:33.236]                     }, args = future.call.arguments)
[16:09:33.236]                   }
[16:09:33.236]                 }, immediateCondition = function(cond) {
[16:09:33.236]                   save_rds <- function (object, pathname, ...) 
[16:09:33.236]                   {
[16:09:33.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.236]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.236]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.236]                         fi_tmp[["mtime"]])
[16:09:33.236]                     }
[16:09:33.236]                     tryCatch({
[16:09:33.236]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.236]                     }, error = function(ex) {
[16:09:33.236]                       msg <- conditionMessage(ex)
[16:09:33.236]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.236]                         fi_tmp[["mtime"]], msg)
[16:09:33.236]                       ex$message <- msg
[16:09:33.236]                       stop(ex)
[16:09:33.236]                     })
[16:09:33.236]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.236]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.236]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.236]                       fi <- file.info(pathname)
[16:09:33.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.236]                         fi[["size"]], fi[["mtime"]])
[16:09:33.236]                       stop(msg)
[16:09:33.236]                     }
[16:09:33.236]                     invisible(pathname)
[16:09:33.236]                   }
[16:09:33.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.236]                     rootPath = tempdir()) 
[16:09:33.236]                   {
[16:09:33.236]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.236]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.236]                       tmpdir = path, fileext = ".rds")
[16:09:33.236]                     save_rds(obj, file)
[16:09:33.236]                   }
[16:09:33.236]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.236]                   {
[16:09:33.236]                     inherits <- base::inherits
[16:09:33.236]                     invokeRestart <- base::invokeRestart
[16:09:33.236]                     is.null <- base::is.null
[16:09:33.236]                     muffled <- FALSE
[16:09:33.236]                     if (inherits(cond, "message")) {
[16:09:33.236]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.236]                       if (muffled) 
[16:09:33.236]                         invokeRestart("muffleMessage")
[16:09:33.236]                     }
[16:09:33.236]                     else if (inherits(cond, "warning")) {
[16:09:33.236]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.236]                       if (muffled) 
[16:09:33.236]                         invokeRestart("muffleWarning")
[16:09:33.236]                     }
[16:09:33.236]                     else if (inherits(cond, "condition")) {
[16:09:33.236]                       if (!is.null(pattern)) {
[16:09:33.236]                         computeRestarts <- base::computeRestarts
[16:09:33.236]                         grepl <- base::grepl
[16:09:33.236]                         restarts <- computeRestarts(cond)
[16:09:33.236]                         for (restart in restarts) {
[16:09:33.236]                           name <- restart$name
[16:09:33.236]                           if (is.null(name)) 
[16:09:33.236]                             next
[16:09:33.236]                           if (!grepl(pattern, name)) 
[16:09:33.236]                             next
[16:09:33.236]                           invokeRestart(restart)
[16:09:33.236]                           muffled <- TRUE
[16:09:33.236]                           break
[16:09:33.236]                         }
[16:09:33.236]                       }
[16:09:33.236]                     }
[16:09:33.236]                     invisible(muffled)
[16:09:33.236]                   }
[16:09:33.236]                   muffleCondition(cond)
[16:09:33.236]                 })
[16:09:33.236]             }))
[16:09:33.236]             future::FutureResult(value = ...future.value$value, 
[16:09:33.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.236]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.236]                     ...future.globalenv.names))
[16:09:33.236]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.236]         }, condition = base::local({
[16:09:33.236]             c <- base::c
[16:09:33.236]             inherits <- base::inherits
[16:09:33.236]             invokeRestart <- base::invokeRestart
[16:09:33.236]             length <- base::length
[16:09:33.236]             list <- base::list
[16:09:33.236]             seq.int <- base::seq.int
[16:09:33.236]             signalCondition <- base::signalCondition
[16:09:33.236]             sys.calls <- base::sys.calls
[16:09:33.236]             `[[` <- base::`[[`
[16:09:33.236]             `+` <- base::`+`
[16:09:33.236]             `<<-` <- base::`<<-`
[16:09:33.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.236]                   3L)]
[16:09:33.236]             }
[16:09:33.236]             function(cond) {
[16:09:33.236]                 is_error <- inherits(cond, "error")
[16:09:33.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.236]                   NULL)
[16:09:33.236]                 if (is_error) {
[16:09:33.236]                   sessionInformation <- function() {
[16:09:33.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.236]                       search = base::search(), system = base::Sys.info())
[16:09:33.236]                   }
[16:09:33.236]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.236]                     cond$call), session = sessionInformation(), 
[16:09:33.236]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.236]                   signalCondition(cond)
[16:09:33.236]                 }
[16:09:33.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.236]                 "immediateCondition"))) {
[16:09:33.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.236]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.236]                   if (TRUE && !signal) {
[16:09:33.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.236]                     {
[16:09:33.236]                       inherits <- base::inherits
[16:09:33.236]                       invokeRestart <- base::invokeRestart
[16:09:33.236]                       is.null <- base::is.null
[16:09:33.236]                       muffled <- FALSE
[16:09:33.236]                       if (inherits(cond, "message")) {
[16:09:33.236]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.236]                         if (muffled) 
[16:09:33.236]                           invokeRestart("muffleMessage")
[16:09:33.236]                       }
[16:09:33.236]                       else if (inherits(cond, "warning")) {
[16:09:33.236]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.236]                         if (muffled) 
[16:09:33.236]                           invokeRestart("muffleWarning")
[16:09:33.236]                       }
[16:09:33.236]                       else if (inherits(cond, "condition")) {
[16:09:33.236]                         if (!is.null(pattern)) {
[16:09:33.236]                           computeRestarts <- base::computeRestarts
[16:09:33.236]                           grepl <- base::grepl
[16:09:33.236]                           restarts <- computeRestarts(cond)
[16:09:33.236]                           for (restart in restarts) {
[16:09:33.236]                             name <- restart$name
[16:09:33.236]                             if (is.null(name)) 
[16:09:33.236]                               next
[16:09:33.236]                             if (!grepl(pattern, name)) 
[16:09:33.236]                               next
[16:09:33.236]                             invokeRestart(restart)
[16:09:33.236]                             muffled <- TRUE
[16:09:33.236]                             break
[16:09:33.236]                           }
[16:09:33.236]                         }
[16:09:33.236]                       }
[16:09:33.236]                       invisible(muffled)
[16:09:33.236]                     }
[16:09:33.236]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.236]                   }
[16:09:33.236]                 }
[16:09:33.236]                 else {
[16:09:33.236]                   if (TRUE) {
[16:09:33.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.236]                     {
[16:09:33.236]                       inherits <- base::inherits
[16:09:33.236]                       invokeRestart <- base::invokeRestart
[16:09:33.236]                       is.null <- base::is.null
[16:09:33.236]                       muffled <- FALSE
[16:09:33.236]                       if (inherits(cond, "message")) {
[16:09:33.236]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.236]                         if (muffled) 
[16:09:33.236]                           invokeRestart("muffleMessage")
[16:09:33.236]                       }
[16:09:33.236]                       else if (inherits(cond, "warning")) {
[16:09:33.236]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.236]                         if (muffled) 
[16:09:33.236]                           invokeRestart("muffleWarning")
[16:09:33.236]                       }
[16:09:33.236]                       else if (inherits(cond, "condition")) {
[16:09:33.236]                         if (!is.null(pattern)) {
[16:09:33.236]                           computeRestarts <- base::computeRestarts
[16:09:33.236]                           grepl <- base::grepl
[16:09:33.236]                           restarts <- computeRestarts(cond)
[16:09:33.236]                           for (restart in restarts) {
[16:09:33.236]                             name <- restart$name
[16:09:33.236]                             if (is.null(name)) 
[16:09:33.236]                               next
[16:09:33.236]                             if (!grepl(pattern, name)) 
[16:09:33.236]                               next
[16:09:33.236]                             invokeRestart(restart)
[16:09:33.236]                             muffled <- TRUE
[16:09:33.236]                             break
[16:09:33.236]                           }
[16:09:33.236]                         }
[16:09:33.236]                       }
[16:09:33.236]                       invisible(muffled)
[16:09:33.236]                     }
[16:09:33.236]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.236]                   }
[16:09:33.236]                 }
[16:09:33.236]             }
[16:09:33.236]         }))
[16:09:33.236]     }, error = function(ex) {
[16:09:33.236]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.236]                 ...future.rng), started = ...future.startTime, 
[16:09:33.236]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.236]             version = "1.8"), class = "FutureResult")
[16:09:33.236]     }, finally = {
[16:09:33.236]         if (!identical(...future.workdir, getwd())) 
[16:09:33.236]             setwd(...future.workdir)
[16:09:33.236]         {
[16:09:33.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.236]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.236]             }
[16:09:33.236]             base::options(...future.oldOptions)
[16:09:33.236]             if (.Platform$OS.type == "windows") {
[16:09:33.236]                 old_names <- names(...future.oldEnvVars)
[16:09:33.236]                 envs <- base::Sys.getenv()
[16:09:33.236]                 names <- names(envs)
[16:09:33.236]                 common <- intersect(names, old_names)
[16:09:33.236]                 added <- setdiff(names, old_names)
[16:09:33.236]                 removed <- setdiff(old_names, names)
[16:09:33.236]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.236]                   envs[common]]
[16:09:33.236]                 NAMES <- toupper(changed)
[16:09:33.236]                 args <- list()
[16:09:33.236]                 for (kk in seq_along(NAMES)) {
[16:09:33.236]                   name <- changed[[kk]]
[16:09:33.236]                   NAME <- NAMES[[kk]]
[16:09:33.236]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.236]                     next
[16:09:33.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.236]                 }
[16:09:33.236]                 NAMES <- toupper(added)
[16:09:33.236]                 for (kk in seq_along(NAMES)) {
[16:09:33.236]                   name <- added[[kk]]
[16:09:33.236]                   NAME <- NAMES[[kk]]
[16:09:33.236]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.236]                     next
[16:09:33.236]                   args[[name]] <- ""
[16:09:33.236]                 }
[16:09:33.236]                 NAMES <- toupper(removed)
[16:09:33.236]                 for (kk in seq_along(NAMES)) {
[16:09:33.236]                   name <- removed[[kk]]
[16:09:33.236]                   NAME <- NAMES[[kk]]
[16:09:33.236]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.236]                     next
[16:09:33.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.236]                 }
[16:09:33.236]                 if (length(args) > 0) 
[16:09:33.236]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.236]             }
[16:09:33.236]             else {
[16:09:33.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.236]             }
[16:09:33.236]             {
[16:09:33.236]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.236]                   0L) {
[16:09:33.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.236]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.236]                   base::options(opts)
[16:09:33.236]                 }
[16:09:33.236]                 {
[16:09:33.236]                   {
[16:09:33.236]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.236]                     NULL
[16:09:33.236]                   }
[16:09:33.236]                   options(future.plan = NULL)
[16:09:33.236]                   if (is.na(NA_character_)) 
[16:09:33.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.236]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.236]                     envir = parent.frame()) 
[16:09:33.236]                   {
[16:09:33.236]                     default_workers <- missing(workers)
[16:09:33.236]                     if (is.function(workers)) 
[16:09:33.236]                       workers <- workers()
[16:09:33.236]                     workers <- structure(as.integer(workers), 
[16:09:33.236]                       class = class(workers))
[16:09:33.236]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.236]                       1L)
[16:09:33.236]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.236]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.236]                       if (default_workers) 
[16:09:33.236]                         supportsMulticore(warn = TRUE)
[16:09:33.236]                       return(sequential(..., envir = envir))
[16:09:33.236]                     }
[16:09:33.236]                     oopts <- options(mc.cores = workers)
[16:09:33.236]                     on.exit(options(oopts))
[16:09:33.236]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.236]                       envir = envir)
[16:09:33.236]                     if (!future$lazy) 
[16:09:33.236]                       future <- run(future)
[16:09:33.236]                     invisible(future)
[16:09:33.236]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.236]                 }
[16:09:33.236]             }
[16:09:33.236]         }
[16:09:33.236]     })
[16:09:33.236]     if (TRUE) {
[16:09:33.236]         base::sink(type = "output", split = FALSE)
[16:09:33.236]         if (TRUE) {
[16:09:33.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.236]         }
[16:09:33.236]         else {
[16:09:33.236]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.236]         }
[16:09:33.236]         base::close(...future.stdout)
[16:09:33.236]         ...future.stdout <- NULL
[16:09:33.236]     }
[16:09:33.236]     ...future.result$conditions <- ...future.conditions
[16:09:33.236]     ...future.result$finished <- base::Sys.time()
[16:09:33.236]     ...future.result
[16:09:33.236] }
[16:09:33.238] assign_globals() ...
[16:09:33.238] List of 5
[16:09:33.238]  $ ...future.FUN            :function (object, ...)  
[16:09:33.238]  $ future.call.arguments    :List of 1
[16:09:33.238]   ..$ digits: int 2
[16:09:33.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.238]  $ ...future.elements_ii    :List of 3
[16:09:33.238]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:09:33.238]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:09:33.238]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:09:33.238]  $ ...future.seeds_ii       : NULL
[16:09:33.238]  $ ...future.globals.maxSize: NULL
[16:09:33.238]  - attr(*, "resolved")= logi FALSE
[16:09:33.238]  - attr(*, "total_size")= num 1296
[16:09:33.238]  - attr(*, "where")=List of 5
[16:09:33.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.238]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.238]  - attr(*, "already-done")= logi TRUE
[16:09:33.246] - copied ‘...future.FUN’ to environment
[16:09:33.246] - copied ‘future.call.arguments’ to environment
[16:09:33.246] - copied ‘...future.elements_ii’ to environment
[16:09:33.246] - copied ‘...future.seeds_ii’ to environment
[16:09:33.246] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.246] assign_globals() ... done
[16:09:33.246] requestCore(): workers = 2
[16:09:33.248] MulticoreFuture started
[16:09:33.249] - Launch lazy future ... done
[16:09:33.250] plan(): Setting new future strategy stack:
[16:09:33.249] run() for ‘MulticoreFuture’ ... done
[16:09:33.250] Created future:
[16:09:33.250] List of future strategies:
[16:09:33.250] 1. sequential:
[16:09:33.250]    - args: function (..., envir = parent.frame())
[16:09:33.250]    - tweaked: FALSE
[16:09:33.250]    - call: NULL
[16:09:33.251] plan(): nbrOfWorkers() = 1
[16:09:33.255] plan(): Setting new future strategy stack:
[16:09:33.255] List of future strategies:
[16:09:33.255] 1. multicore:
[16:09:33.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.255]    - tweaked: FALSE
[16:09:33.255]    - call: plan(strategy)
[16:09:33.262] plan(): nbrOfWorkers() = 2
[16:09:33.251] MulticoreFuture:
[16:09:33.251] Label: ‘future_by-1’
[16:09:33.251] Expression:
[16:09:33.251] {
[16:09:33.251]     do.call(function(...) {
[16:09:33.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.251]             on.exit(options(oopts), add = TRUE)
[16:09:33.251]         }
[16:09:33.251]         {
[16:09:33.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.251]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.251]             })
[16:09:33.251]         }
[16:09:33.251]     }, args = future.call.arguments)
[16:09:33.251] }
[16:09:33.251] Lazy evaluation: FALSE
[16:09:33.251] Asynchronous evaluation: TRUE
[16:09:33.251] Local evaluation: TRUE
[16:09:33.251] Environment: R_GlobalEnv
[16:09:33.251] Capture standard output: TRUE
[16:09:33.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.251] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.251] Packages: <none>
[16:09:33.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.251] Resolved: TRUE
[16:09:33.251] Value: <not collected>
[16:09:33.251] Conditions captured: <none>
[16:09:33.251] Early signaling: FALSE
[16:09:33.251] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.251] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.263] Chunk #1 of 2 ... DONE
[16:09:33.263] Chunk #2 of 2 ...
[16:09:33.263]  - Finding globals in 'X' for chunk #2 ...
[16:09:33.264] getGlobalsAndPackages() ...
[16:09:33.264] Searching for globals...
[16:09:33.264] 
[16:09:33.265] Searching for globals ... DONE
[16:09:33.265] - globals: [0] <none>
[16:09:33.265] getGlobalsAndPackages() ... DONE
[16:09:33.265]    + additional globals found: [n=0] 
[16:09:33.265]    + additional namespaces needed: [n=0] 
[16:09:33.266]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:33.266]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:33.266]  - seeds: <none>
[16:09:33.266] getGlobalsAndPackages() ...
[16:09:33.266] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.267] Resolving globals: FALSE
[16:09:33.267] Tweak future expression to call with '...' arguments ...
[16:09:33.267] {
[16:09:33.267]     do.call(function(...) {
[16:09:33.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.267]             on.exit(options(oopts), add = TRUE)
[16:09:33.267]         }
[16:09:33.267]         {
[16:09:33.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.267]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.267]             })
[16:09:33.267]         }
[16:09:33.267]     }, args = future.call.arguments)
[16:09:33.267] }
[16:09:33.268] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.268] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.269] 
[16:09:33.269] getGlobalsAndPackages() ... DONE
[16:09:33.269] run() for ‘Future’ ...
[16:09:33.269] - state: ‘created’
[16:09:33.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.274] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.275]   - Field: ‘label’
[16:09:33.275]   - Field: ‘local’
[16:09:33.275]   - Field: ‘owner’
[16:09:33.275]   - Field: ‘envir’
[16:09:33.275]   - Field: ‘workers’
[16:09:33.275]   - Field: ‘packages’
[16:09:33.276]   - Field: ‘gc’
[16:09:33.276]   - Field: ‘job’
[16:09:33.276]   - Field: ‘conditions’
[16:09:33.276]   - Field: ‘expr’
[16:09:33.276]   - Field: ‘uuid’
[16:09:33.276]   - Field: ‘seed’
[16:09:33.276]   - Field: ‘version’
[16:09:33.277]   - Field: ‘result’
[16:09:33.277]   - Field: ‘asynchronous’
[16:09:33.277]   - Field: ‘calls’
[16:09:33.277]   - Field: ‘globals’
[16:09:33.277]   - Field: ‘stdout’
[16:09:33.277]   - Field: ‘earlySignal’
[16:09:33.277]   - Field: ‘lazy’
[16:09:33.278]   - Field: ‘state’
[16:09:33.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.278] - Launch lazy future ...
[16:09:33.278] Packages needed by the future expression (n = 0): <none>
[16:09:33.278] Packages needed by future strategies (n = 0): <none>
[16:09:33.279] {
[16:09:33.279]     {
[16:09:33.279]         {
[16:09:33.279]             ...future.startTime <- base::Sys.time()
[16:09:33.279]             {
[16:09:33.279]                 {
[16:09:33.279]                   {
[16:09:33.279]                     {
[16:09:33.279]                       base::local({
[16:09:33.279]                         has_future <- base::requireNamespace("future", 
[16:09:33.279]                           quietly = TRUE)
[16:09:33.279]                         if (has_future) {
[16:09:33.279]                           ns <- base::getNamespace("future")
[16:09:33.279]                           version <- ns[[".package"]][["version"]]
[16:09:33.279]                           if (is.null(version)) 
[16:09:33.279]                             version <- utils::packageVersion("future")
[16:09:33.279]                         }
[16:09:33.279]                         else {
[16:09:33.279]                           version <- NULL
[16:09:33.279]                         }
[16:09:33.279]                         if (!has_future || version < "1.8.0") {
[16:09:33.279]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.279]                             "", base::R.version$version.string), 
[16:09:33.279]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.279]                               "release", "version")], collapse = " "), 
[16:09:33.279]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.279]                             info)
[16:09:33.279]                           info <- base::paste(info, collapse = "; ")
[16:09:33.279]                           if (!has_future) {
[16:09:33.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.279]                               info)
[16:09:33.279]                           }
[16:09:33.279]                           else {
[16:09:33.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.279]                               info, version)
[16:09:33.279]                           }
[16:09:33.279]                           base::stop(msg)
[16:09:33.279]                         }
[16:09:33.279]                       })
[16:09:33.279]                     }
[16:09:33.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.279]                     base::options(mc.cores = 1L)
[16:09:33.279]                   }
[16:09:33.279]                   options(future.plan = NULL)
[16:09:33.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.279]                 }
[16:09:33.279]                 ...future.workdir <- getwd()
[16:09:33.279]             }
[16:09:33.279]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.279]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.279]         }
[16:09:33.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.279]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:33.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.279]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.279]             base::names(...future.oldOptions))
[16:09:33.279]     }
[16:09:33.279]     if (FALSE) {
[16:09:33.279]     }
[16:09:33.279]     else {
[16:09:33.279]         if (TRUE) {
[16:09:33.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.279]                 open = "w")
[16:09:33.279]         }
[16:09:33.279]         else {
[16:09:33.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.279]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.279]         }
[16:09:33.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.279]             base::sink(type = "output", split = FALSE)
[16:09:33.279]             base::close(...future.stdout)
[16:09:33.279]         }, add = TRUE)
[16:09:33.279]     }
[16:09:33.279]     ...future.frame <- base::sys.nframe()
[16:09:33.279]     ...future.conditions <- base::list()
[16:09:33.279]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.279]     if (FALSE) {
[16:09:33.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.279]     }
[16:09:33.279]     ...future.result <- base::tryCatch({
[16:09:33.279]         base::withCallingHandlers({
[16:09:33.279]             ...future.value <- base::withVisible(base::local({
[16:09:33.279]                 withCallingHandlers({
[16:09:33.279]                   {
[16:09:33.279]                     do.call(function(...) {
[16:09:33.279]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.279]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.279]                         ...future.globals.maxSize)) {
[16:09:33.279]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.279]                         on.exit(options(oopts), add = TRUE)
[16:09:33.279]                       }
[16:09:33.279]                       {
[16:09:33.279]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.279]                           FUN = function(jj) {
[16:09:33.279]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.279]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.279]                           })
[16:09:33.279]                       }
[16:09:33.279]                     }, args = future.call.arguments)
[16:09:33.279]                   }
[16:09:33.279]                 }, immediateCondition = function(cond) {
[16:09:33.279]                   save_rds <- function (object, pathname, ...) 
[16:09:33.279]                   {
[16:09:33.279]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.279]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.279]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.279]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.279]                         fi_tmp[["mtime"]])
[16:09:33.279]                     }
[16:09:33.279]                     tryCatch({
[16:09:33.279]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.279]                     }, error = function(ex) {
[16:09:33.279]                       msg <- conditionMessage(ex)
[16:09:33.279]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.279]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.279]                         fi_tmp[["mtime"]], msg)
[16:09:33.279]                       ex$message <- msg
[16:09:33.279]                       stop(ex)
[16:09:33.279]                     })
[16:09:33.279]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.279]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.279]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.279]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.279]                       fi <- file.info(pathname)
[16:09:33.279]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.279]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.279]                         fi[["size"]], fi[["mtime"]])
[16:09:33.279]                       stop(msg)
[16:09:33.279]                     }
[16:09:33.279]                     invisible(pathname)
[16:09:33.279]                   }
[16:09:33.279]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.279]                     rootPath = tempdir()) 
[16:09:33.279]                   {
[16:09:33.279]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.279]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.279]                       tmpdir = path, fileext = ".rds")
[16:09:33.279]                     save_rds(obj, file)
[16:09:33.279]                   }
[16:09:33.279]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.279]                   {
[16:09:33.279]                     inherits <- base::inherits
[16:09:33.279]                     invokeRestart <- base::invokeRestart
[16:09:33.279]                     is.null <- base::is.null
[16:09:33.279]                     muffled <- FALSE
[16:09:33.279]                     if (inherits(cond, "message")) {
[16:09:33.279]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.279]                       if (muffled) 
[16:09:33.279]                         invokeRestart("muffleMessage")
[16:09:33.279]                     }
[16:09:33.279]                     else if (inherits(cond, "warning")) {
[16:09:33.279]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.279]                       if (muffled) 
[16:09:33.279]                         invokeRestart("muffleWarning")
[16:09:33.279]                     }
[16:09:33.279]                     else if (inherits(cond, "condition")) {
[16:09:33.279]                       if (!is.null(pattern)) {
[16:09:33.279]                         computeRestarts <- base::computeRestarts
[16:09:33.279]                         grepl <- base::grepl
[16:09:33.279]                         restarts <- computeRestarts(cond)
[16:09:33.279]                         for (restart in restarts) {
[16:09:33.279]                           name <- restart$name
[16:09:33.279]                           if (is.null(name)) 
[16:09:33.279]                             next
[16:09:33.279]                           if (!grepl(pattern, name)) 
[16:09:33.279]                             next
[16:09:33.279]                           invokeRestart(restart)
[16:09:33.279]                           muffled <- TRUE
[16:09:33.279]                           break
[16:09:33.279]                         }
[16:09:33.279]                       }
[16:09:33.279]                     }
[16:09:33.279]                     invisible(muffled)
[16:09:33.279]                   }
[16:09:33.279]                   muffleCondition(cond)
[16:09:33.279]                 })
[16:09:33.279]             }))
[16:09:33.279]             future::FutureResult(value = ...future.value$value, 
[16:09:33.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.279]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.279]                     ...future.globalenv.names))
[16:09:33.279]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.279]         }, condition = base::local({
[16:09:33.279]             c <- base::c
[16:09:33.279]             inherits <- base::inherits
[16:09:33.279]             invokeRestart <- base::invokeRestart
[16:09:33.279]             length <- base::length
[16:09:33.279]             list <- base::list
[16:09:33.279]             seq.int <- base::seq.int
[16:09:33.279]             signalCondition <- base::signalCondition
[16:09:33.279]             sys.calls <- base::sys.calls
[16:09:33.279]             `[[` <- base::`[[`
[16:09:33.279]             `+` <- base::`+`
[16:09:33.279]             `<<-` <- base::`<<-`
[16:09:33.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.279]                   3L)]
[16:09:33.279]             }
[16:09:33.279]             function(cond) {
[16:09:33.279]                 is_error <- inherits(cond, "error")
[16:09:33.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.279]                   NULL)
[16:09:33.279]                 if (is_error) {
[16:09:33.279]                   sessionInformation <- function() {
[16:09:33.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.279]                       search = base::search(), system = base::Sys.info())
[16:09:33.279]                   }
[16:09:33.279]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.279]                     cond$call), session = sessionInformation(), 
[16:09:33.279]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.279]                   signalCondition(cond)
[16:09:33.279]                 }
[16:09:33.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.279]                 "immediateCondition"))) {
[16:09:33.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.279]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.279]                   if (TRUE && !signal) {
[16:09:33.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.279]                     {
[16:09:33.279]                       inherits <- base::inherits
[16:09:33.279]                       invokeRestart <- base::invokeRestart
[16:09:33.279]                       is.null <- base::is.null
[16:09:33.279]                       muffled <- FALSE
[16:09:33.279]                       if (inherits(cond, "message")) {
[16:09:33.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.279]                         if (muffled) 
[16:09:33.279]                           invokeRestart("muffleMessage")
[16:09:33.279]                       }
[16:09:33.279]                       else if (inherits(cond, "warning")) {
[16:09:33.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.279]                         if (muffled) 
[16:09:33.279]                           invokeRestart("muffleWarning")
[16:09:33.279]                       }
[16:09:33.279]                       else if (inherits(cond, "condition")) {
[16:09:33.279]                         if (!is.null(pattern)) {
[16:09:33.279]                           computeRestarts <- base::computeRestarts
[16:09:33.279]                           grepl <- base::grepl
[16:09:33.279]                           restarts <- computeRestarts(cond)
[16:09:33.279]                           for (restart in restarts) {
[16:09:33.279]                             name <- restart$name
[16:09:33.279]                             if (is.null(name)) 
[16:09:33.279]                               next
[16:09:33.279]                             if (!grepl(pattern, name)) 
[16:09:33.279]                               next
[16:09:33.279]                             invokeRestart(restart)
[16:09:33.279]                             muffled <- TRUE
[16:09:33.279]                             break
[16:09:33.279]                           }
[16:09:33.279]                         }
[16:09:33.279]                       }
[16:09:33.279]                       invisible(muffled)
[16:09:33.279]                     }
[16:09:33.279]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.279]                   }
[16:09:33.279]                 }
[16:09:33.279]                 else {
[16:09:33.279]                   if (TRUE) {
[16:09:33.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.279]                     {
[16:09:33.279]                       inherits <- base::inherits
[16:09:33.279]                       invokeRestart <- base::invokeRestart
[16:09:33.279]                       is.null <- base::is.null
[16:09:33.279]                       muffled <- FALSE
[16:09:33.279]                       if (inherits(cond, "message")) {
[16:09:33.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.279]                         if (muffled) 
[16:09:33.279]                           invokeRestart("muffleMessage")
[16:09:33.279]                       }
[16:09:33.279]                       else if (inherits(cond, "warning")) {
[16:09:33.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.279]                         if (muffled) 
[16:09:33.279]                           invokeRestart("muffleWarning")
[16:09:33.279]                       }
[16:09:33.279]                       else if (inherits(cond, "condition")) {
[16:09:33.279]                         if (!is.null(pattern)) {
[16:09:33.279]                           computeRestarts <- base::computeRestarts
[16:09:33.279]                           grepl <- base::grepl
[16:09:33.279]                           restarts <- computeRestarts(cond)
[16:09:33.279]                           for (restart in restarts) {
[16:09:33.279]                             name <- restart$name
[16:09:33.279]                             if (is.null(name)) 
[16:09:33.279]                               next
[16:09:33.279]                             if (!grepl(pattern, name)) 
[16:09:33.279]                               next
[16:09:33.279]                             invokeRestart(restart)
[16:09:33.279]                             muffled <- TRUE
[16:09:33.279]                             break
[16:09:33.279]                           }
[16:09:33.279]                         }
[16:09:33.279]                       }
[16:09:33.279]                       invisible(muffled)
[16:09:33.279]                     }
[16:09:33.279]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.279]                   }
[16:09:33.279]                 }
[16:09:33.279]             }
[16:09:33.279]         }))
[16:09:33.279]     }, error = function(ex) {
[16:09:33.279]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.279]                 ...future.rng), started = ...future.startTime, 
[16:09:33.279]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.279]             version = "1.8"), class = "FutureResult")
[16:09:33.279]     }, finally = {
[16:09:33.279]         if (!identical(...future.workdir, getwd())) 
[16:09:33.279]             setwd(...future.workdir)
[16:09:33.279]         {
[16:09:33.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.279]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.279]             }
[16:09:33.279]             base::options(...future.oldOptions)
[16:09:33.279]             if (.Platform$OS.type == "windows") {
[16:09:33.279]                 old_names <- names(...future.oldEnvVars)
[16:09:33.279]                 envs <- base::Sys.getenv()
[16:09:33.279]                 names <- names(envs)
[16:09:33.279]                 common <- intersect(names, old_names)
[16:09:33.279]                 added <- setdiff(names, old_names)
[16:09:33.279]                 removed <- setdiff(old_names, names)
[16:09:33.279]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.279]                   envs[common]]
[16:09:33.279]                 NAMES <- toupper(changed)
[16:09:33.279]                 args <- list()
[16:09:33.279]                 for (kk in seq_along(NAMES)) {
[16:09:33.279]                   name <- changed[[kk]]
[16:09:33.279]                   NAME <- NAMES[[kk]]
[16:09:33.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.279]                     next
[16:09:33.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.279]                 }
[16:09:33.279]                 NAMES <- toupper(added)
[16:09:33.279]                 for (kk in seq_along(NAMES)) {
[16:09:33.279]                   name <- added[[kk]]
[16:09:33.279]                   NAME <- NAMES[[kk]]
[16:09:33.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.279]                     next
[16:09:33.279]                   args[[name]] <- ""
[16:09:33.279]                 }
[16:09:33.279]                 NAMES <- toupper(removed)
[16:09:33.279]                 for (kk in seq_along(NAMES)) {
[16:09:33.279]                   name <- removed[[kk]]
[16:09:33.279]                   NAME <- NAMES[[kk]]
[16:09:33.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.279]                     next
[16:09:33.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.279]                 }
[16:09:33.279]                 if (length(args) > 0) 
[16:09:33.279]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.279]             }
[16:09:33.279]             else {
[16:09:33.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.279]             }
[16:09:33.279]             {
[16:09:33.279]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.279]                   0L) {
[16:09:33.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.279]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.279]                   base::options(opts)
[16:09:33.279]                 }
[16:09:33.279]                 {
[16:09:33.279]                   {
[16:09:33.279]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.279]                     NULL
[16:09:33.279]                   }
[16:09:33.279]                   options(future.plan = NULL)
[16:09:33.279]                   if (is.na(NA_character_)) 
[16:09:33.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.279]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.279]                     envir = parent.frame()) 
[16:09:33.279]                   {
[16:09:33.279]                     default_workers <- missing(workers)
[16:09:33.279]                     if (is.function(workers)) 
[16:09:33.279]                       workers <- workers()
[16:09:33.279]                     workers <- structure(as.integer(workers), 
[16:09:33.279]                       class = class(workers))
[16:09:33.279]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.279]                       1L)
[16:09:33.279]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.279]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.279]                       if (default_workers) 
[16:09:33.279]                         supportsMulticore(warn = TRUE)
[16:09:33.279]                       return(sequential(..., envir = envir))
[16:09:33.279]                     }
[16:09:33.279]                     oopts <- options(mc.cores = workers)
[16:09:33.279]                     on.exit(options(oopts))
[16:09:33.279]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.279]                       envir = envir)
[16:09:33.279]                     if (!future$lazy) 
[16:09:33.279]                       future <- run(future)
[16:09:33.279]                     invisible(future)
[16:09:33.279]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.279]                 }
[16:09:33.279]             }
[16:09:33.279]         }
[16:09:33.279]     })
[16:09:33.279]     if (TRUE) {
[16:09:33.279]         base::sink(type = "output", split = FALSE)
[16:09:33.279]         if (TRUE) {
[16:09:33.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.279]         }
[16:09:33.279]         else {
[16:09:33.279]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.279]         }
[16:09:33.279]         base::close(...future.stdout)
[16:09:33.279]         ...future.stdout <- NULL
[16:09:33.279]     }
[16:09:33.279]     ...future.result$conditions <- ...future.conditions
[16:09:33.279]     ...future.result$finished <- base::Sys.time()
[16:09:33.279]     ...future.result
[16:09:33.279] }
[16:09:33.282] assign_globals() ...
[16:09:33.282] List of 5
[16:09:33.282]  $ ...future.FUN            :function (object, ...)  
[16:09:33.282]  $ future.call.arguments    :List of 1
[16:09:33.282]   ..$ digits: int 2
[16:09:33.282]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.282]  $ ...future.elements_ii    :List of 3
[16:09:33.282]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:09:33.282]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:09:33.282]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:09:33.282]  $ ...future.seeds_ii       : NULL
[16:09:33.282]  $ ...future.globals.maxSize: NULL
[16:09:33.282]  - attr(*, "resolved")= logi FALSE
[16:09:33.282]  - attr(*, "total_size")= num 1296
[16:09:33.282]  - attr(*, "where")=List of 5
[16:09:33.282]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.282]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.282]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.282]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.282]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.282]  - attr(*, "already-done")= logi TRUE
[16:09:33.290] - copied ‘...future.FUN’ to environment
[16:09:33.290] - copied ‘future.call.arguments’ to environment
[16:09:33.290] - copied ‘...future.elements_ii’ to environment
[16:09:33.290] - copied ‘...future.seeds_ii’ to environment
[16:09:33.292] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.293] assign_globals() ... done
[16:09:33.293] requestCore(): workers = 2
[16:09:33.295] MulticoreFuture started
[16:09:33.296] - Launch lazy future ... done
[16:09:33.296] run() for ‘MulticoreFuture’ ... done
[16:09:33.296] plan(): Setting new future strategy stack:
[16:09:33.297] Created future:
[16:09:33.297] List of future strategies:
[16:09:33.297] 1. sequential:
[16:09:33.297]    - args: function (..., envir = parent.frame())
[16:09:33.297]    - tweaked: FALSE
[16:09:33.297]    - call: NULL
[16:09:33.298] plan(): nbrOfWorkers() = 1
[16:09:33.302] plan(): Setting new future strategy stack:
[16:09:33.302] List of future strategies:
[16:09:33.302] 1. multicore:
[16:09:33.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.302]    - tweaked: FALSE
[16:09:33.302]    - call: plan(strategy)
[16:09:33.308] plan(): nbrOfWorkers() = 2
[16:09:33.297] MulticoreFuture:
[16:09:33.297] Label: ‘future_by-2’
[16:09:33.297] Expression:
[16:09:33.297] {
[16:09:33.297]     do.call(function(...) {
[16:09:33.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.297]             on.exit(options(oopts), add = TRUE)
[16:09:33.297]         }
[16:09:33.297]         {
[16:09:33.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.297]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.297]             })
[16:09:33.297]         }
[16:09:33.297]     }, args = future.call.arguments)
[16:09:33.297] }
[16:09:33.297] Lazy evaluation: FALSE
[16:09:33.297] Asynchronous evaluation: TRUE
[16:09:33.297] Local evaluation: TRUE
[16:09:33.297] Environment: R_GlobalEnv
[16:09:33.297] Capture standard output: TRUE
[16:09:33.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.297] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.297] Packages: <none>
[16:09:33.297] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.297] Resolved: TRUE
[16:09:33.297] Value: <not collected>
[16:09:33.297] Conditions captured: <none>
[16:09:33.297] Early signaling: FALSE
[16:09:33.297] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.297] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.309] Chunk #2 of 2 ... DONE
[16:09:33.309] Launching 2 futures (chunks) ... DONE
[16:09:33.309] Resolving 2 futures (chunks) ...
[16:09:33.310] resolve() on list ...
[16:09:33.310]  recursive: 0
[16:09:33.310]  length: 2
[16:09:33.310] 
[16:09:33.311] Future #1
[16:09:33.312] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:33.312] - nx: 2
[16:09:33.312] - relay: TRUE
[16:09:33.312] - stdout: TRUE
[16:09:33.312] - signal: TRUE
[16:09:33.313] - resignal: FALSE
[16:09:33.313] - force: TRUE
[16:09:33.313] - relayed: [n=2] FALSE, FALSE
[16:09:33.313] - queued futures: [n=2] FALSE, FALSE
[16:09:33.313]  - until=1
[16:09:33.314]  - relaying element #1
[16:09:33.314] - relayed: [n=2] TRUE, FALSE
[16:09:33.314] - queued futures: [n=2] TRUE, FALSE
[16:09:33.315] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:33.315]  length: 1 (resolved future 1)
[16:09:33.315] Future #2
[16:09:33.316] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:33.316] - nx: 2
[16:09:33.317] - relay: TRUE
[16:09:33.317] - stdout: TRUE
[16:09:33.317] - signal: TRUE
[16:09:33.317] - resignal: FALSE
[16:09:33.317] - force: TRUE
[16:09:33.317] - relayed: [n=2] TRUE, FALSE
[16:09:33.317] - queued futures: [n=2] TRUE, FALSE
[16:09:33.318]  - until=2
[16:09:33.318]  - relaying element #2
[16:09:33.318] - relayed: [n=2] TRUE, TRUE
[16:09:33.318] - queued futures: [n=2] TRUE, TRUE
[16:09:33.318] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:33.318]  length: 0 (resolved future 2)
[16:09:33.318] Relaying remaining futures
[16:09:33.319] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.319] - nx: 2
[16:09:33.319] - relay: TRUE
[16:09:33.319] - stdout: TRUE
[16:09:33.319] - signal: TRUE
[16:09:33.319] - resignal: FALSE
[16:09:33.319] - force: TRUE
[16:09:33.319] - relayed: [n=2] TRUE, TRUE
[16:09:33.319] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:33.320] - relayed: [n=2] TRUE, TRUE
[16:09:33.320] - queued futures: [n=2] TRUE, TRUE
[16:09:33.320] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.320] resolve() on list ... DONE
[16:09:33.320]  - Number of value chunks collected: 2
[16:09:33.320] Resolving 2 futures (chunks) ... DONE
[16:09:33.320] Reducing values from 2 chunks ...
[16:09:33.321]  - Number of values collected after concatenation: 6
[16:09:33.321]  - Number of values expected: 6
[16:09:33.321] Reducing values from 2 chunks ... DONE
[16:09:33.321] future_lapply() ... DONE
[16:09:33.321] future_by_internal() ... DONE
[16:09:33.322] future_by_internal() ...
[16:09:33.323] future_lapply() ...
[16:09:33.327] Number of chunks: 2
[16:09:33.328] getGlobalsAndPackagesXApply() ...
[16:09:33.328]  - future.globals: TRUE
[16:09:33.328] getGlobalsAndPackages() ...
[16:09:33.328] Searching for globals...
[16:09:33.330] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:33.330] Searching for globals ... DONE
[16:09:33.330] Resolving globals: FALSE
[16:09:33.330] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:09:33.331] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:09:33.331] - globals: [1] ‘FUN’
[16:09:33.331] - packages: [1] ‘stats’
[16:09:33.331] getGlobalsAndPackages() ... DONE
[16:09:33.331]  - globals found/used: [n=1] ‘FUN’
[16:09:33.331]  - needed namespaces: [n=1] ‘stats’
[16:09:33.332] Finding globals ... DONE
[16:09:33.332]  - use_args: TRUE
[16:09:33.332]  - Getting '...' globals ...
[16:09:33.332] resolve() on list ...
[16:09:33.332]  recursive: 0
[16:09:33.332]  length: 1
[16:09:33.332]  elements: ‘...’
[16:09:33.333]  length: 0 (resolved future 1)
[16:09:33.333] resolve() on list ... DONE
[16:09:33.333]    - '...' content: [n=1] ‘singular.ok’
[16:09:33.333] List of 1
[16:09:33.333]  $ ...:List of 1
[16:09:33.333]   ..$ singular.ok: logi FALSE
[16:09:33.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.333]  - attr(*, "where")=List of 1
[16:09:33.333]   ..$ ...:<environment: 0x5567e8423428> 
[16:09:33.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.333]  - attr(*, "resolved")= logi TRUE
[16:09:33.333]  - attr(*, "total_size")= num NA
[16:09:33.339]  - Getting '...' globals ... DONE
[16:09:33.339] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.339] List of 2
[16:09:33.339]  $ ...future.FUN:function (x, ...)  
[16:09:33.339]  $ ...          :List of 1
[16:09:33.339]   ..$ singular.ok: logi FALSE
[16:09:33.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.339]  - attr(*, "where")=List of 2
[16:09:33.339]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.339]   ..$ ...          :<environment: 0x5567e8423428> 
[16:09:33.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.339]  - attr(*, "resolved")= logi FALSE
[16:09:33.339]  - attr(*, "total_size")= num 5384
[16:09:33.342] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:33.342] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.343] Number of futures (= number of chunks): 2
[16:09:33.343] Launching 2 futures (chunks) ...
[16:09:33.343] Chunk #1 of 2 ...
[16:09:33.343]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.343] getGlobalsAndPackages() ...
[16:09:33.343] Searching for globals...
[16:09:33.344] 
[16:09:33.344] Searching for globals ... DONE
[16:09:33.344] - globals: [0] <none>
[16:09:33.344] getGlobalsAndPackages() ... DONE
[16:09:33.344]    + additional globals found: [n=0] 
[16:09:33.344]    + additional namespaces needed: [n=0] 
[16:09:33.344]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.344]  - seeds: <none>
[16:09:33.344] getGlobalsAndPackages() ...
[16:09:33.344] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.345] Resolving globals: FALSE
[16:09:33.345] Tweak future expression to call with '...' arguments ...
[16:09:33.345] {
[16:09:33.345]     do.call(function(...) {
[16:09:33.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.345]             on.exit(options(oopts), add = TRUE)
[16:09:33.345]         }
[16:09:33.345]         {
[16:09:33.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.345]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.345]             })
[16:09:33.345]         }
[16:09:33.345]     }, args = future.call.arguments)
[16:09:33.345] }
[16:09:33.345] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.345] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.345] 
[16:09:33.346] getGlobalsAndPackages() ... DONE
[16:09:33.346] run() for ‘Future’ ...
[16:09:33.346] - state: ‘created’
[16:09:33.346] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.350] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.350]   - Field: ‘label’
[16:09:33.350]   - Field: ‘local’
[16:09:33.350]   - Field: ‘owner’
[16:09:33.350]   - Field: ‘envir’
[16:09:33.350]   - Field: ‘workers’
[16:09:33.350]   - Field: ‘packages’
[16:09:33.351]   - Field: ‘gc’
[16:09:33.351]   - Field: ‘job’
[16:09:33.351]   - Field: ‘conditions’
[16:09:33.351]   - Field: ‘expr’
[16:09:33.351]   - Field: ‘uuid’
[16:09:33.351]   - Field: ‘seed’
[16:09:33.351]   - Field: ‘version’
[16:09:33.351]   - Field: ‘result’
[16:09:33.351]   - Field: ‘asynchronous’
[16:09:33.351]   - Field: ‘calls’
[16:09:33.352]   - Field: ‘globals’
[16:09:33.352]   - Field: ‘stdout’
[16:09:33.352]   - Field: ‘earlySignal’
[16:09:33.352]   - Field: ‘lazy’
[16:09:33.352]   - Field: ‘state’
[16:09:33.352] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.352] - Launch lazy future ...
[16:09:33.352] Packages needed by the future expression (n = 1): ‘stats’
[16:09:33.353] Packages needed by future strategies (n = 0): <none>
[16:09:33.353] {
[16:09:33.353]     {
[16:09:33.353]         {
[16:09:33.353]             ...future.startTime <- base::Sys.time()
[16:09:33.353]             {
[16:09:33.353]                 {
[16:09:33.353]                   {
[16:09:33.353]                     {
[16:09:33.353]                       {
[16:09:33.353]                         base::local({
[16:09:33.353]                           has_future <- base::requireNamespace("future", 
[16:09:33.353]                             quietly = TRUE)
[16:09:33.353]                           if (has_future) {
[16:09:33.353]                             ns <- base::getNamespace("future")
[16:09:33.353]                             version <- ns[[".package"]][["version"]]
[16:09:33.353]                             if (is.null(version)) 
[16:09:33.353]                               version <- utils::packageVersion("future")
[16:09:33.353]                           }
[16:09:33.353]                           else {
[16:09:33.353]                             version <- NULL
[16:09:33.353]                           }
[16:09:33.353]                           if (!has_future || version < "1.8.0") {
[16:09:33.353]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.353]                               "", base::R.version$version.string), 
[16:09:33.353]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:33.353]                                 base::R.version$platform, 8 * 
[16:09:33.353]                                   base::.Machine$sizeof.pointer), 
[16:09:33.353]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.353]                                 "release", "version")], collapse = " "), 
[16:09:33.353]                               hostname = base::Sys.info()[["nodename"]])
[16:09:33.353]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.353]                               info)
[16:09:33.353]                             info <- base::paste(info, collapse = "; ")
[16:09:33.353]                             if (!has_future) {
[16:09:33.353]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.353]                                 info)
[16:09:33.353]                             }
[16:09:33.353]                             else {
[16:09:33.353]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.353]                                 info, version)
[16:09:33.353]                             }
[16:09:33.353]                             base::stop(msg)
[16:09:33.353]                           }
[16:09:33.353]                         })
[16:09:33.353]                       }
[16:09:33.353]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.353]                       base::options(mc.cores = 1L)
[16:09:33.353]                     }
[16:09:33.353]                     base::local({
[16:09:33.353]                       for (pkg in "stats") {
[16:09:33.353]                         base::loadNamespace(pkg)
[16:09:33.353]                         base::library(pkg, character.only = TRUE)
[16:09:33.353]                       }
[16:09:33.353]                     })
[16:09:33.353]                   }
[16:09:33.353]                   options(future.plan = NULL)
[16:09:33.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.353]                 }
[16:09:33.353]                 ...future.workdir <- getwd()
[16:09:33.353]             }
[16:09:33.353]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.353]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.353]         }
[16:09:33.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:33.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.353]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.353]             base::names(...future.oldOptions))
[16:09:33.353]     }
[16:09:33.353]     if (FALSE) {
[16:09:33.353]     }
[16:09:33.353]     else {
[16:09:33.353]         if (TRUE) {
[16:09:33.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.353]                 open = "w")
[16:09:33.353]         }
[16:09:33.353]         else {
[16:09:33.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.353]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.353]         }
[16:09:33.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.353]             base::sink(type = "output", split = FALSE)
[16:09:33.353]             base::close(...future.stdout)
[16:09:33.353]         }, add = TRUE)
[16:09:33.353]     }
[16:09:33.353]     ...future.frame <- base::sys.nframe()
[16:09:33.353]     ...future.conditions <- base::list()
[16:09:33.353]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.353]     if (FALSE) {
[16:09:33.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.353]     }
[16:09:33.353]     ...future.result <- base::tryCatch({
[16:09:33.353]         base::withCallingHandlers({
[16:09:33.353]             ...future.value <- base::withVisible(base::local({
[16:09:33.353]                 withCallingHandlers({
[16:09:33.353]                   {
[16:09:33.353]                     do.call(function(...) {
[16:09:33.353]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.353]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.353]                         ...future.globals.maxSize)) {
[16:09:33.353]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.353]                         on.exit(options(oopts), add = TRUE)
[16:09:33.353]                       }
[16:09:33.353]                       {
[16:09:33.353]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.353]                           FUN = function(jj) {
[16:09:33.353]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.353]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.353]                           })
[16:09:33.353]                       }
[16:09:33.353]                     }, args = future.call.arguments)
[16:09:33.353]                   }
[16:09:33.353]                 }, immediateCondition = function(cond) {
[16:09:33.353]                   save_rds <- function (object, pathname, ...) 
[16:09:33.353]                   {
[16:09:33.353]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.353]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.353]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.353]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.353]                         fi_tmp[["mtime"]])
[16:09:33.353]                     }
[16:09:33.353]                     tryCatch({
[16:09:33.353]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.353]                     }, error = function(ex) {
[16:09:33.353]                       msg <- conditionMessage(ex)
[16:09:33.353]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.353]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.353]                         fi_tmp[["mtime"]], msg)
[16:09:33.353]                       ex$message <- msg
[16:09:33.353]                       stop(ex)
[16:09:33.353]                     })
[16:09:33.353]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.353]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.353]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.353]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.353]                       fi <- file.info(pathname)
[16:09:33.353]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.353]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.353]                         fi[["size"]], fi[["mtime"]])
[16:09:33.353]                       stop(msg)
[16:09:33.353]                     }
[16:09:33.353]                     invisible(pathname)
[16:09:33.353]                   }
[16:09:33.353]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.353]                     rootPath = tempdir()) 
[16:09:33.353]                   {
[16:09:33.353]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.353]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.353]                       tmpdir = path, fileext = ".rds")
[16:09:33.353]                     save_rds(obj, file)
[16:09:33.353]                   }
[16:09:33.353]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.353]                   {
[16:09:33.353]                     inherits <- base::inherits
[16:09:33.353]                     invokeRestart <- base::invokeRestart
[16:09:33.353]                     is.null <- base::is.null
[16:09:33.353]                     muffled <- FALSE
[16:09:33.353]                     if (inherits(cond, "message")) {
[16:09:33.353]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.353]                       if (muffled) 
[16:09:33.353]                         invokeRestart("muffleMessage")
[16:09:33.353]                     }
[16:09:33.353]                     else if (inherits(cond, "warning")) {
[16:09:33.353]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.353]                       if (muffled) 
[16:09:33.353]                         invokeRestart("muffleWarning")
[16:09:33.353]                     }
[16:09:33.353]                     else if (inherits(cond, "condition")) {
[16:09:33.353]                       if (!is.null(pattern)) {
[16:09:33.353]                         computeRestarts <- base::computeRestarts
[16:09:33.353]                         grepl <- base::grepl
[16:09:33.353]                         restarts <- computeRestarts(cond)
[16:09:33.353]                         for (restart in restarts) {
[16:09:33.353]                           name <- restart$name
[16:09:33.353]                           if (is.null(name)) 
[16:09:33.353]                             next
[16:09:33.353]                           if (!grepl(pattern, name)) 
[16:09:33.353]                             next
[16:09:33.353]                           invokeRestart(restart)
[16:09:33.353]                           muffled <- TRUE
[16:09:33.353]                           break
[16:09:33.353]                         }
[16:09:33.353]                       }
[16:09:33.353]                     }
[16:09:33.353]                     invisible(muffled)
[16:09:33.353]                   }
[16:09:33.353]                   muffleCondition(cond)
[16:09:33.353]                 })
[16:09:33.353]             }))
[16:09:33.353]             future::FutureResult(value = ...future.value$value, 
[16:09:33.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.353]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.353]                     ...future.globalenv.names))
[16:09:33.353]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.353]         }, condition = base::local({
[16:09:33.353]             c <- base::c
[16:09:33.353]             inherits <- base::inherits
[16:09:33.353]             invokeRestart <- base::invokeRestart
[16:09:33.353]             length <- base::length
[16:09:33.353]             list <- base::list
[16:09:33.353]             seq.int <- base::seq.int
[16:09:33.353]             signalCondition <- base::signalCondition
[16:09:33.353]             sys.calls <- base::sys.calls
[16:09:33.353]             `[[` <- base::`[[`
[16:09:33.353]             `+` <- base::`+`
[16:09:33.353]             `<<-` <- base::`<<-`
[16:09:33.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.353]                   3L)]
[16:09:33.353]             }
[16:09:33.353]             function(cond) {
[16:09:33.353]                 is_error <- inherits(cond, "error")
[16:09:33.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.353]                   NULL)
[16:09:33.353]                 if (is_error) {
[16:09:33.353]                   sessionInformation <- function() {
[16:09:33.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.353]                       search = base::search(), system = base::Sys.info())
[16:09:33.353]                   }
[16:09:33.353]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.353]                     cond$call), session = sessionInformation(), 
[16:09:33.353]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.353]                   signalCondition(cond)
[16:09:33.353]                 }
[16:09:33.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.353]                 "immediateCondition"))) {
[16:09:33.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.353]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.353]                   if (TRUE && !signal) {
[16:09:33.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.353]                     {
[16:09:33.353]                       inherits <- base::inherits
[16:09:33.353]                       invokeRestart <- base::invokeRestart
[16:09:33.353]                       is.null <- base::is.null
[16:09:33.353]                       muffled <- FALSE
[16:09:33.353]                       if (inherits(cond, "message")) {
[16:09:33.353]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.353]                         if (muffled) 
[16:09:33.353]                           invokeRestart("muffleMessage")
[16:09:33.353]                       }
[16:09:33.353]                       else if (inherits(cond, "warning")) {
[16:09:33.353]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.353]                         if (muffled) 
[16:09:33.353]                           invokeRestart("muffleWarning")
[16:09:33.353]                       }
[16:09:33.353]                       else if (inherits(cond, "condition")) {
[16:09:33.353]                         if (!is.null(pattern)) {
[16:09:33.353]                           computeRestarts <- base::computeRestarts
[16:09:33.353]                           grepl <- base::grepl
[16:09:33.353]                           restarts <- computeRestarts(cond)
[16:09:33.353]                           for (restart in restarts) {
[16:09:33.353]                             name <- restart$name
[16:09:33.353]                             if (is.null(name)) 
[16:09:33.353]                               next
[16:09:33.353]                             if (!grepl(pattern, name)) 
[16:09:33.353]                               next
[16:09:33.353]                             invokeRestart(restart)
[16:09:33.353]                             muffled <- TRUE
[16:09:33.353]                             break
[16:09:33.353]                           }
[16:09:33.353]                         }
[16:09:33.353]                       }
[16:09:33.353]                       invisible(muffled)
[16:09:33.353]                     }
[16:09:33.353]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.353]                   }
[16:09:33.353]                 }
[16:09:33.353]                 else {
[16:09:33.353]                   if (TRUE) {
[16:09:33.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.353]                     {
[16:09:33.353]                       inherits <- base::inherits
[16:09:33.353]                       invokeRestart <- base::invokeRestart
[16:09:33.353]                       is.null <- base::is.null
[16:09:33.353]                       muffled <- FALSE
[16:09:33.353]                       if (inherits(cond, "message")) {
[16:09:33.353]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.353]                         if (muffled) 
[16:09:33.353]                           invokeRestart("muffleMessage")
[16:09:33.353]                       }
[16:09:33.353]                       else if (inherits(cond, "warning")) {
[16:09:33.353]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.353]                         if (muffled) 
[16:09:33.353]                           invokeRestart("muffleWarning")
[16:09:33.353]                       }
[16:09:33.353]                       else if (inherits(cond, "condition")) {
[16:09:33.353]                         if (!is.null(pattern)) {
[16:09:33.353]                           computeRestarts <- base::computeRestarts
[16:09:33.353]                           grepl <- base::grepl
[16:09:33.353]                           restarts <- computeRestarts(cond)
[16:09:33.353]                           for (restart in restarts) {
[16:09:33.353]                             name <- restart$name
[16:09:33.353]                             if (is.null(name)) 
[16:09:33.353]                               next
[16:09:33.353]                             if (!grepl(pattern, name)) 
[16:09:33.353]                               next
[16:09:33.353]                             invokeRestart(restart)
[16:09:33.353]                             muffled <- TRUE
[16:09:33.353]                             break
[16:09:33.353]                           }
[16:09:33.353]                         }
[16:09:33.353]                       }
[16:09:33.353]                       invisible(muffled)
[16:09:33.353]                     }
[16:09:33.353]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.353]                   }
[16:09:33.353]                 }
[16:09:33.353]             }
[16:09:33.353]         }))
[16:09:33.353]     }, error = function(ex) {
[16:09:33.353]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.353]                 ...future.rng), started = ...future.startTime, 
[16:09:33.353]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.353]             version = "1.8"), class = "FutureResult")
[16:09:33.353]     }, finally = {
[16:09:33.353]         if (!identical(...future.workdir, getwd())) 
[16:09:33.353]             setwd(...future.workdir)
[16:09:33.353]         {
[16:09:33.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.353]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.353]             }
[16:09:33.353]             base::options(...future.oldOptions)
[16:09:33.353]             if (.Platform$OS.type == "windows") {
[16:09:33.353]                 old_names <- names(...future.oldEnvVars)
[16:09:33.353]                 envs <- base::Sys.getenv()
[16:09:33.353]                 names <- names(envs)
[16:09:33.353]                 common <- intersect(names, old_names)
[16:09:33.353]                 added <- setdiff(names, old_names)
[16:09:33.353]                 removed <- setdiff(old_names, names)
[16:09:33.353]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.353]                   envs[common]]
[16:09:33.353]                 NAMES <- toupper(changed)
[16:09:33.353]                 args <- list()
[16:09:33.353]                 for (kk in seq_along(NAMES)) {
[16:09:33.353]                   name <- changed[[kk]]
[16:09:33.353]                   NAME <- NAMES[[kk]]
[16:09:33.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.353]                     next
[16:09:33.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.353]                 }
[16:09:33.353]                 NAMES <- toupper(added)
[16:09:33.353]                 for (kk in seq_along(NAMES)) {
[16:09:33.353]                   name <- added[[kk]]
[16:09:33.353]                   NAME <- NAMES[[kk]]
[16:09:33.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.353]                     next
[16:09:33.353]                   args[[name]] <- ""
[16:09:33.353]                 }
[16:09:33.353]                 NAMES <- toupper(removed)
[16:09:33.353]                 for (kk in seq_along(NAMES)) {
[16:09:33.353]                   name <- removed[[kk]]
[16:09:33.353]                   NAME <- NAMES[[kk]]
[16:09:33.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.353]                     next
[16:09:33.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.353]                 }
[16:09:33.353]                 if (length(args) > 0) 
[16:09:33.353]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.353]             }
[16:09:33.353]             else {
[16:09:33.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.353]             }
[16:09:33.353]             {
[16:09:33.353]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.353]                   0L) {
[16:09:33.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.353]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.353]                   base::options(opts)
[16:09:33.353]                 }
[16:09:33.353]                 {
[16:09:33.353]                   {
[16:09:33.353]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.353]                     NULL
[16:09:33.353]                   }
[16:09:33.353]                   options(future.plan = NULL)
[16:09:33.353]                   if (is.na(NA_character_)) 
[16:09:33.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.353]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.353]                     envir = parent.frame()) 
[16:09:33.353]                   {
[16:09:33.353]                     default_workers <- missing(workers)
[16:09:33.353]                     if (is.function(workers)) 
[16:09:33.353]                       workers <- workers()
[16:09:33.353]                     workers <- structure(as.integer(workers), 
[16:09:33.353]                       class = class(workers))
[16:09:33.353]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.353]                       1L)
[16:09:33.353]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.353]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.353]                       if (default_workers) 
[16:09:33.353]                         supportsMulticore(warn = TRUE)
[16:09:33.353]                       return(sequential(..., envir = envir))
[16:09:33.353]                     }
[16:09:33.353]                     oopts <- options(mc.cores = workers)
[16:09:33.353]                     on.exit(options(oopts))
[16:09:33.353]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.353]                       envir = envir)
[16:09:33.353]                     if (!future$lazy) 
[16:09:33.353]                       future <- run(future)
[16:09:33.353]                     invisible(future)
[16:09:33.353]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.353]                 }
[16:09:33.353]             }
[16:09:33.353]         }
[16:09:33.353]     })
[16:09:33.353]     if (TRUE) {
[16:09:33.353]         base::sink(type = "output", split = FALSE)
[16:09:33.353]         if (TRUE) {
[16:09:33.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.353]         }
[16:09:33.353]         else {
[16:09:33.353]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.353]         }
[16:09:33.353]         base::close(...future.stdout)
[16:09:33.353]         ...future.stdout <- NULL
[16:09:33.353]     }
[16:09:33.353]     ...future.result$conditions <- ...future.conditions
[16:09:33.353]     ...future.result$finished <- base::Sys.time()
[16:09:33.353]     ...future.result
[16:09:33.353] }
[16:09:33.356] assign_globals() ...
[16:09:33.356] List of 5
[16:09:33.356]  $ ...future.FUN            :function (x, ...)  
[16:09:33.356]  $ future.call.arguments    :List of 1
[16:09:33.356]   ..$ singular.ok: logi FALSE
[16:09:33.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.356]  $ ...future.elements_ii    :List of 1
[16:09:33.356]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.356]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.356]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.356]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.356]  $ ...future.seeds_ii       : NULL
[16:09:33.356]  $ ...future.globals.maxSize: NULL
[16:09:33.356]  - attr(*, "where")=List of 5
[16:09:33.356]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.356]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.356]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.356]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.356]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.356]  - attr(*, "resolved")= logi FALSE
[16:09:33.356]  - attr(*, "total_size")= num 5384
[16:09:33.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.356]  - attr(*, "already-done")= logi TRUE
[16:09:33.364] - reassign environment for ‘...future.FUN’
[16:09:33.364] - copied ‘...future.FUN’ to environment
[16:09:33.364] - copied ‘future.call.arguments’ to environment
[16:09:33.365] - copied ‘...future.elements_ii’ to environment
[16:09:33.365] - copied ‘...future.seeds_ii’ to environment
[16:09:33.365] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.365] assign_globals() ... done
[16:09:33.365] requestCore(): workers = 2
[16:09:33.367] MulticoreFuture started
[16:09:33.368] - Launch lazy future ... done
[16:09:33.368] run() for ‘MulticoreFuture’ ... done
[16:09:33.369] Created future:
[16:09:33.369] plan(): Setting new future strategy stack:
[16:09:33.369] List of future strategies:
[16:09:33.369] 1. sequential:
[16:09:33.369]    - args: function (..., envir = parent.frame())
[16:09:33.369]    - tweaked: FALSE
[16:09:33.369]    - call: NULL
[16:09:33.370] plan(): nbrOfWorkers() = 1
[16:09:33.374] plan(): Setting new future strategy stack:
[16:09:33.375] List of future strategies:
[16:09:33.375] 1. multicore:
[16:09:33.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.375]    - tweaked: FALSE
[16:09:33.375]    - call: plan(strategy)
[16:09:33.380] plan(): nbrOfWorkers() = 2
[16:09:33.369] MulticoreFuture:
[16:09:33.369] Label: ‘future_by-1’
[16:09:33.369] Expression:
[16:09:33.369] {
[16:09:33.369]     do.call(function(...) {
[16:09:33.369]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.369]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.369]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.369]             on.exit(options(oopts), add = TRUE)
[16:09:33.369]         }
[16:09:33.369]         {
[16:09:33.369]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.369]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.369]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.369]             })
[16:09:33.369]         }
[16:09:33.369]     }, args = future.call.arguments)
[16:09:33.369] }
[16:09:33.369] Lazy evaluation: FALSE
[16:09:33.369] Asynchronous evaluation: TRUE
[16:09:33.369] Local evaluation: TRUE
[16:09:33.369] Environment: R_GlobalEnv
[16:09:33.369] Capture standard output: TRUE
[16:09:33.369] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.369] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.369] Packages: 1 packages (‘stats’)
[16:09:33.369] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.369] Resolved: TRUE
[16:09:33.369] Value: <not collected>
[16:09:33.369] Conditions captured: <none>
[16:09:33.369] Early signaling: FALSE
[16:09:33.369] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.369] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.382] Chunk #1 of 2 ... DONE
[16:09:33.382] Chunk #2 of 2 ...
[16:09:33.382]  - Finding globals in 'X' for chunk #2 ...
[16:09:33.382] getGlobalsAndPackages() ...
[16:09:33.382] Searching for globals...
[16:09:33.383] 
[16:09:33.383] Searching for globals ... DONE
[16:09:33.383] - globals: [0] <none>
[16:09:33.384] getGlobalsAndPackages() ... DONE
[16:09:33.384]    + additional globals found: [n=0] 
[16:09:33.384]    + additional namespaces needed: [n=0] 
[16:09:33.384]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:33.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:33.384]  - seeds: <none>
[16:09:33.384] getGlobalsAndPackages() ...
[16:09:33.385] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.385] Resolving globals: FALSE
[16:09:33.385] Tweak future expression to call with '...' arguments ...
[16:09:33.385] {
[16:09:33.385]     do.call(function(...) {
[16:09:33.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.385]             on.exit(options(oopts), add = TRUE)
[16:09:33.385]         }
[16:09:33.385]         {
[16:09:33.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.385]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.385]             })
[16:09:33.385]         }
[16:09:33.385]     }, args = future.call.arguments)
[16:09:33.385] }
[16:09:33.386] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.386] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.386] 
[16:09:33.387] getGlobalsAndPackages() ... DONE
[16:09:33.387] run() for ‘Future’ ...
[16:09:33.387] - state: ‘created’
[16:09:33.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.392] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.392]   - Field: ‘label’
[16:09:33.392]   - Field: ‘local’
[16:09:33.393]   - Field: ‘owner’
[16:09:33.393]   - Field: ‘envir’
[16:09:33.393]   - Field: ‘workers’
[16:09:33.393]   - Field: ‘packages’
[16:09:33.393]   - Field: ‘gc’
[16:09:33.393]   - Field: ‘job’
[16:09:33.393]   - Field: ‘conditions’
[16:09:33.394]   - Field: ‘expr’
[16:09:33.394]   - Field: ‘uuid’
[16:09:33.394]   - Field: ‘seed’
[16:09:33.394]   - Field: ‘version’
[16:09:33.394]   - Field: ‘result’
[16:09:33.394]   - Field: ‘asynchronous’
[16:09:33.394]   - Field: ‘calls’
[16:09:33.395]   - Field: ‘globals’
[16:09:33.395]   - Field: ‘stdout’
[16:09:33.395]   - Field: ‘earlySignal’
[16:09:33.395]   - Field: ‘lazy’
[16:09:33.395]   - Field: ‘state’
[16:09:33.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.395] - Launch lazy future ...
[16:09:33.396] Packages needed by the future expression (n = 1): ‘stats’
[16:09:33.396] Packages needed by future strategies (n = 0): <none>
[16:09:33.397] {
[16:09:33.397]     {
[16:09:33.397]         {
[16:09:33.397]             ...future.startTime <- base::Sys.time()
[16:09:33.397]             {
[16:09:33.397]                 {
[16:09:33.397]                   {
[16:09:33.397]                     {
[16:09:33.397]                       {
[16:09:33.397]                         base::local({
[16:09:33.397]                           has_future <- base::requireNamespace("future", 
[16:09:33.397]                             quietly = TRUE)
[16:09:33.397]                           if (has_future) {
[16:09:33.397]                             ns <- base::getNamespace("future")
[16:09:33.397]                             version <- ns[[".package"]][["version"]]
[16:09:33.397]                             if (is.null(version)) 
[16:09:33.397]                               version <- utils::packageVersion("future")
[16:09:33.397]                           }
[16:09:33.397]                           else {
[16:09:33.397]                             version <- NULL
[16:09:33.397]                           }
[16:09:33.397]                           if (!has_future || version < "1.8.0") {
[16:09:33.397]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.397]                               "", base::R.version$version.string), 
[16:09:33.397]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:33.397]                                 base::R.version$platform, 8 * 
[16:09:33.397]                                   base::.Machine$sizeof.pointer), 
[16:09:33.397]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.397]                                 "release", "version")], collapse = " "), 
[16:09:33.397]                               hostname = base::Sys.info()[["nodename"]])
[16:09:33.397]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.397]                               info)
[16:09:33.397]                             info <- base::paste(info, collapse = "; ")
[16:09:33.397]                             if (!has_future) {
[16:09:33.397]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.397]                                 info)
[16:09:33.397]                             }
[16:09:33.397]                             else {
[16:09:33.397]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.397]                                 info, version)
[16:09:33.397]                             }
[16:09:33.397]                             base::stop(msg)
[16:09:33.397]                           }
[16:09:33.397]                         })
[16:09:33.397]                       }
[16:09:33.397]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.397]                       base::options(mc.cores = 1L)
[16:09:33.397]                     }
[16:09:33.397]                     base::local({
[16:09:33.397]                       for (pkg in "stats") {
[16:09:33.397]                         base::loadNamespace(pkg)
[16:09:33.397]                         base::library(pkg, character.only = TRUE)
[16:09:33.397]                       }
[16:09:33.397]                     })
[16:09:33.397]                   }
[16:09:33.397]                   options(future.plan = NULL)
[16:09:33.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.397]                 }
[16:09:33.397]                 ...future.workdir <- getwd()
[16:09:33.397]             }
[16:09:33.397]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.397]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.397]         }
[16:09:33.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.397]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:33.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.397]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.397]             base::names(...future.oldOptions))
[16:09:33.397]     }
[16:09:33.397]     if (FALSE) {
[16:09:33.397]     }
[16:09:33.397]     else {
[16:09:33.397]         if (TRUE) {
[16:09:33.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.397]                 open = "w")
[16:09:33.397]         }
[16:09:33.397]         else {
[16:09:33.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.397]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.397]         }
[16:09:33.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.397]             base::sink(type = "output", split = FALSE)
[16:09:33.397]             base::close(...future.stdout)
[16:09:33.397]         }, add = TRUE)
[16:09:33.397]     }
[16:09:33.397]     ...future.frame <- base::sys.nframe()
[16:09:33.397]     ...future.conditions <- base::list()
[16:09:33.397]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.397]     if (FALSE) {
[16:09:33.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.397]     }
[16:09:33.397]     ...future.result <- base::tryCatch({
[16:09:33.397]         base::withCallingHandlers({
[16:09:33.397]             ...future.value <- base::withVisible(base::local({
[16:09:33.397]                 withCallingHandlers({
[16:09:33.397]                   {
[16:09:33.397]                     do.call(function(...) {
[16:09:33.397]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.397]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.397]                         ...future.globals.maxSize)) {
[16:09:33.397]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.397]                         on.exit(options(oopts), add = TRUE)
[16:09:33.397]                       }
[16:09:33.397]                       {
[16:09:33.397]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.397]                           FUN = function(jj) {
[16:09:33.397]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.397]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.397]                           })
[16:09:33.397]                       }
[16:09:33.397]                     }, args = future.call.arguments)
[16:09:33.397]                   }
[16:09:33.397]                 }, immediateCondition = function(cond) {
[16:09:33.397]                   save_rds <- function (object, pathname, ...) 
[16:09:33.397]                   {
[16:09:33.397]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.397]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.397]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.397]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.397]                         fi_tmp[["mtime"]])
[16:09:33.397]                     }
[16:09:33.397]                     tryCatch({
[16:09:33.397]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.397]                     }, error = function(ex) {
[16:09:33.397]                       msg <- conditionMessage(ex)
[16:09:33.397]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.397]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.397]                         fi_tmp[["mtime"]], msg)
[16:09:33.397]                       ex$message <- msg
[16:09:33.397]                       stop(ex)
[16:09:33.397]                     })
[16:09:33.397]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.397]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.397]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.397]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.397]                       fi <- file.info(pathname)
[16:09:33.397]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.397]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.397]                         fi[["size"]], fi[["mtime"]])
[16:09:33.397]                       stop(msg)
[16:09:33.397]                     }
[16:09:33.397]                     invisible(pathname)
[16:09:33.397]                   }
[16:09:33.397]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.397]                     rootPath = tempdir()) 
[16:09:33.397]                   {
[16:09:33.397]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.397]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.397]                       tmpdir = path, fileext = ".rds")
[16:09:33.397]                     save_rds(obj, file)
[16:09:33.397]                   }
[16:09:33.397]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.397]                   {
[16:09:33.397]                     inherits <- base::inherits
[16:09:33.397]                     invokeRestart <- base::invokeRestart
[16:09:33.397]                     is.null <- base::is.null
[16:09:33.397]                     muffled <- FALSE
[16:09:33.397]                     if (inherits(cond, "message")) {
[16:09:33.397]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.397]                       if (muffled) 
[16:09:33.397]                         invokeRestart("muffleMessage")
[16:09:33.397]                     }
[16:09:33.397]                     else if (inherits(cond, "warning")) {
[16:09:33.397]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.397]                       if (muffled) 
[16:09:33.397]                         invokeRestart("muffleWarning")
[16:09:33.397]                     }
[16:09:33.397]                     else if (inherits(cond, "condition")) {
[16:09:33.397]                       if (!is.null(pattern)) {
[16:09:33.397]                         computeRestarts <- base::computeRestarts
[16:09:33.397]                         grepl <- base::grepl
[16:09:33.397]                         restarts <- computeRestarts(cond)
[16:09:33.397]                         for (restart in restarts) {
[16:09:33.397]                           name <- restart$name
[16:09:33.397]                           if (is.null(name)) 
[16:09:33.397]                             next
[16:09:33.397]                           if (!grepl(pattern, name)) 
[16:09:33.397]                             next
[16:09:33.397]                           invokeRestart(restart)
[16:09:33.397]                           muffled <- TRUE
[16:09:33.397]                           break
[16:09:33.397]                         }
[16:09:33.397]                       }
[16:09:33.397]                     }
[16:09:33.397]                     invisible(muffled)
[16:09:33.397]                   }
[16:09:33.397]                   muffleCondition(cond)
[16:09:33.397]                 })
[16:09:33.397]             }))
[16:09:33.397]             future::FutureResult(value = ...future.value$value, 
[16:09:33.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.397]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.397]                     ...future.globalenv.names))
[16:09:33.397]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.397]         }, condition = base::local({
[16:09:33.397]             c <- base::c
[16:09:33.397]             inherits <- base::inherits
[16:09:33.397]             invokeRestart <- base::invokeRestart
[16:09:33.397]             length <- base::length
[16:09:33.397]             list <- base::list
[16:09:33.397]             seq.int <- base::seq.int
[16:09:33.397]             signalCondition <- base::signalCondition
[16:09:33.397]             sys.calls <- base::sys.calls
[16:09:33.397]             `[[` <- base::`[[`
[16:09:33.397]             `+` <- base::`+`
[16:09:33.397]             `<<-` <- base::`<<-`
[16:09:33.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.397]                   3L)]
[16:09:33.397]             }
[16:09:33.397]             function(cond) {
[16:09:33.397]                 is_error <- inherits(cond, "error")
[16:09:33.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.397]                   NULL)
[16:09:33.397]                 if (is_error) {
[16:09:33.397]                   sessionInformation <- function() {
[16:09:33.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.397]                       search = base::search(), system = base::Sys.info())
[16:09:33.397]                   }
[16:09:33.397]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.397]                     cond$call), session = sessionInformation(), 
[16:09:33.397]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.397]                   signalCondition(cond)
[16:09:33.397]                 }
[16:09:33.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.397]                 "immediateCondition"))) {
[16:09:33.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.397]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.397]                   if (TRUE && !signal) {
[16:09:33.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.397]                     {
[16:09:33.397]                       inherits <- base::inherits
[16:09:33.397]                       invokeRestart <- base::invokeRestart
[16:09:33.397]                       is.null <- base::is.null
[16:09:33.397]                       muffled <- FALSE
[16:09:33.397]                       if (inherits(cond, "message")) {
[16:09:33.397]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.397]                         if (muffled) 
[16:09:33.397]                           invokeRestart("muffleMessage")
[16:09:33.397]                       }
[16:09:33.397]                       else if (inherits(cond, "warning")) {
[16:09:33.397]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.397]                         if (muffled) 
[16:09:33.397]                           invokeRestart("muffleWarning")
[16:09:33.397]                       }
[16:09:33.397]                       else if (inherits(cond, "condition")) {
[16:09:33.397]                         if (!is.null(pattern)) {
[16:09:33.397]                           computeRestarts <- base::computeRestarts
[16:09:33.397]                           grepl <- base::grepl
[16:09:33.397]                           restarts <- computeRestarts(cond)
[16:09:33.397]                           for (restart in restarts) {
[16:09:33.397]                             name <- restart$name
[16:09:33.397]                             if (is.null(name)) 
[16:09:33.397]                               next
[16:09:33.397]                             if (!grepl(pattern, name)) 
[16:09:33.397]                               next
[16:09:33.397]                             invokeRestart(restart)
[16:09:33.397]                             muffled <- TRUE
[16:09:33.397]                             break
[16:09:33.397]                           }
[16:09:33.397]                         }
[16:09:33.397]                       }
[16:09:33.397]                       invisible(muffled)
[16:09:33.397]                     }
[16:09:33.397]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.397]                   }
[16:09:33.397]                 }
[16:09:33.397]                 else {
[16:09:33.397]                   if (TRUE) {
[16:09:33.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.397]                     {
[16:09:33.397]                       inherits <- base::inherits
[16:09:33.397]                       invokeRestart <- base::invokeRestart
[16:09:33.397]                       is.null <- base::is.null
[16:09:33.397]                       muffled <- FALSE
[16:09:33.397]                       if (inherits(cond, "message")) {
[16:09:33.397]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.397]                         if (muffled) 
[16:09:33.397]                           invokeRestart("muffleMessage")
[16:09:33.397]                       }
[16:09:33.397]                       else if (inherits(cond, "warning")) {
[16:09:33.397]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.397]                         if (muffled) 
[16:09:33.397]                           invokeRestart("muffleWarning")
[16:09:33.397]                       }
[16:09:33.397]                       else if (inherits(cond, "condition")) {
[16:09:33.397]                         if (!is.null(pattern)) {
[16:09:33.397]                           computeRestarts <- base::computeRestarts
[16:09:33.397]                           grepl <- base::grepl
[16:09:33.397]                           restarts <- computeRestarts(cond)
[16:09:33.397]                           for (restart in restarts) {
[16:09:33.397]                             name <- restart$name
[16:09:33.397]                             if (is.null(name)) 
[16:09:33.397]                               next
[16:09:33.397]                             if (!grepl(pattern, name)) 
[16:09:33.397]                               next
[16:09:33.397]                             invokeRestart(restart)
[16:09:33.397]                             muffled <- TRUE
[16:09:33.397]                             break
[16:09:33.397]                           }
[16:09:33.397]                         }
[16:09:33.397]                       }
[16:09:33.397]                       invisible(muffled)
[16:09:33.397]                     }
[16:09:33.397]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.397]                   }
[16:09:33.397]                 }
[16:09:33.397]             }
[16:09:33.397]         }))
[16:09:33.397]     }, error = function(ex) {
[16:09:33.397]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.397]                 ...future.rng), started = ...future.startTime, 
[16:09:33.397]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.397]             version = "1.8"), class = "FutureResult")
[16:09:33.397]     }, finally = {
[16:09:33.397]         if (!identical(...future.workdir, getwd())) 
[16:09:33.397]             setwd(...future.workdir)
[16:09:33.397]         {
[16:09:33.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.397]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.397]             }
[16:09:33.397]             base::options(...future.oldOptions)
[16:09:33.397]             if (.Platform$OS.type == "windows") {
[16:09:33.397]                 old_names <- names(...future.oldEnvVars)
[16:09:33.397]                 envs <- base::Sys.getenv()
[16:09:33.397]                 names <- names(envs)
[16:09:33.397]                 common <- intersect(names, old_names)
[16:09:33.397]                 added <- setdiff(names, old_names)
[16:09:33.397]                 removed <- setdiff(old_names, names)
[16:09:33.397]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.397]                   envs[common]]
[16:09:33.397]                 NAMES <- toupper(changed)
[16:09:33.397]                 args <- list()
[16:09:33.397]                 for (kk in seq_along(NAMES)) {
[16:09:33.397]                   name <- changed[[kk]]
[16:09:33.397]                   NAME <- NAMES[[kk]]
[16:09:33.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.397]                     next
[16:09:33.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.397]                 }
[16:09:33.397]                 NAMES <- toupper(added)
[16:09:33.397]                 for (kk in seq_along(NAMES)) {
[16:09:33.397]                   name <- added[[kk]]
[16:09:33.397]                   NAME <- NAMES[[kk]]
[16:09:33.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.397]                     next
[16:09:33.397]                   args[[name]] <- ""
[16:09:33.397]                 }
[16:09:33.397]                 NAMES <- toupper(removed)
[16:09:33.397]                 for (kk in seq_along(NAMES)) {
[16:09:33.397]                   name <- removed[[kk]]
[16:09:33.397]                   NAME <- NAMES[[kk]]
[16:09:33.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.397]                     next
[16:09:33.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.397]                 }
[16:09:33.397]                 if (length(args) > 0) 
[16:09:33.397]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.397]             }
[16:09:33.397]             else {
[16:09:33.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.397]             }
[16:09:33.397]             {
[16:09:33.397]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.397]                   0L) {
[16:09:33.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.397]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.397]                   base::options(opts)
[16:09:33.397]                 }
[16:09:33.397]                 {
[16:09:33.397]                   {
[16:09:33.397]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.397]                     NULL
[16:09:33.397]                   }
[16:09:33.397]                   options(future.plan = NULL)
[16:09:33.397]                   if (is.na(NA_character_)) 
[16:09:33.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.397]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.397]                     envir = parent.frame()) 
[16:09:33.397]                   {
[16:09:33.397]                     default_workers <- missing(workers)
[16:09:33.397]                     if (is.function(workers)) 
[16:09:33.397]                       workers <- workers()
[16:09:33.397]                     workers <- structure(as.integer(workers), 
[16:09:33.397]                       class = class(workers))
[16:09:33.397]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.397]                       1L)
[16:09:33.397]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.397]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.397]                       if (default_workers) 
[16:09:33.397]                         supportsMulticore(warn = TRUE)
[16:09:33.397]                       return(sequential(..., envir = envir))
[16:09:33.397]                     }
[16:09:33.397]                     oopts <- options(mc.cores = workers)
[16:09:33.397]                     on.exit(options(oopts))
[16:09:33.397]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.397]                       envir = envir)
[16:09:33.397]                     if (!future$lazy) 
[16:09:33.397]                       future <- run(future)
[16:09:33.397]                     invisible(future)
[16:09:33.397]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.397]                 }
[16:09:33.397]             }
[16:09:33.397]         }
[16:09:33.397]     })
[16:09:33.397]     if (TRUE) {
[16:09:33.397]         base::sink(type = "output", split = FALSE)
[16:09:33.397]         if (TRUE) {
[16:09:33.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.397]         }
[16:09:33.397]         else {
[16:09:33.397]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.397]         }
[16:09:33.397]         base::close(...future.stdout)
[16:09:33.397]         ...future.stdout <- NULL
[16:09:33.397]     }
[16:09:33.397]     ...future.result$conditions <- ...future.conditions
[16:09:33.397]     ...future.result$finished <- base::Sys.time()
[16:09:33.397]     ...future.result
[16:09:33.397] }
[16:09:33.400] assign_globals() ...
[16:09:33.400] List of 5
[16:09:33.400]  $ ...future.FUN            :function (x, ...)  
[16:09:33.400]  $ future.call.arguments    :List of 1
[16:09:33.400]   ..$ singular.ok: logi FALSE
[16:09:33.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.400]  $ ...future.elements_ii    :List of 2
[16:09:33.400]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.400]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.400]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.400]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:33.400]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.400]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.400]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.400]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:33.400]  $ ...future.seeds_ii       : NULL
[16:09:33.400]  $ ...future.globals.maxSize: NULL
[16:09:33.400]  - attr(*, "resolved")= logi FALSE
[16:09:33.400]  - attr(*, "total_size")= num 5384
[16:09:33.400]  - attr(*, "where")=List of 5
[16:09:33.400]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.400]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.400]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.400]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.400]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.400]  - attr(*, "already-done")= logi TRUE
[16:09:33.415] - reassign environment for ‘...future.FUN’
[16:09:33.415] - copied ‘...future.FUN’ to environment
[16:09:33.415] - copied ‘future.call.arguments’ to environment
[16:09:33.415] - copied ‘...future.elements_ii’ to environment
[16:09:33.416] - copied ‘...future.seeds_ii’ to environment
[16:09:33.416] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.416] assign_globals() ... done
[16:09:33.416] requestCore(): workers = 2
[16:09:33.418] MulticoreFuture started
[16:09:33.419] - Launch lazy future ... done
[16:09:33.419] run() for ‘MulticoreFuture’ ... done
[16:09:33.419] Created future:
[16:09:33.420] plan(): Setting new future strategy stack:
[16:09:33.420] List of future strategies:
[16:09:33.420] 1. sequential:
[16:09:33.420]    - args: function (..., envir = parent.frame())
[16:09:33.420]    - tweaked: FALSE
[16:09:33.420]    - call: NULL
[16:09:33.421] plan(): nbrOfWorkers() = 1
[16:09:33.426] plan(): Setting new future strategy stack:
[16:09:33.426] List of future strategies:
[16:09:33.426] 1. multicore:
[16:09:33.426]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.426]    - tweaked: FALSE
[16:09:33.426]    - call: plan(strategy)
[16:09:33.431] plan(): nbrOfWorkers() = 2
[16:09:33.420] MulticoreFuture:
[16:09:33.420] Label: ‘future_by-2’
[16:09:33.420] Expression:
[16:09:33.420] {
[16:09:33.420]     do.call(function(...) {
[16:09:33.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.420]             on.exit(options(oopts), add = TRUE)
[16:09:33.420]         }
[16:09:33.420]         {
[16:09:33.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.420]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.420]             })
[16:09:33.420]         }
[16:09:33.420]     }, args = future.call.arguments)
[16:09:33.420] }
[16:09:33.420] Lazy evaluation: FALSE
[16:09:33.420] Asynchronous evaluation: TRUE
[16:09:33.420] Local evaluation: TRUE
[16:09:33.420] Environment: R_GlobalEnv
[16:09:33.420] Capture standard output: TRUE
[16:09:33.420] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.420] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.420] Packages: 1 packages (‘stats’)
[16:09:33.420] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.420] Resolved: TRUE
[16:09:33.420] Value: <not collected>
[16:09:33.420] Conditions captured: <none>
[16:09:33.420] Early signaling: FALSE
[16:09:33.420] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.420] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.433] Chunk #2 of 2 ... DONE
[16:09:33.433] Launching 2 futures (chunks) ... DONE
[16:09:33.433] Resolving 2 futures (chunks) ...
[16:09:33.434] resolve() on list ...
[16:09:33.434]  recursive: 0
[16:09:33.434]  length: 2
[16:09:33.434] 
[16:09:33.434] Future #1
[16:09:33.436] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:33.436] - nx: 2
[16:09:33.436] - relay: TRUE
[16:09:33.436] - stdout: TRUE
[16:09:33.436] - signal: TRUE
[16:09:33.437] - resignal: FALSE
[16:09:33.437] - force: TRUE
[16:09:33.437] - relayed: [n=2] FALSE, FALSE
[16:09:33.437] - queued futures: [n=2] FALSE, FALSE
[16:09:33.437]  - until=1
[16:09:33.437]  - relaying element #1
[16:09:33.437] - relayed: [n=2] TRUE, FALSE
[16:09:33.438] - queued futures: [n=2] TRUE, FALSE
[16:09:33.438] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:33.438]  length: 1 (resolved future 1)
[16:09:33.438] Future #2
[16:09:33.440] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:33.440] - nx: 2
[16:09:33.440] - relay: TRUE
[16:09:33.440] - stdout: TRUE
[16:09:33.440] - signal: TRUE
[16:09:33.440] - resignal: FALSE
[16:09:33.440] - force: TRUE
[16:09:33.441] - relayed: [n=2] TRUE, FALSE
[16:09:33.441] - queued futures: [n=2] TRUE, FALSE
[16:09:33.441]  - until=2
[16:09:33.441]  - relaying element #2
[16:09:33.441] - relayed: [n=2] TRUE, TRUE
[16:09:33.441] - queued futures: [n=2] TRUE, TRUE
[16:09:33.441] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:33.442]  length: 0 (resolved future 2)
[16:09:33.442] Relaying remaining futures
[16:09:33.442] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.442] - nx: 2
[16:09:33.442] - relay: TRUE
[16:09:33.442] - stdout: TRUE
[16:09:33.442] - signal: TRUE
[16:09:33.442] - resignal: FALSE
[16:09:33.442] - force: TRUE
[16:09:33.443] - relayed: [n=2] TRUE, TRUE
[16:09:33.443] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:33.443] - relayed: [n=2] TRUE, TRUE
[16:09:33.443] - queued futures: [n=2] TRUE, TRUE
[16:09:33.443] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.443] resolve() on list ... DONE
[16:09:33.443]  - Number of value chunks collected: 2
[16:09:33.444] Resolving 2 futures (chunks) ... DONE
[16:09:33.444] Reducing values from 2 chunks ...
[16:09:33.444]  - Number of values collected after concatenation: 3
[16:09:33.444]  - Number of values expected: 3
[16:09:33.444] Reducing values from 2 chunks ... DONE
[16:09:33.444] future_lapply() ... DONE
[16:09:33.444] future_by_internal() ... DONE
[16:09:33.453] future_by_internal() ...
[16:09:33.454] future_lapply() ...
[16:09:33.458] Number of chunks: 2
[16:09:33.459] getGlobalsAndPackagesXApply() ...
[16:09:33.459]  - future.globals: TRUE
[16:09:33.459] getGlobalsAndPackages() ...
[16:09:33.459] Searching for globals...
[16:09:33.461] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:33.461] Searching for globals ... DONE
[16:09:33.461] Resolving globals: FALSE
[16:09:33.461] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:09:33.462] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:09:33.462] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:33.462] - packages: [1] ‘stats’
[16:09:33.462] getGlobalsAndPackages() ... DONE
[16:09:33.462]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:33.463]  - needed namespaces: [n=1] ‘stats’
[16:09:33.463] Finding globals ... DONE
[16:09:33.463]  - use_args: TRUE
[16:09:33.463]  - Getting '...' globals ...
[16:09:33.463] resolve() on list ...
[16:09:33.463]  recursive: 0
[16:09:33.463]  length: 1
[16:09:33.463]  elements: ‘...’
[16:09:33.463]  length: 0 (resolved future 1)
[16:09:33.464] resolve() on list ... DONE
[16:09:33.464]    - '...' content: [n=0] 
[16:09:33.464] List of 1
[16:09:33.464]  $ ...: list()
[16:09:33.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.464]  - attr(*, "where")=List of 1
[16:09:33.464]   ..$ ...:<environment: 0x5567e7c54820> 
[16:09:33.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.464]  - attr(*, "resolved")= logi TRUE
[16:09:33.464]  - attr(*, "total_size")= num NA
[16:09:33.466]  - Getting '...' globals ... DONE
[16:09:33.467] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:09:33.467] List of 4
[16:09:33.467]  $ ...future.FUN:function (x)  
[16:09:33.467]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:33.467]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.467]  $ ...          : list()
[16:09:33.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.467]  - attr(*, "where")=List of 4
[16:09:33.467]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.467]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:09:33.467]   ..$ wool         :<environment: R_EmptyEnv> 
[16:09:33.467]   ..$ ...          :<environment: 0x5567e7c54820> 
[16:09:33.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.467]  - attr(*, "resolved")= logi FALSE
[16:09:33.467]  - attr(*, "total_size")= num 2320
[16:09:33.473] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:33.473] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.473] Number of futures (= number of chunks): 2
[16:09:33.473] Launching 2 futures (chunks) ...
[16:09:33.474] Chunk #1 of 2 ...
[16:09:33.474]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.474] getGlobalsAndPackages() ...
[16:09:33.474] Searching for globals...
[16:09:33.474] 
[16:09:33.474] Searching for globals ... DONE
[16:09:33.474] - globals: [0] <none>
[16:09:33.475] getGlobalsAndPackages() ... DONE
[16:09:33.475]    + additional globals found: [n=0] 
[16:09:33.475]    + additional namespaces needed: [n=0] 
[16:09:33.475]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.475]  - seeds: <none>
[16:09:33.475] getGlobalsAndPackages() ...
[16:09:33.475] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.475] Resolving globals: FALSE
[16:09:33.475] Tweak future expression to call with '...' arguments ...
[16:09:33.476] {
[16:09:33.476]     do.call(function(...) {
[16:09:33.476]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.476]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.476]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.476]             on.exit(options(oopts), add = TRUE)
[16:09:33.476]         }
[16:09:33.476]         {
[16:09:33.476]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.476]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.476]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.476]             })
[16:09:33.476]         }
[16:09:33.476]     }, args = future.call.arguments)
[16:09:33.476] }
[16:09:33.476] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.476] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.476] 
[16:09:33.477] getGlobalsAndPackages() ... DONE
[16:09:33.477] run() for ‘Future’ ...
[16:09:33.477] - state: ‘created’
[16:09:33.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.481]   - Field: ‘label’
[16:09:33.481]   - Field: ‘local’
[16:09:33.481]   - Field: ‘owner’
[16:09:33.481]   - Field: ‘envir’
[16:09:33.481]   - Field: ‘workers’
[16:09:33.481]   - Field: ‘packages’
[16:09:33.482]   - Field: ‘gc’
[16:09:33.482]   - Field: ‘job’
[16:09:33.482]   - Field: ‘conditions’
[16:09:33.482]   - Field: ‘expr’
[16:09:33.482]   - Field: ‘uuid’
[16:09:33.482]   - Field: ‘seed’
[16:09:33.482]   - Field: ‘version’
[16:09:33.482]   - Field: ‘result’
[16:09:33.482]   - Field: ‘asynchronous’
[16:09:33.482]   - Field: ‘calls’
[16:09:33.482]   - Field: ‘globals’
[16:09:33.483]   - Field: ‘stdout’
[16:09:33.483]   - Field: ‘earlySignal’
[16:09:33.483]   - Field: ‘lazy’
[16:09:33.483]   - Field: ‘state’
[16:09:33.483] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.483] - Launch lazy future ...
[16:09:33.483] Packages needed by the future expression (n = 1): ‘stats’
[16:09:33.483] Packages needed by future strategies (n = 0): <none>
[16:09:33.484] {
[16:09:33.484]     {
[16:09:33.484]         {
[16:09:33.484]             ...future.startTime <- base::Sys.time()
[16:09:33.484]             {
[16:09:33.484]                 {
[16:09:33.484]                   {
[16:09:33.484]                     {
[16:09:33.484]                       {
[16:09:33.484]                         base::local({
[16:09:33.484]                           has_future <- base::requireNamespace("future", 
[16:09:33.484]                             quietly = TRUE)
[16:09:33.484]                           if (has_future) {
[16:09:33.484]                             ns <- base::getNamespace("future")
[16:09:33.484]                             version <- ns[[".package"]][["version"]]
[16:09:33.484]                             if (is.null(version)) 
[16:09:33.484]                               version <- utils::packageVersion("future")
[16:09:33.484]                           }
[16:09:33.484]                           else {
[16:09:33.484]                             version <- NULL
[16:09:33.484]                           }
[16:09:33.484]                           if (!has_future || version < "1.8.0") {
[16:09:33.484]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.484]                               "", base::R.version$version.string), 
[16:09:33.484]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:33.484]                                 base::R.version$platform, 8 * 
[16:09:33.484]                                   base::.Machine$sizeof.pointer), 
[16:09:33.484]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.484]                                 "release", "version")], collapse = " "), 
[16:09:33.484]                               hostname = base::Sys.info()[["nodename"]])
[16:09:33.484]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.484]                               info)
[16:09:33.484]                             info <- base::paste(info, collapse = "; ")
[16:09:33.484]                             if (!has_future) {
[16:09:33.484]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.484]                                 info)
[16:09:33.484]                             }
[16:09:33.484]                             else {
[16:09:33.484]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.484]                                 info, version)
[16:09:33.484]                             }
[16:09:33.484]                             base::stop(msg)
[16:09:33.484]                           }
[16:09:33.484]                         })
[16:09:33.484]                       }
[16:09:33.484]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.484]                       base::options(mc.cores = 1L)
[16:09:33.484]                     }
[16:09:33.484]                     base::local({
[16:09:33.484]                       for (pkg in "stats") {
[16:09:33.484]                         base::loadNamespace(pkg)
[16:09:33.484]                         base::library(pkg, character.only = TRUE)
[16:09:33.484]                       }
[16:09:33.484]                     })
[16:09:33.484]                   }
[16:09:33.484]                   options(future.plan = NULL)
[16:09:33.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.484]                 }
[16:09:33.484]                 ...future.workdir <- getwd()
[16:09:33.484]             }
[16:09:33.484]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.484]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.484]         }
[16:09:33.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:33.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.484]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.484]             base::names(...future.oldOptions))
[16:09:33.484]     }
[16:09:33.484]     if (FALSE) {
[16:09:33.484]     }
[16:09:33.484]     else {
[16:09:33.484]         if (TRUE) {
[16:09:33.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.484]                 open = "w")
[16:09:33.484]         }
[16:09:33.484]         else {
[16:09:33.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.484]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.484]         }
[16:09:33.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.484]             base::sink(type = "output", split = FALSE)
[16:09:33.484]             base::close(...future.stdout)
[16:09:33.484]         }, add = TRUE)
[16:09:33.484]     }
[16:09:33.484]     ...future.frame <- base::sys.nframe()
[16:09:33.484]     ...future.conditions <- base::list()
[16:09:33.484]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.484]     if (FALSE) {
[16:09:33.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.484]     }
[16:09:33.484]     ...future.result <- base::tryCatch({
[16:09:33.484]         base::withCallingHandlers({
[16:09:33.484]             ...future.value <- base::withVisible(base::local({
[16:09:33.484]                 withCallingHandlers({
[16:09:33.484]                   {
[16:09:33.484]                     do.call(function(...) {
[16:09:33.484]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.484]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.484]                         ...future.globals.maxSize)) {
[16:09:33.484]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.484]                         on.exit(options(oopts), add = TRUE)
[16:09:33.484]                       }
[16:09:33.484]                       {
[16:09:33.484]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.484]                           FUN = function(jj) {
[16:09:33.484]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.484]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.484]                           })
[16:09:33.484]                       }
[16:09:33.484]                     }, args = future.call.arguments)
[16:09:33.484]                   }
[16:09:33.484]                 }, immediateCondition = function(cond) {
[16:09:33.484]                   save_rds <- function (object, pathname, ...) 
[16:09:33.484]                   {
[16:09:33.484]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.484]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.484]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.484]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.484]                         fi_tmp[["mtime"]])
[16:09:33.484]                     }
[16:09:33.484]                     tryCatch({
[16:09:33.484]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.484]                     }, error = function(ex) {
[16:09:33.484]                       msg <- conditionMessage(ex)
[16:09:33.484]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.484]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.484]                         fi_tmp[["mtime"]], msg)
[16:09:33.484]                       ex$message <- msg
[16:09:33.484]                       stop(ex)
[16:09:33.484]                     })
[16:09:33.484]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.484]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.484]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.484]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.484]                       fi <- file.info(pathname)
[16:09:33.484]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.484]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.484]                         fi[["size"]], fi[["mtime"]])
[16:09:33.484]                       stop(msg)
[16:09:33.484]                     }
[16:09:33.484]                     invisible(pathname)
[16:09:33.484]                   }
[16:09:33.484]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.484]                     rootPath = tempdir()) 
[16:09:33.484]                   {
[16:09:33.484]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.484]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.484]                       tmpdir = path, fileext = ".rds")
[16:09:33.484]                     save_rds(obj, file)
[16:09:33.484]                   }
[16:09:33.484]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.484]                   {
[16:09:33.484]                     inherits <- base::inherits
[16:09:33.484]                     invokeRestart <- base::invokeRestart
[16:09:33.484]                     is.null <- base::is.null
[16:09:33.484]                     muffled <- FALSE
[16:09:33.484]                     if (inherits(cond, "message")) {
[16:09:33.484]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.484]                       if (muffled) 
[16:09:33.484]                         invokeRestart("muffleMessage")
[16:09:33.484]                     }
[16:09:33.484]                     else if (inherits(cond, "warning")) {
[16:09:33.484]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.484]                       if (muffled) 
[16:09:33.484]                         invokeRestart("muffleWarning")
[16:09:33.484]                     }
[16:09:33.484]                     else if (inherits(cond, "condition")) {
[16:09:33.484]                       if (!is.null(pattern)) {
[16:09:33.484]                         computeRestarts <- base::computeRestarts
[16:09:33.484]                         grepl <- base::grepl
[16:09:33.484]                         restarts <- computeRestarts(cond)
[16:09:33.484]                         for (restart in restarts) {
[16:09:33.484]                           name <- restart$name
[16:09:33.484]                           if (is.null(name)) 
[16:09:33.484]                             next
[16:09:33.484]                           if (!grepl(pattern, name)) 
[16:09:33.484]                             next
[16:09:33.484]                           invokeRestart(restart)
[16:09:33.484]                           muffled <- TRUE
[16:09:33.484]                           break
[16:09:33.484]                         }
[16:09:33.484]                       }
[16:09:33.484]                     }
[16:09:33.484]                     invisible(muffled)
[16:09:33.484]                   }
[16:09:33.484]                   muffleCondition(cond)
[16:09:33.484]                 })
[16:09:33.484]             }))
[16:09:33.484]             future::FutureResult(value = ...future.value$value, 
[16:09:33.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.484]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.484]                     ...future.globalenv.names))
[16:09:33.484]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.484]         }, condition = base::local({
[16:09:33.484]             c <- base::c
[16:09:33.484]             inherits <- base::inherits
[16:09:33.484]             invokeRestart <- base::invokeRestart
[16:09:33.484]             length <- base::length
[16:09:33.484]             list <- base::list
[16:09:33.484]             seq.int <- base::seq.int
[16:09:33.484]             signalCondition <- base::signalCondition
[16:09:33.484]             sys.calls <- base::sys.calls
[16:09:33.484]             `[[` <- base::`[[`
[16:09:33.484]             `+` <- base::`+`
[16:09:33.484]             `<<-` <- base::`<<-`
[16:09:33.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.484]                   3L)]
[16:09:33.484]             }
[16:09:33.484]             function(cond) {
[16:09:33.484]                 is_error <- inherits(cond, "error")
[16:09:33.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.484]                   NULL)
[16:09:33.484]                 if (is_error) {
[16:09:33.484]                   sessionInformation <- function() {
[16:09:33.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.484]                       search = base::search(), system = base::Sys.info())
[16:09:33.484]                   }
[16:09:33.484]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.484]                     cond$call), session = sessionInformation(), 
[16:09:33.484]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.484]                   signalCondition(cond)
[16:09:33.484]                 }
[16:09:33.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.484]                 "immediateCondition"))) {
[16:09:33.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.484]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.484]                   if (TRUE && !signal) {
[16:09:33.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.484]                     {
[16:09:33.484]                       inherits <- base::inherits
[16:09:33.484]                       invokeRestart <- base::invokeRestart
[16:09:33.484]                       is.null <- base::is.null
[16:09:33.484]                       muffled <- FALSE
[16:09:33.484]                       if (inherits(cond, "message")) {
[16:09:33.484]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.484]                         if (muffled) 
[16:09:33.484]                           invokeRestart("muffleMessage")
[16:09:33.484]                       }
[16:09:33.484]                       else if (inherits(cond, "warning")) {
[16:09:33.484]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.484]                         if (muffled) 
[16:09:33.484]                           invokeRestart("muffleWarning")
[16:09:33.484]                       }
[16:09:33.484]                       else if (inherits(cond, "condition")) {
[16:09:33.484]                         if (!is.null(pattern)) {
[16:09:33.484]                           computeRestarts <- base::computeRestarts
[16:09:33.484]                           grepl <- base::grepl
[16:09:33.484]                           restarts <- computeRestarts(cond)
[16:09:33.484]                           for (restart in restarts) {
[16:09:33.484]                             name <- restart$name
[16:09:33.484]                             if (is.null(name)) 
[16:09:33.484]                               next
[16:09:33.484]                             if (!grepl(pattern, name)) 
[16:09:33.484]                               next
[16:09:33.484]                             invokeRestart(restart)
[16:09:33.484]                             muffled <- TRUE
[16:09:33.484]                             break
[16:09:33.484]                           }
[16:09:33.484]                         }
[16:09:33.484]                       }
[16:09:33.484]                       invisible(muffled)
[16:09:33.484]                     }
[16:09:33.484]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.484]                   }
[16:09:33.484]                 }
[16:09:33.484]                 else {
[16:09:33.484]                   if (TRUE) {
[16:09:33.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.484]                     {
[16:09:33.484]                       inherits <- base::inherits
[16:09:33.484]                       invokeRestart <- base::invokeRestart
[16:09:33.484]                       is.null <- base::is.null
[16:09:33.484]                       muffled <- FALSE
[16:09:33.484]                       if (inherits(cond, "message")) {
[16:09:33.484]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.484]                         if (muffled) 
[16:09:33.484]                           invokeRestart("muffleMessage")
[16:09:33.484]                       }
[16:09:33.484]                       else if (inherits(cond, "warning")) {
[16:09:33.484]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.484]                         if (muffled) 
[16:09:33.484]                           invokeRestart("muffleWarning")
[16:09:33.484]                       }
[16:09:33.484]                       else if (inherits(cond, "condition")) {
[16:09:33.484]                         if (!is.null(pattern)) {
[16:09:33.484]                           computeRestarts <- base::computeRestarts
[16:09:33.484]                           grepl <- base::grepl
[16:09:33.484]                           restarts <- computeRestarts(cond)
[16:09:33.484]                           for (restart in restarts) {
[16:09:33.484]                             name <- restart$name
[16:09:33.484]                             if (is.null(name)) 
[16:09:33.484]                               next
[16:09:33.484]                             if (!grepl(pattern, name)) 
[16:09:33.484]                               next
[16:09:33.484]                             invokeRestart(restart)
[16:09:33.484]                             muffled <- TRUE
[16:09:33.484]                             break
[16:09:33.484]                           }
[16:09:33.484]                         }
[16:09:33.484]                       }
[16:09:33.484]                       invisible(muffled)
[16:09:33.484]                     }
[16:09:33.484]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.484]                   }
[16:09:33.484]                 }
[16:09:33.484]             }
[16:09:33.484]         }))
[16:09:33.484]     }, error = function(ex) {
[16:09:33.484]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.484]                 ...future.rng), started = ...future.startTime, 
[16:09:33.484]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.484]             version = "1.8"), class = "FutureResult")
[16:09:33.484]     }, finally = {
[16:09:33.484]         if (!identical(...future.workdir, getwd())) 
[16:09:33.484]             setwd(...future.workdir)
[16:09:33.484]         {
[16:09:33.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.484]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.484]             }
[16:09:33.484]             base::options(...future.oldOptions)
[16:09:33.484]             if (.Platform$OS.type == "windows") {
[16:09:33.484]                 old_names <- names(...future.oldEnvVars)
[16:09:33.484]                 envs <- base::Sys.getenv()
[16:09:33.484]                 names <- names(envs)
[16:09:33.484]                 common <- intersect(names, old_names)
[16:09:33.484]                 added <- setdiff(names, old_names)
[16:09:33.484]                 removed <- setdiff(old_names, names)
[16:09:33.484]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.484]                   envs[common]]
[16:09:33.484]                 NAMES <- toupper(changed)
[16:09:33.484]                 args <- list()
[16:09:33.484]                 for (kk in seq_along(NAMES)) {
[16:09:33.484]                   name <- changed[[kk]]
[16:09:33.484]                   NAME <- NAMES[[kk]]
[16:09:33.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.484]                     next
[16:09:33.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.484]                 }
[16:09:33.484]                 NAMES <- toupper(added)
[16:09:33.484]                 for (kk in seq_along(NAMES)) {
[16:09:33.484]                   name <- added[[kk]]
[16:09:33.484]                   NAME <- NAMES[[kk]]
[16:09:33.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.484]                     next
[16:09:33.484]                   args[[name]] <- ""
[16:09:33.484]                 }
[16:09:33.484]                 NAMES <- toupper(removed)
[16:09:33.484]                 for (kk in seq_along(NAMES)) {
[16:09:33.484]                   name <- removed[[kk]]
[16:09:33.484]                   NAME <- NAMES[[kk]]
[16:09:33.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.484]                     next
[16:09:33.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.484]                 }
[16:09:33.484]                 if (length(args) > 0) 
[16:09:33.484]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.484]             }
[16:09:33.484]             else {
[16:09:33.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.484]             }
[16:09:33.484]             {
[16:09:33.484]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.484]                   0L) {
[16:09:33.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.484]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.484]                   base::options(opts)
[16:09:33.484]                 }
[16:09:33.484]                 {
[16:09:33.484]                   {
[16:09:33.484]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.484]                     NULL
[16:09:33.484]                   }
[16:09:33.484]                   options(future.plan = NULL)
[16:09:33.484]                   if (is.na(NA_character_)) 
[16:09:33.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.484]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.484]                     envir = parent.frame()) 
[16:09:33.484]                   {
[16:09:33.484]                     default_workers <- missing(workers)
[16:09:33.484]                     if (is.function(workers)) 
[16:09:33.484]                       workers <- workers()
[16:09:33.484]                     workers <- structure(as.integer(workers), 
[16:09:33.484]                       class = class(workers))
[16:09:33.484]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.484]                       1L)
[16:09:33.484]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.484]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.484]                       if (default_workers) 
[16:09:33.484]                         supportsMulticore(warn = TRUE)
[16:09:33.484]                       return(sequential(..., envir = envir))
[16:09:33.484]                     }
[16:09:33.484]                     oopts <- options(mc.cores = workers)
[16:09:33.484]                     on.exit(options(oopts))
[16:09:33.484]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.484]                       envir = envir)
[16:09:33.484]                     if (!future$lazy) 
[16:09:33.484]                       future <- run(future)
[16:09:33.484]                     invisible(future)
[16:09:33.484]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.484]                 }
[16:09:33.484]             }
[16:09:33.484]         }
[16:09:33.484]     })
[16:09:33.484]     if (TRUE) {
[16:09:33.484]         base::sink(type = "output", split = FALSE)
[16:09:33.484]         if (TRUE) {
[16:09:33.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.484]         }
[16:09:33.484]         else {
[16:09:33.484]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.484]         }
[16:09:33.484]         base::close(...future.stdout)
[16:09:33.484]         ...future.stdout <- NULL
[16:09:33.484]     }
[16:09:33.484]     ...future.result$conditions <- ...future.conditions
[16:09:33.484]     ...future.result$finished <- base::Sys.time()
[16:09:33.484]     ...future.result
[16:09:33.484] }
[16:09:33.487] assign_globals() ...
[16:09:33.487] List of 7
[16:09:33.487]  $ ...future.FUN            :function (x)  
[16:09:33.487]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:33.487]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.487]  $ future.call.arguments    : list()
[16:09:33.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.487]  $ ...future.elements_ii    :List of 1
[16:09:33.487]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.487]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.487]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.487]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.487]  $ ...future.seeds_ii       : NULL
[16:09:33.487]  $ ...future.globals.maxSize: NULL
[16:09:33.487]  - attr(*, "where")=List of 7
[16:09:33.487]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.487]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:09:33.487]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:09:33.487]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.487]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.487]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.487]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.487]  - attr(*, "resolved")= logi FALSE
[16:09:33.487]  - attr(*, "total_size")= num 2320
[16:09:33.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.487]  - attr(*, "already-done")= logi TRUE
[16:09:33.495] - reassign environment for ‘...future.FUN’
[16:09:33.495] - copied ‘...future.FUN’ to environment
[16:09:33.495] - copied ‘breaks’ to environment
[16:09:33.495] - copied ‘wool’ to environment
[16:09:33.496] - copied ‘future.call.arguments’ to environment
[16:09:33.496] - copied ‘...future.elements_ii’ to environment
[16:09:33.496] - copied ‘...future.seeds_ii’ to environment
[16:09:33.496] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.496] assign_globals() ... done
[16:09:33.496] requestCore(): workers = 2
[16:09:33.498] MulticoreFuture started
[16:09:33.499] - Launch lazy future ... done
[16:09:33.499] run() for ‘MulticoreFuture’ ... done
[16:09:33.500] Created future:
[16:09:33.500] plan(): Setting new future strategy stack:
[16:09:33.501] List of future strategies:
[16:09:33.501] 1. sequential:
[16:09:33.501]    - args: function (..., envir = parent.frame())
[16:09:33.501]    - tweaked: FALSE
[16:09:33.501]    - call: NULL
[16:09:33.502] plan(): nbrOfWorkers() = 1
[16:09:33.507] plan(): Setting new future strategy stack:
[16:09:33.507] List of future strategies:
[16:09:33.507] 1. multicore:
[16:09:33.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.507]    - tweaked: FALSE
[16:09:33.507]    - call: plan(strategy)
[16:09:33.513] plan(): nbrOfWorkers() = 2
[16:09:33.500] MulticoreFuture:
[16:09:33.500] Label: ‘future_by-1’
[16:09:33.500] Expression:
[16:09:33.500] {
[16:09:33.500]     do.call(function(...) {
[16:09:33.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.500]             on.exit(options(oopts), add = TRUE)
[16:09:33.500]         }
[16:09:33.500]         {
[16:09:33.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.500]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.500]             })
[16:09:33.500]         }
[16:09:33.500]     }, args = future.call.arguments)
[16:09:33.500] }
[16:09:33.500] Lazy evaluation: FALSE
[16:09:33.500] Asynchronous evaluation: TRUE
[16:09:33.500] Local evaluation: TRUE
[16:09:33.500] Environment: 0x5567e8d73858
[16:09:33.500] Capture standard output: TRUE
[16:09:33.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.500] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:09:33.500] Packages: 1 packages (‘stats’)
[16:09:33.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.500] Resolved: FALSE
[16:09:33.500] Value: <not collected>
[16:09:33.500] Conditions captured: <none>
[16:09:33.500] Early signaling: FALSE
[16:09:33.500] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.500] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.515] Chunk #1 of 2 ... DONE
[16:09:33.515] Chunk #2 of 2 ...
[16:09:33.515]  - Finding globals in 'X' for chunk #2 ...
[16:09:33.516] getGlobalsAndPackages() ...
[16:09:33.516] Searching for globals...
[16:09:33.517] 
[16:09:33.517] Searching for globals ... DONE
[16:09:33.517] - globals: [0] <none>
[16:09:33.517] getGlobalsAndPackages() ... DONE
[16:09:33.518]    + additional globals found: [n=0] 
[16:09:33.518]    + additional namespaces needed: [n=0] 
[16:09:33.518]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:33.518]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:33.518]  - seeds: <none>
[16:09:33.519] getGlobalsAndPackages() ...
[16:09:33.519] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.519] Resolving globals: FALSE
[16:09:33.519] Tweak future expression to call with '...' arguments ...
[16:09:33.519] {
[16:09:33.519]     do.call(function(...) {
[16:09:33.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.519]             on.exit(options(oopts), add = TRUE)
[16:09:33.519]         }
[16:09:33.519]         {
[16:09:33.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.519]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.519]             })
[16:09:33.519]         }
[16:09:33.519]     }, args = future.call.arguments)
[16:09:33.519] }
[16:09:33.520] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.520] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.521] 
[16:09:33.521] getGlobalsAndPackages() ... DONE
[16:09:33.521] run() for ‘Future’ ...
[16:09:33.521] - state: ‘created’
[16:09:33.522] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.526] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.527]   - Field: ‘label’
[16:09:33.527]   - Field: ‘local’
[16:09:33.527]   - Field: ‘owner’
[16:09:33.527]   - Field: ‘envir’
[16:09:33.528]   - Field: ‘workers’
[16:09:33.528]   - Field: ‘packages’
[16:09:33.528]   - Field: ‘gc’
[16:09:33.528]   - Field: ‘job’
[16:09:33.528]   - Field: ‘conditions’
[16:09:33.528]   - Field: ‘expr’
[16:09:33.528]   - Field: ‘uuid’
[16:09:33.529]   - Field: ‘seed’
[16:09:33.529]   - Field: ‘version’
[16:09:33.529]   - Field: ‘result’
[16:09:33.529]   - Field: ‘asynchronous’
[16:09:33.529]   - Field: ‘calls’
[16:09:33.529]   - Field: ‘globals’
[16:09:33.529]   - Field: ‘stdout’
[16:09:33.529]   - Field: ‘earlySignal’
[16:09:33.530]   - Field: ‘lazy’
[16:09:33.530]   - Field: ‘state’
[16:09:33.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.530] - Launch lazy future ...
[16:09:33.530] Packages needed by the future expression (n = 1): ‘stats’
[16:09:33.531] Packages needed by future strategies (n = 0): <none>
[16:09:33.531] {
[16:09:33.531]     {
[16:09:33.531]         {
[16:09:33.531]             ...future.startTime <- base::Sys.time()
[16:09:33.531]             {
[16:09:33.531]                 {
[16:09:33.531]                   {
[16:09:33.531]                     {
[16:09:33.531]                       {
[16:09:33.531]                         base::local({
[16:09:33.531]                           has_future <- base::requireNamespace("future", 
[16:09:33.531]                             quietly = TRUE)
[16:09:33.531]                           if (has_future) {
[16:09:33.531]                             ns <- base::getNamespace("future")
[16:09:33.531]                             version <- ns[[".package"]][["version"]]
[16:09:33.531]                             if (is.null(version)) 
[16:09:33.531]                               version <- utils::packageVersion("future")
[16:09:33.531]                           }
[16:09:33.531]                           else {
[16:09:33.531]                             version <- NULL
[16:09:33.531]                           }
[16:09:33.531]                           if (!has_future || version < "1.8.0") {
[16:09:33.531]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.531]                               "", base::R.version$version.string), 
[16:09:33.531]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:33.531]                                 base::R.version$platform, 8 * 
[16:09:33.531]                                   base::.Machine$sizeof.pointer), 
[16:09:33.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.531]                                 "release", "version")], collapse = " "), 
[16:09:33.531]                               hostname = base::Sys.info()[["nodename"]])
[16:09:33.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.531]                               info)
[16:09:33.531]                             info <- base::paste(info, collapse = "; ")
[16:09:33.531]                             if (!has_future) {
[16:09:33.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.531]                                 info)
[16:09:33.531]                             }
[16:09:33.531]                             else {
[16:09:33.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.531]                                 info, version)
[16:09:33.531]                             }
[16:09:33.531]                             base::stop(msg)
[16:09:33.531]                           }
[16:09:33.531]                         })
[16:09:33.531]                       }
[16:09:33.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.531]                       base::options(mc.cores = 1L)
[16:09:33.531]                     }
[16:09:33.531]                     base::local({
[16:09:33.531]                       for (pkg in "stats") {
[16:09:33.531]                         base::loadNamespace(pkg)
[16:09:33.531]                         base::library(pkg, character.only = TRUE)
[16:09:33.531]                       }
[16:09:33.531]                     })
[16:09:33.531]                   }
[16:09:33.531]                   options(future.plan = NULL)
[16:09:33.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.531]                 }
[16:09:33.531]                 ...future.workdir <- getwd()
[16:09:33.531]             }
[16:09:33.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.531]         }
[16:09:33.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.531]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:33.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.531]             base::names(...future.oldOptions))
[16:09:33.531]     }
[16:09:33.531]     if (FALSE) {
[16:09:33.531]     }
[16:09:33.531]     else {
[16:09:33.531]         if (TRUE) {
[16:09:33.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.531]                 open = "w")
[16:09:33.531]         }
[16:09:33.531]         else {
[16:09:33.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.531]         }
[16:09:33.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.531]             base::sink(type = "output", split = FALSE)
[16:09:33.531]             base::close(...future.stdout)
[16:09:33.531]         }, add = TRUE)
[16:09:33.531]     }
[16:09:33.531]     ...future.frame <- base::sys.nframe()
[16:09:33.531]     ...future.conditions <- base::list()
[16:09:33.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.531]     if (FALSE) {
[16:09:33.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.531]     }
[16:09:33.531]     ...future.result <- base::tryCatch({
[16:09:33.531]         base::withCallingHandlers({
[16:09:33.531]             ...future.value <- base::withVisible(base::local({
[16:09:33.531]                 withCallingHandlers({
[16:09:33.531]                   {
[16:09:33.531]                     do.call(function(...) {
[16:09:33.531]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.531]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.531]                         ...future.globals.maxSize)) {
[16:09:33.531]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.531]                         on.exit(options(oopts), add = TRUE)
[16:09:33.531]                       }
[16:09:33.531]                       {
[16:09:33.531]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.531]                           FUN = function(jj) {
[16:09:33.531]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.531]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.531]                           })
[16:09:33.531]                       }
[16:09:33.531]                     }, args = future.call.arguments)
[16:09:33.531]                   }
[16:09:33.531]                 }, immediateCondition = function(cond) {
[16:09:33.531]                   save_rds <- function (object, pathname, ...) 
[16:09:33.531]                   {
[16:09:33.531]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.531]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.531]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.531]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.531]                         fi_tmp[["mtime"]])
[16:09:33.531]                     }
[16:09:33.531]                     tryCatch({
[16:09:33.531]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.531]                     }, error = function(ex) {
[16:09:33.531]                       msg <- conditionMessage(ex)
[16:09:33.531]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.531]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.531]                         fi_tmp[["mtime"]], msg)
[16:09:33.531]                       ex$message <- msg
[16:09:33.531]                       stop(ex)
[16:09:33.531]                     })
[16:09:33.531]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.531]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.531]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.531]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.531]                       fi <- file.info(pathname)
[16:09:33.531]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.531]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.531]                         fi[["size"]], fi[["mtime"]])
[16:09:33.531]                       stop(msg)
[16:09:33.531]                     }
[16:09:33.531]                     invisible(pathname)
[16:09:33.531]                   }
[16:09:33.531]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.531]                     rootPath = tempdir()) 
[16:09:33.531]                   {
[16:09:33.531]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.531]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.531]                       tmpdir = path, fileext = ".rds")
[16:09:33.531]                     save_rds(obj, file)
[16:09:33.531]                   }
[16:09:33.531]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.531]                   {
[16:09:33.531]                     inherits <- base::inherits
[16:09:33.531]                     invokeRestart <- base::invokeRestart
[16:09:33.531]                     is.null <- base::is.null
[16:09:33.531]                     muffled <- FALSE
[16:09:33.531]                     if (inherits(cond, "message")) {
[16:09:33.531]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.531]                       if (muffled) 
[16:09:33.531]                         invokeRestart("muffleMessage")
[16:09:33.531]                     }
[16:09:33.531]                     else if (inherits(cond, "warning")) {
[16:09:33.531]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.531]                       if (muffled) 
[16:09:33.531]                         invokeRestart("muffleWarning")
[16:09:33.531]                     }
[16:09:33.531]                     else if (inherits(cond, "condition")) {
[16:09:33.531]                       if (!is.null(pattern)) {
[16:09:33.531]                         computeRestarts <- base::computeRestarts
[16:09:33.531]                         grepl <- base::grepl
[16:09:33.531]                         restarts <- computeRestarts(cond)
[16:09:33.531]                         for (restart in restarts) {
[16:09:33.531]                           name <- restart$name
[16:09:33.531]                           if (is.null(name)) 
[16:09:33.531]                             next
[16:09:33.531]                           if (!grepl(pattern, name)) 
[16:09:33.531]                             next
[16:09:33.531]                           invokeRestart(restart)
[16:09:33.531]                           muffled <- TRUE
[16:09:33.531]                           break
[16:09:33.531]                         }
[16:09:33.531]                       }
[16:09:33.531]                     }
[16:09:33.531]                     invisible(muffled)
[16:09:33.531]                   }
[16:09:33.531]                   muffleCondition(cond)
[16:09:33.531]                 })
[16:09:33.531]             }))
[16:09:33.531]             future::FutureResult(value = ...future.value$value, 
[16:09:33.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.531]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.531]                     ...future.globalenv.names))
[16:09:33.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.531]         }, condition = base::local({
[16:09:33.531]             c <- base::c
[16:09:33.531]             inherits <- base::inherits
[16:09:33.531]             invokeRestart <- base::invokeRestart
[16:09:33.531]             length <- base::length
[16:09:33.531]             list <- base::list
[16:09:33.531]             seq.int <- base::seq.int
[16:09:33.531]             signalCondition <- base::signalCondition
[16:09:33.531]             sys.calls <- base::sys.calls
[16:09:33.531]             `[[` <- base::`[[`
[16:09:33.531]             `+` <- base::`+`
[16:09:33.531]             `<<-` <- base::`<<-`
[16:09:33.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.531]                   3L)]
[16:09:33.531]             }
[16:09:33.531]             function(cond) {
[16:09:33.531]                 is_error <- inherits(cond, "error")
[16:09:33.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.531]                   NULL)
[16:09:33.531]                 if (is_error) {
[16:09:33.531]                   sessionInformation <- function() {
[16:09:33.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.531]                       search = base::search(), system = base::Sys.info())
[16:09:33.531]                   }
[16:09:33.531]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.531]                     cond$call), session = sessionInformation(), 
[16:09:33.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.531]                   signalCondition(cond)
[16:09:33.531]                 }
[16:09:33.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.531]                 "immediateCondition"))) {
[16:09:33.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.531]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.531]                   if (TRUE && !signal) {
[16:09:33.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.531]                     {
[16:09:33.531]                       inherits <- base::inherits
[16:09:33.531]                       invokeRestart <- base::invokeRestart
[16:09:33.531]                       is.null <- base::is.null
[16:09:33.531]                       muffled <- FALSE
[16:09:33.531]                       if (inherits(cond, "message")) {
[16:09:33.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.531]                         if (muffled) 
[16:09:33.531]                           invokeRestart("muffleMessage")
[16:09:33.531]                       }
[16:09:33.531]                       else if (inherits(cond, "warning")) {
[16:09:33.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.531]                         if (muffled) 
[16:09:33.531]                           invokeRestart("muffleWarning")
[16:09:33.531]                       }
[16:09:33.531]                       else if (inherits(cond, "condition")) {
[16:09:33.531]                         if (!is.null(pattern)) {
[16:09:33.531]                           computeRestarts <- base::computeRestarts
[16:09:33.531]                           grepl <- base::grepl
[16:09:33.531]                           restarts <- computeRestarts(cond)
[16:09:33.531]                           for (restart in restarts) {
[16:09:33.531]                             name <- restart$name
[16:09:33.531]                             if (is.null(name)) 
[16:09:33.531]                               next
[16:09:33.531]                             if (!grepl(pattern, name)) 
[16:09:33.531]                               next
[16:09:33.531]                             invokeRestart(restart)
[16:09:33.531]                             muffled <- TRUE
[16:09:33.531]                             break
[16:09:33.531]                           }
[16:09:33.531]                         }
[16:09:33.531]                       }
[16:09:33.531]                       invisible(muffled)
[16:09:33.531]                     }
[16:09:33.531]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.531]                   }
[16:09:33.531]                 }
[16:09:33.531]                 else {
[16:09:33.531]                   if (TRUE) {
[16:09:33.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.531]                     {
[16:09:33.531]                       inherits <- base::inherits
[16:09:33.531]                       invokeRestart <- base::invokeRestart
[16:09:33.531]                       is.null <- base::is.null
[16:09:33.531]                       muffled <- FALSE
[16:09:33.531]                       if (inherits(cond, "message")) {
[16:09:33.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.531]                         if (muffled) 
[16:09:33.531]                           invokeRestart("muffleMessage")
[16:09:33.531]                       }
[16:09:33.531]                       else if (inherits(cond, "warning")) {
[16:09:33.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.531]                         if (muffled) 
[16:09:33.531]                           invokeRestart("muffleWarning")
[16:09:33.531]                       }
[16:09:33.531]                       else if (inherits(cond, "condition")) {
[16:09:33.531]                         if (!is.null(pattern)) {
[16:09:33.531]                           computeRestarts <- base::computeRestarts
[16:09:33.531]                           grepl <- base::grepl
[16:09:33.531]                           restarts <- computeRestarts(cond)
[16:09:33.531]                           for (restart in restarts) {
[16:09:33.531]                             name <- restart$name
[16:09:33.531]                             if (is.null(name)) 
[16:09:33.531]                               next
[16:09:33.531]                             if (!grepl(pattern, name)) 
[16:09:33.531]                               next
[16:09:33.531]                             invokeRestart(restart)
[16:09:33.531]                             muffled <- TRUE
[16:09:33.531]                             break
[16:09:33.531]                           }
[16:09:33.531]                         }
[16:09:33.531]                       }
[16:09:33.531]                       invisible(muffled)
[16:09:33.531]                     }
[16:09:33.531]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.531]                   }
[16:09:33.531]                 }
[16:09:33.531]             }
[16:09:33.531]         }))
[16:09:33.531]     }, error = function(ex) {
[16:09:33.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.531]                 ...future.rng), started = ...future.startTime, 
[16:09:33.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.531]             version = "1.8"), class = "FutureResult")
[16:09:33.531]     }, finally = {
[16:09:33.531]         if (!identical(...future.workdir, getwd())) 
[16:09:33.531]             setwd(...future.workdir)
[16:09:33.531]         {
[16:09:33.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.531]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.531]             }
[16:09:33.531]             base::options(...future.oldOptions)
[16:09:33.531]             if (.Platform$OS.type == "windows") {
[16:09:33.531]                 old_names <- names(...future.oldEnvVars)
[16:09:33.531]                 envs <- base::Sys.getenv()
[16:09:33.531]                 names <- names(envs)
[16:09:33.531]                 common <- intersect(names, old_names)
[16:09:33.531]                 added <- setdiff(names, old_names)
[16:09:33.531]                 removed <- setdiff(old_names, names)
[16:09:33.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.531]                   envs[common]]
[16:09:33.531]                 NAMES <- toupper(changed)
[16:09:33.531]                 args <- list()
[16:09:33.531]                 for (kk in seq_along(NAMES)) {
[16:09:33.531]                   name <- changed[[kk]]
[16:09:33.531]                   NAME <- NAMES[[kk]]
[16:09:33.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.531]                     next
[16:09:33.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.531]                 }
[16:09:33.531]                 NAMES <- toupper(added)
[16:09:33.531]                 for (kk in seq_along(NAMES)) {
[16:09:33.531]                   name <- added[[kk]]
[16:09:33.531]                   NAME <- NAMES[[kk]]
[16:09:33.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.531]                     next
[16:09:33.531]                   args[[name]] <- ""
[16:09:33.531]                 }
[16:09:33.531]                 NAMES <- toupper(removed)
[16:09:33.531]                 for (kk in seq_along(NAMES)) {
[16:09:33.531]                   name <- removed[[kk]]
[16:09:33.531]                   NAME <- NAMES[[kk]]
[16:09:33.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.531]                     next
[16:09:33.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.531]                 }
[16:09:33.531]                 if (length(args) > 0) 
[16:09:33.531]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.531]             }
[16:09:33.531]             else {
[16:09:33.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.531]             }
[16:09:33.531]             {
[16:09:33.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.531]                   0L) {
[16:09:33.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.531]                   base::options(opts)
[16:09:33.531]                 }
[16:09:33.531]                 {
[16:09:33.531]                   {
[16:09:33.531]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.531]                     NULL
[16:09:33.531]                   }
[16:09:33.531]                   options(future.plan = NULL)
[16:09:33.531]                   if (is.na(NA_character_)) 
[16:09:33.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.531]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.531]                     envir = parent.frame()) 
[16:09:33.531]                   {
[16:09:33.531]                     default_workers <- missing(workers)
[16:09:33.531]                     if (is.function(workers)) 
[16:09:33.531]                       workers <- workers()
[16:09:33.531]                     workers <- structure(as.integer(workers), 
[16:09:33.531]                       class = class(workers))
[16:09:33.531]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.531]                       1L)
[16:09:33.531]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.531]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.531]                       if (default_workers) 
[16:09:33.531]                         supportsMulticore(warn = TRUE)
[16:09:33.531]                       return(sequential(..., envir = envir))
[16:09:33.531]                     }
[16:09:33.531]                     oopts <- options(mc.cores = workers)
[16:09:33.531]                     on.exit(options(oopts))
[16:09:33.531]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.531]                       envir = envir)
[16:09:33.531]                     if (!future$lazy) 
[16:09:33.531]                       future <- run(future)
[16:09:33.531]                     invisible(future)
[16:09:33.531]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.531]                 }
[16:09:33.531]             }
[16:09:33.531]         }
[16:09:33.531]     })
[16:09:33.531]     if (TRUE) {
[16:09:33.531]         base::sink(type = "output", split = FALSE)
[16:09:33.531]         if (TRUE) {
[16:09:33.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.531]         }
[16:09:33.531]         else {
[16:09:33.531]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.531]         }
[16:09:33.531]         base::close(...future.stdout)
[16:09:33.531]         ...future.stdout <- NULL
[16:09:33.531]     }
[16:09:33.531]     ...future.result$conditions <- ...future.conditions
[16:09:33.531]     ...future.result$finished <- base::Sys.time()
[16:09:33.531]     ...future.result
[16:09:33.531] }
[16:09:33.535] assign_globals() ...
[16:09:33.535] List of 7
[16:09:33.535]  $ ...future.FUN            :function (x)  
[16:09:33.535]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:33.535]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.535]  $ future.call.arguments    : list()
[16:09:33.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.535]  $ ...future.elements_ii    :List of 2
[16:09:33.535]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.535]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.535]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.535]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:33.535]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.535]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.535]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.535]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:33.535]  $ ...future.seeds_ii       : NULL
[16:09:33.535]  $ ...future.globals.maxSize: NULL
[16:09:33.535]  - attr(*, "resolved")= logi FALSE
[16:09:33.535]  - attr(*, "total_size")= num 2320
[16:09:33.535]  - attr(*, "where")=List of 7
[16:09:33.535]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.535]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:09:33.535]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:09:33.535]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.535]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.535]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.535]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.535]  - attr(*, "already-done")= logi TRUE
[16:09:33.548] - reassign environment for ‘...future.FUN’
[16:09:33.548] - copied ‘...future.FUN’ to environment
[16:09:33.548] - copied ‘breaks’ to environment
[16:09:33.549] - copied ‘wool’ to environment
[16:09:33.549] - copied ‘future.call.arguments’ to environment
[16:09:33.549] - copied ‘...future.elements_ii’ to environment
[16:09:33.549] - copied ‘...future.seeds_ii’ to environment
[16:09:33.549] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.549] assign_globals() ... done
[16:09:33.549] requestCore(): workers = 2
[16:09:33.552] MulticoreFuture started
[16:09:33.553] - Launch lazy future ... done
[16:09:33.553] run() for ‘MulticoreFuture’ ... done
[16:09:33.554] Created future:
[16:09:33.554] plan(): Setting new future strategy stack:
[16:09:33.554] List of future strategies:
[16:09:33.554] 1. sequential:
[16:09:33.554]    - args: function (..., envir = parent.frame())
[16:09:33.554]    - tweaked: FALSE
[16:09:33.554]    - call: NULL
[16:09:33.555] plan(): nbrOfWorkers() = 1
[16:09:33.560] plan(): Setting new future strategy stack:
[16:09:33.560] List of future strategies:
[16:09:33.560] 1. multicore:
[16:09:33.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.560]    - tweaked: FALSE
[16:09:33.560]    - call: plan(strategy)
[16:09:33.566] plan(): nbrOfWorkers() = 2
[16:09:33.554] MulticoreFuture:
[16:09:33.554] Label: ‘future_by-2’
[16:09:33.554] Expression:
[16:09:33.554] {
[16:09:33.554]     do.call(function(...) {
[16:09:33.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.554]             on.exit(options(oopts), add = TRUE)
[16:09:33.554]         }
[16:09:33.554]         {
[16:09:33.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.554]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.554]             })
[16:09:33.554]         }
[16:09:33.554]     }, args = future.call.arguments)
[16:09:33.554] }
[16:09:33.554] Lazy evaluation: FALSE
[16:09:33.554] Asynchronous evaluation: TRUE
[16:09:33.554] Local evaluation: TRUE
[16:09:33.554] Environment: 0x5567e8d73858
[16:09:33.554] Capture standard output: TRUE
[16:09:33.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.554] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:09:33.554] Packages: 1 packages (‘stats’)
[16:09:33.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.554] Resolved: TRUE
[16:09:33.554] Value: <not collected>
[16:09:33.554] Conditions captured: <none>
[16:09:33.554] Early signaling: FALSE
[16:09:33.554] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.554] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.567] Chunk #2 of 2 ... DONE
[16:09:33.567] Launching 2 futures (chunks) ... DONE
[16:09:33.568] Resolving 2 futures (chunks) ...
[16:09:33.568] resolve() on list ...
[16:09:33.568]  recursive: 0
[16:09:33.568]  length: 2
[16:09:33.568] 
[16:09:33.569] Future #1
[16:09:33.570] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:33.570] - nx: 2
[16:09:33.571] - relay: TRUE
[16:09:33.571] - stdout: TRUE
[16:09:33.571] - signal: TRUE
[16:09:33.571] - resignal: FALSE
[16:09:33.571] - force: TRUE
[16:09:33.571] - relayed: [n=2] FALSE, FALSE
[16:09:33.571] - queued futures: [n=2] FALSE, FALSE
[16:09:33.572]  - until=1
[16:09:33.572]  - relaying element #1
[16:09:33.572] - relayed: [n=2] TRUE, FALSE
[16:09:33.572] - queued futures: [n=2] TRUE, FALSE
[16:09:33.572] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:33.572]  length: 1 (resolved future 1)
[16:09:33.573] Future #2
[16:09:33.574] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:33.574] - nx: 2
[16:09:33.574] - relay: TRUE
[16:09:33.574] - stdout: TRUE
[16:09:33.575] - signal: TRUE
[16:09:33.575] - resignal: FALSE
[16:09:33.575] - force: TRUE
[16:09:33.575] - relayed: [n=2] TRUE, FALSE
[16:09:33.575] - queued futures: [n=2] TRUE, FALSE
[16:09:33.575]  - until=2
[16:09:33.575]  - relaying element #2
[16:09:33.575] - relayed: [n=2] TRUE, TRUE
[16:09:33.576] - queued futures: [n=2] TRUE, TRUE
[16:09:33.576] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:33.576]  length: 0 (resolved future 2)
[16:09:33.576] Relaying remaining futures
[16:09:33.576] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.576] - nx: 2
[16:09:33.576] - relay: TRUE
[16:09:33.576] - stdout: TRUE
[16:09:33.577] - signal: TRUE
[16:09:33.577] - resignal: FALSE
[16:09:33.577] - force: TRUE
[16:09:33.577] - relayed: [n=2] TRUE, TRUE
[16:09:33.577] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:33.577] - relayed: [n=2] TRUE, TRUE
[16:09:33.577] - queued futures: [n=2] TRUE, TRUE
[16:09:33.577] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.578] resolve() on list ... DONE
[16:09:33.578]  - Number of value chunks collected: 2
[16:09:33.578] Resolving 2 futures (chunks) ... DONE
[16:09:33.578] Reducing values from 2 chunks ...
[16:09:33.578]  - Number of values collected after concatenation: 3
[16:09:33.578]  - Number of values expected: 3
[16:09:33.578] Reducing values from 2 chunks ... DONE
[16:09:33.579] future_lapply() ... DONE
[16:09:33.579] future_by_internal() ... DONE
[16:09:33.579] future_by_internal() ...
[16:09:33.580] future_lapply() ...
[16:09:33.620] Number of chunks: 2
[16:09:33.620] getGlobalsAndPackagesXApply() ...
[16:09:33.620]  - future.globals: TRUE
[16:09:33.620] getGlobalsAndPackages() ...
[16:09:33.620] Searching for globals...
[16:09:33.621] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:33.621] Searching for globals ... DONE
[16:09:33.622] Resolving globals: FALSE
[16:09:33.622] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:33.622] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:33.622] - globals: [1] ‘FUN’
[16:09:33.622] 
[16:09:33.623] getGlobalsAndPackages() ... DONE
[16:09:33.623]  - globals found/used: [n=1] ‘FUN’
[16:09:33.623]  - needed namespaces: [n=0] 
[16:09:33.623] Finding globals ... DONE
[16:09:33.623]  - use_args: TRUE
[16:09:33.623]  - Getting '...' globals ...
[16:09:33.623] resolve() on list ...
[16:09:33.623]  recursive: 0
[16:09:33.623]  length: 1
[16:09:33.624]  elements: ‘...’
[16:09:33.624]  length: 0 (resolved future 1)
[16:09:33.624] resolve() on list ... DONE
[16:09:33.624]    - '...' content: [n=0] 
[16:09:33.624] List of 1
[16:09:33.624]  $ ...: list()
[16:09:33.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.624]  - attr(*, "where")=List of 1
[16:09:33.624]   ..$ ...:<environment: 0x5567e8e07620> 
[16:09:33.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.624]  - attr(*, "resolved")= logi TRUE
[16:09:33.624]  - attr(*, "total_size")= num NA
[16:09:33.626]  - Getting '...' globals ... DONE
[16:09:33.626] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.627] List of 2
[16:09:33.627]  $ ...future.FUN:function (object, ...)  
[16:09:33.627]  $ ...          : list()
[16:09:33.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.627]  - attr(*, "where")=List of 2
[16:09:33.627]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.627]   ..$ ...          :<environment: 0x5567e8e07620> 
[16:09:33.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.627]  - attr(*, "resolved")= logi FALSE
[16:09:33.627]  - attr(*, "total_size")= num 1240
[16:09:33.629] Packages to be attached in all futures: [n=0] 
[16:09:33.629] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.629] Number of futures (= number of chunks): 2
[16:09:33.629] Launching 2 futures (chunks) ...
[16:09:33.630] Chunk #1 of 2 ...
[16:09:33.630]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.630] getGlobalsAndPackages() ...
[16:09:33.630] Searching for globals...
[16:09:33.630] 
[16:09:33.630] Searching for globals ... DONE
[16:09:33.630] - globals: [0] <none>
[16:09:33.630] getGlobalsAndPackages() ... DONE
[16:09:33.631]    + additional globals found: [n=0] 
[16:09:33.631]    + additional namespaces needed: [n=0] 
[16:09:33.631]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.631]  - seeds: <none>
[16:09:33.631] getGlobalsAndPackages() ...
[16:09:33.631] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.631] Resolving globals: FALSE
[16:09:33.631] Tweak future expression to call with '...' arguments ...
[16:09:33.631] {
[16:09:33.631]     do.call(function(...) {
[16:09:33.631]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.631]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.631]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.631]             on.exit(options(oopts), add = TRUE)
[16:09:33.631]         }
[16:09:33.631]         {
[16:09:33.631]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.631]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.631]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.631]             })
[16:09:33.631]         }
[16:09:33.631]     }, args = future.call.arguments)
[16:09:33.631] }
[16:09:33.632] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.632] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.632] 
[16:09:33.632] getGlobalsAndPackages() ... DONE
[16:09:33.632] run() for ‘Future’ ...
[16:09:33.632] - state: ‘created’
[16:09:33.633] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.637]   - Field: ‘label’
[16:09:33.637]   - Field: ‘local’
[16:09:33.637]   - Field: ‘owner’
[16:09:33.637]   - Field: ‘envir’
[16:09:33.637]   - Field: ‘workers’
[16:09:33.637]   - Field: ‘packages’
[16:09:33.637]   - Field: ‘gc’
[16:09:33.637]   - Field: ‘job’
[16:09:33.637]   - Field: ‘conditions’
[16:09:33.637]   - Field: ‘expr’
[16:09:33.637]   - Field: ‘uuid’
[16:09:33.638]   - Field: ‘seed’
[16:09:33.638]   - Field: ‘version’
[16:09:33.638]   - Field: ‘result’
[16:09:33.638]   - Field: ‘asynchronous’
[16:09:33.638]   - Field: ‘calls’
[16:09:33.638]   - Field: ‘globals’
[16:09:33.638]   - Field: ‘stdout’
[16:09:33.638]   - Field: ‘earlySignal’
[16:09:33.638]   - Field: ‘lazy’
[16:09:33.638]   - Field: ‘state’
[16:09:33.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.639] - Launch lazy future ...
[16:09:33.639] Packages needed by the future expression (n = 0): <none>
[16:09:33.639] Packages needed by future strategies (n = 0): <none>
[16:09:33.639] {
[16:09:33.639]     {
[16:09:33.639]         {
[16:09:33.639]             ...future.startTime <- base::Sys.time()
[16:09:33.639]             {
[16:09:33.639]                 {
[16:09:33.639]                   {
[16:09:33.639]                     {
[16:09:33.639]                       base::local({
[16:09:33.639]                         has_future <- base::requireNamespace("future", 
[16:09:33.639]                           quietly = TRUE)
[16:09:33.639]                         if (has_future) {
[16:09:33.639]                           ns <- base::getNamespace("future")
[16:09:33.639]                           version <- ns[[".package"]][["version"]]
[16:09:33.639]                           if (is.null(version)) 
[16:09:33.639]                             version <- utils::packageVersion("future")
[16:09:33.639]                         }
[16:09:33.639]                         else {
[16:09:33.639]                           version <- NULL
[16:09:33.639]                         }
[16:09:33.639]                         if (!has_future || version < "1.8.0") {
[16:09:33.639]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.639]                             "", base::R.version$version.string), 
[16:09:33.639]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.639]                               "release", "version")], collapse = " "), 
[16:09:33.639]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.639]                             info)
[16:09:33.639]                           info <- base::paste(info, collapse = "; ")
[16:09:33.639]                           if (!has_future) {
[16:09:33.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.639]                               info)
[16:09:33.639]                           }
[16:09:33.639]                           else {
[16:09:33.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.639]                               info, version)
[16:09:33.639]                           }
[16:09:33.639]                           base::stop(msg)
[16:09:33.639]                         }
[16:09:33.639]                       })
[16:09:33.639]                     }
[16:09:33.639]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.639]                     base::options(mc.cores = 1L)
[16:09:33.639]                   }
[16:09:33.639]                   options(future.plan = NULL)
[16:09:33.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.639]                 }
[16:09:33.639]                 ...future.workdir <- getwd()
[16:09:33.639]             }
[16:09:33.639]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.639]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.639]         }
[16:09:33.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:33.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.639]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.639]             base::names(...future.oldOptions))
[16:09:33.639]     }
[16:09:33.639]     if (FALSE) {
[16:09:33.639]     }
[16:09:33.639]     else {
[16:09:33.639]         if (TRUE) {
[16:09:33.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.639]                 open = "w")
[16:09:33.639]         }
[16:09:33.639]         else {
[16:09:33.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.639]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.639]         }
[16:09:33.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.639]             base::sink(type = "output", split = FALSE)
[16:09:33.639]             base::close(...future.stdout)
[16:09:33.639]         }, add = TRUE)
[16:09:33.639]     }
[16:09:33.639]     ...future.frame <- base::sys.nframe()
[16:09:33.639]     ...future.conditions <- base::list()
[16:09:33.639]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.639]     if (FALSE) {
[16:09:33.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.639]     }
[16:09:33.639]     ...future.result <- base::tryCatch({
[16:09:33.639]         base::withCallingHandlers({
[16:09:33.639]             ...future.value <- base::withVisible(base::local({
[16:09:33.639]                 withCallingHandlers({
[16:09:33.639]                   {
[16:09:33.639]                     do.call(function(...) {
[16:09:33.639]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.639]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.639]                         ...future.globals.maxSize)) {
[16:09:33.639]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.639]                         on.exit(options(oopts), add = TRUE)
[16:09:33.639]                       }
[16:09:33.639]                       {
[16:09:33.639]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.639]                           FUN = function(jj) {
[16:09:33.639]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.639]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.639]                           })
[16:09:33.639]                       }
[16:09:33.639]                     }, args = future.call.arguments)
[16:09:33.639]                   }
[16:09:33.639]                 }, immediateCondition = function(cond) {
[16:09:33.639]                   save_rds <- function (object, pathname, ...) 
[16:09:33.639]                   {
[16:09:33.639]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.639]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.639]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.639]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.639]                         fi_tmp[["mtime"]])
[16:09:33.639]                     }
[16:09:33.639]                     tryCatch({
[16:09:33.639]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.639]                     }, error = function(ex) {
[16:09:33.639]                       msg <- conditionMessage(ex)
[16:09:33.639]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.639]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.639]                         fi_tmp[["mtime"]], msg)
[16:09:33.639]                       ex$message <- msg
[16:09:33.639]                       stop(ex)
[16:09:33.639]                     })
[16:09:33.639]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.639]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.639]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.639]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.639]                       fi <- file.info(pathname)
[16:09:33.639]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.639]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.639]                         fi[["size"]], fi[["mtime"]])
[16:09:33.639]                       stop(msg)
[16:09:33.639]                     }
[16:09:33.639]                     invisible(pathname)
[16:09:33.639]                   }
[16:09:33.639]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.639]                     rootPath = tempdir()) 
[16:09:33.639]                   {
[16:09:33.639]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.639]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.639]                       tmpdir = path, fileext = ".rds")
[16:09:33.639]                     save_rds(obj, file)
[16:09:33.639]                   }
[16:09:33.639]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.639]                   {
[16:09:33.639]                     inherits <- base::inherits
[16:09:33.639]                     invokeRestart <- base::invokeRestart
[16:09:33.639]                     is.null <- base::is.null
[16:09:33.639]                     muffled <- FALSE
[16:09:33.639]                     if (inherits(cond, "message")) {
[16:09:33.639]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.639]                       if (muffled) 
[16:09:33.639]                         invokeRestart("muffleMessage")
[16:09:33.639]                     }
[16:09:33.639]                     else if (inherits(cond, "warning")) {
[16:09:33.639]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.639]                       if (muffled) 
[16:09:33.639]                         invokeRestart("muffleWarning")
[16:09:33.639]                     }
[16:09:33.639]                     else if (inherits(cond, "condition")) {
[16:09:33.639]                       if (!is.null(pattern)) {
[16:09:33.639]                         computeRestarts <- base::computeRestarts
[16:09:33.639]                         grepl <- base::grepl
[16:09:33.639]                         restarts <- computeRestarts(cond)
[16:09:33.639]                         for (restart in restarts) {
[16:09:33.639]                           name <- restart$name
[16:09:33.639]                           if (is.null(name)) 
[16:09:33.639]                             next
[16:09:33.639]                           if (!grepl(pattern, name)) 
[16:09:33.639]                             next
[16:09:33.639]                           invokeRestart(restart)
[16:09:33.639]                           muffled <- TRUE
[16:09:33.639]                           break
[16:09:33.639]                         }
[16:09:33.639]                       }
[16:09:33.639]                     }
[16:09:33.639]                     invisible(muffled)
[16:09:33.639]                   }
[16:09:33.639]                   muffleCondition(cond)
[16:09:33.639]                 })
[16:09:33.639]             }))
[16:09:33.639]             future::FutureResult(value = ...future.value$value, 
[16:09:33.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.639]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.639]                     ...future.globalenv.names))
[16:09:33.639]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.639]         }, condition = base::local({
[16:09:33.639]             c <- base::c
[16:09:33.639]             inherits <- base::inherits
[16:09:33.639]             invokeRestart <- base::invokeRestart
[16:09:33.639]             length <- base::length
[16:09:33.639]             list <- base::list
[16:09:33.639]             seq.int <- base::seq.int
[16:09:33.639]             signalCondition <- base::signalCondition
[16:09:33.639]             sys.calls <- base::sys.calls
[16:09:33.639]             `[[` <- base::`[[`
[16:09:33.639]             `+` <- base::`+`
[16:09:33.639]             `<<-` <- base::`<<-`
[16:09:33.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.639]                   3L)]
[16:09:33.639]             }
[16:09:33.639]             function(cond) {
[16:09:33.639]                 is_error <- inherits(cond, "error")
[16:09:33.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.639]                   NULL)
[16:09:33.639]                 if (is_error) {
[16:09:33.639]                   sessionInformation <- function() {
[16:09:33.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.639]                       search = base::search(), system = base::Sys.info())
[16:09:33.639]                   }
[16:09:33.639]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.639]                     cond$call), session = sessionInformation(), 
[16:09:33.639]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.639]                   signalCondition(cond)
[16:09:33.639]                 }
[16:09:33.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.639]                 "immediateCondition"))) {
[16:09:33.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.639]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.639]                   if (TRUE && !signal) {
[16:09:33.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.639]                     {
[16:09:33.639]                       inherits <- base::inherits
[16:09:33.639]                       invokeRestart <- base::invokeRestart
[16:09:33.639]                       is.null <- base::is.null
[16:09:33.639]                       muffled <- FALSE
[16:09:33.639]                       if (inherits(cond, "message")) {
[16:09:33.639]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.639]                         if (muffled) 
[16:09:33.639]                           invokeRestart("muffleMessage")
[16:09:33.639]                       }
[16:09:33.639]                       else if (inherits(cond, "warning")) {
[16:09:33.639]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.639]                         if (muffled) 
[16:09:33.639]                           invokeRestart("muffleWarning")
[16:09:33.639]                       }
[16:09:33.639]                       else if (inherits(cond, "condition")) {
[16:09:33.639]                         if (!is.null(pattern)) {
[16:09:33.639]                           computeRestarts <- base::computeRestarts
[16:09:33.639]                           grepl <- base::grepl
[16:09:33.639]                           restarts <- computeRestarts(cond)
[16:09:33.639]                           for (restart in restarts) {
[16:09:33.639]                             name <- restart$name
[16:09:33.639]                             if (is.null(name)) 
[16:09:33.639]                               next
[16:09:33.639]                             if (!grepl(pattern, name)) 
[16:09:33.639]                               next
[16:09:33.639]                             invokeRestart(restart)
[16:09:33.639]                             muffled <- TRUE
[16:09:33.639]                             break
[16:09:33.639]                           }
[16:09:33.639]                         }
[16:09:33.639]                       }
[16:09:33.639]                       invisible(muffled)
[16:09:33.639]                     }
[16:09:33.639]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.639]                   }
[16:09:33.639]                 }
[16:09:33.639]                 else {
[16:09:33.639]                   if (TRUE) {
[16:09:33.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.639]                     {
[16:09:33.639]                       inherits <- base::inherits
[16:09:33.639]                       invokeRestart <- base::invokeRestart
[16:09:33.639]                       is.null <- base::is.null
[16:09:33.639]                       muffled <- FALSE
[16:09:33.639]                       if (inherits(cond, "message")) {
[16:09:33.639]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.639]                         if (muffled) 
[16:09:33.639]                           invokeRestart("muffleMessage")
[16:09:33.639]                       }
[16:09:33.639]                       else if (inherits(cond, "warning")) {
[16:09:33.639]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.639]                         if (muffled) 
[16:09:33.639]                           invokeRestart("muffleWarning")
[16:09:33.639]                       }
[16:09:33.639]                       else if (inherits(cond, "condition")) {
[16:09:33.639]                         if (!is.null(pattern)) {
[16:09:33.639]                           computeRestarts <- base::computeRestarts
[16:09:33.639]                           grepl <- base::grepl
[16:09:33.639]                           restarts <- computeRestarts(cond)
[16:09:33.639]                           for (restart in restarts) {
[16:09:33.639]                             name <- restart$name
[16:09:33.639]                             if (is.null(name)) 
[16:09:33.639]                               next
[16:09:33.639]                             if (!grepl(pattern, name)) 
[16:09:33.639]                               next
[16:09:33.639]                             invokeRestart(restart)
[16:09:33.639]                             muffled <- TRUE
[16:09:33.639]                             break
[16:09:33.639]                           }
[16:09:33.639]                         }
[16:09:33.639]                       }
[16:09:33.639]                       invisible(muffled)
[16:09:33.639]                     }
[16:09:33.639]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.639]                   }
[16:09:33.639]                 }
[16:09:33.639]             }
[16:09:33.639]         }))
[16:09:33.639]     }, error = function(ex) {
[16:09:33.639]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.639]                 ...future.rng), started = ...future.startTime, 
[16:09:33.639]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.639]             version = "1.8"), class = "FutureResult")
[16:09:33.639]     }, finally = {
[16:09:33.639]         if (!identical(...future.workdir, getwd())) 
[16:09:33.639]             setwd(...future.workdir)
[16:09:33.639]         {
[16:09:33.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.639]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.639]             }
[16:09:33.639]             base::options(...future.oldOptions)
[16:09:33.639]             if (.Platform$OS.type == "windows") {
[16:09:33.639]                 old_names <- names(...future.oldEnvVars)
[16:09:33.639]                 envs <- base::Sys.getenv()
[16:09:33.639]                 names <- names(envs)
[16:09:33.639]                 common <- intersect(names, old_names)
[16:09:33.639]                 added <- setdiff(names, old_names)
[16:09:33.639]                 removed <- setdiff(old_names, names)
[16:09:33.639]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.639]                   envs[common]]
[16:09:33.639]                 NAMES <- toupper(changed)
[16:09:33.639]                 args <- list()
[16:09:33.639]                 for (kk in seq_along(NAMES)) {
[16:09:33.639]                   name <- changed[[kk]]
[16:09:33.639]                   NAME <- NAMES[[kk]]
[16:09:33.639]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.639]                     next
[16:09:33.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.639]                 }
[16:09:33.639]                 NAMES <- toupper(added)
[16:09:33.639]                 for (kk in seq_along(NAMES)) {
[16:09:33.639]                   name <- added[[kk]]
[16:09:33.639]                   NAME <- NAMES[[kk]]
[16:09:33.639]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.639]                     next
[16:09:33.639]                   args[[name]] <- ""
[16:09:33.639]                 }
[16:09:33.639]                 NAMES <- toupper(removed)
[16:09:33.639]                 for (kk in seq_along(NAMES)) {
[16:09:33.639]                   name <- removed[[kk]]
[16:09:33.639]                   NAME <- NAMES[[kk]]
[16:09:33.639]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.639]                     next
[16:09:33.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.639]                 }
[16:09:33.639]                 if (length(args) > 0) 
[16:09:33.639]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.639]             }
[16:09:33.639]             else {
[16:09:33.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.639]             }
[16:09:33.639]             {
[16:09:33.639]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.639]                   0L) {
[16:09:33.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.639]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.639]                   base::options(opts)
[16:09:33.639]                 }
[16:09:33.639]                 {
[16:09:33.639]                   {
[16:09:33.639]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.639]                     NULL
[16:09:33.639]                   }
[16:09:33.639]                   options(future.plan = NULL)
[16:09:33.639]                   if (is.na(NA_character_)) 
[16:09:33.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.639]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.639]                     envir = parent.frame()) 
[16:09:33.639]                   {
[16:09:33.639]                     default_workers <- missing(workers)
[16:09:33.639]                     if (is.function(workers)) 
[16:09:33.639]                       workers <- workers()
[16:09:33.639]                     workers <- structure(as.integer(workers), 
[16:09:33.639]                       class = class(workers))
[16:09:33.639]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.639]                       1L)
[16:09:33.639]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.639]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.639]                       if (default_workers) 
[16:09:33.639]                         supportsMulticore(warn = TRUE)
[16:09:33.639]                       return(sequential(..., envir = envir))
[16:09:33.639]                     }
[16:09:33.639]                     oopts <- options(mc.cores = workers)
[16:09:33.639]                     on.exit(options(oopts))
[16:09:33.639]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.639]                       envir = envir)
[16:09:33.639]                     if (!future$lazy) 
[16:09:33.639]                       future <- run(future)
[16:09:33.639]                     invisible(future)
[16:09:33.639]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.639]                 }
[16:09:33.639]             }
[16:09:33.639]         }
[16:09:33.639]     })
[16:09:33.639]     if (TRUE) {
[16:09:33.639]         base::sink(type = "output", split = FALSE)
[16:09:33.639]         if (TRUE) {
[16:09:33.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.639]         }
[16:09:33.639]         else {
[16:09:33.639]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.639]         }
[16:09:33.639]         base::close(...future.stdout)
[16:09:33.639]         ...future.stdout <- NULL
[16:09:33.639]     }
[16:09:33.639]     ...future.result$conditions <- ...future.conditions
[16:09:33.639]     ...future.result$finished <- base::Sys.time()
[16:09:33.639]     ...future.result
[16:09:33.639] }
[16:09:33.642] assign_globals() ...
[16:09:33.642] List of 5
[16:09:33.642]  $ ...future.FUN            :function (object, ...)  
[16:09:33.642]  $ future.call.arguments    : list()
[16:09:33.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.642]  $ ...future.elements_ii    :List of 1
[16:09:33.642]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.642]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.642]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.642]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.642]  $ ...future.seeds_ii       : NULL
[16:09:33.642]  $ ...future.globals.maxSize: NULL
[16:09:33.642]  - attr(*, "where")=List of 5
[16:09:33.642]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.642]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.642]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.642]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.642]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.642]  - attr(*, "resolved")= logi FALSE
[16:09:33.642]  - attr(*, "total_size")= num 1240
[16:09:33.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.642]  - attr(*, "already-done")= logi TRUE
[16:09:33.648] - copied ‘...future.FUN’ to environment
[16:09:33.648] - copied ‘future.call.arguments’ to environment
[16:09:33.648] - copied ‘...future.elements_ii’ to environment
[16:09:33.648] - copied ‘...future.seeds_ii’ to environment
[16:09:33.648] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.648] assign_globals() ... done
[16:09:33.649] requestCore(): workers = 2
[16:09:33.651] MulticoreFuture started
[16:09:33.651] - Launch lazy future ... done
[16:09:33.651] run() for ‘MulticoreFuture’ ... done
[16:09:33.652] Created future:
[16:09:33.652] plan(): Setting new future strategy stack:
[16:09:33.652] List of future strategies:
[16:09:33.652] 1. sequential:
[16:09:33.652]    - args: function (..., envir = parent.frame())
[16:09:33.652]    - tweaked: FALSE
[16:09:33.652]    - call: NULL
[16:09:33.653] plan(): nbrOfWorkers() = 1
[16:09:33.656] plan(): Setting new future strategy stack:
[16:09:33.656] List of future strategies:
[16:09:33.656] 1. multicore:
[16:09:33.656]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.656]    - tweaked: FALSE
[16:09:33.656]    - call: plan(strategy)
[16:09:33.661] plan(): nbrOfWorkers() = 2
[16:09:33.652] MulticoreFuture:
[16:09:33.652] Label: ‘future_by-1’
[16:09:33.652] Expression:
[16:09:33.652] {
[16:09:33.652]     do.call(function(...) {
[16:09:33.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.652]             on.exit(options(oopts), add = TRUE)
[16:09:33.652]         }
[16:09:33.652]         {
[16:09:33.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.652]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.652]             })
[16:09:33.652]         }
[16:09:33.652]     }, args = future.call.arguments)
[16:09:33.652] }
[16:09:33.652] Lazy evaluation: FALSE
[16:09:33.652] Asynchronous evaluation: TRUE
[16:09:33.652] Local evaluation: TRUE
[16:09:33.652] Environment: 0x5567e8d8bda0
[16:09:33.652] Capture standard output: TRUE
[16:09:33.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.652] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.652] Packages: <none>
[16:09:33.652] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.652] Resolved: TRUE
[16:09:33.652] Value: <not collected>
[16:09:33.652] Conditions captured: <none>
[16:09:33.652] Early signaling: FALSE
[16:09:33.652] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.652] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.662] Chunk #1 of 2 ... DONE
[16:09:33.662] Chunk #2 of 2 ...
[16:09:33.662]  - Finding globals in 'X' for chunk #2 ...
[16:09:33.663] getGlobalsAndPackages() ...
[16:09:33.663] Searching for globals...
[16:09:33.663] 
[16:09:33.664] Searching for globals ... DONE
[16:09:33.664] - globals: [0] <none>
[16:09:33.664] getGlobalsAndPackages() ... DONE
[16:09:33.664]    + additional globals found: [n=0] 
[16:09:33.664]    + additional namespaces needed: [n=0] 
[16:09:33.664]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:33.664]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:33.665]  - seeds: <none>
[16:09:33.665] getGlobalsAndPackages() ...
[16:09:33.665] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.665] Resolving globals: FALSE
[16:09:33.665] Tweak future expression to call with '...' arguments ...
[16:09:33.665] {
[16:09:33.665]     do.call(function(...) {
[16:09:33.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.665]             on.exit(options(oopts), add = TRUE)
[16:09:33.665]         }
[16:09:33.665]         {
[16:09:33.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.665]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.665]             })
[16:09:33.665]         }
[16:09:33.665]     }, args = future.call.arguments)
[16:09:33.665] }
[16:09:33.666] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.666] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.667] 
[16:09:33.667] getGlobalsAndPackages() ... DONE
[16:09:33.667] run() for ‘Future’ ...
[16:09:33.667] - state: ‘created’
[16:09:33.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.672] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.672]   - Field: ‘label’
[16:09:33.672]   - Field: ‘local’
[16:09:33.672]   - Field: ‘owner’
[16:09:33.672]   - Field: ‘envir’
[16:09:33.673]   - Field: ‘workers’
[16:09:33.673]   - Field: ‘packages’
[16:09:33.673]   - Field: ‘gc’
[16:09:33.673]   - Field: ‘job’
[16:09:33.673]   - Field: ‘conditions’
[16:09:33.673]   - Field: ‘expr’
[16:09:33.673]   - Field: ‘uuid’
[16:09:33.674]   - Field: ‘seed’
[16:09:33.674]   - Field: ‘version’
[16:09:33.674]   - Field: ‘result’
[16:09:33.674]   - Field: ‘asynchronous’
[16:09:33.674]   - Field: ‘calls’
[16:09:33.674]   - Field: ‘globals’
[16:09:33.674]   - Field: ‘stdout’
[16:09:33.674]   - Field: ‘earlySignal’
[16:09:33.675]   - Field: ‘lazy’
[16:09:33.675]   - Field: ‘state’
[16:09:33.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.675] - Launch lazy future ...
[16:09:33.675] Packages needed by the future expression (n = 0): <none>
[16:09:33.676] Packages needed by future strategies (n = 0): <none>
[16:09:33.676] {
[16:09:33.676]     {
[16:09:33.676]         {
[16:09:33.676]             ...future.startTime <- base::Sys.time()
[16:09:33.676]             {
[16:09:33.676]                 {
[16:09:33.676]                   {
[16:09:33.676]                     {
[16:09:33.676]                       base::local({
[16:09:33.676]                         has_future <- base::requireNamespace("future", 
[16:09:33.676]                           quietly = TRUE)
[16:09:33.676]                         if (has_future) {
[16:09:33.676]                           ns <- base::getNamespace("future")
[16:09:33.676]                           version <- ns[[".package"]][["version"]]
[16:09:33.676]                           if (is.null(version)) 
[16:09:33.676]                             version <- utils::packageVersion("future")
[16:09:33.676]                         }
[16:09:33.676]                         else {
[16:09:33.676]                           version <- NULL
[16:09:33.676]                         }
[16:09:33.676]                         if (!has_future || version < "1.8.0") {
[16:09:33.676]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.676]                             "", base::R.version$version.string), 
[16:09:33.676]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.676]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.676]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.676]                               "release", "version")], collapse = " "), 
[16:09:33.676]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.676]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.676]                             info)
[16:09:33.676]                           info <- base::paste(info, collapse = "; ")
[16:09:33.676]                           if (!has_future) {
[16:09:33.676]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.676]                               info)
[16:09:33.676]                           }
[16:09:33.676]                           else {
[16:09:33.676]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.676]                               info, version)
[16:09:33.676]                           }
[16:09:33.676]                           base::stop(msg)
[16:09:33.676]                         }
[16:09:33.676]                       })
[16:09:33.676]                     }
[16:09:33.676]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.676]                     base::options(mc.cores = 1L)
[16:09:33.676]                   }
[16:09:33.676]                   options(future.plan = NULL)
[16:09:33.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.676]                 }
[16:09:33.676]                 ...future.workdir <- getwd()
[16:09:33.676]             }
[16:09:33.676]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.676]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.676]         }
[16:09:33.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.676]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:33.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.676]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.676]             base::names(...future.oldOptions))
[16:09:33.676]     }
[16:09:33.676]     if (FALSE) {
[16:09:33.676]     }
[16:09:33.676]     else {
[16:09:33.676]         if (TRUE) {
[16:09:33.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.676]                 open = "w")
[16:09:33.676]         }
[16:09:33.676]         else {
[16:09:33.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.676]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.676]         }
[16:09:33.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.676]             base::sink(type = "output", split = FALSE)
[16:09:33.676]             base::close(...future.stdout)
[16:09:33.676]         }, add = TRUE)
[16:09:33.676]     }
[16:09:33.676]     ...future.frame <- base::sys.nframe()
[16:09:33.676]     ...future.conditions <- base::list()
[16:09:33.676]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.676]     if (FALSE) {
[16:09:33.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.676]     }
[16:09:33.676]     ...future.result <- base::tryCatch({
[16:09:33.676]         base::withCallingHandlers({
[16:09:33.676]             ...future.value <- base::withVisible(base::local({
[16:09:33.676]                 withCallingHandlers({
[16:09:33.676]                   {
[16:09:33.676]                     do.call(function(...) {
[16:09:33.676]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.676]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.676]                         ...future.globals.maxSize)) {
[16:09:33.676]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.676]                         on.exit(options(oopts), add = TRUE)
[16:09:33.676]                       }
[16:09:33.676]                       {
[16:09:33.676]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.676]                           FUN = function(jj) {
[16:09:33.676]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.676]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.676]                           })
[16:09:33.676]                       }
[16:09:33.676]                     }, args = future.call.arguments)
[16:09:33.676]                   }
[16:09:33.676]                 }, immediateCondition = function(cond) {
[16:09:33.676]                   save_rds <- function (object, pathname, ...) 
[16:09:33.676]                   {
[16:09:33.676]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.676]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.676]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.676]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.676]                         fi_tmp[["mtime"]])
[16:09:33.676]                     }
[16:09:33.676]                     tryCatch({
[16:09:33.676]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.676]                     }, error = function(ex) {
[16:09:33.676]                       msg <- conditionMessage(ex)
[16:09:33.676]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.676]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.676]                         fi_tmp[["mtime"]], msg)
[16:09:33.676]                       ex$message <- msg
[16:09:33.676]                       stop(ex)
[16:09:33.676]                     })
[16:09:33.676]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.676]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.676]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.676]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.676]                       fi <- file.info(pathname)
[16:09:33.676]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.676]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.676]                         fi[["size"]], fi[["mtime"]])
[16:09:33.676]                       stop(msg)
[16:09:33.676]                     }
[16:09:33.676]                     invisible(pathname)
[16:09:33.676]                   }
[16:09:33.676]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.676]                     rootPath = tempdir()) 
[16:09:33.676]                   {
[16:09:33.676]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.676]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.676]                       tmpdir = path, fileext = ".rds")
[16:09:33.676]                     save_rds(obj, file)
[16:09:33.676]                   }
[16:09:33.676]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.676]                   {
[16:09:33.676]                     inherits <- base::inherits
[16:09:33.676]                     invokeRestart <- base::invokeRestart
[16:09:33.676]                     is.null <- base::is.null
[16:09:33.676]                     muffled <- FALSE
[16:09:33.676]                     if (inherits(cond, "message")) {
[16:09:33.676]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.676]                       if (muffled) 
[16:09:33.676]                         invokeRestart("muffleMessage")
[16:09:33.676]                     }
[16:09:33.676]                     else if (inherits(cond, "warning")) {
[16:09:33.676]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.676]                       if (muffled) 
[16:09:33.676]                         invokeRestart("muffleWarning")
[16:09:33.676]                     }
[16:09:33.676]                     else if (inherits(cond, "condition")) {
[16:09:33.676]                       if (!is.null(pattern)) {
[16:09:33.676]                         computeRestarts <- base::computeRestarts
[16:09:33.676]                         grepl <- base::grepl
[16:09:33.676]                         restarts <- computeRestarts(cond)
[16:09:33.676]                         for (restart in restarts) {
[16:09:33.676]                           name <- restart$name
[16:09:33.676]                           if (is.null(name)) 
[16:09:33.676]                             next
[16:09:33.676]                           if (!grepl(pattern, name)) 
[16:09:33.676]                             next
[16:09:33.676]                           invokeRestart(restart)
[16:09:33.676]                           muffled <- TRUE
[16:09:33.676]                           break
[16:09:33.676]                         }
[16:09:33.676]                       }
[16:09:33.676]                     }
[16:09:33.676]                     invisible(muffled)
[16:09:33.676]                   }
[16:09:33.676]                   muffleCondition(cond)
[16:09:33.676]                 })
[16:09:33.676]             }))
[16:09:33.676]             future::FutureResult(value = ...future.value$value, 
[16:09:33.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.676]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.676]                     ...future.globalenv.names))
[16:09:33.676]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.676]         }, condition = base::local({
[16:09:33.676]             c <- base::c
[16:09:33.676]             inherits <- base::inherits
[16:09:33.676]             invokeRestart <- base::invokeRestart
[16:09:33.676]             length <- base::length
[16:09:33.676]             list <- base::list
[16:09:33.676]             seq.int <- base::seq.int
[16:09:33.676]             signalCondition <- base::signalCondition
[16:09:33.676]             sys.calls <- base::sys.calls
[16:09:33.676]             `[[` <- base::`[[`
[16:09:33.676]             `+` <- base::`+`
[16:09:33.676]             `<<-` <- base::`<<-`
[16:09:33.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.676]                   3L)]
[16:09:33.676]             }
[16:09:33.676]             function(cond) {
[16:09:33.676]                 is_error <- inherits(cond, "error")
[16:09:33.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.676]                   NULL)
[16:09:33.676]                 if (is_error) {
[16:09:33.676]                   sessionInformation <- function() {
[16:09:33.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.676]                       search = base::search(), system = base::Sys.info())
[16:09:33.676]                   }
[16:09:33.676]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.676]                     cond$call), session = sessionInformation(), 
[16:09:33.676]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.676]                   signalCondition(cond)
[16:09:33.676]                 }
[16:09:33.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.676]                 "immediateCondition"))) {
[16:09:33.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.676]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.676]                   if (TRUE && !signal) {
[16:09:33.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.676]                     {
[16:09:33.676]                       inherits <- base::inherits
[16:09:33.676]                       invokeRestart <- base::invokeRestart
[16:09:33.676]                       is.null <- base::is.null
[16:09:33.676]                       muffled <- FALSE
[16:09:33.676]                       if (inherits(cond, "message")) {
[16:09:33.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.676]                         if (muffled) 
[16:09:33.676]                           invokeRestart("muffleMessage")
[16:09:33.676]                       }
[16:09:33.676]                       else if (inherits(cond, "warning")) {
[16:09:33.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.676]                         if (muffled) 
[16:09:33.676]                           invokeRestart("muffleWarning")
[16:09:33.676]                       }
[16:09:33.676]                       else if (inherits(cond, "condition")) {
[16:09:33.676]                         if (!is.null(pattern)) {
[16:09:33.676]                           computeRestarts <- base::computeRestarts
[16:09:33.676]                           grepl <- base::grepl
[16:09:33.676]                           restarts <- computeRestarts(cond)
[16:09:33.676]                           for (restart in restarts) {
[16:09:33.676]                             name <- restart$name
[16:09:33.676]                             if (is.null(name)) 
[16:09:33.676]                               next
[16:09:33.676]                             if (!grepl(pattern, name)) 
[16:09:33.676]                               next
[16:09:33.676]                             invokeRestart(restart)
[16:09:33.676]                             muffled <- TRUE
[16:09:33.676]                             break
[16:09:33.676]                           }
[16:09:33.676]                         }
[16:09:33.676]                       }
[16:09:33.676]                       invisible(muffled)
[16:09:33.676]                     }
[16:09:33.676]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.676]                   }
[16:09:33.676]                 }
[16:09:33.676]                 else {
[16:09:33.676]                   if (TRUE) {
[16:09:33.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.676]                     {
[16:09:33.676]                       inherits <- base::inherits
[16:09:33.676]                       invokeRestart <- base::invokeRestart
[16:09:33.676]                       is.null <- base::is.null
[16:09:33.676]                       muffled <- FALSE
[16:09:33.676]                       if (inherits(cond, "message")) {
[16:09:33.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.676]                         if (muffled) 
[16:09:33.676]                           invokeRestart("muffleMessage")
[16:09:33.676]                       }
[16:09:33.676]                       else if (inherits(cond, "warning")) {
[16:09:33.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.676]                         if (muffled) 
[16:09:33.676]                           invokeRestart("muffleWarning")
[16:09:33.676]                       }
[16:09:33.676]                       else if (inherits(cond, "condition")) {
[16:09:33.676]                         if (!is.null(pattern)) {
[16:09:33.676]                           computeRestarts <- base::computeRestarts
[16:09:33.676]                           grepl <- base::grepl
[16:09:33.676]                           restarts <- computeRestarts(cond)
[16:09:33.676]                           for (restart in restarts) {
[16:09:33.676]                             name <- restart$name
[16:09:33.676]                             if (is.null(name)) 
[16:09:33.676]                               next
[16:09:33.676]                             if (!grepl(pattern, name)) 
[16:09:33.676]                               next
[16:09:33.676]                             invokeRestart(restart)
[16:09:33.676]                             muffled <- TRUE
[16:09:33.676]                             break
[16:09:33.676]                           }
[16:09:33.676]                         }
[16:09:33.676]                       }
[16:09:33.676]                       invisible(muffled)
[16:09:33.676]                     }
[16:09:33.676]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.676]                   }
[16:09:33.676]                 }
[16:09:33.676]             }
[16:09:33.676]         }))
[16:09:33.676]     }, error = function(ex) {
[16:09:33.676]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.676]                 ...future.rng), started = ...future.startTime, 
[16:09:33.676]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.676]             version = "1.8"), class = "FutureResult")
[16:09:33.676]     }, finally = {
[16:09:33.676]         if (!identical(...future.workdir, getwd())) 
[16:09:33.676]             setwd(...future.workdir)
[16:09:33.676]         {
[16:09:33.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.676]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.676]             }
[16:09:33.676]             base::options(...future.oldOptions)
[16:09:33.676]             if (.Platform$OS.type == "windows") {
[16:09:33.676]                 old_names <- names(...future.oldEnvVars)
[16:09:33.676]                 envs <- base::Sys.getenv()
[16:09:33.676]                 names <- names(envs)
[16:09:33.676]                 common <- intersect(names, old_names)
[16:09:33.676]                 added <- setdiff(names, old_names)
[16:09:33.676]                 removed <- setdiff(old_names, names)
[16:09:33.676]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.676]                   envs[common]]
[16:09:33.676]                 NAMES <- toupper(changed)
[16:09:33.676]                 args <- list()
[16:09:33.676]                 for (kk in seq_along(NAMES)) {
[16:09:33.676]                   name <- changed[[kk]]
[16:09:33.676]                   NAME <- NAMES[[kk]]
[16:09:33.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.676]                     next
[16:09:33.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.676]                 }
[16:09:33.676]                 NAMES <- toupper(added)
[16:09:33.676]                 for (kk in seq_along(NAMES)) {
[16:09:33.676]                   name <- added[[kk]]
[16:09:33.676]                   NAME <- NAMES[[kk]]
[16:09:33.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.676]                     next
[16:09:33.676]                   args[[name]] <- ""
[16:09:33.676]                 }
[16:09:33.676]                 NAMES <- toupper(removed)
[16:09:33.676]                 for (kk in seq_along(NAMES)) {
[16:09:33.676]                   name <- removed[[kk]]
[16:09:33.676]                   NAME <- NAMES[[kk]]
[16:09:33.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.676]                     next
[16:09:33.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.676]                 }
[16:09:33.676]                 if (length(args) > 0) 
[16:09:33.676]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.676]             }
[16:09:33.676]             else {
[16:09:33.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.676]             }
[16:09:33.676]             {
[16:09:33.676]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.676]                   0L) {
[16:09:33.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.676]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.676]                   base::options(opts)
[16:09:33.676]                 }
[16:09:33.676]                 {
[16:09:33.676]                   {
[16:09:33.676]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.676]                     NULL
[16:09:33.676]                   }
[16:09:33.676]                   options(future.plan = NULL)
[16:09:33.676]                   if (is.na(NA_character_)) 
[16:09:33.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.676]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.676]                     envir = parent.frame()) 
[16:09:33.676]                   {
[16:09:33.676]                     default_workers <- missing(workers)
[16:09:33.676]                     if (is.function(workers)) 
[16:09:33.676]                       workers <- workers()
[16:09:33.676]                     workers <- structure(as.integer(workers), 
[16:09:33.676]                       class = class(workers))
[16:09:33.676]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.676]                       1L)
[16:09:33.676]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.676]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.676]                       if (default_workers) 
[16:09:33.676]                         supportsMulticore(warn = TRUE)
[16:09:33.676]                       return(sequential(..., envir = envir))
[16:09:33.676]                     }
[16:09:33.676]                     oopts <- options(mc.cores = workers)
[16:09:33.676]                     on.exit(options(oopts))
[16:09:33.676]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.676]                       envir = envir)
[16:09:33.676]                     if (!future$lazy) 
[16:09:33.676]                       future <- run(future)
[16:09:33.676]                     invisible(future)
[16:09:33.676]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.676]                 }
[16:09:33.676]             }
[16:09:33.676]         }
[16:09:33.676]     })
[16:09:33.676]     if (TRUE) {
[16:09:33.676]         base::sink(type = "output", split = FALSE)
[16:09:33.676]         if (TRUE) {
[16:09:33.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.676]         }
[16:09:33.676]         else {
[16:09:33.676]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.676]         }
[16:09:33.676]         base::close(...future.stdout)
[16:09:33.676]         ...future.stdout <- NULL
[16:09:33.676]     }
[16:09:33.676]     ...future.result$conditions <- ...future.conditions
[16:09:33.676]     ...future.result$finished <- base::Sys.time()
[16:09:33.676]     ...future.result
[16:09:33.676] }
[16:09:33.679] assign_globals() ...
[16:09:33.680] List of 5
[16:09:33.680]  $ ...future.FUN            :function (object, ...)  
[16:09:33.680]  $ future.call.arguments    : list()
[16:09:33.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.680]  $ ...future.elements_ii    :List of 2
[16:09:33.680]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.680]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.680]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.680]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:33.680]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.680]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.680]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.680]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:33.680]  $ ...future.seeds_ii       : NULL
[16:09:33.680]  $ ...future.globals.maxSize: NULL
[16:09:33.680]  - attr(*, "resolved")= logi FALSE
[16:09:33.680]  - attr(*, "total_size")= num 1240
[16:09:33.680]  - attr(*, "where")=List of 5
[16:09:33.680]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.680]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.680]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.680]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.680]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.680]  - attr(*, "already-done")= logi TRUE
[16:09:33.690] - copied ‘...future.FUN’ to environment
[16:09:33.690] - copied ‘future.call.arguments’ to environment
[16:09:33.690] - copied ‘...future.elements_ii’ to environment
[16:09:33.690] - copied ‘...future.seeds_ii’ to environment
[16:09:33.690] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.690] assign_globals() ... done
[16:09:33.690] requestCore(): workers = 2
[16:09:33.693] MulticoreFuture started
[16:09:33.693] - Launch lazy future ... done
[16:09:33.693] run() for ‘MulticoreFuture’ ... done
[16:09:33.693] Created future:
[16:09:33.694] plan(): Setting new future strategy stack:
[16:09:33.694] List of future strategies:
[16:09:33.694] 1. sequential:
[16:09:33.694]    - args: function (..., envir = parent.frame())
[16:09:33.694]    - tweaked: FALSE
[16:09:33.694]    - call: NULL
[16:09:33.695] plan(): nbrOfWorkers() = 1
[16:09:33.698] plan(): Setting new future strategy stack:
[16:09:33.699] List of future strategies:
[16:09:33.699] 1. multicore:
[16:09:33.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.699]    - tweaked: FALSE
[16:09:33.699]    - call: plan(strategy)
[16:09:33.703] plan(): nbrOfWorkers() = 2
[16:09:33.693] MulticoreFuture:
[16:09:33.693] Label: ‘future_by-2’
[16:09:33.693] Expression:
[16:09:33.693] {
[16:09:33.693]     do.call(function(...) {
[16:09:33.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.693]             on.exit(options(oopts), add = TRUE)
[16:09:33.693]         }
[16:09:33.693]         {
[16:09:33.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.693]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.693]             })
[16:09:33.693]         }
[16:09:33.693]     }, args = future.call.arguments)
[16:09:33.693] }
[16:09:33.693] Lazy evaluation: FALSE
[16:09:33.693] Asynchronous evaluation: TRUE
[16:09:33.693] Local evaluation: TRUE
[16:09:33.693] Environment: 0x5567e8d8bda0
[16:09:33.693] Capture standard output: TRUE
[16:09:33.693] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.693] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.693] Packages: <none>
[16:09:33.693] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.693] Resolved: TRUE
[16:09:33.693] Value: <not collected>
[16:09:33.693] Conditions captured: <none>
[16:09:33.693] Early signaling: FALSE
[16:09:33.693] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.693] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.704] Chunk #2 of 2 ... DONE
[16:09:33.704] Launching 2 futures (chunks) ... DONE
[16:09:33.704] Resolving 2 futures (chunks) ...
[16:09:33.705] resolve() on list ...
[16:09:33.705]  recursive: 0
[16:09:33.705]  length: 2
[16:09:33.705] 
[16:09:33.705] Future #1
[16:09:33.706] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:33.706] - nx: 2
[16:09:33.707] - relay: TRUE
[16:09:33.707] - stdout: TRUE
[16:09:33.707] - signal: TRUE
[16:09:33.707] - resignal: FALSE
[16:09:33.707] - force: TRUE
[16:09:33.707] - relayed: [n=2] FALSE, FALSE
[16:09:33.707] - queued futures: [n=2] FALSE, FALSE
[16:09:33.707]  - until=1
[16:09:33.707]  - relaying element #1
[16:09:33.708] - relayed: [n=2] TRUE, FALSE
[16:09:33.708] - queued futures: [n=2] TRUE, FALSE
[16:09:33.708] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:33.708]  length: 1 (resolved future 1)
[16:09:33.708] Future #2
[16:09:33.709] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:33.709] - nx: 2
[16:09:33.709] - relay: TRUE
[16:09:33.710] - stdout: TRUE
[16:09:33.710] - signal: TRUE
[16:09:33.710] - resignal: FALSE
[16:09:33.710] - force: TRUE
[16:09:33.710] - relayed: [n=2] TRUE, FALSE
[16:09:33.710] - queued futures: [n=2] TRUE, FALSE
[16:09:33.710]  - until=2
[16:09:33.710]  - relaying element #2
[16:09:33.711] - relayed: [n=2] TRUE, TRUE
[16:09:33.711] - queued futures: [n=2] TRUE, TRUE
[16:09:33.711] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:33.711]  length: 0 (resolved future 2)
[16:09:33.711] Relaying remaining futures
[16:09:33.711] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.711] - nx: 2
[16:09:33.711] - relay: TRUE
[16:09:33.712] - stdout: TRUE
[16:09:33.712] - signal: TRUE
[16:09:33.712] - resignal: FALSE
[16:09:33.712] - force: TRUE
[16:09:33.712] - relayed: [n=2] TRUE, TRUE
[16:09:33.712] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:33.712] - relayed: [n=2] TRUE, TRUE
[16:09:33.712] - queued futures: [n=2] TRUE, TRUE
[16:09:33.713] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.713] resolve() on list ... DONE
[16:09:33.713]  - Number of value chunks collected: 2
[16:09:33.713] Resolving 2 futures (chunks) ... DONE
[16:09:33.713] Reducing values from 2 chunks ...
[16:09:33.713]  - Number of values collected after concatenation: 3
[16:09:33.713]  - Number of values expected: 3
[16:09:33.713] Reducing values from 2 chunks ... DONE
[16:09:33.714] future_lapply() ... DONE
[16:09:33.714] future_by_internal() ... DONE
[16:09:33.715] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:09:33.716] future_lapply() ...
[16:09:33.720] Number of chunks: 2
[16:09:33.720] getGlobalsAndPackagesXApply() ...
[16:09:33.721]  - future.globals: TRUE
[16:09:33.721] getGlobalsAndPackages() ...
[16:09:33.721] Searching for globals...
[16:09:33.722] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:33.722] Searching for globals ... DONE
[16:09:33.722] Resolving globals: FALSE
[16:09:33.723] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:33.723] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:33.724] - globals: [1] ‘FUN’
[16:09:33.724] 
[16:09:33.724] getGlobalsAndPackages() ... DONE
[16:09:33.724]  - globals found/used: [n=1] ‘FUN’
[16:09:33.724]  - needed namespaces: [n=0] 
[16:09:33.724] Finding globals ... DONE
[16:09:33.724]  - use_args: TRUE
[16:09:33.724]  - Getting '...' globals ...
[16:09:33.725] resolve() on list ...
[16:09:33.725]  recursive: 0
[16:09:33.725]  length: 1
[16:09:33.725]  elements: ‘...’
[16:09:33.725]  length: 0 (resolved future 1)
[16:09:33.725] resolve() on list ... DONE
[16:09:33.726]    - '...' content: [n=0] 
[16:09:33.726] List of 1
[16:09:33.726]  $ ...: list()
[16:09:33.726]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.726]  - attr(*, "where")=List of 1
[16:09:33.726]   ..$ ...:<environment: 0x5567eaa38f38> 
[16:09:33.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.726]  - attr(*, "resolved")= logi TRUE
[16:09:33.726]  - attr(*, "total_size")= num NA
[16:09:33.729]  - Getting '...' globals ... DONE
[16:09:33.729] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:33.729] List of 2
[16:09:33.729]  $ ...future.FUN:function (object, ...)  
[16:09:33.729]  $ ...          : list()
[16:09:33.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.729]  - attr(*, "where")=List of 2
[16:09:33.729]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:33.729]   ..$ ...          :<environment: 0x5567eaa38f38> 
[16:09:33.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.729]  - attr(*, "resolved")= logi FALSE
[16:09:33.729]  - attr(*, "total_size")= num 1240
[16:09:33.733] Packages to be attached in all futures: [n=0] 
[16:09:33.733] getGlobalsAndPackagesXApply() ... DONE
[16:09:33.733] Number of futures (= number of chunks): 2
[16:09:33.733] Launching 2 futures (chunks) ...
[16:09:33.733] Chunk #1 of 2 ...
[16:09:33.733]  - Finding globals in 'X' for chunk #1 ...
[16:09:33.734] getGlobalsAndPackages() ...
[16:09:33.734] Searching for globals...
[16:09:33.734] 
[16:09:33.734] Searching for globals ... DONE
[16:09:33.734] - globals: [0] <none>
[16:09:33.734] getGlobalsAndPackages() ... DONE
[16:09:33.735]    + additional globals found: [n=0] 
[16:09:33.735]    + additional namespaces needed: [n=0] 
[16:09:33.735]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:33.735]  - seeds: <none>
[16:09:33.735] getGlobalsAndPackages() ...
[16:09:33.735] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.735] Resolving globals: FALSE
[16:09:33.735] Tweak future expression to call with '...' arguments ...
[16:09:33.736] {
[16:09:33.736]     do.call(function(...) {
[16:09:33.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.736]             on.exit(options(oopts), add = TRUE)
[16:09:33.736]         }
[16:09:33.736]         {
[16:09:33.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.736]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.736]             })
[16:09:33.736]         }
[16:09:33.736]     }, args = future.call.arguments)
[16:09:33.736] }
[16:09:33.736] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.736] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.737] 
[16:09:33.737] getGlobalsAndPackages() ... DONE
[16:09:33.737] run() for ‘Future’ ...
[16:09:33.737] - state: ‘created’
[16:09:33.737] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.741] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.742]   - Field: ‘label’
[16:09:33.742]   - Field: ‘local’
[16:09:33.742]   - Field: ‘owner’
[16:09:33.742]   - Field: ‘envir’
[16:09:33.742]   - Field: ‘workers’
[16:09:33.742]   - Field: ‘packages’
[16:09:33.742]   - Field: ‘gc’
[16:09:33.743]   - Field: ‘job’
[16:09:33.743]   - Field: ‘conditions’
[16:09:33.743]   - Field: ‘expr’
[16:09:33.743]   - Field: ‘uuid’
[16:09:33.743]   - Field: ‘seed’
[16:09:33.743]   - Field: ‘version’
[16:09:33.743]   - Field: ‘result’
[16:09:33.743]   - Field: ‘asynchronous’
[16:09:33.743]   - Field: ‘calls’
[16:09:33.744]   - Field: ‘globals’
[16:09:33.744]   - Field: ‘stdout’
[16:09:33.744]   - Field: ‘earlySignal’
[16:09:33.744]   - Field: ‘lazy’
[16:09:33.744]   - Field: ‘state’
[16:09:33.744] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.744] - Launch lazy future ...
[16:09:33.745] Packages needed by the future expression (n = 0): <none>
[16:09:33.745] Packages needed by future strategies (n = 0): <none>
[16:09:33.745] {
[16:09:33.745]     {
[16:09:33.745]         {
[16:09:33.745]             ...future.startTime <- base::Sys.time()
[16:09:33.745]             {
[16:09:33.745]                 {
[16:09:33.745]                   {
[16:09:33.745]                     {
[16:09:33.745]                       base::local({
[16:09:33.745]                         has_future <- base::requireNamespace("future", 
[16:09:33.745]                           quietly = TRUE)
[16:09:33.745]                         if (has_future) {
[16:09:33.745]                           ns <- base::getNamespace("future")
[16:09:33.745]                           version <- ns[[".package"]][["version"]]
[16:09:33.745]                           if (is.null(version)) 
[16:09:33.745]                             version <- utils::packageVersion("future")
[16:09:33.745]                         }
[16:09:33.745]                         else {
[16:09:33.745]                           version <- NULL
[16:09:33.745]                         }
[16:09:33.745]                         if (!has_future || version < "1.8.0") {
[16:09:33.745]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.745]                             "", base::R.version$version.string), 
[16:09:33.745]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.745]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.745]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.745]                               "release", "version")], collapse = " "), 
[16:09:33.745]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.745]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.745]                             info)
[16:09:33.745]                           info <- base::paste(info, collapse = "; ")
[16:09:33.745]                           if (!has_future) {
[16:09:33.745]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.745]                               info)
[16:09:33.745]                           }
[16:09:33.745]                           else {
[16:09:33.745]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.745]                               info, version)
[16:09:33.745]                           }
[16:09:33.745]                           base::stop(msg)
[16:09:33.745]                         }
[16:09:33.745]                       })
[16:09:33.745]                     }
[16:09:33.745]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.745]                     base::options(mc.cores = 1L)
[16:09:33.745]                   }
[16:09:33.745]                   options(future.plan = NULL)
[16:09:33.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.745]                 }
[16:09:33.745]                 ...future.workdir <- getwd()
[16:09:33.745]             }
[16:09:33.745]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.745]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.745]         }
[16:09:33.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.745]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:33.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.745]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.745]             base::names(...future.oldOptions))
[16:09:33.745]     }
[16:09:33.745]     if (FALSE) {
[16:09:33.745]     }
[16:09:33.745]     else {
[16:09:33.745]         if (TRUE) {
[16:09:33.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.745]                 open = "w")
[16:09:33.745]         }
[16:09:33.745]         else {
[16:09:33.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.745]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.745]         }
[16:09:33.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.745]             base::sink(type = "output", split = FALSE)
[16:09:33.745]             base::close(...future.stdout)
[16:09:33.745]         }, add = TRUE)
[16:09:33.745]     }
[16:09:33.745]     ...future.frame <- base::sys.nframe()
[16:09:33.745]     ...future.conditions <- base::list()
[16:09:33.745]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.745]     if (FALSE) {
[16:09:33.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.745]     }
[16:09:33.745]     ...future.result <- base::tryCatch({
[16:09:33.745]         base::withCallingHandlers({
[16:09:33.745]             ...future.value <- base::withVisible(base::local({
[16:09:33.745]                 withCallingHandlers({
[16:09:33.745]                   {
[16:09:33.745]                     do.call(function(...) {
[16:09:33.745]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.745]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.745]                         ...future.globals.maxSize)) {
[16:09:33.745]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.745]                         on.exit(options(oopts), add = TRUE)
[16:09:33.745]                       }
[16:09:33.745]                       {
[16:09:33.745]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.745]                           FUN = function(jj) {
[16:09:33.745]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.745]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.745]                           })
[16:09:33.745]                       }
[16:09:33.745]                     }, args = future.call.arguments)
[16:09:33.745]                   }
[16:09:33.745]                 }, immediateCondition = function(cond) {
[16:09:33.745]                   save_rds <- function (object, pathname, ...) 
[16:09:33.745]                   {
[16:09:33.745]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.745]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.745]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.745]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.745]                         fi_tmp[["mtime"]])
[16:09:33.745]                     }
[16:09:33.745]                     tryCatch({
[16:09:33.745]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.745]                     }, error = function(ex) {
[16:09:33.745]                       msg <- conditionMessage(ex)
[16:09:33.745]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.745]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.745]                         fi_tmp[["mtime"]], msg)
[16:09:33.745]                       ex$message <- msg
[16:09:33.745]                       stop(ex)
[16:09:33.745]                     })
[16:09:33.745]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.745]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.745]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.745]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.745]                       fi <- file.info(pathname)
[16:09:33.745]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.745]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.745]                         fi[["size"]], fi[["mtime"]])
[16:09:33.745]                       stop(msg)
[16:09:33.745]                     }
[16:09:33.745]                     invisible(pathname)
[16:09:33.745]                   }
[16:09:33.745]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.745]                     rootPath = tempdir()) 
[16:09:33.745]                   {
[16:09:33.745]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.745]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.745]                       tmpdir = path, fileext = ".rds")
[16:09:33.745]                     save_rds(obj, file)
[16:09:33.745]                   }
[16:09:33.745]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.745]                   {
[16:09:33.745]                     inherits <- base::inherits
[16:09:33.745]                     invokeRestart <- base::invokeRestart
[16:09:33.745]                     is.null <- base::is.null
[16:09:33.745]                     muffled <- FALSE
[16:09:33.745]                     if (inherits(cond, "message")) {
[16:09:33.745]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.745]                       if (muffled) 
[16:09:33.745]                         invokeRestart("muffleMessage")
[16:09:33.745]                     }
[16:09:33.745]                     else if (inherits(cond, "warning")) {
[16:09:33.745]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.745]                       if (muffled) 
[16:09:33.745]                         invokeRestart("muffleWarning")
[16:09:33.745]                     }
[16:09:33.745]                     else if (inherits(cond, "condition")) {
[16:09:33.745]                       if (!is.null(pattern)) {
[16:09:33.745]                         computeRestarts <- base::computeRestarts
[16:09:33.745]                         grepl <- base::grepl
[16:09:33.745]                         restarts <- computeRestarts(cond)
[16:09:33.745]                         for (restart in restarts) {
[16:09:33.745]                           name <- restart$name
[16:09:33.745]                           if (is.null(name)) 
[16:09:33.745]                             next
[16:09:33.745]                           if (!grepl(pattern, name)) 
[16:09:33.745]                             next
[16:09:33.745]                           invokeRestart(restart)
[16:09:33.745]                           muffled <- TRUE
[16:09:33.745]                           break
[16:09:33.745]                         }
[16:09:33.745]                       }
[16:09:33.745]                     }
[16:09:33.745]                     invisible(muffled)
[16:09:33.745]                   }
[16:09:33.745]                   muffleCondition(cond)
[16:09:33.745]                 })
[16:09:33.745]             }))
[16:09:33.745]             future::FutureResult(value = ...future.value$value, 
[16:09:33.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.745]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.745]                     ...future.globalenv.names))
[16:09:33.745]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.745]         }, condition = base::local({
[16:09:33.745]             c <- base::c
[16:09:33.745]             inherits <- base::inherits
[16:09:33.745]             invokeRestart <- base::invokeRestart
[16:09:33.745]             length <- base::length
[16:09:33.745]             list <- base::list
[16:09:33.745]             seq.int <- base::seq.int
[16:09:33.745]             signalCondition <- base::signalCondition
[16:09:33.745]             sys.calls <- base::sys.calls
[16:09:33.745]             `[[` <- base::`[[`
[16:09:33.745]             `+` <- base::`+`
[16:09:33.745]             `<<-` <- base::`<<-`
[16:09:33.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.745]                   3L)]
[16:09:33.745]             }
[16:09:33.745]             function(cond) {
[16:09:33.745]                 is_error <- inherits(cond, "error")
[16:09:33.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.745]                   NULL)
[16:09:33.745]                 if (is_error) {
[16:09:33.745]                   sessionInformation <- function() {
[16:09:33.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.745]                       search = base::search(), system = base::Sys.info())
[16:09:33.745]                   }
[16:09:33.745]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.745]                     cond$call), session = sessionInformation(), 
[16:09:33.745]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.745]                   signalCondition(cond)
[16:09:33.745]                 }
[16:09:33.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.745]                 "immediateCondition"))) {
[16:09:33.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.745]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.745]                   if (TRUE && !signal) {
[16:09:33.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.745]                     {
[16:09:33.745]                       inherits <- base::inherits
[16:09:33.745]                       invokeRestart <- base::invokeRestart
[16:09:33.745]                       is.null <- base::is.null
[16:09:33.745]                       muffled <- FALSE
[16:09:33.745]                       if (inherits(cond, "message")) {
[16:09:33.745]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.745]                         if (muffled) 
[16:09:33.745]                           invokeRestart("muffleMessage")
[16:09:33.745]                       }
[16:09:33.745]                       else if (inherits(cond, "warning")) {
[16:09:33.745]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.745]                         if (muffled) 
[16:09:33.745]                           invokeRestart("muffleWarning")
[16:09:33.745]                       }
[16:09:33.745]                       else if (inherits(cond, "condition")) {
[16:09:33.745]                         if (!is.null(pattern)) {
[16:09:33.745]                           computeRestarts <- base::computeRestarts
[16:09:33.745]                           grepl <- base::grepl
[16:09:33.745]                           restarts <- computeRestarts(cond)
[16:09:33.745]                           for (restart in restarts) {
[16:09:33.745]                             name <- restart$name
[16:09:33.745]                             if (is.null(name)) 
[16:09:33.745]                               next
[16:09:33.745]                             if (!grepl(pattern, name)) 
[16:09:33.745]                               next
[16:09:33.745]                             invokeRestart(restart)
[16:09:33.745]                             muffled <- TRUE
[16:09:33.745]                             break
[16:09:33.745]                           }
[16:09:33.745]                         }
[16:09:33.745]                       }
[16:09:33.745]                       invisible(muffled)
[16:09:33.745]                     }
[16:09:33.745]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.745]                   }
[16:09:33.745]                 }
[16:09:33.745]                 else {
[16:09:33.745]                   if (TRUE) {
[16:09:33.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.745]                     {
[16:09:33.745]                       inherits <- base::inherits
[16:09:33.745]                       invokeRestart <- base::invokeRestart
[16:09:33.745]                       is.null <- base::is.null
[16:09:33.745]                       muffled <- FALSE
[16:09:33.745]                       if (inherits(cond, "message")) {
[16:09:33.745]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.745]                         if (muffled) 
[16:09:33.745]                           invokeRestart("muffleMessage")
[16:09:33.745]                       }
[16:09:33.745]                       else if (inherits(cond, "warning")) {
[16:09:33.745]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.745]                         if (muffled) 
[16:09:33.745]                           invokeRestart("muffleWarning")
[16:09:33.745]                       }
[16:09:33.745]                       else if (inherits(cond, "condition")) {
[16:09:33.745]                         if (!is.null(pattern)) {
[16:09:33.745]                           computeRestarts <- base::computeRestarts
[16:09:33.745]                           grepl <- base::grepl
[16:09:33.745]                           restarts <- computeRestarts(cond)
[16:09:33.745]                           for (restart in restarts) {
[16:09:33.745]                             name <- restart$name
[16:09:33.745]                             if (is.null(name)) 
[16:09:33.745]                               next
[16:09:33.745]                             if (!grepl(pattern, name)) 
[16:09:33.745]                               next
[16:09:33.745]                             invokeRestart(restart)
[16:09:33.745]                             muffled <- TRUE
[16:09:33.745]                             break
[16:09:33.745]                           }
[16:09:33.745]                         }
[16:09:33.745]                       }
[16:09:33.745]                       invisible(muffled)
[16:09:33.745]                     }
[16:09:33.745]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.745]                   }
[16:09:33.745]                 }
[16:09:33.745]             }
[16:09:33.745]         }))
[16:09:33.745]     }, error = function(ex) {
[16:09:33.745]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.745]                 ...future.rng), started = ...future.startTime, 
[16:09:33.745]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.745]             version = "1.8"), class = "FutureResult")
[16:09:33.745]     }, finally = {
[16:09:33.745]         if (!identical(...future.workdir, getwd())) 
[16:09:33.745]             setwd(...future.workdir)
[16:09:33.745]         {
[16:09:33.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.745]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.745]             }
[16:09:33.745]             base::options(...future.oldOptions)
[16:09:33.745]             if (.Platform$OS.type == "windows") {
[16:09:33.745]                 old_names <- names(...future.oldEnvVars)
[16:09:33.745]                 envs <- base::Sys.getenv()
[16:09:33.745]                 names <- names(envs)
[16:09:33.745]                 common <- intersect(names, old_names)
[16:09:33.745]                 added <- setdiff(names, old_names)
[16:09:33.745]                 removed <- setdiff(old_names, names)
[16:09:33.745]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.745]                   envs[common]]
[16:09:33.745]                 NAMES <- toupper(changed)
[16:09:33.745]                 args <- list()
[16:09:33.745]                 for (kk in seq_along(NAMES)) {
[16:09:33.745]                   name <- changed[[kk]]
[16:09:33.745]                   NAME <- NAMES[[kk]]
[16:09:33.745]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.745]                     next
[16:09:33.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.745]                 }
[16:09:33.745]                 NAMES <- toupper(added)
[16:09:33.745]                 for (kk in seq_along(NAMES)) {
[16:09:33.745]                   name <- added[[kk]]
[16:09:33.745]                   NAME <- NAMES[[kk]]
[16:09:33.745]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.745]                     next
[16:09:33.745]                   args[[name]] <- ""
[16:09:33.745]                 }
[16:09:33.745]                 NAMES <- toupper(removed)
[16:09:33.745]                 for (kk in seq_along(NAMES)) {
[16:09:33.745]                   name <- removed[[kk]]
[16:09:33.745]                   NAME <- NAMES[[kk]]
[16:09:33.745]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.745]                     next
[16:09:33.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.745]                 }
[16:09:33.745]                 if (length(args) > 0) 
[16:09:33.745]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.745]             }
[16:09:33.745]             else {
[16:09:33.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.745]             }
[16:09:33.745]             {
[16:09:33.745]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.745]                   0L) {
[16:09:33.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.745]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.745]                   base::options(opts)
[16:09:33.745]                 }
[16:09:33.745]                 {
[16:09:33.745]                   {
[16:09:33.745]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.745]                     NULL
[16:09:33.745]                   }
[16:09:33.745]                   options(future.plan = NULL)
[16:09:33.745]                   if (is.na(NA_character_)) 
[16:09:33.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.745]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.745]                     envir = parent.frame()) 
[16:09:33.745]                   {
[16:09:33.745]                     default_workers <- missing(workers)
[16:09:33.745]                     if (is.function(workers)) 
[16:09:33.745]                       workers <- workers()
[16:09:33.745]                     workers <- structure(as.integer(workers), 
[16:09:33.745]                       class = class(workers))
[16:09:33.745]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.745]                       1L)
[16:09:33.745]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.745]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.745]                       if (default_workers) 
[16:09:33.745]                         supportsMulticore(warn = TRUE)
[16:09:33.745]                       return(sequential(..., envir = envir))
[16:09:33.745]                     }
[16:09:33.745]                     oopts <- options(mc.cores = workers)
[16:09:33.745]                     on.exit(options(oopts))
[16:09:33.745]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.745]                       envir = envir)
[16:09:33.745]                     if (!future$lazy) 
[16:09:33.745]                       future <- run(future)
[16:09:33.745]                     invisible(future)
[16:09:33.745]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.745]                 }
[16:09:33.745]             }
[16:09:33.745]         }
[16:09:33.745]     })
[16:09:33.745]     if (TRUE) {
[16:09:33.745]         base::sink(type = "output", split = FALSE)
[16:09:33.745]         if (TRUE) {
[16:09:33.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.745]         }
[16:09:33.745]         else {
[16:09:33.745]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.745]         }
[16:09:33.745]         base::close(...future.stdout)
[16:09:33.745]         ...future.stdout <- NULL
[16:09:33.745]     }
[16:09:33.745]     ...future.result$conditions <- ...future.conditions
[16:09:33.745]     ...future.result$finished <- base::Sys.time()
[16:09:33.745]     ...future.result
[16:09:33.745] }
[16:09:33.748] assign_globals() ...
[16:09:33.748] List of 5
[16:09:33.748]  $ ...future.FUN            :function (object, ...)  
[16:09:33.748]  $ future.call.arguments    : list()
[16:09:33.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.748]  $ ...future.elements_ii    :List of 1
[16:09:33.748]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.748]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:09:33.748]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.748]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:33.748]  $ ...future.seeds_ii       : NULL
[16:09:33.748]  $ ...future.globals.maxSize: NULL
[16:09:33.748]  - attr(*, "where")=List of 5
[16:09:33.748]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.748]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.748]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.748]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.748]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.748]  - attr(*, "resolved")= logi FALSE
[16:09:33.748]  - attr(*, "total_size")= num 1240
[16:09:33.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.748]  - attr(*, "already-done")= logi TRUE
[16:09:33.758] - copied ‘...future.FUN’ to environment
[16:09:33.758] - copied ‘future.call.arguments’ to environment
[16:09:33.758] - copied ‘...future.elements_ii’ to environment
[16:09:33.758] - copied ‘...future.seeds_ii’ to environment
[16:09:33.758] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.758] assign_globals() ... done
[16:09:33.759] requestCore(): workers = 2
[16:09:33.761] MulticoreFuture started
[16:09:33.761] - Launch lazy future ... done
[16:09:33.761] run() for ‘MulticoreFuture’ ... done
[16:09:33.761] Created future:
[16:09:33.762] plan(): Setting new future strategy stack:
[16:09:33.762] List of future strategies:
[16:09:33.762] 1. sequential:
[16:09:33.762]    - args: function (..., envir = parent.frame())
[16:09:33.762]    - tweaked: FALSE
[16:09:33.762]    - call: NULL
[16:09:33.763] plan(): nbrOfWorkers() = 1
[16:09:33.766] plan(): Setting new future strategy stack:
[16:09:33.766] List of future strategies:
[16:09:33.766] 1. multicore:
[16:09:33.766]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.766]    - tweaked: FALSE
[16:09:33.766]    - call: plan(strategy)
[16:09:33.771] plan(): nbrOfWorkers() = 2
[16:09:33.762] MulticoreFuture:
[16:09:33.762] Label: ‘future_by-1’
[16:09:33.762] Expression:
[16:09:33.762] {
[16:09:33.762]     do.call(function(...) {
[16:09:33.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.762]             on.exit(options(oopts), add = TRUE)
[16:09:33.762]         }
[16:09:33.762]         {
[16:09:33.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.762]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.762]             })
[16:09:33.762]         }
[16:09:33.762]     }, args = future.call.arguments)
[16:09:33.762] }
[16:09:33.762] Lazy evaluation: FALSE
[16:09:33.762] Asynchronous evaluation: TRUE
[16:09:33.762] Local evaluation: TRUE
[16:09:33.762] Environment: 0x5567eaa04080
[16:09:33.762] Capture standard output: TRUE
[16:09:33.762] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.762] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.762] Packages: <none>
[16:09:33.762] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.762] Resolved: TRUE
[16:09:33.762] Value: <not collected>
[16:09:33.762] Conditions captured: <none>
[16:09:33.762] Early signaling: FALSE
[16:09:33.762] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.762] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.772] Chunk #1 of 2 ... DONE
[16:09:33.772] Chunk #2 of 2 ...
[16:09:33.772]  - Finding globals in 'X' for chunk #2 ...
[16:09:33.773] getGlobalsAndPackages() ...
[16:09:33.773] Searching for globals...
[16:09:33.773] 
[16:09:33.774] Searching for globals ... DONE
[16:09:33.774] - globals: [0] <none>
[16:09:33.774] getGlobalsAndPackages() ... DONE
[16:09:33.774]    + additional globals found: [n=0] 
[16:09:33.774]    + additional namespaces needed: [n=0] 
[16:09:33.774]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:33.774]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:33.774]  - seeds: <none>
[16:09:33.775] getGlobalsAndPackages() ...
[16:09:33.775] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.775] Resolving globals: FALSE
[16:09:33.775] Tweak future expression to call with '...' arguments ...
[16:09:33.775] {
[16:09:33.775]     do.call(function(...) {
[16:09:33.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.775]             on.exit(options(oopts), add = TRUE)
[16:09:33.775]         }
[16:09:33.775]         {
[16:09:33.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.775]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.775]             })
[16:09:33.775]         }
[16:09:33.775]     }, args = future.call.arguments)
[16:09:33.775] }
[16:09:33.776] Tweak future expression to call with '...' arguments ... DONE
[16:09:33.776] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:33.776] 
[16:09:33.777] getGlobalsAndPackages() ... DONE
[16:09:33.777] run() for ‘Future’ ...
[16:09:33.777] - state: ‘created’
[16:09:33.777] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:33.782] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:33.782]   - Field: ‘label’
[16:09:33.782]   - Field: ‘local’
[16:09:33.782]   - Field: ‘owner’
[16:09:33.782]   - Field: ‘envir’
[16:09:33.783]   - Field: ‘workers’
[16:09:33.783]   - Field: ‘packages’
[16:09:33.783]   - Field: ‘gc’
[16:09:33.783]   - Field: ‘job’
[16:09:33.783]   - Field: ‘conditions’
[16:09:33.783]   - Field: ‘expr’
[16:09:33.783]   - Field: ‘uuid’
[16:09:33.784]   - Field: ‘seed’
[16:09:33.784]   - Field: ‘version’
[16:09:33.784]   - Field: ‘result’
[16:09:33.784]   - Field: ‘asynchronous’
[16:09:33.784]   - Field: ‘calls’
[16:09:33.784]   - Field: ‘globals’
[16:09:33.784]   - Field: ‘stdout’
[16:09:33.785]   - Field: ‘earlySignal’
[16:09:33.785]   - Field: ‘lazy’
[16:09:33.785]   - Field: ‘state’
[16:09:33.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:33.785] - Launch lazy future ...
[16:09:33.786] Packages needed by the future expression (n = 0): <none>
[16:09:33.786] Packages needed by future strategies (n = 0): <none>
[16:09:33.787] {
[16:09:33.787]     {
[16:09:33.787]         {
[16:09:33.787]             ...future.startTime <- base::Sys.time()
[16:09:33.787]             {
[16:09:33.787]                 {
[16:09:33.787]                   {
[16:09:33.787]                     {
[16:09:33.787]                       base::local({
[16:09:33.787]                         has_future <- base::requireNamespace("future", 
[16:09:33.787]                           quietly = TRUE)
[16:09:33.787]                         if (has_future) {
[16:09:33.787]                           ns <- base::getNamespace("future")
[16:09:33.787]                           version <- ns[[".package"]][["version"]]
[16:09:33.787]                           if (is.null(version)) 
[16:09:33.787]                             version <- utils::packageVersion("future")
[16:09:33.787]                         }
[16:09:33.787]                         else {
[16:09:33.787]                           version <- NULL
[16:09:33.787]                         }
[16:09:33.787]                         if (!has_future || version < "1.8.0") {
[16:09:33.787]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:33.787]                             "", base::R.version$version.string), 
[16:09:33.787]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:33.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:33.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:33.787]                               "release", "version")], collapse = " "), 
[16:09:33.787]                             hostname = base::Sys.info()[["nodename"]])
[16:09:33.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:33.787]                             info)
[16:09:33.787]                           info <- base::paste(info, collapse = "; ")
[16:09:33.787]                           if (!has_future) {
[16:09:33.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:33.787]                               info)
[16:09:33.787]                           }
[16:09:33.787]                           else {
[16:09:33.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:33.787]                               info, version)
[16:09:33.787]                           }
[16:09:33.787]                           base::stop(msg)
[16:09:33.787]                         }
[16:09:33.787]                       })
[16:09:33.787]                     }
[16:09:33.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:33.787]                     base::options(mc.cores = 1L)
[16:09:33.787]                   }
[16:09:33.787]                   options(future.plan = NULL)
[16:09:33.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:33.787]                 }
[16:09:33.787]                 ...future.workdir <- getwd()
[16:09:33.787]             }
[16:09:33.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:33.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:33.787]         }
[16:09:33.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:33.787]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:33.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:33.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:33.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:33.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:33.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:33.787]             base::names(...future.oldOptions))
[16:09:33.787]     }
[16:09:33.787]     if (FALSE) {
[16:09:33.787]     }
[16:09:33.787]     else {
[16:09:33.787]         if (TRUE) {
[16:09:33.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:33.787]                 open = "w")
[16:09:33.787]         }
[16:09:33.787]         else {
[16:09:33.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:33.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:33.787]         }
[16:09:33.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:33.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:33.787]             base::sink(type = "output", split = FALSE)
[16:09:33.787]             base::close(...future.stdout)
[16:09:33.787]         }, add = TRUE)
[16:09:33.787]     }
[16:09:33.787]     ...future.frame <- base::sys.nframe()
[16:09:33.787]     ...future.conditions <- base::list()
[16:09:33.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:33.787]     if (FALSE) {
[16:09:33.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:33.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:33.787]     }
[16:09:33.787]     ...future.result <- base::tryCatch({
[16:09:33.787]         base::withCallingHandlers({
[16:09:33.787]             ...future.value <- base::withVisible(base::local({
[16:09:33.787]                 withCallingHandlers({
[16:09:33.787]                   {
[16:09:33.787]                     do.call(function(...) {
[16:09:33.787]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.787]                       if (!identical(...future.globals.maxSize.org, 
[16:09:33.787]                         ...future.globals.maxSize)) {
[16:09:33.787]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.787]                         on.exit(options(oopts), add = TRUE)
[16:09:33.787]                       }
[16:09:33.787]                       {
[16:09:33.787]                         lapply(seq_along(...future.elements_ii), 
[16:09:33.787]                           FUN = function(jj) {
[16:09:33.787]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.787]                             ...future.FUN(...future.X_jj, ...)
[16:09:33.787]                           })
[16:09:33.787]                       }
[16:09:33.787]                     }, args = future.call.arguments)
[16:09:33.787]                   }
[16:09:33.787]                 }, immediateCondition = function(cond) {
[16:09:33.787]                   save_rds <- function (object, pathname, ...) 
[16:09:33.787]                   {
[16:09:33.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:33.787]                     if (file_test("-f", pathname_tmp)) {
[16:09:33.787]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:33.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.787]                         fi_tmp[["mtime"]])
[16:09:33.787]                     }
[16:09:33.787]                     tryCatch({
[16:09:33.787]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:33.787]                     }, error = function(ex) {
[16:09:33.787]                       msg <- conditionMessage(ex)
[16:09:33.787]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:33.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.787]                         fi_tmp[["mtime"]], msg)
[16:09:33.787]                       ex$message <- msg
[16:09:33.787]                       stop(ex)
[16:09:33.787]                     })
[16:09:33.787]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:33.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:33.787]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:33.787]                       fi_tmp <- file.info(pathname_tmp)
[16:09:33.787]                       fi <- file.info(pathname)
[16:09:33.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:33.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:33.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:33.787]                         fi[["size"]], fi[["mtime"]])
[16:09:33.787]                       stop(msg)
[16:09:33.787]                     }
[16:09:33.787]                     invisible(pathname)
[16:09:33.787]                   }
[16:09:33.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:33.787]                     rootPath = tempdir()) 
[16:09:33.787]                   {
[16:09:33.787]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:33.787]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:33.787]                       tmpdir = path, fileext = ".rds")
[16:09:33.787]                     save_rds(obj, file)
[16:09:33.787]                   }
[16:09:33.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpauWMCG/.future/immediateConditions")
[16:09:33.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.787]                   {
[16:09:33.787]                     inherits <- base::inherits
[16:09:33.787]                     invokeRestart <- base::invokeRestart
[16:09:33.787]                     is.null <- base::is.null
[16:09:33.787]                     muffled <- FALSE
[16:09:33.787]                     if (inherits(cond, "message")) {
[16:09:33.787]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:33.787]                       if (muffled) 
[16:09:33.787]                         invokeRestart("muffleMessage")
[16:09:33.787]                     }
[16:09:33.787]                     else if (inherits(cond, "warning")) {
[16:09:33.787]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:33.787]                       if (muffled) 
[16:09:33.787]                         invokeRestart("muffleWarning")
[16:09:33.787]                     }
[16:09:33.787]                     else if (inherits(cond, "condition")) {
[16:09:33.787]                       if (!is.null(pattern)) {
[16:09:33.787]                         computeRestarts <- base::computeRestarts
[16:09:33.787]                         grepl <- base::grepl
[16:09:33.787]                         restarts <- computeRestarts(cond)
[16:09:33.787]                         for (restart in restarts) {
[16:09:33.787]                           name <- restart$name
[16:09:33.787]                           if (is.null(name)) 
[16:09:33.787]                             next
[16:09:33.787]                           if (!grepl(pattern, name)) 
[16:09:33.787]                             next
[16:09:33.787]                           invokeRestart(restart)
[16:09:33.787]                           muffled <- TRUE
[16:09:33.787]                           break
[16:09:33.787]                         }
[16:09:33.787]                       }
[16:09:33.787]                     }
[16:09:33.787]                     invisible(muffled)
[16:09:33.787]                   }
[16:09:33.787]                   muffleCondition(cond)
[16:09:33.787]                 })
[16:09:33.787]             }))
[16:09:33.787]             future::FutureResult(value = ...future.value$value, 
[16:09:33.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.787]                   ...future.rng), globalenv = if (FALSE) 
[16:09:33.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:33.787]                     ...future.globalenv.names))
[16:09:33.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:33.787]         }, condition = base::local({
[16:09:33.787]             c <- base::c
[16:09:33.787]             inherits <- base::inherits
[16:09:33.787]             invokeRestart <- base::invokeRestart
[16:09:33.787]             length <- base::length
[16:09:33.787]             list <- base::list
[16:09:33.787]             seq.int <- base::seq.int
[16:09:33.787]             signalCondition <- base::signalCondition
[16:09:33.787]             sys.calls <- base::sys.calls
[16:09:33.787]             `[[` <- base::`[[`
[16:09:33.787]             `+` <- base::`+`
[16:09:33.787]             `<<-` <- base::`<<-`
[16:09:33.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:33.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:33.787]                   3L)]
[16:09:33.787]             }
[16:09:33.787]             function(cond) {
[16:09:33.787]                 is_error <- inherits(cond, "error")
[16:09:33.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:33.787]                   NULL)
[16:09:33.787]                 if (is_error) {
[16:09:33.787]                   sessionInformation <- function() {
[16:09:33.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:33.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:33.787]                       search = base::search(), system = base::Sys.info())
[16:09:33.787]                   }
[16:09:33.787]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:33.787]                     cond$call), session = sessionInformation(), 
[16:09:33.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:33.787]                   signalCondition(cond)
[16:09:33.787]                 }
[16:09:33.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:33.787]                 "immediateCondition"))) {
[16:09:33.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:33.787]                   ...future.conditions[[length(...future.conditions) + 
[16:09:33.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:33.787]                   if (TRUE && !signal) {
[16:09:33.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.787]                     {
[16:09:33.787]                       inherits <- base::inherits
[16:09:33.787]                       invokeRestart <- base::invokeRestart
[16:09:33.787]                       is.null <- base::is.null
[16:09:33.787]                       muffled <- FALSE
[16:09:33.787]                       if (inherits(cond, "message")) {
[16:09:33.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.787]                         if (muffled) 
[16:09:33.787]                           invokeRestart("muffleMessage")
[16:09:33.787]                       }
[16:09:33.787]                       else if (inherits(cond, "warning")) {
[16:09:33.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.787]                         if (muffled) 
[16:09:33.787]                           invokeRestart("muffleWarning")
[16:09:33.787]                       }
[16:09:33.787]                       else if (inherits(cond, "condition")) {
[16:09:33.787]                         if (!is.null(pattern)) {
[16:09:33.787]                           computeRestarts <- base::computeRestarts
[16:09:33.787]                           grepl <- base::grepl
[16:09:33.787]                           restarts <- computeRestarts(cond)
[16:09:33.787]                           for (restart in restarts) {
[16:09:33.787]                             name <- restart$name
[16:09:33.787]                             if (is.null(name)) 
[16:09:33.787]                               next
[16:09:33.787]                             if (!grepl(pattern, name)) 
[16:09:33.787]                               next
[16:09:33.787]                             invokeRestart(restart)
[16:09:33.787]                             muffled <- TRUE
[16:09:33.787]                             break
[16:09:33.787]                           }
[16:09:33.787]                         }
[16:09:33.787]                       }
[16:09:33.787]                       invisible(muffled)
[16:09:33.787]                     }
[16:09:33.787]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.787]                   }
[16:09:33.787]                 }
[16:09:33.787]                 else {
[16:09:33.787]                   if (TRUE) {
[16:09:33.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:33.787]                     {
[16:09:33.787]                       inherits <- base::inherits
[16:09:33.787]                       invokeRestart <- base::invokeRestart
[16:09:33.787]                       is.null <- base::is.null
[16:09:33.787]                       muffled <- FALSE
[16:09:33.787]                       if (inherits(cond, "message")) {
[16:09:33.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:33.787]                         if (muffled) 
[16:09:33.787]                           invokeRestart("muffleMessage")
[16:09:33.787]                       }
[16:09:33.787]                       else if (inherits(cond, "warning")) {
[16:09:33.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:33.787]                         if (muffled) 
[16:09:33.787]                           invokeRestart("muffleWarning")
[16:09:33.787]                       }
[16:09:33.787]                       else if (inherits(cond, "condition")) {
[16:09:33.787]                         if (!is.null(pattern)) {
[16:09:33.787]                           computeRestarts <- base::computeRestarts
[16:09:33.787]                           grepl <- base::grepl
[16:09:33.787]                           restarts <- computeRestarts(cond)
[16:09:33.787]                           for (restart in restarts) {
[16:09:33.787]                             name <- restart$name
[16:09:33.787]                             if (is.null(name)) 
[16:09:33.787]                               next
[16:09:33.787]                             if (!grepl(pattern, name)) 
[16:09:33.787]                               next
[16:09:33.787]                             invokeRestart(restart)
[16:09:33.787]                             muffled <- TRUE
[16:09:33.787]                             break
[16:09:33.787]                           }
[16:09:33.787]                         }
[16:09:33.787]                       }
[16:09:33.787]                       invisible(muffled)
[16:09:33.787]                     }
[16:09:33.787]                     muffleCondition(cond, pattern = "^muffle")
[16:09:33.787]                   }
[16:09:33.787]                 }
[16:09:33.787]             }
[16:09:33.787]         }))
[16:09:33.787]     }, error = function(ex) {
[16:09:33.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:33.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:33.787]                 ...future.rng), started = ...future.startTime, 
[16:09:33.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:33.787]             version = "1.8"), class = "FutureResult")
[16:09:33.787]     }, finally = {
[16:09:33.787]         if (!identical(...future.workdir, getwd())) 
[16:09:33.787]             setwd(...future.workdir)
[16:09:33.787]         {
[16:09:33.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:33.787]                 ...future.oldOptions$nwarnings <- NULL
[16:09:33.787]             }
[16:09:33.787]             base::options(...future.oldOptions)
[16:09:33.787]             if (.Platform$OS.type == "windows") {
[16:09:33.787]                 old_names <- names(...future.oldEnvVars)
[16:09:33.787]                 envs <- base::Sys.getenv()
[16:09:33.787]                 names <- names(envs)
[16:09:33.787]                 common <- intersect(names, old_names)
[16:09:33.787]                 added <- setdiff(names, old_names)
[16:09:33.787]                 removed <- setdiff(old_names, names)
[16:09:33.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:33.787]                   envs[common]]
[16:09:33.787]                 NAMES <- toupper(changed)
[16:09:33.787]                 args <- list()
[16:09:33.787]                 for (kk in seq_along(NAMES)) {
[16:09:33.787]                   name <- changed[[kk]]
[16:09:33.787]                   NAME <- NAMES[[kk]]
[16:09:33.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.787]                     next
[16:09:33.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.787]                 }
[16:09:33.787]                 NAMES <- toupper(added)
[16:09:33.787]                 for (kk in seq_along(NAMES)) {
[16:09:33.787]                   name <- added[[kk]]
[16:09:33.787]                   NAME <- NAMES[[kk]]
[16:09:33.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.787]                     next
[16:09:33.787]                   args[[name]] <- ""
[16:09:33.787]                 }
[16:09:33.787]                 NAMES <- toupper(removed)
[16:09:33.787]                 for (kk in seq_along(NAMES)) {
[16:09:33.787]                   name <- removed[[kk]]
[16:09:33.787]                   NAME <- NAMES[[kk]]
[16:09:33.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:33.787]                     next
[16:09:33.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:33.787]                 }
[16:09:33.787]                 if (length(args) > 0) 
[16:09:33.787]                   base::do.call(base::Sys.setenv, args = args)
[16:09:33.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:33.787]             }
[16:09:33.787]             else {
[16:09:33.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:33.787]             }
[16:09:33.787]             {
[16:09:33.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:33.787]                   0L) {
[16:09:33.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:33.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:33.787]                   base::options(opts)
[16:09:33.787]                 }
[16:09:33.787]                 {
[16:09:33.787]                   {
[16:09:33.787]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:33.787]                     NULL
[16:09:33.787]                   }
[16:09:33.787]                   options(future.plan = NULL)
[16:09:33.787]                   if (is.na(NA_character_)) 
[16:09:33.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:33.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:33.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:33.787]                     envir = parent.frame()) 
[16:09:33.787]                   {
[16:09:33.787]                     default_workers <- missing(workers)
[16:09:33.787]                     if (is.function(workers)) 
[16:09:33.787]                       workers <- workers()
[16:09:33.787]                     workers <- structure(as.integer(workers), 
[16:09:33.787]                       class = class(workers))
[16:09:33.787]                     stop_if_not(is.finite(workers), workers >= 
[16:09:33.787]                       1L)
[16:09:33.787]                     if ((workers == 1L && !inherits(workers, 
[16:09:33.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:33.787]                       if (default_workers) 
[16:09:33.787]                         supportsMulticore(warn = TRUE)
[16:09:33.787]                       return(sequential(..., envir = envir))
[16:09:33.787]                     }
[16:09:33.787]                     oopts <- options(mc.cores = workers)
[16:09:33.787]                     on.exit(options(oopts))
[16:09:33.787]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:33.787]                       envir = envir)
[16:09:33.787]                     if (!future$lazy) 
[16:09:33.787]                       future <- run(future)
[16:09:33.787]                     invisible(future)
[16:09:33.787]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:33.787]                 }
[16:09:33.787]             }
[16:09:33.787]         }
[16:09:33.787]     })
[16:09:33.787]     if (TRUE) {
[16:09:33.787]         base::sink(type = "output", split = FALSE)
[16:09:33.787]         if (TRUE) {
[16:09:33.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:33.787]         }
[16:09:33.787]         else {
[16:09:33.787]             ...future.result["stdout"] <- base::list(NULL)
[16:09:33.787]         }
[16:09:33.787]         base::close(...future.stdout)
[16:09:33.787]         ...future.stdout <- NULL
[16:09:33.787]     }
[16:09:33.787]     ...future.result$conditions <- ...future.conditions
[16:09:33.787]     ...future.result$finished <- base::Sys.time()
[16:09:33.787]     ...future.result
[16:09:33.787] }
[16:09:33.790] assign_globals() ...
[16:09:33.790] List of 5
[16:09:33.790]  $ ...future.FUN            :function (object, ...)  
[16:09:33.790]  $ future.call.arguments    : list()
[16:09:33.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:33.790]  $ ...future.elements_ii    :List of 2
[16:09:33.790]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.790]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:09:33.790]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.790]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:09:33.790]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:09:33.790]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:09:33.790]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:09:33.790]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:09:33.790]  $ ...future.seeds_ii       : NULL
[16:09:33.790]  $ ...future.globals.maxSize: NULL
[16:09:33.790]  - attr(*, "resolved")= logi FALSE
[16:09:33.790]  - attr(*, "total_size")= num 1240
[16:09:33.790]  - attr(*, "where")=List of 5
[16:09:33.790]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:33.790]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:33.790]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:33.790]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:33.790]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:33.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:33.790]  - attr(*, "already-done")= logi TRUE
[16:09:33.801] - copied ‘...future.FUN’ to environment
[16:09:33.802] - copied ‘future.call.arguments’ to environment
[16:09:33.802] - copied ‘...future.elements_ii’ to environment
[16:09:33.802] - copied ‘...future.seeds_ii’ to environment
[16:09:33.802] - copied ‘...future.globals.maxSize’ to environment
[16:09:33.802] assign_globals() ... done
[16:09:33.803] requestCore(): workers = 2
[16:09:33.805] MulticoreFuture started
[16:09:33.805] - Launch lazy future ... done
[16:09:33.806] run() for ‘MulticoreFuture’ ... done
[16:09:33.806] Created future:
[16:09:33.806] plan(): Setting new future strategy stack:
[16:09:33.806] List of future strategies:
[16:09:33.806] 1. sequential:
[16:09:33.806]    - args: function (..., envir = parent.frame())
[16:09:33.806]    - tweaked: FALSE
[16:09:33.806]    - call: NULL
[16:09:33.807] plan(): nbrOfWorkers() = 1
[16:09:33.811] plan(): Setting new future strategy stack:
[16:09:33.812] List of future strategies:
[16:09:33.812] 1. multicore:
[16:09:33.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:33.812]    - tweaked: FALSE
[16:09:33.812]    - call: plan(strategy)
[16:09:33.817] plan(): nbrOfWorkers() = 2
[16:09:33.806] MulticoreFuture:
[16:09:33.806] Label: ‘future_by-2’
[16:09:33.806] Expression:
[16:09:33.806] {
[16:09:33.806]     do.call(function(...) {
[16:09:33.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:33.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:33.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:33.806]             on.exit(options(oopts), add = TRUE)
[16:09:33.806]         }
[16:09:33.806]         {
[16:09:33.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:33.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:33.806]                 ...future.FUN(...future.X_jj, ...)
[16:09:33.806]             })
[16:09:33.806]         }
[16:09:33.806]     }, args = future.call.arguments)
[16:09:33.806] }
[16:09:33.806] Lazy evaluation: FALSE
[16:09:33.806] Asynchronous evaluation: TRUE
[16:09:33.806] Local evaluation: TRUE
[16:09:33.806] Environment: 0x5567eaa04080
[16:09:33.806] Capture standard output: TRUE
[16:09:33.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:33.806] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:33.806] Packages: <none>
[16:09:33.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:33.806] Resolved: TRUE
[16:09:33.806] Value: <not collected>
[16:09:33.806] Conditions captured: <none>
[16:09:33.806] Early signaling: FALSE
[16:09:33.806] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:33.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:33.818] Chunk #2 of 2 ... DONE
[16:09:33.818] Launching 2 futures (chunks) ... DONE
[16:09:33.818] Resolving 2 futures (chunks) ...
[16:09:33.818] resolve() on list ...
[16:09:33.818]  recursive: 0
[16:09:33.818]  length: 2
[16:09:33.819] 
[16:09:33.819] Future #1
[16:09:33.820] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:33.820] - nx: 2
[16:09:33.820] - relay: TRUE
[16:09:33.820] - stdout: TRUE
[16:09:33.821] - signal: TRUE
[16:09:33.821] - resignal: FALSE
[16:09:33.821] - force: TRUE
[16:09:33.821] - relayed: [n=2] FALSE, FALSE
[16:09:33.821] - queued futures: [n=2] FALSE, FALSE
[16:09:33.821]  - until=1
[16:09:33.821]  - relaying element #1
[16:09:33.822] - relayed: [n=2] TRUE, FALSE
[16:09:33.822] - queued futures: [n=2] TRUE, FALSE
[16:09:33.822] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:33.822]  length: 1 (resolved future 1)
[16:09:33.822] Future #2
[16:09:33.823] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:33.823] - nx: 2
[16:09:33.823] - relay: TRUE
[16:09:33.824] - stdout: TRUE
[16:09:33.824] - signal: TRUE
[16:09:33.824] - resignal: FALSE
[16:09:33.824] - force: TRUE
[16:09:33.824] - relayed: [n=2] TRUE, FALSE
[16:09:33.824] - queued futures: [n=2] TRUE, FALSE
[16:09:33.824]  - until=2
[16:09:33.824]  - relaying element #2
[16:09:33.825] - relayed: [n=2] TRUE, TRUE
[16:09:33.825] - queued futures: [n=2] TRUE, TRUE
[16:09:33.825] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:33.825]  length: 0 (resolved future 2)
[16:09:33.825] Relaying remaining futures
[16:09:33.825] signalConditionsASAP(NULL, pos=0) ...
[16:09:33.825] - nx: 2
[16:09:33.825] - relay: TRUE
[16:09:33.826] - stdout: TRUE
[16:09:33.826] - signal: TRUE
[16:09:33.826] - resignal: FALSE
[16:09:33.826] - force: TRUE
[16:09:33.826] - relayed: [n=2] TRUE, TRUE
[16:09:33.826] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:33.826] - relayed: [n=2] TRUE, TRUE
[16:09:33.826] - queued futures: [n=2] TRUE, TRUE
[16:09:33.826] signalConditionsASAP(NULL, pos=0) ... done
[16:09:33.827] resolve() on list ... DONE
[16:09:33.827]  - Number of value chunks collected: 2
[16:09:33.827] Resolving 2 futures (chunks) ... DONE
[16:09:33.827] Reducing values from 2 chunks ...
[16:09:33.827]  - Number of values collected after concatenation: 3
[16:09:33.827]  - Number of values expected: 3
[16:09:33.827] Reducing values from 2 chunks ... DONE
[16:09:33.827] future_lapply() ... DONE
[16:09:33.828] future_by_internal() ... DONE
[16:09:33.829] future_by_internal() ...
- plan('multisession') ...
[16:09:33.829] plan(): Setting new future strategy stack:
[16:09:33.829] List of future strategies:
[16:09:33.829] 1. multisession:
[16:09:33.829]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:33.829]    - tweaked: FALSE
[16:09:33.829]    - call: plan(strategy)
[16:09:33.830] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:09:33.830] multisession:
[16:09:33.830] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:33.830] - tweaked: FALSE
[16:09:33.830] - call: plan(strategy)
[16:09:33.836] getGlobalsAndPackages() ...
[16:09:33.837] Not searching for globals
[16:09:33.837] - globals: [0] <none>
[16:09:33.837] getGlobalsAndPackages() ... DONE
[16:09:33.837] [local output] makeClusterPSOCK() ...
[16:09:33.884] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:09:33.890] [local output] Base port: 11680
[16:09:33.890] [local output] Getting setup options for 2 cluster nodes ...
[16:09:33.890] [local output]  - Node 1 of 2 ...
[16:09:33.890] [local output] localMachine=TRUE => revtunnel=FALSE

[16:09:33.891] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpauWMCG/worker.rank=1.parallelly.parent=69210.10e5a2da87525.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpauWMCG/worker.rank=1.parallelly.parent=69210.10e5a2da87525.pid")'’
[16:09:34.077] - Possible to infer worker's PID: TRUE
[16:09:34.078] [local output] Rscript port: 11680

[16:09:34.078] [local output]  - Node 2 of 2 ...
[16:09:34.078] [local output] localMachine=TRUE => revtunnel=FALSE

[16:09:34.079] [local output] Rscript port: 11680

[16:09:34.079] [local output] Getting setup options for 2 cluster nodes ... done
[16:09:34.079] [local output]  - Parallel setup requested for some PSOCK nodes
[16:09:34.080] [local output] Setting up PSOCK nodes in parallel
[16:09:34.080] List of 36
[16:09:34.080]  $ worker          : chr "localhost"
[16:09:34.080]   ..- attr(*, "localhost")= logi TRUE
[16:09:34.080]  $ master          : chr "localhost"
[16:09:34.080]  $ port            : int 11680
[16:09:34.080]  $ connectTimeout  : num 120
[16:09:34.080]  $ timeout         : num 2592000
[16:09:34.080]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:09:34.080]  $ homogeneous     : logi TRUE
[16:09:34.080]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:09:34.080]  $ rscript_envs    : NULL
[16:09:34.080]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:09:34.080]  $ rscript_startup : NULL
[16:09:34.080]  $ rscript_sh      : chr "sh"
[16:09:34.080]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:09:34.080]  $ methods         : logi TRUE
[16:09:34.080]  $ socketOptions   : chr "no-delay"
[16:09:34.080]  $ useXDR          : logi FALSE
[16:09:34.080]  $ outfile         : chr "/dev/null"
[16:09:34.080]  $ renice          : int NA
[16:09:34.080]  $ rshcmd          : NULL
[16:09:34.080]  $ user            : chr(0) 
[16:09:34.080]  $ revtunnel       : logi FALSE
[16:09:34.080]  $ rshlogfile      : NULL
[16:09:34.080]  $ rshopts         : chr(0) 
[16:09:34.080]  $ rank            : int 1
[16:09:34.080]  $ manual          : logi FALSE
[16:09:34.080]  $ dryrun          : logi FALSE
[16:09:34.080]  $ quiet           : logi FALSE
[16:09:34.080]  $ setup_strategy  : chr "parallel"
[16:09:34.080]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:09:34.080]  $ pidfile         : chr "/tmp/RtmpauWMCG/worker.rank=1.parallelly.parent=69210.10e5a2da87525.pid"
[16:09:34.080]  $ rshcmd_label    : NULL
[16:09:34.080]  $ rsh_call        : NULL
[16:09:34.080]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:09:34.080]  $ localMachine    : logi TRUE
[16:09:34.080]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:09:34.080]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:09:34.080]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:09:34.080]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:09:34.080]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:09:34.080]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:09:34.080]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:09:34.080]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:09:34.080]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:09:34.080]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:09:34.080]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:09:34.080]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:09:34.080]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:09:34.080]  $ arguments       :List of 28
[16:09:34.080]   ..$ worker          : chr "localhost"
[16:09:34.080]   ..$ master          : NULL
[16:09:34.080]   ..$ port            : int 11680
[16:09:34.080]   ..$ connectTimeout  : num 120
[16:09:34.080]   ..$ timeout         : num 2592000
[16:09:34.080]   ..$ rscript         : NULL
[16:09:34.080]   ..$ homogeneous     : NULL
[16:09:34.080]   ..$ rscript_args    : NULL
[16:09:34.080]   ..$ rscript_envs    : NULL
[16:09:34.080]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:09:34.080]   ..$ rscript_startup : NULL
[16:09:34.080]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:09:34.080]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:09:34.080]   ..$ methods         : logi TRUE
[16:09:34.080]   ..$ socketOptions   : chr "no-delay"
[16:09:34.080]   ..$ useXDR          : logi FALSE
[16:09:34.080]   ..$ outfile         : chr "/dev/null"
[16:09:34.080]   ..$ renice          : int NA
[16:09:34.080]   ..$ rshcmd          : NULL
[16:09:34.080]   ..$ user            : NULL
[16:09:34.080]   ..$ revtunnel       : logi NA
[16:09:34.080]   ..$ rshlogfile      : NULL
[16:09:34.080]   ..$ rshopts         : NULL
[16:09:34.080]   ..$ rank            : int 1
[16:09:34.080]   ..$ manual          : logi FALSE
[16:09:34.080]   ..$ dryrun          : logi FALSE
[16:09:34.080]   ..$ quiet           : logi FALSE
[16:09:34.080]   ..$ setup_strategy  : chr "parallel"
[16:09:34.080]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:09:34.096] [local output] System call to launch all workers:
[16:09:34.096] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpauWMCG/worker.rank=1.parallelly.parent=69210.10e5a2da87525.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11680 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:09:34.096] [local output] Starting PSOCK main server
[16:09:34.098] [local output] Workers launched
[16:09:34.098] [local output] Waiting for workers to connect back
[16:09:34.098]  - [local output] 0 workers out of 2 ready
[16:09:34.342]  - [local output] 0 workers out of 2 ready
[16:09:34.343]  - [local output] 1 workers out of 2 ready
[16:09:34.343]  - [local output] 2 workers out of 2 ready
[16:09:34.343] [local output] Launching of workers completed
[16:09:34.343] [local output] Collecting session information from workers
[16:09:34.344] [local output]  - Worker #1 of 2
[16:09:34.344] [local output]  - Worker #2 of 2
[16:09:34.345] [local output] makeClusterPSOCK() ... done
[16:09:34.356] Packages needed by the future expression (n = 0): <none>
[16:09:34.356] Packages needed by future strategies (n = 0): <none>
[16:09:34.357] {
[16:09:34.357]     {
[16:09:34.357]         {
[16:09:34.357]             ...future.startTime <- base::Sys.time()
[16:09:34.357]             {
[16:09:34.357]                 {
[16:09:34.357]                   {
[16:09:34.357]                     {
[16:09:34.357]                       base::local({
[16:09:34.357]                         has_future <- base::requireNamespace("future", 
[16:09:34.357]                           quietly = TRUE)
[16:09:34.357]                         if (has_future) {
[16:09:34.357]                           ns <- base::getNamespace("future")
[16:09:34.357]                           version <- ns[[".package"]][["version"]]
[16:09:34.357]                           if (is.null(version)) 
[16:09:34.357]                             version <- utils::packageVersion("future")
[16:09:34.357]                         }
[16:09:34.357]                         else {
[16:09:34.357]                           version <- NULL
[16:09:34.357]                         }
[16:09:34.357]                         if (!has_future || version < "1.8.0") {
[16:09:34.357]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.357]                             "", base::R.version$version.string), 
[16:09:34.357]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:34.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:34.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.357]                               "release", "version")], collapse = " "), 
[16:09:34.357]                             hostname = base::Sys.info()[["nodename"]])
[16:09:34.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.357]                             info)
[16:09:34.357]                           info <- base::paste(info, collapse = "; ")
[16:09:34.357]                           if (!has_future) {
[16:09:34.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.357]                               info)
[16:09:34.357]                           }
[16:09:34.357]                           else {
[16:09:34.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.357]                               info, version)
[16:09:34.357]                           }
[16:09:34.357]                           base::stop(msg)
[16:09:34.357]                         }
[16:09:34.357]                       })
[16:09:34.357]                     }
[16:09:34.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.357]                     base::options(mc.cores = 1L)
[16:09:34.357]                   }
[16:09:34.357]                   options(future.plan = NULL)
[16:09:34.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.357]                 }
[16:09:34.357]                 ...future.workdir <- getwd()
[16:09:34.357]             }
[16:09:34.357]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.357]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.357]         }
[16:09:34.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:34.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.357]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.357]             base::names(...future.oldOptions))
[16:09:34.357]     }
[16:09:34.357]     if (FALSE) {
[16:09:34.357]     }
[16:09:34.357]     else {
[16:09:34.357]         if (TRUE) {
[16:09:34.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.357]                 open = "w")
[16:09:34.357]         }
[16:09:34.357]         else {
[16:09:34.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.357]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.357]         }
[16:09:34.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.357]             base::sink(type = "output", split = FALSE)
[16:09:34.357]             base::close(...future.stdout)
[16:09:34.357]         }, add = TRUE)
[16:09:34.357]     }
[16:09:34.357]     ...future.frame <- base::sys.nframe()
[16:09:34.357]     ...future.conditions <- base::list()
[16:09:34.357]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.357]     if (FALSE) {
[16:09:34.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.357]     }
[16:09:34.357]     ...future.result <- base::tryCatch({
[16:09:34.357]         base::withCallingHandlers({
[16:09:34.357]             ...future.value <- base::withVisible(base::local({
[16:09:34.357]                 ...future.makeSendCondition <- local({
[16:09:34.357]                   sendCondition <- NULL
[16:09:34.357]                   function(frame = 1L) {
[16:09:34.357]                     if (is.function(sendCondition)) 
[16:09:34.357]                       return(sendCondition)
[16:09:34.357]                     ns <- getNamespace("parallel")
[16:09:34.357]                     if (exists("sendData", mode = "function", 
[16:09:34.357]                       envir = ns)) {
[16:09:34.357]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.357]                         envir = ns)
[16:09:34.357]                       envir <- sys.frame(frame)
[16:09:34.357]                       master <- NULL
[16:09:34.357]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.357]                         !identical(envir, emptyenv())) {
[16:09:34.357]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.357]                           inherits = FALSE)) {
[16:09:34.357]                           master <- get("master", mode = "list", 
[16:09:34.357]                             envir = envir, inherits = FALSE)
[16:09:34.357]                           if (inherits(master, c("SOCKnode", 
[16:09:34.357]                             "SOCK0node"))) {
[16:09:34.357]                             sendCondition <<- function(cond) {
[16:09:34.357]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.357]                                 success = TRUE)
[16:09:34.357]                               parallel_sendData(master, data)
[16:09:34.357]                             }
[16:09:34.357]                             return(sendCondition)
[16:09:34.357]                           }
[16:09:34.357]                         }
[16:09:34.357]                         frame <- frame + 1L
[16:09:34.357]                         envir <- sys.frame(frame)
[16:09:34.357]                       }
[16:09:34.357]                     }
[16:09:34.357]                     sendCondition <<- function(cond) NULL
[16:09:34.357]                   }
[16:09:34.357]                 })
[16:09:34.357]                 withCallingHandlers({
[16:09:34.357]                   NA
[16:09:34.357]                 }, immediateCondition = function(cond) {
[16:09:34.357]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.357]                   sendCondition(cond)
[16:09:34.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.357]                   {
[16:09:34.357]                     inherits <- base::inherits
[16:09:34.357]                     invokeRestart <- base::invokeRestart
[16:09:34.357]                     is.null <- base::is.null
[16:09:34.357]                     muffled <- FALSE
[16:09:34.357]                     if (inherits(cond, "message")) {
[16:09:34.357]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.357]                       if (muffled) 
[16:09:34.357]                         invokeRestart("muffleMessage")
[16:09:34.357]                     }
[16:09:34.357]                     else if (inherits(cond, "warning")) {
[16:09:34.357]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.357]                       if (muffled) 
[16:09:34.357]                         invokeRestart("muffleWarning")
[16:09:34.357]                     }
[16:09:34.357]                     else if (inherits(cond, "condition")) {
[16:09:34.357]                       if (!is.null(pattern)) {
[16:09:34.357]                         computeRestarts <- base::computeRestarts
[16:09:34.357]                         grepl <- base::grepl
[16:09:34.357]                         restarts <- computeRestarts(cond)
[16:09:34.357]                         for (restart in restarts) {
[16:09:34.357]                           name <- restart$name
[16:09:34.357]                           if (is.null(name)) 
[16:09:34.357]                             next
[16:09:34.357]                           if (!grepl(pattern, name)) 
[16:09:34.357]                             next
[16:09:34.357]                           invokeRestart(restart)
[16:09:34.357]                           muffled <- TRUE
[16:09:34.357]                           break
[16:09:34.357]                         }
[16:09:34.357]                       }
[16:09:34.357]                     }
[16:09:34.357]                     invisible(muffled)
[16:09:34.357]                   }
[16:09:34.357]                   muffleCondition(cond)
[16:09:34.357]                 })
[16:09:34.357]             }))
[16:09:34.357]             future::FutureResult(value = ...future.value$value, 
[16:09:34.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.357]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.357]                     ...future.globalenv.names))
[16:09:34.357]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.357]         }, condition = base::local({
[16:09:34.357]             c <- base::c
[16:09:34.357]             inherits <- base::inherits
[16:09:34.357]             invokeRestart <- base::invokeRestart
[16:09:34.357]             length <- base::length
[16:09:34.357]             list <- base::list
[16:09:34.357]             seq.int <- base::seq.int
[16:09:34.357]             signalCondition <- base::signalCondition
[16:09:34.357]             sys.calls <- base::sys.calls
[16:09:34.357]             `[[` <- base::`[[`
[16:09:34.357]             `+` <- base::`+`
[16:09:34.357]             `<<-` <- base::`<<-`
[16:09:34.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.357]                   3L)]
[16:09:34.357]             }
[16:09:34.357]             function(cond) {
[16:09:34.357]                 is_error <- inherits(cond, "error")
[16:09:34.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.357]                   NULL)
[16:09:34.357]                 if (is_error) {
[16:09:34.357]                   sessionInformation <- function() {
[16:09:34.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.357]                       search = base::search(), system = base::Sys.info())
[16:09:34.357]                   }
[16:09:34.357]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.357]                     cond$call), session = sessionInformation(), 
[16:09:34.357]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.357]                   signalCondition(cond)
[16:09:34.357]                 }
[16:09:34.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.357]                 "immediateCondition"))) {
[16:09:34.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.357]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.357]                   if (TRUE && !signal) {
[16:09:34.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.357]                     {
[16:09:34.357]                       inherits <- base::inherits
[16:09:34.357]                       invokeRestart <- base::invokeRestart
[16:09:34.357]                       is.null <- base::is.null
[16:09:34.357]                       muffled <- FALSE
[16:09:34.357]                       if (inherits(cond, "message")) {
[16:09:34.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.357]                         if (muffled) 
[16:09:34.357]                           invokeRestart("muffleMessage")
[16:09:34.357]                       }
[16:09:34.357]                       else if (inherits(cond, "warning")) {
[16:09:34.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.357]                         if (muffled) 
[16:09:34.357]                           invokeRestart("muffleWarning")
[16:09:34.357]                       }
[16:09:34.357]                       else if (inherits(cond, "condition")) {
[16:09:34.357]                         if (!is.null(pattern)) {
[16:09:34.357]                           computeRestarts <- base::computeRestarts
[16:09:34.357]                           grepl <- base::grepl
[16:09:34.357]                           restarts <- computeRestarts(cond)
[16:09:34.357]                           for (restart in restarts) {
[16:09:34.357]                             name <- restart$name
[16:09:34.357]                             if (is.null(name)) 
[16:09:34.357]                               next
[16:09:34.357]                             if (!grepl(pattern, name)) 
[16:09:34.357]                               next
[16:09:34.357]                             invokeRestart(restart)
[16:09:34.357]                             muffled <- TRUE
[16:09:34.357]                             break
[16:09:34.357]                           }
[16:09:34.357]                         }
[16:09:34.357]                       }
[16:09:34.357]                       invisible(muffled)
[16:09:34.357]                     }
[16:09:34.357]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.357]                   }
[16:09:34.357]                 }
[16:09:34.357]                 else {
[16:09:34.357]                   if (TRUE) {
[16:09:34.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.357]                     {
[16:09:34.357]                       inherits <- base::inherits
[16:09:34.357]                       invokeRestart <- base::invokeRestart
[16:09:34.357]                       is.null <- base::is.null
[16:09:34.357]                       muffled <- FALSE
[16:09:34.357]                       if (inherits(cond, "message")) {
[16:09:34.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.357]                         if (muffled) 
[16:09:34.357]                           invokeRestart("muffleMessage")
[16:09:34.357]                       }
[16:09:34.357]                       else if (inherits(cond, "warning")) {
[16:09:34.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.357]                         if (muffled) 
[16:09:34.357]                           invokeRestart("muffleWarning")
[16:09:34.357]                       }
[16:09:34.357]                       else if (inherits(cond, "condition")) {
[16:09:34.357]                         if (!is.null(pattern)) {
[16:09:34.357]                           computeRestarts <- base::computeRestarts
[16:09:34.357]                           grepl <- base::grepl
[16:09:34.357]                           restarts <- computeRestarts(cond)
[16:09:34.357]                           for (restart in restarts) {
[16:09:34.357]                             name <- restart$name
[16:09:34.357]                             if (is.null(name)) 
[16:09:34.357]                               next
[16:09:34.357]                             if (!grepl(pattern, name)) 
[16:09:34.357]                               next
[16:09:34.357]                             invokeRestart(restart)
[16:09:34.357]                             muffled <- TRUE
[16:09:34.357]                             break
[16:09:34.357]                           }
[16:09:34.357]                         }
[16:09:34.357]                       }
[16:09:34.357]                       invisible(muffled)
[16:09:34.357]                     }
[16:09:34.357]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.357]                   }
[16:09:34.357]                 }
[16:09:34.357]             }
[16:09:34.357]         }))
[16:09:34.357]     }, error = function(ex) {
[16:09:34.357]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.357]                 ...future.rng), started = ...future.startTime, 
[16:09:34.357]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.357]             version = "1.8"), class = "FutureResult")
[16:09:34.357]     }, finally = {
[16:09:34.357]         if (!identical(...future.workdir, getwd())) 
[16:09:34.357]             setwd(...future.workdir)
[16:09:34.357]         {
[16:09:34.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.357]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.357]             }
[16:09:34.357]             base::options(...future.oldOptions)
[16:09:34.357]             if (.Platform$OS.type == "windows") {
[16:09:34.357]                 old_names <- names(...future.oldEnvVars)
[16:09:34.357]                 envs <- base::Sys.getenv()
[16:09:34.357]                 names <- names(envs)
[16:09:34.357]                 common <- intersect(names, old_names)
[16:09:34.357]                 added <- setdiff(names, old_names)
[16:09:34.357]                 removed <- setdiff(old_names, names)
[16:09:34.357]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.357]                   envs[common]]
[16:09:34.357]                 NAMES <- toupper(changed)
[16:09:34.357]                 args <- list()
[16:09:34.357]                 for (kk in seq_along(NAMES)) {
[16:09:34.357]                   name <- changed[[kk]]
[16:09:34.357]                   NAME <- NAMES[[kk]]
[16:09:34.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.357]                     next
[16:09:34.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.357]                 }
[16:09:34.357]                 NAMES <- toupper(added)
[16:09:34.357]                 for (kk in seq_along(NAMES)) {
[16:09:34.357]                   name <- added[[kk]]
[16:09:34.357]                   NAME <- NAMES[[kk]]
[16:09:34.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.357]                     next
[16:09:34.357]                   args[[name]] <- ""
[16:09:34.357]                 }
[16:09:34.357]                 NAMES <- toupper(removed)
[16:09:34.357]                 for (kk in seq_along(NAMES)) {
[16:09:34.357]                   name <- removed[[kk]]
[16:09:34.357]                   NAME <- NAMES[[kk]]
[16:09:34.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.357]                     next
[16:09:34.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.357]                 }
[16:09:34.357]                 if (length(args) > 0) 
[16:09:34.357]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.357]             }
[16:09:34.357]             else {
[16:09:34.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.357]             }
[16:09:34.357]             {
[16:09:34.357]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.357]                   0L) {
[16:09:34.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.357]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.357]                   base::options(opts)
[16:09:34.357]                 }
[16:09:34.357]                 {
[16:09:34.357]                   {
[16:09:34.357]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.357]                     NULL
[16:09:34.357]                   }
[16:09:34.357]                   options(future.plan = NULL)
[16:09:34.357]                   if (is.na(NA_character_)) 
[16:09:34.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.357]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.357]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.357]                     envir = parent.frame()) 
[16:09:34.357]                   {
[16:09:34.357]                     if (is.function(workers)) 
[16:09:34.357]                       workers <- workers()
[16:09:34.357]                     workers <- structure(as.integer(workers), 
[16:09:34.357]                       class = class(workers))
[16:09:34.357]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.357]                       workers >= 1)
[16:09:34.357]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.357]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.357]                     }
[16:09:34.357]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.357]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.357]                       envir = envir)
[16:09:34.357]                     if (!future$lazy) 
[16:09:34.357]                       future <- run(future)
[16:09:34.357]                     invisible(future)
[16:09:34.357]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.357]                 }
[16:09:34.357]             }
[16:09:34.357]         }
[16:09:34.357]     })
[16:09:34.357]     if (TRUE) {
[16:09:34.357]         base::sink(type = "output", split = FALSE)
[16:09:34.357]         if (TRUE) {
[16:09:34.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.357]         }
[16:09:34.357]         else {
[16:09:34.357]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.357]         }
[16:09:34.357]         base::close(...future.stdout)
[16:09:34.357]         ...future.stdout <- NULL
[16:09:34.357]     }
[16:09:34.357]     ...future.result$conditions <- ...future.conditions
[16:09:34.357]     ...future.result$finished <- base::Sys.time()
[16:09:34.357]     ...future.result
[16:09:34.357] }
[16:09:34.427] MultisessionFuture started
[16:09:34.427] result() for ClusterFuture ...
[16:09:34.428] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.428] - Validating connection of MultisessionFuture
[16:09:34.460] - received message: FutureResult
[16:09:34.461] - Received FutureResult
[16:09:34.461] - Erased future from FutureRegistry
[16:09:34.461] result() for ClusterFuture ...
[16:09:34.461] - result already collected: FutureResult
[16:09:34.461] result() for ClusterFuture ... done
[16:09:34.461] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.461] result() for ClusterFuture ... done
[16:09:34.461] result() for ClusterFuture ...
[16:09:34.461] - result already collected: FutureResult
[16:09:34.461] result() for ClusterFuture ... done
[16:09:34.462] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:09:34.465] plan(): nbrOfWorkers() = 2
[16:09:34.465] future_by_internal() ...
[16:09:34.466] future_lapply() ...
[16:09:34.469] Number of chunks: 2
[16:09:34.469] getGlobalsAndPackagesXApply() ...
[16:09:34.470]  - future.globals: TRUE
[16:09:34.470] getGlobalsAndPackages() ...
[16:09:34.470] Searching for globals...
[16:09:34.471] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:34.471] Searching for globals ... DONE
[16:09:34.471] Resolving globals: FALSE
[16:09:34.471] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:34.472] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:34.472] - globals: [1] ‘FUN’
[16:09:34.472] 
[16:09:34.472] getGlobalsAndPackages() ... DONE
[16:09:34.472]  - globals found/used: [n=1] ‘FUN’
[16:09:34.472]  - needed namespaces: [n=0] 
[16:09:34.472] Finding globals ... DONE
[16:09:34.472]  - use_args: TRUE
[16:09:34.472]  - Getting '...' globals ...
[16:09:34.473] resolve() on list ...
[16:09:34.473]  recursive: 0
[16:09:34.473]  length: 1
[16:09:34.473]  elements: ‘...’
[16:09:34.473]  length: 0 (resolved future 1)
[16:09:34.473] resolve() on list ... DONE
[16:09:34.473]    - '...' content: [n=0] 
[16:09:34.473] List of 1
[16:09:34.473]  $ ...: list()
[16:09:34.473]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:34.473]  - attr(*, "where")=List of 1
[16:09:34.473]   ..$ ...:<environment: 0x5567ea578b38> 
[16:09:34.473]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:34.473]  - attr(*, "resolved")= logi TRUE
[16:09:34.473]  - attr(*, "total_size")= num NA
[16:09:34.476]  - Getting '...' globals ... DONE
[16:09:34.476] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:34.476] List of 2
[16:09:34.476]  $ ...future.FUN:function (object, ...)  
[16:09:34.476]  $ ...          : list()
[16:09:34.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:34.476]  - attr(*, "where")=List of 2
[16:09:34.476]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:34.476]   ..$ ...          :<environment: 0x5567ea578b38> 
[16:09:34.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:34.476]  - attr(*, "resolved")= logi FALSE
[16:09:34.476]  - attr(*, "total_size")= num 1240
[16:09:34.479] Packages to be attached in all futures: [n=0] 
[16:09:34.479] getGlobalsAndPackagesXApply() ... DONE
[16:09:34.479] Number of futures (= number of chunks): 2
[16:09:34.479] Launching 2 futures (chunks) ...
[16:09:34.479] Chunk #1 of 2 ...
[16:09:34.479]  - Finding globals in 'X' for chunk #1 ...
[16:09:34.479] getGlobalsAndPackages() ...
[16:09:34.479] Searching for globals...
[16:09:34.480] 
[16:09:34.480] Searching for globals ... DONE
[16:09:34.480] - globals: [0] <none>
[16:09:34.480] getGlobalsAndPackages() ... DONE
[16:09:34.480]    + additional globals found: [n=0] 
[16:09:34.480]    + additional namespaces needed: [n=0] 
[16:09:34.480]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:34.480]  - seeds: <none>
[16:09:34.480] getGlobalsAndPackages() ...
[16:09:34.481] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.481] Resolving globals: FALSE
[16:09:34.481] Tweak future expression to call with '...' arguments ...
[16:09:34.481] {
[16:09:34.481]     do.call(function(...) {
[16:09:34.481]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.481]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.481]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.481]             on.exit(options(oopts), add = TRUE)
[16:09:34.481]         }
[16:09:34.481]         {
[16:09:34.481]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.481]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.481]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.481]             })
[16:09:34.481]         }
[16:09:34.481]     }, args = future.call.arguments)
[16:09:34.481] }
[16:09:34.481] Tweak future expression to call with '...' arguments ... DONE
[16:09:34.481] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.482] 
[16:09:34.482] getGlobalsAndPackages() ... DONE
[16:09:34.482] run() for ‘Future’ ...
[16:09:34.482] - state: ‘created’
[16:09:34.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:34.496] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:34.496]   - Field: ‘node’
[16:09:34.496]   - Field: ‘label’
[16:09:34.497]   - Field: ‘local’
[16:09:34.497]   - Field: ‘owner’
[16:09:34.497]   - Field: ‘envir’
[16:09:34.497]   - Field: ‘workers’
[16:09:34.497]   - Field: ‘packages’
[16:09:34.497]   - Field: ‘gc’
[16:09:34.497]   - Field: ‘conditions’
[16:09:34.497]   - Field: ‘persistent’
[16:09:34.497]   - Field: ‘expr’
[16:09:34.497]   - Field: ‘uuid’
[16:09:34.497]   - Field: ‘seed’
[16:09:34.498]   - Field: ‘version’
[16:09:34.498]   - Field: ‘result’
[16:09:34.498]   - Field: ‘asynchronous’
[16:09:34.498]   - Field: ‘calls’
[16:09:34.498]   - Field: ‘globals’
[16:09:34.498]   - Field: ‘stdout’
[16:09:34.498]   - Field: ‘earlySignal’
[16:09:34.498]   - Field: ‘lazy’
[16:09:34.498]   - Field: ‘state’
[16:09:34.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:34.498] - Launch lazy future ...
[16:09:34.499] Packages needed by the future expression (n = 0): <none>
[16:09:34.499] Packages needed by future strategies (n = 0): <none>
[16:09:34.499] {
[16:09:34.499]     {
[16:09:34.499]         {
[16:09:34.499]             ...future.startTime <- base::Sys.time()
[16:09:34.499]             {
[16:09:34.499]                 {
[16:09:34.499]                   {
[16:09:34.499]                     {
[16:09:34.499]                       base::local({
[16:09:34.499]                         has_future <- base::requireNamespace("future", 
[16:09:34.499]                           quietly = TRUE)
[16:09:34.499]                         if (has_future) {
[16:09:34.499]                           ns <- base::getNamespace("future")
[16:09:34.499]                           version <- ns[[".package"]][["version"]]
[16:09:34.499]                           if (is.null(version)) 
[16:09:34.499]                             version <- utils::packageVersion("future")
[16:09:34.499]                         }
[16:09:34.499]                         else {
[16:09:34.499]                           version <- NULL
[16:09:34.499]                         }
[16:09:34.499]                         if (!has_future || version < "1.8.0") {
[16:09:34.499]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.499]                             "", base::R.version$version.string), 
[16:09:34.499]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:34.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:34.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.499]                               "release", "version")], collapse = " "), 
[16:09:34.499]                             hostname = base::Sys.info()[["nodename"]])
[16:09:34.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.499]                             info)
[16:09:34.499]                           info <- base::paste(info, collapse = "; ")
[16:09:34.499]                           if (!has_future) {
[16:09:34.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.499]                               info)
[16:09:34.499]                           }
[16:09:34.499]                           else {
[16:09:34.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.499]                               info, version)
[16:09:34.499]                           }
[16:09:34.499]                           base::stop(msg)
[16:09:34.499]                         }
[16:09:34.499]                       })
[16:09:34.499]                     }
[16:09:34.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.499]                     base::options(mc.cores = 1L)
[16:09:34.499]                   }
[16:09:34.499]                   options(future.plan = NULL)
[16:09:34.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.499]                 }
[16:09:34.499]                 ...future.workdir <- getwd()
[16:09:34.499]             }
[16:09:34.499]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.499]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.499]         }
[16:09:34.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:34.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.499]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.499]             base::names(...future.oldOptions))
[16:09:34.499]     }
[16:09:34.499]     if (FALSE) {
[16:09:34.499]     }
[16:09:34.499]     else {
[16:09:34.499]         if (TRUE) {
[16:09:34.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.499]                 open = "w")
[16:09:34.499]         }
[16:09:34.499]         else {
[16:09:34.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.499]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.499]         }
[16:09:34.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.499]             base::sink(type = "output", split = FALSE)
[16:09:34.499]             base::close(...future.stdout)
[16:09:34.499]         }, add = TRUE)
[16:09:34.499]     }
[16:09:34.499]     ...future.frame <- base::sys.nframe()
[16:09:34.499]     ...future.conditions <- base::list()
[16:09:34.499]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.499]     if (FALSE) {
[16:09:34.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.499]     }
[16:09:34.499]     ...future.result <- base::tryCatch({
[16:09:34.499]         base::withCallingHandlers({
[16:09:34.499]             ...future.value <- base::withVisible(base::local({
[16:09:34.499]                 ...future.makeSendCondition <- local({
[16:09:34.499]                   sendCondition <- NULL
[16:09:34.499]                   function(frame = 1L) {
[16:09:34.499]                     if (is.function(sendCondition)) 
[16:09:34.499]                       return(sendCondition)
[16:09:34.499]                     ns <- getNamespace("parallel")
[16:09:34.499]                     if (exists("sendData", mode = "function", 
[16:09:34.499]                       envir = ns)) {
[16:09:34.499]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.499]                         envir = ns)
[16:09:34.499]                       envir <- sys.frame(frame)
[16:09:34.499]                       master <- NULL
[16:09:34.499]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.499]                         !identical(envir, emptyenv())) {
[16:09:34.499]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.499]                           inherits = FALSE)) {
[16:09:34.499]                           master <- get("master", mode = "list", 
[16:09:34.499]                             envir = envir, inherits = FALSE)
[16:09:34.499]                           if (inherits(master, c("SOCKnode", 
[16:09:34.499]                             "SOCK0node"))) {
[16:09:34.499]                             sendCondition <<- function(cond) {
[16:09:34.499]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.499]                                 success = TRUE)
[16:09:34.499]                               parallel_sendData(master, data)
[16:09:34.499]                             }
[16:09:34.499]                             return(sendCondition)
[16:09:34.499]                           }
[16:09:34.499]                         }
[16:09:34.499]                         frame <- frame + 1L
[16:09:34.499]                         envir <- sys.frame(frame)
[16:09:34.499]                       }
[16:09:34.499]                     }
[16:09:34.499]                     sendCondition <<- function(cond) NULL
[16:09:34.499]                   }
[16:09:34.499]                 })
[16:09:34.499]                 withCallingHandlers({
[16:09:34.499]                   {
[16:09:34.499]                     do.call(function(...) {
[16:09:34.499]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.499]                       if (!identical(...future.globals.maxSize.org, 
[16:09:34.499]                         ...future.globals.maxSize)) {
[16:09:34.499]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.499]                         on.exit(options(oopts), add = TRUE)
[16:09:34.499]                       }
[16:09:34.499]                       {
[16:09:34.499]                         lapply(seq_along(...future.elements_ii), 
[16:09:34.499]                           FUN = function(jj) {
[16:09:34.499]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.499]                             ...future.FUN(...future.X_jj, ...)
[16:09:34.499]                           })
[16:09:34.499]                       }
[16:09:34.499]                     }, args = future.call.arguments)
[16:09:34.499]                   }
[16:09:34.499]                 }, immediateCondition = function(cond) {
[16:09:34.499]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.499]                   sendCondition(cond)
[16:09:34.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.499]                   {
[16:09:34.499]                     inherits <- base::inherits
[16:09:34.499]                     invokeRestart <- base::invokeRestart
[16:09:34.499]                     is.null <- base::is.null
[16:09:34.499]                     muffled <- FALSE
[16:09:34.499]                     if (inherits(cond, "message")) {
[16:09:34.499]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.499]                       if (muffled) 
[16:09:34.499]                         invokeRestart("muffleMessage")
[16:09:34.499]                     }
[16:09:34.499]                     else if (inherits(cond, "warning")) {
[16:09:34.499]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.499]                       if (muffled) 
[16:09:34.499]                         invokeRestart("muffleWarning")
[16:09:34.499]                     }
[16:09:34.499]                     else if (inherits(cond, "condition")) {
[16:09:34.499]                       if (!is.null(pattern)) {
[16:09:34.499]                         computeRestarts <- base::computeRestarts
[16:09:34.499]                         grepl <- base::grepl
[16:09:34.499]                         restarts <- computeRestarts(cond)
[16:09:34.499]                         for (restart in restarts) {
[16:09:34.499]                           name <- restart$name
[16:09:34.499]                           if (is.null(name)) 
[16:09:34.499]                             next
[16:09:34.499]                           if (!grepl(pattern, name)) 
[16:09:34.499]                             next
[16:09:34.499]                           invokeRestart(restart)
[16:09:34.499]                           muffled <- TRUE
[16:09:34.499]                           break
[16:09:34.499]                         }
[16:09:34.499]                       }
[16:09:34.499]                     }
[16:09:34.499]                     invisible(muffled)
[16:09:34.499]                   }
[16:09:34.499]                   muffleCondition(cond)
[16:09:34.499]                 })
[16:09:34.499]             }))
[16:09:34.499]             future::FutureResult(value = ...future.value$value, 
[16:09:34.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.499]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.499]                     ...future.globalenv.names))
[16:09:34.499]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.499]         }, condition = base::local({
[16:09:34.499]             c <- base::c
[16:09:34.499]             inherits <- base::inherits
[16:09:34.499]             invokeRestart <- base::invokeRestart
[16:09:34.499]             length <- base::length
[16:09:34.499]             list <- base::list
[16:09:34.499]             seq.int <- base::seq.int
[16:09:34.499]             signalCondition <- base::signalCondition
[16:09:34.499]             sys.calls <- base::sys.calls
[16:09:34.499]             `[[` <- base::`[[`
[16:09:34.499]             `+` <- base::`+`
[16:09:34.499]             `<<-` <- base::`<<-`
[16:09:34.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.499]                   3L)]
[16:09:34.499]             }
[16:09:34.499]             function(cond) {
[16:09:34.499]                 is_error <- inherits(cond, "error")
[16:09:34.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.499]                   NULL)
[16:09:34.499]                 if (is_error) {
[16:09:34.499]                   sessionInformation <- function() {
[16:09:34.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.499]                       search = base::search(), system = base::Sys.info())
[16:09:34.499]                   }
[16:09:34.499]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.499]                     cond$call), session = sessionInformation(), 
[16:09:34.499]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.499]                   signalCondition(cond)
[16:09:34.499]                 }
[16:09:34.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.499]                 "immediateCondition"))) {
[16:09:34.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.499]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.499]                   if (TRUE && !signal) {
[16:09:34.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.499]                     {
[16:09:34.499]                       inherits <- base::inherits
[16:09:34.499]                       invokeRestart <- base::invokeRestart
[16:09:34.499]                       is.null <- base::is.null
[16:09:34.499]                       muffled <- FALSE
[16:09:34.499]                       if (inherits(cond, "message")) {
[16:09:34.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.499]                         if (muffled) 
[16:09:34.499]                           invokeRestart("muffleMessage")
[16:09:34.499]                       }
[16:09:34.499]                       else if (inherits(cond, "warning")) {
[16:09:34.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.499]                         if (muffled) 
[16:09:34.499]                           invokeRestart("muffleWarning")
[16:09:34.499]                       }
[16:09:34.499]                       else if (inherits(cond, "condition")) {
[16:09:34.499]                         if (!is.null(pattern)) {
[16:09:34.499]                           computeRestarts <- base::computeRestarts
[16:09:34.499]                           grepl <- base::grepl
[16:09:34.499]                           restarts <- computeRestarts(cond)
[16:09:34.499]                           for (restart in restarts) {
[16:09:34.499]                             name <- restart$name
[16:09:34.499]                             if (is.null(name)) 
[16:09:34.499]                               next
[16:09:34.499]                             if (!grepl(pattern, name)) 
[16:09:34.499]                               next
[16:09:34.499]                             invokeRestart(restart)
[16:09:34.499]                             muffled <- TRUE
[16:09:34.499]                             break
[16:09:34.499]                           }
[16:09:34.499]                         }
[16:09:34.499]                       }
[16:09:34.499]                       invisible(muffled)
[16:09:34.499]                     }
[16:09:34.499]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.499]                   }
[16:09:34.499]                 }
[16:09:34.499]                 else {
[16:09:34.499]                   if (TRUE) {
[16:09:34.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.499]                     {
[16:09:34.499]                       inherits <- base::inherits
[16:09:34.499]                       invokeRestart <- base::invokeRestart
[16:09:34.499]                       is.null <- base::is.null
[16:09:34.499]                       muffled <- FALSE
[16:09:34.499]                       if (inherits(cond, "message")) {
[16:09:34.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.499]                         if (muffled) 
[16:09:34.499]                           invokeRestart("muffleMessage")
[16:09:34.499]                       }
[16:09:34.499]                       else if (inherits(cond, "warning")) {
[16:09:34.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.499]                         if (muffled) 
[16:09:34.499]                           invokeRestart("muffleWarning")
[16:09:34.499]                       }
[16:09:34.499]                       else if (inherits(cond, "condition")) {
[16:09:34.499]                         if (!is.null(pattern)) {
[16:09:34.499]                           computeRestarts <- base::computeRestarts
[16:09:34.499]                           grepl <- base::grepl
[16:09:34.499]                           restarts <- computeRestarts(cond)
[16:09:34.499]                           for (restart in restarts) {
[16:09:34.499]                             name <- restart$name
[16:09:34.499]                             if (is.null(name)) 
[16:09:34.499]                               next
[16:09:34.499]                             if (!grepl(pattern, name)) 
[16:09:34.499]                               next
[16:09:34.499]                             invokeRestart(restart)
[16:09:34.499]                             muffled <- TRUE
[16:09:34.499]                             break
[16:09:34.499]                           }
[16:09:34.499]                         }
[16:09:34.499]                       }
[16:09:34.499]                       invisible(muffled)
[16:09:34.499]                     }
[16:09:34.499]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.499]                   }
[16:09:34.499]                 }
[16:09:34.499]             }
[16:09:34.499]         }))
[16:09:34.499]     }, error = function(ex) {
[16:09:34.499]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.499]                 ...future.rng), started = ...future.startTime, 
[16:09:34.499]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.499]             version = "1.8"), class = "FutureResult")
[16:09:34.499]     }, finally = {
[16:09:34.499]         if (!identical(...future.workdir, getwd())) 
[16:09:34.499]             setwd(...future.workdir)
[16:09:34.499]         {
[16:09:34.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.499]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.499]             }
[16:09:34.499]             base::options(...future.oldOptions)
[16:09:34.499]             if (.Platform$OS.type == "windows") {
[16:09:34.499]                 old_names <- names(...future.oldEnvVars)
[16:09:34.499]                 envs <- base::Sys.getenv()
[16:09:34.499]                 names <- names(envs)
[16:09:34.499]                 common <- intersect(names, old_names)
[16:09:34.499]                 added <- setdiff(names, old_names)
[16:09:34.499]                 removed <- setdiff(old_names, names)
[16:09:34.499]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.499]                   envs[common]]
[16:09:34.499]                 NAMES <- toupper(changed)
[16:09:34.499]                 args <- list()
[16:09:34.499]                 for (kk in seq_along(NAMES)) {
[16:09:34.499]                   name <- changed[[kk]]
[16:09:34.499]                   NAME <- NAMES[[kk]]
[16:09:34.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.499]                     next
[16:09:34.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.499]                 }
[16:09:34.499]                 NAMES <- toupper(added)
[16:09:34.499]                 for (kk in seq_along(NAMES)) {
[16:09:34.499]                   name <- added[[kk]]
[16:09:34.499]                   NAME <- NAMES[[kk]]
[16:09:34.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.499]                     next
[16:09:34.499]                   args[[name]] <- ""
[16:09:34.499]                 }
[16:09:34.499]                 NAMES <- toupper(removed)
[16:09:34.499]                 for (kk in seq_along(NAMES)) {
[16:09:34.499]                   name <- removed[[kk]]
[16:09:34.499]                   NAME <- NAMES[[kk]]
[16:09:34.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.499]                     next
[16:09:34.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.499]                 }
[16:09:34.499]                 if (length(args) > 0) 
[16:09:34.499]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.499]             }
[16:09:34.499]             else {
[16:09:34.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.499]             }
[16:09:34.499]             {
[16:09:34.499]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.499]                   0L) {
[16:09:34.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.499]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.499]                   base::options(opts)
[16:09:34.499]                 }
[16:09:34.499]                 {
[16:09:34.499]                   {
[16:09:34.499]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.499]                     NULL
[16:09:34.499]                   }
[16:09:34.499]                   options(future.plan = NULL)
[16:09:34.499]                   if (is.na(NA_character_)) 
[16:09:34.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.499]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.499]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.499]                     envir = parent.frame()) 
[16:09:34.499]                   {
[16:09:34.499]                     if (is.function(workers)) 
[16:09:34.499]                       workers <- workers()
[16:09:34.499]                     workers <- structure(as.integer(workers), 
[16:09:34.499]                       class = class(workers))
[16:09:34.499]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.499]                       workers >= 1)
[16:09:34.499]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.499]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.499]                     }
[16:09:34.499]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.499]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.499]                       envir = envir)
[16:09:34.499]                     if (!future$lazy) 
[16:09:34.499]                       future <- run(future)
[16:09:34.499]                     invisible(future)
[16:09:34.499]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.499]                 }
[16:09:34.499]             }
[16:09:34.499]         }
[16:09:34.499]     })
[16:09:34.499]     if (TRUE) {
[16:09:34.499]         base::sink(type = "output", split = FALSE)
[16:09:34.499]         if (TRUE) {
[16:09:34.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.499]         }
[16:09:34.499]         else {
[16:09:34.499]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.499]         }
[16:09:34.499]         base::close(...future.stdout)
[16:09:34.499]         ...future.stdout <- NULL
[16:09:34.499]     }
[16:09:34.499]     ...future.result$conditions <- ...future.conditions
[16:09:34.499]     ...future.result$finished <- base::Sys.time()
[16:09:34.499]     ...future.result
[16:09:34.499] }
[16:09:34.502] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:09:34.502] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:09:34.503] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:09:34.503] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:34.503] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.504] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[16:09:34.504] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[16:09:34.504] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:34.505] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.505] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:34.505] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.505] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:09:34.506] MultisessionFuture started
[16:09:34.506] - Launch lazy future ... done
[16:09:34.506] run() for ‘MultisessionFuture’ ... done
[16:09:34.506] Created future:
[16:09:34.506] MultisessionFuture:
[16:09:34.506] Label: ‘future_by-1’
[16:09:34.506] Expression:
[16:09:34.506] {
[16:09:34.506]     do.call(function(...) {
[16:09:34.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.506]             on.exit(options(oopts), add = TRUE)
[16:09:34.506]         }
[16:09:34.506]         {
[16:09:34.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.506]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.506]             })
[16:09:34.506]         }
[16:09:34.506]     }, args = future.call.arguments)
[16:09:34.506] }
[16:09:34.506] Lazy evaluation: FALSE
[16:09:34.506] Asynchronous evaluation: TRUE
[16:09:34.506] Local evaluation: TRUE
[16:09:34.506] Environment: R_GlobalEnv
[16:09:34.506] Capture standard output: TRUE
[16:09:34.506] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:34.506] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:34.506] Packages: <none>
[16:09:34.506] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:34.506] Resolved: FALSE
[16:09:34.506] Value: <not collected>
[16:09:34.506] Conditions captured: <none>
[16:09:34.506] Early signaling: FALSE
[16:09:34.506] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:34.506] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.518] Chunk #1 of 2 ... DONE
[16:09:34.519] Chunk #2 of 2 ...
[16:09:34.519]  - Finding globals in 'X' for chunk #2 ...
[16:09:34.519] getGlobalsAndPackages() ...
[16:09:34.519] Searching for globals...
[16:09:34.519] 
[16:09:34.519] Searching for globals ... DONE
[16:09:34.519] - globals: [0] <none>
[16:09:34.520] getGlobalsAndPackages() ... DONE
[16:09:34.520]    + additional globals found: [n=0] 
[16:09:34.520]    + additional namespaces needed: [n=0] 
[16:09:34.520]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:34.520]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:34.520]  - seeds: <none>
[16:09:34.520] getGlobalsAndPackages() ...
[16:09:34.520] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.520] Resolving globals: FALSE
[16:09:34.521] Tweak future expression to call with '...' arguments ...
[16:09:34.521] {
[16:09:34.521]     do.call(function(...) {
[16:09:34.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.521]             on.exit(options(oopts), add = TRUE)
[16:09:34.521]         }
[16:09:34.521]         {
[16:09:34.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.521]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.521]             })
[16:09:34.521]         }
[16:09:34.521]     }, args = future.call.arguments)
[16:09:34.521] }
[16:09:34.521] Tweak future expression to call with '...' arguments ... DONE
[16:09:34.521] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.521] 
[16:09:34.521] getGlobalsAndPackages() ... DONE
[16:09:34.522] run() for ‘Future’ ...
[16:09:34.522] - state: ‘created’
[16:09:34.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:34.537] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:34.538]   - Field: ‘node’
[16:09:34.538]   - Field: ‘label’
[16:09:34.538]   - Field: ‘local’
[16:09:34.538]   - Field: ‘owner’
[16:09:34.538]   - Field: ‘envir’
[16:09:34.538]   - Field: ‘workers’
[16:09:34.538]   - Field: ‘packages’
[16:09:34.538]   - Field: ‘gc’
[16:09:34.538]   - Field: ‘conditions’
[16:09:34.539]   - Field: ‘persistent’
[16:09:34.539]   - Field: ‘expr’
[16:09:34.539]   - Field: ‘uuid’
[16:09:34.539]   - Field: ‘seed’
[16:09:34.539]   - Field: ‘version’
[16:09:34.539]   - Field: ‘result’
[16:09:34.539]   - Field: ‘asynchronous’
[16:09:34.539]   - Field: ‘calls’
[16:09:34.539]   - Field: ‘globals’
[16:09:34.539]   - Field: ‘stdout’
[16:09:34.539]   - Field: ‘earlySignal’
[16:09:34.540]   - Field: ‘lazy’
[16:09:34.540]   - Field: ‘state’
[16:09:34.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:34.540] - Launch lazy future ...
[16:09:34.540] Packages needed by the future expression (n = 0): <none>
[16:09:34.540] Packages needed by future strategies (n = 0): <none>
[16:09:34.541] {
[16:09:34.541]     {
[16:09:34.541]         {
[16:09:34.541]             ...future.startTime <- base::Sys.time()
[16:09:34.541]             {
[16:09:34.541]                 {
[16:09:34.541]                   {
[16:09:34.541]                     {
[16:09:34.541]                       base::local({
[16:09:34.541]                         has_future <- base::requireNamespace("future", 
[16:09:34.541]                           quietly = TRUE)
[16:09:34.541]                         if (has_future) {
[16:09:34.541]                           ns <- base::getNamespace("future")
[16:09:34.541]                           version <- ns[[".package"]][["version"]]
[16:09:34.541]                           if (is.null(version)) 
[16:09:34.541]                             version <- utils::packageVersion("future")
[16:09:34.541]                         }
[16:09:34.541]                         else {
[16:09:34.541]                           version <- NULL
[16:09:34.541]                         }
[16:09:34.541]                         if (!has_future || version < "1.8.0") {
[16:09:34.541]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.541]                             "", base::R.version$version.string), 
[16:09:34.541]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:34.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:34.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.541]                               "release", "version")], collapse = " "), 
[16:09:34.541]                             hostname = base::Sys.info()[["nodename"]])
[16:09:34.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.541]                             info)
[16:09:34.541]                           info <- base::paste(info, collapse = "; ")
[16:09:34.541]                           if (!has_future) {
[16:09:34.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.541]                               info)
[16:09:34.541]                           }
[16:09:34.541]                           else {
[16:09:34.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.541]                               info, version)
[16:09:34.541]                           }
[16:09:34.541]                           base::stop(msg)
[16:09:34.541]                         }
[16:09:34.541]                       })
[16:09:34.541]                     }
[16:09:34.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.541]                     base::options(mc.cores = 1L)
[16:09:34.541]                   }
[16:09:34.541]                   options(future.plan = NULL)
[16:09:34.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.541]                 }
[16:09:34.541]                 ...future.workdir <- getwd()
[16:09:34.541]             }
[16:09:34.541]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.541]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.541]         }
[16:09:34.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.541]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:34.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.541]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.541]             base::names(...future.oldOptions))
[16:09:34.541]     }
[16:09:34.541]     if (FALSE) {
[16:09:34.541]     }
[16:09:34.541]     else {
[16:09:34.541]         if (TRUE) {
[16:09:34.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.541]                 open = "w")
[16:09:34.541]         }
[16:09:34.541]         else {
[16:09:34.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.541]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.541]         }
[16:09:34.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.541]             base::sink(type = "output", split = FALSE)
[16:09:34.541]             base::close(...future.stdout)
[16:09:34.541]         }, add = TRUE)
[16:09:34.541]     }
[16:09:34.541]     ...future.frame <- base::sys.nframe()
[16:09:34.541]     ...future.conditions <- base::list()
[16:09:34.541]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.541]     if (FALSE) {
[16:09:34.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.541]     }
[16:09:34.541]     ...future.result <- base::tryCatch({
[16:09:34.541]         base::withCallingHandlers({
[16:09:34.541]             ...future.value <- base::withVisible(base::local({
[16:09:34.541]                 ...future.makeSendCondition <- local({
[16:09:34.541]                   sendCondition <- NULL
[16:09:34.541]                   function(frame = 1L) {
[16:09:34.541]                     if (is.function(sendCondition)) 
[16:09:34.541]                       return(sendCondition)
[16:09:34.541]                     ns <- getNamespace("parallel")
[16:09:34.541]                     if (exists("sendData", mode = "function", 
[16:09:34.541]                       envir = ns)) {
[16:09:34.541]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.541]                         envir = ns)
[16:09:34.541]                       envir <- sys.frame(frame)
[16:09:34.541]                       master <- NULL
[16:09:34.541]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.541]                         !identical(envir, emptyenv())) {
[16:09:34.541]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.541]                           inherits = FALSE)) {
[16:09:34.541]                           master <- get("master", mode = "list", 
[16:09:34.541]                             envir = envir, inherits = FALSE)
[16:09:34.541]                           if (inherits(master, c("SOCKnode", 
[16:09:34.541]                             "SOCK0node"))) {
[16:09:34.541]                             sendCondition <<- function(cond) {
[16:09:34.541]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.541]                                 success = TRUE)
[16:09:34.541]                               parallel_sendData(master, data)
[16:09:34.541]                             }
[16:09:34.541]                             return(sendCondition)
[16:09:34.541]                           }
[16:09:34.541]                         }
[16:09:34.541]                         frame <- frame + 1L
[16:09:34.541]                         envir <- sys.frame(frame)
[16:09:34.541]                       }
[16:09:34.541]                     }
[16:09:34.541]                     sendCondition <<- function(cond) NULL
[16:09:34.541]                   }
[16:09:34.541]                 })
[16:09:34.541]                 withCallingHandlers({
[16:09:34.541]                   {
[16:09:34.541]                     do.call(function(...) {
[16:09:34.541]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.541]                       if (!identical(...future.globals.maxSize.org, 
[16:09:34.541]                         ...future.globals.maxSize)) {
[16:09:34.541]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.541]                         on.exit(options(oopts), add = TRUE)
[16:09:34.541]                       }
[16:09:34.541]                       {
[16:09:34.541]                         lapply(seq_along(...future.elements_ii), 
[16:09:34.541]                           FUN = function(jj) {
[16:09:34.541]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.541]                             ...future.FUN(...future.X_jj, ...)
[16:09:34.541]                           })
[16:09:34.541]                       }
[16:09:34.541]                     }, args = future.call.arguments)
[16:09:34.541]                   }
[16:09:34.541]                 }, immediateCondition = function(cond) {
[16:09:34.541]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.541]                   sendCondition(cond)
[16:09:34.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.541]                   {
[16:09:34.541]                     inherits <- base::inherits
[16:09:34.541]                     invokeRestart <- base::invokeRestart
[16:09:34.541]                     is.null <- base::is.null
[16:09:34.541]                     muffled <- FALSE
[16:09:34.541]                     if (inherits(cond, "message")) {
[16:09:34.541]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.541]                       if (muffled) 
[16:09:34.541]                         invokeRestart("muffleMessage")
[16:09:34.541]                     }
[16:09:34.541]                     else if (inherits(cond, "warning")) {
[16:09:34.541]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.541]                       if (muffled) 
[16:09:34.541]                         invokeRestart("muffleWarning")
[16:09:34.541]                     }
[16:09:34.541]                     else if (inherits(cond, "condition")) {
[16:09:34.541]                       if (!is.null(pattern)) {
[16:09:34.541]                         computeRestarts <- base::computeRestarts
[16:09:34.541]                         grepl <- base::grepl
[16:09:34.541]                         restarts <- computeRestarts(cond)
[16:09:34.541]                         for (restart in restarts) {
[16:09:34.541]                           name <- restart$name
[16:09:34.541]                           if (is.null(name)) 
[16:09:34.541]                             next
[16:09:34.541]                           if (!grepl(pattern, name)) 
[16:09:34.541]                             next
[16:09:34.541]                           invokeRestart(restart)
[16:09:34.541]                           muffled <- TRUE
[16:09:34.541]                           break
[16:09:34.541]                         }
[16:09:34.541]                       }
[16:09:34.541]                     }
[16:09:34.541]                     invisible(muffled)
[16:09:34.541]                   }
[16:09:34.541]                   muffleCondition(cond)
[16:09:34.541]                 })
[16:09:34.541]             }))
[16:09:34.541]             future::FutureResult(value = ...future.value$value, 
[16:09:34.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.541]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.541]                     ...future.globalenv.names))
[16:09:34.541]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.541]         }, condition = base::local({
[16:09:34.541]             c <- base::c
[16:09:34.541]             inherits <- base::inherits
[16:09:34.541]             invokeRestart <- base::invokeRestart
[16:09:34.541]             length <- base::length
[16:09:34.541]             list <- base::list
[16:09:34.541]             seq.int <- base::seq.int
[16:09:34.541]             signalCondition <- base::signalCondition
[16:09:34.541]             sys.calls <- base::sys.calls
[16:09:34.541]             `[[` <- base::`[[`
[16:09:34.541]             `+` <- base::`+`
[16:09:34.541]             `<<-` <- base::`<<-`
[16:09:34.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.541]                   3L)]
[16:09:34.541]             }
[16:09:34.541]             function(cond) {
[16:09:34.541]                 is_error <- inherits(cond, "error")
[16:09:34.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.541]                   NULL)
[16:09:34.541]                 if (is_error) {
[16:09:34.541]                   sessionInformation <- function() {
[16:09:34.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.541]                       search = base::search(), system = base::Sys.info())
[16:09:34.541]                   }
[16:09:34.541]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.541]                     cond$call), session = sessionInformation(), 
[16:09:34.541]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.541]                   signalCondition(cond)
[16:09:34.541]                 }
[16:09:34.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.541]                 "immediateCondition"))) {
[16:09:34.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.541]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.541]                   if (TRUE && !signal) {
[16:09:34.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.541]                     {
[16:09:34.541]                       inherits <- base::inherits
[16:09:34.541]                       invokeRestart <- base::invokeRestart
[16:09:34.541]                       is.null <- base::is.null
[16:09:34.541]                       muffled <- FALSE
[16:09:34.541]                       if (inherits(cond, "message")) {
[16:09:34.541]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.541]                         if (muffled) 
[16:09:34.541]                           invokeRestart("muffleMessage")
[16:09:34.541]                       }
[16:09:34.541]                       else if (inherits(cond, "warning")) {
[16:09:34.541]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.541]                         if (muffled) 
[16:09:34.541]                           invokeRestart("muffleWarning")
[16:09:34.541]                       }
[16:09:34.541]                       else if (inherits(cond, "condition")) {
[16:09:34.541]                         if (!is.null(pattern)) {
[16:09:34.541]                           computeRestarts <- base::computeRestarts
[16:09:34.541]                           grepl <- base::grepl
[16:09:34.541]                           restarts <- computeRestarts(cond)
[16:09:34.541]                           for (restart in restarts) {
[16:09:34.541]                             name <- restart$name
[16:09:34.541]                             if (is.null(name)) 
[16:09:34.541]                               next
[16:09:34.541]                             if (!grepl(pattern, name)) 
[16:09:34.541]                               next
[16:09:34.541]                             invokeRestart(restart)
[16:09:34.541]                             muffled <- TRUE
[16:09:34.541]                             break
[16:09:34.541]                           }
[16:09:34.541]                         }
[16:09:34.541]                       }
[16:09:34.541]                       invisible(muffled)
[16:09:34.541]                     }
[16:09:34.541]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.541]                   }
[16:09:34.541]                 }
[16:09:34.541]                 else {
[16:09:34.541]                   if (TRUE) {
[16:09:34.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.541]                     {
[16:09:34.541]                       inherits <- base::inherits
[16:09:34.541]                       invokeRestart <- base::invokeRestart
[16:09:34.541]                       is.null <- base::is.null
[16:09:34.541]                       muffled <- FALSE
[16:09:34.541]                       if (inherits(cond, "message")) {
[16:09:34.541]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.541]                         if (muffled) 
[16:09:34.541]                           invokeRestart("muffleMessage")
[16:09:34.541]                       }
[16:09:34.541]                       else if (inherits(cond, "warning")) {
[16:09:34.541]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.541]                         if (muffled) 
[16:09:34.541]                           invokeRestart("muffleWarning")
[16:09:34.541]                       }
[16:09:34.541]                       else if (inherits(cond, "condition")) {
[16:09:34.541]                         if (!is.null(pattern)) {
[16:09:34.541]                           computeRestarts <- base::computeRestarts
[16:09:34.541]                           grepl <- base::grepl
[16:09:34.541]                           restarts <- computeRestarts(cond)
[16:09:34.541]                           for (restart in restarts) {
[16:09:34.541]                             name <- restart$name
[16:09:34.541]                             if (is.null(name)) 
[16:09:34.541]                               next
[16:09:34.541]                             if (!grepl(pattern, name)) 
[16:09:34.541]                               next
[16:09:34.541]                             invokeRestart(restart)
[16:09:34.541]                             muffled <- TRUE
[16:09:34.541]                             break
[16:09:34.541]                           }
[16:09:34.541]                         }
[16:09:34.541]                       }
[16:09:34.541]                       invisible(muffled)
[16:09:34.541]                     }
[16:09:34.541]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.541]                   }
[16:09:34.541]                 }
[16:09:34.541]             }
[16:09:34.541]         }))
[16:09:34.541]     }, error = function(ex) {
[16:09:34.541]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.541]                 ...future.rng), started = ...future.startTime, 
[16:09:34.541]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.541]             version = "1.8"), class = "FutureResult")
[16:09:34.541]     }, finally = {
[16:09:34.541]         if (!identical(...future.workdir, getwd())) 
[16:09:34.541]             setwd(...future.workdir)
[16:09:34.541]         {
[16:09:34.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.541]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.541]             }
[16:09:34.541]             base::options(...future.oldOptions)
[16:09:34.541]             if (.Platform$OS.type == "windows") {
[16:09:34.541]                 old_names <- names(...future.oldEnvVars)
[16:09:34.541]                 envs <- base::Sys.getenv()
[16:09:34.541]                 names <- names(envs)
[16:09:34.541]                 common <- intersect(names, old_names)
[16:09:34.541]                 added <- setdiff(names, old_names)
[16:09:34.541]                 removed <- setdiff(old_names, names)
[16:09:34.541]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.541]                   envs[common]]
[16:09:34.541]                 NAMES <- toupper(changed)
[16:09:34.541]                 args <- list()
[16:09:34.541]                 for (kk in seq_along(NAMES)) {
[16:09:34.541]                   name <- changed[[kk]]
[16:09:34.541]                   NAME <- NAMES[[kk]]
[16:09:34.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.541]                     next
[16:09:34.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.541]                 }
[16:09:34.541]                 NAMES <- toupper(added)
[16:09:34.541]                 for (kk in seq_along(NAMES)) {
[16:09:34.541]                   name <- added[[kk]]
[16:09:34.541]                   NAME <- NAMES[[kk]]
[16:09:34.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.541]                     next
[16:09:34.541]                   args[[name]] <- ""
[16:09:34.541]                 }
[16:09:34.541]                 NAMES <- toupper(removed)
[16:09:34.541]                 for (kk in seq_along(NAMES)) {
[16:09:34.541]                   name <- removed[[kk]]
[16:09:34.541]                   NAME <- NAMES[[kk]]
[16:09:34.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.541]                     next
[16:09:34.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.541]                 }
[16:09:34.541]                 if (length(args) > 0) 
[16:09:34.541]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.541]             }
[16:09:34.541]             else {
[16:09:34.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.541]             }
[16:09:34.541]             {
[16:09:34.541]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.541]                   0L) {
[16:09:34.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.541]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.541]                   base::options(opts)
[16:09:34.541]                 }
[16:09:34.541]                 {
[16:09:34.541]                   {
[16:09:34.541]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.541]                     NULL
[16:09:34.541]                   }
[16:09:34.541]                   options(future.plan = NULL)
[16:09:34.541]                   if (is.na(NA_character_)) 
[16:09:34.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.541]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.541]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.541]                     envir = parent.frame()) 
[16:09:34.541]                   {
[16:09:34.541]                     if (is.function(workers)) 
[16:09:34.541]                       workers <- workers()
[16:09:34.541]                     workers <- structure(as.integer(workers), 
[16:09:34.541]                       class = class(workers))
[16:09:34.541]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.541]                       workers >= 1)
[16:09:34.541]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.541]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.541]                     }
[16:09:34.541]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.541]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.541]                       envir = envir)
[16:09:34.541]                     if (!future$lazy) 
[16:09:34.541]                       future <- run(future)
[16:09:34.541]                     invisible(future)
[16:09:34.541]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.541]                 }
[16:09:34.541]             }
[16:09:34.541]         }
[16:09:34.541]     })
[16:09:34.541]     if (TRUE) {
[16:09:34.541]         base::sink(type = "output", split = FALSE)
[16:09:34.541]         if (TRUE) {
[16:09:34.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.541]         }
[16:09:34.541]         else {
[16:09:34.541]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.541]         }
[16:09:34.541]         base::close(...future.stdout)
[16:09:34.541]         ...future.stdout <- NULL
[16:09:34.541]     }
[16:09:34.541]     ...future.result$conditions <- ...future.conditions
[16:09:34.541]     ...future.result$finished <- base::Sys.time()
[16:09:34.541]     ...future.result
[16:09:34.541] }
[16:09:34.615] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:09:34.616] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:09:34.616] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:09:34.616] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:34.617] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.617] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[16:09:34.617] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[16:09:34.618] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:34.618] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.618] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:34.618] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.619] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:09:34.619] MultisessionFuture started
[16:09:34.619] - Launch lazy future ... done
[16:09:34.620] run() for ‘MultisessionFuture’ ... done
[16:09:34.620] Created future:
[16:09:34.620] MultisessionFuture:
[16:09:34.620] Label: ‘future_by-2’
[16:09:34.620] Expression:
[16:09:34.620] {
[16:09:34.620]     do.call(function(...) {
[16:09:34.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.620]             on.exit(options(oopts), add = TRUE)
[16:09:34.620]         }
[16:09:34.620]         {
[16:09:34.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.620]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.620]             })
[16:09:34.620]         }
[16:09:34.620]     }, args = future.call.arguments)
[16:09:34.620] }
[16:09:34.620] Lazy evaluation: FALSE
[16:09:34.620] Asynchronous evaluation: TRUE
[16:09:34.620] Local evaluation: TRUE
[16:09:34.620] Environment: R_GlobalEnv
[16:09:34.620] Capture standard output: TRUE
[16:09:34.620] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:34.620] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:34.620] Packages: <none>
[16:09:34.620] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:34.620] Resolved: FALSE
[16:09:34.620] Value: <not collected>
[16:09:34.620] Conditions captured: <none>
[16:09:34.620] Early signaling: FALSE
[16:09:34.620] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:34.620] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.632] Chunk #2 of 2 ... DONE
[16:09:34.632] Launching 2 futures (chunks) ... DONE
[16:09:34.632] Resolving 2 futures (chunks) ...
[16:09:34.632] resolve() on list ...
[16:09:34.632]  recursive: 0
[16:09:34.632]  length: 2
[16:09:34.632] 
[16:09:34.633] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.633] - Validating connection of MultisessionFuture
[16:09:34.633] - received message: FutureResult
[16:09:34.633] - Received FutureResult
[16:09:34.633] - Erased future from FutureRegistry
[16:09:34.633] result() for ClusterFuture ...
[16:09:34.634] - result already collected: FutureResult
[16:09:34.634] result() for ClusterFuture ... done
[16:09:34.634] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.634] Future #1
[16:09:34.634] result() for ClusterFuture ...
[16:09:34.634] - result already collected: FutureResult
[16:09:34.634] result() for ClusterFuture ... done
[16:09:34.634] result() for ClusterFuture ...
[16:09:34.634] - result already collected: FutureResult
[16:09:34.634] result() for ClusterFuture ... done
[16:09:34.635] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:34.635] - nx: 2
[16:09:34.635] - relay: TRUE
[16:09:34.635] - stdout: TRUE
[16:09:34.635] - signal: TRUE
[16:09:34.635] - resignal: FALSE
[16:09:34.635] - force: TRUE
[16:09:34.635] - relayed: [n=2] FALSE, FALSE
[16:09:34.635] - queued futures: [n=2] FALSE, FALSE
[16:09:34.635]  - until=1
[16:09:34.635]  - relaying element #1
[16:09:34.636] result() for ClusterFuture ...
[16:09:34.638] - result already collected: FutureResult
[16:09:34.638] result() for ClusterFuture ... done
[16:09:34.638] result() for ClusterFuture ...
[16:09:34.638] - result already collected: FutureResult
[16:09:34.638] result() for ClusterFuture ... done
[16:09:34.638] result() for ClusterFuture ...
[16:09:34.638] - result already collected: FutureResult
[16:09:34.639] result() for ClusterFuture ... done
[16:09:34.639] result() for ClusterFuture ...
[16:09:34.639] - result already collected: FutureResult
[16:09:34.639] result() for ClusterFuture ... done
[16:09:34.639] - relayed: [n=2] TRUE, FALSE
[16:09:34.639] - queued futures: [n=2] TRUE, FALSE
[16:09:34.639] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:34.639]  length: 1 (resolved future 1)
[16:09:34.702] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.702] - Validating connection of MultisessionFuture
[16:09:34.702] - received message: FutureResult
[16:09:34.703] - Received FutureResult
[16:09:34.703] - Erased future from FutureRegistry
[16:09:34.703] result() for ClusterFuture ...
[16:09:34.703] - result already collected: FutureResult
[16:09:34.703] result() for ClusterFuture ... done
[16:09:34.703] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.703] Future #2
[16:09:34.703] result() for ClusterFuture ...
[16:09:34.703] - result already collected: FutureResult
[16:09:34.703] result() for ClusterFuture ... done
[16:09:34.704] result() for ClusterFuture ...
[16:09:34.704] - result already collected: FutureResult
[16:09:34.704] result() for ClusterFuture ... done
[16:09:34.704] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:34.704] - nx: 2
[16:09:34.704] - relay: TRUE
[16:09:34.704] - stdout: TRUE
[16:09:34.704] - signal: TRUE
[16:09:34.704] - resignal: FALSE
[16:09:34.704] - force: TRUE
[16:09:34.704] - relayed: [n=2] TRUE, FALSE
[16:09:34.705] - queued futures: [n=2] TRUE, FALSE
[16:09:34.705]  - until=2
[16:09:34.705]  - relaying element #2
[16:09:34.705] result() for ClusterFuture ...
[16:09:34.705] - result already collected: FutureResult
[16:09:34.705] result() for ClusterFuture ... done
[16:09:34.705] result() for ClusterFuture ...
[16:09:34.705] - result already collected: FutureResult
[16:09:34.705] result() for ClusterFuture ... done
[16:09:34.705] result() for ClusterFuture ...
[16:09:34.706] - result already collected: FutureResult
[16:09:34.706] result() for ClusterFuture ... done
[16:09:34.706] result() for ClusterFuture ...
[16:09:34.706] - result already collected: FutureResult
[16:09:34.706] result() for ClusterFuture ... done
[16:09:34.706] - relayed: [n=2] TRUE, TRUE
[16:09:34.706] - queued futures: [n=2] TRUE, TRUE
[16:09:34.706] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:34.706]  length: 0 (resolved future 2)
[16:09:34.706] Relaying remaining futures
[16:09:34.706] signalConditionsASAP(NULL, pos=0) ...
[16:09:34.707] - nx: 2
[16:09:34.707] - relay: TRUE
[16:09:34.707] - stdout: TRUE
[16:09:34.707] - signal: TRUE
[16:09:34.707] - resignal: FALSE
[16:09:34.707] - force: TRUE
[16:09:34.707] - relayed: [n=2] TRUE, TRUE
[16:09:34.707] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:34.707] - relayed: [n=2] TRUE, TRUE
[16:09:34.707] - queued futures: [n=2] TRUE, TRUE
[16:09:34.707] signalConditionsASAP(NULL, pos=0) ... done
[16:09:34.707] resolve() on list ... DONE
[16:09:34.708] result() for ClusterFuture ...
[16:09:34.708] - result already collected: FutureResult
[16:09:34.708] result() for ClusterFuture ... done
[16:09:34.708] result() for ClusterFuture ...
[16:09:34.708] - result already collected: FutureResult
[16:09:34.708] result() for ClusterFuture ... done
[16:09:34.708] result() for ClusterFuture ...
[16:09:34.708] - result already collected: FutureResult
[16:09:34.708] result() for ClusterFuture ... done
[16:09:34.708] result() for ClusterFuture ...
[16:09:34.708] - result already collected: FutureResult
[16:09:34.708] result() for ClusterFuture ... done
[16:09:34.709]  - Number of value chunks collected: 2
[16:09:34.709] Resolving 2 futures (chunks) ... DONE
[16:09:34.709] Reducing values from 2 chunks ...
[16:09:34.709]  - Number of values collected after concatenation: 3
[16:09:34.709]  - Number of values expected: 3
[16:09:34.709] Reducing values from 2 chunks ... DONE
[16:09:34.709] future_lapply() ... DONE
[16:09:34.709] future_by_internal() ... DONE
[16:09:34.710] future_by_internal() ...
[16:09:34.710] future_lapply() ...
[16:09:34.714] Number of chunks: 2
[16:09:34.714] getGlobalsAndPackagesXApply() ...
[16:09:34.714]  - future.globals: TRUE
[16:09:34.714] getGlobalsAndPackages() ...
[16:09:34.714] Searching for globals...
[16:09:34.715] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:34.715] Searching for globals ... DONE
[16:09:34.715] Resolving globals: FALSE
[16:09:34.716] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:34.716] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:34.716] - globals: [1] ‘FUN’
[16:09:34.716] 
[16:09:34.716] getGlobalsAndPackages() ... DONE
[16:09:34.717]  - globals found/used: [n=1] ‘FUN’
[16:09:34.717]  - needed namespaces: [n=0] 
[16:09:34.717] Finding globals ... DONE
[16:09:34.717]  - use_args: TRUE
[16:09:34.717]  - Getting '...' globals ...
[16:09:34.717] resolve() on list ...
[16:09:34.717]  recursive: 0
[16:09:34.717]  length: 1
[16:09:34.717]  elements: ‘...’
[16:09:34.718]  length: 0 (resolved future 1)
[16:09:34.718] resolve() on list ... DONE
[16:09:34.718]    - '...' content: [n=1] ‘digits’
[16:09:34.718] List of 1
[16:09:34.718]  $ ...:List of 1
[16:09:34.718]   ..$ digits: int 2
[16:09:34.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:34.718]  - attr(*, "where")=List of 1
[16:09:34.718]   ..$ ...:<environment: 0x5567eafb2730> 
[16:09:34.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:34.718]  - attr(*, "resolved")= logi TRUE
[16:09:34.718]  - attr(*, "total_size")= num NA
[16:09:34.721]  - Getting '...' globals ... DONE
[16:09:34.721] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:34.721] List of 2
[16:09:34.721]  $ ...future.FUN:function (object, ...)  
[16:09:34.721]  $ ...          :List of 1
[16:09:34.721]   ..$ digits: int 2
[16:09:34.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:34.721]  - attr(*, "where")=List of 2
[16:09:34.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:34.721]   ..$ ...          :<environment: 0x5567eafb2730> 
[16:09:34.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:34.721]  - attr(*, "resolved")= logi FALSE
[16:09:34.721]  - attr(*, "total_size")= num 1296
[16:09:34.724] Packages to be attached in all futures: [n=0] 
[16:09:34.724] getGlobalsAndPackagesXApply() ... DONE
[16:09:34.724] Number of futures (= number of chunks): 2
[16:09:34.724] Launching 2 futures (chunks) ...
[16:09:34.724] Chunk #1 of 2 ...
[16:09:34.725]  - Finding globals in 'X' for chunk #1 ...
[16:09:34.725] getGlobalsAndPackages() ...
[16:09:34.725] Searching for globals...
[16:09:34.725] 
[16:09:34.725] Searching for globals ... DONE
[16:09:34.725] - globals: [0] <none>
[16:09:34.725] getGlobalsAndPackages() ... DONE
[16:09:34.725]    + additional globals found: [n=0] 
[16:09:34.725]    + additional namespaces needed: [n=0] 
[16:09:34.725]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:34.726]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:34.726]  - seeds: <none>
[16:09:34.726] getGlobalsAndPackages() ...
[16:09:34.726] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.726] Resolving globals: FALSE
[16:09:34.726] Tweak future expression to call with '...' arguments ...
[16:09:34.726] {
[16:09:34.726]     do.call(function(...) {
[16:09:34.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.726]             on.exit(options(oopts), add = TRUE)
[16:09:34.726]         }
[16:09:34.726]         {
[16:09:34.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.726]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.726]             })
[16:09:34.726]         }
[16:09:34.726]     }, args = future.call.arguments)
[16:09:34.726] }
[16:09:34.726] Tweak future expression to call with '...' arguments ... DONE
[16:09:34.727] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.727] 
[16:09:34.727] getGlobalsAndPackages() ... DONE
[16:09:34.727] run() for ‘Future’ ...
[16:09:34.727] - state: ‘created’
[16:09:34.727] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:34.741] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:34.742]   - Field: ‘node’
[16:09:34.742]   - Field: ‘label’
[16:09:34.742]   - Field: ‘local’
[16:09:34.742]   - Field: ‘owner’
[16:09:34.742]   - Field: ‘envir’
[16:09:34.742]   - Field: ‘workers’
[16:09:34.742]   - Field: ‘packages’
[16:09:34.742]   - Field: ‘gc’
[16:09:34.742]   - Field: ‘conditions’
[16:09:34.742]   - Field: ‘persistent’
[16:09:34.743]   - Field: ‘expr’
[16:09:34.743]   - Field: ‘uuid’
[16:09:34.743]   - Field: ‘seed’
[16:09:34.743]   - Field: ‘version’
[16:09:34.743]   - Field: ‘result’
[16:09:34.743]   - Field: ‘asynchronous’
[16:09:34.743]   - Field: ‘calls’
[16:09:34.743]   - Field: ‘globals’
[16:09:34.743]   - Field: ‘stdout’
[16:09:34.743]   - Field: ‘earlySignal’
[16:09:34.743]   - Field: ‘lazy’
[16:09:34.744]   - Field: ‘state’
[16:09:34.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:34.744] - Launch lazy future ...
[16:09:34.744] Packages needed by the future expression (n = 0): <none>
[16:09:34.744] Packages needed by future strategies (n = 0): <none>
[16:09:34.745] {
[16:09:34.745]     {
[16:09:34.745]         {
[16:09:34.745]             ...future.startTime <- base::Sys.time()
[16:09:34.745]             {
[16:09:34.745]                 {
[16:09:34.745]                   {
[16:09:34.745]                     {
[16:09:34.745]                       base::local({
[16:09:34.745]                         has_future <- base::requireNamespace("future", 
[16:09:34.745]                           quietly = TRUE)
[16:09:34.745]                         if (has_future) {
[16:09:34.745]                           ns <- base::getNamespace("future")
[16:09:34.745]                           version <- ns[[".package"]][["version"]]
[16:09:34.745]                           if (is.null(version)) 
[16:09:34.745]                             version <- utils::packageVersion("future")
[16:09:34.745]                         }
[16:09:34.745]                         else {
[16:09:34.745]                           version <- NULL
[16:09:34.745]                         }
[16:09:34.745]                         if (!has_future || version < "1.8.0") {
[16:09:34.745]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.745]                             "", base::R.version$version.string), 
[16:09:34.745]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:34.745]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:34.745]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.745]                               "release", "version")], collapse = " "), 
[16:09:34.745]                             hostname = base::Sys.info()[["nodename"]])
[16:09:34.745]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.745]                             info)
[16:09:34.745]                           info <- base::paste(info, collapse = "; ")
[16:09:34.745]                           if (!has_future) {
[16:09:34.745]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.745]                               info)
[16:09:34.745]                           }
[16:09:34.745]                           else {
[16:09:34.745]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.745]                               info, version)
[16:09:34.745]                           }
[16:09:34.745]                           base::stop(msg)
[16:09:34.745]                         }
[16:09:34.745]                       })
[16:09:34.745]                     }
[16:09:34.745]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.745]                     base::options(mc.cores = 1L)
[16:09:34.745]                   }
[16:09:34.745]                   options(future.plan = NULL)
[16:09:34.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.745]                 }
[16:09:34.745]                 ...future.workdir <- getwd()
[16:09:34.745]             }
[16:09:34.745]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.745]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.745]         }
[16:09:34.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.745]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:34.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.745]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.745]             base::names(...future.oldOptions))
[16:09:34.745]     }
[16:09:34.745]     if (FALSE) {
[16:09:34.745]     }
[16:09:34.745]     else {
[16:09:34.745]         if (TRUE) {
[16:09:34.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.745]                 open = "w")
[16:09:34.745]         }
[16:09:34.745]         else {
[16:09:34.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.745]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.745]         }
[16:09:34.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.745]             base::sink(type = "output", split = FALSE)
[16:09:34.745]             base::close(...future.stdout)
[16:09:34.745]         }, add = TRUE)
[16:09:34.745]     }
[16:09:34.745]     ...future.frame <- base::sys.nframe()
[16:09:34.745]     ...future.conditions <- base::list()
[16:09:34.745]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.745]     if (FALSE) {
[16:09:34.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.745]     }
[16:09:34.745]     ...future.result <- base::tryCatch({
[16:09:34.745]         base::withCallingHandlers({
[16:09:34.745]             ...future.value <- base::withVisible(base::local({
[16:09:34.745]                 ...future.makeSendCondition <- local({
[16:09:34.745]                   sendCondition <- NULL
[16:09:34.745]                   function(frame = 1L) {
[16:09:34.745]                     if (is.function(sendCondition)) 
[16:09:34.745]                       return(sendCondition)
[16:09:34.745]                     ns <- getNamespace("parallel")
[16:09:34.745]                     if (exists("sendData", mode = "function", 
[16:09:34.745]                       envir = ns)) {
[16:09:34.745]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.745]                         envir = ns)
[16:09:34.745]                       envir <- sys.frame(frame)
[16:09:34.745]                       master <- NULL
[16:09:34.745]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.745]                         !identical(envir, emptyenv())) {
[16:09:34.745]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.745]                           inherits = FALSE)) {
[16:09:34.745]                           master <- get("master", mode = "list", 
[16:09:34.745]                             envir = envir, inherits = FALSE)
[16:09:34.745]                           if (inherits(master, c("SOCKnode", 
[16:09:34.745]                             "SOCK0node"))) {
[16:09:34.745]                             sendCondition <<- function(cond) {
[16:09:34.745]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.745]                                 success = TRUE)
[16:09:34.745]                               parallel_sendData(master, data)
[16:09:34.745]                             }
[16:09:34.745]                             return(sendCondition)
[16:09:34.745]                           }
[16:09:34.745]                         }
[16:09:34.745]                         frame <- frame + 1L
[16:09:34.745]                         envir <- sys.frame(frame)
[16:09:34.745]                       }
[16:09:34.745]                     }
[16:09:34.745]                     sendCondition <<- function(cond) NULL
[16:09:34.745]                   }
[16:09:34.745]                 })
[16:09:34.745]                 withCallingHandlers({
[16:09:34.745]                   {
[16:09:34.745]                     do.call(function(...) {
[16:09:34.745]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.745]                       if (!identical(...future.globals.maxSize.org, 
[16:09:34.745]                         ...future.globals.maxSize)) {
[16:09:34.745]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.745]                         on.exit(options(oopts), add = TRUE)
[16:09:34.745]                       }
[16:09:34.745]                       {
[16:09:34.745]                         lapply(seq_along(...future.elements_ii), 
[16:09:34.745]                           FUN = function(jj) {
[16:09:34.745]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.745]                             ...future.FUN(...future.X_jj, ...)
[16:09:34.745]                           })
[16:09:34.745]                       }
[16:09:34.745]                     }, args = future.call.arguments)
[16:09:34.745]                   }
[16:09:34.745]                 }, immediateCondition = function(cond) {
[16:09:34.745]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.745]                   sendCondition(cond)
[16:09:34.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.745]                   {
[16:09:34.745]                     inherits <- base::inherits
[16:09:34.745]                     invokeRestart <- base::invokeRestart
[16:09:34.745]                     is.null <- base::is.null
[16:09:34.745]                     muffled <- FALSE
[16:09:34.745]                     if (inherits(cond, "message")) {
[16:09:34.745]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.745]                       if (muffled) 
[16:09:34.745]                         invokeRestart("muffleMessage")
[16:09:34.745]                     }
[16:09:34.745]                     else if (inherits(cond, "warning")) {
[16:09:34.745]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.745]                       if (muffled) 
[16:09:34.745]                         invokeRestart("muffleWarning")
[16:09:34.745]                     }
[16:09:34.745]                     else if (inherits(cond, "condition")) {
[16:09:34.745]                       if (!is.null(pattern)) {
[16:09:34.745]                         computeRestarts <- base::computeRestarts
[16:09:34.745]                         grepl <- base::grepl
[16:09:34.745]                         restarts <- computeRestarts(cond)
[16:09:34.745]                         for (restart in restarts) {
[16:09:34.745]                           name <- restart$name
[16:09:34.745]                           if (is.null(name)) 
[16:09:34.745]                             next
[16:09:34.745]                           if (!grepl(pattern, name)) 
[16:09:34.745]                             next
[16:09:34.745]                           invokeRestart(restart)
[16:09:34.745]                           muffled <- TRUE
[16:09:34.745]                           break
[16:09:34.745]                         }
[16:09:34.745]                       }
[16:09:34.745]                     }
[16:09:34.745]                     invisible(muffled)
[16:09:34.745]                   }
[16:09:34.745]                   muffleCondition(cond)
[16:09:34.745]                 })
[16:09:34.745]             }))
[16:09:34.745]             future::FutureResult(value = ...future.value$value, 
[16:09:34.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.745]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.745]                     ...future.globalenv.names))
[16:09:34.745]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.745]         }, condition = base::local({
[16:09:34.745]             c <- base::c
[16:09:34.745]             inherits <- base::inherits
[16:09:34.745]             invokeRestart <- base::invokeRestart
[16:09:34.745]             length <- base::length
[16:09:34.745]             list <- base::list
[16:09:34.745]             seq.int <- base::seq.int
[16:09:34.745]             signalCondition <- base::signalCondition
[16:09:34.745]             sys.calls <- base::sys.calls
[16:09:34.745]             `[[` <- base::`[[`
[16:09:34.745]             `+` <- base::`+`
[16:09:34.745]             `<<-` <- base::`<<-`
[16:09:34.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.745]                   3L)]
[16:09:34.745]             }
[16:09:34.745]             function(cond) {
[16:09:34.745]                 is_error <- inherits(cond, "error")
[16:09:34.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.745]                   NULL)
[16:09:34.745]                 if (is_error) {
[16:09:34.745]                   sessionInformation <- function() {
[16:09:34.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.745]                       search = base::search(), system = base::Sys.info())
[16:09:34.745]                   }
[16:09:34.745]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.745]                     cond$call), session = sessionInformation(), 
[16:09:34.745]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.745]                   signalCondition(cond)
[16:09:34.745]                 }
[16:09:34.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.745]                 "immediateCondition"))) {
[16:09:34.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.745]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.745]                   if (TRUE && !signal) {
[16:09:34.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.745]                     {
[16:09:34.745]                       inherits <- base::inherits
[16:09:34.745]                       invokeRestart <- base::invokeRestart
[16:09:34.745]                       is.null <- base::is.null
[16:09:34.745]                       muffled <- FALSE
[16:09:34.745]                       if (inherits(cond, "message")) {
[16:09:34.745]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.745]                         if (muffled) 
[16:09:34.745]                           invokeRestart("muffleMessage")
[16:09:34.745]                       }
[16:09:34.745]                       else if (inherits(cond, "warning")) {
[16:09:34.745]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.745]                         if (muffled) 
[16:09:34.745]                           invokeRestart("muffleWarning")
[16:09:34.745]                       }
[16:09:34.745]                       else if (inherits(cond, "condition")) {
[16:09:34.745]                         if (!is.null(pattern)) {
[16:09:34.745]                           computeRestarts <- base::computeRestarts
[16:09:34.745]                           grepl <- base::grepl
[16:09:34.745]                           restarts <- computeRestarts(cond)
[16:09:34.745]                           for (restart in restarts) {
[16:09:34.745]                             name <- restart$name
[16:09:34.745]                             if (is.null(name)) 
[16:09:34.745]                               next
[16:09:34.745]                             if (!grepl(pattern, name)) 
[16:09:34.745]                               next
[16:09:34.745]                             invokeRestart(restart)
[16:09:34.745]                             muffled <- TRUE
[16:09:34.745]                             break
[16:09:34.745]                           }
[16:09:34.745]                         }
[16:09:34.745]                       }
[16:09:34.745]                       invisible(muffled)
[16:09:34.745]                     }
[16:09:34.745]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.745]                   }
[16:09:34.745]                 }
[16:09:34.745]                 else {
[16:09:34.745]                   if (TRUE) {
[16:09:34.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.745]                     {
[16:09:34.745]                       inherits <- base::inherits
[16:09:34.745]                       invokeRestart <- base::invokeRestart
[16:09:34.745]                       is.null <- base::is.null
[16:09:34.745]                       muffled <- FALSE
[16:09:34.745]                       if (inherits(cond, "message")) {
[16:09:34.745]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.745]                         if (muffled) 
[16:09:34.745]                           invokeRestart("muffleMessage")
[16:09:34.745]                       }
[16:09:34.745]                       else if (inherits(cond, "warning")) {
[16:09:34.745]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.745]                         if (muffled) 
[16:09:34.745]                           invokeRestart("muffleWarning")
[16:09:34.745]                       }
[16:09:34.745]                       else if (inherits(cond, "condition")) {
[16:09:34.745]                         if (!is.null(pattern)) {
[16:09:34.745]                           computeRestarts <- base::computeRestarts
[16:09:34.745]                           grepl <- base::grepl
[16:09:34.745]                           restarts <- computeRestarts(cond)
[16:09:34.745]                           for (restart in restarts) {
[16:09:34.745]                             name <- restart$name
[16:09:34.745]                             if (is.null(name)) 
[16:09:34.745]                               next
[16:09:34.745]                             if (!grepl(pattern, name)) 
[16:09:34.745]                               next
[16:09:34.745]                             invokeRestart(restart)
[16:09:34.745]                             muffled <- TRUE
[16:09:34.745]                             break
[16:09:34.745]                           }
[16:09:34.745]                         }
[16:09:34.745]                       }
[16:09:34.745]                       invisible(muffled)
[16:09:34.745]                     }
[16:09:34.745]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.745]                   }
[16:09:34.745]                 }
[16:09:34.745]             }
[16:09:34.745]         }))
[16:09:34.745]     }, error = function(ex) {
[16:09:34.745]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.745]                 ...future.rng), started = ...future.startTime, 
[16:09:34.745]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.745]             version = "1.8"), class = "FutureResult")
[16:09:34.745]     }, finally = {
[16:09:34.745]         if (!identical(...future.workdir, getwd())) 
[16:09:34.745]             setwd(...future.workdir)
[16:09:34.745]         {
[16:09:34.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.745]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.745]             }
[16:09:34.745]             base::options(...future.oldOptions)
[16:09:34.745]             if (.Platform$OS.type == "windows") {
[16:09:34.745]                 old_names <- names(...future.oldEnvVars)
[16:09:34.745]                 envs <- base::Sys.getenv()
[16:09:34.745]                 names <- names(envs)
[16:09:34.745]                 common <- intersect(names, old_names)
[16:09:34.745]                 added <- setdiff(names, old_names)
[16:09:34.745]                 removed <- setdiff(old_names, names)
[16:09:34.745]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.745]                   envs[common]]
[16:09:34.745]                 NAMES <- toupper(changed)
[16:09:34.745]                 args <- list()
[16:09:34.745]                 for (kk in seq_along(NAMES)) {
[16:09:34.745]                   name <- changed[[kk]]
[16:09:34.745]                   NAME <- NAMES[[kk]]
[16:09:34.745]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.745]                     next
[16:09:34.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.745]                 }
[16:09:34.745]                 NAMES <- toupper(added)
[16:09:34.745]                 for (kk in seq_along(NAMES)) {
[16:09:34.745]                   name <- added[[kk]]
[16:09:34.745]                   NAME <- NAMES[[kk]]
[16:09:34.745]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.745]                     next
[16:09:34.745]                   args[[name]] <- ""
[16:09:34.745]                 }
[16:09:34.745]                 NAMES <- toupper(removed)
[16:09:34.745]                 for (kk in seq_along(NAMES)) {
[16:09:34.745]                   name <- removed[[kk]]
[16:09:34.745]                   NAME <- NAMES[[kk]]
[16:09:34.745]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.745]                     next
[16:09:34.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.745]                 }
[16:09:34.745]                 if (length(args) > 0) 
[16:09:34.745]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.745]             }
[16:09:34.745]             else {
[16:09:34.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.745]             }
[16:09:34.745]             {
[16:09:34.745]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.745]                   0L) {
[16:09:34.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.745]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.745]                   base::options(opts)
[16:09:34.745]                 }
[16:09:34.745]                 {
[16:09:34.745]                   {
[16:09:34.745]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.745]                     NULL
[16:09:34.745]                   }
[16:09:34.745]                   options(future.plan = NULL)
[16:09:34.745]                   if (is.na(NA_character_)) 
[16:09:34.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.745]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.745]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.745]                     envir = parent.frame()) 
[16:09:34.745]                   {
[16:09:34.745]                     if (is.function(workers)) 
[16:09:34.745]                       workers <- workers()
[16:09:34.745]                     workers <- structure(as.integer(workers), 
[16:09:34.745]                       class = class(workers))
[16:09:34.745]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.745]                       workers >= 1)
[16:09:34.745]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.745]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.745]                     }
[16:09:34.745]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.745]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.745]                       envir = envir)
[16:09:34.745]                     if (!future$lazy) 
[16:09:34.745]                       future <- run(future)
[16:09:34.745]                     invisible(future)
[16:09:34.745]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.745]                 }
[16:09:34.745]             }
[16:09:34.745]         }
[16:09:34.745]     })
[16:09:34.745]     if (TRUE) {
[16:09:34.745]         base::sink(type = "output", split = FALSE)
[16:09:34.745]         if (TRUE) {
[16:09:34.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.745]         }
[16:09:34.745]         else {
[16:09:34.745]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.745]         }
[16:09:34.745]         base::close(...future.stdout)
[16:09:34.745]         ...future.stdout <- NULL
[16:09:34.745]     }
[16:09:34.745]     ...future.result$conditions <- ...future.conditions
[16:09:34.745]     ...future.result$finished <- base::Sys.time()
[16:09:34.745]     ...future.result
[16:09:34.745] }
[16:09:34.747] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[16:09:34.747] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:09:34.748] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:09:34.748] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:09:34.748] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:09:34.749] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[16:09:34.749] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[16:09:34.749] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:34.749] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.749] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:34.750] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.750] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[16:09:34.750] MultisessionFuture started
[16:09:34.750] - Launch lazy future ... done
[16:09:34.750] run() for ‘MultisessionFuture’ ... done
[16:09:34.751] Created future:
[16:09:34.751] MultisessionFuture:
[16:09:34.751] Label: ‘future_by-1’
[16:09:34.751] Expression:
[16:09:34.751] {
[16:09:34.751]     do.call(function(...) {
[16:09:34.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.751]             on.exit(options(oopts), add = TRUE)
[16:09:34.751]         }
[16:09:34.751]         {
[16:09:34.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.751]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.751]             })
[16:09:34.751]         }
[16:09:34.751]     }, args = future.call.arguments)
[16:09:34.751] }
[16:09:34.751] Lazy evaluation: FALSE
[16:09:34.751] Asynchronous evaluation: TRUE
[16:09:34.751] Local evaluation: TRUE
[16:09:34.751] Environment: R_GlobalEnv
[16:09:34.751] Capture standard output: TRUE
[16:09:34.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:34.751] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:34.751] Packages: <none>
[16:09:34.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:34.751] Resolved: FALSE
[16:09:34.751] Value: <not collected>
[16:09:34.751] Conditions captured: <none>
[16:09:34.751] Early signaling: FALSE
[16:09:34.751] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:34.751] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.762] Chunk #1 of 2 ... DONE
[16:09:34.762] Chunk #2 of 2 ...
[16:09:34.762]  - Finding globals in 'X' for chunk #2 ...
[16:09:34.763] getGlobalsAndPackages() ...
[16:09:34.763] Searching for globals...
[16:09:34.763] 
[16:09:34.763] Searching for globals ... DONE
[16:09:34.763] - globals: [0] <none>
[16:09:34.763] getGlobalsAndPackages() ... DONE
[16:09:34.763]    + additional globals found: [n=0] 
[16:09:34.763]    + additional namespaces needed: [n=0] 
[16:09:34.763]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:34.763]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:34.764]  - seeds: <none>
[16:09:34.764] getGlobalsAndPackages() ...
[16:09:34.764] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.764] Resolving globals: FALSE
[16:09:34.764] Tweak future expression to call with '...' arguments ...
[16:09:34.764] {
[16:09:34.764]     do.call(function(...) {
[16:09:34.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.764]             on.exit(options(oopts), add = TRUE)
[16:09:34.764]         }
[16:09:34.764]         {
[16:09:34.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.764]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.764]             })
[16:09:34.764]         }
[16:09:34.764]     }, args = future.call.arguments)
[16:09:34.764] }
[16:09:34.764] Tweak future expression to call with '...' arguments ... DONE
[16:09:34.765] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.765] 
[16:09:34.765] getGlobalsAndPackages() ... DONE
[16:09:34.765] run() for ‘Future’ ...
[16:09:34.765] - state: ‘created’
[16:09:34.765] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:34.779] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:34.780]   - Field: ‘node’
[16:09:34.780]   - Field: ‘label’
[16:09:34.780]   - Field: ‘local’
[16:09:34.780]   - Field: ‘owner’
[16:09:34.780]   - Field: ‘envir’
[16:09:34.780]   - Field: ‘workers’
[16:09:34.780]   - Field: ‘packages’
[16:09:34.780]   - Field: ‘gc’
[16:09:34.780]   - Field: ‘conditions’
[16:09:34.780]   - Field: ‘persistent’
[16:09:34.780]   - Field: ‘expr’
[16:09:34.781]   - Field: ‘uuid’
[16:09:34.781]   - Field: ‘seed’
[16:09:34.781]   - Field: ‘version’
[16:09:34.781]   - Field: ‘result’
[16:09:34.781]   - Field: ‘asynchronous’
[16:09:34.781]   - Field: ‘calls’
[16:09:34.781]   - Field: ‘globals’
[16:09:34.781]   - Field: ‘stdout’
[16:09:34.781]   - Field: ‘earlySignal’
[16:09:34.781]   - Field: ‘lazy’
[16:09:34.781]   - Field: ‘state’
[16:09:34.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:34.782] - Launch lazy future ...
[16:09:34.782] Packages needed by the future expression (n = 0): <none>
[16:09:34.782] Packages needed by future strategies (n = 0): <none>
[16:09:34.782] {
[16:09:34.782]     {
[16:09:34.782]         {
[16:09:34.782]             ...future.startTime <- base::Sys.time()
[16:09:34.782]             {
[16:09:34.782]                 {
[16:09:34.782]                   {
[16:09:34.782]                     {
[16:09:34.782]                       base::local({
[16:09:34.782]                         has_future <- base::requireNamespace("future", 
[16:09:34.782]                           quietly = TRUE)
[16:09:34.782]                         if (has_future) {
[16:09:34.782]                           ns <- base::getNamespace("future")
[16:09:34.782]                           version <- ns[[".package"]][["version"]]
[16:09:34.782]                           if (is.null(version)) 
[16:09:34.782]                             version <- utils::packageVersion("future")
[16:09:34.782]                         }
[16:09:34.782]                         else {
[16:09:34.782]                           version <- NULL
[16:09:34.782]                         }
[16:09:34.782]                         if (!has_future || version < "1.8.0") {
[16:09:34.782]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.782]                             "", base::R.version$version.string), 
[16:09:34.782]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:34.782]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:34.782]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.782]                               "release", "version")], collapse = " "), 
[16:09:34.782]                             hostname = base::Sys.info()[["nodename"]])
[16:09:34.782]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.782]                             info)
[16:09:34.782]                           info <- base::paste(info, collapse = "; ")
[16:09:34.782]                           if (!has_future) {
[16:09:34.782]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.782]                               info)
[16:09:34.782]                           }
[16:09:34.782]                           else {
[16:09:34.782]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.782]                               info, version)
[16:09:34.782]                           }
[16:09:34.782]                           base::stop(msg)
[16:09:34.782]                         }
[16:09:34.782]                       })
[16:09:34.782]                     }
[16:09:34.782]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.782]                     base::options(mc.cores = 1L)
[16:09:34.782]                   }
[16:09:34.782]                   options(future.plan = NULL)
[16:09:34.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.782]                 }
[16:09:34.782]                 ...future.workdir <- getwd()
[16:09:34.782]             }
[16:09:34.782]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.782]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.782]         }
[16:09:34.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.782]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:34.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.782]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.782]             base::names(...future.oldOptions))
[16:09:34.782]     }
[16:09:34.782]     if (FALSE) {
[16:09:34.782]     }
[16:09:34.782]     else {
[16:09:34.782]         if (TRUE) {
[16:09:34.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.782]                 open = "w")
[16:09:34.782]         }
[16:09:34.782]         else {
[16:09:34.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.782]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.782]         }
[16:09:34.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.782]             base::sink(type = "output", split = FALSE)
[16:09:34.782]             base::close(...future.stdout)
[16:09:34.782]         }, add = TRUE)
[16:09:34.782]     }
[16:09:34.782]     ...future.frame <- base::sys.nframe()
[16:09:34.782]     ...future.conditions <- base::list()
[16:09:34.782]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.782]     if (FALSE) {
[16:09:34.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.782]     }
[16:09:34.782]     ...future.result <- base::tryCatch({
[16:09:34.782]         base::withCallingHandlers({
[16:09:34.782]             ...future.value <- base::withVisible(base::local({
[16:09:34.782]                 ...future.makeSendCondition <- local({
[16:09:34.782]                   sendCondition <- NULL
[16:09:34.782]                   function(frame = 1L) {
[16:09:34.782]                     if (is.function(sendCondition)) 
[16:09:34.782]                       return(sendCondition)
[16:09:34.782]                     ns <- getNamespace("parallel")
[16:09:34.782]                     if (exists("sendData", mode = "function", 
[16:09:34.782]                       envir = ns)) {
[16:09:34.782]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.782]                         envir = ns)
[16:09:34.782]                       envir <- sys.frame(frame)
[16:09:34.782]                       master <- NULL
[16:09:34.782]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.782]                         !identical(envir, emptyenv())) {
[16:09:34.782]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.782]                           inherits = FALSE)) {
[16:09:34.782]                           master <- get("master", mode = "list", 
[16:09:34.782]                             envir = envir, inherits = FALSE)
[16:09:34.782]                           if (inherits(master, c("SOCKnode", 
[16:09:34.782]                             "SOCK0node"))) {
[16:09:34.782]                             sendCondition <<- function(cond) {
[16:09:34.782]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.782]                                 success = TRUE)
[16:09:34.782]                               parallel_sendData(master, data)
[16:09:34.782]                             }
[16:09:34.782]                             return(sendCondition)
[16:09:34.782]                           }
[16:09:34.782]                         }
[16:09:34.782]                         frame <- frame + 1L
[16:09:34.782]                         envir <- sys.frame(frame)
[16:09:34.782]                       }
[16:09:34.782]                     }
[16:09:34.782]                     sendCondition <<- function(cond) NULL
[16:09:34.782]                   }
[16:09:34.782]                 })
[16:09:34.782]                 withCallingHandlers({
[16:09:34.782]                   {
[16:09:34.782]                     do.call(function(...) {
[16:09:34.782]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.782]                       if (!identical(...future.globals.maxSize.org, 
[16:09:34.782]                         ...future.globals.maxSize)) {
[16:09:34.782]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.782]                         on.exit(options(oopts), add = TRUE)
[16:09:34.782]                       }
[16:09:34.782]                       {
[16:09:34.782]                         lapply(seq_along(...future.elements_ii), 
[16:09:34.782]                           FUN = function(jj) {
[16:09:34.782]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.782]                             ...future.FUN(...future.X_jj, ...)
[16:09:34.782]                           })
[16:09:34.782]                       }
[16:09:34.782]                     }, args = future.call.arguments)
[16:09:34.782]                   }
[16:09:34.782]                 }, immediateCondition = function(cond) {
[16:09:34.782]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.782]                   sendCondition(cond)
[16:09:34.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.782]                   {
[16:09:34.782]                     inherits <- base::inherits
[16:09:34.782]                     invokeRestart <- base::invokeRestart
[16:09:34.782]                     is.null <- base::is.null
[16:09:34.782]                     muffled <- FALSE
[16:09:34.782]                     if (inherits(cond, "message")) {
[16:09:34.782]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.782]                       if (muffled) 
[16:09:34.782]                         invokeRestart("muffleMessage")
[16:09:34.782]                     }
[16:09:34.782]                     else if (inherits(cond, "warning")) {
[16:09:34.782]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.782]                       if (muffled) 
[16:09:34.782]                         invokeRestart("muffleWarning")
[16:09:34.782]                     }
[16:09:34.782]                     else if (inherits(cond, "condition")) {
[16:09:34.782]                       if (!is.null(pattern)) {
[16:09:34.782]                         computeRestarts <- base::computeRestarts
[16:09:34.782]                         grepl <- base::grepl
[16:09:34.782]                         restarts <- computeRestarts(cond)
[16:09:34.782]                         for (restart in restarts) {
[16:09:34.782]                           name <- restart$name
[16:09:34.782]                           if (is.null(name)) 
[16:09:34.782]                             next
[16:09:34.782]                           if (!grepl(pattern, name)) 
[16:09:34.782]                             next
[16:09:34.782]                           invokeRestart(restart)
[16:09:34.782]                           muffled <- TRUE
[16:09:34.782]                           break
[16:09:34.782]                         }
[16:09:34.782]                       }
[16:09:34.782]                     }
[16:09:34.782]                     invisible(muffled)
[16:09:34.782]                   }
[16:09:34.782]                   muffleCondition(cond)
[16:09:34.782]                 })
[16:09:34.782]             }))
[16:09:34.782]             future::FutureResult(value = ...future.value$value, 
[16:09:34.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.782]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.782]                     ...future.globalenv.names))
[16:09:34.782]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.782]         }, condition = base::local({
[16:09:34.782]             c <- base::c
[16:09:34.782]             inherits <- base::inherits
[16:09:34.782]             invokeRestart <- base::invokeRestart
[16:09:34.782]             length <- base::length
[16:09:34.782]             list <- base::list
[16:09:34.782]             seq.int <- base::seq.int
[16:09:34.782]             signalCondition <- base::signalCondition
[16:09:34.782]             sys.calls <- base::sys.calls
[16:09:34.782]             `[[` <- base::`[[`
[16:09:34.782]             `+` <- base::`+`
[16:09:34.782]             `<<-` <- base::`<<-`
[16:09:34.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.782]                   3L)]
[16:09:34.782]             }
[16:09:34.782]             function(cond) {
[16:09:34.782]                 is_error <- inherits(cond, "error")
[16:09:34.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.782]                   NULL)
[16:09:34.782]                 if (is_error) {
[16:09:34.782]                   sessionInformation <- function() {
[16:09:34.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.782]                       search = base::search(), system = base::Sys.info())
[16:09:34.782]                   }
[16:09:34.782]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.782]                     cond$call), session = sessionInformation(), 
[16:09:34.782]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.782]                   signalCondition(cond)
[16:09:34.782]                 }
[16:09:34.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.782]                 "immediateCondition"))) {
[16:09:34.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.782]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.782]                   if (TRUE && !signal) {
[16:09:34.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.782]                     {
[16:09:34.782]                       inherits <- base::inherits
[16:09:34.782]                       invokeRestart <- base::invokeRestart
[16:09:34.782]                       is.null <- base::is.null
[16:09:34.782]                       muffled <- FALSE
[16:09:34.782]                       if (inherits(cond, "message")) {
[16:09:34.782]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.782]                         if (muffled) 
[16:09:34.782]                           invokeRestart("muffleMessage")
[16:09:34.782]                       }
[16:09:34.782]                       else if (inherits(cond, "warning")) {
[16:09:34.782]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.782]                         if (muffled) 
[16:09:34.782]                           invokeRestart("muffleWarning")
[16:09:34.782]                       }
[16:09:34.782]                       else if (inherits(cond, "condition")) {
[16:09:34.782]                         if (!is.null(pattern)) {
[16:09:34.782]                           computeRestarts <- base::computeRestarts
[16:09:34.782]                           grepl <- base::grepl
[16:09:34.782]                           restarts <- computeRestarts(cond)
[16:09:34.782]                           for (restart in restarts) {
[16:09:34.782]                             name <- restart$name
[16:09:34.782]                             if (is.null(name)) 
[16:09:34.782]                               next
[16:09:34.782]                             if (!grepl(pattern, name)) 
[16:09:34.782]                               next
[16:09:34.782]                             invokeRestart(restart)
[16:09:34.782]                             muffled <- TRUE
[16:09:34.782]                             break
[16:09:34.782]                           }
[16:09:34.782]                         }
[16:09:34.782]                       }
[16:09:34.782]                       invisible(muffled)
[16:09:34.782]                     }
[16:09:34.782]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.782]                   }
[16:09:34.782]                 }
[16:09:34.782]                 else {
[16:09:34.782]                   if (TRUE) {
[16:09:34.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.782]                     {
[16:09:34.782]                       inherits <- base::inherits
[16:09:34.782]                       invokeRestart <- base::invokeRestart
[16:09:34.782]                       is.null <- base::is.null
[16:09:34.782]                       muffled <- FALSE
[16:09:34.782]                       if (inherits(cond, "message")) {
[16:09:34.782]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.782]                         if (muffled) 
[16:09:34.782]                           invokeRestart("muffleMessage")
[16:09:34.782]                       }
[16:09:34.782]                       else if (inherits(cond, "warning")) {
[16:09:34.782]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.782]                         if (muffled) 
[16:09:34.782]                           invokeRestart("muffleWarning")
[16:09:34.782]                       }
[16:09:34.782]                       else if (inherits(cond, "condition")) {
[16:09:34.782]                         if (!is.null(pattern)) {
[16:09:34.782]                           computeRestarts <- base::computeRestarts
[16:09:34.782]                           grepl <- base::grepl
[16:09:34.782]                           restarts <- computeRestarts(cond)
[16:09:34.782]                           for (restart in restarts) {
[16:09:34.782]                             name <- restart$name
[16:09:34.782]                             if (is.null(name)) 
[16:09:34.782]                               next
[16:09:34.782]                             if (!grepl(pattern, name)) 
[16:09:34.782]                               next
[16:09:34.782]                             invokeRestart(restart)
[16:09:34.782]                             muffled <- TRUE
[16:09:34.782]                             break
[16:09:34.782]                           }
[16:09:34.782]                         }
[16:09:34.782]                       }
[16:09:34.782]                       invisible(muffled)
[16:09:34.782]                     }
[16:09:34.782]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.782]                   }
[16:09:34.782]                 }
[16:09:34.782]             }
[16:09:34.782]         }))
[16:09:34.782]     }, error = function(ex) {
[16:09:34.782]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.782]                 ...future.rng), started = ...future.startTime, 
[16:09:34.782]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.782]             version = "1.8"), class = "FutureResult")
[16:09:34.782]     }, finally = {
[16:09:34.782]         if (!identical(...future.workdir, getwd())) 
[16:09:34.782]             setwd(...future.workdir)
[16:09:34.782]         {
[16:09:34.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.782]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.782]             }
[16:09:34.782]             base::options(...future.oldOptions)
[16:09:34.782]             if (.Platform$OS.type == "windows") {
[16:09:34.782]                 old_names <- names(...future.oldEnvVars)
[16:09:34.782]                 envs <- base::Sys.getenv()
[16:09:34.782]                 names <- names(envs)
[16:09:34.782]                 common <- intersect(names, old_names)
[16:09:34.782]                 added <- setdiff(names, old_names)
[16:09:34.782]                 removed <- setdiff(old_names, names)
[16:09:34.782]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.782]                   envs[common]]
[16:09:34.782]                 NAMES <- toupper(changed)
[16:09:34.782]                 args <- list()
[16:09:34.782]                 for (kk in seq_along(NAMES)) {
[16:09:34.782]                   name <- changed[[kk]]
[16:09:34.782]                   NAME <- NAMES[[kk]]
[16:09:34.782]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.782]                     next
[16:09:34.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.782]                 }
[16:09:34.782]                 NAMES <- toupper(added)
[16:09:34.782]                 for (kk in seq_along(NAMES)) {
[16:09:34.782]                   name <- added[[kk]]
[16:09:34.782]                   NAME <- NAMES[[kk]]
[16:09:34.782]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.782]                     next
[16:09:34.782]                   args[[name]] <- ""
[16:09:34.782]                 }
[16:09:34.782]                 NAMES <- toupper(removed)
[16:09:34.782]                 for (kk in seq_along(NAMES)) {
[16:09:34.782]                   name <- removed[[kk]]
[16:09:34.782]                   NAME <- NAMES[[kk]]
[16:09:34.782]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.782]                     next
[16:09:34.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.782]                 }
[16:09:34.782]                 if (length(args) > 0) 
[16:09:34.782]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.782]             }
[16:09:34.782]             else {
[16:09:34.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.782]             }
[16:09:34.782]             {
[16:09:34.782]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.782]                   0L) {
[16:09:34.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.782]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.782]                   base::options(opts)
[16:09:34.782]                 }
[16:09:34.782]                 {
[16:09:34.782]                   {
[16:09:34.782]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.782]                     NULL
[16:09:34.782]                   }
[16:09:34.782]                   options(future.plan = NULL)
[16:09:34.782]                   if (is.na(NA_character_)) 
[16:09:34.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.782]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.782]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.782]                     envir = parent.frame()) 
[16:09:34.782]                   {
[16:09:34.782]                     if (is.function(workers)) 
[16:09:34.782]                       workers <- workers()
[16:09:34.782]                     workers <- structure(as.integer(workers), 
[16:09:34.782]                       class = class(workers))
[16:09:34.782]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.782]                       workers >= 1)
[16:09:34.782]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.782]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.782]                     }
[16:09:34.782]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.782]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.782]                       envir = envir)
[16:09:34.782]                     if (!future$lazy) 
[16:09:34.782]                       future <- run(future)
[16:09:34.782]                     invisible(future)
[16:09:34.782]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.782]                 }
[16:09:34.782]             }
[16:09:34.782]         }
[16:09:34.782]     })
[16:09:34.782]     if (TRUE) {
[16:09:34.782]         base::sink(type = "output", split = FALSE)
[16:09:34.782]         if (TRUE) {
[16:09:34.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.782]         }
[16:09:34.782]         else {
[16:09:34.782]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.782]         }
[16:09:34.782]         base::close(...future.stdout)
[16:09:34.782]         ...future.stdout <- NULL
[16:09:34.782]     }
[16:09:34.782]     ...future.result$conditions <- ...future.conditions
[16:09:34.782]     ...future.result$finished <- base::Sys.time()
[16:09:34.782]     ...future.result
[16:09:34.782] }
[16:09:34.785] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[16:09:34.785] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:09:34.786] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:09:34.786] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:09:34.786] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:09:34.786] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[16:09:34.786] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[16:09:34.787] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:34.787] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.787] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:34.787] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.787] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[16:09:34.788] MultisessionFuture started
[16:09:34.788] - Launch lazy future ... done
[16:09:34.788] run() for ‘MultisessionFuture’ ... done
[16:09:34.788] Created future:
[16:09:34.788] MultisessionFuture:
[16:09:34.788] Label: ‘future_by-2’
[16:09:34.788] Expression:
[16:09:34.788] {
[16:09:34.788]     do.call(function(...) {
[16:09:34.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.788]             on.exit(options(oopts), add = TRUE)
[16:09:34.788]         }
[16:09:34.788]         {
[16:09:34.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.788]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.788]             })
[16:09:34.788]         }
[16:09:34.788]     }, args = future.call.arguments)
[16:09:34.788] }
[16:09:34.788] Lazy evaluation: FALSE
[16:09:34.788] Asynchronous evaluation: TRUE
[16:09:34.788] Local evaluation: TRUE
[16:09:34.788] Environment: R_GlobalEnv
[16:09:34.788] Capture standard output: TRUE
[16:09:34.788] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:34.788] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:34.788] Packages: <none>
[16:09:34.788] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:34.788] Resolved: FALSE
[16:09:34.788] Value: <not collected>
[16:09:34.788] Conditions captured: <none>
[16:09:34.788] Early signaling: FALSE
[16:09:34.788] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:34.788] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.800] Chunk #2 of 2 ... DONE
[16:09:34.800] Launching 2 futures (chunks) ... DONE
[16:09:34.800] Resolving 2 futures (chunks) ...
[16:09:34.800] resolve() on list ...
[16:09:34.800]  recursive: 0
[16:09:34.800]  length: 2
[16:09:34.800] 
[16:09:34.801] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.801] - Validating connection of MultisessionFuture
[16:09:34.801] - received message: FutureResult
[16:09:34.801] - Received FutureResult
[16:09:34.801] - Erased future from FutureRegistry
[16:09:34.802] result() for ClusterFuture ...
[16:09:34.802] - result already collected: FutureResult
[16:09:34.802] result() for ClusterFuture ... done
[16:09:34.802] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.802] Future #1
[16:09:34.802] result() for ClusterFuture ...
[16:09:34.802] - result already collected: FutureResult
[16:09:34.802] result() for ClusterFuture ... done
[16:09:34.802] result() for ClusterFuture ...
[16:09:34.802] - result already collected: FutureResult
[16:09:34.802] result() for ClusterFuture ... done
[16:09:34.803] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:34.803] - nx: 2
[16:09:34.803] - relay: TRUE
[16:09:34.803] - stdout: TRUE
[16:09:34.803] - signal: TRUE
[16:09:34.803] - resignal: FALSE
[16:09:34.803] - force: TRUE
[16:09:34.803] - relayed: [n=2] FALSE, FALSE
[16:09:34.803] - queued futures: [n=2] FALSE, FALSE
[16:09:34.803]  - until=1
[16:09:34.803]  - relaying element #1
[16:09:34.803] result() for ClusterFuture ...
[16:09:34.804] - result already collected: FutureResult
[16:09:34.804] result() for ClusterFuture ... done
[16:09:34.804] result() for ClusterFuture ...
[16:09:34.804] - result already collected: FutureResult
[16:09:34.804] result() for ClusterFuture ... done
[16:09:34.804] result() for ClusterFuture ...
[16:09:34.804] - result already collected: FutureResult
[16:09:34.804] result() for ClusterFuture ... done
[16:09:34.804] result() for ClusterFuture ...
[16:09:34.804] - result already collected: FutureResult
[16:09:34.804] result() for ClusterFuture ... done
[16:09:34.805] - relayed: [n=2] TRUE, FALSE
[16:09:34.805] - queued futures: [n=2] TRUE, FALSE
[16:09:34.805] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:34.805]  length: 1 (resolved future 1)
[16:09:34.846] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.847] - Validating connection of MultisessionFuture
[16:09:34.847] - received message: FutureResult
[16:09:34.847] - Received FutureResult
[16:09:34.847] - Erased future from FutureRegistry
[16:09:34.847] result() for ClusterFuture ...
[16:09:34.847] - result already collected: FutureResult
[16:09:34.847] result() for ClusterFuture ... done
[16:09:34.847] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.847] Future #2
[16:09:34.848] result() for ClusterFuture ...
[16:09:34.848] - result already collected: FutureResult
[16:09:34.848] result() for ClusterFuture ... done
[16:09:34.848] result() for ClusterFuture ...
[16:09:34.848] - result already collected: FutureResult
[16:09:34.848] result() for ClusterFuture ... done
[16:09:34.848] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:34.848] - nx: 2
[16:09:34.848] - relay: TRUE
[16:09:34.848] - stdout: TRUE
[16:09:34.848] - signal: TRUE
[16:09:34.849] - resignal: FALSE
[16:09:34.849] - force: TRUE
[16:09:34.849] - relayed: [n=2] TRUE, FALSE
[16:09:34.849] - queued futures: [n=2] TRUE, FALSE
[16:09:34.849]  - until=2
[16:09:34.849]  - relaying element #2
[16:09:34.849] result() for ClusterFuture ...
[16:09:34.849] - result already collected: FutureResult
[16:09:34.849] result() for ClusterFuture ... done
[16:09:34.849] result() for ClusterFuture ...
[16:09:34.849] - result already collected: FutureResult
[16:09:34.849] result() for ClusterFuture ... done
[16:09:34.850] result() for ClusterFuture ...
[16:09:34.850] - result already collected: FutureResult
[16:09:34.850] result() for ClusterFuture ... done
[16:09:34.850] result() for ClusterFuture ...
[16:09:34.850] - result already collected: FutureResult
[16:09:34.850] result() for ClusterFuture ... done
[16:09:34.850] - relayed: [n=2] TRUE, TRUE
[16:09:34.850] - queued futures: [n=2] TRUE, TRUE
[16:09:34.850] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:34.850]  length: 0 (resolved future 2)
[16:09:34.850] Relaying remaining futures
[16:09:34.851] signalConditionsASAP(NULL, pos=0) ...
[16:09:34.851] - nx: 2
[16:09:34.851] - relay: TRUE
[16:09:34.851] - stdout: TRUE
[16:09:34.851] - signal: TRUE
[16:09:34.851] - resignal: FALSE
[16:09:34.851] - force: TRUE
[16:09:34.851] - relayed: [n=2] TRUE, TRUE
[16:09:34.851] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:34.851] - relayed: [n=2] TRUE, TRUE
[16:09:34.851] - queued futures: [n=2] TRUE, TRUE
[16:09:34.852] signalConditionsASAP(NULL, pos=0) ... done
[16:09:34.852] resolve() on list ... DONE
[16:09:34.852] result() for ClusterFuture ...
[16:09:34.852] - result already collected: FutureResult
[16:09:34.852] result() for ClusterFuture ... done
[16:09:34.852] result() for ClusterFuture ...
[16:09:34.852] - result already collected: FutureResult
[16:09:34.852] result() for ClusterFuture ... done
[16:09:34.852] result() for ClusterFuture ...
[16:09:34.852] - result already collected: FutureResult
[16:09:34.852] result() for ClusterFuture ... done
[16:09:34.853] result() for ClusterFuture ...
[16:09:34.853] - result already collected: FutureResult
[16:09:34.853] result() for ClusterFuture ... done
[16:09:34.853]  - Number of value chunks collected: 2
[16:09:34.853] Resolving 2 futures (chunks) ... DONE
[16:09:34.853] Reducing values from 2 chunks ...
[16:09:34.853]  - Number of values collected after concatenation: 6
[16:09:34.853]  - Number of values expected: 6
[16:09:34.853] Reducing values from 2 chunks ... DONE
[16:09:34.853] future_lapply() ... DONE
[16:09:34.853] future_by_internal() ... DONE
[16:09:34.854] future_by_internal() ...
[16:09:34.855] future_lapply() ...
[16:09:34.859] Number of chunks: 2
[16:09:34.859] getGlobalsAndPackagesXApply() ...
[16:09:34.859]  - future.globals: TRUE
[16:09:34.859] getGlobalsAndPackages() ...
[16:09:34.860] Searching for globals...
[16:09:34.861] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:34.861] Searching for globals ... DONE
[16:09:34.861] Resolving globals: FALSE
[16:09:34.862] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:09:34.862] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:09:34.862] - globals: [1] ‘FUN’
[16:09:34.862] - packages: [1] ‘stats’
[16:09:34.863] getGlobalsAndPackages() ... DONE
[16:09:34.863]  - globals found/used: [n=1] ‘FUN’
[16:09:34.863]  - needed namespaces: [n=1] ‘stats’
[16:09:34.863] Finding globals ... DONE
[16:09:34.863]  - use_args: TRUE
[16:09:34.863]  - Getting '...' globals ...
[16:09:34.863] resolve() on list ...
[16:09:34.863]  recursive: 0
[16:09:34.864]  length: 1
[16:09:34.864]  elements: ‘...’
[16:09:34.864]  length: 0 (resolved future 1)
[16:09:34.864] resolve() on list ... DONE
[16:09:34.864]    - '...' content: [n=1] ‘singular.ok’
[16:09:34.864] List of 1
[16:09:34.864]  $ ...:List of 1
[16:09:34.864]   ..$ singular.ok: logi FALSE
[16:09:34.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:34.864]  - attr(*, "where")=List of 1
[16:09:34.864]   ..$ ...:<environment: 0x5567e8edf5f8> 
[16:09:34.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:34.864]  - attr(*, "resolved")= logi TRUE
[16:09:34.864]  - attr(*, "total_size")= num NA
[16:09:34.869]  - Getting '...' globals ... DONE
[16:09:34.869] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:34.869] List of 2
[16:09:34.869]  $ ...future.FUN:function (x, ...)  
[16:09:34.869]  $ ...          :List of 1
[16:09:34.869]   ..$ singular.ok: logi FALSE
[16:09:34.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:34.869]  - attr(*, "where")=List of 2
[16:09:34.869]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:34.869]   ..$ ...          :<environment: 0x5567e8edf5f8> 
[16:09:34.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:34.869]  - attr(*, "resolved")= logi FALSE
[16:09:34.869]  - attr(*, "total_size")= num 5384
[16:09:34.872] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:34.872] getGlobalsAndPackagesXApply() ... DONE
[16:09:34.872] Number of futures (= number of chunks): 2
[16:09:34.873] Launching 2 futures (chunks) ...
[16:09:34.873] Chunk #1 of 2 ...
[16:09:34.873]  - Finding globals in 'X' for chunk #1 ...
[16:09:34.873] getGlobalsAndPackages() ...
[16:09:34.873] Searching for globals...
[16:09:34.873] 
[16:09:34.873] Searching for globals ... DONE
[16:09:34.873] - globals: [0] <none>
[16:09:34.874] getGlobalsAndPackages() ... DONE
[16:09:34.874]    + additional globals found: [n=0] 
[16:09:34.874]    + additional namespaces needed: [n=0] 
[16:09:34.874]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:34.874]  - seeds: <none>
[16:09:34.874] getGlobalsAndPackages() ...
[16:09:34.874] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.874] Resolving globals: FALSE
[16:09:34.874] Tweak future expression to call with '...' arguments ...
[16:09:34.874] {
[16:09:34.874]     do.call(function(...) {
[16:09:34.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.874]             on.exit(options(oopts), add = TRUE)
[16:09:34.874]         }
[16:09:34.874]         {
[16:09:34.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.874]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.874]             })
[16:09:34.874]         }
[16:09:34.874]     }, args = future.call.arguments)
[16:09:34.874] }
[16:09:34.875] Tweak future expression to call with '...' arguments ... DONE
[16:09:34.875] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.875] 
[16:09:34.875] getGlobalsAndPackages() ... DONE
[16:09:34.876] run() for ‘Future’ ...
[16:09:34.876] - state: ‘created’
[16:09:34.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:34.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:34.890]   - Field: ‘node’
[16:09:34.890]   - Field: ‘label’
[16:09:34.890]   - Field: ‘local’
[16:09:34.890]   - Field: ‘owner’
[16:09:34.890]   - Field: ‘envir’
[16:09:34.890]   - Field: ‘workers’
[16:09:34.890]   - Field: ‘packages’
[16:09:34.891]   - Field: ‘gc’
[16:09:34.891]   - Field: ‘conditions’
[16:09:34.891]   - Field: ‘persistent’
[16:09:34.891]   - Field: ‘expr’
[16:09:34.891]   - Field: ‘uuid’
[16:09:34.891]   - Field: ‘seed’
[16:09:34.891]   - Field: ‘version’
[16:09:34.891]   - Field: ‘result’
[16:09:34.891]   - Field: ‘asynchronous’
[16:09:34.891]   - Field: ‘calls’
[16:09:34.891]   - Field: ‘globals’
[16:09:34.892]   - Field: ‘stdout’
[16:09:34.892]   - Field: ‘earlySignal’
[16:09:34.892]   - Field: ‘lazy’
[16:09:34.892]   - Field: ‘state’
[16:09:34.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:34.892] - Launch lazy future ...
[16:09:34.892] Packages needed by the future expression (n = 1): ‘stats’
[16:09:34.892] Packages needed by future strategies (n = 0): <none>
[16:09:34.893] {
[16:09:34.893]     {
[16:09:34.893]         {
[16:09:34.893]             ...future.startTime <- base::Sys.time()
[16:09:34.893]             {
[16:09:34.893]                 {
[16:09:34.893]                   {
[16:09:34.893]                     {
[16:09:34.893]                       {
[16:09:34.893]                         base::local({
[16:09:34.893]                           has_future <- base::requireNamespace("future", 
[16:09:34.893]                             quietly = TRUE)
[16:09:34.893]                           if (has_future) {
[16:09:34.893]                             ns <- base::getNamespace("future")
[16:09:34.893]                             version <- ns[[".package"]][["version"]]
[16:09:34.893]                             if (is.null(version)) 
[16:09:34.893]                               version <- utils::packageVersion("future")
[16:09:34.893]                           }
[16:09:34.893]                           else {
[16:09:34.893]                             version <- NULL
[16:09:34.893]                           }
[16:09:34.893]                           if (!has_future || version < "1.8.0") {
[16:09:34.893]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.893]                               "", base::R.version$version.string), 
[16:09:34.893]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:34.893]                                 base::R.version$platform, 8 * 
[16:09:34.893]                                   base::.Machine$sizeof.pointer), 
[16:09:34.893]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.893]                                 "release", "version")], collapse = " "), 
[16:09:34.893]                               hostname = base::Sys.info()[["nodename"]])
[16:09:34.893]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.893]                               info)
[16:09:34.893]                             info <- base::paste(info, collapse = "; ")
[16:09:34.893]                             if (!has_future) {
[16:09:34.893]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.893]                                 info)
[16:09:34.893]                             }
[16:09:34.893]                             else {
[16:09:34.893]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.893]                                 info, version)
[16:09:34.893]                             }
[16:09:34.893]                             base::stop(msg)
[16:09:34.893]                           }
[16:09:34.893]                         })
[16:09:34.893]                       }
[16:09:34.893]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.893]                       base::options(mc.cores = 1L)
[16:09:34.893]                     }
[16:09:34.893]                     base::local({
[16:09:34.893]                       for (pkg in "stats") {
[16:09:34.893]                         base::loadNamespace(pkg)
[16:09:34.893]                         base::library(pkg, character.only = TRUE)
[16:09:34.893]                       }
[16:09:34.893]                     })
[16:09:34.893]                   }
[16:09:34.893]                   options(future.plan = NULL)
[16:09:34.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.893]                 }
[16:09:34.893]                 ...future.workdir <- getwd()
[16:09:34.893]             }
[16:09:34.893]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.893]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.893]         }
[16:09:34.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:34.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.893]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.893]             base::names(...future.oldOptions))
[16:09:34.893]     }
[16:09:34.893]     if (FALSE) {
[16:09:34.893]     }
[16:09:34.893]     else {
[16:09:34.893]         if (TRUE) {
[16:09:34.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.893]                 open = "w")
[16:09:34.893]         }
[16:09:34.893]         else {
[16:09:34.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.893]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.893]         }
[16:09:34.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.893]             base::sink(type = "output", split = FALSE)
[16:09:34.893]             base::close(...future.stdout)
[16:09:34.893]         }, add = TRUE)
[16:09:34.893]     }
[16:09:34.893]     ...future.frame <- base::sys.nframe()
[16:09:34.893]     ...future.conditions <- base::list()
[16:09:34.893]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.893]     if (FALSE) {
[16:09:34.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.893]     }
[16:09:34.893]     ...future.result <- base::tryCatch({
[16:09:34.893]         base::withCallingHandlers({
[16:09:34.893]             ...future.value <- base::withVisible(base::local({
[16:09:34.893]                 ...future.makeSendCondition <- local({
[16:09:34.893]                   sendCondition <- NULL
[16:09:34.893]                   function(frame = 1L) {
[16:09:34.893]                     if (is.function(sendCondition)) 
[16:09:34.893]                       return(sendCondition)
[16:09:34.893]                     ns <- getNamespace("parallel")
[16:09:34.893]                     if (exists("sendData", mode = "function", 
[16:09:34.893]                       envir = ns)) {
[16:09:34.893]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.893]                         envir = ns)
[16:09:34.893]                       envir <- sys.frame(frame)
[16:09:34.893]                       master <- NULL
[16:09:34.893]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.893]                         !identical(envir, emptyenv())) {
[16:09:34.893]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.893]                           inherits = FALSE)) {
[16:09:34.893]                           master <- get("master", mode = "list", 
[16:09:34.893]                             envir = envir, inherits = FALSE)
[16:09:34.893]                           if (inherits(master, c("SOCKnode", 
[16:09:34.893]                             "SOCK0node"))) {
[16:09:34.893]                             sendCondition <<- function(cond) {
[16:09:34.893]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.893]                                 success = TRUE)
[16:09:34.893]                               parallel_sendData(master, data)
[16:09:34.893]                             }
[16:09:34.893]                             return(sendCondition)
[16:09:34.893]                           }
[16:09:34.893]                         }
[16:09:34.893]                         frame <- frame + 1L
[16:09:34.893]                         envir <- sys.frame(frame)
[16:09:34.893]                       }
[16:09:34.893]                     }
[16:09:34.893]                     sendCondition <<- function(cond) NULL
[16:09:34.893]                   }
[16:09:34.893]                 })
[16:09:34.893]                 withCallingHandlers({
[16:09:34.893]                   {
[16:09:34.893]                     do.call(function(...) {
[16:09:34.893]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.893]                       if (!identical(...future.globals.maxSize.org, 
[16:09:34.893]                         ...future.globals.maxSize)) {
[16:09:34.893]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.893]                         on.exit(options(oopts), add = TRUE)
[16:09:34.893]                       }
[16:09:34.893]                       {
[16:09:34.893]                         lapply(seq_along(...future.elements_ii), 
[16:09:34.893]                           FUN = function(jj) {
[16:09:34.893]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.893]                             ...future.FUN(...future.X_jj, ...)
[16:09:34.893]                           })
[16:09:34.893]                       }
[16:09:34.893]                     }, args = future.call.arguments)
[16:09:34.893]                   }
[16:09:34.893]                 }, immediateCondition = function(cond) {
[16:09:34.893]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.893]                   sendCondition(cond)
[16:09:34.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.893]                   {
[16:09:34.893]                     inherits <- base::inherits
[16:09:34.893]                     invokeRestart <- base::invokeRestart
[16:09:34.893]                     is.null <- base::is.null
[16:09:34.893]                     muffled <- FALSE
[16:09:34.893]                     if (inherits(cond, "message")) {
[16:09:34.893]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.893]                       if (muffled) 
[16:09:34.893]                         invokeRestart("muffleMessage")
[16:09:34.893]                     }
[16:09:34.893]                     else if (inherits(cond, "warning")) {
[16:09:34.893]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.893]                       if (muffled) 
[16:09:34.893]                         invokeRestart("muffleWarning")
[16:09:34.893]                     }
[16:09:34.893]                     else if (inherits(cond, "condition")) {
[16:09:34.893]                       if (!is.null(pattern)) {
[16:09:34.893]                         computeRestarts <- base::computeRestarts
[16:09:34.893]                         grepl <- base::grepl
[16:09:34.893]                         restarts <- computeRestarts(cond)
[16:09:34.893]                         for (restart in restarts) {
[16:09:34.893]                           name <- restart$name
[16:09:34.893]                           if (is.null(name)) 
[16:09:34.893]                             next
[16:09:34.893]                           if (!grepl(pattern, name)) 
[16:09:34.893]                             next
[16:09:34.893]                           invokeRestart(restart)
[16:09:34.893]                           muffled <- TRUE
[16:09:34.893]                           break
[16:09:34.893]                         }
[16:09:34.893]                       }
[16:09:34.893]                     }
[16:09:34.893]                     invisible(muffled)
[16:09:34.893]                   }
[16:09:34.893]                   muffleCondition(cond)
[16:09:34.893]                 })
[16:09:34.893]             }))
[16:09:34.893]             future::FutureResult(value = ...future.value$value, 
[16:09:34.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.893]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.893]                     ...future.globalenv.names))
[16:09:34.893]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.893]         }, condition = base::local({
[16:09:34.893]             c <- base::c
[16:09:34.893]             inherits <- base::inherits
[16:09:34.893]             invokeRestart <- base::invokeRestart
[16:09:34.893]             length <- base::length
[16:09:34.893]             list <- base::list
[16:09:34.893]             seq.int <- base::seq.int
[16:09:34.893]             signalCondition <- base::signalCondition
[16:09:34.893]             sys.calls <- base::sys.calls
[16:09:34.893]             `[[` <- base::`[[`
[16:09:34.893]             `+` <- base::`+`
[16:09:34.893]             `<<-` <- base::`<<-`
[16:09:34.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.893]                   3L)]
[16:09:34.893]             }
[16:09:34.893]             function(cond) {
[16:09:34.893]                 is_error <- inherits(cond, "error")
[16:09:34.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.893]                   NULL)
[16:09:34.893]                 if (is_error) {
[16:09:34.893]                   sessionInformation <- function() {
[16:09:34.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.893]                       search = base::search(), system = base::Sys.info())
[16:09:34.893]                   }
[16:09:34.893]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.893]                     cond$call), session = sessionInformation(), 
[16:09:34.893]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.893]                   signalCondition(cond)
[16:09:34.893]                 }
[16:09:34.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.893]                 "immediateCondition"))) {
[16:09:34.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.893]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.893]                   if (TRUE && !signal) {
[16:09:34.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.893]                     {
[16:09:34.893]                       inherits <- base::inherits
[16:09:34.893]                       invokeRestart <- base::invokeRestart
[16:09:34.893]                       is.null <- base::is.null
[16:09:34.893]                       muffled <- FALSE
[16:09:34.893]                       if (inherits(cond, "message")) {
[16:09:34.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.893]                         if (muffled) 
[16:09:34.893]                           invokeRestart("muffleMessage")
[16:09:34.893]                       }
[16:09:34.893]                       else if (inherits(cond, "warning")) {
[16:09:34.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.893]                         if (muffled) 
[16:09:34.893]                           invokeRestart("muffleWarning")
[16:09:34.893]                       }
[16:09:34.893]                       else if (inherits(cond, "condition")) {
[16:09:34.893]                         if (!is.null(pattern)) {
[16:09:34.893]                           computeRestarts <- base::computeRestarts
[16:09:34.893]                           grepl <- base::grepl
[16:09:34.893]                           restarts <- computeRestarts(cond)
[16:09:34.893]                           for (restart in restarts) {
[16:09:34.893]                             name <- restart$name
[16:09:34.893]                             if (is.null(name)) 
[16:09:34.893]                               next
[16:09:34.893]                             if (!grepl(pattern, name)) 
[16:09:34.893]                               next
[16:09:34.893]                             invokeRestart(restart)
[16:09:34.893]                             muffled <- TRUE
[16:09:34.893]                             break
[16:09:34.893]                           }
[16:09:34.893]                         }
[16:09:34.893]                       }
[16:09:34.893]                       invisible(muffled)
[16:09:34.893]                     }
[16:09:34.893]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.893]                   }
[16:09:34.893]                 }
[16:09:34.893]                 else {
[16:09:34.893]                   if (TRUE) {
[16:09:34.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.893]                     {
[16:09:34.893]                       inherits <- base::inherits
[16:09:34.893]                       invokeRestart <- base::invokeRestart
[16:09:34.893]                       is.null <- base::is.null
[16:09:34.893]                       muffled <- FALSE
[16:09:34.893]                       if (inherits(cond, "message")) {
[16:09:34.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.893]                         if (muffled) 
[16:09:34.893]                           invokeRestart("muffleMessage")
[16:09:34.893]                       }
[16:09:34.893]                       else if (inherits(cond, "warning")) {
[16:09:34.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.893]                         if (muffled) 
[16:09:34.893]                           invokeRestart("muffleWarning")
[16:09:34.893]                       }
[16:09:34.893]                       else if (inherits(cond, "condition")) {
[16:09:34.893]                         if (!is.null(pattern)) {
[16:09:34.893]                           computeRestarts <- base::computeRestarts
[16:09:34.893]                           grepl <- base::grepl
[16:09:34.893]                           restarts <- computeRestarts(cond)
[16:09:34.893]                           for (restart in restarts) {
[16:09:34.893]                             name <- restart$name
[16:09:34.893]                             if (is.null(name)) 
[16:09:34.893]                               next
[16:09:34.893]                             if (!grepl(pattern, name)) 
[16:09:34.893]                               next
[16:09:34.893]                             invokeRestart(restart)
[16:09:34.893]                             muffled <- TRUE
[16:09:34.893]                             break
[16:09:34.893]                           }
[16:09:34.893]                         }
[16:09:34.893]                       }
[16:09:34.893]                       invisible(muffled)
[16:09:34.893]                     }
[16:09:34.893]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.893]                   }
[16:09:34.893]                 }
[16:09:34.893]             }
[16:09:34.893]         }))
[16:09:34.893]     }, error = function(ex) {
[16:09:34.893]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.893]                 ...future.rng), started = ...future.startTime, 
[16:09:34.893]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.893]             version = "1.8"), class = "FutureResult")
[16:09:34.893]     }, finally = {
[16:09:34.893]         if (!identical(...future.workdir, getwd())) 
[16:09:34.893]             setwd(...future.workdir)
[16:09:34.893]         {
[16:09:34.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.893]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.893]             }
[16:09:34.893]             base::options(...future.oldOptions)
[16:09:34.893]             if (.Platform$OS.type == "windows") {
[16:09:34.893]                 old_names <- names(...future.oldEnvVars)
[16:09:34.893]                 envs <- base::Sys.getenv()
[16:09:34.893]                 names <- names(envs)
[16:09:34.893]                 common <- intersect(names, old_names)
[16:09:34.893]                 added <- setdiff(names, old_names)
[16:09:34.893]                 removed <- setdiff(old_names, names)
[16:09:34.893]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.893]                   envs[common]]
[16:09:34.893]                 NAMES <- toupper(changed)
[16:09:34.893]                 args <- list()
[16:09:34.893]                 for (kk in seq_along(NAMES)) {
[16:09:34.893]                   name <- changed[[kk]]
[16:09:34.893]                   NAME <- NAMES[[kk]]
[16:09:34.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.893]                     next
[16:09:34.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.893]                 }
[16:09:34.893]                 NAMES <- toupper(added)
[16:09:34.893]                 for (kk in seq_along(NAMES)) {
[16:09:34.893]                   name <- added[[kk]]
[16:09:34.893]                   NAME <- NAMES[[kk]]
[16:09:34.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.893]                     next
[16:09:34.893]                   args[[name]] <- ""
[16:09:34.893]                 }
[16:09:34.893]                 NAMES <- toupper(removed)
[16:09:34.893]                 for (kk in seq_along(NAMES)) {
[16:09:34.893]                   name <- removed[[kk]]
[16:09:34.893]                   NAME <- NAMES[[kk]]
[16:09:34.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.893]                     next
[16:09:34.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.893]                 }
[16:09:34.893]                 if (length(args) > 0) 
[16:09:34.893]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.893]             }
[16:09:34.893]             else {
[16:09:34.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.893]             }
[16:09:34.893]             {
[16:09:34.893]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.893]                   0L) {
[16:09:34.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.893]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.893]                   base::options(opts)
[16:09:34.893]                 }
[16:09:34.893]                 {
[16:09:34.893]                   {
[16:09:34.893]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.893]                     NULL
[16:09:34.893]                   }
[16:09:34.893]                   options(future.plan = NULL)
[16:09:34.893]                   if (is.na(NA_character_)) 
[16:09:34.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.893]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.893]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.893]                     envir = parent.frame()) 
[16:09:34.893]                   {
[16:09:34.893]                     if (is.function(workers)) 
[16:09:34.893]                       workers <- workers()
[16:09:34.893]                     workers <- structure(as.integer(workers), 
[16:09:34.893]                       class = class(workers))
[16:09:34.893]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.893]                       workers >= 1)
[16:09:34.893]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.893]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.893]                     }
[16:09:34.893]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.893]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.893]                       envir = envir)
[16:09:34.893]                     if (!future$lazy) 
[16:09:34.893]                       future <- run(future)
[16:09:34.893]                     invisible(future)
[16:09:34.893]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.893]                 }
[16:09:34.893]             }
[16:09:34.893]         }
[16:09:34.893]     })
[16:09:34.893]     if (TRUE) {
[16:09:34.893]         base::sink(type = "output", split = FALSE)
[16:09:34.893]         if (TRUE) {
[16:09:34.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.893]         }
[16:09:34.893]         else {
[16:09:34.893]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.893]         }
[16:09:34.893]         base::close(...future.stdout)
[16:09:34.893]         ...future.stdout <- NULL
[16:09:34.893]     }
[16:09:34.893]     ...future.result$conditions <- ...future.conditions
[16:09:34.893]     ...future.result$finished <- base::Sys.time()
[16:09:34.893]     ...future.result
[16:09:34.893] }
[16:09:34.896] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[16:09:34.896] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[16:09:34.896] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[16:09:34.897] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:09:34.897] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:09:34.897] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:09:34.897] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:09:34.898] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:34.898] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.898] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:34.898] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:34.898] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[16:09:34.899] MultisessionFuture started
[16:09:34.899] - Launch lazy future ... done
[16:09:34.899] run() for ‘MultisessionFuture’ ... done
[16:09:34.899] Created future:
[16:09:34.899] MultisessionFuture:
[16:09:34.899] Label: ‘future_by-1’
[16:09:34.899] Expression:
[16:09:34.899] {
[16:09:34.899]     do.call(function(...) {
[16:09:34.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.899]             on.exit(options(oopts), add = TRUE)
[16:09:34.899]         }
[16:09:34.899]         {
[16:09:34.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.899]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.899]             })
[16:09:34.899]         }
[16:09:34.899]     }, args = future.call.arguments)
[16:09:34.899] }
[16:09:34.899] Lazy evaluation: FALSE
[16:09:34.899] Asynchronous evaluation: TRUE
[16:09:34.899] Local evaluation: TRUE
[16:09:34.899] Environment: R_GlobalEnv
[16:09:34.899] Capture standard output: TRUE
[16:09:34.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:34.899] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:34.899] Packages: 1 packages (‘stats’)
[16:09:34.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:34.899] Resolved: FALSE
[16:09:34.899] Value: <not collected>
[16:09:34.899] Conditions captured: <none>
[16:09:34.899] Early signaling: FALSE
[16:09:34.899] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:34.899] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.911] Chunk #1 of 2 ... DONE
[16:09:34.911] Chunk #2 of 2 ...
[16:09:34.911]  - Finding globals in 'X' for chunk #2 ...
[16:09:34.911] getGlobalsAndPackages() ...
[16:09:34.911] Searching for globals...
[16:09:34.912] 
[16:09:34.912] Searching for globals ... DONE
[16:09:34.912] - globals: [0] <none>
[16:09:34.912] getGlobalsAndPackages() ... DONE
[16:09:34.912]    + additional globals found: [n=0] 
[16:09:34.912]    + additional namespaces needed: [n=0] 
[16:09:34.912]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:34.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:34.913]  - seeds: <none>
[16:09:34.913] getGlobalsAndPackages() ...
[16:09:34.913] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.913] Resolving globals: FALSE
[16:09:34.913] Tweak future expression to call with '...' arguments ...
[16:09:34.913] {
[16:09:34.913]     do.call(function(...) {
[16:09:34.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.913]             on.exit(options(oopts), add = TRUE)
[16:09:34.913]         }
[16:09:34.913]         {
[16:09:34.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.913]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.913]             })
[16:09:34.913]         }
[16:09:34.913]     }, args = future.call.arguments)
[16:09:34.913] }
[16:09:34.913] Tweak future expression to call with '...' arguments ... DONE
[16:09:34.914] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:34.914] 
[16:09:34.914] getGlobalsAndPackages() ... DONE
[16:09:34.914] run() for ‘Future’ ...
[16:09:34.914] - state: ‘created’
[16:09:34.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:34.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:34.929]   - Field: ‘node’
[16:09:34.929]   - Field: ‘label’
[16:09:34.929]   - Field: ‘local’
[16:09:34.929]   - Field: ‘owner’
[16:09:34.929]   - Field: ‘envir’
[16:09:34.929]   - Field: ‘workers’
[16:09:34.929]   - Field: ‘packages’
[16:09:34.930]   - Field: ‘gc’
[16:09:34.930]   - Field: ‘conditions’
[16:09:34.930]   - Field: ‘persistent’
[16:09:34.930]   - Field: ‘expr’
[16:09:34.930]   - Field: ‘uuid’
[16:09:34.930]   - Field: ‘seed’
[16:09:34.930]   - Field: ‘version’
[16:09:34.930]   - Field: ‘result’
[16:09:34.930]   - Field: ‘asynchronous’
[16:09:34.930]   - Field: ‘calls’
[16:09:34.930]   - Field: ‘globals’
[16:09:34.931]   - Field: ‘stdout’
[16:09:34.931]   - Field: ‘earlySignal’
[16:09:34.931]   - Field: ‘lazy’
[16:09:34.931]   - Field: ‘state’
[16:09:34.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:34.931] - Launch lazy future ...
[16:09:34.931] Packages needed by the future expression (n = 1): ‘stats’
[16:09:34.931] Packages needed by future strategies (n = 0): <none>
[16:09:34.932] {
[16:09:34.932]     {
[16:09:34.932]         {
[16:09:34.932]             ...future.startTime <- base::Sys.time()
[16:09:34.932]             {
[16:09:34.932]                 {
[16:09:34.932]                   {
[16:09:34.932]                     {
[16:09:34.932]                       {
[16:09:34.932]                         base::local({
[16:09:34.932]                           has_future <- base::requireNamespace("future", 
[16:09:34.932]                             quietly = TRUE)
[16:09:34.932]                           if (has_future) {
[16:09:34.932]                             ns <- base::getNamespace("future")
[16:09:34.932]                             version <- ns[[".package"]][["version"]]
[16:09:34.932]                             if (is.null(version)) 
[16:09:34.932]                               version <- utils::packageVersion("future")
[16:09:34.932]                           }
[16:09:34.932]                           else {
[16:09:34.932]                             version <- NULL
[16:09:34.932]                           }
[16:09:34.932]                           if (!has_future || version < "1.8.0") {
[16:09:34.932]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:34.932]                               "", base::R.version$version.string), 
[16:09:34.932]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:34.932]                                 base::R.version$platform, 8 * 
[16:09:34.932]                                   base::.Machine$sizeof.pointer), 
[16:09:34.932]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:34.932]                                 "release", "version")], collapse = " "), 
[16:09:34.932]                               hostname = base::Sys.info()[["nodename"]])
[16:09:34.932]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:34.932]                               info)
[16:09:34.932]                             info <- base::paste(info, collapse = "; ")
[16:09:34.932]                             if (!has_future) {
[16:09:34.932]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:34.932]                                 info)
[16:09:34.932]                             }
[16:09:34.932]                             else {
[16:09:34.932]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:34.932]                                 info, version)
[16:09:34.932]                             }
[16:09:34.932]                             base::stop(msg)
[16:09:34.932]                           }
[16:09:34.932]                         })
[16:09:34.932]                       }
[16:09:34.932]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:34.932]                       base::options(mc.cores = 1L)
[16:09:34.932]                     }
[16:09:34.932]                     base::local({
[16:09:34.932]                       for (pkg in "stats") {
[16:09:34.932]                         base::loadNamespace(pkg)
[16:09:34.932]                         base::library(pkg, character.only = TRUE)
[16:09:34.932]                       }
[16:09:34.932]                     })
[16:09:34.932]                   }
[16:09:34.932]                   options(future.plan = NULL)
[16:09:34.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:34.932]                 }
[16:09:34.932]                 ...future.workdir <- getwd()
[16:09:34.932]             }
[16:09:34.932]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:34.932]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:34.932]         }
[16:09:34.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:34.932]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:34.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:34.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:34.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:34.932]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:34.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:34.932]             base::names(...future.oldOptions))
[16:09:34.932]     }
[16:09:34.932]     if (FALSE) {
[16:09:34.932]     }
[16:09:34.932]     else {
[16:09:34.932]         if (TRUE) {
[16:09:34.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:34.932]                 open = "w")
[16:09:34.932]         }
[16:09:34.932]         else {
[16:09:34.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:34.932]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:34.932]         }
[16:09:34.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:34.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:34.932]             base::sink(type = "output", split = FALSE)
[16:09:34.932]             base::close(...future.stdout)
[16:09:34.932]         }, add = TRUE)
[16:09:34.932]     }
[16:09:34.932]     ...future.frame <- base::sys.nframe()
[16:09:34.932]     ...future.conditions <- base::list()
[16:09:34.932]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:34.932]     if (FALSE) {
[16:09:34.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:34.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:34.932]     }
[16:09:34.932]     ...future.result <- base::tryCatch({
[16:09:34.932]         base::withCallingHandlers({
[16:09:34.932]             ...future.value <- base::withVisible(base::local({
[16:09:34.932]                 ...future.makeSendCondition <- local({
[16:09:34.932]                   sendCondition <- NULL
[16:09:34.932]                   function(frame = 1L) {
[16:09:34.932]                     if (is.function(sendCondition)) 
[16:09:34.932]                       return(sendCondition)
[16:09:34.932]                     ns <- getNamespace("parallel")
[16:09:34.932]                     if (exists("sendData", mode = "function", 
[16:09:34.932]                       envir = ns)) {
[16:09:34.932]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:34.932]                         envir = ns)
[16:09:34.932]                       envir <- sys.frame(frame)
[16:09:34.932]                       master <- NULL
[16:09:34.932]                       while (!identical(envir, .GlobalEnv) && 
[16:09:34.932]                         !identical(envir, emptyenv())) {
[16:09:34.932]                         if (exists("master", mode = "list", envir = envir, 
[16:09:34.932]                           inherits = FALSE)) {
[16:09:34.932]                           master <- get("master", mode = "list", 
[16:09:34.932]                             envir = envir, inherits = FALSE)
[16:09:34.932]                           if (inherits(master, c("SOCKnode", 
[16:09:34.932]                             "SOCK0node"))) {
[16:09:34.932]                             sendCondition <<- function(cond) {
[16:09:34.932]                               data <- list(type = "VALUE", value = cond, 
[16:09:34.932]                                 success = TRUE)
[16:09:34.932]                               parallel_sendData(master, data)
[16:09:34.932]                             }
[16:09:34.932]                             return(sendCondition)
[16:09:34.932]                           }
[16:09:34.932]                         }
[16:09:34.932]                         frame <- frame + 1L
[16:09:34.932]                         envir <- sys.frame(frame)
[16:09:34.932]                       }
[16:09:34.932]                     }
[16:09:34.932]                     sendCondition <<- function(cond) NULL
[16:09:34.932]                   }
[16:09:34.932]                 })
[16:09:34.932]                 withCallingHandlers({
[16:09:34.932]                   {
[16:09:34.932]                     do.call(function(...) {
[16:09:34.932]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.932]                       if (!identical(...future.globals.maxSize.org, 
[16:09:34.932]                         ...future.globals.maxSize)) {
[16:09:34.932]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.932]                         on.exit(options(oopts), add = TRUE)
[16:09:34.932]                       }
[16:09:34.932]                       {
[16:09:34.932]                         lapply(seq_along(...future.elements_ii), 
[16:09:34.932]                           FUN = function(jj) {
[16:09:34.932]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.932]                             ...future.FUN(...future.X_jj, ...)
[16:09:34.932]                           })
[16:09:34.932]                       }
[16:09:34.932]                     }, args = future.call.arguments)
[16:09:34.932]                   }
[16:09:34.932]                 }, immediateCondition = function(cond) {
[16:09:34.932]                   sendCondition <- ...future.makeSendCondition()
[16:09:34.932]                   sendCondition(cond)
[16:09:34.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.932]                   {
[16:09:34.932]                     inherits <- base::inherits
[16:09:34.932]                     invokeRestart <- base::invokeRestart
[16:09:34.932]                     is.null <- base::is.null
[16:09:34.932]                     muffled <- FALSE
[16:09:34.932]                     if (inherits(cond, "message")) {
[16:09:34.932]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:34.932]                       if (muffled) 
[16:09:34.932]                         invokeRestart("muffleMessage")
[16:09:34.932]                     }
[16:09:34.932]                     else if (inherits(cond, "warning")) {
[16:09:34.932]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:34.932]                       if (muffled) 
[16:09:34.932]                         invokeRestart("muffleWarning")
[16:09:34.932]                     }
[16:09:34.932]                     else if (inherits(cond, "condition")) {
[16:09:34.932]                       if (!is.null(pattern)) {
[16:09:34.932]                         computeRestarts <- base::computeRestarts
[16:09:34.932]                         grepl <- base::grepl
[16:09:34.932]                         restarts <- computeRestarts(cond)
[16:09:34.932]                         for (restart in restarts) {
[16:09:34.932]                           name <- restart$name
[16:09:34.932]                           if (is.null(name)) 
[16:09:34.932]                             next
[16:09:34.932]                           if (!grepl(pattern, name)) 
[16:09:34.932]                             next
[16:09:34.932]                           invokeRestart(restart)
[16:09:34.932]                           muffled <- TRUE
[16:09:34.932]                           break
[16:09:34.932]                         }
[16:09:34.932]                       }
[16:09:34.932]                     }
[16:09:34.932]                     invisible(muffled)
[16:09:34.932]                   }
[16:09:34.932]                   muffleCondition(cond)
[16:09:34.932]                 })
[16:09:34.932]             }))
[16:09:34.932]             future::FutureResult(value = ...future.value$value, 
[16:09:34.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.932]                   ...future.rng), globalenv = if (FALSE) 
[16:09:34.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:34.932]                     ...future.globalenv.names))
[16:09:34.932]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:34.932]         }, condition = base::local({
[16:09:34.932]             c <- base::c
[16:09:34.932]             inherits <- base::inherits
[16:09:34.932]             invokeRestart <- base::invokeRestart
[16:09:34.932]             length <- base::length
[16:09:34.932]             list <- base::list
[16:09:34.932]             seq.int <- base::seq.int
[16:09:34.932]             signalCondition <- base::signalCondition
[16:09:34.932]             sys.calls <- base::sys.calls
[16:09:34.932]             `[[` <- base::`[[`
[16:09:34.932]             `+` <- base::`+`
[16:09:34.932]             `<<-` <- base::`<<-`
[16:09:34.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:34.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:34.932]                   3L)]
[16:09:34.932]             }
[16:09:34.932]             function(cond) {
[16:09:34.932]                 is_error <- inherits(cond, "error")
[16:09:34.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:34.932]                   NULL)
[16:09:34.932]                 if (is_error) {
[16:09:34.932]                   sessionInformation <- function() {
[16:09:34.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:34.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:34.932]                       search = base::search(), system = base::Sys.info())
[16:09:34.932]                   }
[16:09:34.932]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:34.932]                     cond$call), session = sessionInformation(), 
[16:09:34.932]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:34.932]                   signalCondition(cond)
[16:09:34.932]                 }
[16:09:34.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:34.932]                 "immediateCondition"))) {
[16:09:34.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:34.932]                   ...future.conditions[[length(...future.conditions) + 
[16:09:34.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:34.932]                   if (TRUE && !signal) {
[16:09:34.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.932]                     {
[16:09:34.932]                       inherits <- base::inherits
[16:09:34.932]                       invokeRestart <- base::invokeRestart
[16:09:34.932]                       is.null <- base::is.null
[16:09:34.932]                       muffled <- FALSE
[16:09:34.932]                       if (inherits(cond, "message")) {
[16:09:34.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.932]                         if (muffled) 
[16:09:34.932]                           invokeRestart("muffleMessage")
[16:09:34.932]                       }
[16:09:34.932]                       else if (inherits(cond, "warning")) {
[16:09:34.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.932]                         if (muffled) 
[16:09:34.932]                           invokeRestart("muffleWarning")
[16:09:34.932]                       }
[16:09:34.932]                       else if (inherits(cond, "condition")) {
[16:09:34.932]                         if (!is.null(pattern)) {
[16:09:34.932]                           computeRestarts <- base::computeRestarts
[16:09:34.932]                           grepl <- base::grepl
[16:09:34.932]                           restarts <- computeRestarts(cond)
[16:09:34.932]                           for (restart in restarts) {
[16:09:34.932]                             name <- restart$name
[16:09:34.932]                             if (is.null(name)) 
[16:09:34.932]                               next
[16:09:34.932]                             if (!grepl(pattern, name)) 
[16:09:34.932]                               next
[16:09:34.932]                             invokeRestart(restart)
[16:09:34.932]                             muffled <- TRUE
[16:09:34.932]                             break
[16:09:34.932]                           }
[16:09:34.932]                         }
[16:09:34.932]                       }
[16:09:34.932]                       invisible(muffled)
[16:09:34.932]                     }
[16:09:34.932]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.932]                   }
[16:09:34.932]                 }
[16:09:34.932]                 else {
[16:09:34.932]                   if (TRUE) {
[16:09:34.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:34.932]                     {
[16:09:34.932]                       inherits <- base::inherits
[16:09:34.932]                       invokeRestart <- base::invokeRestart
[16:09:34.932]                       is.null <- base::is.null
[16:09:34.932]                       muffled <- FALSE
[16:09:34.932]                       if (inherits(cond, "message")) {
[16:09:34.932]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:34.932]                         if (muffled) 
[16:09:34.932]                           invokeRestart("muffleMessage")
[16:09:34.932]                       }
[16:09:34.932]                       else if (inherits(cond, "warning")) {
[16:09:34.932]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:34.932]                         if (muffled) 
[16:09:34.932]                           invokeRestart("muffleWarning")
[16:09:34.932]                       }
[16:09:34.932]                       else if (inherits(cond, "condition")) {
[16:09:34.932]                         if (!is.null(pattern)) {
[16:09:34.932]                           computeRestarts <- base::computeRestarts
[16:09:34.932]                           grepl <- base::grepl
[16:09:34.932]                           restarts <- computeRestarts(cond)
[16:09:34.932]                           for (restart in restarts) {
[16:09:34.932]                             name <- restart$name
[16:09:34.932]                             if (is.null(name)) 
[16:09:34.932]                               next
[16:09:34.932]                             if (!grepl(pattern, name)) 
[16:09:34.932]                               next
[16:09:34.932]                             invokeRestart(restart)
[16:09:34.932]                             muffled <- TRUE
[16:09:34.932]                             break
[16:09:34.932]                           }
[16:09:34.932]                         }
[16:09:34.932]                       }
[16:09:34.932]                       invisible(muffled)
[16:09:34.932]                     }
[16:09:34.932]                     muffleCondition(cond, pattern = "^muffle")
[16:09:34.932]                   }
[16:09:34.932]                 }
[16:09:34.932]             }
[16:09:34.932]         }))
[16:09:34.932]     }, error = function(ex) {
[16:09:34.932]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:34.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:34.932]                 ...future.rng), started = ...future.startTime, 
[16:09:34.932]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:34.932]             version = "1.8"), class = "FutureResult")
[16:09:34.932]     }, finally = {
[16:09:34.932]         if (!identical(...future.workdir, getwd())) 
[16:09:34.932]             setwd(...future.workdir)
[16:09:34.932]         {
[16:09:34.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:34.932]                 ...future.oldOptions$nwarnings <- NULL
[16:09:34.932]             }
[16:09:34.932]             base::options(...future.oldOptions)
[16:09:34.932]             if (.Platform$OS.type == "windows") {
[16:09:34.932]                 old_names <- names(...future.oldEnvVars)
[16:09:34.932]                 envs <- base::Sys.getenv()
[16:09:34.932]                 names <- names(envs)
[16:09:34.932]                 common <- intersect(names, old_names)
[16:09:34.932]                 added <- setdiff(names, old_names)
[16:09:34.932]                 removed <- setdiff(old_names, names)
[16:09:34.932]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:34.932]                   envs[common]]
[16:09:34.932]                 NAMES <- toupper(changed)
[16:09:34.932]                 args <- list()
[16:09:34.932]                 for (kk in seq_along(NAMES)) {
[16:09:34.932]                   name <- changed[[kk]]
[16:09:34.932]                   NAME <- NAMES[[kk]]
[16:09:34.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.932]                     next
[16:09:34.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.932]                 }
[16:09:34.932]                 NAMES <- toupper(added)
[16:09:34.932]                 for (kk in seq_along(NAMES)) {
[16:09:34.932]                   name <- added[[kk]]
[16:09:34.932]                   NAME <- NAMES[[kk]]
[16:09:34.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.932]                     next
[16:09:34.932]                   args[[name]] <- ""
[16:09:34.932]                 }
[16:09:34.932]                 NAMES <- toupper(removed)
[16:09:34.932]                 for (kk in seq_along(NAMES)) {
[16:09:34.932]                   name <- removed[[kk]]
[16:09:34.932]                   NAME <- NAMES[[kk]]
[16:09:34.932]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:34.932]                     next
[16:09:34.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:34.932]                 }
[16:09:34.932]                 if (length(args) > 0) 
[16:09:34.932]                   base::do.call(base::Sys.setenv, args = args)
[16:09:34.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:34.932]             }
[16:09:34.932]             else {
[16:09:34.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:34.932]             }
[16:09:34.932]             {
[16:09:34.932]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:34.932]                   0L) {
[16:09:34.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:34.932]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:34.932]                   base::options(opts)
[16:09:34.932]                 }
[16:09:34.932]                 {
[16:09:34.932]                   {
[16:09:34.932]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:34.932]                     NULL
[16:09:34.932]                   }
[16:09:34.932]                   options(future.plan = NULL)
[16:09:34.932]                   if (is.na(NA_character_)) 
[16:09:34.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:34.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:34.932]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:34.932]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:34.932]                     envir = parent.frame()) 
[16:09:34.932]                   {
[16:09:34.932]                     if (is.function(workers)) 
[16:09:34.932]                       workers <- workers()
[16:09:34.932]                     workers <- structure(as.integer(workers), 
[16:09:34.932]                       class = class(workers))
[16:09:34.932]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:34.932]                       workers >= 1)
[16:09:34.932]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:34.932]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:34.932]                     }
[16:09:34.932]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:34.932]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:34.932]                       envir = envir)
[16:09:34.932]                     if (!future$lazy) 
[16:09:34.932]                       future <- run(future)
[16:09:34.932]                     invisible(future)
[16:09:34.932]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:34.932]                 }
[16:09:34.932]             }
[16:09:34.932]         }
[16:09:34.932]     })
[16:09:34.932]     if (TRUE) {
[16:09:34.932]         base::sink(type = "output", split = FALSE)
[16:09:34.932]         if (TRUE) {
[16:09:34.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:34.932]         }
[16:09:34.932]         else {
[16:09:34.932]             ...future.result["stdout"] <- base::list(NULL)
[16:09:34.932]         }
[16:09:34.932]         base::close(...future.stdout)
[16:09:34.932]         ...future.stdout <- NULL
[16:09:34.932]     }
[16:09:34.932]     ...future.result$conditions <- ...future.conditions
[16:09:34.932]     ...future.result$finished <- base::Sys.time()
[16:09:34.932]     ...future.result
[16:09:34.932] }
[16:09:34.935] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[16:09:34.935] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[16:09:34.935] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[16:09:34.935] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:09:34.936] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:09:34.936] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:09:34.936] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:09:34.937] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:34.937] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.937] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:34.937] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:34.937] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[16:09:34.938] MultisessionFuture started
[16:09:34.938] - Launch lazy future ... done
[16:09:34.938] run() for ‘MultisessionFuture’ ... done
[16:09:34.938] Created future:
[16:09:34.938] MultisessionFuture:
[16:09:34.938] Label: ‘future_by-2’
[16:09:34.938] Expression:
[16:09:34.938] {
[16:09:34.938]     do.call(function(...) {
[16:09:34.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:34.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:34.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:34.938]             on.exit(options(oopts), add = TRUE)
[16:09:34.938]         }
[16:09:34.938]         {
[16:09:34.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:34.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:34.938]                 ...future.FUN(...future.X_jj, ...)
[16:09:34.938]             })
[16:09:34.938]         }
[16:09:34.938]     }, args = future.call.arguments)
[16:09:34.938] }
[16:09:34.938] Lazy evaluation: FALSE
[16:09:34.938] Asynchronous evaluation: TRUE
[16:09:34.938] Local evaluation: TRUE
[16:09:34.938] Environment: R_GlobalEnv
[16:09:34.938] Capture standard output: TRUE
[16:09:34.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:34.938] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:34.938] Packages: 1 packages (‘stats’)
[16:09:34.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:34.938] Resolved: FALSE
[16:09:34.938] Value: <not collected>
[16:09:34.938] Conditions captured: <none>
[16:09:34.938] Early signaling: FALSE
[16:09:34.938] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:34.938] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:34.950] Chunk #2 of 2 ... DONE
[16:09:34.950] Launching 2 futures (chunks) ... DONE
[16:09:34.950] Resolving 2 futures (chunks) ...
[16:09:34.950] resolve() on list ...
[16:09:34.950]  recursive: 0
[16:09:34.950]  length: 2
[16:09:34.950] 
[16:09:34.951] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.951] - Validating connection of MultisessionFuture
[16:09:34.951] - received message: FutureResult
[16:09:34.951] - Received FutureResult
[16:09:34.951] - Erased future from FutureRegistry
[16:09:34.952] result() for ClusterFuture ...
[16:09:34.952] - result already collected: FutureResult
[16:09:34.952] result() for ClusterFuture ... done
[16:09:34.952] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.952] Future #1
[16:09:34.952] result() for ClusterFuture ...
[16:09:34.952] - result already collected: FutureResult
[16:09:34.952] result() for ClusterFuture ... done
[16:09:34.952] result() for ClusterFuture ...
[16:09:34.952] - result already collected: FutureResult
[16:09:34.953] result() for ClusterFuture ... done
[16:09:34.953] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:34.953] - nx: 2
[16:09:34.953] - relay: TRUE
[16:09:34.953] - stdout: TRUE
[16:09:34.953] - signal: TRUE
[16:09:34.953] - resignal: FALSE
[16:09:34.953] - force: TRUE
[16:09:34.953] - relayed: [n=2] FALSE, FALSE
[16:09:34.953] - queued futures: [n=2] FALSE, FALSE
[16:09:34.954]  - until=1
[16:09:34.954]  - relaying element #1
[16:09:34.954] result() for ClusterFuture ...
[16:09:34.954] - result already collected: FutureResult
[16:09:34.954] result() for ClusterFuture ... done
[16:09:34.954] result() for ClusterFuture ...
[16:09:34.954] - result already collected: FutureResult
[16:09:34.954] result() for ClusterFuture ... done
[16:09:34.954] result() for ClusterFuture ...
[16:09:34.954] - result already collected: FutureResult
[16:09:34.955] result() for ClusterFuture ... done
[16:09:34.955] result() for ClusterFuture ...
[16:09:34.955] - result already collected: FutureResult
[16:09:34.955] result() for ClusterFuture ... done
[16:09:34.955] - relayed: [n=2] TRUE, FALSE
[16:09:34.955] - queued futures: [n=2] TRUE, FALSE
[16:09:34.955] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:34.955]  length: 1 (resolved future 1)
[16:09:34.997] receiveMessageFromWorker() for ClusterFuture ...
[16:09:34.997] - Validating connection of MultisessionFuture
[16:09:34.997] - received message: FutureResult
[16:09:34.997] - Received FutureResult
[16:09:34.998] - Erased future from FutureRegistry
[16:09:34.998] result() for ClusterFuture ...
[16:09:34.998] - result already collected: FutureResult
[16:09:34.998] result() for ClusterFuture ... done
[16:09:34.998] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:34.998] Future #2
[16:09:34.998] result() for ClusterFuture ...
[16:09:34.998] - result already collected: FutureResult
[16:09:34.998] result() for ClusterFuture ... done
[16:09:34.998] result() for ClusterFuture ...
[16:09:34.998] - result already collected: FutureResult
[16:09:34.999] result() for ClusterFuture ... done
[16:09:34.999] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:34.999] - nx: 2
[16:09:34.999] - relay: TRUE
[16:09:34.999] - stdout: TRUE
[16:09:34.999] - signal: TRUE
[16:09:34.999] - resignal: FALSE
[16:09:34.999] - force: TRUE
[16:09:34.999] - relayed: [n=2] TRUE, FALSE
[16:09:34.999] - queued futures: [n=2] TRUE, FALSE
[16:09:34.999]  - until=2
[16:09:34.999]  - relaying element #2
[16:09:35.000] result() for ClusterFuture ...
[16:09:35.000] - result already collected: FutureResult
[16:09:35.000] result() for ClusterFuture ... done
[16:09:35.000] result() for ClusterFuture ...
[16:09:35.000] - result already collected: FutureResult
[16:09:35.000] result() for ClusterFuture ... done
[16:09:35.000] result() for ClusterFuture ...
[16:09:35.000] - result already collected: FutureResult
[16:09:35.000] result() for ClusterFuture ... done
[16:09:35.000] result() for ClusterFuture ...
[16:09:35.000] - result already collected: FutureResult
[16:09:35.001] result() for ClusterFuture ... done
[16:09:35.001] - relayed: [n=2] TRUE, TRUE
[16:09:35.001] - queued futures: [n=2] TRUE, TRUE
[16:09:35.001] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:35.001]  length: 0 (resolved future 2)
[16:09:35.001] Relaying remaining futures
[16:09:35.001] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.001] - nx: 2
[16:09:35.001] - relay: TRUE
[16:09:35.001] - stdout: TRUE
[16:09:35.001] - signal: TRUE
[16:09:35.002] - resignal: FALSE
[16:09:35.002] - force: TRUE
[16:09:35.002] - relayed: [n=2] TRUE, TRUE
[16:09:35.002] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:35.002] - relayed: [n=2] TRUE, TRUE
[16:09:35.002] - queued futures: [n=2] TRUE, TRUE
[16:09:35.002] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.002] resolve() on list ... DONE
[16:09:35.002] result() for ClusterFuture ...
[16:09:35.002] - result already collected: FutureResult
[16:09:35.002] result() for ClusterFuture ... done
[16:09:35.003] result() for ClusterFuture ...
[16:09:35.003] - result already collected: FutureResult
[16:09:35.003] result() for ClusterFuture ... done
[16:09:35.003] result() for ClusterFuture ...
[16:09:35.003] - result already collected: FutureResult
[16:09:35.003] result() for ClusterFuture ... done
[16:09:35.003] result() for ClusterFuture ...
[16:09:35.003] - result already collected: FutureResult
[16:09:35.003] result() for ClusterFuture ... done
[16:09:35.003]  - Number of value chunks collected: 2
[16:09:35.003] Resolving 2 futures (chunks) ... DONE
[16:09:35.004] Reducing values from 2 chunks ...
[16:09:35.004]  - Number of values collected after concatenation: 3
[16:09:35.004]  - Number of values expected: 3
[16:09:35.004] Reducing values from 2 chunks ... DONE
[16:09:35.004] future_lapply() ... DONE
[16:09:35.004] future_by_internal() ... DONE
[16:09:35.008] future_by_internal() ...
[16:09:35.008] future_lapply() ...
[16:09:35.013] Number of chunks: 2
[16:09:35.013] getGlobalsAndPackagesXApply() ...
[16:09:35.013]  - future.globals: TRUE
[16:09:35.013] getGlobalsAndPackages() ...
[16:09:35.013] Searching for globals...
[16:09:35.015] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:09:35.015] Searching for globals ... DONE
[16:09:35.015] Resolving globals: FALSE
[16:09:35.016] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:09:35.016] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:09:35.017] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:35.017] - packages: [1] ‘stats’
[16:09:35.017] getGlobalsAndPackages() ... DONE
[16:09:35.017]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:09:35.017]  - needed namespaces: [n=1] ‘stats’
[16:09:35.017] Finding globals ... DONE
[16:09:35.017]  - use_args: TRUE
[16:09:35.017]  - Getting '...' globals ...
[16:09:35.018] resolve() on list ...
[16:09:35.018]  recursive: 0
[16:09:35.018]  length: 1
[16:09:35.018]  elements: ‘...’
[16:09:35.018]  length: 0 (resolved future 1)
[16:09:35.018] resolve() on list ... DONE
[16:09:35.018]    - '...' content: [n=0] 
[16:09:35.018] List of 1
[16:09:35.018]  $ ...: list()
[16:09:35.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.018]  - attr(*, "where")=List of 1
[16:09:35.018]   ..$ ...:<environment: 0x5567e9bca828> 
[16:09:35.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.018]  - attr(*, "resolved")= logi TRUE
[16:09:35.018]  - attr(*, "total_size")= num NA
[16:09:35.021]  - Getting '...' globals ... DONE
[16:09:35.021] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:09:35.021] List of 4
[16:09:35.021]  $ ...future.FUN:function (x)  
[16:09:35.021]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:09:35.021]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:09:35.021]  $ ...          : list()
[16:09:35.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.021]  - attr(*, "where")=List of 4
[16:09:35.021]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.021]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:09:35.021]   ..$ wool         :<environment: R_EmptyEnv> 
[16:09:35.021]   ..$ ...          :<environment: 0x5567e9bca828> 
[16:09:35.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.021]  - attr(*, "resolved")= logi FALSE
[16:09:35.021]  - attr(*, "total_size")= num 2320
[16:09:35.025] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:35.025] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.025] Number of futures (= number of chunks): 2
[16:09:35.025] Launching 2 futures (chunks) ...
[16:09:35.026] Chunk #1 of 2 ...
[16:09:35.026]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.026] getGlobalsAndPackages() ...
[16:09:35.026] Searching for globals...
[16:09:35.026] 
[16:09:35.026] Searching for globals ... DONE
[16:09:35.026] - globals: [0] <none>
[16:09:35.026] getGlobalsAndPackages() ... DONE
[16:09:35.027]    + additional globals found: [n=0] 
[16:09:35.027]    + additional namespaces needed: [n=0] 
[16:09:35.027]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.027]  - seeds: <none>
[16:09:35.027] getGlobalsAndPackages() ...
[16:09:35.027] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.027] Resolving globals: FALSE
[16:09:35.027] Tweak future expression to call with '...' arguments ...
[16:09:35.027] {
[16:09:35.027]     do.call(function(...) {
[16:09:35.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.027]             on.exit(options(oopts), add = TRUE)
[16:09:35.027]         }
[16:09:35.027]         {
[16:09:35.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.027]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.027]             })
[16:09:35.027]         }
[16:09:35.027]     }, args = future.call.arguments)
[16:09:35.027] }
[16:09:35.028] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.028] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.028] 
[16:09:35.028] getGlobalsAndPackages() ... DONE
[16:09:35.029] run() for ‘Future’ ...
[16:09:35.029] - state: ‘created’
[16:09:35.029] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:35.044]   - Field: ‘node’
[16:09:35.044]   - Field: ‘label’
[16:09:35.044]   - Field: ‘local’
[16:09:35.044]   - Field: ‘owner’
[16:09:35.044]   - Field: ‘envir’
[16:09:35.044]   - Field: ‘workers’
[16:09:35.045]   - Field: ‘packages’
[16:09:35.045]   - Field: ‘gc’
[16:09:35.045]   - Field: ‘conditions’
[16:09:35.045]   - Field: ‘persistent’
[16:09:35.045]   - Field: ‘expr’
[16:09:35.045]   - Field: ‘uuid’
[16:09:35.045]   - Field: ‘seed’
[16:09:35.045]   - Field: ‘version’
[16:09:35.045]   - Field: ‘result’
[16:09:35.045]   - Field: ‘asynchronous’
[16:09:35.045]   - Field: ‘calls’
[16:09:35.046]   - Field: ‘globals’
[16:09:35.046]   - Field: ‘stdout’
[16:09:35.046]   - Field: ‘earlySignal’
[16:09:35.046]   - Field: ‘lazy’
[16:09:35.046]   - Field: ‘state’
[16:09:35.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:35.046] - Launch lazy future ...
[16:09:35.046] Packages needed by the future expression (n = 1): ‘stats’
[16:09:35.046] Packages needed by future strategies (n = 0): <none>
[16:09:35.049] {
[16:09:35.049]     {
[16:09:35.049]         {
[16:09:35.049]             ...future.startTime <- base::Sys.time()
[16:09:35.049]             {
[16:09:35.049]                 {
[16:09:35.049]                   {
[16:09:35.049]                     {
[16:09:35.049]                       {
[16:09:35.049]                         base::local({
[16:09:35.049]                           has_future <- base::requireNamespace("future", 
[16:09:35.049]                             quietly = TRUE)
[16:09:35.049]                           if (has_future) {
[16:09:35.049]                             ns <- base::getNamespace("future")
[16:09:35.049]                             version <- ns[[".package"]][["version"]]
[16:09:35.049]                             if (is.null(version)) 
[16:09:35.049]                               version <- utils::packageVersion("future")
[16:09:35.049]                           }
[16:09:35.049]                           else {
[16:09:35.049]                             version <- NULL
[16:09:35.049]                           }
[16:09:35.049]                           if (!has_future || version < "1.8.0") {
[16:09:35.049]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.049]                               "", base::R.version$version.string), 
[16:09:35.049]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:35.049]                                 base::R.version$platform, 8 * 
[16:09:35.049]                                   base::.Machine$sizeof.pointer), 
[16:09:35.049]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.049]                                 "release", "version")], collapse = " "), 
[16:09:35.049]                               hostname = base::Sys.info()[["nodename"]])
[16:09:35.049]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.049]                               info)
[16:09:35.049]                             info <- base::paste(info, collapse = "; ")
[16:09:35.049]                             if (!has_future) {
[16:09:35.049]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.049]                                 info)
[16:09:35.049]                             }
[16:09:35.049]                             else {
[16:09:35.049]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.049]                                 info, version)
[16:09:35.049]                             }
[16:09:35.049]                             base::stop(msg)
[16:09:35.049]                           }
[16:09:35.049]                         })
[16:09:35.049]                       }
[16:09:35.049]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.049]                       base::options(mc.cores = 1L)
[16:09:35.049]                     }
[16:09:35.049]                     base::local({
[16:09:35.049]                       for (pkg in "stats") {
[16:09:35.049]                         base::loadNamespace(pkg)
[16:09:35.049]                         base::library(pkg, character.only = TRUE)
[16:09:35.049]                       }
[16:09:35.049]                     })
[16:09:35.049]                   }
[16:09:35.049]                   options(future.plan = NULL)
[16:09:35.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.049]                 }
[16:09:35.049]                 ...future.workdir <- getwd()
[16:09:35.049]             }
[16:09:35.049]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.049]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.049]         }
[16:09:35.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.049]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:35.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.049]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.049]             base::names(...future.oldOptions))
[16:09:35.049]     }
[16:09:35.049]     if (FALSE) {
[16:09:35.049]     }
[16:09:35.049]     else {
[16:09:35.049]         if (TRUE) {
[16:09:35.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.049]                 open = "w")
[16:09:35.049]         }
[16:09:35.049]         else {
[16:09:35.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.049]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.049]         }
[16:09:35.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.049]             base::sink(type = "output", split = FALSE)
[16:09:35.049]             base::close(...future.stdout)
[16:09:35.049]         }, add = TRUE)
[16:09:35.049]     }
[16:09:35.049]     ...future.frame <- base::sys.nframe()
[16:09:35.049]     ...future.conditions <- base::list()
[16:09:35.049]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.049]     if (FALSE) {
[16:09:35.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.049]     }
[16:09:35.049]     ...future.result <- base::tryCatch({
[16:09:35.049]         base::withCallingHandlers({
[16:09:35.049]             ...future.value <- base::withVisible(base::local({
[16:09:35.049]                 ...future.makeSendCondition <- local({
[16:09:35.049]                   sendCondition <- NULL
[16:09:35.049]                   function(frame = 1L) {
[16:09:35.049]                     if (is.function(sendCondition)) 
[16:09:35.049]                       return(sendCondition)
[16:09:35.049]                     ns <- getNamespace("parallel")
[16:09:35.049]                     if (exists("sendData", mode = "function", 
[16:09:35.049]                       envir = ns)) {
[16:09:35.049]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:35.049]                         envir = ns)
[16:09:35.049]                       envir <- sys.frame(frame)
[16:09:35.049]                       master <- NULL
[16:09:35.049]                       while (!identical(envir, .GlobalEnv) && 
[16:09:35.049]                         !identical(envir, emptyenv())) {
[16:09:35.049]                         if (exists("master", mode = "list", envir = envir, 
[16:09:35.049]                           inherits = FALSE)) {
[16:09:35.049]                           master <- get("master", mode = "list", 
[16:09:35.049]                             envir = envir, inherits = FALSE)
[16:09:35.049]                           if (inherits(master, c("SOCKnode", 
[16:09:35.049]                             "SOCK0node"))) {
[16:09:35.049]                             sendCondition <<- function(cond) {
[16:09:35.049]                               data <- list(type = "VALUE", value = cond, 
[16:09:35.049]                                 success = TRUE)
[16:09:35.049]                               parallel_sendData(master, data)
[16:09:35.049]                             }
[16:09:35.049]                             return(sendCondition)
[16:09:35.049]                           }
[16:09:35.049]                         }
[16:09:35.049]                         frame <- frame + 1L
[16:09:35.049]                         envir <- sys.frame(frame)
[16:09:35.049]                       }
[16:09:35.049]                     }
[16:09:35.049]                     sendCondition <<- function(cond) NULL
[16:09:35.049]                   }
[16:09:35.049]                 })
[16:09:35.049]                 withCallingHandlers({
[16:09:35.049]                   {
[16:09:35.049]                     do.call(function(...) {
[16:09:35.049]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.049]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.049]                         ...future.globals.maxSize)) {
[16:09:35.049]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.049]                         on.exit(options(oopts), add = TRUE)
[16:09:35.049]                       }
[16:09:35.049]                       {
[16:09:35.049]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.049]                           FUN = function(jj) {
[16:09:35.049]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.049]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.049]                           })
[16:09:35.049]                       }
[16:09:35.049]                     }, args = future.call.arguments)
[16:09:35.049]                   }
[16:09:35.049]                 }, immediateCondition = function(cond) {
[16:09:35.049]                   sendCondition <- ...future.makeSendCondition()
[16:09:35.049]                   sendCondition(cond)
[16:09:35.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.049]                   {
[16:09:35.049]                     inherits <- base::inherits
[16:09:35.049]                     invokeRestart <- base::invokeRestart
[16:09:35.049]                     is.null <- base::is.null
[16:09:35.049]                     muffled <- FALSE
[16:09:35.049]                     if (inherits(cond, "message")) {
[16:09:35.049]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.049]                       if (muffled) 
[16:09:35.049]                         invokeRestart("muffleMessage")
[16:09:35.049]                     }
[16:09:35.049]                     else if (inherits(cond, "warning")) {
[16:09:35.049]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.049]                       if (muffled) 
[16:09:35.049]                         invokeRestart("muffleWarning")
[16:09:35.049]                     }
[16:09:35.049]                     else if (inherits(cond, "condition")) {
[16:09:35.049]                       if (!is.null(pattern)) {
[16:09:35.049]                         computeRestarts <- base::computeRestarts
[16:09:35.049]                         grepl <- base::grepl
[16:09:35.049]                         restarts <- computeRestarts(cond)
[16:09:35.049]                         for (restart in restarts) {
[16:09:35.049]                           name <- restart$name
[16:09:35.049]                           if (is.null(name)) 
[16:09:35.049]                             next
[16:09:35.049]                           if (!grepl(pattern, name)) 
[16:09:35.049]                             next
[16:09:35.049]                           invokeRestart(restart)
[16:09:35.049]                           muffled <- TRUE
[16:09:35.049]                           break
[16:09:35.049]                         }
[16:09:35.049]                       }
[16:09:35.049]                     }
[16:09:35.049]                     invisible(muffled)
[16:09:35.049]                   }
[16:09:35.049]                   muffleCondition(cond)
[16:09:35.049]                 })
[16:09:35.049]             }))
[16:09:35.049]             future::FutureResult(value = ...future.value$value, 
[16:09:35.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.049]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.049]                     ...future.globalenv.names))
[16:09:35.049]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.049]         }, condition = base::local({
[16:09:35.049]             c <- base::c
[16:09:35.049]             inherits <- base::inherits
[16:09:35.049]             invokeRestart <- base::invokeRestart
[16:09:35.049]             length <- base::length
[16:09:35.049]             list <- base::list
[16:09:35.049]             seq.int <- base::seq.int
[16:09:35.049]             signalCondition <- base::signalCondition
[16:09:35.049]             sys.calls <- base::sys.calls
[16:09:35.049]             `[[` <- base::`[[`
[16:09:35.049]             `+` <- base::`+`
[16:09:35.049]             `<<-` <- base::`<<-`
[16:09:35.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.049]                   3L)]
[16:09:35.049]             }
[16:09:35.049]             function(cond) {
[16:09:35.049]                 is_error <- inherits(cond, "error")
[16:09:35.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.049]                   NULL)
[16:09:35.049]                 if (is_error) {
[16:09:35.049]                   sessionInformation <- function() {
[16:09:35.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.049]                       search = base::search(), system = base::Sys.info())
[16:09:35.049]                   }
[16:09:35.049]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.049]                     cond$call), session = sessionInformation(), 
[16:09:35.049]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.049]                   signalCondition(cond)
[16:09:35.049]                 }
[16:09:35.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.049]                 "immediateCondition"))) {
[16:09:35.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.049]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.049]                   if (TRUE && !signal) {
[16:09:35.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.049]                     {
[16:09:35.049]                       inherits <- base::inherits
[16:09:35.049]                       invokeRestart <- base::invokeRestart
[16:09:35.049]                       is.null <- base::is.null
[16:09:35.049]                       muffled <- FALSE
[16:09:35.049]                       if (inherits(cond, "message")) {
[16:09:35.049]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.049]                         if (muffled) 
[16:09:35.049]                           invokeRestart("muffleMessage")
[16:09:35.049]                       }
[16:09:35.049]                       else if (inherits(cond, "warning")) {
[16:09:35.049]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.049]                         if (muffled) 
[16:09:35.049]                           invokeRestart("muffleWarning")
[16:09:35.049]                       }
[16:09:35.049]                       else if (inherits(cond, "condition")) {
[16:09:35.049]                         if (!is.null(pattern)) {
[16:09:35.049]                           computeRestarts <- base::computeRestarts
[16:09:35.049]                           grepl <- base::grepl
[16:09:35.049]                           restarts <- computeRestarts(cond)
[16:09:35.049]                           for (restart in restarts) {
[16:09:35.049]                             name <- restart$name
[16:09:35.049]                             if (is.null(name)) 
[16:09:35.049]                               next
[16:09:35.049]                             if (!grepl(pattern, name)) 
[16:09:35.049]                               next
[16:09:35.049]                             invokeRestart(restart)
[16:09:35.049]                             muffled <- TRUE
[16:09:35.049]                             break
[16:09:35.049]                           }
[16:09:35.049]                         }
[16:09:35.049]                       }
[16:09:35.049]                       invisible(muffled)
[16:09:35.049]                     }
[16:09:35.049]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.049]                   }
[16:09:35.049]                 }
[16:09:35.049]                 else {
[16:09:35.049]                   if (TRUE) {
[16:09:35.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.049]                     {
[16:09:35.049]                       inherits <- base::inherits
[16:09:35.049]                       invokeRestart <- base::invokeRestart
[16:09:35.049]                       is.null <- base::is.null
[16:09:35.049]                       muffled <- FALSE
[16:09:35.049]                       if (inherits(cond, "message")) {
[16:09:35.049]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.049]                         if (muffled) 
[16:09:35.049]                           invokeRestart("muffleMessage")
[16:09:35.049]                       }
[16:09:35.049]                       else if (inherits(cond, "warning")) {
[16:09:35.049]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.049]                         if (muffled) 
[16:09:35.049]                           invokeRestart("muffleWarning")
[16:09:35.049]                       }
[16:09:35.049]                       else if (inherits(cond, "condition")) {
[16:09:35.049]                         if (!is.null(pattern)) {
[16:09:35.049]                           computeRestarts <- base::computeRestarts
[16:09:35.049]                           grepl <- base::grepl
[16:09:35.049]                           restarts <- computeRestarts(cond)
[16:09:35.049]                           for (restart in restarts) {
[16:09:35.049]                             name <- restart$name
[16:09:35.049]                             if (is.null(name)) 
[16:09:35.049]                               next
[16:09:35.049]                             if (!grepl(pattern, name)) 
[16:09:35.049]                               next
[16:09:35.049]                             invokeRestart(restart)
[16:09:35.049]                             muffled <- TRUE
[16:09:35.049]                             break
[16:09:35.049]                           }
[16:09:35.049]                         }
[16:09:35.049]                       }
[16:09:35.049]                       invisible(muffled)
[16:09:35.049]                     }
[16:09:35.049]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.049]                   }
[16:09:35.049]                 }
[16:09:35.049]             }
[16:09:35.049]         }))
[16:09:35.049]     }, error = function(ex) {
[16:09:35.049]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.049]                 ...future.rng), started = ...future.startTime, 
[16:09:35.049]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.049]             version = "1.8"), class = "FutureResult")
[16:09:35.049]     }, finally = {
[16:09:35.049]         if (!identical(...future.workdir, getwd())) 
[16:09:35.049]             setwd(...future.workdir)
[16:09:35.049]         {
[16:09:35.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.049]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.049]             }
[16:09:35.049]             base::options(...future.oldOptions)
[16:09:35.049]             if (.Platform$OS.type == "windows") {
[16:09:35.049]                 old_names <- names(...future.oldEnvVars)
[16:09:35.049]                 envs <- base::Sys.getenv()
[16:09:35.049]                 names <- names(envs)
[16:09:35.049]                 common <- intersect(names, old_names)
[16:09:35.049]                 added <- setdiff(names, old_names)
[16:09:35.049]                 removed <- setdiff(old_names, names)
[16:09:35.049]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.049]                   envs[common]]
[16:09:35.049]                 NAMES <- toupper(changed)
[16:09:35.049]                 args <- list()
[16:09:35.049]                 for (kk in seq_along(NAMES)) {
[16:09:35.049]                   name <- changed[[kk]]
[16:09:35.049]                   NAME <- NAMES[[kk]]
[16:09:35.049]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.049]                     next
[16:09:35.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.049]                 }
[16:09:35.049]                 NAMES <- toupper(added)
[16:09:35.049]                 for (kk in seq_along(NAMES)) {
[16:09:35.049]                   name <- added[[kk]]
[16:09:35.049]                   NAME <- NAMES[[kk]]
[16:09:35.049]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.049]                     next
[16:09:35.049]                   args[[name]] <- ""
[16:09:35.049]                 }
[16:09:35.049]                 NAMES <- toupper(removed)
[16:09:35.049]                 for (kk in seq_along(NAMES)) {
[16:09:35.049]                   name <- removed[[kk]]
[16:09:35.049]                   NAME <- NAMES[[kk]]
[16:09:35.049]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.049]                     next
[16:09:35.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.049]                 }
[16:09:35.049]                 if (length(args) > 0) 
[16:09:35.049]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.049]             }
[16:09:35.049]             else {
[16:09:35.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.049]             }
[16:09:35.049]             {
[16:09:35.049]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.049]                   0L) {
[16:09:35.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.049]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.049]                   base::options(opts)
[16:09:35.049]                 }
[16:09:35.049]                 {
[16:09:35.049]                   {
[16:09:35.049]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.049]                     NULL
[16:09:35.049]                   }
[16:09:35.049]                   options(future.plan = NULL)
[16:09:35.049]                   if (is.na(NA_character_)) 
[16:09:35.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.049]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:35.049]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:35.049]                     envir = parent.frame()) 
[16:09:35.049]                   {
[16:09:35.049]                     if (is.function(workers)) 
[16:09:35.049]                       workers <- workers()
[16:09:35.049]                     workers <- structure(as.integer(workers), 
[16:09:35.049]                       class = class(workers))
[16:09:35.049]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:35.049]                       workers >= 1)
[16:09:35.049]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:35.049]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:35.049]                     }
[16:09:35.049]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:35.049]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:35.049]                       envir = envir)
[16:09:35.049]                     if (!future$lazy) 
[16:09:35.049]                       future <- run(future)
[16:09:35.049]                     invisible(future)
[16:09:35.049]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.049]                 }
[16:09:35.049]             }
[16:09:35.049]         }
[16:09:35.049]     })
[16:09:35.049]     if (TRUE) {
[16:09:35.049]         base::sink(type = "output", split = FALSE)
[16:09:35.049]         if (TRUE) {
[16:09:35.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.049]         }
[16:09:35.049]         else {
[16:09:35.049]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.049]         }
[16:09:35.049]         base::close(...future.stdout)
[16:09:35.049]         ...future.stdout <- NULL
[16:09:35.049]     }
[16:09:35.049]     ...future.result$conditions <- ...future.conditions
[16:09:35.049]     ...future.result$finished <- base::Sys.time()
[16:09:35.049]     ...future.result
[16:09:35.049] }
[16:09:35.052] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[16:09:35.052] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[16:09:35.053] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[16:09:35.053] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[16:09:35.053] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[16:09:35.053] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[16:09:35.054] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[16:09:35.054] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:35.054] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.054] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:09:35.055] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:09:35.055] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:35.055] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:35.056] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.056] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[16:09:35.056] MultisessionFuture started
[16:09:35.057] - Launch lazy future ... done
[16:09:35.057] run() for ‘MultisessionFuture’ ... done
[16:09:35.057] Created future:
[16:09:35.057] MultisessionFuture:
[16:09:35.057] Label: ‘future_by-1’
[16:09:35.057] Expression:
[16:09:35.057] {
[16:09:35.057]     do.call(function(...) {
[16:09:35.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.057]             on.exit(options(oopts), add = TRUE)
[16:09:35.057]         }
[16:09:35.057]         {
[16:09:35.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.057]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.057]             })
[16:09:35.057]         }
[16:09:35.057]     }, args = future.call.arguments)
[16:09:35.057] }
[16:09:35.057] Lazy evaluation: FALSE
[16:09:35.057] Asynchronous evaluation: TRUE
[16:09:35.057] Local evaluation: TRUE
[16:09:35.057] Environment: 0x5567e9edf2b8
[16:09:35.057] Capture standard output: TRUE
[16:09:35.057] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.057] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:09:35.057] Packages: 1 packages (‘stats’)
[16:09:35.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.057] Resolved: FALSE
[16:09:35.057] Value: <not collected>
[16:09:35.057] Conditions captured: <none>
[16:09:35.057] Early signaling: FALSE
[16:09:35.057] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:35.057] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.069] Chunk #1 of 2 ... DONE
[16:09:35.069] Chunk #2 of 2 ...
[16:09:35.069]  - Finding globals in 'X' for chunk #2 ...
[16:09:35.069] getGlobalsAndPackages() ...
[16:09:35.069] Searching for globals...
[16:09:35.070] 
[16:09:35.070] Searching for globals ... DONE
[16:09:35.070] - globals: [0] <none>
[16:09:35.070] getGlobalsAndPackages() ... DONE
[16:09:35.070]    + additional globals found: [n=0] 
[16:09:35.070]    + additional namespaces needed: [n=0] 
[16:09:35.070]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:35.070]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:35.070]  - seeds: <none>
[16:09:35.070] getGlobalsAndPackages() ...
[16:09:35.070] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.071] Resolving globals: FALSE
[16:09:35.071] Tweak future expression to call with '...' arguments ...
[16:09:35.071] {
[16:09:35.071]     do.call(function(...) {
[16:09:35.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.071]             on.exit(options(oopts), add = TRUE)
[16:09:35.071]         }
[16:09:35.071]         {
[16:09:35.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.071]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.071]             })
[16:09:35.071]         }
[16:09:35.071]     }, args = future.call.arguments)
[16:09:35.071] }
[16:09:35.071] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.071] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.072] 
[16:09:35.072] getGlobalsAndPackages() ... DONE
[16:09:35.072] run() for ‘Future’ ...
[16:09:35.072] - state: ‘created’
[16:09:35.072] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:35.087]   - Field: ‘node’
[16:09:35.087]   - Field: ‘label’
[16:09:35.088]   - Field: ‘local’
[16:09:35.088]   - Field: ‘owner’
[16:09:35.088]   - Field: ‘envir’
[16:09:35.088]   - Field: ‘workers’
[16:09:35.088]   - Field: ‘packages’
[16:09:35.088]   - Field: ‘gc’
[16:09:35.088]   - Field: ‘conditions’
[16:09:35.088]   - Field: ‘persistent’
[16:09:35.088]   - Field: ‘expr’
[16:09:35.088]   - Field: ‘uuid’
[16:09:35.089]   - Field: ‘seed’
[16:09:35.089]   - Field: ‘version’
[16:09:35.089]   - Field: ‘result’
[16:09:35.089]   - Field: ‘asynchronous’
[16:09:35.089]   - Field: ‘calls’
[16:09:35.089]   - Field: ‘globals’
[16:09:35.089]   - Field: ‘stdout’
[16:09:35.089]   - Field: ‘earlySignal’
[16:09:35.089]   - Field: ‘lazy’
[16:09:35.089]   - Field: ‘state’
[16:09:35.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:35.090] - Launch lazy future ...
[16:09:35.090] Packages needed by the future expression (n = 1): ‘stats’
[16:09:35.090] Packages needed by future strategies (n = 0): <none>
[16:09:35.090] {
[16:09:35.090]     {
[16:09:35.090]         {
[16:09:35.090]             ...future.startTime <- base::Sys.time()
[16:09:35.090]             {
[16:09:35.090]                 {
[16:09:35.090]                   {
[16:09:35.090]                     {
[16:09:35.090]                       {
[16:09:35.090]                         base::local({
[16:09:35.090]                           has_future <- base::requireNamespace("future", 
[16:09:35.090]                             quietly = TRUE)
[16:09:35.090]                           if (has_future) {
[16:09:35.090]                             ns <- base::getNamespace("future")
[16:09:35.090]                             version <- ns[[".package"]][["version"]]
[16:09:35.090]                             if (is.null(version)) 
[16:09:35.090]                               version <- utils::packageVersion("future")
[16:09:35.090]                           }
[16:09:35.090]                           else {
[16:09:35.090]                             version <- NULL
[16:09:35.090]                           }
[16:09:35.090]                           if (!has_future || version < "1.8.0") {
[16:09:35.090]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.090]                               "", base::R.version$version.string), 
[16:09:35.090]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:35.090]                                 base::R.version$platform, 8 * 
[16:09:35.090]                                   base::.Machine$sizeof.pointer), 
[16:09:35.090]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.090]                                 "release", "version")], collapse = " "), 
[16:09:35.090]                               hostname = base::Sys.info()[["nodename"]])
[16:09:35.090]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.090]                               info)
[16:09:35.090]                             info <- base::paste(info, collapse = "; ")
[16:09:35.090]                             if (!has_future) {
[16:09:35.090]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.090]                                 info)
[16:09:35.090]                             }
[16:09:35.090]                             else {
[16:09:35.090]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.090]                                 info, version)
[16:09:35.090]                             }
[16:09:35.090]                             base::stop(msg)
[16:09:35.090]                           }
[16:09:35.090]                         })
[16:09:35.090]                       }
[16:09:35.090]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.090]                       base::options(mc.cores = 1L)
[16:09:35.090]                     }
[16:09:35.090]                     base::local({
[16:09:35.090]                       for (pkg in "stats") {
[16:09:35.090]                         base::loadNamespace(pkg)
[16:09:35.090]                         base::library(pkg, character.only = TRUE)
[16:09:35.090]                       }
[16:09:35.090]                     })
[16:09:35.090]                   }
[16:09:35.090]                   options(future.plan = NULL)
[16:09:35.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.090]                 }
[16:09:35.090]                 ...future.workdir <- getwd()
[16:09:35.090]             }
[16:09:35.090]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.090]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.090]         }
[16:09:35.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.090]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:35.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.090]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.090]             base::names(...future.oldOptions))
[16:09:35.090]     }
[16:09:35.090]     if (FALSE) {
[16:09:35.090]     }
[16:09:35.090]     else {
[16:09:35.090]         if (TRUE) {
[16:09:35.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.090]                 open = "w")
[16:09:35.090]         }
[16:09:35.090]         else {
[16:09:35.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.090]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.090]         }
[16:09:35.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.090]             base::sink(type = "output", split = FALSE)
[16:09:35.090]             base::close(...future.stdout)
[16:09:35.090]         }, add = TRUE)
[16:09:35.090]     }
[16:09:35.090]     ...future.frame <- base::sys.nframe()
[16:09:35.090]     ...future.conditions <- base::list()
[16:09:35.090]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.090]     if (FALSE) {
[16:09:35.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.090]     }
[16:09:35.090]     ...future.result <- base::tryCatch({
[16:09:35.090]         base::withCallingHandlers({
[16:09:35.090]             ...future.value <- base::withVisible(base::local({
[16:09:35.090]                 ...future.makeSendCondition <- local({
[16:09:35.090]                   sendCondition <- NULL
[16:09:35.090]                   function(frame = 1L) {
[16:09:35.090]                     if (is.function(sendCondition)) 
[16:09:35.090]                       return(sendCondition)
[16:09:35.090]                     ns <- getNamespace("parallel")
[16:09:35.090]                     if (exists("sendData", mode = "function", 
[16:09:35.090]                       envir = ns)) {
[16:09:35.090]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:35.090]                         envir = ns)
[16:09:35.090]                       envir <- sys.frame(frame)
[16:09:35.090]                       master <- NULL
[16:09:35.090]                       while (!identical(envir, .GlobalEnv) && 
[16:09:35.090]                         !identical(envir, emptyenv())) {
[16:09:35.090]                         if (exists("master", mode = "list", envir = envir, 
[16:09:35.090]                           inherits = FALSE)) {
[16:09:35.090]                           master <- get("master", mode = "list", 
[16:09:35.090]                             envir = envir, inherits = FALSE)
[16:09:35.090]                           if (inherits(master, c("SOCKnode", 
[16:09:35.090]                             "SOCK0node"))) {
[16:09:35.090]                             sendCondition <<- function(cond) {
[16:09:35.090]                               data <- list(type = "VALUE", value = cond, 
[16:09:35.090]                                 success = TRUE)
[16:09:35.090]                               parallel_sendData(master, data)
[16:09:35.090]                             }
[16:09:35.090]                             return(sendCondition)
[16:09:35.090]                           }
[16:09:35.090]                         }
[16:09:35.090]                         frame <- frame + 1L
[16:09:35.090]                         envir <- sys.frame(frame)
[16:09:35.090]                       }
[16:09:35.090]                     }
[16:09:35.090]                     sendCondition <<- function(cond) NULL
[16:09:35.090]                   }
[16:09:35.090]                 })
[16:09:35.090]                 withCallingHandlers({
[16:09:35.090]                   {
[16:09:35.090]                     do.call(function(...) {
[16:09:35.090]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.090]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.090]                         ...future.globals.maxSize)) {
[16:09:35.090]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.090]                         on.exit(options(oopts), add = TRUE)
[16:09:35.090]                       }
[16:09:35.090]                       {
[16:09:35.090]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.090]                           FUN = function(jj) {
[16:09:35.090]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.090]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.090]                           })
[16:09:35.090]                       }
[16:09:35.090]                     }, args = future.call.arguments)
[16:09:35.090]                   }
[16:09:35.090]                 }, immediateCondition = function(cond) {
[16:09:35.090]                   sendCondition <- ...future.makeSendCondition()
[16:09:35.090]                   sendCondition(cond)
[16:09:35.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.090]                   {
[16:09:35.090]                     inherits <- base::inherits
[16:09:35.090]                     invokeRestart <- base::invokeRestart
[16:09:35.090]                     is.null <- base::is.null
[16:09:35.090]                     muffled <- FALSE
[16:09:35.090]                     if (inherits(cond, "message")) {
[16:09:35.090]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.090]                       if (muffled) 
[16:09:35.090]                         invokeRestart("muffleMessage")
[16:09:35.090]                     }
[16:09:35.090]                     else if (inherits(cond, "warning")) {
[16:09:35.090]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.090]                       if (muffled) 
[16:09:35.090]                         invokeRestart("muffleWarning")
[16:09:35.090]                     }
[16:09:35.090]                     else if (inherits(cond, "condition")) {
[16:09:35.090]                       if (!is.null(pattern)) {
[16:09:35.090]                         computeRestarts <- base::computeRestarts
[16:09:35.090]                         grepl <- base::grepl
[16:09:35.090]                         restarts <- computeRestarts(cond)
[16:09:35.090]                         for (restart in restarts) {
[16:09:35.090]                           name <- restart$name
[16:09:35.090]                           if (is.null(name)) 
[16:09:35.090]                             next
[16:09:35.090]                           if (!grepl(pattern, name)) 
[16:09:35.090]                             next
[16:09:35.090]                           invokeRestart(restart)
[16:09:35.090]                           muffled <- TRUE
[16:09:35.090]                           break
[16:09:35.090]                         }
[16:09:35.090]                       }
[16:09:35.090]                     }
[16:09:35.090]                     invisible(muffled)
[16:09:35.090]                   }
[16:09:35.090]                   muffleCondition(cond)
[16:09:35.090]                 })
[16:09:35.090]             }))
[16:09:35.090]             future::FutureResult(value = ...future.value$value, 
[16:09:35.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.090]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.090]                     ...future.globalenv.names))
[16:09:35.090]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.090]         }, condition = base::local({
[16:09:35.090]             c <- base::c
[16:09:35.090]             inherits <- base::inherits
[16:09:35.090]             invokeRestart <- base::invokeRestart
[16:09:35.090]             length <- base::length
[16:09:35.090]             list <- base::list
[16:09:35.090]             seq.int <- base::seq.int
[16:09:35.090]             signalCondition <- base::signalCondition
[16:09:35.090]             sys.calls <- base::sys.calls
[16:09:35.090]             `[[` <- base::`[[`
[16:09:35.090]             `+` <- base::`+`
[16:09:35.090]             `<<-` <- base::`<<-`
[16:09:35.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.090]                   3L)]
[16:09:35.090]             }
[16:09:35.090]             function(cond) {
[16:09:35.090]                 is_error <- inherits(cond, "error")
[16:09:35.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.090]                   NULL)
[16:09:35.090]                 if (is_error) {
[16:09:35.090]                   sessionInformation <- function() {
[16:09:35.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.090]                       search = base::search(), system = base::Sys.info())
[16:09:35.090]                   }
[16:09:35.090]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.090]                     cond$call), session = sessionInformation(), 
[16:09:35.090]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.090]                   signalCondition(cond)
[16:09:35.090]                 }
[16:09:35.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.090]                 "immediateCondition"))) {
[16:09:35.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.090]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.090]                   if (TRUE && !signal) {
[16:09:35.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.090]                     {
[16:09:35.090]                       inherits <- base::inherits
[16:09:35.090]                       invokeRestart <- base::invokeRestart
[16:09:35.090]                       is.null <- base::is.null
[16:09:35.090]                       muffled <- FALSE
[16:09:35.090]                       if (inherits(cond, "message")) {
[16:09:35.090]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.090]                         if (muffled) 
[16:09:35.090]                           invokeRestart("muffleMessage")
[16:09:35.090]                       }
[16:09:35.090]                       else if (inherits(cond, "warning")) {
[16:09:35.090]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.090]                         if (muffled) 
[16:09:35.090]                           invokeRestart("muffleWarning")
[16:09:35.090]                       }
[16:09:35.090]                       else if (inherits(cond, "condition")) {
[16:09:35.090]                         if (!is.null(pattern)) {
[16:09:35.090]                           computeRestarts <- base::computeRestarts
[16:09:35.090]                           grepl <- base::grepl
[16:09:35.090]                           restarts <- computeRestarts(cond)
[16:09:35.090]                           for (restart in restarts) {
[16:09:35.090]                             name <- restart$name
[16:09:35.090]                             if (is.null(name)) 
[16:09:35.090]                               next
[16:09:35.090]                             if (!grepl(pattern, name)) 
[16:09:35.090]                               next
[16:09:35.090]                             invokeRestart(restart)
[16:09:35.090]                             muffled <- TRUE
[16:09:35.090]                             break
[16:09:35.090]                           }
[16:09:35.090]                         }
[16:09:35.090]                       }
[16:09:35.090]                       invisible(muffled)
[16:09:35.090]                     }
[16:09:35.090]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.090]                   }
[16:09:35.090]                 }
[16:09:35.090]                 else {
[16:09:35.090]                   if (TRUE) {
[16:09:35.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.090]                     {
[16:09:35.090]                       inherits <- base::inherits
[16:09:35.090]                       invokeRestart <- base::invokeRestart
[16:09:35.090]                       is.null <- base::is.null
[16:09:35.090]                       muffled <- FALSE
[16:09:35.090]                       if (inherits(cond, "message")) {
[16:09:35.090]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.090]                         if (muffled) 
[16:09:35.090]                           invokeRestart("muffleMessage")
[16:09:35.090]                       }
[16:09:35.090]                       else if (inherits(cond, "warning")) {
[16:09:35.090]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.090]                         if (muffled) 
[16:09:35.090]                           invokeRestart("muffleWarning")
[16:09:35.090]                       }
[16:09:35.090]                       else if (inherits(cond, "condition")) {
[16:09:35.090]                         if (!is.null(pattern)) {
[16:09:35.090]                           computeRestarts <- base::computeRestarts
[16:09:35.090]                           grepl <- base::grepl
[16:09:35.090]                           restarts <- computeRestarts(cond)
[16:09:35.090]                           for (restart in restarts) {
[16:09:35.090]                             name <- restart$name
[16:09:35.090]                             if (is.null(name)) 
[16:09:35.090]                               next
[16:09:35.090]                             if (!grepl(pattern, name)) 
[16:09:35.090]                               next
[16:09:35.090]                             invokeRestart(restart)
[16:09:35.090]                             muffled <- TRUE
[16:09:35.090]                             break
[16:09:35.090]                           }
[16:09:35.090]                         }
[16:09:35.090]                       }
[16:09:35.090]                       invisible(muffled)
[16:09:35.090]                     }
[16:09:35.090]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.090]                   }
[16:09:35.090]                 }
[16:09:35.090]             }
[16:09:35.090]         }))
[16:09:35.090]     }, error = function(ex) {
[16:09:35.090]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.090]                 ...future.rng), started = ...future.startTime, 
[16:09:35.090]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.090]             version = "1.8"), class = "FutureResult")
[16:09:35.090]     }, finally = {
[16:09:35.090]         if (!identical(...future.workdir, getwd())) 
[16:09:35.090]             setwd(...future.workdir)
[16:09:35.090]         {
[16:09:35.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.090]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.090]             }
[16:09:35.090]             base::options(...future.oldOptions)
[16:09:35.090]             if (.Platform$OS.type == "windows") {
[16:09:35.090]                 old_names <- names(...future.oldEnvVars)
[16:09:35.090]                 envs <- base::Sys.getenv()
[16:09:35.090]                 names <- names(envs)
[16:09:35.090]                 common <- intersect(names, old_names)
[16:09:35.090]                 added <- setdiff(names, old_names)
[16:09:35.090]                 removed <- setdiff(old_names, names)
[16:09:35.090]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.090]                   envs[common]]
[16:09:35.090]                 NAMES <- toupper(changed)
[16:09:35.090]                 args <- list()
[16:09:35.090]                 for (kk in seq_along(NAMES)) {
[16:09:35.090]                   name <- changed[[kk]]
[16:09:35.090]                   NAME <- NAMES[[kk]]
[16:09:35.090]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.090]                     next
[16:09:35.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.090]                 }
[16:09:35.090]                 NAMES <- toupper(added)
[16:09:35.090]                 for (kk in seq_along(NAMES)) {
[16:09:35.090]                   name <- added[[kk]]
[16:09:35.090]                   NAME <- NAMES[[kk]]
[16:09:35.090]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.090]                     next
[16:09:35.090]                   args[[name]] <- ""
[16:09:35.090]                 }
[16:09:35.090]                 NAMES <- toupper(removed)
[16:09:35.090]                 for (kk in seq_along(NAMES)) {
[16:09:35.090]                   name <- removed[[kk]]
[16:09:35.090]                   NAME <- NAMES[[kk]]
[16:09:35.090]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.090]                     next
[16:09:35.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.090]                 }
[16:09:35.090]                 if (length(args) > 0) 
[16:09:35.090]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.090]             }
[16:09:35.090]             else {
[16:09:35.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.090]             }
[16:09:35.090]             {
[16:09:35.090]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.090]                   0L) {
[16:09:35.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.090]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.090]                   base::options(opts)
[16:09:35.090]                 }
[16:09:35.090]                 {
[16:09:35.090]                   {
[16:09:35.090]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.090]                     NULL
[16:09:35.090]                   }
[16:09:35.090]                   options(future.plan = NULL)
[16:09:35.090]                   if (is.na(NA_character_)) 
[16:09:35.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.090]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:35.090]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:35.090]                     envir = parent.frame()) 
[16:09:35.090]                   {
[16:09:35.090]                     if (is.function(workers)) 
[16:09:35.090]                       workers <- workers()
[16:09:35.090]                     workers <- structure(as.integer(workers), 
[16:09:35.090]                       class = class(workers))
[16:09:35.090]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:35.090]                       workers >= 1)
[16:09:35.090]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:35.090]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:35.090]                     }
[16:09:35.090]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:35.090]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:35.090]                       envir = envir)
[16:09:35.090]                     if (!future$lazy) 
[16:09:35.090]                       future <- run(future)
[16:09:35.090]                     invisible(future)
[16:09:35.090]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.090]                 }
[16:09:35.090]             }
[16:09:35.090]         }
[16:09:35.090]     })
[16:09:35.090]     if (TRUE) {
[16:09:35.090]         base::sink(type = "output", split = FALSE)
[16:09:35.090]         if (TRUE) {
[16:09:35.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.090]         }
[16:09:35.090]         else {
[16:09:35.090]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.090]         }
[16:09:35.090]         base::close(...future.stdout)
[16:09:35.090]         ...future.stdout <- NULL
[16:09:35.090]     }
[16:09:35.090]     ...future.result$conditions <- ...future.conditions
[16:09:35.090]     ...future.result$finished <- base::Sys.time()
[16:09:35.090]     ...future.result
[16:09:35.090] }
[16:09:35.093] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[16:09:35.093] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[16:09:35.094] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[16:09:35.094] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[16:09:35.094] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[16:09:35.095] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[16:09:35.095] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[16:09:35.095] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:35.095] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.096] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:09:35.096] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:09:35.096] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:35.097] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.097] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:35.097] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.097] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[16:09:35.098] MultisessionFuture started
[16:09:35.098] - Launch lazy future ... done
[16:09:35.098] run() for ‘MultisessionFuture’ ... done
[16:09:35.098] Created future:
[16:09:35.098] MultisessionFuture:
[16:09:35.098] Label: ‘future_by-2’
[16:09:35.098] Expression:
[16:09:35.098] {
[16:09:35.098]     do.call(function(...) {
[16:09:35.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.098]             on.exit(options(oopts), add = TRUE)
[16:09:35.098]         }
[16:09:35.098]         {
[16:09:35.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.098]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.098]             })
[16:09:35.098]         }
[16:09:35.098]     }, args = future.call.arguments)
[16:09:35.098] }
[16:09:35.098] Lazy evaluation: FALSE
[16:09:35.098] Asynchronous evaluation: TRUE
[16:09:35.098] Local evaluation: TRUE
[16:09:35.098] Environment: 0x5567e9edf2b8
[16:09:35.098] Capture standard output: TRUE
[16:09:35.098] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.098] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:09:35.098] Packages: 1 packages (‘stats’)
[16:09:35.098] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.098] Resolved: FALSE
[16:09:35.098] Value: <not collected>
[16:09:35.098] Conditions captured: <none>
[16:09:35.098] Early signaling: FALSE
[16:09:35.098] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:35.098] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.110] Chunk #2 of 2 ... DONE
[16:09:35.110] Launching 2 futures (chunks) ... DONE
[16:09:35.110] Resolving 2 futures (chunks) ...
[16:09:35.111] resolve() on list ...
[16:09:35.111]  recursive: 0
[16:09:35.111]  length: 2
[16:09:35.111] 
[16:09:35.111] receiveMessageFromWorker() for ClusterFuture ...
[16:09:35.112] - Validating connection of MultisessionFuture
[16:09:35.112] - received message: FutureResult
[16:09:35.112] - Received FutureResult
[16:09:35.112] - Erased future from FutureRegistry
[16:09:35.112] result() for ClusterFuture ...
[16:09:35.112] - result already collected: FutureResult
[16:09:35.112] result() for ClusterFuture ... done
[16:09:35.112] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:35.113] Future #1
[16:09:35.113] result() for ClusterFuture ...
[16:09:35.113] - result already collected: FutureResult
[16:09:35.113] result() for ClusterFuture ... done
[16:09:35.113] result() for ClusterFuture ...
[16:09:35.113] - result already collected: FutureResult
[16:09:35.113] result() for ClusterFuture ... done
[16:09:35.113] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:35.113] - nx: 2
[16:09:35.113] - relay: TRUE
[16:09:35.113] - stdout: TRUE
[16:09:35.114] - signal: TRUE
[16:09:35.114] - resignal: FALSE
[16:09:35.114] - force: TRUE
[16:09:35.114] - relayed: [n=2] FALSE, FALSE
[16:09:35.114] - queued futures: [n=2] FALSE, FALSE
[16:09:35.114]  - until=1
[16:09:35.114]  - relaying element #1
[16:09:35.114] result() for ClusterFuture ...
[16:09:35.114] - result already collected: FutureResult
[16:09:35.114] result() for ClusterFuture ... done
[16:09:35.114] result() for ClusterFuture ...
[16:09:35.114] - result already collected: FutureResult
[16:09:35.114] result() for ClusterFuture ... done
[16:09:35.115] result() for ClusterFuture ...
[16:09:35.115] - result already collected: FutureResult
[16:09:35.115] result() for ClusterFuture ... done
[16:09:35.115] result() for ClusterFuture ...
[16:09:35.115] - result already collected: FutureResult
[16:09:35.115] result() for ClusterFuture ... done
[16:09:35.115] - relayed: [n=2] TRUE, FALSE
[16:09:35.115] - queued futures: [n=2] TRUE, FALSE
[16:09:35.115] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:35.115]  length: 1 (resolved future 1)
[16:09:35.146] receiveMessageFromWorker() for ClusterFuture ...
[16:09:35.146] - Validating connection of MultisessionFuture
[16:09:35.146] - received message: FutureResult
[16:09:35.147] - Received FutureResult
[16:09:35.147] - Erased future from FutureRegistry
[16:09:35.147] result() for ClusterFuture ...
[16:09:35.147] - result already collected: FutureResult
[16:09:35.147] result() for ClusterFuture ... done
[16:09:35.147] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:35.147] Future #2
[16:09:35.147] result() for ClusterFuture ...
[16:09:35.147] - result already collected: FutureResult
[16:09:35.147] result() for ClusterFuture ... done
[16:09:35.147] result() for ClusterFuture ...
[16:09:35.148] - result already collected: FutureResult
[16:09:35.148] result() for ClusterFuture ... done
[16:09:35.148] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:35.148] - nx: 2
[16:09:35.148] - relay: TRUE
[16:09:35.148] - stdout: TRUE
[16:09:35.148] - signal: TRUE
[16:09:35.148] - resignal: FALSE
[16:09:35.148] - force: TRUE
[16:09:35.148] - relayed: [n=2] TRUE, FALSE
[16:09:35.148] - queued futures: [n=2] TRUE, FALSE
[16:09:35.149]  - until=2
[16:09:35.149]  - relaying element #2
[16:09:35.149] result() for ClusterFuture ...
[16:09:35.149] - result already collected: FutureResult
[16:09:35.149] result() for ClusterFuture ... done
[16:09:35.149] result() for ClusterFuture ...
[16:09:35.149] - result already collected: FutureResult
[16:09:35.149] result() for ClusterFuture ... done
[16:09:35.149] result() for ClusterFuture ...
[16:09:35.149] - result already collected: FutureResult
[16:09:35.149] result() for ClusterFuture ... done
[16:09:35.150] result() for ClusterFuture ...
[16:09:35.150] - result already collected: FutureResult
[16:09:35.150] result() for ClusterFuture ... done
[16:09:35.150] - relayed: [n=2] TRUE, TRUE
[16:09:35.150] - queued futures: [n=2] TRUE, TRUE
[16:09:35.150] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:35.150]  length: 0 (resolved future 2)
[16:09:35.150] Relaying remaining futures
[16:09:35.150] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.150] - nx: 2
[16:09:35.150] - relay: TRUE
[16:09:35.150] - stdout: TRUE
[16:09:35.151] - signal: TRUE
[16:09:35.151] - resignal: FALSE
[16:09:35.151] - force: TRUE
[16:09:35.151] - relayed: [n=2] TRUE, TRUE
[16:09:35.151] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:35.151] - relayed: [n=2] TRUE, TRUE
[16:09:35.151] - queued futures: [n=2] TRUE, TRUE
[16:09:35.151] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.151] resolve() on list ... DONE
[16:09:35.151] result() for ClusterFuture ...
[16:09:35.151] - result already collected: FutureResult
[16:09:35.151] result() for ClusterFuture ... done
[16:09:35.152] result() for ClusterFuture ...
[16:09:35.152] - result already collected: FutureResult
[16:09:35.152] result() for ClusterFuture ... done
[16:09:35.152] result() for ClusterFuture ...
[16:09:35.152] - result already collected: FutureResult
[16:09:35.152] result() for ClusterFuture ... done
[16:09:35.152] result() for ClusterFuture ...
[16:09:35.152] - result already collected: FutureResult
[16:09:35.152] result() for ClusterFuture ... done
[16:09:35.152]  - Number of value chunks collected: 2
[16:09:35.152] Resolving 2 futures (chunks) ... DONE
[16:09:35.153] Reducing values from 2 chunks ...
[16:09:35.153]  - Number of values collected after concatenation: 3
[16:09:35.153]  - Number of values expected: 3
[16:09:35.153] Reducing values from 2 chunks ... DONE
[16:09:35.153] future_lapply() ... DONE
[16:09:35.153] future_by_internal() ... DONE
[16:09:35.153] future_by_internal() ...
[16:09:35.154] future_lapply() ...
[16:09:35.158] Number of chunks: 2
[16:09:35.158] getGlobalsAndPackagesXApply() ...
[16:09:35.158]  - future.globals: TRUE
[16:09:35.158] getGlobalsAndPackages() ...
[16:09:35.158] Searching for globals...
[16:09:35.159] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.159] Searching for globals ... DONE
[16:09:35.159] Resolving globals: FALSE
[16:09:35.160] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:35.160] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:35.160] - globals: [1] ‘FUN’
[16:09:35.160] 
[16:09:35.160] getGlobalsAndPackages() ... DONE
[16:09:35.160]  - globals found/used: [n=1] ‘FUN’
[16:09:35.161]  - needed namespaces: [n=0] 
[16:09:35.161] Finding globals ... DONE
[16:09:35.161]  - use_args: TRUE
[16:09:35.161]  - Getting '...' globals ...
[16:09:35.161] resolve() on list ...
[16:09:35.161]  recursive: 0
[16:09:35.161]  length: 1
[16:09:35.161]  elements: ‘...’
[16:09:35.162]  length: 0 (resolved future 1)
[16:09:35.162] resolve() on list ... DONE
[16:09:35.162]    - '...' content: [n=0] 
[16:09:35.162] List of 1
[16:09:35.162]  $ ...: list()
[16:09:35.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.162]  - attr(*, "where")=List of 1
[16:09:35.162]   ..$ ...:<environment: 0x5567ea5a9560> 
[16:09:35.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.162]  - attr(*, "resolved")= logi TRUE
[16:09:35.162]  - attr(*, "total_size")= num NA
[16:09:35.164]  - Getting '...' globals ... DONE
[16:09:35.165] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.165] List of 2
[16:09:35.165]  $ ...future.FUN:function (object, ...)  
[16:09:35.165]  $ ...          : list()
[16:09:35.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.165]  - attr(*, "where")=List of 2
[16:09:35.165]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.165]   ..$ ...          :<environment: 0x5567ea5a9560> 
[16:09:35.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.165]  - attr(*, "resolved")= logi FALSE
[16:09:35.165]  - attr(*, "total_size")= num 1240
[16:09:35.167] Packages to be attached in all futures: [n=0] 
[16:09:35.167] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.167] Number of futures (= number of chunks): 2
[16:09:35.168] Launching 2 futures (chunks) ...
[16:09:35.168] Chunk #1 of 2 ...
[16:09:35.168]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.168] getGlobalsAndPackages() ...
[16:09:35.168] Searching for globals...
[16:09:35.168] 
[16:09:35.168] Searching for globals ... DONE
[16:09:35.169] - globals: [0] <none>
[16:09:35.169] getGlobalsAndPackages() ... DONE
[16:09:35.169]    + additional globals found: [n=0] 
[16:09:35.169]    + additional namespaces needed: [n=0] 
[16:09:35.169]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.169]  - seeds: <none>
[16:09:35.169] getGlobalsAndPackages() ...
[16:09:35.169] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.169] Resolving globals: FALSE
[16:09:35.169] Tweak future expression to call with '...' arguments ...
[16:09:35.169] {
[16:09:35.169]     do.call(function(...) {
[16:09:35.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.169]             on.exit(options(oopts), add = TRUE)
[16:09:35.169]         }
[16:09:35.169]         {
[16:09:35.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.169]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.169]             })
[16:09:35.169]         }
[16:09:35.169]     }, args = future.call.arguments)
[16:09:35.169] }
[16:09:35.170] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.170] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.170] 
[16:09:35.170] getGlobalsAndPackages() ... DONE
[16:09:35.171] run() for ‘Future’ ...
[16:09:35.171] - state: ‘created’
[16:09:35.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.185] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:35.186]   - Field: ‘node’
[16:09:35.186]   - Field: ‘label’
[16:09:35.186]   - Field: ‘local’
[16:09:35.186]   - Field: ‘owner’
[16:09:35.186]   - Field: ‘envir’
[16:09:35.186]   - Field: ‘workers’
[16:09:35.186]   - Field: ‘packages’
[16:09:35.186]   - Field: ‘gc’
[16:09:35.186]   - Field: ‘conditions’
[16:09:35.186]   - Field: ‘persistent’
[16:09:35.187]   - Field: ‘expr’
[16:09:35.187]   - Field: ‘uuid’
[16:09:35.187]   - Field: ‘seed’
[16:09:35.187]   - Field: ‘version’
[16:09:35.187]   - Field: ‘result’
[16:09:35.187]   - Field: ‘asynchronous’
[16:09:35.187]   - Field: ‘calls’
[16:09:35.187]   - Field: ‘globals’
[16:09:35.187]   - Field: ‘stdout’
[16:09:35.187]   - Field: ‘earlySignal’
[16:09:35.187]   - Field: ‘lazy’
[16:09:35.188]   - Field: ‘state’
[16:09:35.188] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:35.188] - Launch lazy future ...
[16:09:35.188] Packages needed by the future expression (n = 0): <none>
[16:09:35.188] Packages needed by future strategies (n = 0): <none>
[16:09:35.189] {
[16:09:35.189]     {
[16:09:35.189]         {
[16:09:35.189]             ...future.startTime <- base::Sys.time()
[16:09:35.189]             {
[16:09:35.189]                 {
[16:09:35.189]                   {
[16:09:35.189]                     {
[16:09:35.189]                       base::local({
[16:09:35.189]                         has_future <- base::requireNamespace("future", 
[16:09:35.189]                           quietly = TRUE)
[16:09:35.189]                         if (has_future) {
[16:09:35.189]                           ns <- base::getNamespace("future")
[16:09:35.189]                           version <- ns[[".package"]][["version"]]
[16:09:35.189]                           if (is.null(version)) 
[16:09:35.189]                             version <- utils::packageVersion("future")
[16:09:35.189]                         }
[16:09:35.189]                         else {
[16:09:35.189]                           version <- NULL
[16:09:35.189]                         }
[16:09:35.189]                         if (!has_future || version < "1.8.0") {
[16:09:35.189]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.189]                             "", base::R.version$version.string), 
[16:09:35.189]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.189]                               "release", "version")], collapse = " "), 
[16:09:35.189]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.189]                             info)
[16:09:35.189]                           info <- base::paste(info, collapse = "; ")
[16:09:35.189]                           if (!has_future) {
[16:09:35.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.189]                               info)
[16:09:35.189]                           }
[16:09:35.189]                           else {
[16:09:35.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.189]                               info, version)
[16:09:35.189]                           }
[16:09:35.189]                           base::stop(msg)
[16:09:35.189]                         }
[16:09:35.189]                       })
[16:09:35.189]                     }
[16:09:35.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.189]                     base::options(mc.cores = 1L)
[16:09:35.189]                   }
[16:09:35.189]                   options(future.plan = NULL)
[16:09:35.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.189]                 }
[16:09:35.189]                 ...future.workdir <- getwd()
[16:09:35.189]             }
[16:09:35.189]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.189]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.189]         }
[16:09:35.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:35.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.189]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.189]             base::names(...future.oldOptions))
[16:09:35.189]     }
[16:09:35.189]     if (FALSE) {
[16:09:35.189]     }
[16:09:35.189]     else {
[16:09:35.189]         if (TRUE) {
[16:09:35.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.189]                 open = "w")
[16:09:35.189]         }
[16:09:35.189]         else {
[16:09:35.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.189]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.189]         }
[16:09:35.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.189]             base::sink(type = "output", split = FALSE)
[16:09:35.189]             base::close(...future.stdout)
[16:09:35.189]         }, add = TRUE)
[16:09:35.189]     }
[16:09:35.189]     ...future.frame <- base::sys.nframe()
[16:09:35.189]     ...future.conditions <- base::list()
[16:09:35.189]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.189]     if (FALSE) {
[16:09:35.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.189]     }
[16:09:35.189]     ...future.result <- base::tryCatch({
[16:09:35.189]         base::withCallingHandlers({
[16:09:35.189]             ...future.value <- base::withVisible(base::local({
[16:09:35.189]                 ...future.makeSendCondition <- local({
[16:09:35.189]                   sendCondition <- NULL
[16:09:35.189]                   function(frame = 1L) {
[16:09:35.189]                     if (is.function(sendCondition)) 
[16:09:35.189]                       return(sendCondition)
[16:09:35.189]                     ns <- getNamespace("parallel")
[16:09:35.189]                     if (exists("sendData", mode = "function", 
[16:09:35.189]                       envir = ns)) {
[16:09:35.189]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:35.189]                         envir = ns)
[16:09:35.189]                       envir <- sys.frame(frame)
[16:09:35.189]                       master <- NULL
[16:09:35.189]                       while (!identical(envir, .GlobalEnv) && 
[16:09:35.189]                         !identical(envir, emptyenv())) {
[16:09:35.189]                         if (exists("master", mode = "list", envir = envir, 
[16:09:35.189]                           inherits = FALSE)) {
[16:09:35.189]                           master <- get("master", mode = "list", 
[16:09:35.189]                             envir = envir, inherits = FALSE)
[16:09:35.189]                           if (inherits(master, c("SOCKnode", 
[16:09:35.189]                             "SOCK0node"))) {
[16:09:35.189]                             sendCondition <<- function(cond) {
[16:09:35.189]                               data <- list(type = "VALUE", value = cond, 
[16:09:35.189]                                 success = TRUE)
[16:09:35.189]                               parallel_sendData(master, data)
[16:09:35.189]                             }
[16:09:35.189]                             return(sendCondition)
[16:09:35.189]                           }
[16:09:35.189]                         }
[16:09:35.189]                         frame <- frame + 1L
[16:09:35.189]                         envir <- sys.frame(frame)
[16:09:35.189]                       }
[16:09:35.189]                     }
[16:09:35.189]                     sendCondition <<- function(cond) NULL
[16:09:35.189]                   }
[16:09:35.189]                 })
[16:09:35.189]                 withCallingHandlers({
[16:09:35.189]                   {
[16:09:35.189]                     do.call(function(...) {
[16:09:35.189]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.189]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.189]                         ...future.globals.maxSize)) {
[16:09:35.189]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.189]                         on.exit(options(oopts), add = TRUE)
[16:09:35.189]                       }
[16:09:35.189]                       {
[16:09:35.189]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.189]                           FUN = function(jj) {
[16:09:35.189]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.189]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.189]                           })
[16:09:35.189]                       }
[16:09:35.189]                     }, args = future.call.arguments)
[16:09:35.189]                   }
[16:09:35.189]                 }, immediateCondition = function(cond) {
[16:09:35.189]                   sendCondition <- ...future.makeSendCondition()
[16:09:35.189]                   sendCondition(cond)
[16:09:35.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.189]                   {
[16:09:35.189]                     inherits <- base::inherits
[16:09:35.189]                     invokeRestart <- base::invokeRestart
[16:09:35.189]                     is.null <- base::is.null
[16:09:35.189]                     muffled <- FALSE
[16:09:35.189]                     if (inherits(cond, "message")) {
[16:09:35.189]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.189]                       if (muffled) 
[16:09:35.189]                         invokeRestart("muffleMessage")
[16:09:35.189]                     }
[16:09:35.189]                     else if (inherits(cond, "warning")) {
[16:09:35.189]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.189]                       if (muffled) 
[16:09:35.189]                         invokeRestart("muffleWarning")
[16:09:35.189]                     }
[16:09:35.189]                     else if (inherits(cond, "condition")) {
[16:09:35.189]                       if (!is.null(pattern)) {
[16:09:35.189]                         computeRestarts <- base::computeRestarts
[16:09:35.189]                         grepl <- base::grepl
[16:09:35.189]                         restarts <- computeRestarts(cond)
[16:09:35.189]                         for (restart in restarts) {
[16:09:35.189]                           name <- restart$name
[16:09:35.189]                           if (is.null(name)) 
[16:09:35.189]                             next
[16:09:35.189]                           if (!grepl(pattern, name)) 
[16:09:35.189]                             next
[16:09:35.189]                           invokeRestart(restart)
[16:09:35.189]                           muffled <- TRUE
[16:09:35.189]                           break
[16:09:35.189]                         }
[16:09:35.189]                       }
[16:09:35.189]                     }
[16:09:35.189]                     invisible(muffled)
[16:09:35.189]                   }
[16:09:35.189]                   muffleCondition(cond)
[16:09:35.189]                 })
[16:09:35.189]             }))
[16:09:35.189]             future::FutureResult(value = ...future.value$value, 
[16:09:35.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.189]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.189]                     ...future.globalenv.names))
[16:09:35.189]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.189]         }, condition = base::local({
[16:09:35.189]             c <- base::c
[16:09:35.189]             inherits <- base::inherits
[16:09:35.189]             invokeRestart <- base::invokeRestart
[16:09:35.189]             length <- base::length
[16:09:35.189]             list <- base::list
[16:09:35.189]             seq.int <- base::seq.int
[16:09:35.189]             signalCondition <- base::signalCondition
[16:09:35.189]             sys.calls <- base::sys.calls
[16:09:35.189]             `[[` <- base::`[[`
[16:09:35.189]             `+` <- base::`+`
[16:09:35.189]             `<<-` <- base::`<<-`
[16:09:35.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.189]                   3L)]
[16:09:35.189]             }
[16:09:35.189]             function(cond) {
[16:09:35.189]                 is_error <- inherits(cond, "error")
[16:09:35.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.189]                   NULL)
[16:09:35.189]                 if (is_error) {
[16:09:35.189]                   sessionInformation <- function() {
[16:09:35.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.189]                       search = base::search(), system = base::Sys.info())
[16:09:35.189]                   }
[16:09:35.189]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.189]                     cond$call), session = sessionInformation(), 
[16:09:35.189]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.189]                   signalCondition(cond)
[16:09:35.189]                 }
[16:09:35.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.189]                 "immediateCondition"))) {
[16:09:35.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.189]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.189]                   if (TRUE && !signal) {
[16:09:35.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.189]                     {
[16:09:35.189]                       inherits <- base::inherits
[16:09:35.189]                       invokeRestart <- base::invokeRestart
[16:09:35.189]                       is.null <- base::is.null
[16:09:35.189]                       muffled <- FALSE
[16:09:35.189]                       if (inherits(cond, "message")) {
[16:09:35.189]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.189]                         if (muffled) 
[16:09:35.189]                           invokeRestart("muffleMessage")
[16:09:35.189]                       }
[16:09:35.189]                       else if (inherits(cond, "warning")) {
[16:09:35.189]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.189]                         if (muffled) 
[16:09:35.189]                           invokeRestart("muffleWarning")
[16:09:35.189]                       }
[16:09:35.189]                       else if (inherits(cond, "condition")) {
[16:09:35.189]                         if (!is.null(pattern)) {
[16:09:35.189]                           computeRestarts <- base::computeRestarts
[16:09:35.189]                           grepl <- base::grepl
[16:09:35.189]                           restarts <- computeRestarts(cond)
[16:09:35.189]                           for (restart in restarts) {
[16:09:35.189]                             name <- restart$name
[16:09:35.189]                             if (is.null(name)) 
[16:09:35.189]                               next
[16:09:35.189]                             if (!grepl(pattern, name)) 
[16:09:35.189]                               next
[16:09:35.189]                             invokeRestart(restart)
[16:09:35.189]                             muffled <- TRUE
[16:09:35.189]                             break
[16:09:35.189]                           }
[16:09:35.189]                         }
[16:09:35.189]                       }
[16:09:35.189]                       invisible(muffled)
[16:09:35.189]                     }
[16:09:35.189]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.189]                   }
[16:09:35.189]                 }
[16:09:35.189]                 else {
[16:09:35.189]                   if (TRUE) {
[16:09:35.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.189]                     {
[16:09:35.189]                       inherits <- base::inherits
[16:09:35.189]                       invokeRestart <- base::invokeRestart
[16:09:35.189]                       is.null <- base::is.null
[16:09:35.189]                       muffled <- FALSE
[16:09:35.189]                       if (inherits(cond, "message")) {
[16:09:35.189]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.189]                         if (muffled) 
[16:09:35.189]                           invokeRestart("muffleMessage")
[16:09:35.189]                       }
[16:09:35.189]                       else if (inherits(cond, "warning")) {
[16:09:35.189]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.189]                         if (muffled) 
[16:09:35.189]                           invokeRestart("muffleWarning")
[16:09:35.189]                       }
[16:09:35.189]                       else if (inherits(cond, "condition")) {
[16:09:35.189]                         if (!is.null(pattern)) {
[16:09:35.189]                           computeRestarts <- base::computeRestarts
[16:09:35.189]                           grepl <- base::grepl
[16:09:35.189]                           restarts <- computeRestarts(cond)
[16:09:35.189]                           for (restart in restarts) {
[16:09:35.189]                             name <- restart$name
[16:09:35.189]                             if (is.null(name)) 
[16:09:35.189]                               next
[16:09:35.189]                             if (!grepl(pattern, name)) 
[16:09:35.189]                               next
[16:09:35.189]                             invokeRestart(restart)
[16:09:35.189]                             muffled <- TRUE
[16:09:35.189]                             break
[16:09:35.189]                           }
[16:09:35.189]                         }
[16:09:35.189]                       }
[16:09:35.189]                       invisible(muffled)
[16:09:35.189]                     }
[16:09:35.189]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.189]                   }
[16:09:35.189]                 }
[16:09:35.189]             }
[16:09:35.189]         }))
[16:09:35.189]     }, error = function(ex) {
[16:09:35.189]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.189]                 ...future.rng), started = ...future.startTime, 
[16:09:35.189]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.189]             version = "1.8"), class = "FutureResult")
[16:09:35.189]     }, finally = {
[16:09:35.189]         if (!identical(...future.workdir, getwd())) 
[16:09:35.189]             setwd(...future.workdir)
[16:09:35.189]         {
[16:09:35.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.189]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.189]             }
[16:09:35.189]             base::options(...future.oldOptions)
[16:09:35.189]             if (.Platform$OS.type == "windows") {
[16:09:35.189]                 old_names <- names(...future.oldEnvVars)
[16:09:35.189]                 envs <- base::Sys.getenv()
[16:09:35.189]                 names <- names(envs)
[16:09:35.189]                 common <- intersect(names, old_names)
[16:09:35.189]                 added <- setdiff(names, old_names)
[16:09:35.189]                 removed <- setdiff(old_names, names)
[16:09:35.189]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.189]                   envs[common]]
[16:09:35.189]                 NAMES <- toupper(changed)
[16:09:35.189]                 args <- list()
[16:09:35.189]                 for (kk in seq_along(NAMES)) {
[16:09:35.189]                   name <- changed[[kk]]
[16:09:35.189]                   NAME <- NAMES[[kk]]
[16:09:35.189]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.189]                     next
[16:09:35.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.189]                 }
[16:09:35.189]                 NAMES <- toupper(added)
[16:09:35.189]                 for (kk in seq_along(NAMES)) {
[16:09:35.189]                   name <- added[[kk]]
[16:09:35.189]                   NAME <- NAMES[[kk]]
[16:09:35.189]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.189]                     next
[16:09:35.189]                   args[[name]] <- ""
[16:09:35.189]                 }
[16:09:35.189]                 NAMES <- toupper(removed)
[16:09:35.189]                 for (kk in seq_along(NAMES)) {
[16:09:35.189]                   name <- removed[[kk]]
[16:09:35.189]                   NAME <- NAMES[[kk]]
[16:09:35.189]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.189]                     next
[16:09:35.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.189]                 }
[16:09:35.189]                 if (length(args) > 0) 
[16:09:35.189]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.189]             }
[16:09:35.189]             else {
[16:09:35.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.189]             }
[16:09:35.189]             {
[16:09:35.189]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.189]                   0L) {
[16:09:35.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.189]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.189]                   base::options(opts)
[16:09:35.189]                 }
[16:09:35.189]                 {
[16:09:35.189]                   {
[16:09:35.189]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.189]                     NULL
[16:09:35.189]                   }
[16:09:35.189]                   options(future.plan = NULL)
[16:09:35.189]                   if (is.na(NA_character_)) 
[16:09:35.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.189]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:35.189]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:35.189]                     envir = parent.frame()) 
[16:09:35.189]                   {
[16:09:35.189]                     if (is.function(workers)) 
[16:09:35.189]                       workers <- workers()
[16:09:35.189]                     workers <- structure(as.integer(workers), 
[16:09:35.189]                       class = class(workers))
[16:09:35.189]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:35.189]                       workers >= 1)
[16:09:35.189]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:35.189]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:35.189]                     }
[16:09:35.189]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:35.189]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:35.189]                       envir = envir)
[16:09:35.189]                     if (!future$lazy) 
[16:09:35.189]                       future <- run(future)
[16:09:35.189]                     invisible(future)
[16:09:35.189]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.189]                 }
[16:09:35.189]             }
[16:09:35.189]         }
[16:09:35.189]     })
[16:09:35.189]     if (TRUE) {
[16:09:35.189]         base::sink(type = "output", split = FALSE)
[16:09:35.189]         if (TRUE) {
[16:09:35.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.189]         }
[16:09:35.189]         else {
[16:09:35.189]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.189]         }
[16:09:35.189]         base::close(...future.stdout)
[16:09:35.189]         ...future.stdout <- NULL
[16:09:35.189]     }
[16:09:35.189]     ...future.result$conditions <- ...future.conditions
[16:09:35.189]     ...future.result$finished <- base::Sys.time()
[16:09:35.189]     ...future.result
[16:09:35.189] }
[16:09:35.191] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:09:35.192] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:09:35.192] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:09:35.192] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:35.193] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.193] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:09:35.193] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:09:35.193] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:35.194] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.194] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:35.194] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.194] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:09:35.195] MultisessionFuture started
[16:09:35.195] - Launch lazy future ... done
[16:09:35.195] run() for ‘MultisessionFuture’ ... done
[16:09:35.195] Created future:
[16:09:35.195] MultisessionFuture:
[16:09:35.195] Label: ‘future_by-1’
[16:09:35.195] Expression:
[16:09:35.195] {
[16:09:35.195]     do.call(function(...) {
[16:09:35.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.195]             on.exit(options(oopts), add = TRUE)
[16:09:35.195]         }
[16:09:35.195]         {
[16:09:35.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.195]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.195]             })
[16:09:35.195]         }
[16:09:35.195]     }, args = future.call.arguments)
[16:09:35.195] }
[16:09:35.195] Lazy evaluation: FALSE
[16:09:35.195] Asynchronous evaluation: TRUE
[16:09:35.195] Local evaluation: TRUE
[16:09:35.195] Environment: 0x5567ea5d5d18
[16:09:35.195] Capture standard output: TRUE
[16:09:35.195] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.195] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.195] Packages: <none>
[16:09:35.195] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.195] Resolved: FALSE
[16:09:35.195] Value: <not collected>
[16:09:35.195] Conditions captured: <none>
[16:09:35.195] Early signaling: FALSE
[16:09:35.195] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:35.195] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.207] Chunk #1 of 2 ... DONE
[16:09:35.207] Chunk #2 of 2 ...
[16:09:35.207]  - Finding globals in 'X' for chunk #2 ...
[16:09:35.208] getGlobalsAndPackages() ...
[16:09:35.208] Searching for globals...
[16:09:35.208] 
[16:09:35.208] Searching for globals ... DONE
[16:09:35.208] - globals: [0] <none>
[16:09:35.208] getGlobalsAndPackages() ... DONE
[16:09:35.209]    + additional globals found: [n=0] 
[16:09:35.209]    + additional namespaces needed: [n=0] 
[16:09:35.209]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:35.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:35.209]  - seeds: <none>
[16:09:35.209] getGlobalsAndPackages() ...
[16:09:35.209] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.209] Resolving globals: FALSE
[16:09:35.209] Tweak future expression to call with '...' arguments ...
[16:09:35.210] {
[16:09:35.210]     do.call(function(...) {
[16:09:35.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.210]             on.exit(options(oopts), add = TRUE)
[16:09:35.210]         }
[16:09:35.210]         {
[16:09:35.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.210]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.210]             })
[16:09:35.210]         }
[16:09:35.210]     }, args = future.call.arguments)
[16:09:35.210] }
[16:09:35.210] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.210] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.210] 
[16:09:35.210] getGlobalsAndPackages() ... DONE
[16:09:35.211] run() for ‘Future’ ...
[16:09:35.211] - state: ‘created’
[16:09:35.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:35.226]   - Field: ‘node’
[16:09:35.226]   - Field: ‘label’
[16:09:35.226]   - Field: ‘local’
[16:09:35.226]   - Field: ‘owner’
[16:09:35.226]   - Field: ‘envir’
[16:09:35.226]   - Field: ‘workers’
[16:09:35.227]   - Field: ‘packages’
[16:09:35.227]   - Field: ‘gc’
[16:09:35.227]   - Field: ‘conditions’
[16:09:35.227]   - Field: ‘persistent’
[16:09:35.227]   - Field: ‘expr’
[16:09:35.227]   - Field: ‘uuid’
[16:09:35.227]   - Field: ‘seed’
[16:09:35.227]   - Field: ‘version’
[16:09:35.227]   - Field: ‘result’
[16:09:35.227]   - Field: ‘asynchronous’
[16:09:35.227]   - Field: ‘calls’
[16:09:35.228]   - Field: ‘globals’
[16:09:35.228]   - Field: ‘stdout’
[16:09:35.228]   - Field: ‘earlySignal’
[16:09:35.228]   - Field: ‘lazy’
[16:09:35.228]   - Field: ‘state’
[16:09:35.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:35.228] - Launch lazy future ...
[16:09:35.228] Packages needed by the future expression (n = 0): <none>
[16:09:35.228] Packages needed by future strategies (n = 0): <none>
[16:09:35.229] {
[16:09:35.229]     {
[16:09:35.229]         {
[16:09:35.229]             ...future.startTime <- base::Sys.time()
[16:09:35.229]             {
[16:09:35.229]                 {
[16:09:35.229]                   {
[16:09:35.229]                     {
[16:09:35.229]                       base::local({
[16:09:35.229]                         has_future <- base::requireNamespace("future", 
[16:09:35.229]                           quietly = TRUE)
[16:09:35.229]                         if (has_future) {
[16:09:35.229]                           ns <- base::getNamespace("future")
[16:09:35.229]                           version <- ns[[".package"]][["version"]]
[16:09:35.229]                           if (is.null(version)) 
[16:09:35.229]                             version <- utils::packageVersion("future")
[16:09:35.229]                         }
[16:09:35.229]                         else {
[16:09:35.229]                           version <- NULL
[16:09:35.229]                         }
[16:09:35.229]                         if (!has_future || version < "1.8.0") {
[16:09:35.229]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.229]                             "", base::R.version$version.string), 
[16:09:35.229]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.229]                               "release", "version")], collapse = " "), 
[16:09:35.229]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.229]                             info)
[16:09:35.229]                           info <- base::paste(info, collapse = "; ")
[16:09:35.229]                           if (!has_future) {
[16:09:35.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.229]                               info)
[16:09:35.229]                           }
[16:09:35.229]                           else {
[16:09:35.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.229]                               info, version)
[16:09:35.229]                           }
[16:09:35.229]                           base::stop(msg)
[16:09:35.229]                         }
[16:09:35.229]                       })
[16:09:35.229]                     }
[16:09:35.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.229]                     base::options(mc.cores = 1L)
[16:09:35.229]                   }
[16:09:35.229]                   options(future.plan = NULL)
[16:09:35.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.229]                 }
[16:09:35.229]                 ...future.workdir <- getwd()
[16:09:35.229]             }
[16:09:35.229]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.229]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.229]         }
[16:09:35.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.229]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:35.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.229]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.229]             base::names(...future.oldOptions))
[16:09:35.229]     }
[16:09:35.229]     if (FALSE) {
[16:09:35.229]     }
[16:09:35.229]     else {
[16:09:35.229]         if (TRUE) {
[16:09:35.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.229]                 open = "w")
[16:09:35.229]         }
[16:09:35.229]         else {
[16:09:35.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.229]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.229]         }
[16:09:35.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.229]             base::sink(type = "output", split = FALSE)
[16:09:35.229]             base::close(...future.stdout)
[16:09:35.229]         }, add = TRUE)
[16:09:35.229]     }
[16:09:35.229]     ...future.frame <- base::sys.nframe()
[16:09:35.229]     ...future.conditions <- base::list()
[16:09:35.229]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.229]     if (FALSE) {
[16:09:35.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.229]     }
[16:09:35.229]     ...future.result <- base::tryCatch({
[16:09:35.229]         base::withCallingHandlers({
[16:09:35.229]             ...future.value <- base::withVisible(base::local({
[16:09:35.229]                 ...future.makeSendCondition <- local({
[16:09:35.229]                   sendCondition <- NULL
[16:09:35.229]                   function(frame = 1L) {
[16:09:35.229]                     if (is.function(sendCondition)) 
[16:09:35.229]                       return(sendCondition)
[16:09:35.229]                     ns <- getNamespace("parallel")
[16:09:35.229]                     if (exists("sendData", mode = "function", 
[16:09:35.229]                       envir = ns)) {
[16:09:35.229]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:35.229]                         envir = ns)
[16:09:35.229]                       envir <- sys.frame(frame)
[16:09:35.229]                       master <- NULL
[16:09:35.229]                       while (!identical(envir, .GlobalEnv) && 
[16:09:35.229]                         !identical(envir, emptyenv())) {
[16:09:35.229]                         if (exists("master", mode = "list", envir = envir, 
[16:09:35.229]                           inherits = FALSE)) {
[16:09:35.229]                           master <- get("master", mode = "list", 
[16:09:35.229]                             envir = envir, inherits = FALSE)
[16:09:35.229]                           if (inherits(master, c("SOCKnode", 
[16:09:35.229]                             "SOCK0node"))) {
[16:09:35.229]                             sendCondition <<- function(cond) {
[16:09:35.229]                               data <- list(type = "VALUE", value = cond, 
[16:09:35.229]                                 success = TRUE)
[16:09:35.229]                               parallel_sendData(master, data)
[16:09:35.229]                             }
[16:09:35.229]                             return(sendCondition)
[16:09:35.229]                           }
[16:09:35.229]                         }
[16:09:35.229]                         frame <- frame + 1L
[16:09:35.229]                         envir <- sys.frame(frame)
[16:09:35.229]                       }
[16:09:35.229]                     }
[16:09:35.229]                     sendCondition <<- function(cond) NULL
[16:09:35.229]                   }
[16:09:35.229]                 })
[16:09:35.229]                 withCallingHandlers({
[16:09:35.229]                   {
[16:09:35.229]                     do.call(function(...) {
[16:09:35.229]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.229]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.229]                         ...future.globals.maxSize)) {
[16:09:35.229]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.229]                         on.exit(options(oopts), add = TRUE)
[16:09:35.229]                       }
[16:09:35.229]                       {
[16:09:35.229]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.229]                           FUN = function(jj) {
[16:09:35.229]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.229]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.229]                           })
[16:09:35.229]                       }
[16:09:35.229]                     }, args = future.call.arguments)
[16:09:35.229]                   }
[16:09:35.229]                 }, immediateCondition = function(cond) {
[16:09:35.229]                   sendCondition <- ...future.makeSendCondition()
[16:09:35.229]                   sendCondition(cond)
[16:09:35.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.229]                   {
[16:09:35.229]                     inherits <- base::inherits
[16:09:35.229]                     invokeRestart <- base::invokeRestart
[16:09:35.229]                     is.null <- base::is.null
[16:09:35.229]                     muffled <- FALSE
[16:09:35.229]                     if (inherits(cond, "message")) {
[16:09:35.229]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.229]                       if (muffled) 
[16:09:35.229]                         invokeRestart("muffleMessage")
[16:09:35.229]                     }
[16:09:35.229]                     else if (inherits(cond, "warning")) {
[16:09:35.229]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.229]                       if (muffled) 
[16:09:35.229]                         invokeRestart("muffleWarning")
[16:09:35.229]                     }
[16:09:35.229]                     else if (inherits(cond, "condition")) {
[16:09:35.229]                       if (!is.null(pattern)) {
[16:09:35.229]                         computeRestarts <- base::computeRestarts
[16:09:35.229]                         grepl <- base::grepl
[16:09:35.229]                         restarts <- computeRestarts(cond)
[16:09:35.229]                         for (restart in restarts) {
[16:09:35.229]                           name <- restart$name
[16:09:35.229]                           if (is.null(name)) 
[16:09:35.229]                             next
[16:09:35.229]                           if (!grepl(pattern, name)) 
[16:09:35.229]                             next
[16:09:35.229]                           invokeRestart(restart)
[16:09:35.229]                           muffled <- TRUE
[16:09:35.229]                           break
[16:09:35.229]                         }
[16:09:35.229]                       }
[16:09:35.229]                     }
[16:09:35.229]                     invisible(muffled)
[16:09:35.229]                   }
[16:09:35.229]                   muffleCondition(cond)
[16:09:35.229]                 })
[16:09:35.229]             }))
[16:09:35.229]             future::FutureResult(value = ...future.value$value, 
[16:09:35.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.229]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.229]                     ...future.globalenv.names))
[16:09:35.229]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.229]         }, condition = base::local({
[16:09:35.229]             c <- base::c
[16:09:35.229]             inherits <- base::inherits
[16:09:35.229]             invokeRestart <- base::invokeRestart
[16:09:35.229]             length <- base::length
[16:09:35.229]             list <- base::list
[16:09:35.229]             seq.int <- base::seq.int
[16:09:35.229]             signalCondition <- base::signalCondition
[16:09:35.229]             sys.calls <- base::sys.calls
[16:09:35.229]             `[[` <- base::`[[`
[16:09:35.229]             `+` <- base::`+`
[16:09:35.229]             `<<-` <- base::`<<-`
[16:09:35.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.229]                   3L)]
[16:09:35.229]             }
[16:09:35.229]             function(cond) {
[16:09:35.229]                 is_error <- inherits(cond, "error")
[16:09:35.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.229]                   NULL)
[16:09:35.229]                 if (is_error) {
[16:09:35.229]                   sessionInformation <- function() {
[16:09:35.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.229]                       search = base::search(), system = base::Sys.info())
[16:09:35.229]                   }
[16:09:35.229]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.229]                     cond$call), session = sessionInformation(), 
[16:09:35.229]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.229]                   signalCondition(cond)
[16:09:35.229]                 }
[16:09:35.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.229]                 "immediateCondition"))) {
[16:09:35.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.229]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.229]                   if (TRUE && !signal) {
[16:09:35.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.229]                     {
[16:09:35.229]                       inherits <- base::inherits
[16:09:35.229]                       invokeRestart <- base::invokeRestart
[16:09:35.229]                       is.null <- base::is.null
[16:09:35.229]                       muffled <- FALSE
[16:09:35.229]                       if (inherits(cond, "message")) {
[16:09:35.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.229]                         if (muffled) 
[16:09:35.229]                           invokeRestart("muffleMessage")
[16:09:35.229]                       }
[16:09:35.229]                       else if (inherits(cond, "warning")) {
[16:09:35.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.229]                         if (muffled) 
[16:09:35.229]                           invokeRestart("muffleWarning")
[16:09:35.229]                       }
[16:09:35.229]                       else if (inherits(cond, "condition")) {
[16:09:35.229]                         if (!is.null(pattern)) {
[16:09:35.229]                           computeRestarts <- base::computeRestarts
[16:09:35.229]                           grepl <- base::grepl
[16:09:35.229]                           restarts <- computeRestarts(cond)
[16:09:35.229]                           for (restart in restarts) {
[16:09:35.229]                             name <- restart$name
[16:09:35.229]                             if (is.null(name)) 
[16:09:35.229]                               next
[16:09:35.229]                             if (!grepl(pattern, name)) 
[16:09:35.229]                               next
[16:09:35.229]                             invokeRestart(restart)
[16:09:35.229]                             muffled <- TRUE
[16:09:35.229]                             break
[16:09:35.229]                           }
[16:09:35.229]                         }
[16:09:35.229]                       }
[16:09:35.229]                       invisible(muffled)
[16:09:35.229]                     }
[16:09:35.229]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.229]                   }
[16:09:35.229]                 }
[16:09:35.229]                 else {
[16:09:35.229]                   if (TRUE) {
[16:09:35.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.229]                     {
[16:09:35.229]                       inherits <- base::inherits
[16:09:35.229]                       invokeRestart <- base::invokeRestart
[16:09:35.229]                       is.null <- base::is.null
[16:09:35.229]                       muffled <- FALSE
[16:09:35.229]                       if (inherits(cond, "message")) {
[16:09:35.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.229]                         if (muffled) 
[16:09:35.229]                           invokeRestart("muffleMessage")
[16:09:35.229]                       }
[16:09:35.229]                       else if (inherits(cond, "warning")) {
[16:09:35.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.229]                         if (muffled) 
[16:09:35.229]                           invokeRestart("muffleWarning")
[16:09:35.229]                       }
[16:09:35.229]                       else if (inherits(cond, "condition")) {
[16:09:35.229]                         if (!is.null(pattern)) {
[16:09:35.229]                           computeRestarts <- base::computeRestarts
[16:09:35.229]                           grepl <- base::grepl
[16:09:35.229]                           restarts <- computeRestarts(cond)
[16:09:35.229]                           for (restart in restarts) {
[16:09:35.229]                             name <- restart$name
[16:09:35.229]                             if (is.null(name)) 
[16:09:35.229]                               next
[16:09:35.229]                             if (!grepl(pattern, name)) 
[16:09:35.229]                               next
[16:09:35.229]                             invokeRestart(restart)
[16:09:35.229]                             muffled <- TRUE
[16:09:35.229]                             break
[16:09:35.229]                           }
[16:09:35.229]                         }
[16:09:35.229]                       }
[16:09:35.229]                       invisible(muffled)
[16:09:35.229]                     }
[16:09:35.229]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.229]                   }
[16:09:35.229]                 }
[16:09:35.229]             }
[16:09:35.229]         }))
[16:09:35.229]     }, error = function(ex) {
[16:09:35.229]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.229]                 ...future.rng), started = ...future.startTime, 
[16:09:35.229]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.229]             version = "1.8"), class = "FutureResult")
[16:09:35.229]     }, finally = {
[16:09:35.229]         if (!identical(...future.workdir, getwd())) 
[16:09:35.229]             setwd(...future.workdir)
[16:09:35.229]         {
[16:09:35.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.229]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.229]             }
[16:09:35.229]             base::options(...future.oldOptions)
[16:09:35.229]             if (.Platform$OS.type == "windows") {
[16:09:35.229]                 old_names <- names(...future.oldEnvVars)
[16:09:35.229]                 envs <- base::Sys.getenv()
[16:09:35.229]                 names <- names(envs)
[16:09:35.229]                 common <- intersect(names, old_names)
[16:09:35.229]                 added <- setdiff(names, old_names)
[16:09:35.229]                 removed <- setdiff(old_names, names)
[16:09:35.229]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.229]                   envs[common]]
[16:09:35.229]                 NAMES <- toupper(changed)
[16:09:35.229]                 args <- list()
[16:09:35.229]                 for (kk in seq_along(NAMES)) {
[16:09:35.229]                   name <- changed[[kk]]
[16:09:35.229]                   NAME <- NAMES[[kk]]
[16:09:35.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.229]                     next
[16:09:35.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.229]                 }
[16:09:35.229]                 NAMES <- toupper(added)
[16:09:35.229]                 for (kk in seq_along(NAMES)) {
[16:09:35.229]                   name <- added[[kk]]
[16:09:35.229]                   NAME <- NAMES[[kk]]
[16:09:35.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.229]                     next
[16:09:35.229]                   args[[name]] <- ""
[16:09:35.229]                 }
[16:09:35.229]                 NAMES <- toupper(removed)
[16:09:35.229]                 for (kk in seq_along(NAMES)) {
[16:09:35.229]                   name <- removed[[kk]]
[16:09:35.229]                   NAME <- NAMES[[kk]]
[16:09:35.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.229]                     next
[16:09:35.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.229]                 }
[16:09:35.229]                 if (length(args) > 0) 
[16:09:35.229]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.229]             }
[16:09:35.229]             else {
[16:09:35.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.229]             }
[16:09:35.229]             {
[16:09:35.229]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.229]                   0L) {
[16:09:35.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.229]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.229]                   base::options(opts)
[16:09:35.229]                 }
[16:09:35.229]                 {
[16:09:35.229]                   {
[16:09:35.229]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.229]                     NULL
[16:09:35.229]                   }
[16:09:35.229]                   options(future.plan = NULL)
[16:09:35.229]                   if (is.na(NA_character_)) 
[16:09:35.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.229]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:35.229]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:35.229]                     envir = parent.frame()) 
[16:09:35.229]                   {
[16:09:35.229]                     if (is.function(workers)) 
[16:09:35.229]                       workers <- workers()
[16:09:35.229]                     workers <- structure(as.integer(workers), 
[16:09:35.229]                       class = class(workers))
[16:09:35.229]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:35.229]                       workers >= 1)
[16:09:35.229]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:35.229]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:35.229]                     }
[16:09:35.229]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:35.229]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:35.229]                       envir = envir)
[16:09:35.229]                     if (!future$lazy) 
[16:09:35.229]                       future <- run(future)
[16:09:35.229]                     invisible(future)
[16:09:35.229]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.229]                 }
[16:09:35.229]             }
[16:09:35.229]         }
[16:09:35.229]     })
[16:09:35.229]     if (TRUE) {
[16:09:35.229]         base::sink(type = "output", split = FALSE)
[16:09:35.229]         if (TRUE) {
[16:09:35.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.229]         }
[16:09:35.229]         else {
[16:09:35.229]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.229]         }
[16:09:35.229]         base::close(...future.stdout)
[16:09:35.229]         ...future.stdout <- NULL
[16:09:35.229]     }
[16:09:35.229]     ...future.result$conditions <- ...future.conditions
[16:09:35.229]     ...future.result$finished <- base::Sys.time()
[16:09:35.229]     ...future.result
[16:09:35.229] }
[16:09:35.232] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:09:35.232] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:09:35.232] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:09:35.233] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:35.233] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.233] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:09:35.234] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:09:35.234] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:35.234] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:35.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.235] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:09:35.236] MultisessionFuture started
[16:09:35.236] - Launch lazy future ... done
[16:09:35.236] run() for ‘MultisessionFuture’ ... done
[16:09:35.236] Created future:
[16:09:35.236] MultisessionFuture:
[16:09:35.236] Label: ‘future_by-2’
[16:09:35.236] Expression:
[16:09:35.236] {
[16:09:35.236]     do.call(function(...) {
[16:09:35.236]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.236]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.236]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.236]             on.exit(options(oopts), add = TRUE)
[16:09:35.236]         }
[16:09:35.236]         {
[16:09:35.236]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.236]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.236]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.236]             })
[16:09:35.236]         }
[16:09:35.236]     }, args = future.call.arguments)
[16:09:35.236] }
[16:09:35.236] Lazy evaluation: FALSE
[16:09:35.236] Asynchronous evaluation: TRUE
[16:09:35.236] Local evaluation: TRUE
[16:09:35.236] Environment: 0x5567ea5d5d18
[16:09:35.236] Capture standard output: TRUE
[16:09:35.236] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.236] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.236] Packages: <none>
[16:09:35.236] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.236] Resolved: FALSE
[16:09:35.236] Value: <not collected>
[16:09:35.236] Conditions captured: <none>
[16:09:35.236] Early signaling: FALSE
[16:09:35.236] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:35.236] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.248] Chunk #2 of 2 ... DONE
[16:09:35.248] Launching 2 futures (chunks) ... DONE
[16:09:35.248] Resolving 2 futures (chunks) ...
[16:09:35.248] resolve() on list ...
[16:09:35.249]  recursive: 0
[16:09:35.249]  length: 2
[16:09:35.249] 
[16:09:35.249] receiveMessageFromWorker() for ClusterFuture ...
[16:09:35.249] - Validating connection of MultisessionFuture
[16:09:35.250] - received message: FutureResult
[16:09:35.250] - Received FutureResult
[16:09:35.250] - Erased future from FutureRegistry
[16:09:35.250] result() for ClusterFuture ...
[16:09:35.250] - result already collected: FutureResult
[16:09:35.252] result() for ClusterFuture ... done
[16:09:35.253] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:35.253] Future #1
[16:09:35.253] result() for ClusterFuture ...
[16:09:35.253] - result already collected: FutureResult
[16:09:35.253] result() for ClusterFuture ... done
[16:09:35.253] result() for ClusterFuture ...
[16:09:35.253] - result already collected: FutureResult
[16:09:35.253] result() for ClusterFuture ... done
[16:09:35.253] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:35.253] - nx: 2
[16:09:35.253] - relay: TRUE
[16:09:35.253] - stdout: TRUE
[16:09:35.254] - signal: TRUE
[16:09:35.254] - resignal: FALSE
[16:09:35.254] - force: TRUE
[16:09:35.254] - relayed: [n=2] FALSE, FALSE
[16:09:35.254] - queued futures: [n=2] FALSE, FALSE
[16:09:35.254]  - until=1
[16:09:35.254]  - relaying element #1
[16:09:35.254] result() for ClusterFuture ...
[16:09:35.254] - result already collected: FutureResult
[16:09:35.254] result() for ClusterFuture ... done
[16:09:35.254] result() for ClusterFuture ...
[16:09:35.254] - result already collected: FutureResult
[16:09:35.255] result() for ClusterFuture ... done
[16:09:35.255] result() for ClusterFuture ...
[16:09:35.255] - result already collected: FutureResult
[16:09:35.255] result() for ClusterFuture ... done
[16:09:35.255] result() for ClusterFuture ...
[16:09:35.255] - result already collected: FutureResult
[16:09:35.255] result() for ClusterFuture ... done
[16:09:35.255] - relayed: [n=2] TRUE, FALSE
[16:09:35.255] - queued futures: [n=2] TRUE, FALSE
[16:09:35.255] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:35.255]  length: 1 (resolved future 1)
[16:09:35.282] receiveMessageFromWorker() for ClusterFuture ...
[16:09:35.282] - Validating connection of MultisessionFuture
[16:09:35.282] - received message: FutureResult
[16:09:35.282] - Received FutureResult
[16:09:35.282] - Erased future from FutureRegistry
[16:09:35.283] result() for ClusterFuture ...
[16:09:35.283] - result already collected: FutureResult
[16:09:35.283] result() for ClusterFuture ... done
[16:09:35.283] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:35.283] Future #2
[16:09:35.283] result() for ClusterFuture ...
[16:09:35.283] - result already collected: FutureResult
[16:09:35.283] result() for ClusterFuture ... done
[16:09:35.283] result() for ClusterFuture ...
[16:09:35.284] - result already collected: FutureResult
[16:09:35.284] result() for ClusterFuture ... done
[16:09:35.284] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:35.284] - nx: 2
[16:09:35.284] - relay: TRUE
[16:09:35.284] - stdout: TRUE
[16:09:35.284] - signal: TRUE
[16:09:35.284] - resignal: FALSE
[16:09:35.284] - force: TRUE
[16:09:35.284] - relayed: [n=2] TRUE, FALSE
[16:09:35.284] - queued futures: [n=2] TRUE, FALSE
[16:09:35.285]  - until=2
[16:09:35.285]  - relaying element #2
[16:09:35.285] result() for ClusterFuture ...
[16:09:35.285] - result already collected: FutureResult
[16:09:35.285] result() for ClusterFuture ... done
[16:09:35.285] result() for ClusterFuture ...
[16:09:35.285] - result already collected: FutureResult
[16:09:35.285] result() for ClusterFuture ... done
[16:09:35.285] result() for ClusterFuture ...
[16:09:35.285] - result already collected: FutureResult
[16:09:35.285] result() for ClusterFuture ... done
[16:09:35.286] result() for ClusterFuture ...
[16:09:35.286] - result already collected: FutureResult
[16:09:35.286] result() for ClusterFuture ... done
[16:09:35.286] - relayed: [n=2] TRUE, TRUE
[16:09:35.286] - queued futures: [n=2] TRUE, TRUE
[16:09:35.286] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:35.286]  length: 0 (resolved future 2)
[16:09:35.286] Relaying remaining futures
[16:09:35.286] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.286] - nx: 2
[16:09:35.286] - relay: TRUE
[16:09:35.287] - stdout: TRUE
[16:09:35.287] - signal: TRUE
[16:09:35.287] - resignal: FALSE
[16:09:35.287] - force: TRUE
[16:09:35.287] - relayed: [n=2] TRUE, TRUE
[16:09:35.287] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:35.287] - relayed: [n=2] TRUE, TRUE
[16:09:35.287] - queued futures: [n=2] TRUE, TRUE
[16:09:35.287] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.287] resolve() on list ... DONE
[16:09:35.287] result() for ClusterFuture ...
[16:09:35.287] - result already collected: FutureResult
[16:09:35.288] result() for ClusterFuture ... done
[16:09:35.288] result() for ClusterFuture ...
[16:09:35.288] - result already collected: FutureResult
[16:09:35.288] result() for ClusterFuture ... done
[16:09:35.288] result() for ClusterFuture ...
[16:09:35.288] - result already collected: FutureResult
[16:09:35.288] result() for ClusterFuture ... done
[16:09:35.288] result() for ClusterFuture ...
[16:09:35.288] - result already collected: FutureResult
[16:09:35.288] result() for ClusterFuture ... done
[16:09:35.288]  - Number of value chunks collected: 2
[16:09:35.289] Resolving 2 futures (chunks) ... DONE
[16:09:35.289] Reducing values from 2 chunks ...
[16:09:35.289]  - Number of values collected after concatenation: 3
[16:09:35.289]  - Number of values expected: 3
[16:09:35.289] Reducing values from 2 chunks ... DONE
[16:09:35.289] future_lapply() ... DONE
[16:09:35.289] future_by_internal() ... DONE
[16:09:35.290] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:09:35.290] future_lapply() ...
[16:09:35.294] Number of chunks: 2
[16:09:35.294] getGlobalsAndPackagesXApply() ...
[16:09:35.294]  - future.globals: TRUE
[16:09:35.295] getGlobalsAndPackages() ...
[16:09:35.295] Searching for globals...
[16:09:35.296] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.296] Searching for globals ... DONE
[16:09:35.296] Resolving globals: FALSE
[16:09:35.296] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:35.297] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:35.297] - globals: [1] ‘FUN’
[16:09:35.297] 
[16:09:35.297] getGlobalsAndPackages() ... DONE
[16:09:35.297]  - globals found/used: [n=1] ‘FUN’
[16:09:35.297]  - needed namespaces: [n=0] 
[16:09:35.297] Finding globals ... DONE
[16:09:35.297]  - use_args: TRUE
[16:09:35.297]  - Getting '...' globals ...
[16:09:35.298] resolve() on list ...
[16:09:35.298]  recursive: 0
[16:09:35.298]  length: 1
[16:09:35.298]  elements: ‘...’
[16:09:35.298]  length: 0 (resolved future 1)
[16:09:35.298] resolve() on list ... DONE
[16:09:35.298]    - '...' content: [n=0] 
[16:09:35.298] List of 1
[16:09:35.298]  $ ...: list()
[16:09:35.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.298]  - attr(*, "where")=List of 1
[16:09:35.298]   ..$ ...:<environment: 0x5567eaea2658> 
[16:09:35.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.298]  - attr(*, "resolved")= logi TRUE
[16:09:35.298]  - attr(*, "total_size")= num NA
[16:09:35.301]  - Getting '...' globals ... DONE
[16:09:35.301] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.301] List of 2
[16:09:35.301]  $ ...future.FUN:function (object, ...)  
[16:09:35.301]  $ ...          : list()
[16:09:35.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.301]  - attr(*, "where")=List of 2
[16:09:35.301]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.301]   ..$ ...          :<environment: 0x5567eaea2658> 
[16:09:35.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.301]  - attr(*, "resolved")= logi FALSE
[16:09:35.301]  - attr(*, "total_size")= num 1240
[16:09:35.304] Packages to be attached in all futures: [n=0] 
[16:09:35.304] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.304] Number of futures (= number of chunks): 2
[16:09:35.304] Launching 2 futures (chunks) ...
[16:09:35.304] Chunk #1 of 2 ...
[16:09:35.304]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.304] getGlobalsAndPackages() ...
[16:09:35.304] Searching for globals...
[16:09:35.305] 
[16:09:35.305] Searching for globals ... DONE
[16:09:35.305] - globals: [0] <none>
[16:09:35.305] getGlobalsAndPackages() ... DONE
[16:09:35.305]    + additional globals found: [n=0] 
[16:09:35.305]    + additional namespaces needed: [n=0] 
[16:09:35.305]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.305]  - seeds: <none>
[16:09:35.305] getGlobalsAndPackages() ...
[16:09:35.305] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.306] Resolving globals: FALSE
[16:09:35.306] Tweak future expression to call with '...' arguments ...
[16:09:35.306] {
[16:09:35.306]     do.call(function(...) {
[16:09:35.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.306]             on.exit(options(oopts), add = TRUE)
[16:09:35.306]         }
[16:09:35.306]         {
[16:09:35.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.306]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.306]             })
[16:09:35.306]         }
[16:09:35.306]     }, args = future.call.arguments)
[16:09:35.306] }
[16:09:35.306] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.306] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.307] 
[16:09:35.307] getGlobalsAndPackages() ... DONE
[16:09:35.307] run() for ‘Future’ ...
[16:09:35.307] - state: ‘created’
[16:09:35.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.321] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:35.321]   - Field: ‘node’
[16:09:35.321]   - Field: ‘label’
[16:09:35.321]   - Field: ‘local’
[16:09:35.321]   - Field: ‘owner’
[16:09:35.321]   - Field: ‘envir’
[16:09:35.322]   - Field: ‘workers’
[16:09:35.322]   - Field: ‘packages’
[16:09:35.322]   - Field: ‘gc’
[16:09:35.322]   - Field: ‘conditions’
[16:09:35.322]   - Field: ‘persistent’
[16:09:35.322]   - Field: ‘expr’
[16:09:35.322]   - Field: ‘uuid’
[16:09:35.322]   - Field: ‘seed’
[16:09:35.322]   - Field: ‘version’
[16:09:35.322]   - Field: ‘result’
[16:09:35.322]   - Field: ‘asynchronous’
[16:09:35.322]   - Field: ‘calls’
[16:09:35.323]   - Field: ‘globals’
[16:09:35.323]   - Field: ‘stdout’
[16:09:35.323]   - Field: ‘earlySignal’
[16:09:35.323]   - Field: ‘lazy’
[16:09:35.323]   - Field: ‘state’
[16:09:35.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:35.323] - Launch lazy future ...
[16:09:35.323] Packages needed by the future expression (n = 0): <none>
[16:09:35.323] Packages needed by future strategies (n = 0): <none>
[16:09:35.324] {
[16:09:35.324]     {
[16:09:35.324]         {
[16:09:35.324]             ...future.startTime <- base::Sys.time()
[16:09:35.324]             {
[16:09:35.324]                 {
[16:09:35.324]                   {
[16:09:35.324]                     {
[16:09:35.324]                       base::local({
[16:09:35.324]                         has_future <- base::requireNamespace("future", 
[16:09:35.324]                           quietly = TRUE)
[16:09:35.324]                         if (has_future) {
[16:09:35.324]                           ns <- base::getNamespace("future")
[16:09:35.324]                           version <- ns[[".package"]][["version"]]
[16:09:35.324]                           if (is.null(version)) 
[16:09:35.324]                             version <- utils::packageVersion("future")
[16:09:35.324]                         }
[16:09:35.324]                         else {
[16:09:35.324]                           version <- NULL
[16:09:35.324]                         }
[16:09:35.324]                         if (!has_future || version < "1.8.0") {
[16:09:35.324]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.324]                             "", base::R.version$version.string), 
[16:09:35.324]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.324]                               "release", "version")], collapse = " "), 
[16:09:35.324]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.324]                             info)
[16:09:35.324]                           info <- base::paste(info, collapse = "; ")
[16:09:35.324]                           if (!has_future) {
[16:09:35.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.324]                               info)
[16:09:35.324]                           }
[16:09:35.324]                           else {
[16:09:35.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.324]                               info, version)
[16:09:35.324]                           }
[16:09:35.324]                           base::stop(msg)
[16:09:35.324]                         }
[16:09:35.324]                       })
[16:09:35.324]                     }
[16:09:35.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.324]                     base::options(mc.cores = 1L)
[16:09:35.324]                   }
[16:09:35.324]                   options(future.plan = NULL)
[16:09:35.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.324]                 }
[16:09:35.324]                 ...future.workdir <- getwd()
[16:09:35.324]             }
[16:09:35.324]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.324]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.324]         }
[16:09:35.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:35.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.324]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.324]             base::names(...future.oldOptions))
[16:09:35.324]     }
[16:09:35.324]     if (FALSE) {
[16:09:35.324]     }
[16:09:35.324]     else {
[16:09:35.324]         if (TRUE) {
[16:09:35.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.324]                 open = "w")
[16:09:35.324]         }
[16:09:35.324]         else {
[16:09:35.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.324]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.324]         }
[16:09:35.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.324]             base::sink(type = "output", split = FALSE)
[16:09:35.324]             base::close(...future.stdout)
[16:09:35.324]         }, add = TRUE)
[16:09:35.324]     }
[16:09:35.324]     ...future.frame <- base::sys.nframe()
[16:09:35.324]     ...future.conditions <- base::list()
[16:09:35.324]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.324]     if (FALSE) {
[16:09:35.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.324]     }
[16:09:35.324]     ...future.result <- base::tryCatch({
[16:09:35.324]         base::withCallingHandlers({
[16:09:35.324]             ...future.value <- base::withVisible(base::local({
[16:09:35.324]                 ...future.makeSendCondition <- local({
[16:09:35.324]                   sendCondition <- NULL
[16:09:35.324]                   function(frame = 1L) {
[16:09:35.324]                     if (is.function(sendCondition)) 
[16:09:35.324]                       return(sendCondition)
[16:09:35.324]                     ns <- getNamespace("parallel")
[16:09:35.324]                     if (exists("sendData", mode = "function", 
[16:09:35.324]                       envir = ns)) {
[16:09:35.324]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:35.324]                         envir = ns)
[16:09:35.324]                       envir <- sys.frame(frame)
[16:09:35.324]                       master <- NULL
[16:09:35.324]                       while (!identical(envir, .GlobalEnv) && 
[16:09:35.324]                         !identical(envir, emptyenv())) {
[16:09:35.324]                         if (exists("master", mode = "list", envir = envir, 
[16:09:35.324]                           inherits = FALSE)) {
[16:09:35.324]                           master <- get("master", mode = "list", 
[16:09:35.324]                             envir = envir, inherits = FALSE)
[16:09:35.324]                           if (inherits(master, c("SOCKnode", 
[16:09:35.324]                             "SOCK0node"))) {
[16:09:35.324]                             sendCondition <<- function(cond) {
[16:09:35.324]                               data <- list(type = "VALUE", value = cond, 
[16:09:35.324]                                 success = TRUE)
[16:09:35.324]                               parallel_sendData(master, data)
[16:09:35.324]                             }
[16:09:35.324]                             return(sendCondition)
[16:09:35.324]                           }
[16:09:35.324]                         }
[16:09:35.324]                         frame <- frame + 1L
[16:09:35.324]                         envir <- sys.frame(frame)
[16:09:35.324]                       }
[16:09:35.324]                     }
[16:09:35.324]                     sendCondition <<- function(cond) NULL
[16:09:35.324]                   }
[16:09:35.324]                 })
[16:09:35.324]                 withCallingHandlers({
[16:09:35.324]                   {
[16:09:35.324]                     do.call(function(...) {
[16:09:35.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.324]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.324]                         ...future.globals.maxSize)) {
[16:09:35.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.324]                         on.exit(options(oopts), add = TRUE)
[16:09:35.324]                       }
[16:09:35.324]                       {
[16:09:35.324]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.324]                           FUN = function(jj) {
[16:09:35.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.324]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.324]                           })
[16:09:35.324]                       }
[16:09:35.324]                     }, args = future.call.arguments)
[16:09:35.324]                   }
[16:09:35.324]                 }, immediateCondition = function(cond) {
[16:09:35.324]                   sendCondition <- ...future.makeSendCondition()
[16:09:35.324]                   sendCondition(cond)
[16:09:35.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.324]                   {
[16:09:35.324]                     inherits <- base::inherits
[16:09:35.324]                     invokeRestart <- base::invokeRestart
[16:09:35.324]                     is.null <- base::is.null
[16:09:35.324]                     muffled <- FALSE
[16:09:35.324]                     if (inherits(cond, "message")) {
[16:09:35.324]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.324]                       if (muffled) 
[16:09:35.324]                         invokeRestart("muffleMessage")
[16:09:35.324]                     }
[16:09:35.324]                     else if (inherits(cond, "warning")) {
[16:09:35.324]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.324]                       if (muffled) 
[16:09:35.324]                         invokeRestart("muffleWarning")
[16:09:35.324]                     }
[16:09:35.324]                     else if (inherits(cond, "condition")) {
[16:09:35.324]                       if (!is.null(pattern)) {
[16:09:35.324]                         computeRestarts <- base::computeRestarts
[16:09:35.324]                         grepl <- base::grepl
[16:09:35.324]                         restarts <- computeRestarts(cond)
[16:09:35.324]                         for (restart in restarts) {
[16:09:35.324]                           name <- restart$name
[16:09:35.324]                           if (is.null(name)) 
[16:09:35.324]                             next
[16:09:35.324]                           if (!grepl(pattern, name)) 
[16:09:35.324]                             next
[16:09:35.324]                           invokeRestart(restart)
[16:09:35.324]                           muffled <- TRUE
[16:09:35.324]                           break
[16:09:35.324]                         }
[16:09:35.324]                       }
[16:09:35.324]                     }
[16:09:35.324]                     invisible(muffled)
[16:09:35.324]                   }
[16:09:35.324]                   muffleCondition(cond)
[16:09:35.324]                 })
[16:09:35.324]             }))
[16:09:35.324]             future::FutureResult(value = ...future.value$value, 
[16:09:35.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.324]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.324]                     ...future.globalenv.names))
[16:09:35.324]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.324]         }, condition = base::local({
[16:09:35.324]             c <- base::c
[16:09:35.324]             inherits <- base::inherits
[16:09:35.324]             invokeRestart <- base::invokeRestart
[16:09:35.324]             length <- base::length
[16:09:35.324]             list <- base::list
[16:09:35.324]             seq.int <- base::seq.int
[16:09:35.324]             signalCondition <- base::signalCondition
[16:09:35.324]             sys.calls <- base::sys.calls
[16:09:35.324]             `[[` <- base::`[[`
[16:09:35.324]             `+` <- base::`+`
[16:09:35.324]             `<<-` <- base::`<<-`
[16:09:35.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.324]                   3L)]
[16:09:35.324]             }
[16:09:35.324]             function(cond) {
[16:09:35.324]                 is_error <- inherits(cond, "error")
[16:09:35.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.324]                   NULL)
[16:09:35.324]                 if (is_error) {
[16:09:35.324]                   sessionInformation <- function() {
[16:09:35.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.324]                       search = base::search(), system = base::Sys.info())
[16:09:35.324]                   }
[16:09:35.324]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.324]                     cond$call), session = sessionInformation(), 
[16:09:35.324]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.324]                   signalCondition(cond)
[16:09:35.324]                 }
[16:09:35.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.324]                 "immediateCondition"))) {
[16:09:35.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.324]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.324]                   if (TRUE && !signal) {
[16:09:35.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.324]                     {
[16:09:35.324]                       inherits <- base::inherits
[16:09:35.324]                       invokeRestart <- base::invokeRestart
[16:09:35.324]                       is.null <- base::is.null
[16:09:35.324]                       muffled <- FALSE
[16:09:35.324]                       if (inherits(cond, "message")) {
[16:09:35.324]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.324]                         if (muffled) 
[16:09:35.324]                           invokeRestart("muffleMessage")
[16:09:35.324]                       }
[16:09:35.324]                       else if (inherits(cond, "warning")) {
[16:09:35.324]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.324]                         if (muffled) 
[16:09:35.324]                           invokeRestart("muffleWarning")
[16:09:35.324]                       }
[16:09:35.324]                       else if (inherits(cond, "condition")) {
[16:09:35.324]                         if (!is.null(pattern)) {
[16:09:35.324]                           computeRestarts <- base::computeRestarts
[16:09:35.324]                           grepl <- base::grepl
[16:09:35.324]                           restarts <- computeRestarts(cond)
[16:09:35.324]                           for (restart in restarts) {
[16:09:35.324]                             name <- restart$name
[16:09:35.324]                             if (is.null(name)) 
[16:09:35.324]                               next
[16:09:35.324]                             if (!grepl(pattern, name)) 
[16:09:35.324]                               next
[16:09:35.324]                             invokeRestart(restart)
[16:09:35.324]                             muffled <- TRUE
[16:09:35.324]                             break
[16:09:35.324]                           }
[16:09:35.324]                         }
[16:09:35.324]                       }
[16:09:35.324]                       invisible(muffled)
[16:09:35.324]                     }
[16:09:35.324]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.324]                   }
[16:09:35.324]                 }
[16:09:35.324]                 else {
[16:09:35.324]                   if (TRUE) {
[16:09:35.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.324]                     {
[16:09:35.324]                       inherits <- base::inherits
[16:09:35.324]                       invokeRestart <- base::invokeRestart
[16:09:35.324]                       is.null <- base::is.null
[16:09:35.324]                       muffled <- FALSE
[16:09:35.324]                       if (inherits(cond, "message")) {
[16:09:35.324]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.324]                         if (muffled) 
[16:09:35.324]                           invokeRestart("muffleMessage")
[16:09:35.324]                       }
[16:09:35.324]                       else if (inherits(cond, "warning")) {
[16:09:35.324]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.324]                         if (muffled) 
[16:09:35.324]                           invokeRestart("muffleWarning")
[16:09:35.324]                       }
[16:09:35.324]                       else if (inherits(cond, "condition")) {
[16:09:35.324]                         if (!is.null(pattern)) {
[16:09:35.324]                           computeRestarts <- base::computeRestarts
[16:09:35.324]                           grepl <- base::grepl
[16:09:35.324]                           restarts <- computeRestarts(cond)
[16:09:35.324]                           for (restart in restarts) {
[16:09:35.324]                             name <- restart$name
[16:09:35.324]                             if (is.null(name)) 
[16:09:35.324]                               next
[16:09:35.324]                             if (!grepl(pattern, name)) 
[16:09:35.324]                               next
[16:09:35.324]                             invokeRestart(restart)
[16:09:35.324]                             muffled <- TRUE
[16:09:35.324]                             break
[16:09:35.324]                           }
[16:09:35.324]                         }
[16:09:35.324]                       }
[16:09:35.324]                       invisible(muffled)
[16:09:35.324]                     }
[16:09:35.324]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.324]                   }
[16:09:35.324]                 }
[16:09:35.324]             }
[16:09:35.324]         }))
[16:09:35.324]     }, error = function(ex) {
[16:09:35.324]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.324]                 ...future.rng), started = ...future.startTime, 
[16:09:35.324]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.324]             version = "1.8"), class = "FutureResult")
[16:09:35.324]     }, finally = {
[16:09:35.324]         if (!identical(...future.workdir, getwd())) 
[16:09:35.324]             setwd(...future.workdir)
[16:09:35.324]         {
[16:09:35.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.324]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.324]             }
[16:09:35.324]             base::options(...future.oldOptions)
[16:09:35.324]             if (.Platform$OS.type == "windows") {
[16:09:35.324]                 old_names <- names(...future.oldEnvVars)
[16:09:35.324]                 envs <- base::Sys.getenv()
[16:09:35.324]                 names <- names(envs)
[16:09:35.324]                 common <- intersect(names, old_names)
[16:09:35.324]                 added <- setdiff(names, old_names)
[16:09:35.324]                 removed <- setdiff(old_names, names)
[16:09:35.324]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.324]                   envs[common]]
[16:09:35.324]                 NAMES <- toupper(changed)
[16:09:35.324]                 args <- list()
[16:09:35.324]                 for (kk in seq_along(NAMES)) {
[16:09:35.324]                   name <- changed[[kk]]
[16:09:35.324]                   NAME <- NAMES[[kk]]
[16:09:35.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.324]                     next
[16:09:35.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.324]                 }
[16:09:35.324]                 NAMES <- toupper(added)
[16:09:35.324]                 for (kk in seq_along(NAMES)) {
[16:09:35.324]                   name <- added[[kk]]
[16:09:35.324]                   NAME <- NAMES[[kk]]
[16:09:35.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.324]                     next
[16:09:35.324]                   args[[name]] <- ""
[16:09:35.324]                 }
[16:09:35.324]                 NAMES <- toupper(removed)
[16:09:35.324]                 for (kk in seq_along(NAMES)) {
[16:09:35.324]                   name <- removed[[kk]]
[16:09:35.324]                   NAME <- NAMES[[kk]]
[16:09:35.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.324]                     next
[16:09:35.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.324]                 }
[16:09:35.324]                 if (length(args) > 0) 
[16:09:35.324]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.324]             }
[16:09:35.324]             else {
[16:09:35.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.324]             }
[16:09:35.324]             {
[16:09:35.324]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.324]                   0L) {
[16:09:35.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.324]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.324]                   base::options(opts)
[16:09:35.324]                 }
[16:09:35.324]                 {
[16:09:35.324]                   {
[16:09:35.324]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.324]                     NULL
[16:09:35.324]                   }
[16:09:35.324]                   options(future.plan = NULL)
[16:09:35.324]                   if (is.na(NA_character_)) 
[16:09:35.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.324]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:35.324]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:35.324]                     envir = parent.frame()) 
[16:09:35.324]                   {
[16:09:35.324]                     if (is.function(workers)) 
[16:09:35.324]                       workers <- workers()
[16:09:35.324]                     workers <- structure(as.integer(workers), 
[16:09:35.324]                       class = class(workers))
[16:09:35.324]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:35.324]                       workers >= 1)
[16:09:35.324]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:35.324]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:35.324]                     }
[16:09:35.324]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:35.324]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:35.324]                       envir = envir)
[16:09:35.324]                     if (!future$lazy) 
[16:09:35.324]                       future <- run(future)
[16:09:35.324]                     invisible(future)
[16:09:35.324]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.324]                 }
[16:09:35.324]             }
[16:09:35.324]         }
[16:09:35.324]     })
[16:09:35.324]     if (TRUE) {
[16:09:35.324]         base::sink(type = "output", split = FALSE)
[16:09:35.324]         if (TRUE) {
[16:09:35.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.324]         }
[16:09:35.324]         else {
[16:09:35.324]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.324]         }
[16:09:35.324]         base::close(...future.stdout)
[16:09:35.324]         ...future.stdout <- NULL
[16:09:35.324]     }
[16:09:35.324]     ...future.result$conditions <- ...future.conditions
[16:09:35.324]     ...future.result$finished <- base::Sys.time()
[16:09:35.324]     ...future.result
[16:09:35.324] }
[16:09:35.327] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:09:35.327] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:09:35.327] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:09:35.328] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:35.328] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.328] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:09:35.329] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:09:35.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:35.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:35.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:35.330] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:09:35.330] MultisessionFuture started
[16:09:35.330] - Launch lazy future ... done
[16:09:35.330] run() for ‘MultisessionFuture’ ... done
[16:09:35.331] Created future:
[16:09:35.331] MultisessionFuture:
[16:09:35.331] Label: ‘future_by-1’
[16:09:35.331] Expression:
[16:09:35.331] {
[16:09:35.331]     do.call(function(...) {
[16:09:35.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.331]             on.exit(options(oopts), add = TRUE)
[16:09:35.331]         }
[16:09:35.331]         {
[16:09:35.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.331]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.331]             })
[16:09:35.331]         }
[16:09:35.331]     }, args = future.call.arguments)
[16:09:35.331] }
[16:09:35.331] Lazy evaluation: FALSE
[16:09:35.331] Asynchronous evaluation: TRUE
[16:09:35.331] Local evaluation: TRUE
[16:09:35.331] Environment: 0x5567eaed74d8
[16:09:35.331] Capture standard output: TRUE
[16:09:35.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.331] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.331] Packages: <none>
[16:09:35.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.331] Resolved: FALSE
[16:09:35.331] Value: <not collected>
[16:09:35.331] Conditions captured: <none>
[16:09:35.331] Early signaling: FALSE
[16:09:35.331] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:35.331] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.342] Chunk #1 of 2 ... DONE
[16:09:35.342] Chunk #2 of 2 ...
[16:09:35.343]  - Finding globals in 'X' for chunk #2 ...
[16:09:35.343] getGlobalsAndPackages() ...
[16:09:35.343] Searching for globals...
[16:09:35.343] 
[16:09:35.343] Searching for globals ... DONE
[16:09:35.344] - globals: [0] <none>
[16:09:35.344] getGlobalsAndPackages() ... DONE
[16:09:35.344]    + additional globals found: [n=0] 
[16:09:35.344]    + additional namespaces needed: [n=0] 
[16:09:35.344]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:35.344]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:35.344]  - seeds: <none>
[16:09:35.344] getGlobalsAndPackages() ...
[16:09:35.344] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.344] Resolving globals: FALSE
[16:09:35.345] Tweak future expression to call with '...' arguments ...
[16:09:35.345] {
[16:09:35.345]     do.call(function(...) {
[16:09:35.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.345]             on.exit(options(oopts), add = TRUE)
[16:09:35.345]         }
[16:09:35.345]         {
[16:09:35.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.345]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.345]             })
[16:09:35.345]         }
[16:09:35.345]     }, args = future.call.arguments)
[16:09:35.345] }
[16:09:35.345] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.345] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.345] 
[16:09:35.345] getGlobalsAndPackages() ... DONE
[16:09:35.346] run() for ‘Future’ ...
[16:09:35.346] - state: ‘created’
[16:09:35.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.360] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:35.360]   - Field: ‘node’
[16:09:35.360]   - Field: ‘label’
[16:09:35.360]   - Field: ‘local’
[16:09:35.360]   - Field: ‘owner’
[16:09:35.360]   - Field: ‘envir’
[16:09:35.360]   - Field: ‘workers’
[16:09:35.360]   - Field: ‘packages’
[16:09:35.361]   - Field: ‘gc’
[16:09:35.361]   - Field: ‘conditions’
[16:09:35.361]   - Field: ‘persistent’
[16:09:35.361]   - Field: ‘expr’
[16:09:35.361]   - Field: ‘uuid’
[16:09:35.361]   - Field: ‘seed’
[16:09:35.361]   - Field: ‘version’
[16:09:35.361]   - Field: ‘result’
[16:09:35.361]   - Field: ‘asynchronous’
[16:09:35.361]   - Field: ‘calls’
[16:09:35.361]   - Field: ‘globals’
[16:09:35.362]   - Field: ‘stdout’
[16:09:35.362]   - Field: ‘earlySignal’
[16:09:35.362]   - Field: ‘lazy’
[16:09:35.362]   - Field: ‘state’
[16:09:35.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:35.362] - Launch lazy future ...
[16:09:35.362] Packages needed by the future expression (n = 0): <none>
[16:09:35.362] Packages needed by future strategies (n = 0): <none>
[16:09:35.363] {
[16:09:35.363]     {
[16:09:35.363]         {
[16:09:35.363]             ...future.startTime <- base::Sys.time()
[16:09:35.363]             {
[16:09:35.363]                 {
[16:09:35.363]                   {
[16:09:35.363]                     {
[16:09:35.363]                       base::local({
[16:09:35.363]                         has_future <- base::requireNamespace("future", 
[16:09:35.363]                           quietly = TRUE)
[16:09:35.363]                         if (has_future) {
[16:09:35.363]                           ns <- base::getNamespace("future")
[16:09:35.363]                           version <- ns[[".package"]][["version"]]
[16:09:35.363]                           if (is.null(version)) 
[16:09:35.363]                             version <- utils::packageVersion("future")
[16:09:35.363]                         }
[16:09:35.363]                         else {
[16:09:35.363]                           version <- NULL
[16:09:35.363]                         }
[16:09:35.363]                         if (!has_future || version < "1.8.0") {
[16:09:35.363]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.363]                             "", base::R.version$version.string), 
[16:09:35.363]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.363]                               "release", "version")], collapse = " "), 
[16:09:35.363]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.363]                             info)
[16:09:35.363]                           info <- base::paste(info, collapse = "; ")
[16:09:35.363]                           if (!has_future) {
[16:09:35.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.363]                               info)
[16:09:35.363]                           }
[16:09:35.363]                           else {
[16:09:35.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.363]                               info, version)
[16:09:35.363]                           }
[16:09:35.363]                           base::stop(msg)
[16:09:35.363]                         }
[16:09:35.363]                       })
[16:09:35.363]                     }
[16:09:35.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.363]                     base::options(mc.cores = 1L)
[16:09:35.363]                   }
[16:09:35.363]                   options(future.plan = NULL)
[16:09:35.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.363]                 }
[16:09:35.363]                 ...future.workdir <- getwd()
[16:09:35.363]             }
[16:09:35.363]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.363]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.363]         }
[16:09:35.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.363]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:35.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.363]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.363]             base::names(...future.oldOptions))
[16:09:35.363]     }
[16:09:35.363]     if (FALSE) {
[16:09:35.363]     }
[16:09:35.363]     else {
[16:09:35.363]         if (TRUE) {
[16:09:35.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.363]                 open = "w")
[16:09:35.363]         }
[16:09:35.363]         else {
[16:09:35.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.363]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.363]         }
[16:09:35.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.363]             base::sink(type = "output", split = FALSE)
[16:09:35.363]             base::close(...future.stdout)
[16:09:35.363]         }, add = TRUE)
[16:09:35.363]     }
[16:09:35.363]     ...future.frame <- base::sys.nframe()
[16:09:35.363]     ...future.conditions <- base::list()
[16:09:35.363]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.363]     if (FALSE) {
[16:09:35.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.363]     }
[16:09:35.363]     ...future.result <- base::tryCatch({
[16:09:35.363]         base::withCallingHandlers({
[16:09:35.363]             ...future.value <- base::withVisible(base::local({
[16:09:35.363]                 ...future.makeSendCondition <- local({
[16:09:35.363]                   sendCondition <- NULL
[16:09:35.363]                   function(frame = 1L) {
[16:09:35.363]                     if (is.function(sendCondition)) 
[16:09:35.363]                       return(sendCondition)
[16:09:35.363]                     ns <- getNamespace("parallel")
[16:09:35.363]                     if (exists("sendData", mode = "function", 
[16:09:35.363]                       envir = ns)) {
[16:09:35.363]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:35.363]                         envir = ns)
[16:09:35.363]                       envir <- sys.frame(frame)
[16:09:35.363]                       master <- NULL
[16:09:35.363]                       while (!identical(envir, .GlobalEnv) && 
[16:09:35.363]                         !identical(envir, emptyenv())) {
[16:09:35.363]                         if (exists("master", mode = "list", envir = envir, 
[16:09:35.363]                           inherits = FALSE)) {
[16:09:35.363]                           master <- get("master", mode = "list", 
[16:09:35.363]                             envir = envir, inherits = FALSE)
[16:09:35.363]                           if (inherits(master, c("SOCKnode", 
[16:09:35.363]                             "SOCK0node"))) {
[16:09:35.363]                             sendCondition <<- function(cond) {
[16:09:35.363]                               data <- list(type = "VALUE", value = cond, 
[16:09:35.363]                                 success = TRUE)
[16:09:35.363]                               parallel_sendData(master, data)
[16:09:35.363]                             }
[16:09:35.363]                             return(sendCondition)
[16:09:35.363]                           }
[16:09:35.363]                         }
[16:09:35.363]                         frame <- frame + 1L
[16:09:35.363]                         envir <- sys.frame(frame)
[16:09:35.363]                       }
[16:09:35.363]                     }
[16:09:35.363]                     sendCondition <<- function(cond) NULL
[16:09:35.363]                   }
[16:09:35.363]                 })
[16:09:35.363]                 withCallingHandlers({
[16:09:35.363]                   {
[16:09:35.363]                     do.call(function(...) {
[16:09:35.363]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.363]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.363]                         ...future.globals.maxSize)) {
[16:09:35.363]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.363]                         on.exit(options(oopts), add = TRUE)
[16:09:35.363]                       }
[16:09:35.363]                       {
[16:09:35.363]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.363]                           FUN = function(jj) {
[16:09:35.363]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.363]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.363]                           })
[16:09:35.363]                       }
[16:09:35.363]                     }, args = future.call.arguments)
[16:09:35.363]                   }
[16:09:35.363]                 }, immediateCondition = function(cond) {
[16:09:35.363]                   sendCondition <- ...future.makeSendCondition()
[16:09:35.363]                   sendCondition(cond)
[16:09:35.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.363]                   {
[16:09:35.363]                     inherits <- base::inherits
[16:09:35.363]                     invokeRestart <- base::invokeRestart
[16:09:35.363]                     is.null <- base::is.null
[16:09:35.363]                     muffled <- FALSE
[16:09:35.363]                     if (inherits(cond, "message")) {
[16:09:35.363]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.363]                       if (muffled) 
[16:09:35.363]                         invokeRestart("muffleMessage")
[16:09:35.363]                     }
[16:09:35.363]                     else if (inherits(cond, "warning")) {
[16:09:35.363]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.363]                       if (muffled) 
[16:09:35.363]                         invokeRestart("muffleWarning")
[16:09:35.363]                     }
[16:09:35.363]                     else if (inherits(cond, "condition")) {
[16:09:35.363]                       if (!is.null(pattern)) {
[16:09:35.363]                         computeRestarts <- base::computeRestarts
[16:09:35.363]                         grepl <- base::grepl
[16:09:35.363]                         restarts <- computeRestarts(cond)
[16:09:35.363]                         for (restart in restarts) {
[16:09:35.363]                           name <- restart$name
[16:09:35.363]                           if (is.null(name)) 
[16:09:35.363]                             next
[16:09:35.363]                           if (!grepl(pattern, name)) 
[16:09:35.363]                             next
[16:09:35.363]                           invokeRestart(restart)
[16:09:35.363]                           muffled <- TRUE
[16:09:35.363]                           break
[16:09:35.363]                         }
[16:09:35.363]                       }
[16:09:35.363]                     }
[16:09:35.363]                     invisible(muffled)
[16:09:35.363]                   }
[16:09:35.363]                   muffleCondition(cond)
[16:09:35.363]                 })
[16:09:35.363]             }))
[16:09:35.363]             future::FutureResult(value = ...future.value$value, 
[16:09:35.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.363]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.363]                     ...future.globalenv.names))
[16:09:35.363]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.363]         }, condition = base::local({
[16:09:35.363]             c <- base::c
[16:09:35.363]             inherits <- base::inherits
[16:09:35.363]             invokeRestart <- base::invokeRestart
[16:09:35.363]             length <- base::length
[16:09:35.363]             list <- base::list
[16:09:35.363]             seq.int <- base::seq.int
[16:09:35.363]             signalCondition <- base::signalCondition
[16:09:35.363]             sys.calls <- base::sys.calls
[16:09:35.363]             `[[` <- base::`[[`
[16:09:35.363]             `+` <- base::`+`
[16:09:35.363]             `<<-` <- base::`<<-`
[16:09:35.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.363]                   3L)]
[16:09:35.363]             }
[16:09:35.363]             function(cond) {
[16:09:35.363]                 is_error <- inherits(cond, "error")
[16:09:35.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.363]                   NULL)
[16:09:35.363]                 if (is_error) {
[16:09:35.363]                   sessionInformation <- function() {
[16:09:35.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.363]                       search = base::search(), system = base::Sys.info())
[16:09:35.363]                   }
[16:09:35.363]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.363]                     cond$call), session = sessionInformation(), 
[16:09:35.363]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.363]                   signalCondition(cond)
[16:09:35.363]                 }
[16:09:35.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.363]                 "immediateCondition"))) {
[16:09:35.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.363]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.363]                   if (TRUE && !signal) {
[16:09:35.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.363]                     {
[16:09:35.363]                       inherits <- base::inherits
[16:09:35.363]                       invokeRestart <- base::invokeRestart
[16:09:35.363]                       is.null <- base::is.null
[16:09:35.363]                       muffled <- FALSE
[16:09:35.363]                       if (inherits(cond, "message")) {
[16:09:35.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.363]                         if (muffled) 
[16:09:35.363]                           invokeRestart("muffleMessage")
[16:09:35.363]                       }
[16:09:35.363]                       else if (inherits(cond, "warning")) {
[16:09:35.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.363]                         if (muffled) 
[16:09:35.363]                           invokeRestart("muffleWarning")
[16:09:35.363]                       }
[16:09:35.363]                       else if (inherits(cond, "condition")) {
[16:09:35.363]                         if (!is.null(pattern)) {
[16:09:35.363]                           computeRestarts <- base::computeRestarts
[16:09:35.363]                           grepl <- base::grepl
[16:09:35.363]                           restarts <- computeRestarts(cond)
[16:09:35.363]                           for (restart in restarts) {
[16:09:35.363]                             name <- restart$name
[16:09:35.363]                             if (is.null(name)) 
[16:09:35.363]                               next
[16:09:35.363]                             if (!grepl(pattern, name)) 
[16:09:35.363]                               next
[16:09:35.363]                             invokeRestart(restart)
[16:09:35.363]                             muffled <- TRUE
[16:09:35.363]                             break
[16:09:35.363]                           }
[16:09:35.363]                         }
[16:09:35.363]                       }
[16:09:35.363]                       invisible(muffled)
[16:09:35.363]                     }
[16:09:35.363]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.363]                   }
[16:09:35.363]                 }
[16:09:35.363]                 else {
[16:09:35.363]                   if (TRUE) {
[16:09:35.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.363]                     {
[16:09:35.363]                       inherits <- base::inherits
[16:09:35.363]                       invokeRestart <- base::invokeRestart
[16:09:35.363]                       is.null <- base::is.null
[16:09:35.363]                       muffled <- FALSE
[16:09:35.363]                       if (inherits(cond, "message")) {
[16:09:35.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.363]                         if (muffled) 
[16:09:35.363]                           invokeRestart("muffleMessage")
[16:09:35.363]                       }
[16:09:35.363]                       else if (inherits(cond, "warning")) {
[16:09:35.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.363]                         if (muffled) 
[16:09:35.363]                           invokeRestart("muffleWarning")
[16:09:35.363]                       }
[16:09:35.363]                       else if (inherits(cond, "condition")) {
[16:09:35.363]                         if (!is.null(pattern)) {
[16:09:35.363]                           computeRestarts <- base::computeRestarts
[16:09:35.363]                           grepl <- base::grepl
[16:09:35.363]                           restarts <- computeRestarts(cond)
[16:09:35.363]                           for (restart in restarts) {
[16:09:35.363]                             name <- restart$name
[16:09:35.363]                             if (is.null(name)) 
[16:09:35.363]                               next
[16:09:35.363]                             if (!grepl(pattern, name)) 
[16:09:35.363]                               next
[16:09:35.363]                             invokeRestart(restart)
[16:09:35.363]                             muffled <- TRUE
[16:09:35.363]                             break
[16:09:35.363]                           }
[16:09:35.363]                         }
[16:09:35.363]                       }
[16:09:35.363]                       invisible(muffled)
[16:09:35.363]                     }
[16:09:35.363]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.363]                   }
[16:09:35.363]                 }
[16:09:35.363]             }
[16:09:35.363]         }))
[16:09:35.363]     }, error = function(ex) {
[16:09:35.363]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.363]                 ...future.rng), started = ...future.startTime, 
[16:09:35.363]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.363]             version = "1.8"), class = "FutureResult")
[16:09:35.363]     }, finally = {
[16:09:35.363]         if (!identical(...future.workdir, getwd())) 
[16:09:35.363]             setwd(...future.workdir)
[16:09:35.363]         {
[16:09:35.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.363]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.363]             }
[16:09:35.363]             base::options(...future.oldOptions)
[16:09:35.363]             if (.Platform$OS.type == "windows") {
[16:09:35.363]                 old_names <- names(...future.oldEnvVars)
[16:09:35.363]                 envs <- base::Sys.getenv()
[16:09:35.363]                 names <- names(envs)
[16:09:35.363]                 common <- intersect(names, old_names)
[16:09:35.363]                 added <- setdiff(names, old_names)
[16:09:35.363]                 removed <- setdiff(old_names, names)
[16:09:35.363]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.363]                   envs[common]]
[16:09:35.363]                 NAMES <- toupper(changed)
[16:09:35.363]                 args <- list()
[16:09:35.363]                 for (kk in seq_along(NAMES)) {
[16:09:35.363]                   name <- changed[[kk]]
[16:09:35.363]                   NAME <- NAMES[[kk]]
[16:09:35.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.363]                     next
[16:09:35.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.363]                 }
[16:09:35.363]                 NAMES <- toupper(added)
[16:09:35.363]                 for (kk in seq_along(NAMES)) {
[16:09:35.363]                   name <- added[[kk]]
[16:09:35.363]                   NAME <- NAMES[[kk]]
[16:09:35.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.363]                     next
[16:09:35.363]                   args[[name]] <- ""
[16:09:35.363]                 }
[16:09:35.363]                 NAMES <- toupper(removed)
[16:09:35.363]                 for (kk in seq_along(NAMES)) {
[16:09:35.363]                   name <- removed[[kk]]
[16:09:35.363]                   NAME <- NAMES[[kk]]
[16:09:35.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.363]                     next
[16:09:35.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.363]                 }
[16:09:35.363]                 if (length(args) > 0) 
[16:09:35.363]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.363]             }
[16:09:35.363]             else {
[16:09:35.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.363]             }
[16:09:35.363]             {
[16:09:35.363]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.363]                   0L) {
[16:09:35.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.363]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.363]                   base::options(opts)
[16:09:35.363]                 }
[16:09:35.363]                 {
[16:09:35.363]                   {
[16:09:35.363]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.363]                     NULL
[16:09:35.363]                   }
[16:09:35.363]                   options(future.plan = NULL)
[16:09:35.363]                   if (is.na(NA_character_)) 
[16:09:35.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.363]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:35.363]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:35.363]                     envir = parent.frame()) 
[16:09:35.363]                   {
[16:09:35.363]                     if (is.function(workers)) 
[16:09:35.363]                       workers <- workers()
[16:09:35.363]                     workers <- structure(as.integer(workers), 
[16:09:35.363]                       class = class(workers))
[16:09:35.363]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:35.363]                       workers >= 1)
[16:09:35.363]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:35.363]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:35.363]                     }
[16:09:35.363]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:35.363]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:35.363]                       envir = envir)
[16:09:35.363]                     if (!future$lazy) 
[16:09:35.363]                       future <- run(future)
[16:09:35.363]                     invisible(future)
[16:09:35.363]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.363]                 }
[16:09:35.363]             }
[16:09:35.363]         }
[16:09:35.363]     })
[16:09:35.363]     if (TRUE) {
[16:09:35.363]         base::sink(type = "output", split = FALSE)
[16:09:35.363]         if (TRUE) {
[16:09:35.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.363]         }
[16:09:35.363]         else {
[16:09:35.363]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.363]         }
[16:09:35.363]         base::close(...future.stdout)
[16:09:35.363]         ...future.stdout <- NULL
[16:09:35.363]     }
[16:09:35.363]     ...future.result$conditions <- ...future.conditions
[16:09:35.363]     ...future.result$finished <- base::Sys.time()
[16:09:35.363]     ...future.result
[16:09:35.363] }
[16:09:35.366] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:09:35.366] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:09:35.366] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:09:35.367] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:35.367] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.367] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:09:35.368] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:09:35.368] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:35.368] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.368] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:35.369] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:35.369] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:09:35.369] MultisessionFuture started
[16:09:35.369] - Launch lazy future ... done
[16:09:35.370] run() for ‘MultisessionFuture’ ... done
[16:09:35.370] Created future:
[16:09:35.370] MultisessionFuture:
[16:09:35.370] Label: ‘future_by-2’
[16:09:35.370] Expression:
[16:09:35.370] {
[16:09:35.370]     do.call(function(...) {
[16:09:35.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.370]             on.exit(options(oopts), add = TRUE)
[16:09:35.370]         }
[16:09:35.370]         {
[16:09:35.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.370]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.370]             })
[16:09:35.370]         }
[16:09:35.370]     }, args = future.call.arguments)
[16:09:35.370] }
[16:09:35.370] Lazy evaluation: FALSE
[16:09:35.370] Asynchronous evaluation: TRUE
[16:09:35.370] Local evaluation: TRUE
[16:09:35.370] Environment: 0x5567eaed74d8
[16:09:35.370] Capture standard output: TRUE
[16:09:35.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.370] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.370] Packages: <none>
[16:09:35.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.370] Resolved: FALSE
[16:09:35.370] Value: <not collected>
[16:09:35.370] Conditions captured: <none>
[16:09:35.370] Early signaling: FALSE
[16:09:35.370] Owner process: a1c80eb0-9e11-0068-978e-7df535f50b67
[16:09:35.370] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.382] Chunk #2 of 2 ... DONE
[16:09:35.382] Launching 2 futures (chunks) ... DONE
[16:09:35.382] Resolving 2 futures (chunks) ...
[16:09:35.382] resolve() on list ...
[16:09:35.382]  recursive: 0
[16:09:35.382]  length: 2
[16:09:35.382] 
[16:09:35.383] receiveMessageFromWorker() for ClusterFuture ...
[16:09:35.383] - Validating connection of MultisessionFuture
[16:09:35.383] - received message: FutureResult
[16:09:35.383] - Received FutureResult
[16:09:35.383] - Erased future from FutureRegistry
[16:09:35.383] result() for ClusterFuture ...
[16:09:35.383] - result already collected: FutureResult
[16:09:35.383] result() for ClusterFuture ... done
[16:09:35.384] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:35.384] Future #1
[16:09:35.384] result() for ClusterFuture ...
[16:09:35.384] - result already collected: FutureResult
[16:09:35.384] result() for ClusterFuture ... done
[16:09:35.384] result() for ClusterFuture ...
[16:09:35.384] - result already collected: FutureResult
[16:09:35.384] result() for ClusterFuture ... done
[16:09:35.384] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:35.384] - nx: 2
[16:09:35.385] - relay: TRUE
[16:09:35.385] - stdout: TRUE
[16:09:35.385] - signal: TRUE
[16:09:35.385] - resignal: FALSE
[16:09:35.385] - force: TRUE
[16:09:35.385] - relayed: [n=2] FALSE, FALSE
[16:09:35.385] - queued futures: [n=2] FALSE, FALSE
[16:09:35.385]  - until=1
[16:09:35.385]  - relaying element #1
[16:09:35.385] result() for ClusterFuture ...
[16:09:35.385] - result already collected: FutureResult
[16:09:35.385] result() for ClusterFuture ... done
[16:09:35.386] result() for ClusterFuture ...
[16:09:35.386] - result already collected: FutureResult
[16:09:35.386] result() for ClusterFuture ... done
[16:09:35.386] result() for ClusterFuture ...
[16:09:35.386] - result already collected: FutureResult
[16:09:35.386] result() for ClusterFuture ... done
[16:09:35.386] result() for ClusterFuture ...
[16:09:35.386] - result already collected: FutureResult
[16:09:35.386] result() for ClusterFuture ... done
[16:09:35.386] - relayed: [n=2] TRUE, FALSE
[16:09:35.386] - queued futures: [n=2] TRUE, FALSE
[16:09:35.387] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:35.387]  length: 1 (resolved future 1)
[16:09:35.418] receiveMessageFromWorker() for ClusterFuture ...
[16:09:35.418] - Validating connection of MultisessionFuture
[16:09:35.418] - received message: FutureResult
[16:09:35.418] - Received FutureResult
[16:09:35.418] - Erased future from FutureRegistry
[16:09:35.418] result() for ClusterFuture ...
[16:09:35.418] - result already collected: FutureResult
[16:09:35.418] result() for ClusterFuture ... done
[16:09:35.419] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:35.419] Future #2
[16:09:35.419] result() for ClusterFuture ...
[16:09:35.419] - result already collected: FutureResult
[16:09:35.419] result() for ClusterFuture ... done
[16:09:35.419] result() for ClusterFuture ...
[16:09:35.419] - result already collected: FutureResult
[16:09:35.419] result() for ClusterFuture ... done
[16:09:35.419] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:35.419] - nx: 2
[16:09:35.419] - relay: TRUE
[16:09:35.419] - stdout: TRUE
[16:09:35.420] - signal: TRUE
[16:09:35.420] - resignal: FALSE
[16:09:35.420] - force: TRUE
[16:09:35.420] - relayed: [n=2] TRUE, FALSE
[16:09:35.420] - queued futures: [n=2] TRUE, FALSE
[16:09:35.420]  - until=2
[16:09:35.420]  - relaying element #2
[16:09:35.420] result() for ClusterFuture ...
[16:09:35.420] - result already collected: FutureResult
[16:09:35.420] result() for ClusterFuture ... done
[16:09:35.420] result() for ClusterFuture ...
[16:09:35.421] - result already collected: FutureResult
[16:09:35.421] result() for ClusterFuture ... done
[16:09:35.421] result() for ClusterFuture ...
[16:09:35.421] - result already collected: FutureResult
[16:09:35.421] result() for ClusterFuture ... done
[16:09:35.421] result() for ClusterFuture ...
[16:09:35.421] - result already collected: FutureResult
[16:09:35.421] result() for ClusterFuture ... done
[16:09:35.421] - relayed: [n=2] TRUE, TRUE
[16:09:35.421] - queued futures: [n=2] TRUE, TRUE
[16:09:35.421] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:35.422]  length: 0 (resolved future 2)
[16:09:35.422] Relaying remaining futures
[16:09:35.422] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.422] - nx: 2
[16:09:35.422] - relay: TRUE
[16:09:35.422] - stdout: TRUE
[16:09:35.422] - signal: TRUE
[16:09:35.422] - resignal: FALSE
[16:09:35.422] - force: TRUE
[16:09:35.422] - relayed: [n=2] TRUE, TRUE
[16:09:35.422] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:35.422] - relayed: [n=2] TRUE, TRUE
[16:09:35.423] - queued futures: [n=2] TRUE, TRUE
[16:09:35.423] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.423] resolve() on list ... DONE
[16:09:35.423] result() for ClusterFuture ...
[16:09:35.423] - result already collected: FutureResult
[16:09:35.423] result() for ClusterFuture ... done
[16:09:35.423] result() for ClusterFuture ...
[16:09:35.423] - result already collected: FutureResult
[16:09:35.423] result() for ClusterFuture ... done
[16:09:35.423] result() for ClusterFuture ...
[16:09:35.423] - result already collected: FutureResult
[16:09:35.424] result() for ClusterFuture ... done
[16:09:35.424] result() for ClusterFuture ...
[16:09:35.424] - result already collected: FutureResult
[16:09:35.424] result() for ClusterFuture ... done
[16:09:35.424]  - Number of value chunks collected: 2
[16:09:35.424] Resolving 2 futures (chunks) ... DONE
[16:09:35.424] Reducing values from 2 chunks ...
[16:09:35.424]  - Number of values collected after concatenation: 3
[16:09:35.424]  - Number of values expected: 3
[16:09:35.424] Reducing values from 2 chunks ... DONE
[16:09:35.425] future_lapply() ... DONE
[16:09:35.425] future_by_internal() ... DONE
[16:09:35.425] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[16:09:35.426] plan(): Setting new future strategy stack:
[16:09:35.426] List of future strategies:
[16:09:35.426] 1. FutureStrategy:
[16:09:35.426]    - args: function (..., envir = parent.frame())
[16:09:35.426]    - tweaked: FALSE
[16:09:35.426]    - call: future::plan(oplan)
[16:09:35.427] plan(): nbrOfWorkers() = 1
> 
