
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:17:28.481] plan(): Setting new future strategy stack:
[13:17:28.481] List of future strategies:
[13:17:28.481] 1. sequential:
[13:17:28.481]    - args: function (..., envir = parent.frame())
[13:17:28.481]    - tweaked: FALSE
[13:17:28.481]    - call: future::plan("sequential")
[13:17:28.491] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[13:17:28.548] plan(): Setting new future strategy stack:
[13:17:28.548] List of future strategies:
[13:17:28.548] 1. sequential:
[13:17:28.548]    - args: function (..., envir = parent.frame())
[13:17:28.548]    - tweaked: FALSE
[13:17:28.548]    - call: plan(strategy)
[13:17:28.559] plan(): nbrOfWorkers() = 1
[13:17:28.559] future_by_internal() ...
[13:17:28.560] future_lapply() ...
[13:17:28.564] Number of chunks: 1
[13:17:28.564] getGlobalsAndPackagesXApply() ...
[13:17:28.564]  - future.globals: TRUE
[13:17:28.565] getGlobalsAndPackages() ...
[13:17:28.565] Searching for globals...
[13:17:28.567] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:28.568] Searching for globals ... DONE
[13:17:28.568] Resolving globals: FALSE
[13:17:28.569] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:28.569] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:28.569] - globals: [1] ‘FUN’
[13:17:28.569] 
[13:17:28.570] getGlobalsAndPackages() ... DONE
[13:17:28.570]  - globals found/used: [n=1] ‘FUN’
[13:17:28.570]  - needed namespaces: [n=0] 
[13:17:28.570] Finding globals ... DONE
[13:17:28.570]  - use_args: TRUE
[13:17:28.570]  - Getting '...' globals ...
[13:17:28.571] resolve() on list ...
[13:17:28.571]  recursive: 0
[13:17:28.571]  length: 1
[13:17:28.571]  elements: ‘...’
[13:17:28.571]  length: 0 (resolved future 1)
[13:17:28.571] resolve() on list ... DONE
[13:17:28.572]    - '...' content: [n=0] 
[13:17:28.572] List of 1
[13:17:28.572]  $ ...: list()
[13:17:28.572]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.572]  - attr(*, "where")=List of 1
[13:17:28.572]   ..$ ...:<environment: 0x5609ea623390> 
[13:17:28.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.572]  - attr(*, "resolved")= logi TRUE
[13:17:28.572]  - attr(*, "total_size")= num NA
[13:17:28.578]  - Getting '...' globals ... DONE
[13:17:28.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.578] List of 2
[13:17:28.578]  $ ...future.FUN:function (object, ...)  
[13:17:28.578]  $ ...          : list()
[13:17:28.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.578]  - attr(*, "where")=List of 2
[13:17:28.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.578]   ..$ ...          :<environment: 0x5609ea623390> 
[13:17:28.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.578]  - attr(*, "resolved")= logi FALSE
[13:17:28.578]  - attr(*, "total_size")= num 1240
[13:17:28.581] Packages to be attached in all futures: [n=0] 
[13:17:28.581] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.581] Number of futures (= number of chunks): 1
[13:17:28.582] Launching 1 futures (chunks) ...
[13:17:28.582] Chunk #1 of 1 ...
[13:17:28.582]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.582] getGlobalsAndPackages() ...
[13:17:28.582] Searching for globals...
[13:17:28.583] 
[13:17:28.583] Searching for globals ... DONE
[13:17:28.583] - globals: [0] <none>
[13:17:28.583] getGlobalsAndPackages() ... DONE
[13:17:28.583]    + additional globals found: [n=0] 
[13:17:28.583]    + additional namespaces needed: [n=0] 
[13:17:28.583]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.583]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.584]  - seeds: <none>
[13:17:28.584] getGlobalsAndPackages() ...
[13:17:28.584] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.584] Resolving globals: FALSE
[13:17:28.584] Tweak future expression to call with '...' arguments ...
[13:17:28.584] {
[13:17:28.584]     do.call(function(...) {
[13:17:28.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.584]             on.exit(options(oopts), add = TRUE)
[13:17:28.584]         }
[13:17:28.584]         {
[13:17:28.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.584]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.584]             })
[13:17:28.584]         }
[13:17:28.584]     }, args = future.call.arguments)
[13:17:28.584] }
[13:17:28.584] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.585] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.585] 
[13:17:28.585] getGlobalsAndPackages() ... DONE
[13:17:28.586] run() for ‘Future’ ...
[13:17:28.586] - state: ‘created’
[13:17:28.586] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:28.586] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.587]   - Field: ‘label’
[13:17:28.587]   - Field: ‘local’
[13:17:28.587]   - Field: ‘owner’
[13:17:28.587]   - Field: ‘envir’
[13:17:28.587]   - Field: ‘packages’
[13:17:28.587]   - Field: ‘gc’
[13:17:28.587]   - Field: ‘conditions’
[13:17:28.587]   - Field: ‘expr’
[13:17:28.587]   - Field: ‘uuid’
[13:17:28.587]   - Field: ‘seed’
[13:17:28.588]   - Field: ‘version’
[13:17:28.588]   - Field: ‘result’
[13:17:28.588]   - Field: ‘asynchronous’
[13:17:28.588]   - Field: ‘calls’
[13:17:28.588]   - Field: ‘globals’
[13:17:28.588]   - Field: ‘stdout’
[13:17:28.588]   - Field: ‘earlySignal’
[13:17:28.588]   - Field: ‘lazy’
[13:17:28.588]   - Field: ‘state’
[13:17:28.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.588] - Launch lazy future ...
[13:17:28.589] Packages needed by the future expression (n = 0): <none>
[13:17:28.589] Packages needed by future strategies (n = 0): <none>
[13:17:28.590] {
[13:17:28.590]     {
[13:17:28.590]         {
[13:17:28.590]             ...future.startTime <- base::Sys.time()
[13:17:28.590]             {
[13:17:28.590]                 {
[13:17:28.590]                   {
[13:17:28.590]                     base::local({
[13:17:28.590]                       has_future <- base::requireNamespace("future", 
[13:17:28.590]                         quietly = TRUE)
[13:17:28.590]                       if (has_future) {
[13:17:28.590]                         ns <- base::getNamespace("future")
[13:17:28.590]                         version <- ns[[".package"]][["version"]]
[13:17:28.590]                         if (is.null(version)) 
[13:17:28.590]                           version <- utils::packageVersion("future")
[13:17:28.590]                       }
[13:17:28.590]                       else {
[13:17:28.590]                         version <- NULL
[13:17:28.590]                       }
[13:17:28.590]                       if (!has_future || version < "1.8.0") {
[13:17:28.590]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.590]                           "", base::R.version$version.string), 
[13:17:28.590]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:28.590]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.590]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.590]                             "release", "version")], collapse = " "), 
[13:17:28.590]                           hostname = base::Sys.info()[["nodename"]])
[13:17:28.590]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.590]                           info)
[13:17:28.590]                         info <- base::paste(info, collapse = "; ")
[13:17:28.590]                         if (!has_future) {
[13:17:28.590]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.590]                             info)
[13:17:28.590]                         }
[13:17:28.590]                         else {
[13:17:28.590]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.590]                             info, version)
[13:17:28.590]                         }
[13:17:28.590]                         base::stop(msg)
[13:17:28.590]                       }
[13:17:28.590]                     })
[13:17:28.590]                   }
[13:17:28.590]                   options(future.plan = NULL)
[13:17:28.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.590]                 }
[13:17:28.590]                 ...future.workdir <- getwd()
[13:17:28.590]             }
[13:17:28.590]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.590]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.590]         }
[13:17:28.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.590]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.590]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.590]             base::names(...future.oldOptions))
[13:17:28.590]     }
[13:17:28.590]     if (FALSE) {
[13:17:28.590]     }
[13:17:28.590]     else {
[13:17:28.590]         if (TRUE) {
[13:17:28.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.590]                 open = "w")
[13:17:28.590]         }
[13:17:28.590]         else {
[13:17:28.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.590]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.590]         }
[13:17:28.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.590]             base::sink(type = "output", split = FALSE)
[13:17:28.590]             base::close(...future.stdout)
[13:17:28.590]         }, add = TRUE)
[13:17:28.590]     }
[13:17:28.590]     ...future.frame <- base::sys.nframe()
[13:17:28.590]     ...future.conditions <- base::list()
[13:17:28.590]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.590]     if (FALSE) {
[13:17:28.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.590]     }
[13:17:28.590]     ...future.result <- base::tryCatch({
[13:17:28.590]         base::withCallingHandlers({
[13:17:28.590]             ...future.value <- base::withVisible(base::local({
[13:17:28.590]                 do.call(function(...) {
[13:17:28.590]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.590]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.590]                     ...future.globals.maxSize)) {
[13:17:28.590]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.590]                     on.exit(options(oopts), add = TRUE)
[13:17:28.590]                   }
[13:17:28.590]                   {
[13:17:28.590]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.590]                       FUN = function(jj) {
[13:17:28.590]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.590]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.590]                       })
[13:17:28.590]                   }
[13:17:28.590]                 }, args = future.call.arguments)
[13:17:28.590]             }))
[13:17:28.590]             future::FutureResult(value = ...future.value$value, 
[13:17:28.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.590]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.590]                     ...future.globalenv.names))
[13:17:28.590]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.590]         }, condition = base::local({
[13:17:28.590]             c <- base::c
[13:17:28.590]             inherits <- base::inherits
[13:17:28.590]             invokeRestart <- base::invokeRestart
[13:17:28.590]             length <- base::length
[13:17:28.590]             list <- base::list
[13:17:28.590]             seq.int <- base::seq.int
[13:17:28.590]             signalCondition <- base::signalCondition
[13:17:28.590]             sys.calls <- base::sys.calls
[13:17:28.590]             `[[` <- base::`[[`
[13:17:28.590]             `+` <- base::`+`
[13:17:28.590]             `<<-` <- base::`<<-`
[13:17:28.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.590]                   3L)]
[13:17:28.590]             }
[13:17:28.590]             function(cond) {
[13:17:28.590]                 is_error <- inherits(cond, "error")
[13:17:28.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.590]                   NULL)
[13:17:28.590]                 if (is_error) {
[13:17:28.590]                   sessionInformation <- function() {
[13:17:28.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.590]                       search = base::search(), system = base::Sys.info())
[13:17:28.590]                   }
[13:17:28.590]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.590]                     cond$call), session = sessionInformation(), 
[13:17:28.590]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.590]                   signalCondition(cond)
[13:17:28.590]                 }
[13:17:28.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.590]                 "immediateCondition"))) {
[13:17:28.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.590]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.590]                   if (TRUE && !signal) {
[13:17:28.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.590]                     {
[13:17:28.590]                       inherits <- base::inherits
[13:17:28.590]                       invokeRestart <- base::invokeRestart
[13:17:28.590]                       is.null <- base::is.null
[13:17:28.590]                       muffled <- FALSE
[13:17:28.590]                       if (inherits(cond, "message")) {
[13:17:28.590]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.590]                         if (muffled) 
[13:17:28.590]                           invokeRestart("muffleMessage")
[13:17:28.590]                       }
[13:17:28.590]                       else if (inherits(cond, "warning")) {
[13:17:28.590]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.590]                         if (muffled) 
[13:17:28.590]                           invokeRestart("muffleWarning")
[13:17:28.590]                       }
[13:17:28.590]                       else if (inherits(cond, "condition")) {
[13:17:28.590]                         if (!is.null(pattern)) {
[13:17:28.590]                           computeRestarts <- base::computeRestarts
[13:17:28.590]                           grepl <- base::grepl
[13:17:28.590]                           restarts <- computeRestarts(cond)
[13:17:28.590]                           for (restart in restarts) {
[13:17:28.590]                             name <- restart$name
[13:17:28.590]                             if (is.null(name)) 
[13:17:28.590]                               next
[13:17:28.590]                             if (!grepl(pattern, name)) 
[13:17:28.590]                               next
[13:17:28.590]                             invokeRestart(restart)
[13:17:28.590]                             muffled <- TRUE
[13:17:28.590]                             break
[13:17:28.590]                           }
[13:17:28.590]                         }
[13:17:28.590]                       }
[13:17:28.590]                       invisible(muffled)
[13:17:28.590]                     }
[13:17:28.590]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.590]                   }
[13:17:28.590]                 }
[13:17:28.590]                 else {
[13:17:28.590]                   if (TRUE) {
[13:17:28.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.590]                     {
[13:17:28.590]                       inherits <- base::inherits
[13:17:28.590]                       invokeRestart <- base::invokeRestart
[13:17:28.590]                       is.null <- base::is.null
[13:17:28.590]                       muffled <- FALSE
[13:17:28.590]                       if (inherits(cond, "message")) {
[13:17:28.590]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.590]                         if (muffled) 
[13:17:28.590]                           invokeRestart("muffleMessage")
[13:17:28.590]                       }
[13:17:28.590]                       else if (inherits(cond, "warning")) {
[13:17:28.590]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.590]                         if (muffled) 
[13:17:28.590]                           invokeRestart("muffleWarning")
[13:17:28.590]                       }
[13:17:28.590]                       else if (inherits(cond, "condition")) {
[13:17:28.590]                         if (!is.null(pattern)) {
[13:17:28.590]                           computeRestarts <- base::computeRestarts
[13:17:28.590]                           grepl <- base::grepl
[13:17:28.590]                           restarts <- computeRestarts(cond)
[13:17:28.590]                           for (restart in restarts) {
[13:17:28.590]                             name <- restart$name
[13:17:28.590]                             if (is.null(name)) 
[13:17:28.590]                               next
[13:17:28.590]                             if (!grepl(pattern, name)) 
[13:17:28.590]                               next
[13:17:28.590]                             invokeRestart(restart)
[13:17:28.590]                             muffled <- TRUE
[13:17:28.590]                             break
[13:17:28.590]                           }
[13:17:28.590]                         }
[13:17:28.590]                       }
[13:17:28.590]                       invisible(muffled)
[13:17:28.590]                     }
[13:17:28.590]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.590]                   }
[13:17:28.590]                 }
[13:17:28.590]             }
[13:17:28.590]         }))
[13:17:28.590]     }, error = function(ex) {
[13:17:28.590]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.590]                 ...future.rng), started = ...future.startTime, 
[13:17:28.590]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.590]             version = "1.8"), class = "FutureResult")
[13:17:28.590]     }, finally = {
[13:17:28.590]         if (!identical(...future.workdir, getwd())) 
[13:17:28.590]             setwd(...future.workdir)
[13:17:28.590]         {
[13:17:28.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.590]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.590]             }
[13:17:28.590]             base::options(...future.oldOptions)
[13:17:28.590]             if (.Platform$OS.type == "windows") {
[13:17:28.590]                 old_names <- names(...future.oldEnvVars)
[13:17:28.590]                 envs <- base::Sys.getenv()
[13:17:28.590]                 names <- names(envs)
[13:17:28.590]                 common <- intersect(names, old_names)
[13:17:28.590]                 added <- setdiff(names, old_names)
[13:17:28.590]                 removed <- setdiff(old_names, names)
[13:17:28.590]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.590]                   envs[common]]
[13:17:28.590]                 NAMES <- toupper(changed)
[13:17:28.590]                 args <- list()
[13:17:28.590]                 for (kk in seq_along(NAMES)) {
[13:17:28.590]                   name <- changed[[kk]]
[13:17:28.590]                   NAME <- NAMES[[kk]]
[13:17:28.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.590]                     next
[13:17:28.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.590]                 }
[13:17:28.590]                 NAMES <- toupper(added)
[13:17:28.590]                 for (kk in seq_along(NAMES)) {
[13:17:28.590]                   name <- added[[kk]]
[13:17:28.590]                   NAME <- NAMES[[kk]]
[13:17:28.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.590]                     next
[13:17:28.590]                   args[[name]] <- ""
[13:17:28.590]                 }
[13:17:28.590]                 NAMES <- toupper(removed)
[13:17:28.590]                 for (kk in seq_along(NAMES)) {
[13:17:28.590]                   name <- removed[[kk]]
[13:17:28.590]                   NAME <- NAMES[[kk]]
[13:17:28.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.590]                     next
[13:17:28.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.590]                 }
[13:17:28.590]                 if (length(args) > 0) 
[13:17:28.590]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.590]             }
[13:17:28.590]             else {
[13:17:28.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.590]             }
[13:17:28.590]             {
[13:17:28.590]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.590]                   0L) {
[13:17:28.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.590]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.590]                   base::options(opts)
[13:17:28.590]                 }
[13:17:28.590]                 {
[13:17:28.590]                   {
[13:17:28.590]                     NULL
[13:17:28.590]                     RNGkind("Mersenne-Twister")
[13:17:28.590]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.590]                       inherits = FALSE)
[13:17:28.590]                   }
[13:17:28.590]                   options(future.plan = NULL)
[13:17:28.590]                   if (is.na(NA_character_)) 
[13:17:28.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.590]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:28.590]                   {
[13:17:28.590]                     future <- SequentialFuture(..., envir = envir)
[13:17:28.590]                     if (!future$lazy) 
[13:17:28.590]                       future <- run(future)
[13:17:28.590]                     invisible(future)
[13:17:28.590]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.590]                 }
[13:17:28.590]             }
[13:17:28.590]         }
[13:17:28.590]     })
[13:17:28.590]     if (TRUE) {
[13:17:28.590]         base::sink(type = "output", split = FALSE)
[13:17:28.590]         if (TRUE) {
[13:17:28.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.590]         }
[13:17:28.590]         else {
[13:17:28.590]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.590]         }
[13:17:28.590]         base::close(...future.stdout)
[13:17:28.590]         ...future.stdout <- NULL
[13:17:28.590]     }
[13:17:28.590]     ...future.result$conditions <- ...future.conditions
[13:17:28.590]     ...future.result$finished <- base::Sys.time()
[13:17:28.590]     ...future.result
[13:17:28.590] }
[13:17:28.592] assign_globals() ...
[13:17:28.592] List of 5
[13:17:28.592]  $ ...future.FUN            :function (object, ...)  
[13:17:28.592]  $ future.call.arguments    : list()
[13:17:28.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.592]  $ ...future.elements_ii    :List of 3
[13:17:28.592]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:28.592]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.592]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.592]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:28.592]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.592]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.592]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:28.592]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.592]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.592]  $ ...future.seeds_ii       : NULL
[13:17:28.592]  $ ...future.globals.maxSize: NULL
[13:17:28.592]  - attr(*, "resolved")= logi FALSE
[13:17:28.592]  - attr(*, "total_size")= num 1240
[13:17:28.592]  - attr(*, "where")=List of 5
[13:17:28.592]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.592]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.592]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.592]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.592]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.592]  - attr(*, "already-done")= logi TRUE
[13:17:28.600] - copied ‘...future.FUN’ to environment
[13:17:28.600] - copied ‘future.call.arguments’ to environment
[13:17:28.600] - copied ‘...future.elements_ii’ to environment
[13:17:28.600] - copied ‘...future.seeds_ii’ to environment
[13:17:28.600] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.600] assign_globals() ... done
[13:17:28.600] plan(): Setting new future strategy stack:
[13:17:28.601] List of future strategies:
[13:17:28.601] 1. sequential:
[13:17:28.601]    - args: function (..., envir = parent.frame())
[13:17:28.601]    - tweaked: FALSE
[13:17:28.601]    - call: NULL
[13:17:28.601] plan(): nbrOfWorkers() = 1
[13:17:28.603] plan(): Setting new future strategy stack:
[13:17:28.605] List of future strategies:
[13:17:28.605] 1. sequential:
[13:17:28.605]    - args: function (..., envir = parent.frame())
[13:17:28.605]    - tweaked: FALSE
[13:17:28.605]    - call: plan(strategy)
[13:17:28.606] plan(): nbrOfWorkers() = 1
[13:17:28.606] SequentialFuture started (and completed)
[13:17:28.606] - Launch lazy future ... done
[13:17:28.606] run() for ‘SequentialFuture’ ... done
[13:17:28.607] Created future:
[13:17:28.607] SequentialFuture:
[13:17:28.607] Label: ‘future_by-1’
[13:17:28.607] Expression:
[13:17:28.607] {
[13:17:28.607]     do.call(function(...) {
[13:17:28.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.607]             on.exit(options(oopts), add = TRUE)
[13:17:28.607]         }
[13:17:28.607]         {
[13:17:28.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.607]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.607]             })
[13:17:28.607]         }
[13:17:28.607]     }, args = future.call.arguments)
[13:17:28.607] }
[13:17:28.607] Lazy evaluation: FALSE
[13:17:28.607] Asynchronous evaluation: FALSE
[13:17:28.607] Local evaluation: TRUE
[13:17:28.607] Environment: R_GlobalEnv
[13:17:28.607] Capture standard output: TRUE
[13:17:28.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.607] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.607] Packages: <none>
[13:17:28.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.607] Resolved: TRUE
[13:17:28.607] Value: 4.62 KiB of class ‘list’
[13:17:28.607] Early signaling: FALSE
[13:17:28.607] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.607] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.608] Chunk #1 of 1 ... DONE
[13:17:28.608] Launching 1 futures (chunks) ... DONE
[13:17:28.609] Resolving 1 futures (chunks) ...
[13:17:28.609] resolve() on list ...
[13:17:28.609]  recursive: 0
[13:17:28.609]  length: 1
[13:17:28.609] 
[13:17:28.609] resolved() for ‘SequentialFuture’ ...
[13:17:28.609] - state: ‘finished’
[13:17:28.609] - run: TRUE
[13:17:28.610] - result: ‘FutureResult’
[13:17:28.610] resolved() for ‘SequentialFuture’ ... done
[13:17:28.610] Future #1
[13:17:28.610] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.610] - nx: 1
[13:17:28.610] - relay: TRUE
[13:17:28.610] - stdout: TRUE
[13:17:28.611] - signal: TRUE
[13:17:28.611] - resignal: FALSE
[13:17:28.611] - force: TRUE
[13:17:28.611] - relayed: [n=1] FALSE
[13:17:28.611] - queued futures: [n=1] FALSE
[13:17:28.611]  - until=1
[13:17:28.611]  - relaying element #1
[13:17:28.611] - relayed: [n=1] TRUE
[13:17:28.611] - queued futures: [n=1] TRUE
[13:17:28.611] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.612]  length: 0 (resolved future 1)
[13:17:28.612] Relaying remaining futures
[13:17:28.612] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.612] - nx: 1
[13:17:28.612] - relay: TRUE
[13:17:28.612] - stdout: TRUE
[13:17:28.612] - signal: TRUE
[13:17:28.612] - resignal: FALSE
[13:17:28.612] - force: TRUE
[13:17:28.612] - relayed: [n=1] TRUE
[13:17:28.612] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.613] - relayed: [n=1] TRUE
[13:17:28.613] - queued futures: [n=1] TRUE
[13:17:28.613] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.613] resolve() on list ... DONE
[13:17:28.613]  - Number of value chunks collected: 1
[13:17:28.613] Resolving 1 futures (chunks) ... DONE
[13:17:28.613] Reducing values from 1 chunks ...
[13:17:28.613]  - Number of values collected after concatenation: 3
[13:17:28.613]  - Number of values expected: 3
[13:17:28.614] Reducing values from 1 chunks ... DONE
[13:17:28.614] future_lapply() ... DONE
[13:17:28.614] future_by_internal() ... DONE
[13:17:28.614] future_by_internal() ...
[13:17:28.615] future_lapply() ...
[13:17:28.615] Number of chunks: 1
[13:17:28.615] getGlobalsAndPackagesXApply() ...
[13:17:28.616]  - future.globals: TRUE
[13:17:28.616] getGlobalsAndPackages() ...
[13:17:28.616] Searching for globals...
[13:17:28.617] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:28.617] Searching for globals ... DONE
[13:17:28.617] Resolving globals: FALSE
[13:17:28.617] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:28.618] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:28.618] - globals: [1] ‘FUN’
[13:17:28.618] 
[13:17:28.618] getGlobalsAndPackages() ... DONE
[13:17:28.618]  - globals found/used: [n=1] ‘FUN’
[13:17:28.618]  - needed namespaces: [n=0] 
[13:17:28.618] Finding globals ... DONE
[13:17:28.618]  - use_args: TRUE
[13:17:28.618]  - Getting '...' globals ...
[13:17:28.619] resolve() on list ...
[13:17:28.619]  recursive: 0
[13:17:28.619]  length: 1
[13:17:28.619]  elements: ‘...’
[13:17:28.619]  length: 0 (resolved future 1)
[13:17:28.619] resolve() on list ... DONE
[13:17:28.619]    - '...' content: [n=1] ‘digits’
[13:17:28.619] List of 1
[13:17:28.619]  $ ...:List of 1
[13:17:28.619]   ..$ digits: int 2
[13:17:28.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.619]  - attr(*, "where")=List of 1
[13:17:28.619]   ..$ ...:<environment: 0x5609e873c8a0> 
[13:17:28.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.619]  - attr(*, "resolved")= logi TRUE
[13:17:28.619]  - attr(*, "total_size")= num NA
[13:17:28.622]  - Getting '...' globals ... DONE
[13:17:28.623] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.623] List of 2
[13:17:28.623]  $ ...future.FUN:function (object, ...)  
[13:17:28.623]  $ ...          :List of 1
[13:17:28.623]   ..$ digits: int 2
[13:17:28.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.623]  - attr(*, "where")=List of 2
[13:17:28.623]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.623]   ..$ ...          :<environment: 0x5609e873c8a0> 
[13:17:28.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.623]  - attr(*, "resolved")= logi FALSE
[13:17:28.623]  - attr(*, "total_size")= num 1296
[13:17:28.626] Packages to be attached in all futures: [n=0] 
[13:17:28.626] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.626] Number of futures (= number of chunks): 1
[13:17:28.626] Launching 1 futures (chunks) ...
[13:17:28.626] Chunk #1 of 1 ...
[13:17:28.626]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.626] getGlobalsAndPackages() ...
[13:17:28.626] Searching for globals...
[13:17:28.627] 
[13:17:28.627] Searching for globals ... DONE
[13:17:28.627] - globals: [0] <none>
[13:17:28.627] getGlobalsAndPackages() ... DONE
[13:17:28.627]    + additional globals found: [n=0] 
[13:17:28.627]    + additional namespaces needed: [n=0] 
[13:17:28.627]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.627]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[13:17:28.627]  - seeds: <none>
[13:17:28.629] getGlobalsAndPackages() ...
[13:17:28.629] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.630] Resolving globals: FALSE
[13:17:28.630] Tweak future expression to call with '...' arguments ...
[13:17:28.630] {
[13:17:28.630]     do.call(function(...) {
[13:17:28.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.630]             on.exit(options(oopts), add = TRUE)
[13:17:28.630]         }
[13:17:28.630]         {
[13:17:28.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.630]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.630]             })
[13:17:28.630]         }
[13:17:28.630]     }, args = future.call.arguments)
[13:17:28.630] }
[13:17:28.630] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.630] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.630] 
[13:17:28.631] getGlobalsAndPackages() ... DONE
[13:17:28.631] run() for ‘Future’ ...
[13:17:28.631] - state: ‘created’
[13:17:28.631] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:28.631] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.631] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.632]   - Field: ‘label’
[13:17:28.632]   - Field: ‘local’
[13:17:28.632]   - Field: ‘owner’
[13:17:28.632]   - Field: ‘envir’
[13:17:28.632]   - Field: ‘packages’
[13:17:28.632]   - Field: ‘gc’
[13:17:28.632]   - Field: ‘conditions’
[13:17:28.632]   - Field: ‘expr’
[13:17:28.632]   - Field: ‘uuid’
[13:17:28.632]   - Field: ‘seed’
[13:17:28.633]   - Field: ‘version’
[13:17:28.633]   - Field: ‘result’
[13:17:28.633]   - Field: ‘asynchronous’
[13:17:28.633]   - Field: ‘calls’
[13:17:28.633]   - Field: ‘globals’
[13:17:28.633]   - Field: ‘stdout’
[13:17:28.633]   - Field: ‘earlySignal’
[13:17:28.633]   - Field: ‘lazy’
[13:17:28.633]   - Field: ‘state’
[13:17:28.633] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.634] - Launch lazy future ...
[13:17:28.634] Packages needed by the future expression (n = 0): <none>
[13:17:28.634] Packages needed by future strategies (n = 0): <none>
[13:17:28.634] {
[13:17:28.634]     {
[13:17:28.634]         {
[13:17:28.634]             ...future.startTime <- base::Sys.time()
[13:17:28.634]             {
[13:17:28.634]                 {
[13:17:28.634]                   {
[13:17:28.634]                     base::local({
[13:17:28.634]                       has_future <- base::requireNamespace("future", 
[13:17:28.634]                         quietly = TRUE)
[13:17:28.634]                       if (has_future) {
[13:17:28.634]                         ns <- base::getNamespace("future")
[13:17:28.634]                         version <- ns[[".package"]][["version"]]
[13:17:28.634]                         if (is.null(version)) 
[13:17:28.634]                           version <- utils::packageVersion("future")
[13:17:28.634]                       }
[13:17:28.634]                       else {
[13:17:28.634]                         version <- NULL
[13:17:28.634]                       }
[13:17:28.634]                       if (!has_future || version < "1.8.0") {
[13:17:28.634]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.634]                           "", base::R.version$version.string), 
[13:17:28.634]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:28.634]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.634]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.634]                             "release", "version")], collapse = " "), 
[13:17:28.634]                           hostname = base::Sys.info()[["nodename"]])
[13:17:28.634]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.634]                           info)
[13:17:28.634]                         info <- base::paste(info, collapse = "; ")
[13:17:28.634]                         if (!has_future) {
[13:17:28.634]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.634]                             info)
[13:17:28.634]                         }
[13:17:28.634]                         else {
[13:17:28.634]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.634]                             info, version)
[13:17:28.634]                         }
[13:17:28.634]                         base::stop(msg)
[13:17:28.634]                       }
[13:17:28.634]                     })
[13:17:28.634]                   }
[13:17:28.634]                   options(future.plan = NULL)
[13:17:28.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.634]                 }
[13:17:28.634]                 ...future.workdir <- getwd()
[13:17:28.634]             }
[13:17:28.634]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.634]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.634]         }
[13:17:28.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.634]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[13:17:28.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.634]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.634]             base::names(...future.oldOptions))
[13:17:28.634]     }
[13:17:28.634]     if (FALSE) {
[13:17:28.634]     }
[13:17:28.634]     else {
[13:17:28.634]         if (TRUE) {
[13:17:28.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.634]                 open = "w")
[13:17:28.634]         }
[13:17:28.634]         else {
[13:17:28.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.634]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.634]         }
[13:17:28.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.634]             base::sink(type = "output", split = FALSE)
[13:17:28.634]             base::close(...future.stdout)
[13:17:28.634]         }, add = TRUE)
[13:17:28.634]     }
[13:17:28.634]     ...future.frame <- base::sys.nframe()
[13:17:28.634]     ...future.conditions <- base::list()
[13:17:28.634]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.634]     if (FALSE) {
[13:17:28.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.634]     }
[13:17:28.634]     ...future.result <- base::tryCatch({
[13:17:28.634]         base::withCallingHandlers({
[13:17:28.634]             ...future.value <- base::withVisible(base::local({
[13:17:28.634]                 do.call(function(...) {
[13:17:28.634]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.634]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.634]                     ...future.globals.maxSize)) {
[13:17:28.634]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.634]                     on.exit(options(oopts), add = TRUE)
[13:17:28.634]                   }
[13:17:28.634]                   {
[13:17:28.634]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.634]                       FUN = function(jj) {
[13:17:28.634]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.634]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.634]                       })
[13:17:28.634]                   }
[13:17:28.634]                 }, args = future.call.arguments)
[13:17:28.634]             }))
[13:17:28.634]             future::FutureResult(value = ...future.value$value, 
[13:17:28.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.634]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.634]                     ...future.globalenv.names))
[13:17:28.634]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.634]         }, condition = base::local({
[13:17:28.634]             c <- base::c
[13:17:28.634]             inherits <- base::inherits
[13:17:28.634]             invokeRestart <- base::invokeRestart
[13:17:28.634]             length <- base::length
[13:17:28.634]             list <- base::list
[13:17:28.634]             seq.int <- base::seq.int
[13:17:28.634]             signalCondition <- base::signalCondition
[13:17:28.634]             sys.calls <- base::sys.calls
[13:17:28.634]             `[[` <- base::`[[`
[13:17:28.634]             `+` <- base::`+`
[13:17:28.634]             `<<-` <- base::`<<-`
[13:17:28.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.634]                   3L)]
[13:17:28.634]             }
[13:17:28.634]             function(cond) {
[13:17:28.634]                 is_error <- inherits(cond, "error")
[13:17:28.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.634]                   NULL)
[13:17:28.634]                 if (is_error) {
[13:17:28.634]                   sessionInformation <- function() {
[13:17:28.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.634]                       search = base::search(), system = base::Sys.info())
[13:17:28.634]                   }
[13:17:28.634]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.634]                     cond$call), session = sessionInformation(), 
[13:17:28.634]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.634]                   signalCondition(cond)
[13:17:28.634]                 }
[13:17:28.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.634]                 "immediateCondition"))) {
[13:17:28.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.634]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.634]                   if (TRUE && !signal) {
[13:17:28.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.634]                     {
[13:17:28.634]                       inherits <- base::inherits
[13:17:28.634]                       invokeRestart <- base::invokeRestart
[13:17:28.634]                       is.null <- base::is.null
[13:17:28.634]                       muffled <- FALSE
[13:17:28.634]                       if (inherits(cond, "message")) {
[13:17:28.634]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.634]                         if (muffled) 
[13:17:28.634]                           invokeRestart("muffleMessage")
[13:17:28.634]                       }
[13:17:28.634]                       else if (inherits(cond, "warning")) {
[13:17:28.634]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.634]                         if (muffled) 
[13:17:28.634]                           invokeRestart("muffleWarning")
[13:17:28.634]                       }
[13:17:28.634]                       else if (inherits(cond, "condition")) {
[13:17:28.634]                         if (!is.null(pattern)) {
[13:17:28.634]                           computeRestarts <- base::computeRestarts
[13:17:28.634]                           grepl <- base::grepl
[13:17:28.634]                           restarts <- computeRestarts(cond)
[13:17:28.634]                           for (restart in restarts) {
[13:17:28.634]                             name <- restart$name
[13:17:28.634]                             if (is.null(name)) 
[13:17:28.634]                               next
[13:17:28.634]                             if (!grepl(pattern, name)) 
[13:17:28.634]                               next
[13:17:28.634]                             invokeRestart(restart)
[13:17:28.634]                             muffled <- TRUE
[13:17:28.634]                             break
[13:17:28.634]                           }
[13:17:28.634]                         }
[13:17:28.634]                       }
[13:17:28.634]                       invisible(muffled)
[13:17:28.634]                     }
[13:17:28.634]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.634]                   }
[13:17:28.634]                 }
[13:17:28.634]                 else {
[13:17:28.634]                   if (TRUE) {
[13:17:28.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.634]                     {
[13:17:28.634]                       inherits <- base::inherits
[13:17:28.634]                       invokeRestart <- base::invokeRestart
[13:17:28.634]                       is.null <- base::is.null
[13:17:28.634]                       muffled <- FALSE
[13:17:28.634]                       if (inherits(cond, "message")) {
[13:17:28.634]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.634]                         if (muffled) 
[13:17:28.634]                           invokeRestart("muffleMessage")
[13:17:28.634]                       }
[13:17:28.634]                       else if (inherits(cond, "warning")) {
[13:17:28.634]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.634]                         if (muffled) 
[13:17:28.634]                           invokeRestart("muffleWarning")
[13:17:28.634]                       }
[13:17:28.634]                       else if (inherits(cond, "condition")) {
[13:17:28.634]                         if (!is.null(pattern)) {
[13:17:28.634]                           computeRestarts <- base::computeRestarts
[13:17:28.634]                           grepl <- base::grepl
[13:17:28.634]                           restarts <- computeRestarts(cond)
[13:17:28.634]                           for (restart in restarts) {
[13:17:28.634]                             name <- restart$name
[13:17:28.634]                             if (is.null(name)) 
[13:17:28.634]                               next
[13:17:28.634]                             if (!grepl(pattern, name)) 
[13:17:28.634]                               next
[13:17:28.634]                             invokeRestart(restart)
[13:17:28.634]                             muffled <- TRUE
[13:17:28.634]                             break
[13:17:28.634]                           }
[13:17:28.634]                         }
[13:17:28.634]                       }
[13:17:28.634]                       invisible(muffled)
[13:17:28.634]                     }
[13:17:28.634]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.634]                   }
[13:17:28.634]                 }
[13:17:28.634]             }
[13:17:28.634]         }))
[13:17:28.634]     }, error = function(ex) {
[13:17:28.634]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.634]                 ...future.rng), started = ...future.startTime, 
[13:17:28.634]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.634]             version = "1.8"), class = "FutureResult")
[13:17:28.634]     }, finally = {
[13:17:28.634]         if (!identical(...future.workdir, getwd())) 
[13:17:28.634]             setwd(...future.workdir)
[13:17:28.634]         {
[13:17:28.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.634]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.634]             }
[13:17:28.634]             base::options(...future.oldOptions)
[13:17:28.634]             if (.Platform$OS.type == "windows") {
[13:17:28.634]                 old_names <- names(...future.oldEnvVars)
[13:17:28.634]                 envs <- base::Sys.getenv()
[13:17:28.634]                 names <- names(envs)
[13:17:28.634]                 common <- intersect(names, old_names)
[13:17:28.634]                 added <- setdiff(names, old_names)
[13:17:28.634]                 removed <- setdiff(old_names, names)
[13:17:28.634]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.634]                   envs[common]]
[13:17:28.634]                 NAMES <- toupper(changed)
[13:17:28.634]                 args <- list()
[13:17:28.634]                 for (kk in seq_along(NAMES)) {
[13:17:28.634]                   name <- changed[[kk]]
[13:17:28.634]                   NAME <- NAMES[[kk]]
[13:17:28.634]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.634]                     next
[13:17:28.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.634]                 }
[13:17:28.634]                 NAMES <- toupper(added)
[13:17:28.634]                 for (kk in seq_along(NAMES)) {
[13:17:28.634]                   name <- added[[kk]]
[13:17:28.634]                   NAME <- NAMES[[kk]]
[13:17:28.634]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.634]                     next
[13:17:28.634]                   args[[name]] <- ""
[13:17:28.634]                 }
[13:17:28.634]                 NAMES <- toupper(removed)
[13:17:28.634]                 for (kk in seq_along(NAMES)) {
[13:17:28.634]                   name <- removed[[kk]]
[13:17:28.634]                   NAME <- NAMES[[kk]]
[13:17:28.634]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.634]                     next
[13:17:28.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.634]                 }
[13:17:28.634]                 if (length(args) > 0) 
[13:17:28.634]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.634]             }
[13:17:28.634]             else {
[13:17:28.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.634]             }
[13:17:28.634]             {
[13:17:28.634]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.634]                   0L) {
[13:17:28.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.634]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.634]                   base::options(opts)
[13:17:28.634]                 }
[13:17:28.634]                 {
[13:17:28.634]                   {
[13:17:28.634]                     NULL
[13:17:28.634]                     RNGkind("Mersenne-Twister")
[13:17:28.634]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.634]                       inherits = FALSE)
[13:17:28.634]                   }
[13:17:28.634]                   options(future.plan = NULL)
[13:17:28.634]                   if (is.na(NA_character_)) 
[13:17:28.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.634]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:28.634]                   {
[13:17:28.634]                     future <- SequentialFuture(..., envir = envir)
[13:17:28.634]                     if (!future$lazy) 
[13:17:28.634]                       future <- run(future)
[13:17:28.634]                     invisible(future)
[13:17:28.634]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.634]                 }
[13:17:28.634]             }
[13:17:28.634]         }
[13:17:28.634]     })
[13:17:28.634]     if (TRUE) {
[13:17:28.634]         base::sink(type = "output", split = FALSE)
[13:17:28.634]         if (TRUE) {
[13:17:28.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.634]         }
[13:17:28.634]         else {
[13:17:28.634]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.634]         }
[13:17:28.634]         base::close(...future.stdout)
[13:17:28.634]         ...future.stdout <- NULL
[13:17:28.634]     }
[13:17:28.634]     ...future.result$conditions <- ...future.conditions
[13:17:28.634]     ...future.result$finished <- base::Sys.time()
[13:17:28.634]     ...future.result
[13:17:28.634] }
[13:17:28.636] assign_globals() ...
[13:17:28.636] List of 5
[13:17:28.636]  $ ...future.FUN            :function (object, ...)  
[13:17:28.636]  $ future.call.arguments    :List of 1
[13:17:28.636]   ..$ digits: int 2
[13:17:28.636]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.636]  $ ...future.elements_ii    :List of 6
[13:17:28.636]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:17:28.636]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:17:28.636]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:17:28.636]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:17:28.636]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:17:28.636]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:17:28.636]  $ ...future.seeds_ii       : NULL
[13:17:28.636]  $ ...future.globals.maxSize: NULL
[13:17:28.636]  - attr(*, "resolved")= logi FALSE
[13:17:28.636]  - attr(*, "total_size")= num 1296
[13:17:28.636]  - attr(*, "where")=List of 5
[13:17:28.636]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.636]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.636]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.636]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.636]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.636]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.636]  - attr(*, "already-done")= logi TRUE
[13:17:28.643] - copied ‘...future.FUN’ to environment
[13:17:28.643] - copied ‘future.call.arguments’ to environment
[13:17:28.643] - copied ‘...future.elements_ii’ to environment
[13:17:28.643] - copied ‘...future.seeds_ii’ to environment
[13:17:28.643] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.643] assign_globals() ... done
[13:17:28.643] plan(): Setting new future strategy stack:
[13:17:28.643] List of future strategies:
[13:17:28.643] 1. sequential:
[13:17:28.643]    - args: function (..., envir = parent.frame())
[13:17:28.643]    - tweaked: FALSE
[13:17:28.643]    - call: NULL
[13:17:28.644] plan(): nbrOfWorkers() = 1
[13:17:28.645] plan(): Setting new future strategy stack:
[13:17:28.645] List of future strategies:
[13:17:28.645] 1. sequential:
[13:17:28.645]    - args: function (..., envir = parent.frame())
[13:17:28.645]    - tweaked: FALSE
[13:17:28.645]    - call: plan(strategy)
[13:17:28.646] plan(): nbrOfWorkers() = 1
[13:17:28.646] SequentialFuture started (and completed)
[13:17:28.646] - Launch lazy future ... done
[13:17:28.646] run() for ‘SequentialFuture’ ... done
[13:17:28.646] Created future:
[13:17:28.646] SequentialFuture:
[13:17:28.646] Label: ‘future_by-1’
[13:17:28.646] Expression:
[13:17:28.646] {
[13:17:28.646]     do.call(function(...) {
[13:17:28.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.646]             on.exit(options(oopts), add = TRUE)
[13:17:28.646]         }
[13:17:28.646]         {
[13:17:28.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.646]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.646]             })
[13:17:28.646]         }
[13:17:28.646]     }, args = future.call.arguments)
[13:17:28.646] }
[13:17:28.646] Lazy evaluation: FALSE
[13:17:28.646] Asynchronous evaluation: FALSE
[13:17:28.646] Local evaluation: TRUE
[13:17:28.646] Environment: R_GlobalEnv
[13:17:28.646] Capture standard output: TRUE
[13:17:28.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.646] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.646] Packages: <none>
[13:17:28.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.646] Resolved: TRUE
[13:17:28.646] Value: 5.48 KiB of class ‘list’
[13:17:28.646] Early signaling: FALSE
[13:17:28.646] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.646] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.647] Chunk #1 of 1 ... DONE
[13:17:28.647] Launching 1 futures (chunks) ... DONE
[13:17:28.647] Resolving 1 futures (chunks) ...
[13:17:28.648] resolve() on list ...
[13:17:28.648]  recursive: 0
[13:17:28.648]  length: 1
[13:17:28.648] 
[13:17:28.648] resolved() for ‘SequentialFuture’ ...
[13:17:28.648] - state: ‘finished’
[13:17:28.648] - run: TRUE
[13:17:28.648] - result: ‘FutureResult’
[13:17:28.648] resolved() for ‘SequentialFuture’ ... done
[13:17:28.648] Future #1
[13:17:28.649] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.649] - nx: 1
[13:17:28.649] - relay: TRUE
[13:17:28.649] - stdout: TRUE
[13:17:28.649] - signal: TRUE
[13:17:28.649] - resignal: FALSE
[13:17:28.649] - force: TRUE
[13:17:28.649] - relayed: [n=1] FALSE
[13:17:28.649] - queued futures: [n=1] FALSE
[13:17:28.649]  - until=1
[13:17:28.649]  - relaying element #1
[13:17:28.650] - relayed: [n=1] TRUE
[13:17:28.650] - queued futures: [n=1] TRUE
[13:17:28.650] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.650]  length: 0 (resolved future 1)
[13:17:28.650] Relaying remaining futures
[13:17:28.650] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.650] - nx: 1
[13:17:28.650] - relay: TRUE
[13:17:28.650] - stdout: TRUE
[13:17:28.650] - signal: TRUE
[13:17:28.650] - resignal: FALSE
[13:17:28.651] - force: TRUE
[13:17:28.651] - relayed: [n=1] TRUE
[13:17:28.651] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.651] - relayed: [n=1] TRUE
[13:17:28.652] - queued futures: [n=1] TRUE
[13:17:28.653] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.653] resolve() on list ... DONE
[13:17:28.653]  - Number of value chunks collected: 1
[13:17:28.653] Resolving 1 futures (chunks) ... DONE
[13:17:28.653] Reducing values from 1 chunks ...
[13:17:28.653]  - Number of values collected after concatenation: 6
[13:17:28.653]  - Number of values expected: 6
[13:17:28.653] Reducing values from 1 chunks ... DONE
[13:17:28.653] future_lapply() ... DONE
[13:17:28.653] future_by_internal() ... DONE
[13:17:28.657] future_by_internal() ...
[13:17:28.657] future_lapply() ...
[13:17:28.658] Number of chunks: 1
[13:17:28.658] getGlobalsAndPackagesXApply() ...
[13:17:28.658]  - future.globals: TRUE
[13:17:28.658] getGlobalsAndPackages() ...
[13:17:28.658] Searching for globals...
[13:17:28.660] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:28.660] Searching for globals ... DONE
[13:17:28.660] Resolving globals: FALSE
[13:17:28.660] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:17:28.661] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:17:28.661] - globals: [1] ‘FUN’
[13:17:28.661] - packages: [1] ‘stats’
[13:17:28.661] getGlobalsAndPackages() ... DONE
[13:17:28.661]  - globals found/used: [n=1] ‘FUN’
[13:17:28.661]  - needed namespaces: [n=1] ‘stats’
[13:17:28.661] Finding globals ... DONE
[13:17:28.662]  - use_args: TRUE
[13:17:28.662]  - Getting '...' globals ...
[13:17:28.662] resolve() on list ...
[13:17:28.662]  recursive: 0
[13:17:28.662]  length: 1
[13:17:28.662]  elements: ‘...’
[13:17:28.662]  length: 0 (resolved future 1)
[13:17:28.662] resolve() on list ... DONE
[13:17:28.662]    - '...' content: [n=1] ‘singular.ok’
[13:17:28.663] List of 1
[13:17:28.663]  $ ...:List of 1
[13:17:28.663]   ..$ singular.ok: logi FALSE
[13:17:28.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.663]  - attr(*, "where")=List of 1
[13:17:28.663]   ..$ ...:<environment: 0x5609e8606010> 
[13:17:28.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.663]  - attr(*, "resolved")= logi TRUE
[13:17:28.663]  - attr(*, "total_size")= num NA
[13:17:28.666]  - Getting '...' globals ... DONE
[13:17:28.666] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.666] List of 2
[13:17:28.666]  $ ...future.FUN:function (x, ...)  
[13:17:28.666]  $ ...          :List of 1
[13:17:28.666]   ..$ singular.ok: logi FALSE
[13:17:28.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.666]  - attr(*, "where")=List of 2
[13:17:28.666]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.666]   ..$ ...          :<environment: 0x5609e8606010> 
[13:17:28.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.666]  - attr(*, "resolved")= logi FALSE
[13:17:28.666]  - attr(*, "total_size")= num 5384
[13:17:28.669] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:28.669] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.669] Number of futures (= number of chunks): 1
[13:17:28.669] Launching 1 futures (chunks) ...
[13:17:28.669] Chunk #1 of 1 ...
[13:17:28.669]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.669] getGlobalsAndPackages() ...
[13:17:28.670] Searching for globals...
[13:17:28.670] 
[13:17:28.670] Searching for globals ... DONE
[13:17:28.670] - globals: [0] <none>
[13:17:28.670] getGlobalsAndPackages() ... DONE
[13:17:28.670]    + additional globals found: [n=0] 
[13:17:28.670]    + additional namespaces needed: [n=0] 
[13:17:28.671]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.671]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.671]  - seeds: <none>
[13:17:28.671] getGlobalsAndPackages() ...
[13:17:28.671] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.671] Resolving globals: FALSE
[13:17:28.672] Tweak future expression to call with '...' arguments ...
[13:17:28.673] {
[13:17:28.673]     do.call(function(...) {
[13:17:28.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.673]             on.exit(options(oopts), add = TRUE)
[13:17:28.673]         }
[13:17:28.673]         {
[13:17:28.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.673]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.673]             })
[13:17:28.673]         }
[13:17:28.673]     }, args = future.call.arguments)
[13:17:28.673] }
[13:17:28.673] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.673] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.673] 
[13:17:28.673] getGlobalsAndPackages() ... DONE
[13:17:28.674] run() for ‘Future’ ...
[13:17:28.674] - state: ‘created’
[13:17:28.674] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:28.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.674]   - Field: ‘label’
[13:17:28.675]   - Field: ‘local’
[13:17:28.675]   - Field: ‘owner’
[13:17:28.675]   - Field: ‘envir’
[13:17:28.675]   - Field: ‘packages’
[13:17:28.675]   - Field: ‘gc’
[13:17:28.675]   - Field: ‘conditions’
[13:17:28.675]   - Field: ‘expr’
[13:17:28.675]   - Field: ‘uuid’
[13:17:28.675]   - Field: ‘seed’
[13:17:28.675]   - Field: ‘version’
[13:17:28.675]   - Field: ‘result’
[13:17:28.676]   - Field: ‘asynchronous’
[13:17:28.676]   - Field: ‘calls’
[13:17:28.676]   - Field: ‘globals’
[13:17:28.676]   - Field: ‘stdout’
[13:17:28.676]   - Field: ‘earlySignal’
[13:17:28.676]   - Field: ‘lazy’
[13:17:28.676]   - Field: ‘state’
[13:17:28.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.676] - Launch lazy future ...
[13:17:28.676] Packages needed by the future expression (n = 1): ‘stats’
[13:17:28.677] Packages needed by future strategies (n = 0): <none>
[13:17:28.677] {
[13:17:28.677]     {
[13:17:28.677]         {
[13:17:28.677]             ...future.startTime <- base::Sys.time()
[13:17:28.677]             {
[13:17:28.677]                 {
[13:17:28.677]                   {
[13:17:28.677]                     {
[13:17:28.677]                       base::local({
[13:17:28.677]                         has_future <- base::requireNamespace("future", 
[13:17:28.677]                           quietly = TRUE)
[13:17:28.677]                         if (has_future) {
[13:17:28.677]                           ns <- base::getNamespace("future")
[13:17:28.677]                           version <- ns[[".package"]][["version"]]
[13:17:28.677]                           if (is.null(version)) 
[13:17:28.677]                             version <- utils::packageVersion("future")
[13:17:28.677]                         }
[13:17:28.677]                         else {
[13:17:28.677]                           version <- NULL
[13:17:28.677]                         }
[13:17:28.677]                         if (!has_future || version < "1.8.0") {
[13:17:28.677]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.677]                             "", base::R.version$version.string), 
[13:17:28.677]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:28.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.677]                               "release", "version")], collapse = " "), 
[13:17:28.677]                             hostname = base::Sys.info()[["nodename"]])
[13:17:28.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.677]                             info)
[13:17:28.677]                           info <- base::paste(info, collapse = "; ")
[13:17:28.677]                           if (!has_future) {
[13:17:28.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.677]                               info)
[13:17:28.677]                           }
[13:17:28.677]                           else {
[13:17:28.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.677]                               info, version)
[13:17:28.677]                           }
[13:17:28.677]                           base::stop(msg)
[13:17:28.677]                         }
[13:17:28.677]                       })
[13:17:28.677]                     }
[13:17:28.677]                     base::local({
[13:17:28.677]                       for (pkg in "stats") {
[13:17:28.677]                         base::loadNamespace(pkg)
[13:17:28.677]                         base::library(pkg, character.only = TRUE)
[13:17:28.677]                       }
[13:17:28.677]                     })
[13:17:28.677]                   }
[13:17:28.677]                   options(future.plan = NULL)
[13:17:28.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.677]                 }
[13:17:28.677]                 ...future.workdir <- getwd()
[13:17:28.677]             }
[13:17:28.677]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.677]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.677]         }
[13:17:28.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.677]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.677]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.677]             base::names(...future.oldOptions))
[13:17:28.677]     }
[13:17:28.677]     if (FALSE) {
[13:17:28.677]     }
[13:17:28.677]     else {
[13:17:28.677]         if (TRUE) {
[13:17:28.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.677]                 open = "w")
[13:17:28.677]         }
[13:17:28.677]         else {
[13:17:28.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.677]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.677]         }
[13:17:28.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.677]             base::sink(type = "output", split = FALSE)
[13:17:28.677]             base::close(...future.stdout)
[13:17:28.677]         }, add = TRUE)
[13:17:28.677]     }
[13:17:28.677]     ...future.frame <- base::sys.nframe()
[13:17:28.677]     ...future.conditions <- base::list()
[13:17:28.677]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.677]     if (FALSE) {
[13:17:28.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.677]     }
[13:17:28.677]     ...future.result <- base::tryCatch({
[13:17:28.677]         base::withCallingHandlers({
[13:17:28.677]             ...future.value <- base::withVisible(base::local({
[13:17:28.677]                 do.call(function(...) {
[13:17:28.677]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.677]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.677]                     ...future.globals.maxSize)) {
[13:17:28.677]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.677]                     on.exit(options(oopts), add = TRUE)
[13:17:28.677]                   }
[13:17:28.677]                   {
[13:17:28.677]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.677]                       FUN = function(jj) {
[13:17:28.677]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.677]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.677]                       })
[13:17:28.677]                   }
[13:17:28.677]                 }, args = future.call.arguments)
[13:17:28.677]             }))
[13:17:28.677]             future::FutureResult(value = ...future.value$value, 
[13:17:28.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.677]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.677]                     ...future.globalenv.names))
[13:17:28.677]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.677]         }, condition = base::local({
[13:17:28.677]             c <- base::c
[13:17:28.677]             inherits <- base::inherits
[13:17:28.677]             invokeRestart <- base::invokeRestart
[13:17:28.677]             length <- base::length
[13:17:28.677]             list <- base::list
[13:17:28.677]             seq.int <- base::seq.int
[13:17:28.677]             signalCondition <- base::signalCondition
[13:17:28.677]             sys.calls <- base::sys.calls
[13:17:28.677]             `[[` <- base::`[[`
[13:17:28.677]             `+` <- base::`+`
[13:17:28.677]             `<<-` <- base::`<<-`
[13:17:28.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.677]                   3L)]
[13:17:28.677]             }
[13:17:28.677]             function(cond) {
[13:17:28.677]                 is_error <- inherits(cond, "error")
[13:17:28.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.677]                   NULL)
[13:17:28.677]                 if (is_error) {
[13:17:28.677]                   sessionInformation <- function() {
[13:17:28.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.677]                       search = base::search(), system = base::Sys.info())
[13:17:28.677]                   }
[13:17:28.677]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.677]                     cond$call), session = sessionInformation(), 
[13:17:28.677]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.677]                   signalCondition(cond)
[13:17:28.677]                 }
[13:17:28.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.677]                 "immediateCondition"))) {
[13:17:28.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.677]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.677]                   if (TRUE && !signal) {
[13:17:28.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.677]                     {
[13:17:28.677]                       inherits <- base::inherits
[13:17:28.677]                       invokeRestart <- base::invokeRestart
[13:17:28.677]                       is.null <- base::is.null
[13:17:28.677]                       muffled <- FALSE
[13:17:28.677]                       if (inherits(cond, "message")) {
[13:17:28.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.677]                         if (muffled) 
[13:17:28.677]                           invokeRestart("muffleMessage")
[13:17:28.677]                       }
[13:17:28.677]                       else if (inherits(cond, "warning")) {
[13:17:28.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.677]                         if (muffled) 
[13:17:28.677]                           invokeRestart("muffleWarning")
[13:17:28.677]                       }
[13:17:28.677]                       else if (inherits(cond, "condition")) {
[13:17:28.677]                         if (!is.null(pattern)) {
[13:17:28.677]                           computeRestarts <- base::computeRestarts
[13:17:28.677]                           grepl <- base::grepl
[13:17:28.677]                           restarts <- computeRestarts(cond)
[13:17:28.677]                           for (restart in restarts) {
[13:17:28.677]                             name <- restart$name
[13:17:28.677]                             if (is.null(name)) 
[13:17:28.677]                               next
[13:17:28.677]                             if (!grepl(pattern, name)) 
[13:17:28.677]                               next
[13:17:28.677]                             invokeRestart(restart)
[13:17:28.677]                             muffled <- TRUE
[13:17:28.677]                             break
[13:17:28.677]                           }
[13:17:28.677]                         }
[13:17:28.677]                       }
[13:17:28.677]                       invisible(muffled)
[13:17:28.677]                     }
[13:17:28.677]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.677]                   }
[13:17:28.677]                 }
[13:17:28.677]                 else {
[13:17:28.677]                   if (TRUE) {
[13:17:28.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.677]                     {
[13:17:28.677]                       inherits <- base::inherits
[13:17:28.677]                       invokeRestart <- base::invokeRestart
[13:17:28.677]                       is.null <- base::is.null
[13:17:28.677]                       muffled <- FALSE
[13:17:28.677]                       if (inherits(cond, "message")) {
[13:17:28.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.677]                         if (muffled) 
[13:17:28.677]                           invokeRestart("muffleMessage")
[13:17:28.677]                       }
[13:17:28.677]                       else if (inherits(cond, "warning")) {
[13:17:28.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.677]                         if (muffled) 
[13:17:28.677]                           invokeRestart("muffleWarning")
[13:17:28.677]                       }
[13:17:28.677]                       else if (inherits(cond, "condition")) {
[13:17:28.677]                         if (!is.null(pattern)) {
[13:17:28.677]                           computeRestarts <- base::computeRestarts
[13:17:28.677]                           grepl <- base::grepl
[13:17:28.677]                           restarts <- computeRestarts(cond)
[13:17:28.677]                           for (restart in restarts) {
[13:17:28.677]                             name <- restart$name
[13:17:28.677]                             if (is.null(name)) 
[13:17:28.677]                               next
[13:17:28.677]                             if (!grepl(pattern, name)) 
[13:17:28.677]                               next
[13:17:28.677]                             invokeRestart(restart)
[13:17:28.677]                             muffled <- TRUE
[13:17:28.677]                             break
[13:17:28.677]                           }
[13:17:28.677]                         }
[13:17:28.677]                       }
[13:17:28.677]                       invisible(muffled)
[13:17:28.677]                     }
[13:17:28.677]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.677]                   }
[13:17:28.677]                 }
[13:17:28.677]             }
[13:17:28.677]         }))
[13:17:28.677]     }, error = function(ex) {
[13:17:28.677]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.677]                 ...future.rng), started = ...future.startTime, 
[13:17:28.677]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.677]             version = "1.8"), class = "FutureResult")
[13:17:28.677]     }, finally = {
[13:17:28.677]         if (!identical(...future.workdir, getwd())) 
[13:17:28.677]             setwd(...future.workdir)
[13:17:28.677]         {
[13:17:28.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.677]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.677]             }
[13:17:28.677]             base::options(...future.oldOptions)
[13:17:28.677]             if (.Platform$OS.type == "windows") {
[13:17:28.677]                 old_names <- names(...future.oldEnvVars)
[13:17:28.677]                 envs <- base::Sys.getenv()
[13:17:28.677]                 names <- names(envs)
[13:17:28.677]                 common <- intersect(names, old_names)
[13:17:28.677]                 added <- setdiff(names, old_names)
[13:17:28.677]                 removed <- setdiff(old_names, names)
[13:17:28.677]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.677]                   envs[common]]
[13:17:28.677]                 NAMES <- toupper(changed)
[13:17:28.677]                 args <- list()
[13:17:28.677]                 for (kk in seq_along(NAMES)) {
[13:17:28.677]                   name <- changed[[kk]]
[13:17:28.677]                   NAME <- NAMES[[kk]]
[13:17:28.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.677]                     next
[13:17:28.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.677]                 }
[13:17:28.677]                 NAMES <- toupper(added)
[13:17:28.677]                 for (kk in seq_along(NAMES)) {
[13:17:28.677]                   name <- added[[kk]]
[13:17:28.677]                   NAME <- NAMES[[kk]]
[13:17:28.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.677]                     next
[13:17:28.677]                   args[[name]] <- ""
[13:17:28.677]                 }
[13:17:28.677]                 NAMES <- toupper(removed)
[13:17:28.677]                 for (kk in seq_along(NAMES)) {
[13:17:28.677]                   name <- removed[[kk]]
[13:17:28.677]                   NAME <- NAMES[[kk]]
[13:17:28.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.677]                     next
[13:17:28.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.677]                 }
[13:17:28.677]                 if (length(args) > 0) 
[13:17:28.677]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.677]             }
[13:17:28.677]             else {
[13:17:28.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.677]             }
[13:17:28.677]             {
[13:17:28.677]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.677]                   0L) {
[13:17:28.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.677]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.677]                   base::options(opts)
[13:17:28.677]                 }
[13:17:28.677]                 {
[13:17:28.677]                   {
[13:17:28.677]                     NULL
[13:17:28.677]                     RNGkind("Mersenne-Twister")
[13:17:28.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.677]                       inherits = FALSE)
[13:17:28.677]                   }
[13:17:28.677]                   options(future.plan = NULL)
[13:17:28.677]                   if (is.na(NA_character_)) 
[13:17:28.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.677]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:28.677]                   {
[13:17:28.677]                     future <- SequentialFuture(..., envir = envir)
[13:17:28.677]                     if (!future$lazy) 
[13:17:28.677]                       future <- run(future)
[13:17:28.677]                     invisible(future)
[13:17:28.677]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.677]                 }
[13:17:28.677]             }
[13:17:28.677]         }
[13:17:28.677]     })
[13:17:28.677]     if (TRUE) {
[13:17:28.677]         base::sink(type = "output", split = FALSE)
[13:17:28.677]         if (TRUE) {
[13:17:28.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.677]         }
[13:17:28.677]         else {
[13:17:28.677]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.677]         }
[13:17:28.677]         base::close(...future.stdout)
[13:17:28.677]         ...future.stdout <- NULL
[13:17:28.677]     }
[13:17:28.677]     ...future.result$conditions <- ...future.conditions
[13:17:28.677]     ...future.result$finished <- base::Sys.time()
[13:17:28.677]     ...future.result
[13:17:28.677] }
[13:17:28.679] assign_globals() ...
[13:17:28.679] List of 5
[13:17:28.679]  $ ...future.FUN            :function (x, ...)  
[13:17:28.679]  $ future.call.arguments    :List of 1
[13:17:28.679]   ..$ singular.ok: logi FALSE
[13:17:28.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.679]  $ ...future.elements_ii    :List of 3
[13:17:28.679]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.679]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.679]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.679]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.679]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.679]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.679]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.679]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:28.679]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.679]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.679]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.679]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:28.679]  $ ...future.seeds_ii       : NULL
[13:17:28.679]  $ ...future.globals.maxSize: NULL
[13:17:28.679]  - attr(*, "resolved")= logi FALSE
[13:17:28.679]  - attr(*, "total_size")= num 5384
[13:17:28.679]  - attr(*, "where")=List of 5
[13:17:28.679]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.679]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.679]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.679]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.679]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.679]  - attr(*, "already-done")= logi TRUE
[13:17:28.688] - reassign environment for ‘...future.FUN’
[13:17:28.688] - copied ‘...future.FUN’ to environment
[13:17:28.688] - copied ‘future.call.arguments’ to environment
[13:17:28.688] - copied ‘...future.elements_ii’ to environment
[13:17:28.688] - copied ‘...future.seeds_ii’ to environment
[13:17:28.688] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.688] assign_globals() ... done
[13:17:28.689] plan(): Setting new future strategy stack:
[13:17:28.689] List of future strategies:
[13:17:28.689] 1. sequential:
[13:17:28.689]    - args: function (..., envir = parent.frame())
[13:17:28.689]    - tweaked: FALSE
[13:17:28.689]    - call: NULL
[13:17:28.689] plan(): nbrOfWorkers() = 1
[13:17:28.692] plan(): Setting new future strategy stack:
[13:17:28.692] List of future strategies:
[13:17:28.692] 1. sequential:
[13:17:28.692]    - args: function (..., envir = parent.frame())
[13:17:28.692]    - tweaked: FALSE
[13:17:28.692]    - call: plan(strategy)
[13:17:28.692] plan(): nbrOfWorkers() = 1
[13:17:28.693] SequentialFuture started (and completed)
[13:17:28.693] - Launch lazy future ... done
[13:17:28.693] run() for ‘SequentialFuture’ ... done
[13:17:28.693] Created future:
[13:17:28.693] SequentialFuture:
[13:17:28.693] Label: ‘future_by-1’
[13:17:28.693] Expression:
[13:17:28.693] {
[13:17:28.693]     do.call(function(...) {
[13:17:28.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.693]             on.exit(options(oopts), add = TRUE)
[13:17:28.693]         }
[13:17:28.693]         {
[13:17:28.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.693]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.693]             })
[13:17:28.693]         }
[13:17:28.693]     }, args = future.call.arguments)
[13:17:28.693] }
[13:17:28.693] Lazy evaluation: FALSE
[13:17:28.693] Asynchronous evaluation: FALSE
[13:17:28.693] Local evaluation: TRUE
[13:17:28.693] Environment: R_GlobalEnv
[13:17:28.693] Capture standard output: TRUE
[13:17:28.693] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.693] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.693] Packages: 1 packages (‘stats’)
[13:17:28.693] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.693] Resolved: TRUE
[13:17:28.693] Value: 26.06 KiB of class ‘list’
[13:17:28.693] Early signaling: FALSE
[13:17:28.693] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.693] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.696] Chunk #1 of 1 ... DONE
[13:17:28.696] Launching 1 futures (chunks) ... DONE
[13:17:28.696] Resolving 1 futures (chunks) ...
[13:17:28.697] resolve() on list ...
[13:17:28.697]  recursive: 0
[13:17:28.697]  length: 1
[13:17:28.697] 
[13:17:28.697] resolved() for ‘SequentialFuture’ ...
[13:17:28.697] - state: ‘finished’
[13:17:28.697] - run: TRUE
[13:17:28.697] - result: ‘FutureResult’
[13:17:28.697] resolved() for ‘SequentialFuture’ ... done
[13:17:28.697] Future #1
[13:17:28.698] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.698] - nx: 1
[13:17:28.698] - relay: TRUE
[13:17:28.698] - stdout: TRUE
[13:17:28.698] - signal: TRUE
[13:17:28.698] - resignal: FALSE
[13:17:28.698] - force: TRUE
[13:17:28.698] - relayed: [n=1] FALSE
[13:17:28.698] - queued futures: [n=1] FALSE
[13:17:28.698]  - until=1
[13:17:28.698]  - relaying element #1
[13:17:28.699] - relayed: [n=1] TRUE
[13:17:28.699] - queued futures: [n=1] TRUE
[13:17:28.699] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.699]  length: 0 (resolved future 1)
[13:17:28.699] Relaying remaining futures
[13:17:28.699] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.699] - nx: 1
[13:17:28.699] - relay: TRUE
[13:17:28.699] - stdout: TRUE
[13:17:28.699] - signal: TRUE
[13:17:28.699] - resignal: FALSE
[13:17:28.700] - force: TRUE
[13:17:28.700] - relayed: [n=1] TRUE
[13:17:28.700] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.700] - relayed: [n=1] TRUE
[13:17:28.700] - queued futures: [n=1] TRUE
[13:17:28.700] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.700] resolve() on list ... DONE
[13:17:28.700]  - Number of value chunks collected: 1
[13:17:28.700] Resolving 1 futures (chunks) ... DONE
[13:17:28.700] Reducing values from 1 chunks ...
[13:17:28.701]  - Number of values collected after concatenation: 3
[13:17:28.701]  - Number of values expected: 3
[13:17:28.701] Reducing values from 1 chunks ... DONE
[13:17:28.701] future_lapply() ... DONE
[13:17:28.701] future_by_internal() ... DONE
[13:17:28.705] future_by_internal() ...
[13:17:28.705] future_lapply() ...
[13:17:28.706] Number of chunks: 1
[13:17:28.706] getGlobalsAndPackagesXApply() ...
[13:17:28.707]  - future.globals: TRUE
[13:17:28.707] getGlobalsAndPackages() ...
[13:17:28.707] Searching for globals...
[13:17:28.708] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:28.708] Searching for globals ... DONE
[13:17:28.709] Resolving globals: FALSE
[13:17:28.709] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:17:28.709] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:17:28.710] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:28.710] - packages: [1] ‘stats’
[13:17:28.710] getGlobalsAndPackages() ... DONE
[13:17:28.710]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:28.710]  - needed namespaces: [n=1] ‘stats’
[13:17:28.710] Finding globals ... DONE
[13:17:28.710]  - use_args: TRUE
[13:17:28.710]  - Getting '...' globals ...
[13:17:28.711] resolve() on list ...
[13:17:28.711]  recursive: 0
[13:17:28.711]  length: 1
[13:17:28.711]  elements: ‘...’
[13:17:28.711]  length: 0 (resolved future 1)
[13:17:28.711] resolve() on list ... DONE
[13:17:28.711]    - '...' content: [n=0] 
[13:17:28.711] List of 1
[13:17:28.711]  $ ...: list()
[13:17:28.711]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.711]  - attr(*, "where")=List of 1
[13:17:28.711]   ..$ ...:<environment: 0x5609ea54ff00> 
[13:17:28.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.711]  - attr(*, "resolved")= logi TRUE
[13:17:28.711]  - attr(*, "total_size")= num NA
[13:17:28.715]  - Getting '...' globals ... DONE
[13:17:28.715] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:17:28.716] List of 4
[13:17:28.716]  $ ...future.FUN:function (x)  
[13:17:28.716]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:28.716]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.716]  $ ...          : list()
[13:17:28.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.716]  - attr(*, "where")=List of 4
[13:17:28.716]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.716]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:17:28.716]   ..$ wool         :<environment: R_EmptyEnv> 
[13:17:28.716]   ..$ ...          :<environment: 0x5609ea54ff00> 
[13:17:28.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.716]  - attr(*, "resolved")= logi FALSE
[13:17:28.716]  - attr(*, "total_size")= num 2320
[13:17:28.719] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:28.720] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.720] Number of futures (= number of chunks): 1
[13:17:28.720] Launching 1 futures (chunks) ...
[13:17:28.720] Chunk #1 of 1 ...
[13:17:28.720]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.720] getGlobalsAndPackages() ...
[13:17:28.720] Searching for globals...
[13:17:28.721] 
[13:17:28.721] Searching for globals ... DONE
[13:17:28.721] - globals: [0] <none>
[13:17:28.721] getGlobalsAndPackages() ... DONE
[13:17:28.721]    + additional globals found: [n=0] 
[13:17:28.721]    + additional namespaces needed: [n=0] 
[13:17:28.721]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.722]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.722]  - seeds: <none>
[13:17:28.722] getGlobalsAndPackages() ...
[13:17:28.722] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.722] Resolving globals: FALSE
[13:17:28.722] Tweak future expression to call with '...' arguments ...
[13:17:28.722] {
[13:17:28.722]     do.call(function(...) {
[13:17:28.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.722]             on.exit(options(oopts), add = TRUE)
[13:17:28.722]         }
[13:17:28.722]         {
[13:17:28.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.722]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.722]             })
[13:17:28.722]         }
[13:17:28.722]     }, args = future.call.arguments)
[13:17:28.722] }
[13:17:28.722] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.723] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.723] 
[13:17:28.723] getGlobalsAndPackages() ... DONE
[13:17:28.723] run() for ‘Future’ ...
[13:17:28.723] - state: ‘created’
[13:17:28.724] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:28.724] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.724] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.724]   - Field: ‘label’
[13:17:28.724]   - Field: ‘local’
[13:17:28.724]   - Field: ‘owner’
[13:17:28.724]   - Field: ‘envir’
[13:17:28.724]   - Field: ‘packages’
[13:17:28.724]   - Field: ‘gc’
[13:17:28.725]   - Field: ‘conditions’
[13:17:28.725]   - Field: ‘expr’
[13:17:28.725]   - Field: ‘uuid’
[13:17:28.725]   - Field: ‘seed’
[13:17:28.725]   - Field: ‘version’
[13:17:28.725]   - Field: ‘result’
[13:17:28.725]   - Field: ‘asynchronous’
[13:17:28.725]   - Field: ‘calls’
[13:17:28.725]   - Field: ‘globals’
[13:17:28.725]   - Field: ‘stdout’
[13:17:28.726]   - Field: ‘earlySignal’
[13:17:28.726]   - Field: ‘lazy’
[13:17:28.726]   - Field: ‘state’
[13:17:28.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.726] - Launch lazy future ...
[13:17:28.726] Packages needed by the future expression (n = 1): ‘stats’
[13:17:28.726] Packages needed by future strategies (n = 0): <none>
[13:17:28.727] {
[13:17:28.727]     {
[13:17:28.727]         {
[13:17:28.727]             ...future.startTime <- base::Sys.time()
[13:17:28.727]             {
[13:17:28.727]                 {
[13:17:28.727]                   {
[13:17:28.727]                     {
[13:17:28.727]                       base::local({
[13:17:28.727]                         has_future <- base::requireNamespace("future", 
[13:17:28.727]                           quietly = TRUE)
[13:17:28.727]                         if (has_future) {
[13:17:28.727]                           ns <- base::getNamespace("future")
[13:17:28.727]                           version <- ns[[".package"]][["version"]]
[13:17:28.727]                           if (is.null(version)) 
[13:17:28.727]                             version <- utils::packageVersion("future")
[13:17:28.727]                         }
[13:17:28.727]                         else {
[13:17:28.727]                           version <- NULL
[13:17:28.727]                         }
[13:17:28.727]                         if (!has_future || version < "1.8.0") {
[13:17:28.727]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.727]                             "", base::R.version$version.string), 
[13:17:28.727]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:28.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.727]                               "release", "version")], collapse = " "), 
[13:17:28.727]                             hostname = base::Sys.info()[["nodename"]])
[13:17:28.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.727]                             info)
[13:17:28.727]                           info <- base::paste(info, collapse = "; ")
[13:17:28.727]                           if (!has_future) {
[13:17:28.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.727]                               info)
[13:17:28.727]                           }
[13:17:28.727]                           else {
[13:17:28.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.727]                               info, version)
[13:17:28.727]                           }
[13:17:28.727]                           base::stop(msg)
[13:17:28.727]                         }
[13:17:28.727]                       })
[13:17:28.727]                     }
[13:17:28.727]                     base::local({
[13:17:28.727]                       for (pkg in "stats") {
[13:17:28.727]                         base::loadNamespace(pkg)
[13:17:28.727]                         base::library(pkg, character.only = TRUE)
[13:17:28.727]                       }
[13:17:28.727]                     })
[13:17:28.727]                   }
[13:17:28.727]                   options(future.plan = NULL)
[13:17:28.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.727]                 }
[13:17:28.727]                 ...future.workdir <- getwd()
[13:17:28.727]             }
[13:17:28.727]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.727]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.727]         }
[13:17:28.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.727]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.727]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.727]             base::names(...future.oldOptions))
[13:17:28.727]     }
[13:17:28.727]     if (FALSE) {
[13:17:28.727]     }
[13:17:28.727]     else {
[13:17:28.727]         if (TRUE) {
[13:17:28.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.727]                 open = "w")
[13:17:28.727]         }
[13:17:28.727]         else {
[13:17:28.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.727]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.727]         }
[13:17:28.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.727]             base::sink(type = "output", split = FALSE)
[13:17:28.727]             base::close(...future.stdout)
[13:17:28.727]         }, add = TRUE)
[13:17:28.727]     }
[13:17:28.727]     ...future.frame <- base::sys.nframe()
[13:17:28.727]     ...future.conditions <- base::list()
[13:17:28.727]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.727]     if (FALSE) {
[13:17:28.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.727]     }
[13:17:28.727]     ...future.result <- base::tryCatch({
[13:17:28.727]         base::withCallingHandlers({
[13:17:28.727]             ...future.value <- base::withVisible(base::local({
[13:17:28.727]                 do.call(function(...) {
[13:17:28.727]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.727]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.727]                     ...future.globals.maxSize)) {
[13:17:28.727]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.727]                     on.exit(options(oopts), add = TRUE)
[13:17:28.727]                   }
[13:17:28.727]                   {
[13:17:28.727]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.727]                       FUN = function(jj) {
[13:17:28.727]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.727]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.727]                       })
[13:17:28.727]                   }
[13:17:28.727]                 }, args = future.call.arguments)
[13:17:28.727]             }))
[13:17:28.727]             future::FutureResult(value = ...future.value$value, 
[13:17:28.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.727]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.727]                     ...future.globalenv.names))
[13:17:28.727]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.727]         }, condition = base::local({
[13:17:28.727]             c <- base::c
[13:17:28.727]             inherits <- base::inherits
[13:17:28.727]             invokeRestart <- base::invokeRestart
[13:17:28.727]             length <- base::length
[13:17:28.727]             list <- base::list
[13:17:28.727]             seq.int <- base::seq.int
[13:17:28.727]             signalCondition <- base::signalCondition
[13:17:28.727]             sys.calls <- base::sys.calls
[13:17:28.727]             `[[` <- base::`[[`
[13:17:28.727]             `+` <- base::`+`
[13:17:28.727]             `<<-` <- base::`<<-`
[13:17:28.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.727]                   3L)]
[13:17:28.727]             }
[13:17:28.727]             function(cond) {
[13:17:28.727]                 is_error <- inherits(cond, "error")
[13:17:28.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.727]                   NULL)
[13:17:28.727]                 if (is_error) {
[13:17:28.727]                   sessionInformation <- function() {
[13:17:28.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.727]                       search = base::search(), system = base::Sys.info())
[13:17:28.727]                   }
[13:17:28.727]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.727]                     cond$call), session = sessionInformation(), 
[13:17:28.727]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.727]                   signalCondition(cond)
[13:17:28.727]                 }
[13:17:28.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.727]                 "immediateCondition"))) {
[13:17:28.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.727]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.727]                   if (TRUE && !signal) {
[13:17:28.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.727]                     {
[13:17:28.727]                       inherits <- base::inherits
[13:17:28.727]                       invokeRestart <- base::invokeRestart
[13:17:28.727]                       is.null <- base::is.null
[13:17:28.727]                       muffled <- FALSE
[13:17:28.727]                       if (inherits(cond, "message")) {
[13:17:28.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.727]                         if (muffled) 
[13:17:28.727]                           invokeRestart("muffleMessage")
[13:17:28.727]                       }
[13:17:28.727]                       else if (inherits(cond, "warning")) {
[13:17:28.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.727]                         if (muffled) 
[13:17:28.727]                           invokeRestart("muffleWarning")
[13:17:28.727]                       }
[13:17:28.727]                       else if (inherits(cond, "condition")) {
[13:17:28.727]                         if (!is.null(pattern)) {
[13:17:28.727]                           computeRestarts <- base::computeRestarts
[13:17:28.727]                           grepl <- base::grepl
[13:17:28.727]                           restarts <- computeRestarts(cond)
[13:17:28.727]                           for (restart in restarts) {
[13:17:28.727]                             name <- restart$name
[13:17:28.727]                             if (is.null(name)) 
[13:17:28.727]                               next
[13:17:28.727]                             if (!grepl(pattern, name)) 
[13:17:28.727]                               next
[13:17:28.727]                             invokeRestart(restart)
[13:17:28.727]                             muffled <- TRUE
[13:17:28.727]                             break
[13:17:28.727]                           }
[13:17:28.727]                         }
[13:17:28.727]                       }
[13:17:28.727]                       invisible(muffled)
[13:17:28.727]                     }
[13:17:28.727]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.727]                   }
[13:17:28.727]                 }
[13:17:28.727]                 else {
[13:17:28.727]                   if (TRUE) {
[13:17:28.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.727]                     {
[13:17:28.727]                       inherits <- base::inherits
[13:17:28.727]                       invokeRestart <- base::invokeRestart
[13:17:28.727]                       is.null <- base::is.null
[13:17:28.727]                       muffled <- FALSE
[13:17:28.727]                       if (inherits(cond, "message")) {
[13:17:28.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.727]                         if (muffled) 
[13:17:28.727]                           invokeRestart("muffleMessage")
[13:17:28.727]                       }
[13:17:28.727]                       else if (inherits(cond, "warning")) {
[13:17:28.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.727]                         if (muffled) 
[13:17:28.727]                           invokeRestart("muffleWarning")
[13:17:28.727]                       }
[13:17:28.727]                       else if (inherits(cond, "condition")) {
[13:17:28.727]                         if (!is.null(pattern)) {
[13:17:28.727]                           computeRestarts <- base::computeRestarts
[13:17:28.727]                           grepl <- base::grepl
[13:17:28.727]                           restarts <- computeRestarts(cond)
[13:17:28.727]                           for (restart in restarts) {
[13:17:28.727]                             name <- restart$name
[13:17:28.727]                             if (is.null(name)) 
[13:17:28.727]                               next
[13:17:28.727]                             if (!grepl(pattern, name)) 
[13:17:28.727]                               next
[13:17:28.727]                             invokeRestart(restart)
[13:17:28.727]                             muffled <- TRUE
[13:17:28.727]                             break
[13:17:28.727]                           }
[13:17:28.727]                         }
[13:17:28.727]                       }
[13:17:28.727]                       invisible(muffled)
[13:17:28.727]                     }
[13:17:28.727]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.727]                   }
[13:17:28.727]                 }
[13:17:28.727]             }
[13:17:28.727]         }))
[13:17:28.727]     }, error = function(ex) {
[13:17:28.727]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.727]                 ...future.rng), started = ...future.startTime, 
[13:17:28.727]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.727]             version = "1.8"), class = "FutureResult")
[13:17:28.727]     }, finally = {
[13:17:28.727]         if (!identical(...future.workdir, getwd())) 
[13:17:28.727]             setwd(...future.workdir)
[13:17:28.727]         {
[13:17:28.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.727]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.727]             }
[13:17:28.727]             base::options(...future.oldOptions)
[13:17:28.727]             if (.Platform$OS.type == "windows") {
[13:17:28.727]                 old_names <- names(...future.oldEnvVars)
[13:17:28.727]                 envs <- base::Sys.getenv()
[13:17:28.727]                 names <- names(envs)
[13:17:28.727]                 common <- intersect(names, old_names)
[13:17:28.727]                 added <- setdiff(names, old_names)
[13:17:28.727]                 removed <- setdiff(old_names, names)
[13:17:28.727]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.727]                   envs[common]]
[13:17:28.727]                 NAMES <- toupper(changed)
[13:17:28.727]                 args <- list()
[13:17:28.727]                 for (kk in seq_along(NAMES)) {
[13:17:28.727]                   name <- changed[[kk]]
[13:17:28.727]                   NAME <- NAMES[[kk]]
[13:17:28.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.727]                     next
[13:17:28.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.727]                 }
[13:17:28.727]                 NAMES <- toupper(added)
[13:17:28.727]                 for (kk in seq_along(NAMES)) {
[13:17:28.727]                   name <- added[[kk]]
[13:17:28.727]                   NAME <- NAMES[[kk]]
[13:17:28.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.727]                     next
[13:17:28.727]                   args[[name]] <- ""
[13:17:28.727]                 }
[13:17:28.727]                 NAMES <- toupper(removed)
[13:17:28.727]                 for (kk in seq_along(NAMES)) {
[13:17:28.727]                   name <- removed[[kk]]
[13:17:28.727]                   NAME <- NAMES[[kk]]
[13:17:28.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.727]                     next
[13:17:28.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.727]                 }
[13:17:28.727]                 if (length(args) > 0) 
[13:17:28.727]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.727]             }
[13:17:28.727]             else {
[13:17:28.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.727]             }
[13:17:28.727]             {
[13:17:28.727]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.727]                   0L) {
[13:17:28.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.727]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.727]                   base::options(opts)
[13:17:28.727]                 }
[13:17:28.727]                 {
[13:17:28.727]                   {
[13:17:28.727]                     NULL
[13:17:28.727]                     RNGkind("Mersenne-Twister")
[13:17:28.727]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.727]                       inherits = FALSE)
[13:17:28.727]                   }
[13:17:28.727]                   options(future.plan = NULL)
[13:17:28.727]                   if (is.na(NA_character_)) 
[13:17:28.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.727]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:28.727]                   {
[13:17:28.727]                     future <- SequentialFuture(..., envir = envir)
[13:17:28.727]                     if (!future$lazy) 
[13:17:28.727]                       future <- run(future)
[13:17:28.727]                     invisible(future)
[13:17:28.727]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.727]                 }
[13:17:28.727]             }
[13:17:28.727]         }
[13:17:28.727]     })
[13:17:28.727]     if (TRUE) {
[13:17:28.727]         base::sink(type = "output", split = FALSE)
[13:17:28.727]         if (TRUE) {
[13:17:28.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.727]         }
[13:17:28.727]         else {
[13:17:28.727]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.727]         }
[13:17:28.727]         base::close(...future.stdout)
[13:17:28.727]         ...future.stdout <- NULL
[13:17:28.727]     }
[13:17:28.727]     ...future.result$conditions <- ...future.conditions
[13:17:28.727]     ...future.result$finished <- base::Sys.time()
[13:17:28.727]     ...future.result
[13:17:28.727] }
[13:17:28.728] assign_globals() ...
[13:17:28.729] List of 7
[13:17:28.729]  $ ...future.FUN            :function (x)  
[13:17:28.729]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:28.729]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.729]  $ future.call.arguments    : list()
[13:17:28.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.729]  $ ...future.elements_ii    :List of 3
[13:17:28.729]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.729]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.729]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.729]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.729]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.729]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.729]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.729]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:28.729]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.729]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.729]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.729]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:28.729]  $ ...future.seeds_ii       : NULL
[13:17:28.729]  $ ...future.globals.maxSize: NULL
[13:17:28.729]  - attr(*, "resolved")= logi FALSE
[13:17:28.729]  - attr(*, "total_size")= num 2320
[13:17:28.729]  - attr(*, "where")=List of 7
[13:17:28.729]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.729]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:17:28.729]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:17:28.729]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.729]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.729]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.729]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.729]  - attr(*, "already-done")= logi TRUE
[13:17:28.740] - reassign environment for ‘...future.FUN’
[13:17:28.740] - copied ‘...future.FUN’ to environment
[13:17:28.740] - copied ‘breaks’ to environment
[13:17:28.740] - copied ‘wool’ to environment
[13:17:28.740] - copied ‘future.call.arguments’ to environment
[13:17:28.740] - copied ‘...future.elements_ii’ to environment
[13:17:28.740] - copied ‘...future.seeds_ii’ to environment
[13:17:28.740] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.740] assign_globals() ... done
[13:17:28.741] plan(): Setting new future strategy stack:
[13:17:28.741] List of future strategies:
[13:17:28.741] 1. sequential:
[13:17:28.741]    - args: function (..., envir = parent.frame())
[13:17:28.741]    - tweaked: FALSE
[13:17:28.741]    - call: NULL
[13:17:28.741] plan(): nbrOfWorkers() = 1
[13:17:28.744] plan(): Setting new future strategy stack:
[13:17:28.744] List of future strategies:
[13:17:28.744] 1. sequential:
[13:17:28.744]    - args: function (..., envir = parent.frame())
[13:17:28.744]    - tweaked: FALSE
[13:17:28.744]    - call: plan(strategy)
[13:17:28.744] plan(): nbrOfWorkers() = 1
[13:17:28.745] SequentialFuture started (and completed)
[13:17:28.745] - Launch lazy future ... done
[13:17:28.745] run() for ‘SequentialFuture’ ... done
[13:17:28.745] Created future:
[13:17:28.745] SequentialFuture:
[13:17:28.745] Label: ‘future_by-1’
[13:17:28.745] Expression:
[13:17:28.745] {
[13:17:28.745]     do.call(function(...) {
[13:17:28.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.745]             on.exit(options(oopts), add = TRUE)
[13:17:28.745]         }
[13:17:28.745]         {
[13:17:28.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.745]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.745]             })
[13:17:28.745]         }
[13:17:28.745]     }, args = future.call.arguments)
[13:17:28.745] }
[13:17:28.745] Lazy evaluation: FALSE
[13:17:28.745] Asynchronous evaluation: FALSE
[13:17:28.745] Local evaluation: TRUE
[13:17:28.745] Environment: 0x5609ea4ee988
[13:17:28.745] Capture standard output: TRUE
[13:17:28.745] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.745] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:17:28.745] Packages: 1 packages (‘stats’)
[13:17:28.745] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.745] Resolved: TRUE
[13:17:28.745] Value: 25.57 KiB of class ‘list’
[13:17:28.745] Early signaling: FALSE
[13:17:28.745] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.745] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.747] Chunk #1 of 1 ... DONE
[13:17:28.747] Launching 1 futures (chunks) ... DONE
[13:17:28.747] Resolving 1 futures (chunks) ...
[13:17:28.747] resolve() on list ...
[13:17:28.747]  recursive: 0
[13:17:28.747]  length: 1
[13:17:28.747] 
[13:17:28.747] resolved() for ‘SequentialFuture’ ...
[13:17:28.747] - state: ‘finished’
[13:17:28.747] - run: TRUE
[13:17:28.747] - result: ‘FutureResult’
[13:17:28.748] resolved() for ‘SequentialFuture’ ... done
[13:17:28.748] Future #1
[13:17:28.748] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.748] - nx: 1
[13:17:28.748] - relay: TRUE
[13:17:28.748] - stdout: TRUE
[13:17:28.748] - signal: TRUE
[13:17:28.748] - resignal: FALSE
[13:17:28.748] - force: TRUE
[13:17:28.748] - relayed: [n=1] FALSE
[13:17:28.748] - queued futures: [n=1] FALSE
[13:17:28.749]  - until=1
[13:17:28.749]  - relaying element #1
[13:17:28.749] - relayed: [n=1] TRUE
[13:17:28.749] - queued futures: [n=1] TRUE
[13:17:28.749] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.749]  length: 0 (resolved future 1)
[13:17:28.749] Relaying remaining futures
[13:17:28.749] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.749] - nx: 1
[13:17:28.749] - relay: TRUE
[13:17:28.750] - stdout: TRUE
[13:17:28.750] - signal: TRUE
[13:17:28.750] - resignal: FALSE
[13:17:28.750] - force: TRUE
[13:17:28.750] - relayed: [n=1] TRUE
[13:17:28.750] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.750] - relayed: [n=1] TRUE
[13:17:28.750] - queued futures: [n=1] TRUE
[13:17:28.750] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.750] resolve() on list ... DONE
[13:17:28.751]  - Number of value chunks collected: 1
[13:17:28.751] Resolving 1 futures (chunks) ... DONE
[13:17:28.751] Reducing values from 1 chunks ...
[13:17:28.751]  - Number of values collected after concatenation: 3
[13:17:28.751]  - Number of values expected: 3
[13:17:28.751] Reducing values from 1 chunks ... DONE
[13:17:28.751] future_lapply() ... DONE
[13:17:28.751] future_by_internal() ... DONE
[13:17:28.752] future_by_internal() ...
[13:17:28.752] future_lapply() ...
[13:17:28.752] Number of chunks: 1
[13:17:28.752] getGlobalsAndPackagesXApply() ...
[13:17:28.753]  - future.globals: TRUE
[13:17:28.753] getGlobalsAndPackages() ...
[13:17:28.753] Searching for globals...
[13:17:28.754] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:28.754] Searching for globals ... DONE
[13:17:28.754] Resolving globals: FALSE
[13:17:28.754] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:28.755] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:28.755] - globals: [1] ‘FUN’
[13:17:28.755] 
[13:17:28.755] getGlobalsAndPackages() ... DONE
[13:17:28.755]  - globals found/used: [n=1] ‘FUN’
[13:17:28.756]  - needed namespaces: [n=0] 
[13:17:28.757] Finding globals ... DONE
[13:17:28.757]  - use_args: TRUE
[13:17:28.757]  - Getting '...' globals ...
[13:17:28.757] resolve() on list ...
[13:17:28.757]  recursive: 0
[13:17:28.757]  length: 1
[13:17:28.757]  elements: ‘...’
[13:17:28.757]  length: 0 (resolved future 1)
[13:17:28.758] resolve() on list ... DONE
[13:17:28.758]    - '...' content: [n=0] 
[13:17:28.758] List of 1
[13:17:28.758]  $ ...: list()
[13:17:28.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.758]  - attr(*, "where")=List of 1
[13:17:28.758]   ..$ ...:<environment: 0x5609eab28498> 
[13:17:28.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.758]  - attr(*, "resolved")= logi TRUE
[13:17:28.758]  - attr(*, "total_size")= num NA
[13:17:28.760]  - Getting '...' globals ... DONE
[13:17:28.760] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.760] List of 2
[13:17:28.760]  $ ...future.FUN:function (object, ...)  
[13:17:28.760]  $ ...          : list()
[13:17:28.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.760]  - attr(*, "where")=List of 2
[13:17:28.760]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.760]   ..$ ...          :<environment: 0x5609eab28498> 
[13:17:28.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.760]  - attr(*, "resolved")= logi FALSE
[13:17:28.760]  - attr(*, "total_size")= num 1240
[13:17:28.763] Packages to be attached in all futures: [n=0] 
[13:17:28.763] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.763] Number of futures (= number of chunks): 1
[13:17:28.763] Launching 1 futures (chunks) ...
[13:17:28.764] Chunk #1 of 1 ...
[13:17:28.764]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.764] getGlobalsAndPackages() ...
[13:17:28.764] Searching for globals...
[13:17:28.764] 
[13:17:28.764] Searching for globals ... DONE
[13:17:28.765] - globals: [0] <none>
[13:17:28.765] getGlobalsAndPackages() ... DONE
[13:17:28.765]    + additional globals found: [n=0] 
[13:17:28.765]    + additional namespaces needed: [n=0] 
[13:17:28.765]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.765]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.765]  - seeds: <none>
[13:17:28.765] getGlobalsAndPackages() ...
[13:17:28.765] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.765] Resolving globals: FALSE
[13:17:28.766] Tweak future expression to call with '...' arguments ...
[13:17:28.766] {
[13:17:28.766]     do.call(function(...) {
[13:17:28.766]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.766]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.766]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.766]             on.exit(options(oopts), add = TRUE)
[13:17:28.766]         }
[13:17:28.766]         {
[13:17:28.766]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.766]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.766]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.766]             })
[13:17:28.766]         }
[13:17:28.766]     }, args = future.call.arguments)
[13:17:28.766] }
[13:17:28.766] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.766] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.766] 
[13:17:28.766] getGlobalsAndPackages() ... DONE
[13:17:28.767] run() for ‘Future’ ...
[13:17:28.767] - state: ‘created’
[13:17:28.767] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:28.767] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.767]   - Field: ‘label’
[13:17:28.768]   - Field: ‘local’
[13:17:28.768]   - Field: ‘owner’
[13:17:28.768]   - Field: ‘envir’
[13:17:28.768]   - Field: ‘packages’
[13:17:28.768]   - Field: ‘gc’
[13:17:28.768]   - Field: ‘conditions’
[13:17:28.768]   - Field: ‘expr’
[13:17:28.768]   - Field: ‘uuid’
[13:17:28.768]   - Field: ‘seed’
[13:17:28.768]   - Field: ‘version’
[13:17:28.768]   - Field: ‘result’
[13:17:28.769]   - Field: ‘asynchronous’
[13:17:28.769]   - Field: ‘calls’
[13:17:28.769]   - Field: ‘globals’
[13:17:28.769]   - Field: ‘stdout’
[13:17:28.769]   - Field: ‘earlySignal’
[13:17:28.769]   - Field: ‘lazy’
[13:17:28.769]   - Field: ‘state’
[13:17:28.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.769] - Launch lazy future ...
[13:17:28.770] Packages needed by the future expression (n = 0): <none>
[13:17:28.770] Packages needed by future strategies (n = 0): <none>
[13:17:28.770] {
[13:17:28.770]     {
[13:17:28.770]         {
[13:17:28.770]             ...future.startTime <- base::Sys.time()
[13:17:28.770]             {
[13:17:28.770]                 {
[13:17:28.770]                   {
[13:17:28.770]                     base::local({
[13:17:28.770]                       has_future <- base::requireNamespace("future", 
[13:17:28.770]                         quietly = TRUE)
[13:17:28.770]                       if (has_future) {
[13:17:28.770]                         ns <- base::getNamespace("future")
[13:17:28.770]                         version <- ns[[".package"]][["version"]]
[13:17:28.770]                         if (is.null(version)) 
[13:17:28.770]                           version <- utils::packageVersion("future")
[13:17:28.770]                       }
[13:17:28.770]                       else {
[13:17:28.770]                         version <- NULL
[13:17:28.770]                       }
[13:17:28.770]                       if (!has_future || version < "1.8.0") {
[13:17:28.770]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.770]                           "", base::R.version$version.string), 
[13:17:28.770]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:28.770]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.770]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.770]                             "release", "version")], collapse = " "), 
[13:17:28.770]                           hostname = base::Sys.info()[["nodename"]])
[13:17:28.770]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.770]                           info)
[13:17:28.770]                         info <- base::paste(info, collapse = "; ")
[13:17:28.770]                         if (!has_future) {
[13:17:28.770]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.770]                             info)
[13:17:28.770]                         }
[13:17:28.770]                         else {
[13:17:28.770]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.770]                             info, version)
[13:17:28.770]                         }
[13:17:28.770]                         base::stop(msg)
[13:17:28.770]                       }
[13:17:28.770]                     })
[13:17:28.770]                   }
[13:17:28.770]                   options(future.plan = NULL)
[13:17:28.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.770]                 }
[13:17:28.770]                 ...future.workdir <- getwd()
[13:17:28.770]             }
[13:17:28.770]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.770]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.770]         }
[13:17:28.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.770]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.770]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.770]             base::names(...future.oldOptions))
[13:17:28.770]     }
[13:17:28.770]     if (FALSE) {
[13:17:28.770]     }
[13:17:28.770]     else {
[13:17:28.770]         if (TRUE) {
[13:17:28.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.770]                 open = "w")
[13:17:28.770]         }
[13:17:28.770]         else {
[13:17:28.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.770]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.770]         }
[13:17:28.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.770]             base::sink(type = "output", split = FALSE)
[13:17:28.770]             base::close(...future.stdout)
[13:17:28.770]         }, add = TRUE)
[13:17:28.770]     }
[13:17:28.770]     ...future.frame <- base::sys.nframe()
[13:17:28.770]     ...future.conditions <- base::list()
[13:17:28.770]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.770]     if (FALSE) {
[13:17:28.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.770]     }
[13:17:28.770]     ...future.result <- base::tryCatch({
[13:17:28.770]         base::withCallingHandlers({
[13:17:28.770]             ...future.value <- base::withVisible(base::local({
[13:17:28.770]                 do.call(function(...) {
[13:17:28.770]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.770]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.770]                     ...future.globals.maxSize)) {
[13:17:28.770]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.770]                     on.exit(options(oopts), add = TRUE)
[13:17:28.770]                   }
[13:17:28.770]                   {
[13:17:28.770]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.770]                       FUN = function(jj) {
[13:17:28.770]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.770]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.770]                       })
[13:17:28.770]                   }
[13:17:28.770]                 }, args = future.call.arguments)
[13:17:28.770]             }))
[13:17:28.770]             future::FutureResult(value = ...future.value$value, 
[13:17:28.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.770]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.770]                     ...future.globalenv.names))
[13:17:28.770]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.770]         }, condition = base::local({
[13:17:28.770]             c <- base::c
[13:17:28.770]             inherits <- base::inherits
[13:17:28.770]             invokeRestart <- base::invokeRestart
[13:17:28.770]             length <- base::length
[13:17:28.770]             list <- base::list
[13:17:28.770]             seq.int <- base::seq.int
[13:17:28.770]             signalCondition <- base::signalCondition
[13:17:28.770]             sys.calls <- base::sys.calls
[13:17:28.770]             `[[` <- base::`[[`
[13:17:28.770]             `+` <- base::`+`
[13:17:28.770]             `<<-` <- base::`<<-`
[13:17:28.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.770]                   3L)]
[13:17:28.770]             }
[13:17:28.770]             function(cond) {
[13:17:28.770]                 is_error <- inherits(cond, "error")
[13:17:28.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.770]                   NULL)
[13:17:28.770]                 if (is_error) {
[13:17:28.770]                   sessionInformation <- function() {
[13:17:28.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.770]                       search = base::search(), system = base::Sys.info())
[13:17:28.770]                   }
[13:17:28.770]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.770]                     cond$call), session = sessionInformation(), 
[13:17:28.770]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.770]                   signalCondition(cond)
[13:17:28.770]                 }
[13:17:28.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.770]                 "immediateCondition"))) {
[13:17:28.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.770]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.770]                   if (TRUE && !signal) {
[13:17:28.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.770]                     {
[13:17:28.770]                       inherits <- base::inherits
[13:17:28.770]                       invokeRestart <- base::invokeRestart
[13:17:28.770]                       is.null <- base::is.null
[13:17:28.770]                       muffled <- FALSE
[13:17:28.770]                       if (inherits(cond, "message")) {
[13:17:28.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.770]                         if (muffled) 
[13:17:28.770]                           invokeRestart("muffleMessage")
[13:17:28.770]                       }
[13:17:28.770]                       else if (inherits(cond, "warning")) {
[13:17:28.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.770]                         if (muffled) 
[13:17:28.770]                           invokeRestart("muffleWarning")
[13:17:28.770]                       }
[13:17:28.770]                       else if (inherits(cond, "condition")) {
[13:17:28.770]                         if (!is.null(pattern)) {
[13:17:28.770]                           computeRestarts <- base::computeRestarts
[13:17:28.770]                           grepl <- base::grepl
[13:17:28.770]                           restarts <- computeRestarts(cond)
[13:17:28.770]                           for (restart in restarts) {
[13:17:28.770]                             name <- restart$name
[13:17:28.770]                             if (is.null(name)) 
[13:17:28.770]                               next
[13:17:28.770]                             if (!grepl(pattern, name)) 
[13:17:28.770]                               next
[13:17:28.770]                             invokeRestart(restart)
[13:17:28.770]                             muffled <- TRUE
[13:17:28.770]                             break
[13:17:28.770]                           }
[13:17:28.770]                         }
[13:17:28.770]                       }
[13:17:28.770]                       invisible(muffled)
[13:17:28.770]                     }
[13:17:28.770]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.770]                   }
[13:17:28.770]                 }
[13:17:28.770]                 else {
[13:17:28.770]                   if (TRUE) {
[13:17:28.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.770]                     {
[13:17:28.770]                       inherits <- base::inherits
[13:17:28.770]                       invokeRestart <- base::invokeRestart
[13:17:28.770]                       is.null <- base::is.null
[13:17:28.770]                       muffled <- FALSE
[13:17:28.770]                       if (inherits(cond, "message")) {
[13:17:28.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.770]                         if (muffled) 
[13:17:28.770]                           invokeRestart("muffleMessage")
[13:17:28.770]                       }
[13:17:28.770]                       else if (inherits(cond, "warning")) {
[13:17:28.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.770]                         if (muffled) 
[13:17:28.770]                           invokeRestart("muffleWarning")
[13:17:28.770]                       }
[13:17:28.770]                       else if (inherits(cond, "condition")) {
[13:17:28.770]                         if (!is.null(pattern)) {
[13:17:28.770]                           computeRestarts <- base::computeRestarts
[13:17:28.770]                           grepl <- base::grepl
[13:17:28.770]                           restarts <- computeRestarts(cond)
[13:17:28.770]                           for (restart in restarts) {
[13:17:28.770]                             name <- restart$name
[13:17:28.770]                             if (is.null(name)) 
[13:17:28.770]                               next
[13:17:28.770]                             if (!grepl(pattern, name)) 
[13:17:28.770]                               next
[13:17:28.770]                             invokeRestart(restart)
[13:17:28.770]                             muffled <- TRUE
[13:17:28.770]                             break
[13:17:28.770]                           }
[13:17:28.770]                         }
[13:17:28.770]                       }
[13:17:28.770]                       invisible(muffled)
[13:17:28.770]                     }
[13:17:28.770]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.770]                   }
[13:17:28.770]                 }
[13:17:28.770]             }
[13:17:28.770]         }))
[13:17:28.770]     }, error = function(ex) {
[13:17:28.770]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.770]                 ...future.rng), started = ...future.startTime, 
[13:17:28.770]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.770]             version = "1.8"), class = "FutureResult")
[13:17:28.770]     }, finally = {
[13:17:28.770]         if (!identical(...future.workdir, getwd())) 
[13:17:28.770]             setwd(...future.workdir)
[13:17:28.770]         {
[13:17:28.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.770]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.770]             }
[13:17:28.770]             base::options(...future.oldOptions)
[13:17:28.770]             if (.Platform$OS.type == "windows") {
[13:17:28.770]                 old_names <- names(...future.oldEnvVars)
[13:17:28.770]                 envs <- base::Sys.getenv()
[13:17:28.770]                 names <- names(envs)
[13:17:28.770]                 common <- intersect(names, old_names)
[13:17:28.770]                 added <- setdiff(names, old_names)
[13:17:28.770]                 removed <- setdiff(old_names, names)
[13:17:28.770]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.770]                   envs[common]]
[13:17:28.770]                 NAMES <- toupper(changed)
[13:17:28.770]                 args <- list()
[13:17:28.770]                 for (kk in seq_along(NAMES)) {
[13:17:28.770]                   name <- changed[[kk]]
[13:17:28.770]                   NAME <- NAMES[[kk]]
[13:17:28.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.770]                     next
[13:17:28.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.770]                 }
[13:17:28.770]                 NAMES <- toupper(added)
[13:17:28.770]                 for (kk in seq_along(NAMES)) {
[13:17:28.770]                   name <- added[[kk]]
[13:17:28.770]                   NAME <- NAMES[[kk]]
[13:17:28.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.770]                     next
[13:17:28.770]                   args[[name]] <- ""
[13:17:28.770]                 }
[13:17:28.770]                 NAMES <- toupper(removed)
[13:17:28.770]                 for (kk in seq_along(NAMES)) {
[13:17:28.770]                   name <- removed[[kk]]
[13:17:28.770]                   NAME <- NAMES[[kk]]
[13:17:28.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.770]                     next
[13:17:28.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.770]                 }
[13:17:28.770]                 if (length(args) > 0) 
[13:17:28.770]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.770]             }
[13:17:28.770]             else {
[13:17:28.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.770]             }
[13:17:28.770]             {
[13:17:28.770]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.770]                   0L) {
[13:17:28.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.770]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.770]                   base::options(opts)
[13:17:28.770]                 }
[13:17:28.770]                 {
[13:17:28.770]                   {
[13:17:28.770]                     NULL
[13:17:28.770]                     RNGkind("Mersenne-Twister")
[13:17:28.770]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.770]                       inherits = FALSE)
[13:17:28.770]                   }
[13:17:28.770]                   options(future.plan = NULL)
[13:17:28.770]                   if (is.na(NA_character_)) 
[13:17:28.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.770]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:28.770]                   {
[13:17:28.770]                     future <- SequentialFuture(..., envir = envir)
[13:17:28.770]                     if (!future$lazy) 
[13:17:28.770]                       future <- run(future)
[13:17:28.770]                     invisible(future)
[13:17:28.770]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.770]                 }
[13:17:28.770]             }
[13:17:28.770]         }
[13:17:28.770]     })
[13:17:28.770]     if (TRUE) {
[13:17:28.770]         base::sink(type = "output", split = FALSE)
[13:17:28.770]         if (TRUE) {
[13:17:28.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.770]         }
[13:17:28.770]         else {
[13:17:28.770]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.770]         }
[13:17:28.770]         base::close(...future.stdout)
[13:17:28.770]         ...future.stdout <- NULL
[13:17:28.770]     }
[13:17:28.770]     ...future.result$conditions <- ...future.conditions
[13:17:28.770]     ...future.result$finished <- base::Sys.time()
[13:17:28.770]     ...future.result
[13:17:28.770] }
[13:17:28.772] assign_globals() ...
[13:17:28.772] List of 5
[13:17:28.772]  $ ...future.FUN            :function (object, ...)  
[13:17:28.772]  $ future.call.arguments    : list()
[13:17:28.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.772]  $ ...future.elements_ii    :List of 3
[13:17:28.772]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.772]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.772]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.772]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.772]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.772]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.772]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.772]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:28.772]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.772]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.772]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.772]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:28.772]  $ ...future.seeds_ii       : NULL
[13:17:28.772]  $ ...future.globals.maxSize: NULL
[13:17:28.772]  - attr(*, "resolved")= logi FALSE
[13:17:28.772]  - attr(*, "total_size")= num 1240
[13:17:28.772]  - attr(*, "where")=List of 5
[13:17:28.772]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.772]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.772]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.772]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.772]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.772]  - attr(*, "already-done")= logi TRUE
[13:17:28.782] - copied ‘...future.FUN’ to environment
[13:17:28.782] - copied ‘future.call.arguments’ to environment
[13:17:28.782] - copied ‘...future.elements_ii’ to environment
[13:17:28.782] - copied ‘...future.seeds_ii’ to environment
[13:17:28.782] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.782] assign_globals() ... done
[13:17:28.783] plan(): Setting new future strategy stack:
[13:17:28.783] List of future strategies:
[13:17:28.783] 1. sequential:
[13:17:28.783]    - args: function (..., envir = parent.frame())
[13:17:28.783]    - tweaked: FALSE
[13:17:28.783]    - call: NULL
[13:17:28.783] plan(): nbrOfWorkers() = 1
[13:17:28.785] plan(): Setting new future strategy stack:
[13:17:28.785] List of future strategies:
[13:17:28.785] 1. sequential:
[13:17:28.785]    - args: function (..., envir = parent.frame())
[13:17:28.785]    - tweaked: FALSE
[13:17:28.785]    - call: plan(strategy)
[13:17:28.786] plan(): nbrOfWorkers() = 1
[13:17:28.786] SequentialFuture started (and completed)
[13:17:28.786] - Launch lazy future ... done
[13:17:28.786] run() for ‘SequentialFuture’ ... done
[13:17:28.786] Created future:
[13:17:28.786] SequentialFuture:
[13:17:28.786] Label: ‘future_by-1’
[13:17:28.786] Expression:
[13:17:28.786] {
[13:17:28.786]     do.call(function(...) {
[13:17:28.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.786]             on.exit(options(oopts), add = TRUE)
[13:17:28.786]         }
[13:17:28.786]         {
[13:17:28.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.786]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.786]             })
[13:17:28.786]         }
[13:17:28.786]     }, args = future.call.arguments)
[13:17:28.786] }
[13:17:28.786] Lazy evaluation: FALSE
[13:17:28.786] Asynchronous evaluation: FALSE
[13:17:28.786] Local evaluation: TRUE
[13:17:28.786] Environment: 0x5609eaac3500
[13:17:28.786] Capture standard output: TRUE
[13:17:28.786] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.786] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.786] Packages: <none>
[13:17:28.786] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.786] Resolved: TRUE
[13:17:28.786] Value: 5.37 KiB of class ‘list’
[13:17:28.786] Early signaling: FALSE
[13:17:28.786] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.786] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.788] Chunk #1 of 1 ... DONE
[13:17:28.788] Launching 1 futures (chunks) ... DONE
[13:17:28.788] Resolving 1 futures (chunks) ...
[13:17:28.788] resolve() on list ...
[13:17:28.788]  recursive: 0
[13:17:28.788]  length: 1
[13:17:28.788] 
[13:17:28.788] resolved() for ‘SequentialFuture’ ...
[13:17:28.788] - state: ‘finished’
[13:17:28.789] - run: TRUE
[13:17:28.789] - result: ‘FutureResult’
[13:17:28.789] resolved() for ‘SequentialFuture’ ... done
[13:17:28.789] Future #1
[13:17:28.789] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.789] - nx: 1
[13:17:28.789] - relay: TRUE
[13:17:28.789] - stdout: TRUE
[13:17:28.789] - signal: TRUE
[13:17:28.789] - resignal: FALSE
[13:17:28.790] - force: TRUE
[13:17:28.790] - relayed: [n=1] FALSE
[13:17:28.790] - queued futures: [n=1] FALSE
[13:17:28.790]  - until=1
[13:17:28.790]  - relaying element #1
[13:17:28.790] - relayed: [n=1] TRUE
[13:17:28.790] - queued futures: [n=1] TRUE
[13:17:28.790] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.790]  length: 0 (resolved future 1)
[13:17:28.790] Relaying remaining futures
[13:17:28.791] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.791] - nx: 1
[13:17:28.791] - relay: TRUE
[13:17:28.791] - stdout: TRUE
[13:17:28.791] - signal: TRUE
[13:17:28.791] - resignal: FALSE
[13:17:28.791] - force: TRUE
[13:17:28.791] - relayed: [n=1] TRUE
[13:17:28.791] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.791] - relayed: [n=1] TRUE
[13:17:28.791] - queued futures: [n=1] TRUE
[13:17:28.792] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.792] resolve() on list ... DONE
[13:17:28.792]  - Number of value chunks collected: 1
[13:17:28.792] Resolving 1 futures (chunks) ... DONE
[13:17:28.792] Reducing values from 1 chunks ...
[13:17:28.792]  - Number of values collected after concatenation: 3
[13:17:28.792]  - Number of values expected: 3
[13:17:28.792] Reducing values from 1 chunks ... DONE
[13:17:28.792] future_lapply() ... DONE
[13:17:28.792] future_by_internal() ... DONE
[13:17:28.794] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:17:28.795] future_lapply() ...
[13:17:28.796] Number of chunks: 1
[13:17:28.796] getGlobalsAndPackagesXApply() ...
[13:17:28.796]  - future.globals: TRUE
[13:17:28.796] getGlobalsAndPackages() ...
[13:17:28.796] Searching for globals...
[13:17:28.799] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:28.799] Searching for globals ... DONE
[13:17:28.799] Resolving globals: FALSE
[13:17:28.799] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:28.800] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:28.800] - globals: [1] ‘FUN’
[13:17:28.800] 
[13:17:28.800] getGlobalsAndPackages() ... DONE
[13:17:28.800]  - globals found/used: [n=1] ‘FUN’
[13:17:28.800]  - needed namespaces: [n=0] 
[13:17:28.800] Finding globals ... DONE
[13:17:28.800]  - use_args: TRUE
[13:17:28.800]  - Getting '...' globals ...
[13:17:28.801] resolve() on list ...
[13:17:28.801]  recursive: 0
[13:17:28.801]  length: 1
[13:17:28.801]  elements: ‘...’
[13:17:28.801]  length: 0 (resolved future 1)
[13:17:28.801] resolve() on list ... DONE
[13:17:28.801]    - '...' content: [n=0] 
[13:17:28.801] List of 1
[13:17:28.801]  $ ...: list()
[13:17:28.801]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.801]  - attr(*, "where")=List of 1
[13:17:28.801]   ..$ ...:<environment: 0x5609eac2ba78> 
[13:17:28.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.801]  - attr(*, "resolved")= logi TRUE
[13:17:28.801]  - attr(*, "total_size")= num NA
[13:17:28.804]  - Getting '...' globals ... DONE
[13:17:28.804] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.804] List of 2
[13:17:28.804]  $ ...future.FUN:function (object, ...)  
[13:17:28.804]  $ ...          : list()
[13:17:28.804]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.804]  - attr(*, "where")=List of 2
[13:17:28.804]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.804]   ..$ ...          :<environment: 0x5609eac2ba78> 
[13:17:28.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.804]  - attr(*, "resolved")= logi FALSE
[13:17:28.804]  - attr(*, "total_size")= num 1240
[13:17:28.807] Packages to be attached in all futures: [n=0] 
[13:17:28.807] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.807] Number of futures (= number of chunks): 1
[13:17:28.807] Launching 1 futures (chunks) ...
[13:17:28.807] Chunk #1 of 1 ...
[13:17:28.807]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.808] getGlobalsAndPackages() ...
[13:17:28.808] Searching for globals...
[13:17:28.808] 
[13:17:28.808] Searching for globals ... DONE
[13:17:28.808] - globals: [0] <none>
[13:17:28.808] getGlobalsAndPackages() ... DONE
[13:17:28.808]    + additional globals found: [n=0] 
[13:17:28.809]    + additional namespaces needed: [n=0] 
[13:17:28.809]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.809]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.809]  - seeds: <none>
[13:17:28.809] getGlobalsAndPackages() ...
[13:17:28.809] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.809] Resolving globals: FALSE
[13:17:28.809] Tweak future expression to call with '...' arguments ...
[13:17:28.809] {
[13:17:28.809]     do.call(function(...) {
[13:17:28.809]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.809]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.809]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.809]             on.exit(options(oopts), add = TRUE)
[13:17:28.809]         }
[13:17:28.809]         {
[13:17:28.809]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.809]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.809]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.809]             })
[13:17:28.809]         }
[13:17:28.809]     }, args = future.call.arguments)
[13:17:28.809] }
[13:17:28.810] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.810] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.810] 
[13:17:28.810] getGlobalsAndPackages() ... DONE
[13:17:28.810] run() for ‘Future’ ...
[13:17:28.811] - state: ‘created’
[13:17:28.811] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:28.811] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.811]   - Field: ‘label’
[13:17:28.811]   - Field: ‘local’
[13:17:28.811]   - Field: ‘owner’
[13:17:28.812]   - Field: ‘envir’
[13:17:28.812]   - Field: ‘packages’
[13:17:28.812]   - Field: ‘gc’
[13:17:28.812]   - Field: ‘conditions’
[13:17:28.812]   - Field: ‘expr’
[13:17:28.812]   - Field: ‘uuid’
[13:17:28.812]   - Field: ‘seed’
[13:17:28.812]   - Field: ‘version’
[13:17:28.812]   - Field: ‘result’
[13:17:28.812]   - Field: ‘asynchronous’
[13:17:28.813]   - Field: ‘calls’
[13:17:28.813]   - Field: ‘globals’
[13:17:28.813]   - Field: ‘stdout’
[13:17:28.813]   - Field: ‘earlySignal’
[13:17:28.813]   - Field: ‘lazy’
[13:17:28.813]   - Field: ‘state’
[13:17:28.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.813] - Launch lazy future ...
[13:17:28.813] Packages needed by the future expression (n = 0): <none>
[13:17:28.813] Packages needed by future strategies (n = 0): <none>
[13:17:28.814] {
[13:17:28.814]     {
[13:17:28.814]         {
[13:17:28.814]             ...future.startTime <- base::Sys.time()
[13:17:28.814]             {
[13:17:28.814]                 {
[13:17:28.814]                   {
[13:17:28.814]                     base::local({
[13:17:28.814]                       has_future <- base::requireNamespace("future", 
[13:17:28.814]                         quietly = TRUE)
[13:17:28.814]                       if (has_future) {
[13:17:28.814]                         ns <- base::getNamespace("future")
[13:17:28.814]                         version <- ns[[".package"]][["version"]]
[13:17:28.814]                         if (is.null(version)) 
[13:17:28.814]                           version <- utils::packageVersion("future")
[13:17:28.814]                       }
[13:17:28.814]                       else {
[13:17:28.814]                         version <- NULL
[13:17:28.814]                       }
[13:17:28.814]                       if (!has_future || version < "1.8.0") {
[13:17:28.814]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.814]                           "", base::R.version$version.string), 
[13:17:28.814]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:28.814]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.814]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.814]                             "release", "version")], collapse = " "), 
[13:17:28.814]                           hostname = base::Sys.info()[["nodename"]])
[13:17:28.814]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.814]                           info)
[13:17:28.814]                         info <- base::paste(info, collapse = "; ")
[13:17:28.814]                         if (!has_future) {
[13:17:28.814]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.814]                             info)
[13:17:28.814]                         }
[13:17:28.814]                         else {
[13:17:28.814]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.814]                             info, version)
[13:17:28.814]                         }
[13:17:28.814]                         base::stop(msg)
[13:17:28.814]                       }
[13:17:28.814]                     })
[13:17:28.814]                   }
[13:17:28.814]                   options(future.plan = NULL)
[13:17:28.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.814]                 }
[13:17:28.814]                 ...future.workdir <- getwd()
[13:17:28.814]             }
[13:17:28.814]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.814]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.814]         }
[13:17:28.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.814]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.814]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.814]             base::names(...future.oldOptions))
[13:17:28.814]     }
[13:17:28.814]     if (FALSE) {
[13:17:28.814]     }
[13:17:28.814]     else {
[13:17:28.814]         if (TRUE) {
[13:17:28.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.814]                 open = "w")
[13:17:28.814]         }
[13:17:28.814]         else {
[13:17:28.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.814]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.814]         }
[13:17:28.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.814]             base::sink(type = "output", split = FALSE)
[13:17:28.814]             base::close(...future.stdout)
[13:17:28.814]         }, add = TRUE)
[13:17:28.814]     }
[13:17:28.814]     ...future.frame <- base::sys.nframe()
[13:17:28.814]     ...future.conditions <- base::list()
[13:17:28.814]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.814]     if (FALSE) {
[13:17:28.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.814]     }
[13:17:28.814]     ...future.result <- base::tryCatch({
[13:17:28.814]         base::withCallingHandlers({
[13:17:28.814]             ...future.value <- base::withVisible(base::local({
[13:17:28.814]                 do.call(function(...) {
[13:17:28.814]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.814]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.814]                     ...future.globals.maxSize)) {
[13:17:28.814]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.814]                     on.exit(options(oopts), add = TRUE)
[13:17:28.814]                   }
[13:17:28.814]                   {
[13:17:28.814]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.814]                       FUN = function(jj) {
[13:17:28.814]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.814]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.814]                       })
[13:17:28.814]                   }
[13:17:28.814]                 }, args = future.call.arguments)
[13:17:28.814]             }))
[13:17:28.814]             future::FutureResult(value = ...future.value$value, 
[13:17:28.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.814]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.814]                     ...future.globalenv.names))
[13:17:28.814]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.814]         }, condition = base::local({
[13:17:28.814]             c <- base::c
[13:17:28.814]             inherits <- base::inherits
[13:17:28.814]             invokeRestart <- base::invokeRestart
[13:17:28.814]             length <- base::length
[13:17:28.814]             list <- base::list
[13:17:28.814]             seq.int <- base::seq.int
[13:17:28.814]             signalCondition <- base::signalCondition
[13:17:28.814]             sys.calls <- base::sys.calls
[13:17:28.814]             `[[` <- base::`[[`
[13:17:28.814]             `+` <- base::`+`
[13:17:28.814]             `<<-` <- base::`<<-`
[13:17:28.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.814]                   3L)]
[13:17:28.814]             }
[13:17:28.814]             function(cond) {
[13:17:28.814]                 is_error <- inherits(cond, "error")
[13:17:28.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.814]                   NULL)
[13:17:28.814]                 if (is_error) {
[13:17:28.814]                   sessionInformation <- function() {
[13:17:28.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.814]                       search = base::search(), system = base::Sys.info())
[13:17:28.814]                   }
[13:17:28.814]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.814]                     cond$call), session = sessionInformation(), 
[13:17:28.814]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.814]                   signalCondition(cond)
[13:17:28.814]                 }
[13:17:28.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.814]                 "immediateCondition"))) {
[13:17:28.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.814]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.814]                   if (TRUE && !signal) {
[13:17:28.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.814]                     {
[13:17:28.814]                       inherits <- base::inherits
[13:17:28.814]                       invokeRestart <- base::invokeRestart
[13:17:28.814]                       is.null <- base::is.null
[13:17:28.814]                       muffled <- FALSE
[13:17:28.814]                       if (inherits(cond, "message")) {
[13:17:28.814]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.814]                         if (muffled) 
[13:17:28.814]                           invokeRestart("muffleMessage")
[13:17:28.814]                       }
[13:17:28.814]                       else if (inherits(cond, "warning")) {
[13:17:28.814]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.814]                         if (muffled) 
[13:17:28.814]                           invokeRestart("muffleWarning")
[13:17:28.814]                       }
[13:17:28.814]                       else if (inherits(cond, "condition")) {
[13:17:28.814]                         if (!is.null(pattern)) {
[13:17:28.814]                           computeRestarts <- base::computeRestarts
[13:17:28.814]                           grepl <- base::grepl
[13:17:28.814]                           restarts <- computeRestarts(cond)
[13:17:28.814]                           for (restart in restarts) {
[13:17:28.814]                             name <- restart$name
[13:17:28.814]                             if (is.null(name)) 
[13:17:28.814]                               next
[13:17:28.814]                             if (!grepl(pattern, name)) 
[13:17:28.814]                               next
[13:17:28.814]                             invokeRestart(restart)
[13:17:28.814]                             muffled <- TRUE
[13:17:28.814]                             break
[13:17:28.814]                           }
[13:17:28.814]                         }
[13:17:28.814]                       }
[13:17:28.814]                       invisible(muffled)
[13:17:28.814]                     }
[13:17:28.814]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.814]                   }
[13:17:28.814]                 }
[13:17:28.814]                 else {
[13:17:28.814]                   if (TRUE) {
[13:17:28.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.814]                     {
[13:17:28.814]                       inherits <- base::inherits
[13:17:28.814]                       invokeRestart <- base::invokeRestart
[13:17:28.814]                       is.null <- base::is.null
[13:17:28.814]                       muffled <- FALSE
[13:17:28.814]                       if (inherits(cond, "message")) {
[13:17:28.814]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.814]                         if (muffled) 
[13:17:28.814]                           invokeRestart("muffleMessage")
[13:17:28.814]                       }
[13:17:28.814]                       else if (inherits(cond, "warning")) {
[13:17:28.814]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.814]                         if (muffled) 
[13:17:28.814]                           invokeRestart("muffleWarning")
[13:17:28.814]                       }
[13:17:28.814]                       else if (inherits(cond, "condition")) {
[13:17:28.814]                         if (!is.null(pattern)) {
[13:17:28.814]                           computeRestarts <- base::computeRestarts
[13:17:28.814]                           grepl <- base::grepl
[13:17:28.814]                           restarts <- computeRestarts(cond)
[13:17:28.814]                           for (restart in restarts) {
[13:17:28.814]                             name <- restart$name
[13:17:28.814]                             if (is.null(name)) 
[13:17:28.814]                               next
[13:17:28.814]                             if (!grepl(pattern, name)) 
[13:17:28.814]                               next
[13:17:28.814]                             invokeRestart(restart)
[13:17:28.814]                             muffled <- TRUE
[13:17:28.814]                             break
[13:17:28.814]                           }
[13:17:28.814]                         }
[13:17:28.814]                       }
[13:17:28.814]                       invisible(muffled)
[13:17:28.814]                     }
[13:17:28.814]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.814]                   }
[13:17:28.814]                 }
[13:17:28.814]             }
[13:17:28.814]         }))
[13:17:28.814]     }, error = function(ex) {
[13:17:28.814]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.814]                 ...future.rng), started = ...future.startTime, 
[13:17:28.814]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.814]             version = "1.8"), class = "FutureResult")
[13:17:28.814]     }, finally = {
[13:17:28.814]         if (!identical(...future.workdir, getwd())) 
[13:17:28.814]             setwd(...future.workdir)
[13:17:28.814]         {
[13:17:28.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.814]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.814]             }
[13:17:28.814]             base::options(...future.oldOptions)
[13:17:28.814]             if (.Platform$OS.type == "windows") {
[13:17:28.814]                 old_names <- names(...future.oldEnvVars)
[13:17:28.814]                 envs <- base::Sys.getenv()
[13:17:28.814]                 names <- names(envs)
[13:17:28.814]                 common <- intersect(names, old_names)
[13:17:28.814]                 added <- setdiff(names, old_names)
[13:17:28.814]                 removed <- setdiff(old_names, names)
[13:17:28.814]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.814]                   envs[common]]
[13:17:28.814]                 NAMES <- toupper(changed)
[13:17:28.814]                 args <- list()
[13:17:28.814]                 for (kk in seq_along(NAMES)) {
[13:17:28.814]                   name <- changed[[kk]]
[13:17:28.814]                   NAME <- NAMES[[kk]]
[13:17:28.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.814]                     next
[13:17:28.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.814]                 }
[13:17:28.814]                 NAMES <- toupper(added)
[13:17:28.814]                 for (kk in seq_along(NAMES)) {
[13:17:28.814]                   name <- added[[kk]]
[13:17:28.814]                   NAME <- NAMES[[kk]]
[13:17:28.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.814]                     next
[13:17:28.814]                   args[[name]] <- ""
[13:17:28.814]                 }
[13:17:28.814]                 NAMES <- toupper(removed)
[13:17:28.814]                 for (kk in seq_along(NAMES)) {
[13:17:28.814]                   name <- removed[[kk]]
[13:17:28.814]                   NAME <- NAMES[[kk]]
[13:17:28.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.814]                     next
[13:17:28.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.814]                 }
[13:17:28.814]                 if (length(args) > 0) 
[13:17:28.814]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.814]             }
[13:17:28.814]             else {
[13:17:28.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.814]             }
[13:17:28.814]             {
[13:17:28.814]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.814]                   0L) {
[13:17:28.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.814]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.814]                   base::options(opts)
[13:17:28.814]                 }
[13:17:28.814]                 {
[13:17:28.814]                   {
[13:17:28.814]                     NULL
[13:17:28.814]                     RNGkind("Mersenne-Twister")
[13:17:28.814]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.814]                       inherits = FALSE)
[13:17:28.814]                   }
[13:17:28.814]                   options(future.plan = NULL)
[13:17:28.814]                   if (is.na(NA_character_)) 
[13:17:28.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.814]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:28.814]                   {
[13:17:28.814]                     future <- SequentialFuture(..., envir = envir)
[13:17:28.814]                     if (!future$lazy) 
[13:17:28.814]                       future <- run(future)
[13:17:28.814]                     invisible(future)
[13:17:28.814]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.814]                 }
[13:17:28.814]             }
[13:17:28.814]         }
[13:17:28.814]     })
[13:17:28.814]     if (TRUE) {
[13:17:28.814]         base::sink(type = "output", split = FALSE)
[13:17:28.814]         if (TRUE) {
[13:17:28.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.814]         }
[13:17:28.814]         else {
[13:17:28.814]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.814]         }
[13:17:28.814]         base::close(...future.stdout)
[13:17:28.814]         ...future.stdout <- NULL
[13:17:28.814]     }
[13:17:28.814]     ...future.result$conditions <- ...future.conditions
[13:17:28.814]     ...future.result$finished <- base::Sys.time()
[13:17:28.814]     ...future.result
[13:17:28.814] }
[13:17:28.816] assign_globals() ...
[13:17:28.816] List of 5
[13:17:28.816]  $ ...future.FUN            :function (object, ...)  
[13:17:28.816]  $ future.call.arguments    : list()
[13:17:28.816]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.816]  $ ...future.elements_ii    :List of 3
[13:17:28.816]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.816]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.816]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.816]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.816]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.816]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.816]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.816]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:28.816]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.816]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.816]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.816]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:28.816]  $ ...future.seeds_ii       : NULL
[13:17:28.816]  $ ...future.globals.maxSize: NULL
[13:17:28.816]  - attr(*, "resolved")= logi FALSE
[13:17:28.816]  - attr(*, "total_size")= num 1240
[13:17:28.816]  - attr(*, "where")=List of 5
[13:17:28.816]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.816]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.816]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.816]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.816]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.816]  - attr(*, "already-done")= logi TRUE
[13:17:28.826] - copied ‘...future.FUN’ to environment
[13:17:28.826] - copied ‘future.call.arguments’ to environment
[13:17:28.826] - copied ‘...future.elements_ii’ to environment
[13:17:28.826] - copied ‘...future.seeds_ii’ to environment
[13:17:28.826] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.826] assign_globals() ... done
[13:17:28.826] plan(): Setting new future strategy stack:
[13:17:28.827] List of future strategies:
[13:17:28.827] 1. sequential:
[13:17:28.827]    - args: function (..., envir = parent.frame())
[13:17:28.827]    - tweaked: FALSE
[13:17:28.827]    - call: NULL
[13:17:28.827] plan(): nbrOfWorkers() = 1
[13:17:28.829] plan(): Setting new future strategy stack:
[13:17:28.829] List of future strategies:
[13:17:28.829] 1. sequential:
[13:17:28.829]    - args: function (..., envir = parent.frame())
[13:17:28.829]    - tweaked: FALSE
[13:17:28.829]    - call: plan(strategy)
[13:17:28.830] plan(): nbrOfWorkers() = 1
[13:17:28.830] SequentialFuture started (and completed)
[13:17:28.830] - Launch lazy future ... done
[13:17:28.830] run() for ‘SequentialFuture’ ... done
[13:17:28.830] Created future:
[13:17:28.830] SequentialFuture:
[13:17:28.830] Label: ‘future_by-1’
[13:17:28.830] Expression:
[13:17:28.830] {
[13:17:28.830]     do.call(function(...) {
[13:17:28.830]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.830]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.830]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.830]             on.exit(options(oopts), add = TRUE)
[13:17:28.830]         }
[13:17:28.830]         {
[13:17:28.830]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.830]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.830]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.830]             })
[13:17:28.830]         }
[13:17:28.830]     }, args = future.call.arguments)
[13:17:28.830] }
[13:17:28.830] Lazy evaluation: FALSE
[13:17:28.830] Asynchronous evaluation: FALSE
[13:17:28.830] Local evaluation: TRUE
[13:17:28.830] Environment: 0x5609eaa9a680
[13:17:28.830] Capture standard output: TRUE
[13:17:28.830] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.830] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.830] Packages: <none>
[13:17:28.830] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.830] Resolved: TRUE
[13:17:28.830] Value: 5.37 KiB of class ‘list’
[13:17:28.830] Early signaling: FALSE
[13:17:28.830] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.830] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.832] Chunk #1 of 1 ... DONE
[13:17:28.832] Launching 1 futures (chunks) ... DONE
[13:17:28.832] Resolving 1 futures (chunks) ...
[13:17:28.832] resolve() on list ...
[13:17:28.832]  recursive: 0
[13:17:28.832]  length: 1
[13:17:28.832] 
[13:17:28.832] resolved() for ‘SequentialFuture’ ...
[13:17:28.832] - state: ‘finished’
[13:17:28.832] - run: TRUE
[13:17:28.832] - result: ‘FutureResult’
[13:17:28.833] resolved() for ‘SequentialFuture’ ... done
[13:17:28.833] Future #1
[13:17:28.833] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.833] - nx: 1
[13:17:28.833] - relay: TRUE
[13:17:28.833] - stdout: TRUE
[13:17:28.833] - signal: TRUE
[13:17:28.833] - resignal: FALSE
[13:17:28.833] - force: TRUE
[13:17:28.834] - relayed: [n=1] FALSE
[13:17:28.834] - queued futures: [n=1] FALSE
[13:17:28.834]  - until=1
[13:17:28.834]  - relaying element #1
[13:17:28.834] - relayed: [n=1] TRUE
[13:17:28.834] - queued futures: [n=1] TRUE
[13:17:28.834] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.834]  length: 0 (resolved future 1)
[13:17:28.834] Relaying remaining futures
[13:17:28.834] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.835] - nx: 1
[13:17:28.835] - relay: TRUE
[13:17:28.835] - stdout: TRUE
[13:17:28.835] - signal: TRUE
[13:17:28.835] - resignal: FALSE
[13:17:28.835] - force: TRUE
[13:17:28.835] - relayed: [n=1] TRUE
[13:17:28.835] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.835] - relayed: [n=1] TRUE
[13:17:28.835] - queued futures: [n=1] TRUE
[13:17:28.835] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.836] resolve() on list ... DONE
[13:17:28.836]  - Number of value chunks collected: 1
[13:17:28.836] Resolving 1 futures (chunks) ... DONE
[13:17:28.836] Reducing values from 1 chunks ...
[13:17:28.836]  - Number of values collected after concatenation: 3
[13:17:28.836]  - Number of values expected: 3
[13:17:28.836] Reducing values from 1 chunks ... DONE
[13:17:28.836] future_lapply() ... DONE
[13:17:28.836] future_by_internal() ... DONE
[13:17:28.837] future_by_internal() ...
- plan('multicore') ...
[13:17:28.838] plan(): Setting new future strategy stack:
[13:17:28.838] List of future strategies:
[13:17:28.838] 1. multicore:
[13:17:28.838]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:28.838]    - tweaked: FALSE
[13:17:28.838]    - call: plan(strategy)
[13:17:28.844] plan(): nbrOfWorkers() = 1
[13:17:28.844] future_by_internal() ...
[13:17:28.844] future_lapply() ...
[13:17:28.848] Number of chunks: 1
[13:17:28.848] getGlobalsAndPackagesXApply() ...
[13:17:28.848]  - future.globals: TRUE
[13:17:28.848] getGlobalsAndPackages() ...
[13:17:28.848] Searching for globals...
[13:17:28.849] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:28.849] Searching for globals ... DONE
[13:17:28.850] Resolving globals: FALSE
[13:17:28.850] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:28.850] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:28.850] - globals: [1] ‘FUN’
[13:17:28.850] 
[13:17:28.851] getGlobalsAndPackages() ... DONE
[13:17:28.851]  - globals found/used: [n=1] ‘FUN’
[13:17:28.851]  - needed namespaces: [n=0] 
[13:17:28.851] Finding globals ... DONE
[13:17:28.851]  - use_args: TRUE
[13:17:28.851]  - Getting '...' globals ...
[13:17:28.851] resolve() on list ...
[13:17:28.851]  recursive: 0
[13:17:28.851]  length: 1
[13:17:28.852]  elements: ‘...’
[13:17:28.852]  length: 0 (resolved future 1)
[13:17:28.852] resolve() on list ... DONE
[13:17:28.852]    - '...' content: [n=0] 
[13:17:28.852] List of 1
[13:17:28.852]  $ ...: list()
[13:17:28.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.852]  - attr(*, "where")=List of 1
[13:17:28.852]   ..$ ...:<environment: 0x5609e9459fd0> 
[13:17:28.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.852]  - attr(*, "resolved")= logi TRUE
[13:17:28.852]  - attr(*, "total_size")= num NA
[13:17:28.854]  - Getting '...' globals ... DONE
[13:17:28.855] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.855] List of 2
[13:17:28.855]  $ ...future.FUN:function (object, ...)  
[13:17:28.855]  $ ...          : list()
[13:17:28.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.855]  - attr(*, "where")=List of 2
[13:17:28.855]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.855]   ..$ ...          :<environment: 0x5609e9459fd0> 
[13:17:28.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.855]  - attr(*, "resolved")= logi FALSE
[13:17:28.855]  - attr(*, "total_size")= num 1240
[13:17:28.857] Packages to be attached in all futures: [n=0] 
[13:17:28.858] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.858] Number of futures (= number of chunks): 1
[13:17:28.858] Launching 1 futures (chunks) ...
[13:17:28.858] Chunk #1 of 1 ...
[13:17:28.858]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.858] getGlobalsAndPackages() ...
[13:17:28.858] Searching for globals...
[13:17:28.859] 
[13:17:28.859] Searching for globals ... DONE
[13:17:28.859] - globals: [0] <none>
[13:17:28.859] getGlobalsAndPackages() ... DONE
[13:17:28.859]    + additional globals found: [n=0] 
[13:17:28.859]    + additional namespaces needed: [n=0] 
[13:17:28.859]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.859]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.859]  - seeds: <none>
[13:17:28.860] getGlobalsAndPackages() ...
[13:17:28.860] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.860] Resolving globals: FALSE
[13:17:28.860] Tweak future expression to call with '...' arguments ...
[13:17:28.860] {
[13:17:28.860]     do.call(function(...) {
[13:17:28.860]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.860]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.860]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.860]             on.exit(options(oopts), add = TRUE)
[13:17:28.860]         }
[13:17:28.860]         {
[13:17:28.860]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.860]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.860]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.860]             })
[13:17:28.860]         }
[13:17:28.860]     }, args = future.call.arguments)
[13:17:28.860] }
[13:17:28.860] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.861] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.861] 
[13:17:28.861] getGlobalsAndPackages() ... DONE
[13:17:28.861] run() for ‘Future’ ...
[13:17:28.861] - state: ‘created’
[13:17:28.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:28.865] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.865]   - Field: ‘label’
[13:17:28.865]   - Field: ‘local’
[13:17:28.865]   - Field: ‘owner’
[13:17:28.865]   - Field: ‘envir’
[13:17:28.866]   - Field: ‘packages’
[13:17:28.866]   - Field: ‘gc’
[13:17:28.866]   - Field: ‘conditions’
[13:17:28.866]   - Field: ‘expr’
[13:17:28.866]   - Field: ‘uuid’
[13:17:28.866]   - Field: ‘seed’
[13:17:28.866]   - Field: ‘version’
[13:17:28.868]   - Field: ‘result’
[13:17:28.868]   - Field: ‘asynchronous’
[13:17:28.868]   - Field: ‘calls’
[13:17:28.868]   - Field: ‘globals’
[13:17:28.868]   - Field: ‘stdout’
[13:17:28.868]   - Field: ‘earlySignal’
[13:17:28.868]   - Field: ‘lazy’
[13:17:28.868]   - Field: ‘state’
[13:17:28.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.869] - Launch lazy future ...
[13:17:28.869] Packages needed by the future expression (n = 0): <none>
[13:17:28.869] Packages needed by future strategies (n = 0): <none>
[13:17:28.869] {
[13:17:28.869]     {
[13:17:28.869]         {
[13:17:28.869]             ...future.startTime <- base::Sys.time()
[13:17:28.869]             {
[13:17:28.869]                 {
[13:17:28.869]                   {
[13:17:28.869]                     base::local({
[13:17:28.869]                       has_future <- base::requireNamespace("future", 
[13:17:28.869]                         quietly = TRUE)
[13:17:28.869]                       if (has_future) {
[13:17:28.869]                         ns <- base::getNamespace("future")
[13:17:28.869]                         version <- ns[[".package"]][["version"]]
[13:17:28.869]                         if (is.null(version)) 
[13:17:28.869]                           version <- utils::packageVersion("future")
[13:17:28.869]                       }
[13:17:28.869]                       else {
[13:17:28.869]                         version <- NULL
[13:17:28.869]                       }
[13:17:28.869]                       if (!has_future || version < "1.8.0") {
[13:17:28.869]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.869]                           "", base::R.version$version.string), 
[13:17:28.869]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:28.869]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.869]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.869]                             "release", "version")], collapse = " "), 
[13:17:28.869]                           hostname = base::Sys.info()[["nodename"]])
[13:17:28.869]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.869]                           info)
[13:17:28.869]                         info <- base::paste(info, collapse = "; ")
[13:17:28.869]                         if (!has_future) {
[13:17:28.869]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.869]                             info)
[13:17:28.869]                         }
[13:17:28.869]                         else {
[13:17:28.869]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.869]                             info, version)
[13:17:28.869]                         }
[13:17:28.869]                         base::stop(msg)
[13:17:28.869]                       }
[13:17:28.869]                     })
[13:17:28.869]                   }
[13:17:28.869]                   options(future.plan = NULL)
[13:17:28.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.869]                 }
[13:17:28.869]                 ...future.workdir <- getwd()
[13:17:28.869]             }
[13:17:28.869]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.869]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.869]         }
[13:17:28.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.869]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.869]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.869]             base::names(...future.oldOptions))
[13:17:28.869]     }
[13:17:28.869]     if (FALSE) {
[13:17:28.869]     }
[13:17:28.869]     else {
[13:17:28.869]         if (TRUE) {
[13:17:28.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.869]                 open = "w")
[13:17:28.869]         }
[13:17:28.869]         else {
[13:17:28.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.869]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.869]         }
[13:17:28.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.869]             base::sink(type = "output", split = FALSE)
[13:17:28.869]             base::close(...future.stdout)
[13:17:28.869]         }, add = TRUE)
[13:17:28.869]     }
[13:17:28.869]     ...future.frame <- base::sys.nframe()
[13:17:28.869]     ...future.conditions <- base::list()
[13:17:28.869]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.869]     if (FALSE) {
[13:17:28.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.869]     }
[13:17:28.869]     ...future.result <- base::tryCatch({
[13:17:28.869]         base::withCallingHandlers({
[13:17:28.869]             ...future.value <- base::withVisible(base::local({
[13:17:28.869]                 do.call(function(...) {
[13:17:28.869]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.869]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.869]                     ...future.globals.maxSize)) {
[13:17:28.869]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.869]                     on.exit(options(oopts), add = TRUE)
[13:17:28.869]                   }
[13:17:28.869]                   {
[13:17:28.869]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.869]                       FUN = function(jj) {
[13:17:28.869]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.869]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.869]                       })
[13:17:28.869]                   }
[13:17:28.869]                 }, args = future.call.arguments)
[13:17:28.869]             }))
[13:17:28.869]             future::FutureResult(value = ...future.value$value, 
[13:17:28.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.869]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.869]                     ...future.globalenv.names))
[13:17:28.869]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.869]         }, condition = base::local({
[13:17:28.869]             c <- base::c
[13:17:28.869]             inherits <- base::inherits
[13:17:28.869]             invokeRestart <- base::invokeRestart
[13:17:28.869]             length <- base::length
[13:17:28.869]             list <- base::list
[13:17:28.869]             seq.int <- base::seq.int
[13:17:28.869]             signalCondition <- base::signalCondition
[13:17:28.869]             sys.calls <- base::sys.calls
[13:17:28.869]             `[[` <- base::`[[`
[13:17:28.869]             `+` <- base::`+`
[13:17:28.869]             `<<-` <- base::`<<-`
[13:17:28.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.869]                   3L)]
[13:17:28.869]             }
[13:17:28.869]             function(cond) {
[13:17:28.869]                 is_error <- inherits(cond, "error")
[13:17:28.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.869]                   NULL)
[13:17:28.869]                 if (is_error) {
[13:17:28.869]                   sessionInformation <- function() {
[13:17:28.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.869]                       search = base::search(), system = base::Sys.info())
[13:17:28.869]                   }
[13:17:28.869]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.869]                     cond$call), session = sessionInformation(), 
[13:17:28.869]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.869]                   signalCondition(cond)
[13:17:28.869]                 }
[13:17:28.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.869]                 "immediateCondition"))) {
[13:17:28.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.869]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.869]                   if (TRUE && !signal) {
[13:17:28.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.869]                     {
[13:17:28.869]                       inherits <- base::inherits
[13:17:28.869]                       invokeRestart <- base::invokeRestart
[13:17:28.869]                       is.null <- base::is.null
[13:17:28.869]                       muffled <- FALSE
[13:17:28.869]                       if (inherits(cond, "message")) {
[13:17:28.869]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.869]                         if (muffled) 
[13:17:28.869]                           invokeRestart("muffleMessage")
[13:17:28.869]                       }
[13:17:28.869]                       else if (inherits(cond, "warning")) {
[13:17:28.869]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.869]                         if (muffled) 
[13:17:28.869]                           invokeRestart("muffleWarning")
[13:17:28.869]                       }
[13:17:28.869]                       else if (inherits(cond, "condition")) {
[13:17:28.869]                         if (!is.null(pattern)) {
[13:17:28.869]                           computeRestarts <- base::computeRestarts
[13:17:28.869]                           grepl <- base::grepl
[13:17:28.869]                           restarts <- computeRestarts(cond)
[13:17:28.869]                           for (restart in restarts) {
[13:17:28.869]                             name <- restart$name
[13:17:28.869]                             if (is.null(name)) 
[13:17:28.869]                               next
[13:17:28.869]                             if (!grepl(pattern, name)) 
[13:17:28.869]                               next
[13:17:28.869]                             invokeRestart(restart)
[13:17:28.869]                             muffled <- TRUE
[13:17:28.869]                             break
[13:17:28.869]                           }
[13:17:28.869]                         }
[13:17:28.869]                       }
[13:17:28.869]                       invisible(muffled)
[13:17:28.869]                     }
[13:17:28.869]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.869]                   }
[13:17:28.869]                 }
[13:17:28.869]                 else {
[13:17:28.869]                   if (TRUE) {
[13:17:28.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.869]                     {
[13:17:28.869]                       inherits <- base::inherits
[13:17:28.869]                       invokeRestart <- base::invokeRestart
[13:17:28.869]                       is.null <- base::is.null
[13:17:28.869]                       muffled <- FALSE
[13:17:28.869]                       if (inherits(cond, "message")) {
[13:17:28.869]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.869]                         if (muffled) 
[13:17:28.869]                           invokeRestart("muffleMessage")
[13:17:28.869]                       }
[13:17:28.869]                       else if (inherits(cond, "warning")) {
[13:17:28.869]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.869]                         if (muffled) 
[13:17:28.869]                           invokeRestart("muffleWarning")
[13:17:28.869]                       }
[13:17:28.869]                       else if (inherits(cond, "condition")) {
[13:17:28.869]                         if (!is.null(pattern)) {
[13:17:28.869]                           computeRestarts <- base::computeRestarts
[13:17:28.869]                           grepl <- base::grepl
[13:17:28.869]                           restarts <- computeRestarts(cond)
[13:17:28.869]                           for (restart in restarts) {
[13:17:28.869]                             name <- restart$name
[13:17:28.869]                             if (is.null(name)) 
[13:17:28.869]                               next
[13:17:28.869]                             if (!grepl(pattern, name)) 
[13:17:28.869]                               next
[13:17:28.869]                             invokeRestart(restart)
[13:17:28.869]                             muffled <- TRUE
[13:17:28.869]                             break
[13:17:28.869]                           }
[13:17:28.869]                         }
[13:17:28.869]                       }
[13:17:28.869]                       invisible(muffled)
[13:17:28.869]                     }
[13:17:28.869]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.869]                   }
[13:17:28.869]                 }
[13:17:28.869]             }
[13:17:28.869]         }))
[13:17:28.869]     }, error = function(ex) {
[13:17:28.869]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.869]                 ...future.rng), started = ...future.startTime, 
[13:17:28.869]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.869]             version = "1.8"), class = "FutureResult")
[13:17:28.869]     }, finally = {
[13:17:28.869]         if (!identical(...future.workdir, getwd())) 
[13:17:28.869]             setwd(...future.workdir)
[13:17:28.869]         {
[13:17:28.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.869]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.869]             }
[13:17:28.869]             base::options(...future.oldOptions)
[13:17:28.869]             if (.Platform$OS.type == "windows") {
[13:17:28.869]                 old_names <- names(...future.oldEnvVars)
[13:17:28.869]                 envs <- base::Sys.getenv()
[13:17:28.869]                 names <- names(envs)
[13:17:28.869]                 common <- intersect(names, old_names)
[13:17:28.869]                 added <- setdiff(names, old_names)
[13:17:28.869]                 removed <- setdiff(old_names, names)
[13:17:28.869]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.869]                   envs[common]]
[13:17:28.869]                 NAMES <- toupper(changed)
[13:17:28.869]                 args <- list()
[13:17:28.869]                 for (kk in seq_along(NAMES)) {
[13:17:28.869]                   name <- changed[[kk]]
[13:17:28.869]                   NAME <- NAMES[[kk]]
[13:17:28.869]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.869]                     next
[13:17:28.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.869]                 }
[13:17:28.869]                 NAMES <- toupper(added)
[13:17:28.869]                 for (kk in seq_along(NAMES)) {
[13:17:28.869]                   name <- added[[kk]]
[13:17:28.869]                   NAME <- NAMES[[kk]]
[13:17:28.869]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.869]                     next
[13:17:28.869]                   args[[name]] <- ""
[13:17:28.869]                 }
[13:17:28.869]                 NAMES <- toupper(removed)
[13:17:28.869]                 for (kk in seq_along(NAMES)) {
[13:17:28.869]                   name <- removed[[kk]]
[13:17:28.869]                   NAME <- NAMES[[kk]]
[13:17:28.869]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.869]                     next
[13:17:28.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.869]                 }
[13:17:28.869]                 if (length(args) > 0) 
[13:17:28.869]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.869]             }
[13:17:28.869]             else {
[13:17:28.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.869]             }
[13:17:28.869]             {
[13:17:28.869]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.869]                   0L) {
[13:17:28.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.869]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.869]                   base::options(opts)
[13:17:28.869]                 }
[13:17:28.869]                 {
[13:17:28.869]                   {
[13:17:28.869]                     NULL
[13:17:28.869]                     RNGkind("Mersenne-Twister")
[13:17:28.869]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.869]                       inherits = FALSE)
[13:17:28.869]                   }
[13:17:28.869]                   options(future.plan = NULL)
[13:17:28.869]                   if (is.na(NA_character_)) 
[13:17:28.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.869]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:28.869]                     envir = parent.frame()) 
[13:17:28.869]                   {
[13:17:28.869]                     default_workers <- missing(workers)
[13:17:28.869]                     if (is.function(workers)) 
[13:17:28.869]                       workers <- workers()
[13:17:28.869]                     workers <- structure(as.integer(workers), 
[13:17:28.869]                       class = class(workers))
[13:17:28.869]                     stop_if_not(is.finite(workers), workers >= 
[13:17:28.869]                       1L)
[13:17:28.869]                     if ((workers == 1L && !inherits(workers, 
[13:17:28.869]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:28.869]                       if (default_workers) 
[13:17:28.869]                         supportsMulticore(warn = TRUE)
[13:17:28.869]                       return(sequential(..., envir = envir))
[13:17:28.869]                     }
[13:17:28.869]                     oopts <- options(mc.cores = workers)
[13:17:28.869]                     on.exit(options(oopts))
[13:17:28.869]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:28.869]                       envir = envir)
[13:17:28.869]                     if (!future$lazy) 
[13:17:28.869]                       future <- run(future)
[13:17:28.869]                     invisible(future)
[13:17:28.869]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.869]                 }
[13:17:28.869]             }
[13:17:28.869]         }
[13:17:28.869]     })
[13:17:28.869]     if (TRUE) {
[13:17:28.869]         base::sink(type = "output", split = FALSE)
[13:17:28.869]         if (TRUE) {
[13:17:28.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.869]         }
[13:17:28.869]         else {
[13:17:28.869]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.869]         }
[13:17:28.869]         base::close(...future.stdout)
[13:17:28.869]         ...future.stdout <- NULL
[13:17:28.869]     }
[13:17:28.869]     ...future.result$conditions <- ...future.conditions
[13:17:28.869]     ...future.result$finished <- base::Sys.time()
[13:17:28.869]     ...future.result
[13:17:28.869] }
[13:17:28.871] assign_globals() ...
[13:17:28.871] List of 5
[13:17:28.871]  $ ...future.FUN            :function (object, ...)  
[13:17:28.871]  $ future.call.arguments    : list()
[13:17:28.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.871]  $ ...future.elements_ii    :List of 3
[13:17:28.871]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:28.871]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.871]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.871]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:28.871]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.871]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.871]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:28.871]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.871]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.871]  $ ...future.seeds_ii       : NULL
[13:17:28.871]  $ ...future.globals.maxSize: NULL
[13:17:28.871]  - attr(*, "resolved")= logi FALSE
[13:17:28.871]  - attr(*, "total_size")= num 1240
[13:17:28.871]  - attr(*, "where")=List of 5
[13:17:28.871]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.871]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.871]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.871]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.871]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.871]  - attr(*, "already-done")= logi TRUE
[13:17:28.879] - copied ‘...future.FUN’ to environment
[13:17:28.879] - copied ‘future.call.arguments’ to environment
[13:17:28.879] - copied ‘...future.elements_ii’ to environment
[13:17:28.879] - copied ‘...future.seeds_ii’ to environment
[13:17:28.879] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.879] assign_globals() ... done
[13:17:28.879] plan(): Setting new future strategy stack:
[13:17:28.880] List of future strategies:
[13:17:28.880] 1. sequential:
[13:17:28.880]    - args: function (..., envir = parent.frame())
[13:17:28.880]    - tweaked: FALSE
[13:17:28.880]    - call: NULL
[13:17:28.880] plan(): nbrOfWorkers() = 1
[13:17:28.882] plan(): Setting new future strategy stack:
[13:17:28.882] List of future strategies:
[13:17:28.882] 1. multicore:
[13:17:28.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:28.882]    - tweaked: FALSE
[13:17:28.882]    - call: plan(strategy)
[13:17:28.886] plan(): nbrOfWorkers() = 1
[13:17:28.886] SequentialFuture started (and completed)
[13:17:28.886] - Launch lazy future ... done
[13:17:28.886] run() for ‘SequentialFuture’ ... done
[13:17:28.886] Created future:
[13:17:28.886] SequentialFuture:
[13:17:28.886] Label: ‘future_by-1’
[13:17:28.886] Expression:
[13:17:28.886] {
[13:17:28.886]     do.call(function(...) {
[13:17:28.886]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.886]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.886]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.886]             on.exit(options(oopts), add = TRUE)
[13:17:28.886]         }
[13:17:28.886]         {
[13:17:28.886]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.886]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.886]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.886]             })
[13:17:28.886]         }
[13:17:28.886]     }, args = future.call.arguments)
[13:17:28.886] }
[13:17:28.886] Lazy evaluation: FALSE
[13:17:28.886] Asynchronous evaluation: FALSE
[13:17:28.886] Local evaluation: TRUE
[13:17:28.886] Environment: R_GlobalEnv
[13:17:28.886] Capture standard output: TRUE
[13:17:28.886] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.886] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.886] Packages: <none>
[13:17:28.886] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.886] Resolved: TRUE
[13:17:28.886] Value: 4.62 KiB of class ‘list’
[13:17:28.886] Early signaling: FALSE
[13:17:28.886] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.886] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.887] Chunk #1 of 1 ... DONE
[13:17:28.887] Launching 1 futures (chunks) ... DONE
[13:17:28.888] Resolving 1 futures (chunks) ...
[13:17:28.888] resolve() on list ...
[13:17:28.888]  recursive: 0
[13:17:28.888]  length: 1
[13:17:28.888] 
[13:17:28.888] resolved() for ‘SequentialFuture’ ...
[13:17:28.888] - state: ‘finished’
[13:17:28.888] - run: TRUE
[13:17:28.888] - result: ‘FutureResult’
[13:17:28.888] resolved() for ‘SequentialFuture’ ... done
[13:17:28.888] Future #1
[13:17:28.889] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.889] - nx: 1
[13:17:28.889] - relay: TRUE
[13:17:28.889] - stdout: TRUE
[13:17:28.889] - signal: TRUE
[13:17:28.889] - resignal: FALSE
[13:17:28.889] - force: TRUE
[13:17:28.889] - relayed: [n=1] FALSE
[13:17:28.889] - queued futures: [n=1] FALSE
[13:17:28.889]  - until=1
[13:17:28.889]  - relaying element #1
[13:17:28.890] - relayed: [n=1] TRUE
[13:17:28.890] - queued futures: [n=1] TRUE
[13:17:28.891] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.891]  length: 0 (resolved future 1)
[13:17:28.892] Relaying remaining futures
[13:17:28.892] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.892] - nx: 1
[13:17:28.892] - relay: TRUE
[13:17:28.892] - stdout: TRUE
[13:17:28.892] - signal: TRUE
[13:17:28.892] - resignal: FALSE
[13:17:28.892] - force: TRUE
[13:17:28.892] - relayed: [n=1] TRUE
[13:17:28.892] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.892] - relayed: [n=1] TRUE
[13:17:28.892] - queued futures: [n=1] TRUE
[13:17:28.893] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.893] resolve() on list ... DONE
[13:17:28.893]  - Number of value chunks collected: 1
[13:17:28.893] Resolving 1 futures (chunks) ... DONE
[13:17:28.893] Reducing values from 1 chunks ...
[13:17:28.893]  - Number of values collected after concatenation: 3
[13:17:28.893]  - Number of values expected: 3
[13:17:28.893] Reducing values from 1 chunks ... DONE
[13:17:28.893] future_lapply() ... DONE
[13:17:28.894] future_by_internal() ... DONE
[13:17:28.894] future_by_internal() ...
[13:17:28.894] future_lapply() ...
[13:17:28.898] Number of chunks: 1
[13:17:28.898] getGlobalsAndPackagesXApply() ...
[13:17:28.898]  - future.globals: TRUE
[13:17:28.898] getGlobalsAndPackages() ...
[13:17:28.898] Searching for globals...
[13:17:28.899] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:28.899] Searching for globals ... DONE
[13:17:28.899] Resolving globals: FALSE
[13:17:28.900] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:28.900] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:28.900] - globals: [1] ‘FUN’
[13:17:28.900] 
[13:17:28.900] getGlobalsAndPackages() ... DONE
[13:17:28.900]  - globals found/used: [n=1] ‘FUN’
[13:17:28.901]  - needed namespaces: [n=0] 
[13:17:28.901] Finding globals ... DONE
[13:17:28.901]  - use_args: TRUE
[13:17:28.901]  - Getting '...' globals ...
[13:17:28.901] resolve() on list ...
[13:17:28.901]  recursive: 0
[13:17:28.901]  length: 1
[13:17:28.901]  elements: ‘...’
[13:17:28.902]  length: 0 (resolved future 1)
[13:17:28.902] resolve() on list ... DONE
[13:17:28.902]    - '...' content: [n=1] ‘digits’
[13:17:28.902] List of 1
[13:17:28.902]  $ ...:List of 1
[13:17:28.902]   ..$ digits: int 2
[13:17:28.902]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.902]  - attr(*, "where")=List of 1
[13:17:28.902]   ..$ ...:<environment: 0x5609e902fc08> 
[13:17:28.902]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.902]  - attr(*, "resolved")= logi TRUE
[13:17:28.902]  - attr(*, "total_size")= num NA
[13:17:28.905]  - Getting '...' globals ... DONE
[13:17:28.905] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.905] List of 2
[13:17:28.905]  $ ...future.FUN:function (object, ...)  
[13:17:28.905]  $ ...          :List of 1
[13:17:28.905]   ..$ digits: int 2
[13:17:28.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.905]  - attr(*, "where")=List of 2
[13:17:28.905]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.905]   ..$ ...          :<environment: 0x5609e902fc08> 
[13:17:28.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.905]  - attr(*, "resolved")= logi FALSE
[13:17:28.905]  - attr(*, "total_size")= num 1296
[13:17:28.908] Packages to be attached in all futures: [n=0] 
[13:17:28.908] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.908] Number of futures (= number of chunks): 1
[13:17:28.908] Launching 1 futures (chunks) ...
[13:17:28.908] Chunk #1 of 1 ...
[13:17:28.909]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.909] getGlobalsAndPackages() ...
[13:17:28.909] Searching for globals...
[13:17:28.909] 
[13:17:28.909] Searching for globals ... DONE
[13:17:28.909] - globals: [0] <none>
[13:17:28.909] getGlobalsAndPackages() ... DONE
[13:17:28.909]    + additional globals found: [n=0] 
[13:17:28.910]    + additional namespaces needed: [n=0] 
[13:17:28.910]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.910]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[13:17:28.910]  - seeds: <none>
[13:17:28.910] getGlobalsAndPackages() ...
[13:17:28.910] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.910] Resolving globals: FALSE
[13:17:28.910] Tweak future expression to call with '...' arguments ...
[13:17:28.910] {
[13:17:28.910]     do.call(function(...) {
[13:17:28.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.910]             on.exit(options(oopts), add = TRUE)
[13:17:28.910]         }
[13:17:28.910]         {
[13:17:28.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.910]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.910]             })
[13:17:28.910]         }
[13:17:28.910]     }, args = future.call.arguments)
[13:17:28.910] }
[13:17:28.911] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.911] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.911] 
[13:17:28.911] getGlobalsAndPackages() ... DONE
[13:17:28.911] run() for ‘Future’ ...
[13:17:28.913] - state: ‘created’
[13:17:28.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:28.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.917]   - Field: ‘label’
[13:17:28.917]   - Field: ‘local’
[13:17:28.917]   - Field: ‘owner’
[13:17:28.917]   - Field: ‘envir’
[13:17:28.917]   - Field: ‘packages’
[13:17:28.917]   - Field: ‘gc’
[13:17:28.917]   - Field: ‘conditions’
[13:17:28.918]   - Field: ‘expr’
[13:17:28.918]   - Field: ‘uuid’
[13:17:28.918]   - Field: ‘seed’
[13:17:28.918]   - Field: ‘version’
[13:17:28.918]   - Field: ‘result’
[13:17:28.918]   - Field: ‘asynchronous’
[13:17:28.918]   - Field: ‘calls’
[13:17:28.918]   - Field: ‘globals’
[13:17:28.918]   - Field: ‘stdout’
[13:17:28.918]   - Field: ‘earlySignal’
[13:17:28.918]   - Field: ‘lazy’
[13:17:28.919]   - Field: ‘state’
[13:17:28.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.919] - Launch lazy future ...
[13:17:28.919] Packages needed by the future expression (n = 0): <none>
[13:17:28.919] Packages needed by future strategies (n = 0): <none>
[13:17:28.919] {
[13:17:28.919]     {
[13:17:28.919]         {
[13:17:28.919]             ...future.startTime <- base::Sys.time()
[13:17:28.919]             {
[13:17:28.919]                 {
[13:17:28.919]                   {
[13:17:28.919]                     base::local({
[13:17:28.919]                       has_future <- base::requireNamespace("future", 
[13:17:28.919]                         quietly = TRUE)
[13:17:28.919]                       if (has_future) {
[13:17:28.919]                         ns <- base::getNamespace("future")
[13:17:28.919]                         version <- ns[[".package"]][["version"]]
[13:17:28.919]                         if (is.null(version)) 
[13:17:28.919]                           version <- utils::packageVersion("future")
[13:17:28.919]                       }
[13:17:28.919]                       else {
[13:17:28.919]                         version <- NULL
[13:17:28.919]                       }
[13:17:28.919]                       if (!has_future || version < "1.8.0") {
[13:17:28.919]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.919]                           "", base::R.version$version.string), 
[13:17:28.919]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:28.919]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.919]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.919]                             "release", "version")], collapse = " "), 
[13:17:28.919]                           hostname = base::Sys.info()[["nodename"]])
[13:17:28.919]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.919]                           info)
[13:17:28.919]                         info <- base::paste(info, collapse = "; ")
[13:17:28.919]                         if (!has_future) {
[13:17:28.919]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.919]                             info)
[13:17:28.919]                         }
[13:17:28.919]                         else {
[13:17:28.919]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.919]                             info, version)
[13:17:28.919]                         }
[13:17:28.919]                         base::stop(msg)
[13:17:28.919]                       }
[13:17:28.919]                     })
[13:17:28.919]                   }
[13:17:28.919]                   options(future.plan = NULL)
[13:17:28.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.919]                 }
[13:17:28.919]                 ...future.workdir <- getwd()
[13:17:28.919]             }
[13:17:28.919]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.919]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.919]         }
[13:17:28.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.919]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[13:17:28.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.919]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.919]             base::names(...future.oldOptions))
[13:17:28.919]     }
[13:17:28.919]     if (FALSE) {
[13:17:28.919]     }
[13:17:28.919]     else {
[13:17:28.919]         if (TRUE) {
[13:17:28.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.919]                 open = "w")
[13:17:28.919]         }
[13:17:28.919]         else {
[13:17:28.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.919]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.919]         }
[13:17:28.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.919]             base::sink(type = "output", split = FALSE)
[13:17:28.919]             base::close(...future.stdout)
[13:17:28.919]         }, add = TRUE)
[13:17:28.919]     }
[13:17:28.919]     ...future.frame <- base::sys.nframe()
[13:17:28.919]     ...future.conditions <- base::list()
[13:17:28.919]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.919]     if (FALSE) {
[13:17:28.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.919]     }
[13:17:28.919]     ...future.result <- base::tryCatch({
[13:17:28.919]         base::withCallingHandlers({
[13:17:28.919]             ...future.value <- base::withVisible(base::local({
[13:17:28.919]                 do.call(function(...) {
[13:17:28.919]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.919]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.919]                     ...future.globals.maxSize)) {
[13:17:28.919]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.919]                     on.exit(options(oopts), add = TRUE)
[13:17:28.919]                   }
[13:17:28.919]                   {
[13:17:28.919]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.919]                       FUN = function(jj) {
[13:17:28.919]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.919]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.919]                       })
[13:17:28.919]                   }
[13:17:28.919]                 }, args = future.call.arguments)
[13:17:28.919]             }))
[13:17:28.919]             future::FutureResult(value = ...future.value$value, 
[13:17:28.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.919]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.919]                     ...future.globalenv.names))
[13:17:28.919]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.919]         }, condition = base::local({
[13:17:28.919]             c <- base::c
[13:17:28.919]             inherits <- base::inherits
[13:17:28.919]             invokeRestart <- base::invokeRestart
[13:17:28.919]             length <- base::length
[13:17:28.919]             list <- base::list
[13:17:28.919]             seq.int <- base::seq.int
[13:17:28.919]             signalCondition <- base::signalCondition
[13:17:28.919]             sys.calls <- base::sys.calls
[13:17:28.919]             `[[` <- base::`[[`
[13:17:28.919]             `+` <- base::`+`
[13:17:28.919]             `<<-` <- base::`<<-`
[13:17:28.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.919]                   3L)]
[13:17:28.919]             }
[13:17:28.919]             function(cond) {
[13:17:28.919]                 is_error <- inherits(cond, "error")
[13:17:28.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.919]                   NULL)
[13:17:28.919]                 if (is_error) {
[13:17:28.919]                   sessionInformation <- function() {
[13:17:28.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.919]                       search = base::search(), system = base::Sys.info())
[13:17:28.919]                   }
[13:17:28.919]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.919]                     cond$call), session = sessionInformation(), 
[13:17:28.919]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.919]                   signalCondition(cond)
[13:17:28.919]                 }
[13:17:28.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.919]                 "immediateCondition"))) {
[13:17:28.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.919]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.919]                   if (TRUE && !signal) {
[13:17:28.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.919]                     {
[13:17:28.919]                       inherits <- base::inherits
[13:17:28.919]                       invokeRestart <- base::invokeRestart
[13:17:28.919]                       is.null <- base::is.null
[13:17:28.919]                       muffled <- FALSE
[13:17:28.919]                       if (inherits(cond, "message")) {
[13:17:28.919]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.919]                         if (muffled) 
[13:17:28.919]                           invokeRestart("muffleMessage")
[13:17:28.919]                       }
[13:17:28.919]                       else if (inherits(cond, "warning")) {
[13:17:28.919]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.919]                         if (muffled) 
[13:17:28.919]                           invokeRestart("muffleWarning")
[13:17:28.919]                       }
[13:17:28.919]                       else if (inherits(cond, "condition")) {
[13:17:28.919]                         if (!is.null(pattern)) {
[13:17:28.919]                           computeRestarts <- base::computeRestarts
[13:17:28.919]                           grepl <- base::grepl
[13:17:28.919]                           restarts <- computeRestarts(cond)
[13:17:28.919]                           for (restart in restarts) {
[13:17:28.919]                             name <- restart$name
[13:17:28.919]                             if (is.null(name)) 
[13:17:28.919]                               next
[13:17:28.919]                             if (!grepl(pattern, name)) 
[13:17:28.919]                               next
[13:17:28.919]                             invokeRestart(restart)
[13:17:28.919]                             muffled <- TRUE
[13:17:28.919]                             break
[13:17:28.919]                           }
[13:17:28.919]                         }
[13:17:28.919]                       }
[13:17:28.919]                       invisible(muffled)
[13:17:28.919]                     }
[13:17:28.919]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.919]                   }
[13:17:28.919]                 }
[13:17:28.919]                 else {
[13:17:28.919]                   if (TRUE) {
[13:17:28.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.919]                     {
[13:17:28.919]                       inherits <- base::inherits
[13:17:28.919]                       invokeRestart <- base::invokeRestart
[13:17:28.919]                       is.null <- base::is.null
[13:17:28.919]                       muffled <- FALSE
[13:17:28.919]                       if (inherits(cond, "message")) {
[13:17:28.919]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.919]                         if (muffled) 
[13:17:28.919]                           invokeRestart("muffleMessage")
[13:17:28.919]                       }
[13:17:28.919]                       else if (inherits(cond, "warning")) {
[13:17:28.919]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.919]                         if (muffled) 
[13:17:28.919]                           invokeRestart("muffleWarning")
[13:17:28.919]                       }
[13:17:28.919]                       else if (inherits(cond, "condition")) {
[13:17:28.919]                         if (!is.null(pattern)) {
[13:17:28.919]                           computeRestarts <- base::computeRestarts
[13:17:28.919]                           grepl <- base::grepl
[13:17:28.919]                           restarts <- computeRestarts(cond)
[13:17:28.919]                           for (restart in restarts) {
[13:17:28.919]                             name <- restart$name
[13:17:28.919]                             if (is.null(name)) 
[13:17:28.919]                               next
[13:17:28.919]                             if (!grepl(pattern, name)) 
[13:17:28.919]                               next
[13:17:28.919]                             invokeRestart(restart)
[13:17:28.919]                             muffled <- TRUE
[13:17:28.919]                             break
[13:17:28.919]                           }
[13:17:28.919]                         }
[13:17:28.919]                       }
[13:17:28.919]                       invisible(muffled)
[13:17:28.919]                     }
[13:17:28.919]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.919]                   }
[13:17:28.919]                 }
[13:17:28.919]             }
[13:17:28.919]         }))
[13:17:28.919]     }, error = function(ex) {
[13:17:28.919]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.919]                 ...future.rng), started = ...future.startTime, 
[13:17:28.919]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.919]             version = "1.8"), class = "FutureResult")
[13:17:28.919]     }, finally = {
[13:17:28.919]         if (!identical(...future.workdir, getwd())) 
[13:17:28.919]             setwd(...future.workdir)
[13:17:28.919]         {
[13:17:28.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.919]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.919]             }
[13:17:28.919]             base::options(...future.oldOptions)
[13:17:28.919]             if (.Platform$OS.type == "windows") {
[13:17:28.919]                 old_names <- names(...future.oldEnvVars)
[13:17:28.919]                 envs <- base::Sys.getenv()
[13:17:28.919]                 names <- names(envs)
[13:17:28.919]                 common <- intersect(names, old_names)
[13:17:28.919]                 added <- setdiff(names, old_names)
[13:17:28.919]                 removed <- setdiff(old_names, names)
[13:17:28.919]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.919]                   envs[common]]
[13:17:28.919]                 NAMES <- toupper(changed)
[13:17:28.919]                 args <- list()
[13:17:28.919]                 for (kk in seq_along(NAMES)) {
[13:17:28.919]                   name <- changed[[kk]]
[13:17:28.919]                   NAME <- NAMES[[kk]]
[13:17:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.919]                     next
[13:17:28.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.919]                 }
[13:17:28.919]                 NAMES <- toupper(added)
[13:17:28.919]                 for (kk in seq_along(NAMES)) {
[13:17:28.919]                   name <- added[[kk]]
[13:17:28.919]                   NAME <- NAMES[[kk]]
[13:17:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.919]                     next
[13:17:28.919]                   args[[name]] <- ""
[13:17:28.919]                 }
[13:17:28.919]                 NAMES <- toupper(removed)
[13:17:28.919]                 for (kk in seq_along(NAMES)) {
[13:17:28.919]                   name <- removed[[kk]]
[13:17:28.919]                   NAME <- NAMES[[kk]]
[13:17:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.919]                     next
[13:17:28.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.919]                 }
[13:17:28.919]                 if (length(args) > 0) 
[13:17:28.919]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.919]             }
[13:17:28.919]             else {
[13:17:28.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.919]             }
[13:17:28.919]             {
[13:17:28.919]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.919]                   0L) {
[13:17:28.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.919]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.919]                   base::options(opts)
[13:17:28.919]                 }
[13:17:28.919]                 {
[13:17:28.919]                   {
[13:17:28.919]                     NULL
[13:17:28.919]                     RNGkind("Mersenne-Twister")
[13:17:28.919]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.919]                       inherits = FALSE)
[13:17:28.919]                   }
[13:17:28.919]                   options(future.plan = NULL)
[13:17:28.919]                   if (is.na(NA_character_)) 
[13:17:28.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.919]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:28.919]                     envir = parent.frame()) 
[13:17:28.919]                   {
[13:17:28.919]                     default_workers <- missing(workers)
[13:17:28.919]                     if (is.function(workers)) 
[13:17:28.919]                       workers <- workers()
[13:17:28.919]                     workers <- structure(as.integer(workers), 
[13:17:28.919]                       class = class(workers))
[13:17:28.919]                     stop_if_not(is.finite(workers), workers >= 
[13:17:28.919]                       1L)
[13:17:28.919]                     if ((workers == 1L && !inherits(workers, 
[13:17:28.919]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:28.919]                       if (default_workers) 
[13:17:28.919]                         supportsMulticore(warn = TRUE)
[13:17:28.919]                       return(sequential(..., envir = envir))
[13:17:28.919]                     }
[13:17:28.919]                     oopts <- options(mc.cores = workers)
[13:17:28.919]                     on.exit(options(oopts))
[13:17:28.919]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:28.919]                       envir = envir)
[13:17:28.919]                     if (!future$lazy) 
[13:17:28.919]                       future <- run(future)
[13:17:28.919]                     invisible(future)
[13:17:28.919]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.919]                 }
[13:17:28.919]             }
[13:17:28.919]         }
[13:17:28.919]     })
[13:17:28.919]     if (TRUE) {
[13:17:28.919]         base::sink(type = "output", split = FALSE)
[13:17:28.919]         if (TRUE) {
[13:17:28.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.919]         }
[13:17:28.919]         else {
[13:17:28.919]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.919]         }
[13:17:28.919]         base::close(...future.stdout)
[13:17:28.919]         ...future.stdout <- NULL
[13:17:28.919]     }
[13:17:28.919]     ...future.result$conditions <- ...future.conditions
[13:17:28.919]     ...future.result$finished <- base::Sys.time()
[13:17:28.919]     ...future.result
[13:17:28.919] }
[13:17:28.921] assign_globals() ...
[13:17:28.921] List of 5
[13:17:28.921]  $ ...future.FUN            :function (object, ...)  
[13:17:28.921]  $ future.call.arguments    :List of 1
[13:17:28.921]   ..$ digits: int 2
[13:17:28.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.921]  $ ...future.elements_ii    :List of 6
[13:17:28.921]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:17:28.921]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:17:28.921]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:17:28.921]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:17:28.921]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:17:28.921]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:17:28.921]  $ ...future.seeds_ii       : NULL
[13:17:28.921]  $ ...future.globals.maxSize: NULL
[13:17:28.921]  - attr(*, "resolved")= logi FALSE
[13:17:28.921]  - attr(*, "total_size")= num 1296
[13:17:28.921]  - attr(*, "where")=List of 5
[13:17:28.921]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.921]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.921]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.921]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.921]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.921]  - attr(*, "already-done")= logi TRUE
[13:17:28.928] - copied ‘...future.FUN’ to environment
[13:17:28.928] - copied ‘future.call.arguments’ to environment
[13:17:28.928] - copied ‘...future.elements_ii’ to environment
[13:17:28.928] - copied ‘...future.seeds_ii’ to environment
[13:17:28.928] - copied ‘...future.globals.maxSize’ to environment
[13:17:28.928] assign_globals() ... done
[13:17:28.929] plan(): Setting new future strategy stack:
[13:17:28.929] List of future strategies:
[13:17:28.929] 1. sequential:
[13:17:28.929]    - args: function (..., envir = parent.frame())
[13:17:28.929]    - tweaked: FALSE
[13:17:28.929]    - call: NULL
[13:17:28.929] plan(): nbrOfWorkers() = 1
[13:17:28.930] plan(): Setting new future strategy stack:
[13:17:28.930] List of future strategies:
[13:17:28.930] 1. multicore:
[13:17:28.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:28.930]    - tweaked: FALSE
[13:17:28.930]    - call: plan(strategy)
[13:17:28.934] plan(): nbrOfWorkers() = 1
[13:17:28.934] SequentialFuture started (and completed)
[13:17:28.935] - Launch lazy future ... done
[13:17:28.935] run() for ‘SequentialFuture’ ... done
[13:17:28.935] Created future:
[13:17:28.935] SequentialFuture:
[13:17:28.935] Label: ‘future_by-1’
[13:17:28.935] Expression:
[13:17:28.935] {
[13:17:28.935]     do.call(function(...) {
[13:17:28.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.935]             on.exit(options(oopts), add = TRUE)
[13:17:28.935]         }
[13:17:28.935]         {
[13:17:28.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.935]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.935]             })
[13:17:28.935]         }
[13:17:28.935]     }, args = future.call.arguments)
[13:17:28.935] }
[13:17:28.935] Lazy evaluation: FALSE
[13:17:28.935] Asynchronous evaluation: FALSE
[13:17:28.935] Local evaluation: TRUE
[13:17:28.935] Environment: R_GlobalEnv
[13:17:28.935] Capture standard output: TRUE
[13:17:28.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:28.935] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.935] Packages: <none>
[13:17:28.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:28.935] Resolved: TRUE
[13:17:28.935] Value: 5.48 KiB of class ‘list’
[13:17:28.935] Early signaling: FALSE
[13:17:28.935] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:28.935] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.936] Chunk #1 of 1 ... DONE
[13:17:28.936] Launching 1 futures (chunks) ... DONE
[13:17:28.936] Resolving 1 futures (chunks) ...
[13:17:28.936] resolve() on list ...
[13:17:28.937]  recursive: 0
[13:17:28.937]  length: 1
[13:17:28.937] 
[13:17:28.937] resolved() for ‘SequentialFuture’ ...
[13:17:28.937] - state: ‘finished’
[13:17:28.937] - run: TRUE
[13:17:28.937] - result: ‘FutureResult’
[13:17:28.937] resolved() for ‘SequentialFuture’ ... done
[13:17:28.963] Future #1
[13:17:28.964] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:28.964] - nx: 1
[13:17:28.964] - relay: TRUE
[13:17:28.964] - stdout: TRUE
[13:17:28.964] - signal: TRUE
[13:17:28.964] - resignal: FALSE
[13:17:28.964] - force: TRUE
[13:17:28.964] - relayed: [n=1] FALSE
[13:17:28.964] - queued futures: [n=1] FALSE
[13:17:28.964]  - until=1
[13:17:28.965]  - relaying element #1
[13:17:28.965] - relayed: [n=1] TRUE
[13:17:28.965] - queued futures: [n=1] TRUE
[13:17:28.965] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:28.965]  length: 0 (resolved future 1)
[13:17:28.965] Relaying remaining futures
[13:17:28.965] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.966] - nx: 1
[13:17:28.966] - relay: TRUE
[13:17:28.966] - stdout: TRUE
[13:17:28.966] - signal: TRUE
[13:17:28.966] - resignal: FALSE
[13:17:28.966] - force: TRUE
[13:17:28.966] - relayed: [n=1] TRUE
[13:17:28.966] - queued futures: [n=1] TRUE
 - flush all
[13:17:28.966] - relayed: [n=1] TRUE
[13:17:28.966] - queued futures: [n=1] TRUE
[13:17:28.966] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.966] resolve() on list ... DONE
[13:17:28.967]  - Number of value chunks collected: 1
[13:17:28.967] Resolving 1 futures (chunks) ... DONE
[13:17:28.967] Reducing values from 1 chunks ...
[13:17:28.967]  - Number of values collected after concatenation: 6
[13:17:28.967]  - Number of values expected: 6
[13:17:28.967] Reducing values from 1 chunks ... DONE
[13:17:28.967] future_lapply() ... DONE
[13:17:28.967] future_by_internal() ... DONE
[13:17:28.968] future_by_internal() ...
[13:17:28.969] future_lapply() ...
[13:17:28.973] Number of chunks: 1
[13:17:28.973] getGlobalsAndPackagesXApply() ...
[13:17:28.973]  - future.globals: TRUE
[13:17:28.973] getGlobalsAndPackages() ...
[13:17:28.973] Searching for globals...
[13:17:28.975] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:28.975] Searching for globals ... DONE
[13:17:28.975] Resolving globals: FALSE
[13:17:28.976] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:17:28.976] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:17:28.976] - globals: [1] ‘FUN’
[13:17:28.976] - packages: [1] ‘stats’
[13:17:28.976] getGlobalsAndPackages() ... DONE
[13:17:28.976]  - globals found/used: [n=1] ‘FUN’
[13:17:28.977]  - needed namespaces: [n=1] ‘stats’
[13:17:28.977] Finding globals ... DONE
[13:17:28.977]  - use_args: TRUE
[13:17:28.977]  - Getting '...' globals ...
[13:17:28.977] resolve() on list ...
[13:17:28.977]  recursive: 0
[13:17:28.977]  length: 1
[13:17:28.977]  elements: ‘...’
[13:17:28.977]  length: 0 (resolved future 1)
[13:17:28.978] resolve() on list ... DONE
[13:17:28.978]    - '...' content: [n=1] ‘singular.ok’
[13:17:28.978] List of 1
[13:17:28.978]  $ ...:List of 1
[13:17:28.978]   ..$ singular.ok: logi FALSE
[13:17:28.978]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.978]  - attr(*, "where")=List of 1
[13:17:28.978]   ..$ ...:<environment: 0x5609e8bb53c0> 
[13:17:28.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.978]  - attr(*, "resolved")= logi TRUE
[13:17:28.978]  - attr(*, "total_size")= num NA
[13:17:28.981]  - Getting '...' globals ... DONE
[13:17:28.981] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:28.981] List of 2
[13:17:28.981]  $ ...future.FUN:function (x, ...)  
[13:17:28.981]  $ ...          :List of 1
[13:17:28.981]   ..$ singular.ok: logi FALSE
[13:17:28.981]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.981]  - attr(*, "where")=List of 2
[13:17:28.981]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:28.981]   ..$ ...          :<environment: 0x5609e8bb53c0> 
[13:17:28.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.981]  - attr(*, "resolved")= logi FALSE
[13:17:28.981]  - attr(*, "total_size")= num 5384
[13:17:28.984] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:28.984] getGlobalsAndPackagesXApply() ... DONE
[13:17:28.984] Number of futures (= number of chunks): 1
[13:17:28.984] Launching 1 futures (chunks) ...
[13:17:28.985] Chunk #1 of 1 ...
[13:17:28.985]  - Finding globals in 'X' for chunk #1 ...
[13:17:28.985] getGlobalsAndPackages() ...
[13:17:28.985] Searching for globals...
[13:17:28.985] 
[13:17:28.985] Searching for globals ... DONE
[13:17:28.986] - globals: [0] <none>
[13:17:28.986] getGlobalsAndPackages() ... DONE
[13:17:28.986]    + additional globals found: [n=0] 
[13:17:28.986]    + additional namespaces needed: [n=0] 
[13:17:28.986]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:28.987]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:28.987]  - seeds: <none>
[13:17:28.987] getGlobalsAndPackages() ...
[13:17:28.988] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.988] Resolving globals: FALSE
[13:17:28.988] Tweak future expression to call with '...' arguments ...
[13:17:28.988] {
[13:17:28.988]     do.call(function(...) {
[13:17:28.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.988]             on.exit(options(oopts), add = TRUE)
[13:17:28.988]         }
[13:17:28.988]         {
[13:17:28.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.988]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.988]             })
[13:17:28.988]         }
[13:17:28.988]     }, args = future.call.arguments)
[13:17:28.988] }
[13:17:28.988] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.989] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.989] 
[13:17:28.989] getGlobalsAndPackages() ... DONE
[13:17:28.989] run() for ‘Future’ ...
[13:17:28.989] - state: ‘created’
[13:17:28.989] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:28.993] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:28.993] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:28.993]   - Field: ‘label’
[13:17:28.993]   - Field: ‘local’
[13:17:28.993]   - Field: ‘owner’
[13:17:28.993]   - Field: ‘envir’
[13:17:28.994]   - Field: ‘packages’
[13:17:28.994]   - Field: ‘gc’
[13:17:28.994]   - Field: ‘conditions’
[13:17:28.994]   - Field: ‘expr’
[13:17:28.994]   - Field: ‘uuid’
[13:17:28.994]   - Field: ‘seed’
[13:17:28.994]   - Field: ‘version’
[13:17:28.994]   - Field: ‘result’
[13:17:28.994]   - Field: ‘asynchronous’
[13:17:28.994]   - Field: ‘calls’
[13:17:28.994]   - Field: ‘globals’
[13:17:28.995]   - Field: ‘stdout’
[13:17:28.995]   - Field: ‘earlySignal’
[13:17:28.995]   - Field: ‘lazy’
[13:17:28.995]   - Field: ‘state’
[13:17:28.995] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:28.995] - Launch lazy future ...
[13:17:28.995] Packages needed by the future expression (n = 1): ‘stats’
[13:17:28.995] Packages needed by future strategies (n = 0): <none>
[13:17:28.996] {
[13:17:28.996]     {
[13:17:28.996]         {
[13:17:28.996]             ...future.startTime <- base::Sys.time()
[13:17:28.996]             {
[13:17:28.996]                 {
[13:17:28.996]                   {
[13:17:28.996]                     {
[13:17:28.996]                       base::local({
[13:17:28.996]                         has_future <- base::requireNamespace("future", 
[13:17:28.996]                           quietly = TRUE)
[13:17:28.996]                         if (has_future) {
[13:17:28.996]                           ns <- base::getNamespace("future")
[13:17:28.996]                           version <- ns[[".package"]][["version"]]
[13:17:28.996]                           if (is.null(version)) 
[13:17:28.996]                             version <- utils::packageVersion("future")
[13:17:28.996]                         }
[13:17:28.996]                         else {
[13:17:28.996]                           version <- NULL
[13:17:28.996]                         }
[13:17:28.996]                         if (!has_future || version < "1.8.0") {
[13:17:28.996]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.996]                             "", base::R.version$version.string), 
[13:17:28.996]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:28.996]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.996]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.996]                               "release", "version")], collapse = " "), 
[13:17:28.996]                             hostname = base::Sys.info()[["nodename"]])
[13:17:28.996]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.996]                             info)
[13:17:28.996]                           info <- base::paste(info, collapse = "; ")
[13:17:28.996]                           if (!has_future) {
[13:17:28.996]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.996]                               info)
[13:17:28.996]                           }
[13:17:28.996]                           else {
[13:17:28.996]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.996]                               info, version)
[13:17:28.996]                           }
[13:17:28.996]                           base::stop(msg)
[13:17:28.996]                         }
[13:17:28.996]                       })
[13:17:28.996]                     }
[13:17:28.996]                     base::local({
[13:17:28.996]                       for (pkg in "stats") {
[13:17:28.996]                         base::loadNamespace(pkg)
[13:17:28.996]                         base::library(pkg, character.only = TRUE)
[13:17:28.996]                       }
[13:17:28.996]                     })
[13:17:28.996]                   }
[13:17:28.996]                   options(future.plan = NULL)
[13:17:28.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.996]                 }
[13:17:28.996]                 ...future.workdir <- getwd()
[13:17:28.996]             }
[13:17:28.996]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.996]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.996]         }
[13:17:28.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.996]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:28.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.996]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.996]             base::names(...future.oldOptions))
[13:17:28.996]     }
[13:17:28.996]     if (FALSE) {
[13:17:28.996]     }
[13:17:28.996]     else {
[13:17:28.996]         if (TRUE) {
[13:17:28.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.996]                 open = "w")
[13:17:28.996]         }
[13:17:28.996]         else {
[13:17:28.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.996]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.996]         }
[13:17:28.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.996]             base::sink(type = "output", split = FALSE)
[13:17:28.996]             base::close(...future.stdout)
[13:17:28.996]         }, add = TRUE)
[13:17:28.996]     }
[13:17:28.996]     ...future.frame <- base::sys.nframe()
[13:17:28.996]     ...future.conditions <- base::list()
[13:17:28.996]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.996]     if (FALSE) {
[13:17:28.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.996]     }
[13:17:28.996]     ...future.result <- base::tryCatch({
[13:17:28.996]         base::withCallingHandlers({
[13:17:28.996]             ...future.value <- base::withVisible(base::local({
[13:17:28.996]                 do.call(function(...) {
[13:17:28.996]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.996]                   if (!identical(...future.globals.maxSize.org, 
[13:17:28.996]                     ...future.globals.maxSize)) {
[13:17:28.996]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.996]                     on.exit(options(oopts), add = TRUE)
[13:17:28.996]                   }
[13:17:28.996]                   {
[13:17:28.996]                     lapply(seq_along(...future.elements_ii), 
[13:17:28.996]                       FUN = function(jj) {
[13:17:28.996]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.996]                         ...future.FUN(...future.X_jj, ...)
[13:17:28.996]                       })
[13:17:28.996]                   }
[13:17:28.996]                 }, args = future.call.arguments)
[13:17:28.996]             }))
[13:17:28.996]             future::FutureResult(value = ...future.value$value, 
[13:17:28.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.996]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.996]                     ...future.globalenv.names))
[13:17:28.996]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.996]         }, condition = base::local({
[13:17:28.996]             c <- base::c
[13:17:28.996]             inherits <- base::inherits
[13:17:28.996]             invokeRestart <- base::invokeRestart
[13:17:28.996]             length <- base::length
[13:17:28.996]             list <- base::list
[13:17:28.996]             seq.int <- base::seq.int
[13:17:28.996]             signalCondition <- base::signalCondition
[13:17:28.996]             sys.calls <- base::sys.calls
[13:17:28.996]             `[[` <- base::`[[`
[13:17:28.996]             `+` <- base::`+`
[13:17:28.996]             `<<-` <- base::`<<-`
[13:17:28.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.996]                   3L)]
[13:17:28.996]             }
[13:17:28.996]             function(cond) {
[13:17:28.996]                 is_error <- inherits(cond, "error")
[13:17:28.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.996]                   NULL)
[13:17:28.996]                 if (is_error) {
[13:17:28.996]                   sessionInformation <- function() {
[13:17:28.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.996]                       search = base::search(), system = base::Sys.info())
[13:17:28.996]                   }
[13:17:28.996]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.996]                     cond$call), session = sessionInformation(), 
[13:17:28.996]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.996]                   signalCondition(cond)
[13:17:28.996]                 }
[13:17:28.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:28.996]                 "immediateCondition"))) {
[13:17:28.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.996]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.996]                   if (TRUE && !signal) {
[13:17:28.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.996]                     {
[13:17:28.996]                       inherits <- base::inherits
[13:17:28.996]                       invokeRestart <- base::invokeRestart
[13:17:28.996]                       is.null <- base::is.null
[13:17:28.996]                       muffled <- FALSE
[13:17:28.996]                       if (inherits(cond, "message")) {
[13:17:28.996]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.996]                         if (muffled) 
[13:17:28.996]                           invokeRestart("muffleMessage")
[13:17:28.996]                       }
[13:17:28.996]                       else if (inherits(cond, "warning")) {
[13:17:28.996]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.996]                         if (muffled) 
[13:17:28.996]                           invokeRestart("muffleWarning")
[13:17:28.996]                       }
[13:17:28.996]                       else if (inherits(cond, "condition")) {
[13:17:28.996]                         if (!is.null(pattern)) {
[13:17:28.996]                           computeRestarts <- base::computeRestarts
[13:17:28.996]                           grepl <- base::grepl
[13:17:28.996]                           restarts <- computeRestarts(cond)
[13:17:28.996]                           for (restart in restarts) {
[13:17:28.996]                             name <- restart$name
[13:17:28.996]                             if (is.null(name)) 
[13:17:28.996]                               next
[13:17:28.996]                             if (!grepl(pattern, name)) 
[13:17:28.996]                               next
[13:17:28.996]                             invokeRestart(restart)
[13:17:28.996]                             muffled <- TRUE
[13:17:28.996]                             break
[13:17:28.996]                           }
[13:17:28.996]                         }
[13:17:28.996]                       }
[13:17:28.996]                       invisible(muffled)
[13:17:28.996]                     }
[13:17:28.996]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.996]                   }
[13:17:28.996]                 }
[13:17:28.996]                 else {
[13:17:28.996]                   if (TRUE) {
[13:17:28.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.996]                     {
[13:17:28.996]                       inherits <- base::inherits
[13:17:28.996]                       invokeRestart <- base::invokeRestart
[13:17:28.996]                       is.null <- base::is.null
[13:17:28.996]                       muffled <- FALSE
[13:17:28.996]                       if (inherits(cond, "message")) {
[13:17:28.996]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.996]                         if (muffled) 
[13:17:28.996]                           invokeRestart("muffleMessage")
[13:17:28.996]                       }
[13:17:28.996]                       else if (inherits(cond, "warning")) {
[13:17:28.996]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.996]                         if (muffled) 
[13:17:28.996]                           invokeRestart("muffleWarning")
[13:17:28.996]                       }
[13:17:28.996]                       else if (inherits(cond, "condition")) {
[13:17:28.996]                         if (!is.null(pattern)) {
[13:17:28.996]                           computeRestarts <- base::computeRestarts
[13:17:28.996]                           grepl <- base::grepl
[13:17:28.996]                           restarts <- computeRestarts(cond)
[13:17:28.996]                           for (restart in restarts) {
[13:17:28.996]                             name <- restart$name
[13:17:28.996]                             if (is.null(name)) 
[13:17:28.996]                               next
[13:17:28.996]                             if (!grepl(pattern, name)) 
[13:17:28.996]                               next
[13:17:28.996]                             invokeRestart(restart)
[13:17:28.996]                             muffled <- TRUE
[13:17:28.996]                             break
[13:17:28.996]                           }
[13:17:28.996]                         }
[13:17:28.996]                       }
[13:17:28.996]                       invisible(muffled)
[13:17:28.996]                     }
[13:17:28.996]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.996]                   }
[13:17:28.996]                 }
[13:17:28.996]             }
[13:17:28.996]         }))
[13:17:28.996]     }, error = function(ex) {
[13:17:28.996]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.996]                 ...future.rng), started = ...future.startTime, 
[13:17:28.996]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.996]             version = "1.8"), class = "FutureResult")
[13:17:28.996]     }, finally = {
[13:17:28.996]         if (!identical(...future.workdir, getwd())) 
[13:17:28.996]             setwd(...future.workdir)
[13:17:28.996]         {
[13:17:28.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.996]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.996]             }
[13:17:28.996]             base::options(...future.oldOptions)
[13:17:28.996]             if (.Platform$OS.type == "windows") {
[13:17:28.996]                 old_names <- names(...future.oldEnvVars)
[13:17:28.996]                 envs <- base::Sys.getenv()
[13:17:28.996]                 names <- names(envs)
[13:17:28.996]                 common <- intersect(names, old_names)
[13:17:28.996]                 added <- setdiff(names, old_names)
[13:17:28.996]                 removed <- setdiff(old_names, names)
[13:17:28.996]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.996]                   envs[common]]
[13:17:28.996]                 NAMES <- toupper(changed)
[13:17:28.996]                 args <- list()
[13:17:28.996]                 for (kk in seq_along(NAMES)) {
[13:17:28.996]                   name <- changed[[kk]]
[13:17:28.996]                   NAME <- NAMES[[kk]]
[13:17:28.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.996]                     next
[13:17:28.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.996]                 }
[13:17:28.996]                 NAMES <- toupper(added)
[13:17:28.996]                 for (kk in seq_along(NAMES)) {
[13:17:28.996]                   name <- added[[kk]]
[13:17:28.996]                   NAME <- NAMES[[kk]]
[13:17:28.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.996]                     next
[13:17:28.996]                   args[[name]] <- ""
[13:17:28.996]                 }
[13:17:28.996]                 NAMES <- toupper(removed)
[13:17:28.996]                 for (kk in seq_along(NAMES)) {
[13:17:28.996]                   name <- removed[[kk]]
[13:17:28.996]                   NAME <- NAMES[[kk]]
[13:17:28.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.996]                     next
[13:17:28.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.996]                 }
[13:17:28.996]                 if (length(args) > 0) 
[13:17:28.996]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.996]             }
[13:17:28.996]             else {
[13:17:28.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.996]             }
[13:17:28.996]             {
[13:17:28.996]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.996]                   0L) {
[13:17:28.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.996]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.996]                   base::options(opts)
[13:17:28.996]                 }
[13:17:28.996]                 {
[13:17:28.996]                   {
[13:17:28.996]                     NULL
[13:17:28.996]                     RNGkind("Mersenne-Twister")
[13:17:28.996]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:28.996]                       inherits = FALSE)
[13:17:28.996]                   }
[13:17:28.996]                   options(future.plan = NULL)
[13:17:28.996]                   if (is.na(NA_character_)) 
[13:17:28.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.996]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:28.996]                     envir = parent.frame()) 
[13:17:28.996]                   {
[13:17:28.996]                     default_workers <- missing(workers)
[13:17:28.996]                     if (is.function(workers)) 
[13:17:28.996]                       workers <- workers()
[13:17:28.996]                     workers <- structure(as.integer(workers), 
[13:17:28.996]                       class = class(workers))
[13:17:28.996]                     stop_if_not(is.finite(workers), workers >= 
[13:17:28.996]                       1L)
[13:17:28.996]                     if ((workers == 1L && !inherits(workers, 
[13:17:28.996]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:28.996]                       if (default_workers) 
[13:17:28.996]                         supportsMulticore(warn = TRUE)
[13:17:28.996]                       return(sequential(..., envir = envir))
[13:17:28.996]                     }
[13:17:28.996]                     oopts <- options(mc.cores = workers)
[13:17:28.996]                     on.exit(options(oopts))
[13:17:28.996]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:28.996]                       envir = envir)
[13:17:28.996]                     if (!future$lazy) 
[13:17:28.996]                       future <- run(future)
[13:17:28.996]                     invisible(future)
[13:17:28.996]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.996]                 }
[13:17:28.996]             }
[13:17:28.996]         }
[13:17:28.996]     })
[13:17:28.996]     if (TRUE) {
[13:17:28.996]         base::sink(type = "output", split = FALSE)
[13:17:28.996]         if (TRUE) {
[13:17:28.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.996]         }
[13:17:28.996]         else {
[13:17:28.996]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.996]         }
[13:17:28.996]         base::close(...future.stdout)
[13:17:28.996]         ...future.stdout <- NULL
[13:17:28.996]     }
[13:17:28.996]     ...future.result$conditions <- ...future.conditions
[13:17:28.996]     ...future.result$finished <- base::Sys.time()
[13:17:28.996]     ...future.result
[13:17:28.996] }
[13:17:28.998] assign_globals() ...
[13:17:28.998] List of 5
[13:17:28.998]  $ ...future.FUN            :function (x, ...)  
[13:17:28.998]  $ future.call.arguments    :List of 1
[13:17:28.998]   ..$ singular.ok: logi FALSE
[13:17:28.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:28.998]  $ ...future.elements_ii    :List of 3
[13:17:28.998]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.998]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:28.998]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.998]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:28.998]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.998]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:28.998]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.998]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:28.998]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:28.998]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:28.998]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:28.998]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:28.998]  $ ...future.seeds_ii       : NULL
[13:17:28.998]  $ ...future.globals.maxSize: NULL
[13:17:28.998]  - attr(*, "resolved")= logi FALSE
[13:17:28.998]  - attr(*, "total_size")= num 5384
[13:17:28.998]  - attr(*, "where")=List of 5
[13:17:28.998]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:28.998]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:28.998]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:28.998]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:28.998]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:28.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:28.998]  - attr(*, "already-done")= logi TRUE
[13:17:29.007] - reassign environment for ‘...future.FUN’
[13:17:29.007] - copied ‘...future.FUN’ to environment
[13:17:29.007] - copied ‘future.call.arguments’ to environment
[13:17:29.007] - copied ‘...future.elements_ii’ to environment
[13:17:29.007] - copied ‘...future.seeds_ii’ to environment
[13:17:29.007] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.007] assign_globals() ... done
[13:17:29.007] plan(): Setting new future strategy stack:
[13:17:29.008] List of future strategies:
[13:17:29.008] 1. sequential:
[13:17:29.008]    - args: function (..., envir = parent.frame())
[13:17:29.008]    - tweaked: FALSE
[13:17:29.008]    - call: NULL
[13:17:29.008] plan(): nbrOfWorkers() = 1
[13:17:29.011] plan(): Setting new future strategy stack:
[13:17:29.011] List of future strategies:
[13:17:29.011] 1. multicore:
[13:17:29.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.011]    - tweaked: FALSE
[13:17:29.011]    - call: plan(strategy)
[13:17:29.016] plan(): nbrOfWorkers() = 1
[13:17:29.016] SequentialFuture started (and completed)
[13:17:29.016] - Launch lazy future ... done
[13:17:29.016] run() for ‘SequentialFuture’ ... done
[13:17:29.017] Created future:
[13:17:29.017] SequentialFuture:
[13:17:29.017] Label: ‘future_by-1’
[13:17:29.017] Expression:
[13:17:29.017] {
[13:17:29.017]     do.call(function(...) {
[13:17:29.017]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.017]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.017]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.017]             on.exit(options(oopts), add = TRUE)
[13:17:29.017]         }
[13:17:29.017]         {
[13:17:29.017]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.017]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.017]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.017]             })
[13:17:29.017]         }
[13:17:29.017]     }, args = future.call.arguments)
[13:17:29.017] }
[13:17:29.017] Lazy evaluation: FALSE
[13:17:29.017] Asynchronous evaluation: FALSE
[13:17:29.017] Local evaluation: TRUE
[13:17:29.017] Environment: R_GlobalEnv
[13:17:29.017] Capture standard output: TRUE
[13:17:29.017] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.017] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.017] Packages: 1 packages (‘stats’)
[13:17:29.017] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.017] Resolved: TRUE
[13:17:29.017] Value: 26.06 KiB of class ‘list’
[13:17:29.017] Early signaling: FALSE
[13:17:29.017] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.017] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.018] Chunk #1 of 1 ... DONE
[13:17:29.018] Launching 1 futures (chunks) ... DONE
[13:17:29.018] Resolving 1 futures (chunks) ...
[13:17:29.019] resolve() on list ...
[13:17:29.019]  recursive: 0
[13:17:29.019]  length: 1
[13:17:29.019] 
[13:17:29.019] resolved() for ‘SequentialFuture’ ...
[13:17:29.019] - state: ‘finished’
[13:17:29.019] - run: TRUE
[13:17:29.019] - result: ‘FutureResult’
[13:17:29.019] resolved() for ‘SequentialFuture’ ... done
[13:17:29.019] Future #1
[13:17:29.020] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.020] - nx: 1
[13:17:29.020] - relay: TRUE
[13:17:29.020] - stdout: TRUE
[13:17:29.020] - signal: TRUE
[13:17:29.020] - resignal: FALSE
[13:17:29.020] - force: TRUE
[13:17:29.020] - relayed: [n=1] FALSE
[13:17:29.020] - queued futures: [n=1] FALSE
[13:17:29.020]  - until=1
[13:17:29.020]  - relaying element #1
[13:17:29.021] - relayed: [n=1] TRUE
[13:17:29.021] - queued futures: [n=1] TRUE
[13:17:29.021] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.021]  length: 0 (resolved future 1)
[13:17:29.021] Relaying remaining futures
[13:17:29.021] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.021] - nx: 1
[13:17:29.021] - relay: TRUE
[13:17:29.021] - stdout: TRUE
[13:17:29.021] - signal: TRUE
[13:17:29.022] - resignal: FALSE
[13:17:29.022] - force: TRUE
[13:17:29.022] - relayed: [n=1] TRUE
[13:17:29.022] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.022] - relayed: [n=1] TRUE
[13:17:29.022] - queued futures: [n=1] TRUE
[13:17:29.022] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.022] resolve() on list ... DONE
[13:17:29.022]  - Number of value chunks collected: 1
[13:17:29.022] Resolving 1 futures (chunks) ... DONE
[13:17:29.022] Reducing values from 1 chunks ...
[13:17:29.023]  - Number of values collected after concatenation: 3
[13:17:29.023]  - Number of values expected: 3
[13:17:29.023] Reducing values from 1 chunks ... DONE
[13:17:29.023] future_lapply() ... DONE
[13:17:29.023] future_by_internal() ... DONE
[13:17:29.027] future_by_internal() ...
[13:17:29.027] future_lapply() ...
[13:17:29.031] Number of chunks: 1
[13:17:29.031] getGlobalsAndPackagesXApply() ...
[13:17:29.031]  - future.globals: TRUE
[13:17:29.031] getGlobalsAndPackages() ...
[13:17:29.032] Searching for globals...
[13:17:29.033] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:29.033] Searching for globals ... DONE
[13:17:29.033] Resolving globals: FALSE
[13:17:29.034] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:17:29.034] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:17:29.034] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:29.035] - packages: [1] ‘stats’
[13:17:29.035] getGlobalsAndPackages() ... DONE
[13:17:29.035]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:29.035]  - needed namespaces: [n=1] ‘stats’
[13:17:29.035] Finding globals ... DONE
[13:17:29.035]  - use_args: TRUE
[13:17:29.035]  - Getting '...' globals ...
[13:17:29.035] resolve() on list ...
[13:17:29.035]  recursive: 0
[13:17:29.036]  length: 1
[13:17:29.036]  elements: ‘...’
[13:17:29.036]  length: 0 (resolved future 1)
[13:17:29.036] resolve() on list ... DONE
[13:17:29.036]    - '...' content: [n=0] 
[13:17:29.037] List of 1
[13:17:29.037]  $ ...: list()
[13:17:29.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.037]  - attr(*, "where")=List of 1
[13:17:29.037]   ..$ ...:<environment: 0x5609ea55d820> 
[13:17:29.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.037]  - attr(*, "resolved")= logi TRUE
[13:17:29.037]  - attr(*, "total_size")= num NA
[13:17:29.040]  - Getting '...' globals ... DONE
[13:17:29.040] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:17:29.040] List of 4
[13:17:29.040]  $ ...future.FUN:function (x)  
[13:17:29.040]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:29.040]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.040]  $ ...          : list()
[13:17:29.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.040]  - attr(*, "where")=List of 4
[13:17:29.040]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.040]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:17:29.040]   ..$ wool         :<environment: R_EmptyEnv> 
[13:17:29.040]   ..$ ...          :<environment: 0x5609ea55d820> 
[13:17:29.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.040]  - attr(*, "resolved")= logi FALSE
[13:17:29.040]  - attr(*, "total_size")= num 2320
[13:17:29.044] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:29.044] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.044] Number of futures (= number of chunks): 1
[13:17:29.044] Launching 1 futures (chunks) ...
[13:17:29.044] Chunk #1 of 1 ...
[13:17:29.044]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.045] getGlobalsAndPackages() ...
[13:17:29.045] Searching for globals...
[13:17:29.045] 
[13:17:29.045] Searching for globals ... DONE
[13:17:29.045] - globals: [0] <none>
[13:17:29.045] getGlobalsAndPackages() ... DONE
[13:17:29.046]    + additional globals found: [n=0] 
[13:17:29.046]    + additional namespaces needed: [n=0] 
[13:17:29.046]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.046]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.046]  - seeds: <none>
[13:17:29.046] getGlobalsAndPackages() ...
[13:17:29.046] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.046] Resolving globals: FALSE
[13:17:29.046] Tweak future expression to call with '...' arguments ...
[13:17:29.046] {
[13:17:29.046]     do.call(function(...) {
[13:17:29.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.046]             on.exit(options(oopts), add = TRUE)
[13:17:29.046]         }
[13:17:29.046]         {
[13:17:29.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.046]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.046]             })
[13:17:29.046]         }
[13:17:29.046]     }, args = future.call.arguments)
[13:17:29.046] }
[13:17:29.047] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.047] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.047] 
[13:17:29.047] getGlobalsAndPackages() ... DONE
[13:17:29.048] run() for ‘Future’ ...
[13:17:29.048] - state: ‘created’
[13:17:29.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.051] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.052]   - Field: ‘label’
[13:17:29.052]   - Field: ‘local’
[13:17:29.052]   - Field: ‘owner’
[13:17:29.052]   - Field: ‘envir’
[13:17:29.052]   - Field: ‘packages’
[13:17:29.052]   - Field: ‘gc’
[13:17:29.052]   - Field: ‘conditions’
[13:17:29.052]   - Field: ‘expr’
[13:17:29.052]   - Field: ‘uuid’
[13:17:29.052]   - Field: ‘seed’
[13:17:29.053]   - Field: ‘version’
[13:17:29.053]   - Field: ‘result’
[13:17:29.053]   - Field: ‘asynchronous’
[13:17:29.053]   - Field: ‘calls’
[13:17:29.053]   - Field: ‘globals’
[13:17:29.053]   - Field: ‘stdout’
[13:17:29.053]   - Field: ‘earlySignal’
[13:17:29.053]   - Field: ‘lazy’
[13:17:29.053]   - Field: ‘state’
[13:17:29.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.053] - Launch lazy future ...
[13:17:29.054] Packages needed by the future expression (n = 1): ‘stats’
[13:17:29.054] Packages needed by future strategies (n = 0): <none>
[13:17:29.054] {
[13:17:29.054]     {
[13:17:29.054]         {
[13:17:29.054]             ...future.startTime <- base::Sys.time()
[13:17:29.054]             {
[13:17:29.054]                 {
[13:17:29.054]                   {
[13:17:29.054]                     {
[13:17:29.054]                       base::local({
[13:17:29.054]                         has_future <- base::requireNamespace("future", 
[13:17:29.054]                           quietly = TRUE)
[13:17:29.054]                         if (has_future) {
[13:17:29.054]                           ns <- base::getNamespace("future")
[13:17:29.054]                           version <- ns[[".package"]][["version"]]
[13:17:29.054]                           if (is.null(version)) 
[13:17:29.054]                             version <- utils::packageVersion("future")
[13:17:29.054]                         }
[13:17:29.054]                         else {
[13:17:29.054]                           version <- NULL
[13:17:29.054]                         }
[13:17:29.054]                         if (!has_future || version < "1.8.0") {
[13:17:29.054]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.054]                             "", base::R.version$version.string), 
[13:17:29.054]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.054]                               "release", "version")], collapse = " "), 
[13:17:29.054]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.054]                             info)
[13:17:29.054]                           info <- base::paste(info, collapse = "; ")
[13:17:29.054]                           if (!has_future) {
[13:17:29.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.054]                               info)
[13:17:29.054]                           }
[13:17:29.054]                           else {
[13:17:29.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.054]                               info, version)
[13:17:29.054]                           }
[13:17:29.054]                           base::stop(msg)
[13:17:29.054]                         }
[13:17:29.054]                       })
[13:17:29.054]                     }
[13:17:29.054]                     base::local({
[13:17:29.054]                       for (pkg in "stats") {
[13:17:29.054]                         base::loadNamespace(pkg)
[13:17:29.054]                         base::library(pkg, character.only = TRUE)
[13:17:29.054]                       }
[13:17:29.054]                     })
[13:17:29.054]                   }
[13:17:29.054]                   options(future.plan = NULL)
[13:17:29.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.054]                 }
[13:17:29.054]                 ...future.workdir <- getwd()
[13:17:29.054]             }
[13:17:29.054]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.054]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.054]         }
[13:17:29.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.054]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.054]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.054]             base::names(...future.oldOptions))
[13:17:29.054]     }
[13:17:29.054]     if (FALSE) {
[13:17:29.054]     }
[13:17:29.054]     else {
[13:17:29.054]         if (TRUE) {
[13:17:29.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.054]                 open = "w")
[13:17:29.054]         }
[13:17:29.054]         else {
[13:17:29.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.054]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.054]         }
[13:17:29.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.054]             base::sink(type = "output", split = FALSE)
[13:17:29.054]             base::close(...future.stdout)
[13:17:29.054]         }, add = TRUE)
[13:17:29.054]     }
[13:17:29.054]     ...future.frame <- base::sys.nframe()
[13:17:29.054]     ...future.conditions <- base::list()
[13:17:29.054]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.054]     if (FALSE) {
[13:17:29.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.054]     }
[13:17:29.054]     ...future.result <- base::tryCatch({
[13:17:29.054]         base::withCallingHandlers({
[13:17:29.054]             ...future.value <- base::withVisible(base::local({
[13:17:29.054]                 do.call(function(...) {
[13:17:29.054]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.054]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.054]                     ...future.globals.maxSize)) {
[13:17:29.054]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.054]                     on.exit(options(oopts), add = TRUE)
[13:17:29.054]                   }
[13:17:29.054]                   {
[13:17:29.054]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.054]                       FUN = function(jj) {
[13:17:29.054]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.054]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.054]                       })
[13:17:29.054]                   }
[13:17:29.054]                 }, args = future.call.arguments)
[13:17:29.054]             }))
[13:17:29.054]             future::FutureResult(value = ...future.value$value, 
[13:17:29.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.054]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.054]                     ...future.globalenv.names))
[13:17:29.054]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.054]         }, condition = base::local({
[13:17:29.054]             c <- base::c
[13:17:29.054]             inherits <- base::inherits
[13:17:29.054]             invokeRestart <- base::invokeRestart
[13:17:29.054]             length <- base::length
[13:17:29.054]             list <- base::list
[13:17:29.054]             seq.int <- base::seq.int
[13:17:29.054]             signalCondition <- base::signalCondition
[13:17:29.054]             sys.calls <- base::sys.calls
[13:17:29.054]             `[[` <- base::`[[`
[13:17:29.054]             `+` <- base::`+`
[13:17:29.054]             `<<-` <- base::`<<-`
[13:17:29.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.054]                   3L)]
[13:17:29.054]             }
[13:17:29.054]             function(cond) {
[13:17:29.054]                 is_error <- inherits(cond, "error")
[13:17:29.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.054]                   NULL)
[13:17:29.054]                 if (is_error) {
[13:17:29.054]                   sessionInformation <- function() {
[13:17:29.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.054]                       search = base::search(), system = base::Sys.info())
[13:17:29.054]                   }
[13:17:29.054]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.054]                     cond$call), session = sessionInformation(), 
[13:17:29.054]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.054]                   signalCondition(cond)
[13:17:29.054]                 }
[13:17:29.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.054]                 "immediateCondition"))) {
[13:17:29.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.054]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.054]                   if (TRUE && !signal) {
[13:17:29.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.054]                     {
[13:17:29.054]                       inherits <- base::inherits
[13:17:29.054]                       invokeRestart <- base::invokeRestart
[13:17:29.054]                       is.null <- base::is.null
[13:17:29.054]                       muffled <- FALSE
[13:17:29.054]                       if (inherits(cond, "message")) {
[13:17:29.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.054]                         if (muffled) 
[13:17:29.054]                           invokeRestart("muffleMessage")
[13:17:29.054]                       }
[13:17:29.054]                       else if (inherits(cond, "warning")) {
[13:17:29.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.054]                         if (muffled) 
[13:17:29.054]                           invokeRestart("muffleWarning")
[13:17:29.054]                       }
[13:17:29.054]                       else if (inherits(cond, "condition")) {
[13:17:29.054]                         if (!is.null(pattern)) {
[13:17:29.054]                           computeRestarts <- base::computeRestarts
[13:17:29.054]                           grepl <- base::grepl
[13:17:29.054]                           restarts <- computeRestarts(cond)
[13:17:29.054]                           for (restart in restarts) {
[13:17:29.054]                             name <- restart$name
[13:17:29.054]                             if (is.null(name)) 
[13:17:29.054]                               next
[13:17:29.054]                             if (!grepl(pattern, name)) 
[13:17:29.054]                               next
[13:17:29.054]                             invokeRestart(restart)
[13:17:29.054]                             muffled <- TRUE
[13:17:29.054]                             break
[13:17:29.054]                           }
[13:17:29.054]                         }
[13:17:29.054]                       }
[13:17:29.054]                       invisible(muffled)
[13:17:29.054]                     }
[13:17:29.054]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.054]                   }
[13:17:29.054]                 }
[13:17:29.054]                 else {
[13:17:29.054]                   if (TRUE) {
[13:17:29.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.054]                     {
[13:17:29.054]                       inherits <- base::inherits
[13:17:29.054]                       invokeRestart <- base::invokeRestart
[13:17:29.054]                       is.null <- base::is.null
[13:17:29.054]                       muffled <- FALSE
[13:17:29.054]                       if (inherits(cond, "message")) {
[13:17:29.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.054]                         if (muffled) 
[13:17:29.054]                           invokeRestart("muffleMessage")
[13:17:29.054]                       }
[13:17:29.054]                       else if (inherits(cond, "warning")) {
[13:17:29.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.054]                         if (muffled) 
[13:17:29.054]                           invokeRestart("muffleWarning")
[13:17:29.054]                       }
[13:17:29.054]                       else if (inherits(cond, "condition")) {
[13:17:29.054]                         if (!is.null(pattern)) {
[13:17:29.054]                           computeRestarts <- base::computeRestarts
[13:17:29.054]                           grepl <- base::grepl
[13:17:29.054]                           restarts <- computeRestarts(cond)
[13:17:29.054]                           for (restart in restarts) {
[13:17:29.054]                             name <- restart$name
[13:17:29.054]                             if (is.null(name)) 
[13:17:29.054]                               next
[13:17:29.054]                             if (!grepl(pattern, name)) 
[13:17:29.054]                               next
[13:17:29.054]                             invokeRestart(restart)
[13:17:29.054]                             muffled <- TRUE
[13:17:29.054]                             break
[13:17:29.054]                           }
[13:17:29.054]                         }
[13:17:29.054]                       }
[13:17:29.054]                       invisible(muffled)
[13:17:29.054]                     }
[13:17:29.054]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.054]                   }
[13:17:29.054]                 }
[13:17:29.054]             }
[13:17:29.054]         }))
[13:17:29.054]     }, error = function(ex) {
[13:17:29.054]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.054]                 ...future.rng), started = ...future.startTime, 
[13:17:29.054]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.054]             version = "1.8"), class = "FutureResult")
[13:17:29.054]     }, finally = {
[13:17:29.054]         if (!identical(...future.workdir, getwd())) 
[13:17:29.054]             setwd(...future.workdir)
[13:17:29.054]         {
[13:17:29.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.054]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.054]             }
[13:17:29.054]             base::options(...future.oldOptions)
[13:17:29.054]             if (.Platform$OS.type == "windows") {
[13:17:29.054]                 old_names <- names(...future.oldEnvVars)
[13:17:29.054]                 envs <- base::Sys.getenv()
[13:17:29.054]                 names <- names(envs)
[13:17:29.054]                 common <- intersect(names, old_names)
[13:17:29.054]                 added <- setdiff(names, old_names)
[13:17:29.054]                 removed <- setdiff(old_names, names)
[13:17:29.054]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.054]                   envs[common]]
[13:17:29.054]                 NAMES <- toupper(changed)
[13:17:29.054]                 args <- list()
[13:17:29.054]                 for (kk in seq_along(NAMES)) {
[13:17:29.054]                   name <- changed[[kk]]
[13:17:29.054]                   NAME <- NAMES[[kk]]
[13:17:29.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.054]                     next
[13:17:29.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.054]                 }
[13:17:29.054]                 NAMES <- toupper(added)
[13:17:29.054]                 for (kk in seq_along(NAMES)) {
[13:17:29.054]                   name <- added[[kk]]
[13:17:29.054]                   NAME <- NAMES[[kk]]
[13:17:29.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.054]                     next
[13:17:29.054]                   args[[name]] <- ""
[13:17:29.054]                 }
[13:17:29.054]                 NAMES <- toupper(removed)
[13:17:29.054]                 for (kk in seq_along(NAMES)) {
[13:17:29.054]                   name <- removed[[kk]]
[13:17:29.054]                   NAME <- NAMES[[kk]]
[13:17:29.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.054]                     next
[13:17:29.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.054]                 }
[13:17:29.054]                 if (length(args) > 0) 
[13:17:29.054]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.054]             }
[13:17:29.054]             else {
[13:17:29.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.054]             }
[13:17:29.054]             {
[13:17:29.054]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.054]                   0L) {
[13:17:29.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.054]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.054]                   base::options(opts)
[13:17:29.054]                 }
[13:17:29.054]                 {
[13:17:29.054]                   {
[13:17:29.054]                     NULL
[13:17:29.054]                     RNGkind("Mersenne-Twister")
[13:17:29.054]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.054]                       inherits = FALSE)
[13:17:29.054]                   }
[13:17:29.054]                   options(future.plan = NULL)
[13:17:29.054]                   if (is.na(NA_character_)) 
[13:17:29.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.054]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:29.054]                     envir = parent.frame()) 
[13:17:29.054]                   {
[13:17:29.054]                     default_workers <- missing(workers)
[13:17:29.054]                     if (is.function(workers)) 
[13:17:29.054]                       workers <- workers()
[13:17:29.054]                     workers <- structure(as.integer(workers), 
[13:17:29.054]                       class = class(workers))
[13:17:29.054]                     stop_if_not(is.finite(workers), workers >= 
[13:17:29.054]                       1L)
[13:17:29.054]                     if ((workers == 1L && !inherits(workers, 
[13:17:29.054]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:29.054]                       if (default_workers) 
[13:17:29.054]                         supportsMulticore(warn = TRUE)
[13:17:29.054]                       return(sequential(..., envir = envir))
[13:17:29.054]                     }
[13:17:29.054]                     oopts <- options(mc.cores = workers)
[13:17:29.054]                     on.exit(options(oopts))
[13:17:29.054]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:29.054]                       envir = envir)
[13:17:29.054]                     if (!future$lazy) 
[13:17:29.054]                       future <- run(future)
[13:17:29.054]                     invisible(future)
[13:17:29.054]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.054]                 }
[13:17:29.054]             }
[13:17:29.054]         }
[13:17:29.054]     })
[13:17:29.054]     if (TRUE) {
[13:17:29.054]         base::sink(type = "output", split = FALSE)
[13:17:29.054]         if (TRUE) {
[13:17:29.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.054]         }
[13:17:29.054]         else {
[13:17:29.054]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.054]         }
[13:17:29.054]         base::close(...future.stdout)
[13:17:29.054]         ...future.stdout <- NULL
[13:17:29.054]     }
[13:17:29.054]     ...future.result$conditions <- ...future.conditions
[13:17:29.054]     ...future.result$finished <- base::Sys.time()
[13:17:29.054]     ...future.result
[13:17:29.054] }
[13:17:29.056] assign_globals() ...
[13:17:29.056] List of 7
[13:17:29.056]  $ ...future.FUN            :function (x)  
[13:17:29.056]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:29.056]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.056]  $ future.call.arguments    : list()
[13:17:29.056]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.056]  $ ...future.elements_ii    :List of 3
[13:17:29.056]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.056]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.056]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.056]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.056]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.056]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.056]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.056]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.056]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.056]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.056]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.056]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.056]  $ ...future.seeds_ii       : NULL
[13:17:29.056]  $ ...future.globals.maxSize: NULL
[13:17:29.056]  - attr(*, "resolved")= logi FALSE
[13:17:29.056]  - attr(*, "total_size")= num 2320
[13:17:29.056]  - attr(*, "where")=List of 7
[13:17:29.056]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.056]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:17:29.056]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:17:29.056]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.056]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.056]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.056]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.056]  - attr(*, "already-done")= logi TRUE
[13:17:29.067] - reassign environment for ‘...future.FUN’
[13:17:29.067] - copied ‘...future.FUN’ to environment
[13:17:29.068] - copied ‘breaks’ to environment
[13:17:29.068] - copied ‘wool’ to environment
[13:17:29.068] - copied ‘future.call.arguments’ to environment
[13:17:29.068] - copied ‘...future.elements_ii’ to environment
[13:17:29.068] - copied ‘...future.seeds_ii’ to environment
[13:17:29.068] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.068] assign_globals() ... done
[13:17:29.069] plan(): Setting new future strategy stack:
[13:17:29.069] List of future strategies:
[13:17:29.069] 1. sequential:
[13:17:29.069]    - args: function (..., envir = parent.frame())
[13:17:29.069]    - tweaked: FALSE
[13:17:29.069]    - call: NULL
[13:17:29.069] plan(): nbrOfWorkers() = 1
[13:17:29.072] plan(): Setting new future strategy stack:
[13:17:29.072] List of future strategies:
[13:17:29.072] 1. multicore:
[13:17:29.072]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.072]    - tweaked: FALSE
[13:17:29.072]    - call: plan(strategy)
[13:17:29.075] plan(): nbrOfWorkers() = 1
[13:17:29.076] SequentialFuture started (and completed)
[13:17:29.076] - Launch lazy future ... done
[13:17:29.076] run() for ‘SequentialFuture’ ... done
[13:17:29.076] Created future:
[13:17:29.076] SequentialFuture:
[13:17:29.076] Label: ‘future_by-1’
[13:17:29.076] Expression:
[13:17:29.076] {
[13:17:29.076]     do.call(function(...) {
[13:17:29.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.076]             on.exit(options(oopts), add = TRUE)
[13:17:29.076]         }
[13:17:29.076]         {
[13:17:29.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.076]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.076]             })
[13:17:29.076]         }
[13:17:29.076]     }, args = future.call.arguments)
[13:17:29.076] }
[13:17:29.076] Lazy evaluation: FALSE
[13:17:29.076] Asynchronous evaluation: FALSE
[13:17:29.076] Local evaluation: TRUE
[13:17:29.076] Environment: 0x5609ea4e62c0
[13:17:29.076] Capture standard output: TRUE
[13:17:29.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.076] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:17:29.076] Packages: 1 packages (‘stats’)
[13:17:29.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.076] Resolved: TRUE
[13:17:29.076] Value: 25.57 KiB of class ‘list’
[13:17:29.076] Early signaling: FALSE
[13:17:29.076] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.076] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.078] Chunk #1 of 1 ... DONE
[13:17:29.078] Launching 1 futures (chunks) ... DONE
[13:17:29.078] Resolving 1 futures (chunks) ...
[13:17:29.078] resolve() on list ...
[13:17:29.078]  recursive: 0
[13:17:29.078]  length: 1
[13:17:29.078] 
[13:17:29.078] resolved() for ‘SequentialFuture’ ...
[13:17:29.078] - state: ‘finished’
[13:17:29.078] - run: TRUE
[13:17:29.079] - result: ‘FutureResult’
[13:17:29.079] resolved() for ‘SequentialFuture’ ... done
[13:17:29.079] Future #1
[13:17:29.079] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.079] - nx: 1
[13:17:29.079] - relay: TRUE
[13:17:29.079] - stdout: TRUE
[13:17:29.079] - signal: TRUE
[13:17:29.079] - resignal: FALSE
[13:17:29.079] - force: TRUE
[13:17:29.079] - relayed: [n=1] FALSE
[13:17:29.080] - queued futures: [n=1] FALSE
[13:17:29.080]  - until=1
[13:17:29.080]  - relaying element #1
[13:17:29.080] - relayed: [n=1] TRUE
[13:17:29.080] - queued futures: [n=1] TRUE
[13:17:29.080] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.080]  length: 0 (resolved future 1)
[13:17:29.080] Relaying remaining futures
[13:17:29.080] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.080] - nx: 1
[13:17:29.081] - relay: TRUE
[13:17:29.081] - stdout: TRUE
[13:17:29.081] - signal: TRUE
[13:17:29.081] - resignal: FALSE
[13:17:29.081] - force: TRUE
[13:17:29.081] - relayed: [n=1] TRUE
[13:17:29.081] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.081] - relayed: [n=1] TRUE
[13:17:29.081] - queued futures: [n=1] TRUE
[13:17:29.081] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.081] resolve() on list ... DONE
[13:17:29.082]  - Number of value chunks collected: 1
[13:17:29.082] Resolving 1 futures (chunks) ... DONE
[13:17:29.082] Reducing values from 1 chunks ...
[13:17:29.082]  - Number of values collected after concatenation: 3
[13:17:29.082]  - Number of values expected: 3
[13:17:29.082] Reducing values from 1 chunks ... DONE
[13:17:29.082] future_lapply() ... DONE
[13:17:29.082] future_by_internal() ... DONE
[13:17:29.083] future_by_internal() ...
[13:17:29.083] future_lapply() ...
[13:17:29.088] Number of chunks: 1
[13:17:29.088] getGlobalsAndPackagesXApply() ...
[13:17:29.088]  - future.globals: TRUE
[13:17:29.088] getGlobalsAndPackages() ...
[13:17:29.088] Searching for globals...
[13:17:29.089] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.089] Searching for globals ... DONE
[13:17:29.089] Resolving globals: FALSE
[13:17:29.090] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.090] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.090] - globals: [1] ‘FUN’
[13:17:29.090] 
[13:17:29.090] getGlobalsAndPackages() ... DONE
[13:17:29.091]  - globals found/used: [n=1] ‘FUN’
[13:17:29.091]  - needed namespaces: [n=0] 
[13:17:29.091] Finding globals ... DONE
[13:17:29.091]  - use_args: TRUE
[13:17:29.091]  - Getting '...' globals ...
[13:17:29.091] resolve() on list ...
[13:17:29.091]  recursive: 0
[13:17:29.091]  length: 1
[13:17:29.091]  elements: ‘...’
[13:17:29.092]  length: 0 (resolved future 1)
[13:17:29.092] resolve() on list ... DONE
[13:17:29.092]    - '...' content: [n=0] 
[13:17:29.092] List of 1
[13:17:29.092]  $ ...: list()
[13:17:29.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.092]  - attr(*, "where")=List of 1
[13:17:29.092]   ..$ ...:<environment: 0x5609ead586d0> 
[13:17:29.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.092]  - attr(*, "resolved")= logi TRUE
[13:17:29.092]  - attr(*, "total_size")= num NA
[13:17:29.094]  - Getting '...' globals ... DONE
[13:17:29.095] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.095] List of 2
[13:17:29.095]  $ ...future.FUN:function (object, ...)  
[13:17:29.095]  $ ...          : list()
[13:17:29.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.095]  - attr(*, "where")=List of 2
[13:17:29.095]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.095]   ..$ ...          :<environment: 0x5609ead586d0> 
[13:17:29.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.095]  - attr(*, "resolved")= logi FALSE
[13:17:29.095]  - attr(*, "total_size")= num 1240
[13:17:29.097] Packages to be attached in all futures: [n=0] 
[13:17:29.097] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.098] Number of futures (= number of chunks): 1
[13:17:29.098] Launching 1 futures (chunks) ...
[13:17:29.098] Chunk #1 of 1 ...
[13:17:29.098]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.098] getGlobalsAndPackages() ...
[13:17:29.098] Searching for globals...
[13:17:29.099] 
[13:17:29.099] Searching for globals ... DONE
[13:17:29.099] - globals: [0] <none>
[13:17:29.099] getGlobalsAndPackages() ... DONE
[13:17:29.099]    + additional globals found: [n=0] 
[13:17:29.099]    + additional namespaces needed: [n=0] 
[13:17:29.099]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.099]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.099]  - seeds: <none>
[13:17:29.099] getGlobalsAndPackages() ...
[13:17:29.100] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.100] Resolving globals: FALSE
[13:17:29.100] Tweak future expression to call with '...' arguments ...
[13:17:29.100] {
[13:17:29.100]     do.call(function(...) {
[13:17:29.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.100]             on.exit(options(oopts), add = TRUE)
[13:17:29.100]         }
[13:17:29.100]         {
[13:17:29.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.100]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.100]             })
[13:17:29.100]         }
[13:17:29.100]     }, args = future.call.arguments)
[13:17:29.100] }
[13:17:29.100] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.100] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.101] 
[13:17:29.101] getGlobalsAndPackages() ... DONE
[13:17:29.101] run() for ‘Future’ ...
[13:17:29.101] - state: ‘created’
[13:17:29.101] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.105] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.105]   - Field: ‘label’
[13:17:29.105]   - Field: ‘local’
[13:17:29.105]   - Field: ‘owner’
[13:17:29.105]   - Field: ‘envir’
[13:17:29.105]   - Field: ‘packages’
[13:17:29.106]   - Field: ‘gc’
[13:17:29.106]   - Field: ‘conditions’
[13:17:29.106]   - Field: ‘expr’
[13:17:29.106]   - Field: ‘uuid’
[13:17:29.106]   - Field: ‘seed’
[13:17:29.106]   - Field: ‘version’
[13:17:29.106]   - Field: ‘result’
[13:17:29.106]   - Field: ‘asynchronous’
[13:17:29.106]   - Field: ‘calls’
[13:17:29.106]   - Field: ‘globals’
[13:17:29.106]   - Field: ‘stdout’
[13:17:29.107]   - Field: ‘earlySignal’
[13:17:29.107]   - Field: ‘lazy’
[13:17:29.107]   - Field: ‘state’
[13:17:29.107] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.107] - Launch lazy future ...
[13:17:29.107] Packages needed by the future expression (n = 0): <none>
[13:17:29.107] Packages needed by future strategies (n = 0): <none>
[13:17:29.108] {
[13:17:29.108]     {
[13:17:29.108]         {
[13:17:29.108]             ...future.startTime <- base::Sys.time()
[13:17:29.108]             {
[13:17:29.108]                 {
[13:17:29.108]                   {
[13:17:29.108]                     base::local({
[13:17:29.108]                       has_future <- base::requireNamespace("future", 
[13:17:29.108]                         quietly = TRUE)
[13:17:29.108]                       if (has_future) {
[13:17:29.108]                         ns <- base::getNamespace("future")
[13:17:29.108]                         version <- ns[[".package"]][["version"]]
[13:17:29.108]                         if (is.null(version)) 
[13:17:29.108]                           version <- utils::packageVersion("future")
[13:17:29.108]                       }
[13:17:29.108]                       else {
[13:17:29.108]                         version <- NULL
[13:17:29.108]                       }
[13:17:29.108]                       if (!has_future || version < "1.8.0") {
[13:17:29.108]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.108]                           "", base::R.version$version.string), 
[13:17:29.108]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.108]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.108]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.108]                             "release", "version")], collapse = " "), 
[13:17:29.108]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.108]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.108]                           info)
[13:17:29.108]                         info <- base::paste(info, collapse = "; ")
[13:17:29.108]                         if (!has_future) {
[13:17:29.108]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.108]                             info)
[13:17:29.108]                         }
[13:17:29.108]                         else {
[13:17:29.108]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.108]                             info, version)
[13:17:29.108]                         }
[13:17:29.108]                         base::stop(msg)
[13:17:29.108]                       }
[13:17:29.108]                     })
[13:17:29.108]                   }
[13:17:29.108]                   options(future.plan = NULL)
[13:17:29.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.108]                 }
[13:17:29.108]                 ...future.workdir <- getwd()
[13:17:29.108]             }
[13:17:29.108]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.108]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.108]         }
[13:17:29.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.108]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.108]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.108]             base::names(...future.oldOptions))
[13:17:29.108]     }
[13:17:29.108]     if (FALSE) {
[13:17:29.108]     }
[13:17:29.108]     else {
[13:17:29.108]         if (TRUE) {
[13:17:29.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.108]                 open = "w")
[13:17:29.108]         }
[13:17:29.108]         else {
[13:17:29.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.108]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.108]         }
[13:17:29.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.108]             base::sink(type = "output", split = FALSE)
[13:17:29.108]             base::close(...future.stdout)
[13:17:29.108]         }, add = TRUE)
[13:17:29.108]     }
[13:17:29.108]     ...future.frame <- base::sys.nframe()
[13:17:29.108]     ...future.conditions <- base::list()
[13:17:29.108]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.108]     if (FALSE) {
[13:17:29.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.108]     }
[13:17:29.108]     ...future.result <- base::tryCatch({
[13:17:29.108]         base::withCallingHandlers({
[13:17:29.108]             ...future.value <- base::withVisible(base::local({
[13:17:29.108]                 do.call(function(...) {
[13:17:29.108]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.108]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.108]                     ...future.globals.maxSize)) {
[13:17:29.108]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.108]                     on.exit(options(oopts), add = TRUE)
[13:17:29.108]                   }
[13:17:29.108]                   {
[13:17:29.108]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.108]                       FUN = function(jj) {
[13:17:29.108]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.108]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.108]                       })
[13:17:29.108]                   }
[13:17:29.108]                 }, args = future.call.arguments)
[13:17:29.108]             }))
[13:17:29.108]             future::FutureResult(value = ...future.value$value, 
[13:17:29.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.108]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.108]                     ...future.globalenv.names))
[13:17:29.108]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.108]         }, condition = base::local({
[13:17:29.108]             c <- base::c
[13:17:29.108]             inherits <- base::inherits
[13:17:29.108]             invokeRestart <- base::invokeRestart
[13:17:29.108]             length <- base::length
[13:17:29.108]             list <- base::list
[13:17:29.108]             seq.int <- base::seq.int
[13:17:29.108]             signalCondition <- base::signalCondition
[13:17:29.108]             sys.calls <- base::sys.calls
[13:17:29.108]             `[[` <- base::`[[`
[13:17:29.108]             `+` <- base::`+`
[13:17:29.108]             `<<-` <- base::`<<-`
[13:17:29.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.108]                   3L)]
[13:17:29.108]             }
[13:17:29.108]             function(cond) {
[13:17:29.108]                 is_error <- inherits(cond, "error")
[13:17:29.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.108]                   NULL)
[13:17:29.108]                 if (is_error) {
[13:17:29.108]                   sessionInformation <- function() {
[13:17:29.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.108]                       search = base::search(), system = base::Sys.info())
[13:17:29.108]                   }
[13:17:29.108]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.108]                     cond$call), session = sessionInformation(), 
[13:17:29.108]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.108]                   signalCondition(cond)
[13:17:29.108]                 }
[13:17:29.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.108]                 "immediateCondition"))) {
[13:17:29.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.108]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.108]                   if (TRUE && !signal) {
[13:17:29.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.108]                     {
[13:17:29.108]                       inherits <- base::inherits
[13:17:29.108]                       invokeRestart <- base::invokeRestart
[13:17:29.108]                       is.null <- base::is.null
[13:17:29.108]                       muffled <- FALSE
[13:17:29.108]                       if (inherits(cond, "message")) {
[13:17:29.108]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.108]                         if (muffled) 
[13:17:29.108]                           invokeRestart("muffleMessage")
[13:17:29.108]                       }
[13:17:29.108]                       else if (inherits(cond, "warning")) {
[13:17:29.108]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.108]                         if (muffled) 
[13:17:29.108]                           invokeRestart("muffleWarning")
[13:17:29.108]                       }
[13:17:29.108]                       else if (inherits(cond, "condition")) {
[13:17:29.108]                         if (!is.null(pattern)) {
[13:17:29.108]                           computeRestarts <- base::computeRestarts
[13:17:29.108]                           grepl <- base::grepl
[13:17:29.108]                           restarts <- computeRestarts(cond)
[13:17:29.108]                           for (restart in restarts) {
[13:17:29.108]                             name <- restart$name
[13:17:29.108]                             if (is.null(name)) 
[13:17:29.108]                               next
[13:17:29.108]                             if (!grepl(pattern, name)) 
[13:17:29.108]                               next
[13:17:29.108]                             invokeRestart(restart)
[13:17:29.108]                             muffled <- TRUE
[13:17:29.108]                             break
[13:17:29.108]                           }
[13:17:29.108]                         }
[13:17:29.108]                       }
[13:17:29.108]                       invisible(muffled)
[13:17:29.108]                     }
[13:17:29.108]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.108]                   }
[13:17:29.108]                 }
[13:17:29.108]                 else {
[13:17:29.108]                   if (TRUE) {
[13:17:29.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.108]                     {
[13:17:29.108]                       inherits <- base::inherits
[13:17:29.108]                       invokeRestart <- base::invokeRestart
[13:17:29.108]                       is.null <- base::is.null
[13:17:29.108]                       muffled <- FALSE
[13:17:29.108]                       if (inherits(cond, "message")) {
[13:17:29.108]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.108]                         if (muffled) 
[13:17:29.108]                           invokeRestart("muffleMessage")
[13:17:29.108]                       }
[13:17:29.108]                       else if (inherits(cond, "warning")) {
[13:17:29.108]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.108]                         if (muffled) 
[13:17:29.108]                           invokeRestart("muffleWarning")
[13:17:29.108]                       }
[13:17:29.108]                       else if (inherits(cond, "condition")) {
[13:17:29.108]                         if (!is.null(pattern)) {
[13:17:29.108]                           computeRestarts <- base::computeRestarts
[13:17:29.108]                           grepl <- base::grepl
[13:17:29.108]                           restarts <- computeRestarts(cond)
[13:17:29.108]                           for (restart in restarts) {
[13:17:29.108]                             name <- restart$name
[13:17:29.108]                             if (is.null(name)) 
[13:17:29.108]                               next
[13:17:29.108]                             if (!grepl(pattern, name)) 
[13:17:29.108]                               next
[13:17:29.108]                             invokeRestart(restart)
[13:17:29.108]                             muffled <- TRUE
[13:17:29.108]                             break
[13:17:29.108]                           }
[13:17:29.108]                         }
[13:17:29.108]                       }
[13:17:29.108]                       invisible(muffled)
[13:17:29.108]                     }
[13:17:29.108]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.108]                   }
[13:17:29.108]                 }
[13:17:29.108]             }
[13:17:29.108]         }))
[13:17:29.108]     }, error = function(ex) {
[13:17:29.108]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.108]                 ...future.rng), started = ...future.startTime, 
[13:17:29.108]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.108]             version = "1.8"), class = "FutureResult")
[13:17:29.108]     }, finally = {
[13:17:29.108]         if (!identical(...future.workdir, getwd())) 
[13:17:29.108]             setwd(...future.workdir)
[13:17:29.108]         {
[13:17:29.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.108]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.108]             }
[13:17:29.108]             base::options(...future.oldOptions)
[13:17:29.108]             if (.Platform$OS.type == "windows") {
[13:17:29.108]                 old_names <- names(...future.oldEnvVars)
[13:17:29.108]                 envs <- base::Sys.getenv()
[13:17:29.108]                 names <- names(envs)
[13:17:29.108]                 common <- intersect(names, old_names)
[13:17:29.108]                 added <- setdiff(names, old_names)
[13:17:29.108]                 removed <- setdiff(old_names, names)
[13:17:29.108]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.108]                   envs[common]]
[13:17:29.108]                 NAMES <- toupper(changed)
[13:17:29.108]                 args <- list()
[13:17:29.108]                 for (kk in seq_along(NAMES)) {
[13:17:29.108]                   name <- changed[[kk]]
[13:17:29.108]                   NAME <- NAMES[[kk]]
[13:17:29.108]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.108]                     next
[13:17:29.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.108]                 }
[13:17:29.108]                 NAMES <- toupper(added)
[13:17:29.108]                 for (kk in seq_along(NAMES)) {
[13:17:29.108]                   name <- added[[kk]]
[13:17:29.108]                   NAME <- NAMES[[kk]]
[13:17:29.108]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.108]                     next
[13:17:29.108]                   args[[name]] <- ""
[13:17:29.108]                 }
[13:17:29.108]                 NAMES <- toupper(removed)
[13:17:29.108]                 for (kk in seq_along(NAMES)) {
[13:17:29.108]                   name <- removed[[kk]]
[13:17:29.108]                   NAME <- NAMES[[kk]]
[13:17:29.108]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.108]                     next
[13:17:29.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.108]                 }
[13:17:29.108]                 if (length(args) > 0) 
[13:17:29.108]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.108]             }
[13:17:29.108]             else {
[13:17:29.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.108]             }
[13:17:29.108]             {
[13:17:29.108]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.108]                   0L) {
[13:17:29.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.108]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.108]                   base::options(opts)
[13:17:29.108]                 }
[13:17:29.108]                 {
[13:17:29.108]                   {
[13:17:29.108]                     NULL
[13:17:29.108]                     RNGkind("Mersenne-Twister")
[13:17:29.108]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.108]                       inherits = FALSE)
[13:17:29.108]                   }
[13:17:29.108]                   options(future.plan = NULL)
[13:17:29.108]                   if (is.na(NA_character_)) 
[13:17:29.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.108]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:29.108]                     envir = parent.frame()) 
[13:17:29.108]                   {
[13:17:29.108]                     default_workers <- missing(workers)
[13:17:29.108]                     if (is.function(workers)) 
[13:17:29.108]                       workers <- workers()
[13:17:29.108]                     workers <- structure(as.integer(workers), 
[13:17:29.108]                       class = class(workers))
[13:17:29.108]                     stop_if_not(is.finite(workers), workers >= 
[13:17:29.108]                       1L)
[13:17:29.108]                     if ((workers == 1L && !inherits(workers, 
[13:17:29.108]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:29.108]                       if (default_workers) 
[13:17:29.108]                         supportsMulticore(warn = TRUE)
[13:17:29.108]                       return(sequential(..., envir = envir))
[13:17:29.108]                     }
[13:17:29.108]                     oopts <- options(mc.cores = workers)
[13:17:29.108]                     on.exit(options(oopts))
[13:17:29.108]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:29.108]                       envir = envir)
[13:17:29.108]                     if (!future$lazy) 
[13:17:29.108]                       future <- run(future)
[13:17:29.108]                     invisible(future)
[13:17:29.108]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.108]                 }
[13:17:29.108]             }
[13:17:29.108]         }
[13:17:29.108]     })
[13:17:29.108]     if (TRUE) {
[13:17:29.108]         base::sink(type = "output", split = FALSE)
[13:17:29.108]         if (TRUE) {
[13:17:29.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.108]         }
[13:17:29.108]         else {
[13:17:29.108]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.108]         }
[13:17:29.108]         base::close(...future.stdout)
[13:17:29.108]         ...future.stdout <- NULL
[13:17:29.108]     }
[13:17:29.108]     ...future.result$conditions <- ...future.conditions
[13:17:29.108]     ...future.result$finished <- base::Sys.time()
[13:17:29.108]     ...future.result
[13:17:29.108] }
[13:17:29.109] assign_globals() ...
[13:17:29.110] List of 5
[13:17:29.110]  $ ...future.FUN            :function (object, ...)  
[13:17:29.110]  $ future.call.arguments    : list()
[13:17:29.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.110]  $ ...future.elements_ii    :List of 3
[13:17:29.110]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.110]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.110]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.110]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.110]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.110]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.110]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.110]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.110]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.110]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.110]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.110]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.110]  $ ...future.seeds_ii       : NULL
[13:17:29.110]  $ ...future.globals.maxSize: NULL
[13:17:29.110]  - attr(*, "resolved")= logi FALSE
[13:17:29.110]  - attr(*, "total_size")= num 1240
[13:17:29.110]  - attr(*, "where")=List of 5
[13:17:29.110]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.110]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.110]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.110]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.110]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.110]  - attr(*, "already-done")= logi TRUE
[13:17:29.120] - copied ‘...future.FUN’ to environment
[13:17:29.120] - copied ‘future.call.arguments’ to environment
[13:17:29.120] - copied ‘...future.elements_ii’ to environment
[13:17:29.120] - copied ‘...future.seeds_ii’ to environment
[13:17:29.120] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.120] assign_globals() ... done
[13:17:29.120] plan(): Setting new future strategy stack:
[13:17:29.120] List of future strategies:
[13:17:29.120] 1. sequential:
[13:17:29.120]    - args: function (..., envir = parent.frame())
[13:17:29.120]    - tweaked: FALSE
[13:17:29.120]    - call: NULL
[13:17:29.121] plan(): nbrOfWorkers() = 1
[13:17:29.123] plan(): Setting new future strategy stack:
[13:17:29.123] List of future strategies:
[13:17:29.123] 1. multicore:
[13:17:29.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.123]    - tweaked: FALSE
[13:17:29.123]    - call: plan(strategy)
[13:17:29.127] plan(): nbrOfWorkers() = 1
[13:17:29.127] SequentialFuture started (and completed)
[13:17:29.127] - Launch lazy future ... done
[13:17:29.127] run() for ‘SequentialFuture’ ... done
[13:17:29.127] Created future:
[13:17:29.128] SequentialFuture:
[13:17:29.128] Label: ‘future_by-1’
[13:17:29.128] Expression:
[13:17:29.128] {
[13:17:29.128]     do.call(function(...) {
[13:17:29.128]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.128]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.128]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.128]             on.exit(options(oopts), add = TRUE)
[13:17:29.128]         }
[13:17:29.128]         {
[13:17:29.128]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.128]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.128]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.128]             })
[13:17:29.128]         }
[13:17:29.128]     }, args = future.call.arguments)
[13:17:29.128] }
[13:17:29.128] Lazy evaluation: FALSE
[13:17:29.128] Asynchronous evaluation: FALSE
[13:17:29.128] Local evaluation: TRUE
[13:17:29.128] Environment: 0x5609eac243d0
[13:17:29.128] Capture standard output: TRUE
[13:17:29.128] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.128] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.128] Packages: <none>
[13:17:29.128] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.128] Resolved: TRUE
[13:17:29.128] Value: 5.37 KiB of class ‘list’
[13:17:29.128] Early signaling: FALSE
[13:17:29.128] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.128] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.129] Chunk #1 of 1 ... DONE
[13:17:29.129] Launching 1 futures (chunks) ... DONE
[13:17:29.129] Resolving 1 futures (chunks) ...
[13:17:29.129] resolve() on list ...
[13:17:29.129]  recursive: 0
[13:17:29.130]  length: 1
[13:17:29.130] 
[13:17:29.130] resolved() for ‘SequentialFuture’ ...
[13:17:29.130] - state: ‘finished’
[13:17:29.130] - run: TRUE
[13:17:29.130] - result: ‘FutureResult’
[13:17:29.130] resolved() for ‘SequentialFuture’ ... done
[13:17:29.130] Future #1
[13:17:29.130] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.130] - nx: 1
[13:17:29.131] - relay: TRUE
[13:17:29.131] - stdout: TRUE
[13:17:29.131] - signal: TRUE
[13:17:29.131] - resignal: FALSE
[13:17:29.131] - force: TRUE
[13:17:29.131] - relayed: [n=1] FALSE
[13:17:29.131] - queued futures: [n=1] FALSE
[13:17:29.131]  - until=1
[13:17:29.131]  - relaying element #1
[13:17:29.131] - relayed: [n=1] TRUE
[13:17:29.132] - queued futures: [n=1] TRUE
[13:17:29.132] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.132]  length: 0 (resolved future 1)
[13:17:29.132] Relaying remaining futures
[13:17:29.132] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.132] - nx: 1
[13:17:29.132] - relay: TRUE
[13:17:29.132] - stdout: TRUE
[13:17:29.132] - signal: TRUE
[13:17:29.132] - resignal: FALSE
[13:17:29.132] - force: TRUE
[13:17:29.133] - relayed: [n=1] TRUE
[13:17:29.133] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.133] - relayed: [n=1] TRUE
[13:17:29.133] - queued futures: [n=1] TRUE
[13:17:29.133] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.133] resolve() on list ... DONE
[13:17:29.133]  - Number of value chunks collected: 1
[13:17:29.133] Resolving 1 futures (chunks) ... DONE
[13:17:29.133] Reducing values from 1 chunks ...
[13:17:29.133]  - Number of values collected after concatenation: 3
[13:17:29.134]  - Number of values expected: 3
[13:17:29.134] Reducing values from 1 chunks ... DONE
[13:17:29.134] future_lapply() ... DONE
[13:17:29.134] future_by_internal() ... DONE
[13:17:29.135] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:17:29.136] future_lapply() ...
[13:17:29.140] Number of chunks: 1
[13:17:29.140] getGlobalsAndPackagesXApply() ...
[13:17:29.140]  - future.globals: TRUE
[13:17:29.140] getGlobalsAndPackages() ...
[13:17:29.140] Searching for globals...
[13:17:29.141] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.142] Searching for globals ... DONE
[13:17:29.142] Resolving globals: FALSE
[13:17:29.142] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.142] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.142] - globals: [1] ‘FUN’
[13:17:29.143] 
[13:17:29.143] getGlobalsAndPackages() ... DONE
[13:17:29.143]  - globals found/used: [n=1] ‘FUN’
[13:17:29.143]  - needed namespaces: [n=0] 
[13:17:29.143] Finding globals ... DONE
[13:17:29.143]  - use_args: TRUE
[13:17:29.143]  - Getting '...' globals ...
[13:17:29.143] resolve() on list ...
[13:17:29.144]  recursive: 0
[13:17:29.144]  length: 1
[13:17:29.144]  elements: ‘...’
[13:17:29.144]  length: 0 (resolved future 1)
[13:17:29.144] resolve() on list ... DONE
[13:17:29.144]    - '...' content: [n=0] 
[13:17:29.144] List of 1
[13:17:29.144]  $ ...: list()
[13:17:29.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.144]  - attr(*, "where")=List of 1
[13:17:29.144]   ..$ ...:<environment: 0x5609e9429260> 
[13:17:29.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.144]  - attr(*, "resolved")= logi TRUE
[13:17:29.144]  - attr(*, "total_size")= num NA
[13:17:29.147]  - Getting '...' globals ... DONE
[13:17:29.147] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.147] List of 2
[13:17:29.147]  $ ...future.FUN:function (object, ...)  
[13:17:29.147]  $ ...          : list()
[13:17:29.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.147]  - attr(*, "where")=List of 2
[13:17:29.147]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.147]   ..$ ...          :<environment: 0x5609e9429260> 
[13:17:29.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.147]  - attr(*, "resolved")= logi FALSE
[13:17:29.147]  - attr(*, "total_size")= num 1240
[13:17:29.150] Packages to be attached in all futures: [n=0] 
[13:17:29.150] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.150] Number of futures (= number of chunks): 1
[13:17:29.150] Launching 1 futures (chunks) ...
[13:17:29.150] Chunk #1 of 1 ...
[13:17:29.150]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.150] getGlobalsAndPackages() ...
[13:17:29.150] Searching for globals...
[13:17:29.151] 
[13:17:29.151] Searching for globals ... DONE
[13:17:29.151] - globals: [0] <none>
[13:17:29.151] getGlobalsAndPackages() ... DONE
[13:17:29.151]    + additional globals found: [n=0] 
[13:17:29.151]    + additional namespaces needed: [n=0] 
[13:17:29.151]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.152]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.152]  - seeds: <none>
[13:17:29.152] getGlobalsAndPackages() ...
[13:17:29.152] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.152] Resolving globals: FALSE
[13:17:29.152] Tweak future expression to call with '...' arguments ...
[13:17:29.152] {
[13:17:29.152]     do.call(function(...) {
[13:17:29.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.152]             on.exit(options(oopts), add = TRUE)
[13:17:29.152]         }
[13:17:29.152]         {
[13:17:29.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.152]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.152]             })
[13:17:29.152]         }
[13:17:29.152]     }, args = future.call.arguments)
[13:17:29.152] }
[13:17:29.152] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.153] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.153] 
[13:17:29.153] getGlobalsAndPackages() ... DONE
[13:17:29.153] run() for ‘Future’ ...
[13:17:29.153] - state: ‘created’
[13:17:29.154] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.157] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.157]   - Field: ‘label’
[13:17:29.158]   - Field: ‘local’
[13:17:29.158]   - Field: ‘owner’
[13:17:29.158]   - Field: ‘envir’
[13:17:29.158]   - Field: ‘packages’
[13:17:29.158]   - Field: ‘gc’
[13:17:29.158]   - Field: ‘conditions’
[13:17:29.158]   - Field: ‘expr’
[13:17:29.158]   - Field: ‘uuid’
[13:17:29.158]   - Field: ‘seed’
[13:17:29.158]   - Field: ‘version’
[13:17:29.158]   - Field: ‘result’
[13:17:29.159]   - Field: ‘asynchronous’
[13:17:29.159]   - Field: ‘calls’
[13:17:29.159]   - Field: ‘globals’
[13:17:29.159]   - Field: ‘stdout’
[13:17:29.159]   - Field: ‘earlySignal’
[13:17:29.159]   - Field: ‘lazy’
[13:17:29.159]   - Field: ‘state’
[13:17:29.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.159] - Launch lazy future ...
[13:17:29.160] Packages needed by the future expression (n = 0): <none>
[13:17:29.160] Packages needed by future strategies (n = 0): <none>
[13:17:29.160] {
[13:17:29.160]     {
[13:17:29.160]         {
[13:17:29.160]             ...future.startTime <- base::Sys.time()
[13:17:29.160]             {
[13:17:29.160]                 {
[13:17:29.160]                   {
[13:17:29.160]                     base::local({
[13:17:29.160]                       has_future <- base::requireNamespace("future", 
[13:17:29.160]                         quietly = TRUE)
[13:17:29.160]                       if (has_future) {
[13:17:29.160]                         ns <- base::getNamespace("future")
[13:17:29.160]                         version <- ns[[".package"]][["version"]]
[13:17:29.160]                         if (is.null(version)) 
[13:17:29.160]                           version <- utils::packageVersion("future")
[13:17:29.160]                       }
[13:17:29.160]                       else {
[13:17:29.160]                         version <- NULL
[13:17:29.160]                       }
[13:17:29.160]                       if (!has_future || version < "1.8.0") {
[13:17:29.160]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.160]                           "", base::R.version$version.string), 
[13:17:29.160]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.160]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.160]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.160]                             "release", "version")], collapse = " "), 
[13:17:29.160]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.160]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.160]                           info)
[13:17:29.160]                         info <- base::paste(info, collapse = "; ")
[13:17:29.160]                         if (!has_future) {
[13:17:29.160]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.160]                             info)
[13:17:29.160]                         }
[13:17:29.160]                         else {
[13:17:29.160]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.160]                             info, version)
[13:17:29.160]                         }
[13:17:29.160]                         base::stop(msg)
[13:17:29.160]                       }
[13:17:29.160]                     })
[13:17:29.160]                   }
[13:17:29.160]                   options(future.plan = NULL)
[13:17:29.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.160]                 }
[13:17:29.160]                 ...future.workdir <- getwd()
[13:17:29.160]             }
[13:17:29.160]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.160]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.160]         }
[13:17:29.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.160]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.160]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.160]             base::names(...future.oldOptions))
[13:17:29.160]     }
[13:17:29.160]     if (FALSE) {
[13:17:29.160]     }
[13:17:29.160]     else {
[13:17:29.160]         if (TRUE) {
[13:17:29.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.160]                 open = "w")
[13:17:29.160]         }
[13:17:29.160]         else {
[13:17:29.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.160]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.160]         }
[13:17:29.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.160]             base::sink(type = "output", split = FALSE)
[13:17:29.160]             base::close(...future.stdout)
[13:17:29.160]         }, add = TRUE)
[13:17:29.160]     }
[13:17:29.160]     ...future.frame <- base::sys.nframe()
[13:17:29.160]     ...future.conditions <- base::list()
[13:17:29.160]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.160]     if (FALSE) {
[13:17:29.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.160]     }
[13:17:29.160]     ...future.result <- base::tryCatch({
[13:17:29.160]         base::withCallingHandlers({
[13:17:29.160]             ...future.value <- base::withVisible(base::local({
[13:17:29.160]                 do.call(function(...) {
[13:17:29.160]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.160]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.160]                     ...future.globals.maxSize)) {
[13:17:29.160]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.160]                     on.exit(options(oopts), add = TRUE)
[13:17:29.160]                   }
[13:17:29.160]                   {
[13:17:29.160]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.160]                       FUN = function(jj) {
[13:17:29.160]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.160]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.160]                       })
[13:17:29.160]                   }
[13:17:29.160]                 }, args = future.call.arguments)
[13:17:29.160]             }))
[13:17:29.160]             future::FutureResult(value = ...future.value$value, 
[13:17:29.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.160]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.160]                     ...future.globalenv.names))
[13:17:29.160]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.160]         }, condition = base::local({
[13:17:29.160]             c <- base::c
[13:17:29.160]             inherits <- base::inherits
[13:17:29.160]             invokeRestart <- base::invokeRestart
[13:17:29.160]             length <- base::length
[13:17:29.160]             list <- base::list
[13:17:29.160]             seq.int <- base::seq.int
[13:17:29.160]             signalCondition <- base::signalCondition
[13:17:29.160]             sys.calls <- base::sys.calls
[13:17:29.160]             `[[` <- base::`[[`
[13:17:29.160]             `+` <- base::`+`
[13:17:29.160]             `<<-` <- base::`<<-`
[13:17:29.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.160]                   3L)]
[13:17:29.160]             }
[13:17:29.160]             function(cond) {
[13:17:29.160]                 is_error <- inherits(cond, "error")
[13:17:29.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.160]                   NULL)
[13:17:29.160]                 if (is_error) {
[13:17:29.160]                   sessionInformation <- function() {
[13:17:29.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.160]                       search = base::search(), system = base::Sys.info())
[13:17:29.160]                   }
[13:17:29.160]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.160]                     cond$call), session = sessionInformation(), 
[13:17:29.160]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.160]                   signalCondition(cond)
[13:17:29.160]                 }
[13:17:29.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.160]                 "immediateCondition"))) {
[13:17:29.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.160]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.160]                   if (TRUE && !signal) {
[13:17:29.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.160]                     {
[13:17:29.160]                       inherits <- base::inherits
[13:17:29.160]                       invokeRestart <- base::invokeRestart
[13:17:29.160]                       is.null <- base::is.null
[13:17:29.160]                       muffled <- FALSE
[13:17:29.160]                       if (inherits(cond, "message")) {
[13:17:29.160]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.160]                         if (muffled) 
[13:17:29.160]                           invokeRestart("muffleMessage")
[13:17:29.160]                       }
[13:17:29.160]                       else if (inherits(cond, "warning")) {
[13:17:29.160]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.160]                         if (muffled) 
[13:17:29.160]                           invokeRestart("muffleWarning")
[13:17:29.160]                       }
[13:17:29.160]                       else if (inherits(cond, "condition")) {
[13:17:29.160]                         if (!is.null(pattern)) {
[13:17:29.160]                           computeRestarts <- base::computeRestarts
[13:17:29.160]                           grepl <- base::grepl
[13:17:29.160]                           restarts <- computeRestarts(cond)
[13:17:29.160]                           for (restart in restarts) {
[13:17:29.160]                             name <- restart$name
[13:17:29.160]                             if (is.null(name)) 
[13:17:29.160]                               next
[13:17:29.160]                             if (!grepl(pattern, name)) 
[13:17:29.160]                               next
[13:17:29.160]                             invokeRestart(restart)
[13:17:29.160]                             muffled <- TRUE
[13:17:29.160]                             break
[13:17:29.160]                           }
[13:17:29.160]                         }
[13:17:29.160]                       }
[13:17:29.160]                       invisible(muffled)
[13:17:29.160]                     }
[13:17:29.160]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.160]                   }
[13:17:29.160]                 }
[13:17:29.160]                 else {
[13:17:29.160]                   if (TRUE) {
[13:17:29.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.160]                     {
[13:17:29.160]                       inherits <- base::inherits
[13:17:29.160]                       invokeRestart <- base::invokeRestart
[13:17:29.160]                       is.null <- base::is.null
[13:17:29.160]                       muffled <- FALSE
[13:17:29.160]                       if (inherits(cond, "message")) {
[13:17:29.160]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.160]                         if (muffled) 
[13:17:29.160]                           invokeRestart("muffleMessage")
[13:17:29.160]                       }
[13:17:29.160]                       else if (inherits(cond, "warning")) {
[13:17:29.160]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.160]                         if (muffled) 
[13:17:29.160]                           invokeRestart("muffleWarning")
[13:17:29.160]                       }
[13:17:29.160]                       else if (inherits(cond, "condition")) {
[13:17:29.160]                         if (!is.null(pattern)) {
[13:17:29.160]                           computeRestarts <- base::computeRestarts
[13:17:29.160]                           grepl <- base::grepl
[13:17:29.160]                           restarts <- computeRestarts(cond)
[13:17:29.160]                           for (restart in restarts) {
[13:17:29.160]                             name <- restart$name
[13:17:29.160]                             if (is.null(name)) 
[13:17:29.160]                               next
[13:17:29.160]                             if (!grepl(pattern, name)) 
[13:17:29.160]                               next
[13:17:29.160]                             invokeRestart(restart)
[13:17:29.160]                             muffled <- TRUE
[13:17:29.160]                             break
[13:17:29.160]                           }
[13:17:29.160]                         }
[13:17:29.160]                       }
[13:17:29.160]                       invisible(muffled)
[13:17:29.160]                     }
[13:17:29.160]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.160]                   }
[13:17:29.160]                 }
[13:17:29.160]             }
[13:17:29.160]         }))
[13:17:29.160]     }, error = function(ex) {
[13:17:29.160]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.160]                 ...future.rng), started = ...future.startTime, 
[13:17:29.160]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.160]             version = "1.8"), class = "FutureResult")
[13:17:29.160]     }, finally = {
[13:17:29.160]         if (!identical(...future.workdir, getwd())) 
[13:17:29.160]             setwd(...future.workdir)
[13:17:29.160]         {
[13:17:29.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.160]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.160]             }
[13:17:29.160]             base::options(...future.oldOptions)
[13:17:29.160]             if (.Platform$OS.type == "windows") {
[13:17:29.160]                 old_names <- names(...future.oldEnvVars)
[13:17:29.160]                 envs <- base::Sys.getenv()
[13:17:29.160]                 names <- names(envs)
[13:17:29.160]                 common <- intersect(names, old_names)
[13:17:29.160]                 added <- setdiff(names, old_names)
[13:17:29.160]                 removed <- setdiff(old_names, names)
[13:17:29.160]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.160]                   envs[common]]
[13:17:29.160]                 NAMES <- toupper(changed)
[13:17:29.160]                 args <- list()
[13:17:29.160]                 for (kk in seq_along(NAMES)) {
[13:17:29.160]                   name <- changed[[kk]]
[13:17:29.160]                   NAME <- NAMES[[kk]]
[13:17:29.160]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.160]                     next
[13:17:29.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.160]                 }
[13:17:29.160]                 NAMES <- toupper(added)
[13:17:29.160]                 for (kk in seq_along(NAMES)) {
[13:17:29.160]                   name <- added[[kk]]
[13:17:29.160]                   NAME <- NAMES[[kk]]
[13:17:29.160]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.160]                     next
[13:17:29.160]                   args[[name]] <- ""
[13:17:29.160]                 }
[13:17:29.160]                 NAMES <- toupper(removed)
[13:17:29.160]                 for (kk in seq_along(NAMES)) {
[13:17:29.160]                   name <- removed[[kk]]
[13:17:29.160]                   NAME <- NAMES[[kk]]
[13:17:29.160]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.160]                     next
[13:17:29.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.160]                 }
[13:17:29.160]                 if (length(args) > 0) 
[13:17:29.160]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.160]             }
[13:17:29.160]             else {
[13:17:29.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.160]             }
[13:17:29.160]             {
[13:17:29.160]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.160]                   0L) {
[13:17:29.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.160]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.160]                   base::options(opts)
[13:17:29.160]                 }
[13:17:29.160]                 {
[13:17:29.160]                   {
[13:17:29.160]                     NULL
[13:17:29.160]                     RNGkind("Mersenne-Twister")
[13:17:29.160]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.160]                       inherits = FALSE)
[13:17:29.160]                   }
[13:17:29.160]                   options(future.plan = NULL)
[13:17:29.160]                   if (is.na(NA_character_)) 
[13:17:29.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.160]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:29.160]                     envir = parent.frame()) 
[13:17:29.160]                   {
[13:17:29.160]                     default_workers <- missing(workers)
[13:17:29.160]                     if (is.function(workers)) 
[13:17:29.160]                       workers <- workers()
[13:17:29.160]                     workers <- structure(as.integer(workers), 
[13:17:29.160]                       class = class(workers))
[13:17:29.160]                     stop_if_not(is.finite(workers), workers >= 
[13:17:29.160]                       1L)
[13:17:29.160]                     if ((workers == 1L && !inherits(workers, 
[13:17:29.160]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:29.160]                       if (default_workers) 
[13:17:29.160]                         supportsMulticore(warn = TRUE)
[13:17:29.160]                       return(sequential(..., envir = envir))
[13:17:29.160]                     }
[13:17:29.160]                     oopts <- options(mc.cores = workers)
[13:17:29.160]                     on.exit(options(oopts))
[13:17:29.160]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:29.160]                       envir = envir)
[13:17:29.160]                     if (!future$lazy) 
[13:17:29.160]                       future <- run(future)
[13:17:29.160]                     invisible(future)
[13:17:29.160]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.160]                 }
[13:17:29.160]             }
[13:17:29.160]         }
[13:17:29.160]     })
[13:17:29.160]     if (TRUE) {
[13:17:29.160]         base::sink(type = "output", split = FALSE)
[13:17:29.160]         if (TRUE) {
[13:17:29.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.160]         }
[13:17:29.160]         else {
[13:17:29.160]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.160]         }
[13:17:29.160]         base::close(...future.stdout)
[13:17:29.160]         ...future.stdout <- NULL
[13:17:29.160]     }
[13:17:29.160]     ...future.result$conditions <- ...future.conditions
[13:17:29.160]     ...future.result$finished <- base::Sys.time()
[13:17:29.160]     ...future.result
[13:17:29.160] }
[13:17:29.162] assign_globals() ...
[13:17:29.162] List of 5
[13:17:29.162]  $ ...future.FUN            :function (object, ...)  
[13:17:29.162]  $ future.call.arguments    : list()
[13:17:29.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.162]  $ ...future.elements_ii    :List of 3
[13:17:29.162]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.162]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.162]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.162]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.162]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.162]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.162]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.162]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.162]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.162]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.162]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.162]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.162]  $ ...future.seeds_ii       : NULL
[13:17:29.162]  $ ...future.globals.maxSize: NULL
[13:17:29.162]  - attr(*, "resolved")= logi FALSE
[13:17:29.162]  - attr(*, "total_size")= num 1240
[13:17:29.162]  - attr(*, "where")=List of 5
[13:17:29.162]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.162]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.162]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.162]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.162]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.162]  - attr(*, "already-done")= logi TRUE
[13:17:29.172] - copied ‘...future.FUN’ to environment
[13:17:29.172] - copied ‘future.call.arguments’ to environment
[13:17:29.172] - copied ‘...future.elements_ii’ to environment
[13:17:29.172] - copied ‘...future.seeds_ii’ to environment
[13:17:29.173] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.173] assign_globals() ... done
[13:17:29.173] plan(): Setting new future strategy stack:
[13:17:29.173] List of future strategies:
[13:17:29.173] 1. sequential:
[13:17:29.173]    - args: function (..., envir = parent.frame())
[13:17:29.173]    - tweaked: FALSE
[13:17:29.173]    - call: NULL
[13:17:29.173] plan(): nbrOfWorkers() = 1
[13:17:29.176] plan(): Setting new future strategy stack:
[13:17:29.176] List of future strategies:
[13:17:29.176] 1. multicore:
[13:17:29.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.176]    - tweaked: FALSE
[13:17:29.176]    - call: plan(strategy)
[13:17:29.179] plan(): nbrOfWorkers() = 1
[13:17:29.179] SequentialFuture started (and completed)
[13:17:29.179] - Launch lazy future ... done
[13:17:29.180] run() for ‘SequentialFuture’ ... done
[13:17:29.180] Created future:
[13:17:29.180] SequentialFuture:
[13:17:29.180] Label: ‘future_by-1’
[13:17:29.180] Expression:
[13:17:29.180] {
[13:17:29.180]     do.call(function(...) {
[13:17:29.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.180]             on.exit(options(oopts), add = TRUE)
[13:17:29.180]         }
[13:17:29.180]         {
[13:17:29.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.180]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.180]             })
[13:17:29.180]         }
[13:17:29.180]     }, args = future.call.arguments)
[13:17:29.180] }
[13:17:29.180] Lazy evaluation: FALSE
[13:17:29.180] Asynchronous evaluation: FALSE
[13:17:29.180] Local evaluation: TRUE
[13:17:29.180] Environment: 0x5609eadd1e90
[13:17:29.180] Capture standard output: TRUE
[13:17:29.180] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.180] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.180] Packages: <none>
[13:17:29.180] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.180] Resolved: TRUE
[13:17:29.180] Value: 5.37 KiB of class ‘list’
[13:17:29.180] Early signaling: FALSE
[13:17:29.180] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.180] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.181] Chunk #1 of 1 ... DONE
[13:17:29.181] Launching 1 futures (chunks) ... DONE
[13:17:29.181] Resolving 1 futures (chunks) ...
[13:17:29.181] resolve() on list ...
[13:17:29.181]  recursive: 0
[13:17:29.182]  length: 1
[13:17:29.182] 
[13:17:29.182] resolved() for ‘SequentialFuture’ ...
[13:17:29.182] - state: ‘finished’
[13:17:29.182] - run: TRUE
[13:17:29.182] - result: ‘FutureResult’
[13:17:29.182] resolved() for ‘SequentialFuture’ ... done
[13:17:29.182] Future #1
[13:17:29.182] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.182] - nx: 1
[13:17:29.183] - relay: TRUE
[13:17:29.183] - stdout: TRUE
[13:17:29.183] - signal: TRUE
[13:17:29.183] - resignal: FALSE
[13:17:29.183] - force: TRUE
[13:17:29.183] - relayed: [n=1] FALSE
[13:17:29.183] - queued futures: [n=1] FALSE
[13:17:29.183]  - until=1
[13:17:29.183]  - relaying element #1
[13:17:29.183] - relayed: [n=1] TRUE
[13:17:29.183] - queued futures: [n=1] TRUE
[13:17:29.184] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.184]  length: 0 (resolved future 1)
[13:17:29.184] Relaying remaining futures
[13:17:29.184] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.184] - nx: 1
[13:17:29.184] - relay: TRUE
[13:17:29.184] - stdout: TRUE
[13:17:29.184] - signal: TRUE
[13:17:29.184] - resignal: FALSE
[13:17:29.184] - force: TRUE
[13:17:29.184] - relayed: [n=1] TRUE
[13:17:29.185] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.185] - relayed: [n=1] TRUE
[13:17:29.185] - queued futures: [n=1] TRUE
[13:17:29.185] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.185] resolve() on list ... DONE
[13:17:29.185]  - Number of value chunks collected: 1
[13:17:29.185] Resolving 1 futures (chunks) ... DONE
[13:17:29.187] Reducing values from 1 chunks ...
[13:17:29.187]  - Number of values collected after concatenation: 3
[13:17:29.187]  - Number of values expected: 3
[13:17:29.187] Reducing values from 1 chunks ... DONE
[13:17:29.187] future_lapply() ... DONE
[13:17:29.187] future_by_internal() ... DONE
[13:17:29.188] future_by_internal() ...
- plan('multisession') ...
[13:17:29.189] plan(): Setting new future strategy stack:
[13:17:29.189] List of future strategies:
[13:17:29.189] 1. multisession:
[13:17:29.189]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.189]    - tweaked: FALSE
[13:17:29.189]    - call: plan(strategy)
[13:17:29.189] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:17:29.189] multisession:
[13:17:29.189] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.189] - tweaked: FALSE
[13:17:29.189] - call: plan(strategy)
[13:17:29.193] getGlobalsAndPackages() ...
[13:17:29.193] Not searching for globals
[13:17:29.193] - globals: [0] <none>
[13:17:29.193] getGlobalsAndPackages() ... DONE
[13:17:29.193] Packages needed by the future expression (n = 0): <none>
[13:17:29.193] Packages needed by future strategies (n = 0): <none>
[13:17:29.194] {
[13:17:29.194]     {
[13:17:29.194]         {
[13:17:29.194]             ...future.startTime <- base::Sys.time()
[13:17:29.194]             {
[13:17:29.194]                 {
[13:17:29.194]                   {
[13:17:29.194]                     base::local({
[13:17:29.194]                       has_future <- base::requireNamespace("future", 
[13:17:29.194]                         quietly = TRUE)
[13:17:29.194]                       if (has_future) {
[13:17:29.194]                         ns <- base::getNamespace("future")
[13:17:29.194]                         version <- ns[[".package"]][["version"]]
[13:17:29.194]                         if (is.null(version)) 
[13:17:29.194]                           version <- utils::packageVersion("future")
[13:17:29.194]                       }
[13:17:29.194]                       else {
[13:17:29.194]                         version <- NULL
[13:17:29.194]                       }
[13:17:29.194]                       if (!has_future || version < "1.8.0") {
[13:17:29.194]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.194]                           "", base::R.version$version.string), 
[13:17:29.194]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.194]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.194]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.194]                             "release", "version")], collapse = " "), 
[13:17:29.194]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.194]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.194]                           info)
[13:17:29.194]                         info <- base::paste(info, collapse = "; ")
[13:17:29.194]                         if (!has_future) {
[13:17:29.194]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.194]                             info)
[13:17:29.194]                         }
[13:17:29.194]                         else {
[13:17:29.194]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.194]                             info, version)
[13:17:29.194]                         }
[13:17:29.194]                         base::stop(msg)
[13:17:29.194]                       }
[13:17:29.194]                     })
[13:17:29.194]                   }
[13:17:29.194]                   options(future.plan = NULL)
[13:17:29.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.194]                 }
[13:17:29.194]                 ...future.workdir <- getwd()
[13:17:29.194]             }
[13:17:29.194]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.194]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.194]         }
[13:17:29.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:29.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.194]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.194]             base::names(...future.oldOptions))
[13:17:29.194]     }
[13:17:29.194]     if (FALSE) {
[13:17:29.194]     }
[13:17:29.194]     else {
[13:17:29.194]         if (TRUE) {
[13:17:29.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.194]                 open = "w")
[13:17:29.194]         }
[13:17:29.194]         else {
[13:17:29.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.194]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.194]         }
[13:17:29.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.194]             base::sink(type = "output", split = FALSE)
[13:17:29.194]             base::close(...future.stdout)
[13:17:29.194]         }, add = TRUE)
[13:17:29.194]     }
[13:17:29.194]     ...future.frame <- base::sys.nframe()
[13:17:29.194]     ...future.conditions <- base::list()
[13:17:29.194]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.194]     if (FALSE) {
[13:17:29.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.194]     }
[13:17:29.194]     ...future.result <- base::tryCatch({
[13:17:29.194]         base::withCallingHandlers({
[13:17:29.194]             ...future.value <- base::withVisible(base::local(NA))
[13:17:29.194]             future::FutureResult(value = ...future.value$value, 
[13:17:29.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.194]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.194]                     ...future.globalenv.names))
[13:17:29.194]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.194]         }, condition = base::local({
[13:17:29.194]             c <- base::c
[13:17:29.194]             inherits <- base::inherits
[13:17:29.194]             invokeRestart <- base::invokeRestart
[13:17:29.194]             length <- base::length
[13:17:29.194]             list <- base::list
[13:17:29.194]             seq.int <- base::seq.int
[13:17:29.194]             signalCondition <- base::signalCondition
[13:17:29.194]             sys.calls <- base::sys.calls
[13:17:29.194]             `[[` <- base::`[[`
[13:17:29.194]             `+` <- base::`+`
[13:17:29.194]             `<<-` <- base::`<<-`
[13:17:29.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.194]                   3L)]
[13:17:29.194]             }
[13:17:29.194]             function(cond) {
[13:17:29.194]                 is_error <- inherits(cond, "error")
[13:17:29.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.194]                   NULL)
[13:17:29.194]                 if (is_error) {
[13:17:29.194]                   sessionInformation <- function() {
[13:17:29.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.194]                       search = base::search(), system = base::Sys.info())
[13:17:29.194]                   }
[13:17:29.194]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.194]                     cond$call), session = sessionInformation(), 
[13:17:29.194]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.194]                   signalCondition(cond)
[13:17:29.194]                 }
[13:17:29.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.194]                 "immediateCondition"))) {
[13:17:29.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.194]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.194]                   if (TRUE && !signal) {
[13:17:29.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.194]                     {
[13:17:29.194]                       inherits <- base::inherits
[13:17:29.194]                       invokeRestart <- base::invokeRestart
[13:17:29.194]                       is.null <- base::is.null
[13:17:29.194]                       muffled <- FALSE
[13:17:29.194]                       if (inherits(cond, "message")) {
[13:17:29.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.194]                         if (muffled) 
[13:17:29.194]                           invokeRestart("muffleMessage")
[13:17:29.194]                       }
[13:17:29.194]                       else if (inherits(cond, "warning")) {
[13:17:29.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.194]                         if (muffled) 
[13:17:29.194]                           invokeRestart("muffleWarning")
[13:17:29.194]                       }
[13:17:29.194]                       else if (inherits(cond, "condition")) {
[13:17:29.194]                         if (!is.null(pattern)) {
[13:17:29.194]                           computeRestarts <- base::computeRestarts
[13:17:29.194]                           grepl <- base::grepl
[13:17:29.194]                           restarts <- computeRestarts(cond)
[13:17:29.194]                           for (restart in restarts) {
[13:17:29.194]                             name <- restart$name
[13:17:29.194]                             if (is.null(name)) 
[13:17:29.194]                               next
[13:17:29.194]                             if (!grepl(pattern, name)) 
[13:17:29.194]                               next
[13:17:29.194]                             invokeRestart(restart)
[13:17:29.194]                             muffled <- TRUE
[13:17:29.194]                             break
[13:17:29.194]                           }
[13:17:29.194]                         }
[13:17:29.194]                       }
[13:17:29.194]                       invisible(muffled)
[13:17:29.194]                     }
[13:17:29.194]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.194]                   }
[13:17:29.194]                 }
[13:17:29.194]                 else {
[13:17:29.194]                   if (TRUE) {
[13:17:29.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.194]                     {
[13:17:29.194]                       inherits <- base::inherits
[13:17:29.194]                       invokeRestart <- base::invokeRestart
[13:17:29.194]                       is.null <- base::is.null
[13:17:29.194]                       muffled <- FALSE
[13:17:29.194]                       if (inherits(cond, "message")) {
[13:17:29.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.194]                         if (muffled) 
[13:17:29.194]                           invokeRestart("muffleMessage")
[13:17:29.194]                       }
[13:17:29.194]                       else if (inherits(cond, "warning")) {
[13:17:29.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.194]                         if (muffled) 
[13:17:29.194]                           invokeRestart("muffleWarning")
[13:17:29.194]                       }
[13:17:29.194]                       else if (inherits(cond, "condition")) {
[13:17:29.194]                         if (!is.null(pattern)) {
[13:17:29.194]                           computeRestarts <- base::computeRestarts
[13:17:29.194]                           grepl <- base::grepl
[13:17:29.194]                           restarts <- computeRestarts(cond)
[13:17:29.194]                           for (restart in restarts) {
[13:17:29.194]                             name <- restart$name
[13:17:29.194]                             if (is.null(name)) 
[13:17:29.194]                               next
[13:17:29.194]                             if (!grepl(pattern, name)) 
[13:17:29.194]                               next
[13:17:29.194]                             invokeRestart(restart)
[13:17:29.194]                             muffled <- TRUE
[13:17:29.194]                             break
[13:17:29.194]                           }
[13:17:29.194]                         }
[13:17:29.194]                       }
[13:17:29.194]                       invisible(muffled)
[13:17:29.194]                     }
[13:17:29.194]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.194]                   }
[13:17:29.194]                 }
[13:17:29.194]             }
[13:17:29.194]         }))
[13:17:29.194]     }, error = function(ex) {
[13:17:29.194]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.194]                 ...future.rng), started = ...future.startTime, 
[13:17:29.194]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.194]             version = "1.8"), class = "FutureResult")
[13:17:29.194]     }, finally = {
[13:17:29.194]         if (!identical(...future.workdir, getwd())) 
[13:17:29.194]             setwd(...future.workdir)
[13:17:29.194]         {
[13:17:29.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.194]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.194]             }
[13:17:29.194]             base::options(...future.oldOptions)
[13:17:29.194]             if (.Platform$OS.type == "windows") {
[13:17:29.194]                 old_names <- names(...future.oldEnvVars)
[13:17:29.194]                 envs <- base::Sys.getenv()
[13:17:29.194]                 names <- names(envs)
[13:17:29.194]                 common <- intersect(names, old_names)
[13:17:29.194]                 added <- setdiff(names, old_names)
[13:17:29.194]                 removed <- setdiff(old_names, names)
[13:17:29.194]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.194]                   envs[common]]
[13:17:29.194]                 NAMES <- toupper(changed)
[13:17:29.194]                 args <- list()
[13:17:29.194]                 for (kk in seq_along(NAMES)) {
[13:17:29.194]                   name <- changed[[kk]]
[13:17:29.194]                   NAME <- NAMES[[kk]]
[13:17:29.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.194]                     next
[13:17:29.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.194]                 }
[13:17:29.194]                 NAMES <- toupper(added)
[13:17:29.194]                 for (kk in seq_along(NAMES)) {
[13:17:29.194]                   name <- added[[kk]]
[13:17:29.194]                   NAME <- NAMES[[kk]]
[13:17:29.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.194]                     next
[13:17:29.194]                   args[[name]] <- ""
[13:17:29.194]                 }
[13:17:29.194]                 NAMES <- toupper(removed)
[13:17:29.194]                 for (kk in seq_along(NAMES)) {
[13:17:29.194]                   name <- removed[[kk]]
[13:17:29.194]                   NAME <- NAMES[[kk]]
[13:17:29.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.194]                     next
[13:17:29.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.194]                 }
[13:17:29.194]                 if (length(args) > 0) 
[13:17:29.194]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.194]             }
[13:17:29.194]             else {
[13:17:29.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.194]             }
[13:17:29.194]             {
[13:17:29.194]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.194]                   0L) {
[13:17:29.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.194]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.194]                   base::options(opts)
[13:17:29.194]                 }
[13:17:29.194]                 {
[13:17:29.194]                   {
[13:17:29.194]                     NULL
[13:17:29.194]                     RNGkind("Mersenne-Twister")
[13:17:29.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.194]                       inherits = FALSE)
[13:17:29.194]                   }
[13:17:29.194]                   options(future.plan = NULL)
[13:17:29.194]                   if (is.na(NA_character_)) 
[13:17:29.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.194]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.194]                     envir = parent.frame()) 
[13:17:29.194]                   {
[13:17:29.194]                     if (is.function(workers)) 
[13:17:29.194]                       workers <- workers()
[13:17:29.194]                     workers <- structure(as.integer(workers), 
[13:17:29.194]                       class = class(workers))
[13:17:29.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.194]                       workers >= 1)
[13:17:29.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.194]                     }
[13:17:29.194]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.194]                       envir = envir)
[13:17:29.194]                     if (!future$lazy) 
[13:17:29.194]                       future <- run(future)
[13:17:29.194]                     invisible(future)
[13:17:29.194]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.194]                 }
[13:17:29.194]             }
[13:17:29.194]         }
[13:17:29.194]     })
[13:17:29.194]     if (TRUE) {
[13:17:29.194]         base::sink(type = "output", split = FALSE)
[13:17:29.194]         if (TRUE) {
[13:17:29.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.194]         }
[13:17:29.194]         else {
[13:17:29.194]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.194]         }
[13:17:29.194]         base::close(...future.stdout)
[13:17:29.194]         ...future.stdout <- NULL
[13:17:29.194]     }
[13:17:29.194]     ...future.result$conditions <- ...future.conditions
[13:17:29.194]     ...future.result$finished <- base::Sys.time()
[13:17:29.194]     ...future.result
[13:17:29.194] }
[13:17:29.196] plan(): Setting new future strategy stack:
[13:17:29.196] List of future strategies:
[13:17:29.196] 1. sequential:
[13:17:29.196]    - args: function (..., envir = parent.frame())
[13:17:29.196]    - tweaked: FALSE
[13:17:29.196]    - call: NULL
[13:17:29.196] plan(): nbrOfWorkers() = 1
[13:17:29.197] plan(): Setting new future strategy stack:
[13:17:29.197] List of future strategies:
[13:17:29.197] 1. multisession:
[13:17:29.197]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.197]    - tweaked: FALSE
[13:17:29.197]    - call: plan(strategy)
[13:17:29.200] plan(): nbrOfWorkers() = 1
[13:17:29.200] SequentialFuture started (and completed)
[13:17:29.201] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:17:29.204] plan(): nbrOfWorkers() = 1
[13:17:29.204] future_by_internal() ...
[13:17:29.204] future_lapply() ...
[13:17:29.208] Number of chunks: 1
[13:17:29.208] getGlobalsAndPackagesXApply() ...
[13:17:29.208]  - future.globals: TRUE
[13:17:29.208] getGlobalsAndPackages() ...
[13:17:29.208] Searching for globals...
[13:17:29.209] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.209] Searching for globals ... DONE
[13:17:29.209] Resolving globals: FALSE
[13:17:29.210] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.210] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.210] - globals: [1] ‘FUN’
[13:17:29.210] 
[13:17:29.210] getGlobalsAndPackages() ... DONE
[13:17:29.210]  - globals found/used: [n=1] ‘FUN’
[13:17:29.210]  - needed namespaces: [n=0] 
[13:17:29.210] Finding globals ... DONE
[13:17:29.211]  - use_args: TRUE
[13:17:29.211]  - Getting '...' globals ...
[13:17:29.211] resolve() on list ...
[13:17:29.211]  recursive: 0
[13:17:29.211]  length: 1
[13:17:29.211]  elements: ‘...’
[13:17:29.211]  length: 0 (resolved future 1)
[13:17:29.211] resolve() on list ... DONE
[13:17:29.212]    - '...' content: [n=0] 
[13:17:29.212] List of 1
[13:17:29.212]  $ ...: list()
[13:17:29.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.212]  - attr(*, "where")=List of 1
[13:17:29.212]   ..$ ...:<environment: 0x5609e8828630> 
[13:17:29.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.212]  - attr(*, "resolved")= logi TRUE
[13:17:29.212]  - attr(*, "total_size")= num NA
[13:17:29.214]  - Getting '...' globals ... DONE
[13:17:29.214] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.214] List of 2
[13:17:29.214]  $ ...future.FUN:function (object, ...)  
[13:17:29.214]  $ ...          : list()
[13:17:29.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.214]  - attr(*, "where")=List of 2
[13:17:29.214]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.214]   ..$ ...          :<environment: 0x5609e8828630> 
[13:17:29.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.214]  - attr(*, "resolved")= logi FALSE
[13:17:29.214]  - attr(*, "total_size")= num 1240
[13:17:29.219] Packages to be attached in all futures: [n=0] 
[13:17:29.219] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.219] Number of futures (= number of chunks): 1
[13:17:29.219] Launching 1 futures (chunks) ...
[13:17:29.219] Chunk #1 of 1 ...
[13:17:29.219]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.220] getGlobalsAndPackages() ...
[13:17:29.220] Searching for globals...
[13:17:29.220] 
[13:17:29.220] Searching for globals ... DONE
[13:17:29.220] - globals: [0] <none>
[13:17:29.220] getGlobalsAndPackages() ... DONE
[13:17:29.221]    + additional globals found: [n=0] 
[13:17:29.221]    + additional namespaces needed: [n=0] 
[13:17:29.221]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.221]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.221]  - seeds: <none>
[13:17:29.221] getGlobalsAndPackages() ...
[13:17:29.221] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.221] Resolving globals: FALSE
[13:17:29.221] Tweak future expression to call with '...' arguments ...
[13:17:29.222] {
[13:17:29.222]     do.call(function(...) {
[13:17:29.222]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.222]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.222]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.222]             on.exit(options(oopts), add = TRUE)
[13:17:29.222]         }
[13:17:29.222]         {
[13:17:29.222]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.222]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.222]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.222]             })
[13:17:29.222]         }
[13:17:29.222]     }, args = future.call.arguments)
[13:17:29.222] }
[13:17:29.222] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.222] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.222] 
[13:17:29.222] getGlobalsAndPackages() ... DONE
[13:17:29.223] run() for ‘Future’ ...
[13:17:29.223] - state: ‘created’
[13:17:29.223] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.226] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.226]   - Field: ‘label’
[13:17:29.226]   - Field: ‘local’
[13:17:29.227]   - Field: ‘owner’
[13:17:29.227]   - Field: ‘envir’
[13:17:29.227]   - Field: ‘packages’
[13:17:29.227]   - Field: ‘gc’
[13:17:29.227]   - Field: ‘conditions’
[13:17:29.227]   - Field: ‘expr’
[13:17:29.227]   - Field: ‘uuid’
[13:17:29.227]   - Field: ‘seed’
[13:17:29.227]   - Field: ‘version’
[13:17:29.227]   - Field: ‘result’
[13:17:29.227]   - Field: ‘asynchronous’
[13:17:29.228]   - Field: ‘calls’
[13:17:29.228]   - Field: ‘globals’
[13:17:29.228]   - Field: ‘stdout’
[13:17:29.228]   - Field: ‘earlySignal’
[13:17:29.228]   - Field: ‘lazy’
[13:17:29.228]   - Field: ‘state’
[13:17:29.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.228] - Launch lazy future ...
[13:17:29.228] Packages needed by the future expression (n = 0): <none>
[13:17:29.229] Packages needed by future strategies (n = 0): <none>
[13:17:29.229] {
[13:17:29.229]     {
[13:17:29.229]         {
[13:17:29.229]             ...future.startTime <- base::Sys.time()
[13:17:29.229]             {
[13:17:29.229]                 {
[13:17:29.229]                   {
[13:17:29.229]                     base::local({
[13:17:29.229]                       has_future <- base::requireNamespace("future", 
[13:17:29.229]                         quietly = TRUE)
[13:17:29.229]                       if (has_future) {
[13:17:29.229]                         ns <- base::getNamespace("future")
[13:17:29.229]                         version <- ns[[".package"]][["version"]]
[13:17:29.229]                         if (is.null(version)) 
[13:17:29.229]                           version <- utils::packageVersion("future")
[13:17:29.229]                       }
[13:17:29.229]                       else {
[13:17:29.229]                         version <- NULL
[13:17:29.229]                       }
[13:17:29.229]                       if (!has_future || version < "1.8.0") {
[13:17:29.229]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.229]                           "", base::R.version$version.string), 
[13:17:29.229]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.229]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.229]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.229]                             "release", "version")], collapse = " "), 
[13:17:29.229]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.229]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.229]                           info)
[13:17:29.229]                         info <- base::paste(info, collapse = "; ")
[13:17:29.229]                         if (!has_future) {
[13:17:29.229]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.229]                             info)
[13:17:29.229]                         }
[13:17:29.229]                         else {
[13:17:29.229]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.229]                             info, version)
[13:17:29.229]                         }
[13:17:29.229]                         base::stop(msg)
[13:17:29.229]                       }
[13:17:29.229]                     })
[13:17:29.229]                   }
[13:17:29.229]                   options(future.plan = NULL)
[13:17:29.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.229]                 }
[13:17:29.229]                 ...future.workdir <- getwd()
[13:17:29.229]             }
[13:17:29.229]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.229]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.229]         }
[13:17:29.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.229]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.229]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.229]             base::names(...future.oldOptions))
[13:17:29.229]     }
[13:17:29.229]     if (FALSE) {
[13:17:29.229]     }
[13:17:29.229]     else {
[13:17:29.229]         if (TRUE) {
[13:17:29.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.229]                 open = "w")
[13:17:29.229]         }
[13:17:29.229]         else {
[13:17:29.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.229]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.229]         }
[13:17:29.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.229]             base::sink(type = "output", split = FALSE)
[13:17:29.229]             base::close(...future.stdout)
[13:17:29.229]         }, add = TRUE)
[13:17:29.229]     }
[13:17:29.229]     ...future.frame <- base::sys.nframe()
[13:17:29.229]     ...future.conditions <- base::list()
[13:17:29.229]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.229]     if (FALSE) {
[13:17:29.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.229]     }
[13:17:29.229]     ...future.result <- base::tryCatch({
[13:17:29.229]         base::withCallingHandlers({
[13:17:29.229]             ...future.value <- base::withVisible(base::local({
[13:17:29.229]                 do.call(function(...) {
[13:17:29.229]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.229]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.229]                     ...future.globals.maxSize)) {
[13:17:29.229]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.229]                     on.exit(options(oopts), add = TRUE)
[13:17:29.229]                   }
[13:17:29.229]                   {
[13:17:29.229]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.229]                       FUN = function(jj) {
[13:17:29.229]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.229]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.229]                       })
[13:17:29.229]                   }
[13:17:29.229]                 }, args = future.call.arguments)
[13:17:29.229]             }))
[13:17:29.229]             future::FutureResult(value = ...future.value$value, 
[13:17:29.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.229]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.229]                     ...future.globalenv.names))
[13:17:29.229]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.229]         }, condition = base::local({
[13:17:29.229]             c <- base::c
[13:17:29.229]             inherits <- base::inherits
[13:17:29.229]             invokeRestart <- base::invokeRestart
[13:17:29.229]             length <- base::length
[13:17:29.229]             list <- base::list
[13:17:29.229]             seq.int <- base::seq.int
[13:17:29.229]             signalCondition <- base::signalCondition
[13:17:29.229]             sys.calls <- base::sys.calls
[13:17:29.229]             `[[` <- base::`[[`
[13:17:29.229]             `+` <- base::`+`
[13:17:29.229]             `<<-` <- base::`<<-`
[13:17:29.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.229]                   3L)]
[13:17:29.229]             }
[13:17:29.229]             function(cond) {
[13:17:29.229]                 is_error <- inherits(cond, "error")
[13:17:29.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.229]                   NULL)
[13:17:29.229]                 if (is_error) {
[13:17:29.229]                   sessionInformation <- function() {
[13:17:29.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.229]                       search = base::search(), system = base::Sys.info())
[13:17:29.229]                   }
[13:17:29.229]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.229]                     cond$call), session = sessionInformation(), 
[13:17:29.229]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.229]                   signalCondition(cond)
[13:17:29.229]                 }
[13:17:29.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.229]                 "immediateCondition"))) {
[13:17:29.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.229]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.229]                   if (TRUE && !signal) {
[13:17:29.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.229]                     {
[13:17:29.229]                       inherits <- base::inherits
[13:17:29.229]                       invokeRestart <- base::invokeRestart
[13:17:29.229]                       is.null <- base::is.null
[13:17:29.229]                       muffled <- FALSE
[13:17:29.229]                       if (inherits(cond, "message")) {
[13:17:29.229]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.229]                         if (muffled) 
[13:17:29.229]                           invokeRestart("muffleMessage")
[13:17:29.229]                       }
[13:17:29.229]                       else if (inherits(cond, "warning")) {
[13:17:29.229]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.229]                         if (muffled) 
[13:17:29.229]                           invokeRestart("muffleWarning")
[13:17:29.229]                       }
[13:17:29.229]                       else if (inherits(cond, "condition")) {
[13:17:29.229]                         if (!is.null(pattern)) {
[13:17:29.229]                           computeRestarts <- base::computeRestarts
[13:17:29.229]                           grepl <- base::grepl
[13:17:29.229]                           restarts <- computeRestarts(cond)
[13:17:29.229]                           for (restart in restarts) {
[13:17:29.229]                             name <- restart$name
[13:17:29.229]                             if (is.null(name)) 
[13:17:29.229]                               next
[13:17:29.229]                             if (!grepl(pattern, name)) 
[13:17:29.229]                               next
[13:17:29.229]                             invokeRestart(restart)
[13:17:29.229]                             muffled <- TRUE
[13:17:29.229]                             break
[13:17:29.229]                           }
[13:17:29.229]                         }
[13:17:29.229]                       }
[13:17:29.229]                       invisible(muffled)
[13:17:29.229]                     }
[13:17:29.229]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.229]                   }
[13:17:29.229]                 }
[13:17:29.229]                 else {
[13:17:29.229]                   if (TRUE) {
[13:17:29.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.229]                     {
[13:17:29.229]                       inherits <- base::inherits
[13:17:29.229]                       invokeRestart <- base::invokeRestart
[13:17:29.229]                       is.null <- base::is.null
[13:17:29.229]                       muffled <- FALSE
[13:17:29.229]                       if (inherits(cond, "message")) {
[13:17:29.229]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.229]                         if (muffled) 
[13:17:29.229]                           invokeRestart("muffleMessage")
[13:17:29.229]                       }
[13:17:29.229]                       else if (inherits(cond, "warning")) {
[13:17:29.229]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.229]                         if (muffled) 
[13:17:29.229]                           invokeRestart("muffleWarning")
[13:17:29.229]                       }
[13:17:29.229]                       else if (inherits(cond, "condition")) {
[13:17:29.229]                         if (!is.null(pattern)) {
[13:17:29.229]                           computeRestarts <- base::computeRestarts
[13:17:29.229]                           grepl <- base::grepl
[13:17:29.229]                           restarts <- computeRestarts(cond)
[13:17:29.229]                           for (restart in restarts) {
[13:17:29.229]                             name <- restart$name
[13:17:29.229]                             if (is.null(name)) 
[13:17:29.229]                               next
[13:17:29.229]                             if (!grepl(pattern, name)) 
[13:17:29.229]                               next
[13:17:29.229]                             invokeRestart(restart)
[13:17:29.229]                             muffled <- TRUE
[13:17:29.229]                             break
[13:17:29.229]                           }
[13:17:29.229]                         }
[13:17:29.229]                       }
[13:17:29.229]                       invisible(muffled)
[13:17:29.229]                     }
[13:17:29.229]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.229]                   }
[13:17:29.229]                 }
[13:17:29.229]             }
[13:17:29.229]         }))
[13:17:29.229]     }, error = function(ex) {
[13:17:29.229]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.229]                 ...future.rng), started = ...future.startTime, 
[13:17:29.229]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.229]             version = "1.8"), class = "FutureResult")
[13:17:29.229]     }, finally = {
[13:17:29.229]         if (!identical(...future.workdir, getwd())) 
[13:17:29.229]             setwd(...future.workdir)
[13:17:29.229]         {
[13:17:29.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.229]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.229]             }
[13:17:29.229]             base::options(...future.oldOptions)
[13:17:29.229]             if (.Platform$OS.type == "windows") {
[13:17:29.229]                 old_names <- names(...future.oldEnvVars)
[13:17:29.229]                 envs <- base::Sys.getenv()
[13:17:29.229]                 names <- names(envs)
[13:17:29.229]                 common <- intersect(names, old_names)
[13:17:29.229]                 added <- setdiff(names, old_names)
[13:17:29.229]                 removed <- setdiff(old_names, names)
[13:17:29.229]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.229]                   envs[common]]
[13:17:29.229]                 NAMES <- toupper(changed)
[13:17:29.229]                 args <- list()
[13:17:29.229]                 for (kk in seq_along(NAMES)) {
[13:17:29.229]                   name <- changed[[kk]]
[13:17:29.229]                   NAME <- NAMES[[kk]]
[13:17:29.229]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.229]                     next
[13:17:29.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.229]                 }
[13:17:29.229]                 NAMES <- toupper(added)
[13:17:29.229]                 for (kk in seq_along(NAMES)) {
[13:17:29.229]                   name <- added[[kk]]
[13:17:29.229]                   NAME <- NAMES[[kk]]
[13:17:29.229]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.229]                     next
[13:17:29.229]                   args[[name]] <- ""
[13:17:29.229]                 }
[13:17:29.229]                 NAMES <- toupper(removed)
[13:17:29.229]                 for (kk in seq_along(NAMES)) {
[13:17:29.229]                   name <- removed[[kk]]
[13:17:29.229]                   NAME <- NAMES[[kk]]
[13:17:29.229]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.229]                     next
[13:17:29.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.229]                 }
[13:17:29.229]                 if (length(args) > 0) 
[13:17:29.229]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.229]             }
[13:17:29.229]             else {
[13:17:29.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.229]             }
[13:17:29.229]             {
[13:17:29.229]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.229]                   0L) {
[13:17:29.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.229]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.229]                   base::options(opts)
[13:17:29.229]                 }
[13:17:29.229]                 {
[13:17:29.229]                   {
[13:17:29.229]                     NULL
[13:17:29.229]                     RNGkind("Mersenne-Twister")
[13:17:29.229]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.229]                       inherits = FALSE)
[13:17:29.229]                   }
[13:17:29.229]                   options(future.plan = NULL)
[13:17:29.229]                   if (is.na(NA_character_)) 
[13:17:29.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.229]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.229]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.229]                     envir = parent.frame()) 
[13:17:29.229]                   {
[13:17:29.229]                     if (is.function(workers)) 
[13:17:29.229]                       workers <- workers()
[13:17:29.229]                     workers <- structure(as.integer(workers), 
[13:17:29.229]                       class = class(workers))
[13:17:29.229]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.229]                       workers >= 1)
[13:17:29.229]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.229]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.229]                     }
[13:17:29.229]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.229]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.229]                       envir = envir)
[13:17:29.229]                     if (!future$lazy) 
[13:17:29.229]                       future <- run(future)
[13:17:29.229]                     invisible(future)
[13:17:29.229]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.229]                 }
[13:17:29.229]             }
[13:17:29.229]         }
[13:17:29.229]     })
[13:17:29.229]     if (TRUE) {
[13:17:29.229]         base::sink(type = "output", split = FALSE)
[13:17:29.229]         if (TRUE) {
[13:17:29.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.229]         }
[13:17:29.229]         else {
[13:17:29.229]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.229]         }
[13:17:29.229]         base::close(...future.stdout)
[13:17:29.229]         ...future.stdout <- NULL
[13:17:29.229]     }
[13:17:29.229]     ...future.result$conditions <- ...future.conditions
[13:17:29.229]     ...future.result$finished <- base::Sys.time()
[13:17:29.229]     ...future.result
[13:17:29.229] }
[13:17:29.231] assign_globals() ...
[13:17:29.231] List of 5
[13:17:29.231]  $ ...future.FUN            :function (object, ...)  
[13:17:29.231]  $ future.call.arguments    : list()
[13:17:29.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.231]  $ ...future.elements_ii    :List of 3
[13:17:29.231]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.231]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.231]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.231]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.231]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.231]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.231]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.231]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.231]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.231]  $ ...future.seeds_ii       : NULL
[13:17:29.231]  $ ...future.globals.maxSize: NULL
[13:17:29.231]  - attr(*, "resolved")= logi FALSE
[13:17:29.231]  - attr(*, "total_size")= num 1240
[13:17:29.231]  - attr(*, "where")=List of 5
[13:17:29.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.231]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.231]  - attr(*, "already-done")= logi TRUE
[13:17:29.238] - copied ‘...future.FUN’ to environment
[13:17:29.238] - copied ‘future.call.arguments’ to environment
[13:17:29.239] - copied ‘...future.elements_ii’ to environment
[13:17:29.239] - copied ‘...future.seeds_ii’ to environment
[13:17:29.239] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.239] assign_globals() ... done
[13:17:29.239] plan(): Setting new future strategy stack:
[13:17:29.239] List of future strategies:
[13:17:29.239] 1. sequential:
[13:17:29.239]    - args: function (..., envir = parent.frame())
[13:17:29.239]    - tweaked: FALSE
[13:17:29.239]    - call: NULL
[13:17:29.240] plan(): nbrOfWorkers() = 1
[13:17:29.243] plan(): Setting new future strategy stack:
[13:17:29.243] List of future strategies:
[13:17:29.243] 1. multisession:
[13:17:29.243]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.243]    - tweaked: FALSE
[13:17:29.243]    - call: plan(strategy)
[13:17:29.247] plan(): nbrOfWorkers() = 1
[13:17:29.247] SequentialFuture started (and completed)
[13:17:29.247] - Launch lazy future ... done
[13:17:29.247] run() for ‘SequentialFuture’ ... done
[13:17:29.247] Created future:
[13:17:29.247] SequentialFuture:
[13:17:29.247] Label: ‘future_by-1’
[13:17:29.247] Expression:
[13:17:29.247] {
[13:17:29.247]     do.call(function(...) {
[13:17:29.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.247]             on.exit(options(oopts), add = TRUE)
[13:17:29.247]         }
[13:17:29.247]         {
[13:17:29.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.247]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.247]             })
[13:17:29.247]         }
[13:17:29.247]     }, args = future.call.arguments)
[13:17:29.247] }
[13:17:29.247] Lazy evaluation: FALSE
[13:17:29.247] Asynchronous evaluation: FALSE
[13:17:29.247] Local evaluation: TRUE
[13:17:29.247] Environment: R_GlobalEnv
[13:17:29.247] Capture standard output: TRUE
[13:17:29.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.247] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.247] Packages: <none>
[13:17:29.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.247] Resolved: TRUE
[13:17:29.247] Value: 4.62 KiB of class ‘list’
[13:17:29.247] Early signaling: FALSE
[13:17:29.247] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.247] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.248] Chunk #1 of 1 ... DONE
[13:17:29.249] Launching 1 futures (chunks) ... DONE
[13:17:29.249] Resolving 1 futures (chunks) ...
[13:17:29.249] resolve() on list ...
[13:17:29.249]  recursive: 0
[13:17:29.249]  length: 1
[13:17:29.249] 
[13:17:29.249] resolved() for ‘SequentialFuture’ ...
[13:17:29.249] - state: ‘finished’
[13:17:29.249] - run: TRUE
[13:17:29.249] - result: ‘FutureResult’
[13:17:29.250] resolved() for ‘SequentialFuture’ ... done
[13:17:29.250] Future #1
[13:17:29.250] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.250] - nx: 1
[13:17:29.250] - relay: TRUE
[13:17:29.250] - stdout: TRUE
[13:17:29.250] - signal: TRUE
[13:17:29.250] - resignal: FALSE
[13:17:29.250] - force: TRUE
[13:17:29.250] - relayed: [n=1] FALSE
[13:17:29.250] - queued futures: [n=1] FALSE
[13:17:29.251]  - until=1
[13:17:29.251]  - relaying element #1
[13:17:29.251] - relayed: [n=1] TRUE
[13:17:29.251] - queued futures: [n=1] TRUE
[13:17:29.251] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.251]  length: 0 (resolved future 1)
[13:17:29.251] Relaying remaining futures
[13:17:29.251] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.251] - nx: 1
[13:17:29.252] - relay: TRUE
[13:17:29.252] - stdout: TRUE
[13:17:29.252] - signal: TRUE
[13:17:29.252] - resignal: FALSE
[13:17:29.252] - force: TRUE
[13:17:29.252] - relayed: [n=1] TRUE
[13:17:29.252] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.252] - relayed: [n=1] TRUE
[13:17:29.252] - queued futures: [n=1] TRUE
[13:17:29.252] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.252] resolve() on list ... DONE
[13:17:29.253]  - Number of value chunks collected: 1
[13:17:29.253] Resolving 1 futures (chunks) ... DONE
[13:17:29.253] Reducing values from 1 chunks ...
[13:17:29.253]  - Number of values collected after concatenation: 3
[13:17:29.253]  - Number of values expected: 3
[13:17:29.253] Reducing values from 1 chunks ... DONE
[13:17:29.253] future_lapply() ... DONE
[13:17:29.253] future_by_internal() ... DONE
[13:17:29.253] future_by_internal() ...
[13:17:29.254] future_lapply() ...
[13:17:29.257] Number of chunks: 1
[13:17:29.257] getGlobalsAndPackagesXApply() ...
[13:17:29.258]  - future.globals: TRUE
[13:17:29.258] getGlobalsAndPackages() ...
[13:17:29.258] Searching for globals...
[13:17:29.259] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.259] Searching for globals ... DONE
[13:17:29.259] Resolving globals: FALSE
[13:17:29.259] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.260] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.260] - globals: [1] ‘FUN’
[13:17:29.260] 
[13:17:29.260] getGlobalsAndPackages() ... DONE
[13:17:29.260]  - globals found/used: [n=1] ‘FUN’
[13:17:29.260]  - needed namespaces: [n=0] 
[13:17:29.260] Finding globals ... DONE
[13:17:29.260]  - use_args: TRUE
[13:17:29.260]  - Getting '...' globals ...
[13:17:29.261] resolve() on list ...
[13:17:29.261]  recursive: 0
[13:17:29.261]  length: 1
[13:17:29.261]  elements: ‘...’
[13:17:29.261]  length: 0 (resolved future 1)
[13:17:29.261] resolve() on list ... DONE
[13:17:29.261]    - '...' content: [n=1] ‘digits’
[13:17:29.261] List of 1
[13:17:29.261]  $ ...:List of 1
[13:17:29.261]   ..$ digits: int 2
[13:17:29.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.261]  - attr(*, "where")=List of 1
[13:17:29.261]   ..$ ...:<environment: 0x5609e94ec2e0> 
[13:17:29.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.261]  - attr(*, "resolved")= logi TRUE
[13:17:29.261]  - attr(*, "total_size")= num NA
[13:17:29.264]  - Getting '...' globals ... DONE
[13:17:29.264] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.265] List of 2
[13:17:29.265]  $ ...future.FUN:function (object, ...)  
[13:17:29.265]  $ ...          :List of 1
[13:17:29.265]   ..$ digits: int 2
[13:17:29.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.265]  - attr(*, "where")=List of 2
[13:17:29.265]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.265]   ..$ ...          :<environment: 0x5609e94ec2e0> 
[13:17:29.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.265]  - attr(*, "resolved")= logi FALSE
[13:17:29.265]  - attr(*, "total_size")= num 1296
[13:17:29.269] Packages to be attached in all futures: [n=0] 
[13:17:29.269] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.270] Number of futures (= number of chunks): 1
[13:17:29.270] Launching 1 futures (chunks) ...
[13:17:29.270] Chunk #1 of 1 ...
[13:17:29.270]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.270] getGlobalsAndPackages() ...
[13:17:29.270] Searching for globals...
[13:17:29.270] 
[13:17:29.270] Searching for globals ... DONE
[13:17:29.270] - globals: [0] <none>
[13:17:29.271] getGlobalsAndPackages() ... DONE
[13:17:29.271]    + additional globals found: [n=0] 
[13:17:29.271]    + additional namespaces needed: [n=0] 
[13:17:29.271]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.271]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[13:17:29.271]  - seeds: <none>
[13:17:29.271] getGlobalsAndPackages() ...
[13:17:29.271] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.271] Resolving globals: FALSE
[13:17:29.271] Tweak future expression to call with '...' arguments ...
[13:17:29.272] {
[13:17:29.272]     do.call(function(...) {
[13:17:29.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.272]             on.exit(options(oopts), add = TRUE)
[13:17:29.272]         }
[13:17:29.272]         {
[13:17:29.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.272]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.272]             })
[13:17:29.272]         }
[13:17:29.272]     }, args = future.call.arguments)
[13:17:29.272] }
[13:17:29.272] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.272] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.272] 
[13:17:29.272] getGlobalsAndPackages() ... DONE
[13:17:29.273] run() for ‘Future’ ...
[13:17:29.273] - state: ‘created’
[13:17:29.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.276] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.276]   - Field: ‘label’
[13:17:29.276]   - Field: ‘local’
[13:17:29.277]   - Field: ‘owner’
[13:17:29.277]   - Field: ‘envir’
[13:17:29.277]   - Field: ‘packages’
[13:17:29.277]   - Field: ‘gc’
[13:17:29.277]   - Field: ‘conditions’
[13:17:29.277]   - Field: ‘expr’
[13:17:29.277]   - Field: ‘uuid’
[13:17:29.277]   - Field: ‘seed’
[13:17:29.277]   - Field: ‘version’
[13:17:29.277]   - Field: ‘result’
[13:17:29.278]   - Field: ‘asynchronous’
[13:17:29.278]   - Field: ‘calls’
[13:17:29.278]   - Field: ‘globals’
[13:17:29.278]   - Field: ‘stdout’
[13:17:29.278]   - Field: ‘earlySignal’
[13:17:29.278]   - Field: ‘lazy’
[13:17:29.278]   - Field: ‘state’
[13:17:29.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.278] - Launch lazy future ...
[13:17:29.278] Packages needed by the future expression (n = 0): <none>
[13:17:29.279] Packages needed by future strategies (n = 0): <none>
[13:17:29.279] {
[13:17:29.279]     {
[13:17:29.279]         {
[13:17:29.279]             ...future.startTime <- base::Sys.time()
[13:17:29.279]             {
[13:17:29.279]                 {
[13:17:29.279]                   {
[13:17:29.279]                     base::local({
[13:17:29.279]                       has_future <- base::requireNamespace("future", 
[13:17:29.279]                         quietly = TRUE)
[13:17:29.279]                       if (has_future) {
[13:17:29.279]                         ns <- base::getNamespace("future")
[13:17:29.279]                         version <- ns[[".package"]][["version"]]
[13:17:29.279]                         if (is.null(version)) 
[13:17:29.279]                           version <- utils::packageVersion("future")
[13:17:29.279]                       }
[13:17:29.279]                       else {
[13:17:29.279]                         version <- NULL
[13:17:29.279]                       }
[13:17:29.279]                       if (!has_future || version < "1.8.0") {
[13:17:29.279]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.279]                           "", base::R.version$version.string), 
[13:17:29.279]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.279]                             "release", "version")], collapse = " "), 
[13:17:29.279]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.279]                           info)
[13:17:29.279]                         info <- base::paste(info, collapse = "; ")
[13:17:29.279]                         if (!has_future) {
[13:17:29.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.279]                             info)
[13:17:29.279]                         }
[13:17:29.279]                         else {
[13:17:29.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.279]                             info, version)
[13:17:29.279]                         }
[13:17:29.279]                         base::stop(msg)
[13:17:29.279]                       }
[13:17:29.279]                     })
[13:17:29.279]                   }
[13:17:29.279]                   options(future.plan = NULL)
[13:17:29.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.279]                 }
[13:17:29.279]                 ...future.workdir <- getwd()
[13:17:29.279]             }
[13:17:29.279]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.279]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.279]         }
[13:17:29.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.279]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[13:17:29.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.279]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.279]             base::names(...future.oldOptions))
[13:17:29.279]     }
[13:17:29.279]     if (FALSE) {
[13:17:29.279]     }
[13:17:29.279]     else {
[13:17:29.279]         if (TRUE) {
[13:17:29.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.279]                 open = "w")
[13:17:29.279]         }
[13:17:29.279]         else {
[13:17:29.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.279]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.279]         }
[13:17:29.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.279]             base::sink(type = "output", split = FALSE)
[13:17:29.279]             base::close(...future.stdout)
[13:17:29.279]         }, add = TRUE)
[13:17:29.279]     }
[13:17:29.279]     ...future.frame <- base::sys.nframe()
[13:17:29.279]     ...future.conditions <- base::list()
[13:17:29.279]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.279]     if (FALSE) {
[13:17:29.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.279]     }
[13:17:29.279]     ...future.result <- base::tryCatch({
[13:17:29.279]         base::withCallingHandlers({
[13:17:29.279]             ...future.value <- base::withVisible(base::local({
[13:17:29.279]                 do.call(function(...) {
[13:17:29.279]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.279]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.279]                     ...future.globals.maxSize)) {
[13:17:29.279]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.279]                     on.exit(options(oopts), add = TRUE)
[13:17:29.279]                   }
[13:17:29.279]                   {
[13:17:29.279]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.279]                       FUN = function(jj) {
[13:17:29.279]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.279]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.279]                       })
[13:17:29.279]                   }
[13:17:29.279]                 }, args = future.call.arguments)
[13:17:29.279]             }))
[13:17:29.279]             future::FutureResult(value = ...future.value$value, 
[13:17:29.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.279]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.279]                     ...future.globalenv.names))
[13:17:29.279]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.279]         }, condition = base::local({
[13:17:29.279]             c <- base::c
[13:17:29.279]             inherits <- base::inherits
[13:17:29.279]             invokeRestart <- base::invokeRestart
[13:17:29.279]             length <- base::length
[13:17:29.279]             list <- base::list
[13:17:29.279]             seq.int <- base::seq.int
[13:17:29.279]             signalCondition <- base::signalCondition
[13:17:29.279]             sys.calls <- base::sys.calls
[13:17:29.279]             `[[` <- base::`[[`
[13:17:29.279]             `+` <- base::`+`
[13:17:29.279]             `<<-` <- base::`<<-`
[13:17:29.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.279]                   3L)]
[13:17:29.279]             }
[13:17:29.279]             function(cond) {
[13:17:29.279]                 is_error <- inherits(cond, "error")
[13:17:29.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.279]                   NULL)
[13:17:29.279]                 if (is_error) {
[13:17:29.279]                   sessionInformation <- function() {
[13:17:29.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.279]                       search = base::search(), system = base::Sys.info())
[13:17:29.279]                   }
[13:17:29.279]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.279]                     cond$call), session = sessionInformation(), 
[13:17:29.279]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.279]                   signalCondition(cond)
[13:17:29.279]                 }
[13:17:29.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.279]                 "immediateCondition"))) {
[13:17:29.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.279]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.279]                   if (TRUE && !signal) {
[13:17:29.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.279]                     {
[13:17:29.279]                       inherits <- base::inherits
[13:17:29.279]                       invokeRestart <- base::invokeRestart
[13:17:29.279]                       is.null <- base::is.null
[13:17:29.279]                       muffled <- FALSE
[13:17:29.279]                       if (inherits(cond, "message")) {
[13:17:29.279]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.279]                         if (muffled) 
[13:17:29.279]                           invokeRestart("muffleMessage")
[13:17:29.279]                       }
[13:17:29.279]                       else if (inherits(cond, "warning")) {
[13:17:29.279]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.279]                         if (muffled) 
[13:17:29.279]                           invokeRestart("muffleWarning")
[13:17:29.279]                       }
[13:17:29.279]                       else if (inherits(cond, "condition")) {
[13:17:29.279]                         if (!is.null(pattern)) {
[13:17:29.279]                           computeRestarts <- base::computeRestarts
[13:17:29.279]                           grepl <- base::grepl
[13:17:29.279]                           restarts <- computeRestarts(cond)
[13:17:29.279]                           for (restart in restarts) {
[13:17:29.279]                             name <- restart$name
[13:17:29.279]                             if (is.null(name)) 
[13:17:29.279]                               next
[13:17:29.279]                             if (!grepl(pattern, name)) 
[13:17:29.279]                               next
[13:17:29.279]                             invokeRestart(restart)
[13:17:29.279]                             muffled <- TRUE
[13:17:29.279]                             break
[13:17:29.279]                           }
[13:17:29.279]                         }
[13:17:29.279]                       }
[13:17:29.279]                       invisible(muffled)
[13:17:29.279]                     }
[13:17:29.279]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.279]                   }
[13:17:29.279]                 }
[13:17:29.279]                 else {
[13:17:29.279]                   if (TRUE) {
[13:17:29.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.279]                     {
[13:17:29.279]                       inherits <- base::inherits
[13:17:29.279]                       invokeRestart <- base::invokeRestart
[13:17:29.279]                       is.null <- base::is.null
[13:17:29.279]                       muffled <- FALSE
[13:17:29.279]                       if (inherits(cond, "message")) {
[13:17:29.279]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.279]                         if (muffled) 
[13:17:29.279]                           invokeRestart("muffleMessage")
[13:17:29.279]                       }
[13:17:29.279]                       else if (inherits(cond, "warning")) {
[13:17:29.279]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.279]                         if (muffled) 
[13:17:29.279]                           invokeRestart("muffleWarning")
[13:17:29.279]                       }
[13:17:29.279]                       else if (inherits(cond, "condition")) {
[13:17:29.279]                         if (!is.null(pattern)) {
[13:17:29.279]                           computeRestarts <- base::computeRestarts
[13:17:29.279]                           grepl <- base::grepl
[13:17:29.279]                           restarts <- computeRestarts(cond)
[13:17:29.279]                           for (restart in restarts) {
[13:17:29.279]                             name <- restart$name
[13:17:29.279]                             if (is.null(name)) 
[13:17:29.279]                               next
[13:17:29.279]                             if (!grepl(pattern, name)) 
[13:17:29.279]                               next
[13:17:29.279]                             invokeRestart(restart)
[13:17:29.279]                             muffled <- TRUE
[13:17:29.279]                             break
[13:17:29.279]                           }
[13:17:29.279]                         }
[13:17:29.279]                       }
[13:17:29.279]                       invisible(muffled)
[13:17:29.279]                     }
[13:17:29.279]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.279]                   }
[13:17:29.279]                 }
[13:17:29.279]             }
[13:17:29.279]         }))
[13:17:29.279]     }, error = function(ex) {
[13:17:29.279]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.279]                 ...future.rng), started = ...future.startTime, 
[13:17:29.279]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.279]             version = "1.8"), class = "FutureResult")
[13:17:29.279]     }, finally = {
[13:17:29.279]         if (!identical(...future.workdir, getwd())) 
[13:17:29.279]             setwd(...future.workdir)
[13:17:29.279]         {
[13:17:29.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.279]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.279]             }
[13:17:29.279]             base::options(...future.oldOptions)
[13:17:29.279]             if (.Platform$OS.type == "windows") {
[13:17:29.279]                 old_names <- names(...future.oldEnvVars)
[13:17:29.279]                 envs <- base::Sys.getenv()
[13:17:29.279]                 names <- names(envs)
[13:17:29.279]                 common <- intersect(names, old_names)
[13:17:29.279]                 added <- setdiff(names, old_names)
[13:17:29.279]                 removed <- setdiff(old_names, names)
[13:17:29.279]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.279]                   envs[common]]
[13:17:29.279]                 NAMES <- toupper(changed)
[13:17:29.279]                 args <- list()
[13:17:29.279]                 for (kk in seq_along(NAMES)) {
[13:17:29.279]                   name <- changed[[kk]]
[13:17:29.279]                   NAME <- NAMES[[kk]]
[13:17:29.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.279]                     next
[13:17:29.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.279]                 }
[13:17:29.279]                 NAMES <- toupper(added)
[13:17:29.279]                 for (kk in seq_along(NAMES)) {
[13:17:29.279]                   name <- added[[kk]]
[13:17:29.279]                   NAME <- NAMES[[kk]]
[13:17:29.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.279]                     next
[13:17:29.279]                   args[[name]] <- ""
[13:17:29.279]                 }
[13:17:29.279]                 NAMES <- toupper(removed)
[13:17:29.279]                 for (kk in seq_along(NAMES)) {
[13:17:29.279]                   name <- removed[[kk]]
[13:17:29.279]                   NAME <- NAMES[[kk]]
[13:17:29.279]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.279]                     next
[13:17:29.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.279]                 }
[13:17:29.279]                 if (length(args) > 0) 
[13:17:29.279]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.279]             }
[13:17:29.279]             else {
[13:17:29.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.279]             }
[13:17:29.279]             {
[13:17:29.279]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.279]                   0L) {
[13:17:29.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.279]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.279]                   base::options(opts)
[13:17:29.279]                 }
[13:17:29.279]                 {
[13:17:29.279]                   {
[13:17:29.279]                     NULL
[13:17:29.279]                     RNGkind("Mersenne-Twister")
[13:17:29.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.279]                       inherits = FALSE)
[13:17:29.279]                   }
[13:17:29.279]                   options(future.plan = NULL)
[13:17:29.279]                   if (is.na(NA_character_)) 
[13:17:29.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.279]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.279]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.279]                     envir = parent.frame()) 
[13:17:29.279]                   {
[13:17:29.279]                     if (is.function(workers)) 
[13:17:29.279]                       workers <- workers()
[13:17:29.279]                     workers <- structure(as.integer(workers), 
[13:17:29.279]                       class = class(workers))
[13:17:29.279]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.279]                       workers >= 1)
[13:17:29.279]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.279]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.279]                     }
[13:17:29.279]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.279]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.279]                       envir = envir)
[13:17:29.279]                     if (!future$lazy) 
[13:17:29.279]                       future <- run(future)
[13:17:29.279]                     invisible(future)
[13:17:29.279]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.279]                 }
[13:17:29.279]             }
[13:17:29.279]         }
[13:17:29.279]     })
[13:17:29.279]     if (TRUE) {
[13:17:29.279]         base::sink(type = "output", split = FALSE)
[13:17:29.279]         if (TRUE) {
[13:17:29.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.279]         }
[13:17:29.279]         else {
[13:17:29.279]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.279]         }
[13:17:29.279]         base::close(...future.stdout)
[13:17:29.279]         ...future.stdout <- NULL
[13:17:29.279]     }
[13:17:29.279]     ...future.result$conditions <- ...future.conditions
[13:17:29.279]     ...future.result$finished <- base::Sys.time()
[13:17:29.279]     ...future.result
[13:17:29.279] }
[13:17:29.281] assign_globals() ...
[13:17:29.281] List of 5
[13:17:29.281]  $ ...future.FUN            :function (object, ...)  
[13:17:29.281]  $ future.call.arguments    :List of 1
[13:17:29.281]   ..$ digits: int 2
[13:17:29.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.281]  $ ...future.elements_ii    :List of 6
[13:17:29.281]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:17:29.281]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:17:29.281]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:17:29.281]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:17:29.281]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:17:29.281]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:17:29.281]  $ ...future.seeds_ii       : NULL
[13:17:29.281]  $ ...future.globals.maxSize: NULL
[13:17:29.281]  - attr(*, "resolved")= logi FALSE
[13:17:29.281]  - attr(*, "total_size")= num 1296
[13:17:29.281]  - attr(*, "where")=List of 5
[13:17:29.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.281]  - attr(*, "already-done")= logi TRUE
[13:17:29.287] - copied ‘...future.FUN’ to environment
[13:17:29.287] - copied ‘future.call.arguments’ to environment
[13:17:29.288] - copied ‘...future.elements_ii’ to environment
[13:17:29.288] - copied ‘...future.seeds_ii’ to environment
[13:17:29.288] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.288] assign_globals() ... done
[13:17:29.288] plan(): Setting new future strategy stack:
[13:17:29.288] List of future strategies:
[13:17:29.288] 1. sequential:
[13:17:29.288]    - args: function (..., envir = parent.frame())
[13:17:29.288]    - tweaked: FALSE
[13:17:29.288]    - call: NULL
[13:17:29.289] plan(): nbrOfWorkers() = 1
[13:17:29.291] plan(): Setting new future strategy stack:
[13:17:29.291] List of future strategies:
[13:17:29.291] 1. multisession:
[13:17:29.291]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.291]    - tweaked: FALSE
[13:17:29.291]    - call: plan(strategy)
[13:17:29.295] plan(): nbrOfWorkers() = 1
[13:17:29.295] SequentialFuture started (and completed)
[13:17:29.295] - Launch lazy future ... done
[13:17:29.295] run() for ‘SequentialFuture’ ... done
[13:17:29.296] Created future:
[13:17:29.296] SequentialFuture:
[13:17:29.296] Label: ‘future_by-1’
[13:17:29.296] Expression:
[13:17:29.296] {
[13:17:29.296]     do.call(function(...) {
[13:17:29.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.296]             on.exit(options(oopts), add = TRUE)
[13:17:29.296]         }
[13:17:29.296]         {
[13:17:29.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.296]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.296]             })
[13:17:29.296]         }
[13:17:29.296]     }, args = future.call.arguments)
[13:17:29.296] }
[13:17:29.296] Lazy evaluation: FALSE
[13:17:29.296] Asynchronous evaluation: FALSE
[13:17:29.296] Local evaluation: TRUE
[13:17:29.296] Environment: R_GlobalEnv
[13:17:29.296] Capture standard output: TRUE
[13:17:29.296] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.296] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.296] Packages: <none>
[13:17:29.296] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.296] Resolved: TRUE
[13:17:29.296] Value: 5.48 KiB of class ‘list’
[13:17:29.296] Early signaling: FALSE
[13:17:29.296] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.296] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.297] Chunk #1 of 1 ... DONE
[13:17:29.297] Launching 1 futures (chunks) ... DONE
[13:17:29.297] Resolving 1 futures (chunks) ...
[13:17:29.297] resolve() on list ...
[13:17:29.297]  recursive: 0
[13:17:29.297]  length: 1
[13:17:29.297] 
[13:17:29.297] resolved() for ‘SequentialFuture’ ...
[13:17:29.297] - state: ‘finished’
[13:17:29.298] - run: TRUE
[13:17:29.298] - result: ‘FutureResult’
[13:17:29.298] resolved() for ‘SequentialFuture’ ... done
[13:17:29.298] Future #1
[13:17:29.298] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.298] - nx: 1
[13:17:29.298] - relay: TRUE
[13:17:29.298] - stdout: TRUE
[13:17:29.298] - signal: TRUE
[13:17:29.298] - resignal: FALSE
[13:17:29.298] - force: TRUE
[13:17:29.299] - relayed: [n=1] FALSE
[13:17:29.299] - queued futures: [n=1] FALSE
[13:17:29.299]  - until=1
[13:17:29.299]  - relaying element #1
[13:17:29.299] - relayed: [n=1] TRUE
[13:17:29.299] - queued futures: [n=1] TRUE
[13:17:29.299] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.299]  length: 0 (resolved future 1)
[13:17:29.299] Relaying remaining futures
[13:17:29.299] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.300] - nx: 1
[13:17:29.300] - relay: TRUE
[13:17:29.300] - stdout: TRUE
[13:17:29.300] - signal: TRUE
[13:17:29.300] - resignal: FALSE
[13:17:29.300] - force: TRUE
[13:17:29.300] - relayed: [n=1] TRUE
[13:17:29.300] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.300] - relayed: [n=1] TRUE
[13:17:29.300] - queued futures: [n=1] TRUE
[13:17:29.300] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.301] resolve() on list ... DONE
[13:17:29.301]  - Number of value chunks collected: 1
[13:17:29.301] Resolving 1 futures (chunks) ... DONE
[13:17:29.301] Reducing values from 1 chunks ...
[13:17:29.301]  - Number of values collected after concatenation: 6
[13:17:29.301]  - Number of values expected: 6
[13:17:29.301] Reducing values from 1 chunks ... DONE
[13:17:29.301] future_lapply() ... DONE
[13:17:29.301] future_by_internal() ... DONE
[13:17:29.302] future_by_internal() ...
[13:17:29.303] future_lapply() ...
[13:17:29.307] Number of chunks: 1
[13:17:29.307] getGlobalsAndPackagesXApply() ...
[13:17:29.307]  - future.globals: TRUE
[13:17:29.307] getGlobalsAndPackages() ...
[13:17:29.307] Searching for globals...
[13:17:29.308] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:29.309] Searching for globals ... DONE
[13:17:29.309] Resolving globals: FALSE
[13:17:29.309] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:17:29.310] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:17:29.310] - globals: [1] ‘FUN’
[13:17:29.310] - packages: [1] ‘stats’
[13:17:29.310] getGlobalsAndPackages() ... DONE
[13:17:29.310]  - globals found/used: [n=1] ‘FUN’
[13:17:29.310]  - needed namespaces: [n=1] ‘stats’
[13:17:29.310] Finding globals ... DONE
[13:17:29.310]  - use_args: TRUE
[13:17:29.310]  - Getting '...' globals ...
[13:17:29.311] resolve() on list ...
[13:17:29.311]  recursive: 0
[13:17:29.311]  length: 1
[13:17:29.311]  elements: ‘...’
[13:17:29.311]  length: 0 (resolved future 1)
[13:17:29.311] resolve() on list ... DONE
[13:17:29.311]    - '...' content: [n=1] ‘singular.ok’
[13:17:29.311] List of 1
[13:17:29.311]  $ ...:List of 1
[13:17:29.311]   ..$ singular.ok: logi FALSE
[13:17:29.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.311]  - attr(*, "where")=List of 1
[13:17:29.311]   ..$ ...:<environment: 0x5609ea1d8278> 
[13:17:29.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.311]  - attr(*, "resolved")= logi TRUE
[13:17:29.311]  - attr(*, "total_size")= num NA
[13:17:29.316]  - Getting '...' globals ... DONE
[13:17:29.316] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.316] List of 2
[13:17:29.316]  $ ...future.FUN:function (x, ...)  
[13:17:29.316]  $ ...          :List of 1
[13:17:29.316]   ..$ singular.ok: logi FALSE
[13:17:29.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.316]  - attr(*, "where")=List of 2
[13:17:29.316]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.316]   ..$ ...          :<environment: 0x5609ea1d8278> 
[13:17:29.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.316]  - attr(*, "resolved")= logi FALSE
[13:17:29.316]  - attr(*, "total_size")= num 5384
[13:17:29.319] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:29.319] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.320] Number of futures (= number of chunks): 1
[13:17:29.320] Launching 1 futures (chunks) ...
[13:17:29.320] Chunk #1 of 1 ...
[13:17:29.320]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.320] getGlobalsAndPackages() ...
[13:17:29.320] Searching for globals...
[13:17:29.321] 
[13:17:29.321] Searching for globals ... DONE
[13:17:29.321] - globals: [0] <none>
[13:17:29.321] getGlobalsAndPackages() ... DONE
[13:17:29.321]    + additional globals found: [n=0] 
[13:17:29.321]    + additional namespaces needed: [n=0] 
[13:17:29.321]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.321]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.321]  - seeds: <none>
[13:17:29.321] getGlobalsAndPackages() ...
[13:17:29.322] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.322] Resolving globals: FALSE
[13:17:29.322] Tweak future expression to call with '...' arguments ...
[13:17:29.322] {
[13:17:29.322]     do.call(function(...) {
[13:17:29.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.322]             on.exit(options(oopts), add = TRUE)
[13:17:29.322]         }
[13:17:29.322]         {
[13:17:29.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.322]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.322]             })
[13:17:29.322]         }
[13:17:29.322]     }, args = future.call.arguments)
[13:17:29.322] }
[13:17:29.322] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.322] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.323] 
[13:17:29.323] getGlobalsAndPackages() ... DONE
[13:17:29.323] run() for ‘Future’ ...
[13:17:29.323] - state: ‘created’
[13:17:29.323] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.327] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.327]   - Field: ‘label’
[13:17:29.327]   - Field: ‘local’
[13:17:29.327]   - Field: ‘owner’
[13:17:29.327]   - Field: ‘envir’
[13:17:29.327]   - Field: ‘packages’
[13:17:29.327]   - Field: ‘gc’
[13:17:29.328]   - Field: ‘conditions’
[13:17:29.328]   - Field: ‘expr’
[13:17:29.328]   - Field: ‘uuid’
[13:17:29.328]   - Field: ‘seed’
[13:17:29.328]   - Field: ‘version’
[13:17:29.328]   - Field: ‘result’
[13:17:29.328]   - Field: ‘asynchronous’
[13:17:29.328]   - Field: ‘calls’
[13:17:29.328]   - Field: ‘globals’
[13:17:29.328]   - Field: ‘stdout’
[13:17:29.328]   - Field: ‘earlySignal’
[13:17:29.329]   - Field: ‘lazy’
[13:17:29.329]   - Field: ‘state’
[13:17:29.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.329] - Launch lazy future ...
[13:17:29.329] Packages needed by the future expression (n = 1): ‘stats’
[13:17:29.329] Packages needed by future strategies (n = 0): <none>
[13:17:29.330] {
[13:17:29.330]     {
[13:17:29.330]         {
[13:17:29.330]             ...future.startTime <- base::Sys.time()
[13:17:29.330]             {
[13:17:29.330]                 {
[13:17:29.330]                   {
[13:17:29.330]                     {
[13:17:29.330]                       base::local({
[13:17:29.330]                         has_future <- base::requireNamespace("future", 
[13:17:29.330]                           quietly = TRUE)
[13:17:29.330]                         if (has_future) {
[13:17:29.330]                           ns <- base::getNamespace("future")
[13:17:29.330]                           version <- ns[[".package"]][["version"]]
[13:17:29.330]                           if (is.null(version)) 
[13:17:29.330]                             version <- utils::packageVersion("future")
[13:17:29.330]                         }
[13:17:29.330]                         else {
[13:17:29.330]                           version <- NULL
[13:17:29.330]                         }
[13:17:29.330]                         if (!has_future || version < "1.8.0") {
[13:17:29.330]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.330]                             "", base::R.version$version.string), 
[13:17:29.330]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.330]                               "release", "version")], collapse = " "), 
[13:17:29.330]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.330]                             info)
[13:17:29.330]                           info <- base::paste(info, collapse = "; ")
[13:17:29.330]                           if (!has_future) {
[13:17:29.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.330]                               info)
[13:17:29.330]                           }
[13:17:29.330]                           else {
[13:17:29.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.330]                               info, version)
[13:17:29.330]                           }
[13:17:29.330]                           base::stop(msg)
[13:17:29.330]                         }
[13:17:29.330]                       })
[13:17:29.330]                     }
[13:17:29.330]                     base::local({
[13:17:29.330]                       for (pkg in "stats") {
[13:17:29.330]                         base::loadNamespace(pkg)
[13:17:29.330]                         base::library(pkg, character.only = TRUE)
[13:17:29.330]                       }
[13:17:29.330]                     })
[13:17:29.330]                   }
[13:17:29.330]                   options(future.plan = NULL)
[13:17:29.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.330]                 }
[13:17:29.330]                 ...future.workdir <- getwd()
[13:17:29.330]             }
[13:17:29.330]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.330]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.330]         }
[13:17:29.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.330]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.330]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.330]             base::names(...future.oldOptions))
[13:17:29.330]     }
[13:17:29.330]     if (FALSE) {
[13:17:29.330]     }
[13:17:29.330]     else {
[13:17:29.330]         if (TRUE) {
[13:17:29.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.330]                 open = "w")
[13:17:29.330]         }
[13:17:29.330]         else {
[13:17:29.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.330]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.330]         }
[13:17:29.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.330]             base::sink(type = "output", split = FALSE)
[13:17:29.330]             base::close(...future.stdout)
[13:17:29.330]         }, add = TRUE)
[13:17:29.330]     }
[13:17:29.330]     ...future.frame <- base::sys.nframe()
[13:17:29.330]     ...future.conditions <- base::list()
[13:17:29.330]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.330]     if (FALSE) {
[13:17:29.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.330]     }
[13:17:29.330]     ...future.result <- base::tryCatch({
[13:17:29.330]         base::withCallingHandlers({
[13:17:29.330]             ...future.value <- base::withVisible(base::local({
[13:17:29.330]                 do.call(function(...) {
[13:17:29.330]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.330]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.330]                     ...future.globals.maxSize)) {
[13:17:29.330]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.330]                     on.exit(options(oopts), add = TRUE)
[13:17:29.330]                   }
[13:17:29.330]                   {
[13:17:29.330]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.330]                       FUN = function(jj) {
[13:17:29.330]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.330]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.330]                       })
[13:17:29.330]                   }
[13:17:29.330]                 }, args = future.call.arguments)
[13:17:29.330]             }))
[13:17:29.330]             future::FutureResult(value = ...future.value$value, 
[13:17:29.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.330]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.330]                     ...future.globalenv.names))
[13:17:29.330]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.330]         }, condition = base::local({
[13:17:29.330]             c <- base::c
[13:17:29.330]             inherits <- base::inherits
[13:17:29.330]             invokeRestart <- base::invokeRestart
[13:17:29.330]             length <- base::length
[13:17:29.330]             list <- base::list
[13:17:29.330]             seq.int <- base::seq.int
[13:17:29.330]             signalCondition <- base::signalCondition
[13:17:29.330]             sys.calls <- base::sys.calls
[13:17:29.330]             `[[` <- base::`[[`
[13:17:29.330]             `+` <- base::`+`
[13:17:29.330]             `<<-` <- base::`<<-`
[13:17:29.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.330]                   3L)]
[13:17:29.330]             }
[13:17:29.330]             function(cond) {
[13:17:29.330]                 is_error <- inherits(cond, "error")
[13:17:29.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.330]                   NULL)
[13:17:29.330]                 if (is_error) {
[13:17:29.330]                   sessionInformation <- function() {
[13:17:29.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.330]                       search = base::search(), system = base::Sys.info())
[13:17:29.330]                   }
[13:17:29.330]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.330]                     cond$call), session = sessionInformation(), 
[13:17:29.330]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.330]                   signalCondition(cond)
[13:17:29.330]                 }
[13:17:29.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.330]                 "immediateCondition"))) {
[13:17:29.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.330]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.330]                   if (TRUE && !signal) {
[13:17:29.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.330]                     {
[13:17:29.330]                       inherits <- base::inherits
[13:17:29.330]                       invokeRestart <- base::invokeRestart
[13:17:29.330]                       is.null <- base::is.null
[13:17:29.330]                       muffled <- FALSE
[13:17:29.330]                       if (inherits(cond, "message")) {
[13:17:29.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.330]                         if (muffled) 
[13:17:29.330]                           invokeRestart("muffleMessage")
[13:17:29.330]                       }
[13:17:29.330]                       else if (inherits(cond, "warning")) {
[13:17:29.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.330]                         if (muffled) 
[13:17:29.330]                           invokeRestart("muffleWarning")
[13:17:29.330]                       }
[13:17:29.330]                       else if (inherits(cond, "condition")) {
[13:17:29.330]                         if (!is.null(pattern)) {
[13:17:29.330]                           computeRestarts <- base::computeRestarts
[13:17:29.330]                           grepl <- base::grepl
[13:17:29.330]                           restarts <- computeRestarts(cond)
[13:17:29.330]                           for (restart in restarts) {
[13:17:29.330]                             name <- restart$name
[13:17:29.330]                             if (is.null(name)) 
[13:17:29.330]                               next
[13:17:29.330]                             if (!grepl(pattern, name)) 
[13:17:29.330]                               next
[13:17:29.330]                             invokeRestart(restart)
[13:17:29.330]                             muffled <- TRUE
[13:17:29.330]                             break
[13:17:29.330]                           }
[13:17:29.330]                         }
[13:17:29.330]                       }
[13:17:29.330]                       invisible(muffled)
[13:17:29.330]                     }
[13:17:29.330]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.330]                   }
[13:17:29.330]                 }
[13:17:29.330]                 else {
[13:17:29.330]                   if (TRUE) {
[13:17:29.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.330]                     {
[13:17:29.330]                       inherits <- base::inherits
[13:17:29.330]                       invokeRestart <- base::invokeRestart
[13:17:29.330]                       is.null <- base::is.null
[13:17:29.330]                       muffled <- FALSE
[13:17:29.330]                       if (inherits(cond, "message")) {
[13:17:29.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.330]                         if (muffled) 
[13:17:29.330]                           invokeRestart("muffleMessage")
[13:17:29.330]                       }
[13:17:29.330]                       else if (inherits(cond, "warning")) {
[13:17:29.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.330]                         if (muffled) 
[13:17:29.330]                           invokeRestart("muffleWarning")
[13:17:29.330]                       }
[13:17:29.330]                       else if (inherits(cond, "condition")) {
[13:17:29.330]                         if (!is.null(pattern)) {
[13:17:29.330]                           computeRestarts <- base::computeRestarts
[13:17:29.330]                           grepl <- base::grepl
[13:17:29.330]                           restarts <- computeRestarts(cond)
[13:17:29.330]                           for (restart in restarts) {
[13:17:29.330]                             name <- restart$name
[13:17:29.330]                             if (is.null(name)) 
[13:17:29.330]                               next
[13:17:29.330]                             if (!grepl(pattern, name)) 
[13:17:29.330]                               next
[13:17:29.330]                             invokeRestart(restart)
[13:17:29.330]                             muffled <- TRUE
[13:17:29.330]                             break
[13:17:29.330]                           }
[13:17:29.330]                         }
[13:17:29.330]                       }
[13:17:29.330]                       invisible(muffled)
[13:17:29.330]                     }
[13:17:29.330]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.330]                   }
[13:17:29.330]                 }
[13:17:29.330]             }
[13:17:29.330]         }))
[13:17:29.330]     }, error = function(ex) {
[13:17:29.330]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.330]                 ...future.rng), started = ...future.startTime, 
[13:17:29.330]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.330]             version = "1.8"), class = "FutureResult")
[13:17:29.330]     }, finally = {
[13:17:29.330]         if (!identical(...future.workdir, getwd())) 
[13:17:29.330]             setwd(...future.workdir)
[13:17:29.330]         {
[13:17:29.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.330]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.330]             }
[13:17:29.330]             base::options(...future.oldOptions)
[13:17:29.330]             if (.Platform$OS.type == "windows") {
[13:17:29.330]                 old_names <- names(...future.oldEnvVars)
[13:17:29.330]                 envs <- base::Sys.getenv()
[13:17:29.330]                 names <- names(envs)
[13:17:29.330]                 common <- intersect(names, old_names)
[13:17:29.330]                 added <- setdiff(names, old_names)
[13:17:29.330]                 removed <- setdiff(old_names, names)
[13:17:29.330]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.330]                   envs[common]]
[13:17:29.330]                 NAMES <- toupper(changed)
[13:17:29.330]                 args <- list()
[13:17:29.330]                 for (kk in seq_along(NAMES)) {
[13:17:29.330]                   name <- changed[[kk]]
[13:17:29.330]                   NAME <- NAMES[[kk]]
[13:17:29.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.330]                     next
[13:17:29.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.330]                 }
[13:17:29.330]                 NAMES <- toupper(added)
[13:17:29.330]                 for (kk in seq_along(NAMES)) {
[13:17:29.330]                   name <- added[[kk]]
[13:17:29.330]                   NAME <- NAMES[[kk]]
[13:17:29.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.330]                     next
[13:17:29.330]                   args[[name]] <- ""
[13:17:29.330]                 }
[13:17:29.330]                 NAMES <- toupper(removed)
[13:17:29.330]                 for (kk in seq_along(NAMES)) {
[13:17:29.330]                   name <- removed[[kk]]
[13:17:29.330]                   NAME <- NAMES[[kk]]
[13:17:29.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.330]                     next
[13:17:29.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.330]                 }
[13:17:29.330]                 if (length(args) > 0) 
[13:17:29.330]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.330]             }
[13:17:29.330]             else {
[13:17:29.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.330]             }
[13:17:29.330]             {
[13:17:29.330]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.330]                   0L) {
[13:17:29.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.330]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.330]                   base::options(opts)
[13:17:29.330]                 }
[13:17:29.330]                 {
[13:17:29.330]                   {
[13:17:29.330]                     NULL
[13:17:29.330]                     RNGkind("Mersenne-Twister")
[13:17:29.330]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.330]                       inherits = FALSE)
[13:17:29.330]                   }
[13:17:29.330]                   options(future.plan = NULL)
[13:17:29.330]                   if (is.na(NA_character_)) 
[13:17:29.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.330]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.330]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.330]                     envir = parent.frame()) 
[13:17:29.330]                   {
[13:17:29.330]                     if (is.function(workers)) 
[13:17:29.330]                       workers <- workers()
[13:17:29.330]                     workers <- structure(as.integer(workers), 
[13:17:29.330]                       class = class(workers))
[13:17:29.330]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.330]                       workers >= 1)
[13:17:29.330]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.330]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.330]                     }
[13:17:29.330]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.330]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.330]                       envir = envir)
[13:17:29.330]                     if (!future$lazy) 
[13:17:29.330]                       future <- run(future)
[13:17:29.330]                     invisible(future)
[13:17:29.330]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.330]                 }
[13:17:29.330]             }
[13:17:29.330]         }
[13:17:29.330]     })
[13:17:29.330]     if (TRUE) {
[13:17:29.330]         base::sink(type = "output", split = FALSE)
[13:17:29.330]         if (TRUE) {
[13:17:29.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.330]         }
[13:17:29.330]         else {
[13:17:29.330]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.330]         }
[13:17:29.330]         base::close(...future.stdout)
[13:17:29.330]         ...future.stdout <- NULL
[13:17:29.330]     }
[13:17:29.330]     ...future.result$conditions <- ...future.conditions
[13:17:29.330]     ...future.result$finished <- base::Sys.time()
[13:17:29.330]     ...future.result
[13:17:29.330] }
[13:17:29.331] assign_globals() ...
[13:17:29.332] List of 5
[13:17:29.332]  $ ...future.FUN            :function (x, ...)  
[13:17:29.332]  $ future.call.arguments    :List of 1
[13:17:29.332]   ..$ singular.ok: logi FALSE
[13:17:29.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.332]  $ ...future.elements_ii    :List of 3
[13:17:29.332]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.332]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.332]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.332]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.332]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.332]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.332]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.332]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.332]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.332]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.332]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.332]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.332]  $ ...future.seeds_ii       : NULL
[13:17:29.332]  $ ...future.globals.maxSize: NULL
[13:17:29.332]  - attr(*, "resolved")= logi FALSE
[13:17:29.332]  - attr(*, "total_size")= num 5384
[13:17:29.332]  - attr(*, "where")=List of 5
[13:17:29.332]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.332]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.332]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.332]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.332]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.332]  - attr(*, "already-done")= logi TRUE
[13:17:29.342] - reassign environment for ‘...future.FUN’
[13:17:29.342] - copied ‘...future.FUN’ to environment
[13:17:29.342] - copied ‘future.call.arguments’ to environment
[13:17:29.343] - copied ‘...future.elements_ii’ to environment
[13:17:29.343] - copied ‘...future.seeds_ii’ to environment
[13:17:29.343] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.343] assign_globals() ... done
[13:17:29.343] plan(): Setting new future strategy stack:
[13:17:29.343] List of future strategies:
[13:17:29.343] 1. sequential:
[13:17:29.343]    - args: function (..., envir = parent.frame())
[13:17:29.343]    - tweaked: FALSE
[13:17:29.343]    - call: NULL
[13:17:29.344] plan(): nbrOfWorkers() = 1
[13:17:29.347] plan(): Setting new future strategy stack:
[13:17:29.347] List of future strategies:
[13:17:29.347] 1. multisession:
[13:17:29.347]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.347]    - tweaked: FALSE
[13:17:29.347]    - call: plan(strategy)
[13:17:29.351] plan(): nbrOfWorkers() = 1
[13:17:29.351] SequentialFuture started (and completed)
[13:17:29.351] - Launch lazy future ... done
[13:17:29.351] run() for ‘SequentialFuture’ ... done
[13:17:29.351] Created future:
[13:17:29.351] SequentialFuture:
[13:17:29.351] Label: ‘future_by-1’
[13:17:29.351] Expression:
[13:17:29.351] {
[13:17:29.351]     do.call(function(...) {
[13:17:29.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.351]             on.exit(options(oopts), add = TRUE)
[13:17:29.351]         }
[13:17:29.351]         {
[13:17:29.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.351]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.351]             })
[13:17:29.351]         }
[13:17:29.351]     }, args = future.call.arguments)
[13:17:29.351] }
[13:17:29.351] Lazy evaluation: FALSE
[13:17:29.351] Asynchronous evaluation: FALSE
[13:17:29.351] Local evaluation: TRUE
[13:17:29.351] Environment: R_GlobalEnv
[13:17:29.351] Capture standard output: TRUE
[13:17:29.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.351] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.351] Packages: 1 packages (‘stats’)
[13:17:29.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.351] Resolved: TRUE
[13:17:29.351] Value: 26.06 KiB of class ‘list’
[13:17:29.351] Early signaling: FALSE
[13:17:29.351] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.351] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.353] Chunk #1 of 1 ... DONE
[13:17:29.353] Launching 1 futures (chunks) ... DONE
[13:17:29.353] Resolving 1 futures (chunks) ...
[13:17:29.353] resolve() on list ...
[13:17:29.353]  recursive: 0
[13:17:29.354]  length: 1
[13:17:29.354] 
[13:17:29.354] resolved() for ‘SequentialFuture’ ...
[13:17:29.354] - state: ‘finished’
[13:17:29.354] - run: TRUE
[13:17:29.354] - result: ‘FutureResult’
[13:17:29.354] resolved() for ‘SequentialFuture’ ... done
[13:17:29.354] Future #1
[13:17:29.354] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.354] - nx: 1
[13:17:29.355] - relay: TRUE
[13:17:29.355] - stdout: TRUE
[13:17:29.355] - signal: TRUE
[13:17:29.355] - resignal: FALSE
[13:17:29.355] - force: TRUE
[13:17:29.355] - relayed: [n=1] FALSE
[13:17:29.355] - queued futures: [n=1] FALSE
[13:17:29.355]  - until=1
[13:17:29.355]  - relaying element #1
[13:17:29.355] - relayed: [n=1] TRUE
[13:17:29.356] - queued futures: [n=1] TRUE
[13:17:29.356] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.356]  length: 0 (resolved future 1)
[13:17:29.356] Relaying remaining futures
[13:17:29.356] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.356] - nx: 1
[13:17:29.356] - relay: TRUE
[13:17:29.356] - stdout: TRUE
[13:17:29.356] - signal: TRUE
[13:17:29.356] - resignal: FALSE
[13:17:29.356] - force: TRUE
[13:17:29.357] - relayed: [n=1] TRUE
[13:17:29.357] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.357] - relayed: [n=1] TRUE
[13:17:29.357] - queued futures: [n=1] TRUE
[13:17:29.357] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.357] resolve() on list ... DONE
[13:17:29.357]  - Number of value chunks collected: 1
[13:17:29.357] Resolving 1 futures (chunks) ... DONE
[13:17:29.357] Reducing values from 1 chunks ...
[13:17:29.358]  - Number of values collected after concatenation: 3
[13:17:29.358]  - Number of values expected: 3
[13:17:29.358] Reducing values from 1 chunks ... DONE
[13:17:29.358] future_lapply() ... DONE
[13:17:29.358] future_by_internal() ... DONE
[13:17:29.364] future_by_internal() ...
[13:17:29.364] future_lapply() ...
[13:17:29.368] Number of chunks: 1
[13:17:29.368] getGlobalsAndPackagesXApply() ...
[13:17:29.368]  - future.globals: TRUE
[13:17:29.368] getGlobalsAndPackages() ...
[13:17:29.368] Searching for globals...
[13:17:29.370] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:29.370] Searching for globals ... DONE
[13:17:29.370] Resolving globals: FALSE
[13:17:29.371] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:17:29.371] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:17:29.371] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:29.371] - packages: [1] ‘stats’
[13:17:29.371] getGlobalsAndPackages() ... DONE
[13:17:29.371]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:29.372]  - needed namespaces: [n=1] ‘stats’
[13:17:29.372] Finding globals ... DONE
[13:17:29.372]  - use_args: TRUE
[13:17:29.372]  - Getting '...' globals ...
[13:17:29.372] resolve() on list ...
[13:17:29.372]  recursive: 0
[13:17:29.372]  length: 1
[13:17:29.372]  elements: ‘...’
[13:17:29.373]  length: 0 (resolved future 1)
[13:17:29.373] resolve() on list ... DONE
[13:17:29.373]    - '...' content: [n=0] 
[13:17:29.373] List of 1
[13:17:29.373]  $ ...: list()
[13:17:29.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.373]  - attr(*, "where")=List of 1
[13:17:29.373]   ..$ ...:<environment: 0x5609e9035f90> 
[13:17:29.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.373]  - attr(*, "resolved")= logi TRUE
[13:17:29.373]  - attr(*, "total_size")= num NA
[13:17:29.375]  - Getting '...' globals ... DONE
[13:17:29.376] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:17:29.376] List of 4
[13:17:29.376]  $ ...future.FUN:function (x)  
[13:17:29.376]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:29.376]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.376]  $ ...          : list()
[13:17:29.376]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.376]  - attr(*, "where")=List of 4
[13:17:29.376]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.376]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:17:29.376]   ..$ wool         :<environment: R_EmptyEnv> 
[13:17:29.376]   ..$ ...          :<environment: 0x5609e9035f90> 
[13:17:29.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.376]  - attr(*, "resolved")= logi FALSE
[13:17:29.376]  - attr(*, "total_size")= num 2320
[13:17:29.381] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:29.381] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.381] Number of futures (= number of chunks): 1
[13:17:29.382] Launching 1 futures (chunks) ...
[13:17:29.382] Chunk #1 of 1 ...
[13:17:29.382]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.382] getGlobalsAndPackages() ...
[13:17:29.382] Searching for globals...
[13:17:29.382] 
[13:17:29.383] Searching for globals ... DONE
[13:17:29.383] - globals: [0] <none>
[13:17:29.383] getGlobalsAndPackages() ... DONE
[13:17:29.383]    + additional globals found: [n=0] 
[13:17:29.383]    + additional namespaces needed: [n=0] 
[13:17:29.383]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.383]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.383]  - seeds: <none>
[13:17:29.383] getGlobalsAndPackages() ...
[13:17:29.383] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.384] Resolving globals: FALSE
[13:17:29.384] Tweak future expression to call with '...' arguments ...
[13:17:29.384] {
[13:17:29.384]     do.call(function(...) {
[13:17:29.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.384]             on.exit(options(oopts), add = TRUE)
[13:17:29.384]         }
[13:17:29.384]         {
[13:17:29.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.384]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.384]             })
[13:17:29.384]         }
[13:17:29.384]     }, args = future.call.arguments)
[13:17:29.384] }
[13:17:29.384] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.384] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.384] 
[13:17:29.385] getGlobalsAndPackages() ... DONE
[13:17:29.385] run() for ‘Future’ ...
[13:17:29.385] - state: ‘created’
[13:17:29.385] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.389]   - Field: ‘label’
[13:17:29.389]   - Field: ‘local’
[13:17:29.389]   - Field: ‘owner’
[13:17:29.389]   - Field: ‘envir’
[13:17:29.389]   - Field: ‘packages’
[13:17:29.389]   - Field: ‘gc’
[13:17:29.389]   - Field: ‘conditions’
[13:17:29.389]   - Field: ‘expr’
[13:17:29.390]   - Field: ‘uuid’
[13:17:29.390]   - Field: ‘seed’
[13:17:29.390]   - Field: ‘version’
[13:17:29.390]   - Field: ‘result’
[13:17:29.390]   - Field: ‘asynchronous’
[13:17:29.390]   - Field: ‘calls’
[13:17:29.390]   - Field: ‘globals’
[13:17:29.390]   - Field: ‘stdout’
[13:17:29.390]   - Field: ‘earlySignal’
[13:17:29.390]   - Field: ‘lazy’
[13:17:29.390]   - Field: ‘state’
[13:17:29.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.391] - Launch lazy future ...
[13:17:29.391] Packages needed by the future expression (n = 1): ‘stats’
[13:17:29.391] Packages needed by future strategies (n = 0): <none>
[13:17:29.391] {
[13:17:29.391]     {
[13:17:29.391]         {
[13:17:29.391]             ...future.startTime <- base::Sys.time()
[13:17:29.391]             {
[13:17:29.391]                 {
[13:17:29.391]                   {
[13:17:29.391]                     {
[13:17:29.391]                       base::local({
[13:17:29.391]                         has_future <- base::requireNamespace("future", 
[13:17:29.391]                           quietly = TRUE)
[13:17:29.391]                         if (has_future) {
[13:17:29.391]                           ns <- base::getNamespace("future")
[13:17:29.391]                           version <- ns[[".package"]][["version"]]
[13:17:29.391]                           if (is.null(version)) 
[13:17:29.391]                             version <- utils::packageVersion("future")
[13:17:29.391]                         }
[13:17:29.391]                         else {
[13:17:29.391]                           version <- NULL
[13:17:29.391]                         }
[13:17:29.391]                         if (!has_future || version < "1.8.0") {
[13:17:29.391]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.391]                             "", base::R.version$version.string), 
[13:17:29.391]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.391]                               "release", "version")], collapse = " "), 
[13:17:29.391]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.391]                             info)
[13:17:29.391]                           info <- base::paste(info, collapse = "; ")
[13:17:29.391]                           if (!has_future) {
[13:17:29.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.391]                               info)
[13:17:29.391]                           }
[13:17:29.391]                           else {
[13:17:29.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.391]                               info, version)
[13:17:29.391]                           }
[13:17:29.391]                           base::stop(msg)
[13:17:29.391]                         }
[13:17:29.391]                       })
[13:17:29.391]                     }
[13:17:29.391]                     base::local({
[13:17:29.391]                       for (pkg in "stats") {
[13:17:29.391]                         base::loadNamespace(pkg)
[13:17:29.391]                         base::library(pkg, character.only = TRUE)
[13:17:29.391]                       }
[13:17:29.391]                     })
[13:17:29.391]                   }
[13:17:29.391]                   options(future.plan = NULL)
[13:17:29.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.391]                 }
[13:17:29.391]                 ...future.workdir <- getwd()
[13:17:29.391]             }
[13:17:29.391]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.391]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.391]         }
[13:17:29.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.391]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.391]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.391]             base::names(...future.oldOptions))
[13:17:29.391]     }
[13:17:29.391]     if (FALSE) {
[13:17:29.391]     }
[13:17:29.391]     else {
[13:17:29.391]         if (TRUE) {
[13:17:29.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.391]                 open = "w")
[13:17:29.391]         }
[13:17:29.391]         else {
[13:17:29.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.391]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.391]         }
[13:17:29.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.391]             base::sink(type = "output", split = FALSE)
[13:17:29.391]             base::close(...future.stdout)
[13:17:29.391]         }, add = TRUE)
[13:17:29.391]     }
[13:17:29.391]     ...future.frame <- base::sys.nframe()
[13:17:29.391]     ...future.conditions <- base::list()
[13:17:29.391]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.391]     if (FALSE) {
[13:17:29.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.391]     }
[13:17:29.391]     ...future.result <- base::tryCatch({
[13:17:29.391]         base::withCallingHandlers({
[13:17:29.391]             ...future.value <- base::withVisible(base::local({
[13:17:29.391]                 do.call(function(...) {
[13:17:29.391]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.391]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.391]                     ...future.globals.maxSize)) {
[13:17:29.391]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.391]                     on.exit(options(oopts), add = TRUE)
[13:17:29.391]                   }
[13:17:29.391]                   {
[13:17:29.391]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.391]                       FUN = function(jj) {
[13:17:29.391]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.391]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.391]                       })
[13:17:29.391]                   }
[13:17:29.391]                 }, args = future.call.arguments)
[13:17:29.391]             }))
[13:17:29.391]             future::FutureResult(value = ...future.value$value, 
[13:17:29.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.391]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.391]                     ...future.globalenv.names))
[13:17:29.391]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.391]         }, condition = base::local({
[13:17:29.391]             c <- base::c
[13:17:29.391]             inherits <- base::inherits
[13:17:29.391]             invokeRestart <- base::invokeRestart
[13:17:29.391]             length <- base::length
[13:17:29.391]             list <- base::list
[13:17:29.391]             seq.int <- base::seq.int
[13:17:29.391]             signalCondition <- base::signalCondition
[13:17:29.391]             sys.calls <- base::sys.calls
[13:17:29.391]             `[[` <- base::`[[`
[13:17:29.391]             `+` <- base::`+`
[13:17:29.391]             `<<-` <- base::`<<-`
[13:17:29.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.391]                   3L)]
[13:17:29.391]             }
[13:17:29.391]             function(cond) {
[13:17:29.391]                 is_error <- inherits(cond, "error")
[13:17:29.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.391]                   NULL)
[13:17:29.391]                 if (is_error) {
[13:17:29.391]                   sessionInformation <- function() {
[13:17:29.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.391]                       search = base::search(), system = base::Sys.info())
[13:17:29.391]                   }
[13:17:29.391]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.391]                     cond$call), session = sessionInformation(), 
[13:17:29.391]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.391]                   signalCondition(cond)
[13:17:29.391]                 }
[13:17:29.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.391]                 "immediateCondition"))) {
[13:17:29.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.391]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.391]                   if (TRUE && !signal) {
[13:17:29.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.391]                     {
[13:17:29.391]                       inherits <- base::inherits
[13:17:29.391]                       invokeRestart <- base::invokeRestart
[13:17:29.391]                       is.null <- base::is.null
[13:17:29.391]                       muffled <- FALSE
[13:17:29.391]                       if (inherits(cond, "message")) {
[13:17:29.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.391]                         if (muffled) 
[13:17:29.391]                           invokeRestart("muffleMessage")
[13:17:29.391]                       }
[13:17:29.391]                       else if (inherits(cond, "warning")) {
[13:17:29.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.391]                         if (muffled) 
[13:17:29.391]                           invokeRestart("muffleWarning")
[13:17:29.391]                       }
[13:17:29.391]                       else if (inherits(cond, "condition")) {
[13:17:29.391]                         if (!is.null(pattern)) {
[13:17:29.391]                           computeRestarts <- base::computeRestarts
[13:17:29.391]                           grepl <- base::grepl
[13:17:29.391]                           restarts <- computeRestarts(cond)
[13:17:29.391]                           for (restart in restarts) {
[13:17:29.391]                             name <- restart$name
[13:17:29.391]                             if (is.null(name)) 
[13:17:29.391]                               next
[13:17:29.391]                             if (!grepl(pattern, name)) 
[13:17:29.391]                               next
[13:17:29.391]                             invokeRestart(restart)
[13:17:29.391]                             muffled <- TRUE
[13:17:29.391]                             break
[13:17:29.391]                           }
[13:17:29.391]                         }
[13:17:29.391]                       }
[13:17:29.391]                       invisible(muffled)
[13:17:29.391]                     }
[13:17:29.391]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.391]                   }
[13:17:29.391]                 }
[13:17:29.391]                 else {
[13:17:29.391]                   if (TRUE) {
[13:17:29.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.391]                     {
[13:17:29.391]                       inherits <- base::inherits
[13:17:29.391]                       invokeRestart <- base::invokeRestart
[13:17:29.391]                       is.null <- base::is.null
[13:17:29.391]                       muffled <- FALSE
[13:17:29.391]                       if (inherits(cond, "message")) {
[13:17:29.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.391]                         if (muffled) 
[13:17:29.391]                           invokeRestart("muffleMessage")
[13:17:29.391]                       }
[13:17:29.391]                       else if (inherits(cond, "warning")) {
[13:17:29.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.391]                         if (muffled) 
[13:17:29.391]                           invokeRestart("muffleWarning")
[13:17:29.391]                       }
[13:17:29.391]                       else if (inherits(cond, "condition")) {
[13:17:29.391]                         if (!is.null(pattern)) {
[13:17:29.391]                           computeRestarts <- base::computeRestarts
[13:17:29.391]                           grepl <- base::grepl
[13:17:29.391]                           restarts <- computeRestarts(cond)
[13:17:29.391]                           for (restart in restarts) {
[13:17:29.391]                             name <- restart$name
[13:17:29.391]                             if (is.null(name)) 
[13:17:29.391]                               next
[13:17:29.391]                             if (!grepl(pattern, name)) 
[13:17:29.391]                               next
[13:17:29.391]                             invokeRestart(restart)
[13:17:29.391]                             muffled <- TRUE
[13:17:29.391]                             break
[13:17:29.391]                           }
[13:17:29.391]                         }
[13:17:29.391]                       }
[13:17:29.391]                       invisible(muffled)
[13:17:29.391]                     }
[13:17:29.391]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.391]                   }
[13:17:29.391]                 }
[13:17:29.391]             }
[13:17:29.391]         }))
[13:17:29.391]     }, error = function(ex) {
[13:17:29.391]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.391]                 ...future.rng), started = ...future.startTime, 
[13:17:29.391]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.391]             version = "1.8"), class = "FutureResult")
[13:17:29.391]     }, finally = {
[13:17:29.391]         if (!identical(...future.workdir, getwd())) 
[13:17:29.391]             setwd(...future.workdir)
[13:17:29.391]         {
[13:17:29.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.391]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.391]             }
[13:17:29.391]             base::options(...future.oldOptions)
[13:17:29.391]             if (.Platform$OS.type == "windows") {
[13:17:29.391]                 old_names <- names(...future.oldEnvVars)
[13:17:29.391]                 envs <- base::Sys.getenv()
[13:17:29.391]                 names <- names(envs)
[13:17:29.391]                 common <- intersect(names, old_names)
[13:17:29.391]                 added <- setdiff(names, old_names)
[13:17:29.391]                 removed <- setdiff(old_names, names)
[13:17:29.391]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.391]                   envs[common]]
[13:17:29.391]                 NAMES <- toupper(changed)
[13:17:29.391]                 args <- list()
[13:17:29.391]                 for (kk in seq_along(NAMES)) {
[13:17:29.391]                   name <- changed[[kk]]
[13:17:29.391]                   NAME <- NAMES[[kk]]
[13:17:29.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.391]                     next
[13:17:29.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.391]                 }
[13:17:29.391]                 NAMES <- toupper(added)
[13:17:29.391]                 for (kk in seq_along(NAMES)) {
[13:17:29.391]                   name <- added[[kk]]
[13:17:29.391]                   NAME <- NAMES[[kk]]
[13:17:29.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.391]                     next
[13:17:29.391]                   args[[name]] <- ""
[13:17:29.391]                 }
[13:17:29.391]                 NAMES <- toupper(removed)
[13:17:29.391]                 for (kk in seq_along(NAMES)) {
[13:17:29.391]                   name <- removed[[kk]]
[13:17:29.391]                   NAME <- NAMES[[kk]]
[13:17:29.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.391]                     next
[13:17:29.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.391]                 }
[13:17:29.391]                 if (length(args) > 0) 
[13:17:29.391]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.391]             }
[13:17:29.391]             else {
[13:17:29.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.391]             }
[13:17:29.391]             {
[13:17:29.391]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.391]                   0L) {
[13:17:29.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.391]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.391]                   base::options(opts)
[13:17:29.391]                 }
[13:17:29.391]                 {
[13:17:29.391]                   {
[13:17:29.391]                     NULL
[13:17:29.391]                     RNGkind("Mersenne-Twister")
[13:17:29.391]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.391]                       inherits = FALSE)
[13:17:29.391]                   }
[13:17:29.391]                   options(future.plan = NULL)
[13:17:29.391]                   if (is.na(NA_character_)) 
[13:17:29.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.391]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.391]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.391]                     envir = parent.frame()) 
[13:17:29.391]                   {
[13:17:29.391]                     if (is.function(workers)) 
[13:17:29.391]                       workers <- workers()
[13:17:29.391]                     workers <- structure(as.integer(workers), 
[13:17:29.391]                       class = class(workers))
[13:17:29.391]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.391]                       workers >= 1)
[13:17:29.391]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.391]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.391]                     }
[13:17:29.391]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.391]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.391]                       envir = envir)
[13:17:29.391]                     if (!future$lazy) 
[13:17:29.391]                       future <- run(future)
[13:17:29.391]                     invisible(future)
[13:17:29.391]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.391]                 }
[13:17:29.391]             }
[13:17:29.391]         }
[13:17:29.391]     })
[13:17:29.391]     if (TRUE) {
[13:17:29.391]         base::sink(type = "output", split = FALSE)
[13:17:29.391]         if (TRUE) {
[13:17:29.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.391]         }
[13:17:29.391]         else {
[13:17:29.391]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.391]         }
[13:17:29.391]         base::close(...future.stdout)
[13:17:29.391]         ...future.stdout <- NULL
[13:17:29.391]     }
[13:17:29.391]     ...future.result$conditions <- ...future.conditions
[13:17:29.391]     ...future.result$finished <- base::Sys.time()
[13:17:29.391]     ...future.result
[13:17:29.391] }
[13:17:29.393] assign_globals() ...
[13:17:29.393] List of 7
[13:17:29.393]  $ ...future.FUN            :function (x)  
[13:17:29.393]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:29.393]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.393]  $ future.call.arguments    : list()
[13:17:29.393]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.393]  $ ...future.elements_ii    :List of 3
[13:17:29.393]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.393]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.393]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.393]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.393]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.393]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.393]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.393]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.393]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.393]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.393]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.393]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.393]  $ ...future.seeds_ii       : NULL
[13:17:29.393]  $ ...future.globals.maxSize: NULL
[13:17:29.393]  - attr(*, "resolved")= logi FALSE
[13:17:29.393]  - attr(*, "total_size")= num 2320
[13:17:29.393]  - attr(*, "where")=List of 7
[13:17:29.393]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.393]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:17:29.393]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:17:29.393]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.393]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.393]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.393]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.393]  - attr(*, "already-done")= logi TRUE
[13:17:29.405] - reassign environment for ‘...future.FUN’
[13:17:29.405] - copied ‘...future.FUN’ to environment
[13:17:29.405] - copied ‘breaks’ to environment
[13:17:29.405] - copied ‘wool’ to environment
[13:17:29.405] - copied ‘future.call.arguments’ to environment
[13:17:29.405] - copied ‘...future.elements_ii’ to environment
[13:17:29.405] - copied ‘...future.seeds_ii’ to environment
[13:17:29.405] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.405] assign_globals() ... done
[13:17:29.406] plan(): Setting new future strategy stack:
[13:17:29.406] List of future strategies:
[13:17:29.406] 1. sequential:
[13:17:29.406]    - args: function (..., envir = parent.frame())
[13:17:29.406]    - tweaked: FALSE
[13:17:29.406]    - call: NULL
[13:17:29.406] plan(): nbrOfWorkers() = 1
[13:17:29.409] plan(): Setting new future strategy stack:
[13:17:29.409] List of future strategies:
[13:17:29.409] 1. multisession:
[13:17:29.409]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.409]    - tweaked: FALSE
[13:17:29.409]    - call: plan(strategy)
[13:17:29.413] plan(): nbrOfWorkers() = 1
[13:17:29.413] SequentialFuture started (and completed)
[13:17:29.413] - Launch lazy future ... done
[13:17:29.413] run() for ‘SequentialFuture’ ... done
[13:17:29.413] Created future:
[13:17:29.413] SequentialFuture:
[13:17:29.413] Label: ‘future_by-1’
[13:17:29.413] Expression:
[13:17:29.413] {
[13:17:29.413]     do.call(function(...) {
[13:17:29.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.413]             on.exit(options(oopts), add = TRUE)
[13:17:29.413]         }
[13:17:29.413]         {
[13:17:29.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.413]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.413]             })
[13:17:29.413]         }
[13:17:29.413]     }, args = future.call.arguments)
[13:17:29.413] }
[13:17:29.413] Lazy evaluation: FALSE
[13:17:29.413] Asynchronous evaluation: FALSE
[13:17:29.413] Local evaluation: TRUE
[13:17:29.413] Environment: 0x5609e90cb730
[13:17:29.413] Capture standard output: TRUE
[13:17:29.413] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.413] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:17:29.413] Packages: 1 packages (‘stats’)
[13:17:29.413] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.413] Resolved: TRUE
[13:17:29.413] Value: 25.57 KiB of class ‘list’
[13:17:29.413] Early signaling: FALSE
[13:17:29.413] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.413] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.415] Chunk #1 of 1 ... DONE
[13:17:29.415] Launching 1 futures (chunks) ... DONE
[13:17:29.415] Resolving 1 futures (chunks) ...
[13:17:29.415] resolve() on list ...
[13:17:29.415]  recursive: 0
[13:17:29.415]  length: 1
[13:17:29.416] 
[13:17:29.416] resolved() for ‘SequentialFuture’ ...
[13:17:29.416] - state: ‘finished’
[13:17:29.416] - run: TRUE
[13:17:29.416] - result: ‘FutureResult’
[13:17:29.416] resolved() for ‘SequentialFuture’ ... done
[13:17:29.416] Future #1
[13:17:29.416] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.416] - nx: 1
[13:17:29.416] - relay: TRUE
[13:17:29.416] - stdout: TRUE
[13:17:29.417] - signal: TRUE
[13:17:29.417] - resignal: FALSE
[13:17:29.417] - force: TRUE
[13:17:29.417] - relayed: [n=1] FALSE
[13:17:29.417] - queued futures: [n=1] FALSE
[13:17:29.417]  - until=1
[13:17:29.417]  - relaying element #1
[13:17:29.417] - relayed: [n=1] TRUE
[13:17:29.417] - queued futures: [n=1] TRUE
[13:17:29.417] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.418]  length: 0 (resolved future 1)
[13:17:29.418] Relaying remaining futures
[13:17:29.418] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.418] - nx: 1
[13:17:29.418] - relay: TRUE
[13:17:29.418] - stdout: TRUE
[13:17:29.418] - signal: TRUE
[13:17:29.418] - resignal: FALSE
[13:17:29.418] - force: TRUE
[13:17:29.418] - relayed: [n=1] TRUE
[13:17:29.418] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.419] - relayed: [n=1] TRUE
[13:17:29.419] - queued futures: [n=1] TRUE
[13:17:29.419] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.419] resolve() on list ... DONE
[13:17:29.419]  - Number of value chunks collected: 1
[13:17:29.419] Resolving 1 futures (chunks) ... DONE
[13:17:29.419] Reducing values from 1 chunks ...
[13:17:29.419]  - Number of values collected after concatenation: 3
[13:17:29.419]  - Number of values expected: 3
[13:17:29.419] Reducing values from 1 chunks ... DONE
[13:17:29.419] future_lapply() ... DONE
[13:17:29.420] future_by_internal() ... DONE
[13:17:29.420] future_by_internal() ...
[13:17:29.420] future_lapply() ...
[13:17:29.424] Number of chunks: 1
[13:17:29.424] getGlobalsAndPackagesXApply() ...
[13:17:29.424]  - future.globals: TRUE
[13:17:29.424] getGlobalsAndPackages() ...
[13:17:29.424] Searching for globals...
[13:17:29.425] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.425] Searching for globals ... DONE
[13:17:29.425] Resolving globals: FALSE
[13:17:29.427] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.428] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.428] - globals: [1] ‘FUN’
[13:17:29.428] 
[13:17:29.428] getGlobalsAndPackages() ... DONE
[13:17:29.428]  - globals found/used: [n=1] ‘FUN’
[13:17:29.428]  - needed namespaces: [n=0] 
[13:17:29.428] Finding globals ... DONE
[13:17:29.428]  - use_args: TRUE
[13:17:29.428]  - Getting '...' globals ...
[13:17:29.429] resolve() on list ...
[13:17:29.429]  recursive: 0
[13:17:29.429]  length: 1
[13:17:29.429]  elements: ‘...’
[13:17:29.429]  length: 0 (resolved future 1)
[13:17:29.429] resolve() on list ... DONE
[13:17:29.429]    - '...' content: [n=0] 
[13:17:29.429] List of 1
[13:17:29.429]  $ ...: list()
[13:17:29.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.429]  - attr(*, "where")=List of 1
[13:17:29.429]   ..$ ...:<environment: 0x5609ea95da50> 
[13:17:29.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.429]  - attr(*, "resolved")= logi TRUE
[13:17:29.429]  - attr(*, "total_size")= num NA
[13:17:29.432]  - Getting '...' globals ... DONE
[13:17:29.432] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.432] List of 2
[13:17:29.432]  $ ...future.FUN:function (object, ...)  
[13:17:29.432]  $ ...          : list()
[13:17:29.432]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.432]  - attr(*, "where")=List of 2
[13:17:29.432]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.432]   ..$ ...          :<environment: 0x5609ea95da50> 
[13:17:29.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.432]  - attr(*, "resolved")= logi FALSE
[13:17:29.432]  - attr(*, "total_size")= num 1240
[13:17:29.435] Packages to be attached in all futures: [n=0] 
[13:17:29.435] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.435] Number of futures (= number of chunks): 1
[13:17:29.435] Launching 1 futures (chunks) ...
[13:17:29.435] Chunk #1 of 1 ...
[13:17:29.436]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.436] getGlobalsAndPackages() ...
[13:17:29.436] Searching for globals...
[13:17:29.436] 
[13:17:29.436] Searching for globals ... DONE
[13:17:29.436] - globals: [0] <none>
[13:17:29.436] getGlobalsAndPackages() ... DONE
[13:17:29.437]    + additional globals found: [n=0] 
[13:17:29.437]    + additional namespaces needed: [n=0] 
[13:17:29.437]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.437]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.437]  - seeds: <none>
[13:17:29.437] getGlobalsAndPackages() ...
[13:17:29.437] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.437] Resolving globals: FALSE
[13:17:29.437] Tweak future expression to call with '...' arguments ...
[13:17:29.437] {
[13:17:29.437]     do.call(function(...) {
[13:17:29.437]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.437]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.437]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.437]             on.exit(options(oopts), add = TRUE)
[13:17:29.437]         }
[13:17:29.437]         {
[13:17:29.437]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.437]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.437]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.437]             })
[13:17:29.437]         }
[13:17:29.437]     }, args = future.call.arguments)
[13:17:29.437] }
[13:17:29.438] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.438] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.438] 
[13:17:29.438] getGlobalsAndPackages() ... DONE
[13:17:29.439] run() for ‘Future’ ...
[13:17:29.439] - state: ‘created’
[13:17:29.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.442] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.442]   - Field: ‘label’
[13:17:29.443]   - Field: ‘local’
[13:17:29.443]   - Field: ‘owner’
[13:17:29.443]   - Field: ‘envir’
[13:17:29.443]   - Field: ‘packages’
[13:17:29.443]   - Field: ‘gc’
[13:17:29.443]   - Field: ‘conditions’
[13:17:29.443]   - Field: ‘expr’
[13:17:29.443]   - Field: ‘uuid’
[13:17:29.443]   - Field: ‘seed’
[13:17:29.443]   - Field: ‘version’
[13:17:29.443]   - Field: ‘result’
[13:17:29.444]   - Field: ‘asynchronous’
[13:17:29.444]   - Field: ‘calls’
[13:17:29.444]   - Field: ‘globals’
[13:17:29.444]   - Field: ‘stdout’
[13:17:29.444]   - Field: ‘earlySignal’
[13:17:29.444]   - Field: ‘lazy’
[13:17:29.444]   - Field: ‘state’
[13:17:29.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.444] - Launch lazy future ...
[13:17:29.444] Packages needed by the future expression (n = 0): <none>
[13:17:29.445] Packages needed by future strategies (n = 0): <none>
[13:17:29.445] {
[13:17:29.445]     {
[13:17:29.445]         {
[13:17:29.445]             ...future.startTime <- base::Sys.time()
[13:17:29.445]             {
[13:17:29.445]                 {
[13:17:29.445]                   {
[13:17:29.445]                     base::local({
[13:17:29.445]                       has_future <- base::requireNamespace("future", 
[13:17:29.445]                         quietly = TRUE)
[13:17:29.445]                       if (has_future) {
[13:17:29.445]                         ns <- base::getNamespace("future")
[13:17:29.445]                         version <- ns[[".package"]][["version"]]
[13:17:29.445]                         if (is.null(version)) 
[13:17:29.445]                           version <- utils::packageVersion("future")
[13:17:29.445]                       }
[13:17:29.445]                       else {
[13:17:29.445]                         version <- NULL
[13:17:29.445]                       }
[13:17:29.445]                       if (!has_future || version < "1.8.0") {
[13:17:29.445]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.445]                           "", base::R.version$version.string), 
[13:17:29.445]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.445]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.445]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.445]                             "release", "version")], collapse = " "), 
[13:17:29.445]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.445]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.445]                           info)
[13:17:29.445]                         info <- base::paste(info, collapse = "; ")
[13:17:29.445]                         if (!has_future) {
[13:17:29.445]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.445]                             info)
[13:17:29.445]                         }
[13:17:29.445]                         else {
[13:17:29.445]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.445]                             info, version)
[13:17:29.445]                         }
[13:17:29.445]                         base::stop(msg)
[13:17:29.445]                       }
[13:17:29.445]                     })
[13:17:29.445]                   }
[13:17:29.445]                   options(future.plan = NULL)
[13:17:29.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.445]                 }
[13:17:29.445]                 ...future.workdir <- getwd()
[13:17:29.445]             }
[13:17:29.445]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.445]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.445]         }
[13:17:29.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.445]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.445]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.445]             base::names(...future.oldOptions))
[13:17:29.445]     }
[13:17:29.445]     if (FALSE) {
[13:17:29.445]     }
[13:17:29.445]     else {
[13:17:29.445]         if (TRUE) {
[13:17:29.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.445]                 open = "w")
[13:17:29.445]         }
[13:17:29.445]         else {
[13:17:29.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.445]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.445]         }
[13:17:29.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.445]             base::sink(type = "output", split = FALSE)
[13:17:29.445]             base::close(...future.stdout)
[13:17:29.445]         }, add = TRUE)
[13:17:29.445]     }
[13:17:29.445]     ...future.frame <- base::sys.nframe()
[13:17:29.445]     ...future.conditions <- base::list()
[13:17:29.445]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.445]     if (FALSE) {
[13:17:29.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.445]     }
[13:17:29.445]     ...future.result <- base::tryCatch({
[13:17:29.445]         base::withCallingHandlers({
[13:17:29.445]             ...future.value <- base::withVisible(base::local({
[13:17:29.445]                 do.call(function(...) {
[13:17:29.445]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.445]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.445]                     ...future.globals.maxSize)) {
[13:17:29.445]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.445]                     on.exit(options(oopts), add = TRUE)
[13:17:29.445]                   }
[13:17:29.445]                   {
[13:17:29.445]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.445]                       FUN = function(jj) {
[13:17:29.445]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.445]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.445]                       })
[13:17:29.445]                   }
[13:17:29.445]                 }, args = future.call.arguments)
[13:17:29.445]             }))
[13:17:29.445]             future::FutureResult(value = ...future.value$value, 
[13:17:29.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.445]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.445]                     ...future.globalenv.names))
[13:17:29.445]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.445]         }, condition = base::local({
[13:17:29.445]             c <- base::c
[13:17:29.445]             inherits <- base::inherits
[13:17:29.445]             invokeRestart <- base::invokeRestart
[13:17:29.445]             length <- base::length
[13:17:29.445]             list <- base::list
[13:17:29.445]             seq.int <- base::seq.int
[13:17:29.445]             signalCondition <- base::signalCondition
[13:17:29.445]             sys.calls <- base::sys.calls
[13:17:29.445]             `[[` <- base::`[[`
[13:17:29.445]             `+` <- base::`+`
[13:17:29.445]             `<<-` <- base::`<<-`
[13:17:29.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.445]                   3L)]
[13:17:29.445]             }
[13:17:29.445]             function(cond) {
[13:17:29.445]                 is_error <- inherits(cond, "error")
[13:17:29.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.445]                   NULL)
[13:17:29.445]                 if (is_error) {
[13:17:29.445]                   sessionInformation <- function() {
[13:17:29.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.445]                       search = base::search(), system = base::Sys.info())
[13:17:29.445]                   }
[13:17:29.445]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.445]                     cond$call), session = sessionInformation(), 
[13:17:29.445]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.445]                   signalCondition(cond)
[13:17:29.445]                 }
[13:17:29.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.445]                 "immediateCondition"))) {
[13:17:29.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.445]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.445]                   if (TRUE && !signal) {
[13:17:29.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.445]                     {
[13:17:29.445]                       inherits <- base::inherits
[13:17:29.445]                       invokeRestart <- base::invokeRestart
[13:17:29.445]                       is.null <- base::is.null
[13:17:29.445]                       muffled <- FALSE
[13:17:29.445]                       if (inherits(cond, "message")) {
[13:17:29.445]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.445]                         if (muffled) 
[13:17:29.445]                           invokeRestart("muffleMessage")
[13:17:29.445]                       }
[13:17:29.445]                       else if (inherits(cond, "warning")) {
[13:17:29.445]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.445]                         if (muffled) 
[13:17:29.445]                           invokeRestart("muffleWarning")
[13:17:29.445]                       }
[13:17:29.445]                       else if (inherits(cond, "condition")) {
[13:17:29.445]                         if (!is.null(pattern)) {
[13:17:29.445]                           computeRestarts <- base::computeRestarts
[13:17:29.445]                           grepl <- base::grepl
[13:17:29.445]                           restarts <- computeRestarts(cond)
[13:17:29.445]                           for (restart in restarts) {
[13:17:29.445]                             name <- restart$name
[13:17:29.445]                             if (is.null(name)) 
[13:17:29.445]                               next
[13:17:29.445]                             if (!grepl(pattern, name)) 
[13:17:29.445]                               next
[13:17:29.445]                             invokeRestart(restart)
[13:17:29.445]                             muffled <- TRUE
[13:17:29.445]                             break
[13:17:29.445]                           }
[13:17:29.445]                         }
[13:17:29.445]                       }
[13:17:29.445]                       invisible(muffled)
[13:17:29.445]                     }
[13:17:29.445]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.445]                   }
[13:17:29.445]                 }
[13:17:29.445]                 else {
[13:17:29.445]                   if (TRUE) {
[13:17:29.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.445]                     {
[13:17:29.445]                       inherits <- base::inherits
[13:17:29.445]                       invokeRestart <- base::invokeRestart
[13:17:29.445]                       is.null <- base::is.null
[13:17:29.445]                       muffled <- FALSE
[13:17:29.445]                       if (inherits(cond, "message")) {
[13:17:29.445]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.445]                         if (muffled) 
[13:17:29.445]                           invokeRestart("muffleMessage")
[13:17:29.445]                       }
[13:17:29.445]                       else if (inherits(cond, "warning")) {
[13:17:29.445]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.445]                         if (muffled) 
[13:17:29.445]                           invokeRestart("muffleWarning")
[13:17:29.445]                       }
[13:17:29.445]                       else if (inherits(cond, "condition")) {
[13:17:29.445]                         if (!is.null(pattern)) {
[13:17:29.445]                           computeRestarts <- base::computeRestarts
[13:17:29.445]                           grepl <- base::grepl
[13:17:29.445]                           restarts <- computeRestarts(cond)
[13:17:29.445]                           for (restart in restarts) {
[13:17:29.445]                             name <- restart$name
[13:17:29.445]                             if (is.null(name)) 
[13:17:29.445]                               next
[13:17:29.445]                             if (!grepl(pattern, name)) 
[13:17:29.445]                               next
[13:17:29.445]                             invokeRestart(restart)
[13:17:29.445]                             muffled <- TRUE
[13:17:29.445]                             break
[13:17:29.445]                           }
[13:17:29.445]                         }
[13:17:29.445]                       }
[13:17:29.445]                       invisible(muffled)
[13:17:29.445]                     }
[13:17:29.445]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.445]                   }
[13:17:29.445]                 }
[13:17:29.445]             }
[13:17:29.445]         }))
[13:17:29.445]     }, error = function(ex) {
[13:17:29.445]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.445]                 ...future.rng), started = ...future.startTime, 
[13:17:29.445]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.445]             version = "1.8"), class = "FutureResult")
[13:17:29.445]     }, finally = {
[13:17:29.445]         if (!identical(...future.workdir, getwd())) 
[13:17:29.445]             setwd(...future.workdir)
[13:17:29.445]         {
[13:17:29.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.445]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.445]             }
[13:17:29.445]             base::options(...future.oldOptions)
[13:17:29.445]             if (.Platform$OS.type == "windows") {
[13:17:29.445]                 old_names <- names(...future.oldEnvVars)
[13:17:29.445]                 envs <- base::Sys.getenv()
[13:17:29.445]                 names <- names(envs)
[13:17:29.445]                 common <- intersect(names, old_names)
[13:17:29.445]                 added <- setdiff(names, old_names)
[13:17:29.445]                 removed <- setdiff(old_names, names)
[13:17:29.445]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.445]                   envs[common]]
[13:17:29.445]                 NAMES <- toupper(changed)
[13:17:29.445]                 args <- list()
[13:17:29.445]                 for (kk in seq_along(NAMES)) {
[13:17:29.445]                   name <- changed[[kk]]
[13:17:29.445]                   NAME <- NAMES[[kk]]
[13:17:29.445]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.445]                     next
[13:17:29.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.445]                 }
[13:17:29.445]                 NAMES <- toupper(added)
[13:17:29.445]                 for (kk in seq_along(NAMES)) {
[13:17:29.445]                   name <- added[[kk]]
[13:17:29.445]                   NAME <- NAMES[[kk]]
[13:17:29.445]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.445]                     next
[13:17:29.445]                   args[[name]] <- ""
[13:17:29.445]                 }
[13:17:29.445]                 NAMES <- toupper(removed)
[13:17:29.445]                 for (kk in seq_along(NAMES)) {
[13:17:29.445]                   name <- removed[[kk]]
[13:17:29.445]                   NAME <- NAMES[[kk]]
[13:17:29.445]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.445]                     next
[13:17:29.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.445]                 }
[13:17:29.445]                 if (length(args) > 0) 
[13:17:29.445]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.445]             }
[13:17:29.445]             else {
[13:17:29.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.445]             }
[13:17:29.445]             {
[13:17:29.445]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.445]                   0L) {
[13:17:29.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.445]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.445]                   base::options(opts)
[13:17:29.445]                 }
[13:17:29.445]                 {
[13:17:29.445]                   {
[13:17:29.445]                     NULL
[13:17:29.445]                     RNGkind("Mersenne-Twister")
[13:17:29.445]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.445]                       inherits = FALSE)
[13:17:29.445]                   }
[13:17:29.445]                   options(future.plan = NULL)
[13:17:29.445]                   if (is.na(NA_character_)) 
[13:17:29.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.445]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.445]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.445]                     envir = parent.frame()) 
[13:17:29.445]                   {
[13:17:29.445]                     if (is.function(workers)) 
[13:17:29.445]                       workers <- workers()
[13:17:29.445]                     workers <- structure(as.integer(workers), 
[13:17:29.445]                       class = class(workers))
[13:17:29.445]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.445]                       workers >= 1)
[13:17:29.445]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.445]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.445]                     }
[13:17:29.445]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.445]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.445]                       envir = envir)
[13:17:29.445]                     if (!future$lazy) 
[13:17:29.445]                       future <- run(future)
[13:17:29.445]                     invisible(future)
[13:17:29.445]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.445]                 }
[13:17:29.445]             }
[13:17:29.445]         }
[13:17:29.445]     })
[13:17:29.445]     if (TRUE) {
[13:17:29.445]         base::sink(type = "output", split = FALSE)
[13:17:29.445]         if (TRUE) {
[13:17:29.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.445]         }
[13:17:29.445]         else {
[13:17:29.445]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.445]         }
[13:17:29.445]         base::close(...future.stdout)
[13:17:29.445]         ...future.stdout <- NULL
[13:17:29.445]     }
[13:17:29.445]     ...future.result$conditions <- ...future.conditions
[13:17:29.445]     ...future.result$finished <- base::Sys.time()
[13:17:29.445]     ...future.result
[13:17:29.445] }
[13:17:29.447] assign_globals() ...
[13:17:29.447] List of 5
[13:17:29.447]  $ ...future.FUN            :function (object, ...)  
[13:17:29.447]  $ future.call.arguments    : list()
[13:17:29.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.447]  $ ...future.elements_ii    :List of 3
[13:17:29.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.447]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.447]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.447]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.447]  $ ...future.seeds_ii       : NULL
[13:17:29.447]  $ ...future.globals.maxSize: NULL
[13:17:29.447]  - attr(*, "resolved")= logi FALSE
[13:17:29.447]  - attr(*, "total_size")= num 1240
[13:17:29.447]  - attr(*, "where")=List of 5
[13:17:29.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.447]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.447]  - attr(*, "already-done")= logi TRUE
[13:17:29.457] - copied ‘...future.FUN’ to environment
[13:17:29.457] - copied ‘future.call.arguments’ to environment
[13:17:29.457] - copied ‘...future.elements_ii’ to environment
[13:17:29.457] - copied ‘...future.seeds_ii’ to environment
[13:17:29.457] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.458] assign_globals() ... done
[13:17:29.458] plan(): Setting new future strategy stack:
[13:17:29.458] List of future strategies:
[13:17:29.458] 1. sequential:
[13:17:29.458]    - args: function (..., envir = parent.frame())
[13:17:29.458]    - tweaked: FALSE
[13:17:29.458]    - call: NULL
[13:17:29.458] plan(): nbrOfWorkers() = 1
[13:17:29.460] plan(): Setting new future strategy stack:
[13:17:29.460] List of future strategies:
[13:17:29.460] 1. multisession:
[13:17:29.460]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.460]    - tweaked: FALSE
[13:17:29.460]    - call: plan(strategy)
[13:17:29.464] plan(): nbrOfWorkers() = 1
[13:17:29.464] SequentialFuture started (and completed)
[13:17:29.464] - Launch lazy future ... done
[13:17:29.464] run() for ‘SequentialFuture’ ... done
[13:17:29.465] Created future:
[13:17:29.465] SequentialFuture:
[13:17:29.465] Label: ‘future_by-1’
[13:17:29.465] Expression:
[13:17:29.465] {
[13:17:29.465]     do.call(function(...) {
[13:17:29.465]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.465]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.465]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.465]             on.exit(options(oopts), add = TRUE)
[13:17:29.465]         }
[13:17:29.465]         {
[13:17:29.465]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.465]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.465]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.465]             })
[13:17:29.465]         }
[13:17:29.465]     }, args = future.call.arguments)
[13:17:29.465] }
[13:17:29.465] Lazy evaluation: FALSE
[13:17:29.465] Asynchronous evaluation: FALSE
[13:17:29.465] Local evaluation: TRUE
[13:17:29.465] Environment: 0x5609ea827060
[13:17:29.465] Capture standard output: TRUE
[13:17:29.465] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.465] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.465] Packages: <none>
[13:17:29.465] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.465] Resolved: TRUE
[13:17:29.465] Value: 5.37 KiB of class ‘list’
[13:17:29.465] Early signaling: FALSE
[13:17:29.465] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.465] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.466] Chunk #1 of 1 ... DONE
[13:17:29.466] Launching 1 futures (chunks) ... DONE
[13:17:29.466] Resolving 1 futures (chunks) ...
[13:17:29.466] resolve() on list ...
[13:17:29.466]  recursive: 0
[13:17:29.466]  length: 1
[13:17:29.467] 
[13:17:29.467] resolved() for ‘SequentialFuture’ ...
[13:17:29.467] - state: ‘finished’
[13:17:29.467] - run: TRUE
[13:17:29.467] - result: ‘FutureResult’
[13:17:29.467] resolved() for ‘SequentialFuture’ ... done
[13:17:29.467] Future #1
[13:17:29.467] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.467] - nx: 1
[13:17:29.467] - relay: TRUE
[13:17:29.467] - stdout: TRUE
[13:17:29.468] - signal: TRUE
[13:17:29.468] - resignal: FALSE
[13:17:29.468] - force: TRUE
[13:17:29.468] - relayed: [n=1] FALSE
[13:17:29.468] - queued futures: [n=1] FALSE
[13:17:29.468]  - until=1
[13:17:29.468]  - relaying element #1
[13:17:29.468] - relayed: [n=1] TRUE
[13:17:29.468] - queued futures: [n=1] TRUE
[13:17:29.468] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.469]  length: 0 (resolved future 1)
[13:17:29.469] Relaying remaining futures
[13:17:29.469] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.469] - nx: 1
[13:17:29.469] - relay: TRUE
[13:17:29.469] - stdout: TRUE
[13:17:29.469] - signal: TRUE
[13:17:29.469] - resignal: FALSE
[13:17:29.469] - force: TRUE
[13:17:29.472] - relayed: [n=1] TRUE
[13:17:29.472] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.473] - relayed: [n=1] TRUE
[13:17:29.473] - queued futures: [n=1] TRUE
[13:17:29.473] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.473] resolve() on list ... DONE
[13:17:29.473]  - Number of value chunks collected: 1
[13:17:29.473] Resolving 1 futures (chunks) ... DONE
[13:17:29.473] Reducing values from 1 chunks ...
[13:17:29.473]  - Number of values collected after concatenation: 3
[13:17:29.473]  - Number of values expected: 3
[13:17:29.474] Reducing values from 1 chunks ... DONE
[13:17:29.474] future_lapply() ... DONE
[13:17:29.474] future_by_internal() ... DONE
[13:17:29.475] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:17:29.475] future_lapply() ...
[13:17:29.479] Number of chunks: 1
[13:17:29.479] getGlobalsAndPackagesXApply() ...
[13:17:29.479]  - future.globals: TRUE
[13:17:29.479] getGlobalsAndPackages() ...
[13:17:29.479] Searching for globals...
[13:17:29.480] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.480] Searching for globals ... DONE
[13:17:29.481] Resolving globals: FALSE
[13:17:29.481] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.481] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.481] - globals: [1] ‘FUN’
[13:17:29.481] 
[13:17:29.482] getGlobalsAndPackages() ... DONE
[13:17:29.482]  - globals found/used: [n=1] ‘FUN’
[13:17:29.482]  - needed namespaces: [n=0] 
[13:17:29.482] Finding globals ... DONE
[13:17:29.482]  - use_args: TRUE
[13:17:29.482]  - Getting '...' globals ...
[13:17:29.482] resolve() on list ...
[13:17:29.482]  recursive: 0
[13:17:29.483]  length: 1
[13:17:29.483]  elements: ‘...’
[13:17:29.483]  length: 0 (resolved future 1)
[13:17:29.483] resolve() on list ... DONE
[13:17:29.483]    - '...' content: [n=0] 
[13:17:29.483] List of 1
[13:17:29.483]  $ ...: list()
[13:17:29.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.483]  - attr(*, "where")=List of 1
[13:17:29.483]   ..$ ...:<environment: 0x5609eae575b8> 
[13:17:29.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.483]  - attr(*, "resolved")= logi TRUE
[13:17:29.483]  - attr(*, "total_size")= num NA
[13:17:29.486]  - Getting '...' globals ... DONE
[13:17:29.486] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.486] List of 2
[13:17:29.486]  $ ...future.FUN:function (object, ...)  
[13:17:29.486]  $ ...          : list()
[13:17:29.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.486]  - attr(*, "where")=List of 2
[13:17:29.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.486]   ..$ ...          :<environment: 0x5609eae575b8> 
[13:17:29.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.486]  - attr(*, "resolved")= logi FALSE
[13:17:29.486]  - attr(*, "total_size")= num 1240
[13:17:29.488] Packages to be attached in all futures: [n=0] 
[13:17:29.489] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.489] Number of futures (= number of chunks): 1
[13:17:29.489] Launching 1 futures (chunks) ...
[13:17:29.489] Chunk #1 of 1 ...
[13:17:29.489]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.489] getGlobalsAndPackages() ...
[13:17:29.489] Searching for globals...
[13:17:29.490] 
[13:17:29.490] Searching for globals ... DONE
[13:17:29.490] - globals: [0] <none>
[13:17:29.490] getGlobalsAndPackages() ... DONE
[13:17:29.490]    + additional globals found: [n=0] 
[13:17:29.490]    + additional namespaces needed: [n=0] 
[13:17:29.490]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.490]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.490]  - seeds: <none>
[13:17:29.491] getGlobalsAndPackages() ...
[13:17:29.491] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.491] Resolving globals: FALSE
[13:17:29.491] Tweak future expression to call with '...' arguments ...
[13:17:29.491] {
[13:17:29.491]     do.call(function(...) {
[13:17:29.491]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.491]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.491]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.491]             on.exit(options(oopts), add = TRUE)
[13:17:29.491]         }
[13:17:29.491]         {
[13:17:29.491]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.491]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.491]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.491]             })
[13:17:29.491]         }
[13:17:29.491]     }, args = future.call.arguments)
[13:17:29.491] }
[13:17:29.491] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.492] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.492] 
[13:17:29.492] getGlobalsAndPackages() ... DONE
[13:17:29.492] run() for ‘Future’ ...
[13:17:29.492] - state: ‘created’
[13:17:29.492] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.496] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.496]   - Field: ‘label’
[13:17:29.496]   - Field: ‘local’
[13:17:29.496]   - Field: ‘owner’
[13:17:29.496]   - Field: ‘envir’
[13:17:29.496]   - Field: ‘packages’
[13:17:29.496]   - Field: ‘gc’
[13:17:29.497]   - Field: ‘conditions’
[13:17:29.498]   - Field: ‘expr’
[13:17:29.498]   - Field: ‘uuid’
[13:17:29.498]   - Field: ‘seed’
[13:17:29.498]   - Field: ‘version’
[13:17:29.499]   - Field: ‘result’
[13:17:29.499]   - Field: ‘asynchronous’
[13:17:29.499]   - Field: ‘calls’
[13:17:29.499]   - Field: ‘globals’
[13:17:29.499]   - Field: ‘stdout’
[13:17:29.499]   - Field: ‘earlySignal’
[13:17:29.499]   - Field: ‘lazy’
[13:17:29.499]   - Field: ‘state’
[13:17:29.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.499] - Launch lazy future ...
[13:17:29.500] Packages needed by the future expression (n = 0): <none>
[13:17:29.500] Packages needed by future strategies (n = 0): <none>
[13:17:29.500] {
[13:17:29.500]     {
[13:17:29.500]         {
[13:17:29.500]             ...future.startTime <- base::Sys.time()
[13:17:29.500]             {
[13:17:29.500]                 {
[13:17:29.500]                   {
[13:17:29.500]                     base::local({
[13:17:29.500]                       has_future <- base::requireNamespace("future", 
[13:17:29.500]                         quietly = TRUE)
[13:17:29.500]                       if (has_future) {
[13:17:29.500]                         ns <- base::getNamespace("future")
[13:17:29.500]                         version <- ns[[".package"]][["version"]]
[13:17:29.500]                         if (is.null(version)) 
[13:17:29.500]                           version <- utils::packageVersion("future")
[13:17:29.500]                       }
[13:17:29.500]                       else {
[13:17:29.500]                         version <- NULL
[13:17:29.500]                       }
[13:17:29.500]                       if (!has_future || version < "1.8.0") {
[13:17:29.500]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.500]                           "", base::R.version$version.string), 
[13:17:29.500]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.500]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.500]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.500]                             "release", "version")], collapse = " "), 
[13:17:29.500]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.500]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.500]                           info)
[13:17:29.500]                         info <- base::paste(info, collapse = "; ")
[13:17:29.500]                         if (!has_future) {
[13:17:29.500]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.500]                             info)
[13:17:29.500]                         }
[13:17:29.500]                         else {
[13:17:29.500]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.500]                             info, version)
[13:17:29.500]                         }
[13:17:29.500]                         base::stop(msg)
[13:17:29.500]                       }
[13:17:29.500]                     })
[13:17:29.500]                   }
[13:17:29.500]                   options(future.plan = NULL)
[13:17:29.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.500]                 }
[13:17:29.500]                 ...future.workdir <- getwd()
[13:17:29.500]             }
[13:17:29.500]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.500]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.500]         }
[13:17:29.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.500]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.500]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.500]             base::names(...future.oldOptions))
[13:17:29.500]     }
[13:17:29.500]     if (FALSE) {
[13:17:29.500]     }
[13:17:29.500]     else {
[13:17:29.500]         if (TRUE) {
[13:17:29.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.500]                 open = "w")
[13:17:29.500]         }
[13:17:29.500]         else {
[13:17:29.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.500]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.500]         }
[13:17:29.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.500]             base::sink(type = "output", split = FALSE)
[13:17:29.500]             base::close(...future.stdout)
[13:17:29.500]         }, add = TRUE)
[13:17:29.500]     }
[13:17:29.500]     ...future.frame <- base::sys.nframe()
[13:17:29.500]     ...future.conditions <- base::list()
[13:17:29.500]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.500]     if (FALSE) {
[13:17:29.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.500]     }
[13:17:29.500]     ...future.result <- base::tryCatch({
[13:17:29.500]         base::withCallingHandlers({
[13:17:29.500]             ...future.value <- base::withVisible(base::local({
[13:17:29.500]                 do.call(function(...) {
[13:17:29.500]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.500]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.500]                     ...future.globals.maxSize)) {
[13:17:29.500]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.500]                     on.exit(options(oopts), add = TRUE)
[13:17:29.500]                   }
[13:17:29.500]                   {
[13:17:29.500]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.500]                       FUN = function(jj) {
[13:17:29.500]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.500]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.500]                       })
[13:17:29.500]                   }
[13:17:29.500]                 }, args = future.call.arguments)
[13:17:29.500]             }))
[13:17:29.500]             future::FutureResult(value = ...future.value$value, 
[13:17:29.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.500]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.500]                     ...future.globalenv.names))
[13:17:29.500]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.500]         }, condition = base::local({
[13:17:29.500]             c <- base::c
[13:17:29.500]             inherits <- base::inherits
[13:17:29.500]             invokeRestart <- base::invokeRestart
[13:17:29.500]             length <- base::length
[13:17:29.500]             list <- base::list
[13:17:29.500]             seq.int <- base::seq.int
[13:17:29.500]             signalCondition <- base::signalCondition
[13:17:29.500]             sys.calls <- base::sys.calls
[13:17:29.500]             `[[` <- base::`[[`
[13:17:29.500]             `+` <- base::`+`
[13:17:29.500]             `<<-` <- base::`<<-`
[13:17:29.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.500]                   3L)]
[13:17:29.500]             }
[13:17:29.500]             function(cond) {
[13:17:29.500]                 is_error <- inherits(cond, "error")
[13:17:29.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.500]                   NULL)
[13:17:29.500]                 if (is_error) {
[13:17:29.500]                   sessionInformation <- function() {
[13:17:29.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.500]                       search = base::search(), system = base::Sys.info())
[13:17:29.500]                   }
[13:17:29.500]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.500]                     cond$call), session = sessionInformation(), 
[13:17:29.500]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.500]                   signalCondition(cond)
[13:17:29.500]                 }
[13:17:29.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.500]                 "immediateCondition"))) {
[13:17:29.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.500]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.500]                   if (TRUE && !signal) {
[13:17:29.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.500]                     {
[13:17:29.500]                       inherits <- base::inherits
[13:17:29.500]                       invokeRestart <- base::invokeRestart
[13:17:29.500]                       is.null <- base::is.null
[13:17:29.500]                       muffled <- FALSE
[13:17:29.500]                       if (inherits(cond, "message")) {
[13:17:29.500]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.500]                         if (muffled) 
[13:17:29.500]                           invokeRestart("muffleMessage")
[13:17:29.500]                       }
[13:17:29.500]                       else if (inherits(cond, "warning")) {
[13:17:29.500]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.500]                         if (muffled) 
[13:17:29.500]                           invokeRestart("muffleWarning")
[13:17:29.500]                       }
[13:17:29.500]                       else if (inherits(cond, "condition")) {
[13:17:29.500]                         if (!is.null(pattern)) {
[13:17:29.500]                           computeRestarts <- base::computeRestarts
[13:17:29.500]                           grepl <- base::grepl
[13:17:29.500]                           restarts <- computeRestarts(cond)
[13:17:29.500]                           for (restart in restarts) {
[13:17:29.500]                             name <- restart$name
[13:17:29.500]                             if (is.null(name)) 
[13:17:29.500]                               next
[13:17:29.500]                             if (!grepl(pattern, name)) 
[13:17:29.500]                               next
[13:17:29.500]                             invokeRestart(restart)
[13:17:29.500]                             muffled <- TRUE
[13:17:29.500]                             break
[13:17:29.500]                           }
[13:17:29.500]                         }
[13:17:29.500]                       }
[13:17:29.500]                       invisible(muffled)
[13:17:29.500]                     }
[13:17:29.500]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.500]                   }
[13:17:29.500]                 }
[13:17:29.500]                 else {
[13:17:29.500]                   if (TRUE) {
[13:17:29.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.500]                     {
[13:17:29.500]                       inherits <- base::inherits
[13:17:29.500]                       invokeRestart <- base::invokeRestart
[13:17:29.500]                       is.null <- base::is.null
[13:17:29.500]                       muffled <- FALSE
[13:17:29.500]                       if (inherits(cond, "message")) {
[13:17:29.500]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.500]                         if (muffled) 
[13:17:29.500]                           invokeRestart("muffleMessage")
[13:17:29.500]                       }
[13:17:29.500]                       else if (inherits(cond, "warning")) {
[13:17:29.500]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.500]                         if (muffled) 
[13:17:29.500]                           invokeRestart("muffleWarning")
[13:17:29.500]                       }
[13:17:29.500]                       else if (inherits(cond, "condition")) {
[13:17:29.500]                         if (!is.null(pattern)) {
[13:17:29.500]                           computeRestarts <- base::computeRestarts
[13:17:29.500]                           grepl <- base::grepl
[13:17:29.500]                           restarts <- computeRestarts(cond)
[13:17:29.500]                           for (restart in restarts) {
[13:17:29.500]                             name <- restart$name
[13:17:29.500]                             if (is.null(name)) 
[13:17:29.500]                               next
[13:17:29.500]                             if (!grepl(pattern, name)) 
[13:17:29.500]                               next
[13:17:29.500]                             invokeRestart(restart)
[13:17:29.500]                             muffled <- TRUE
[13:17:29.500]                             break
[13:17:29.500]                           }
[13:17:29.500]                         }
[13:17:29.500]                       }
[13:17:29.500]                       invisible(muffled)
[13:17:29.500]                     }
[13:17:29.500]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.500]                   }
[13:17:29.500]                 }
[13:17:29.500]             }
[13:17:29.500]         }))
[13:17:29.500]     }, error = function(ex) {
[13:17:29.500]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.500]                 ...future.rng), started = ...future.startTime, 
[13:17:29.500]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.500]             version = "1.8"), class = "FutureResult")
[13:17:29.500]     }, finally = {
[13:17:29.500]         if (!identical(...future.workdir, getwd())) 
[13:17:29.500]             setwd(...future.workdir)
[13:17:29.500]         {
[13:17:29.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.500]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.500]             }
[13:17:29.500]             base::options(...future.oldOptions)
[13:17:29.500]             if (.Platform$OS.type == "windows") {
[13:17:29.500]                 old_names <- names(...future.oldEnvVars)
[13:17:29.500]                 envs <- base::Sys.getenv()
[13:17:29.500]                 names <- names(envs)
[13:17:29.500]                 common <- intersect(names, old_names)
[13:17:29.500]                 added <- setdiff(names, old_names)
[13:17:29.500]                 removed <- setdiff(old_names, names)
[13:17:29.500]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.500]                   envs[common]]
[13:17:29.500]                 NAMES <- toupper(changed)
[13:17:29.500]                 args <- list()
[13:17:29.500]                 for (kk in seq_along(NAMES)) {
[13:17:29.500]                   name <- changed[[kk]]
[13:17:29.500]                   NAME <- NAMES[[kk]]
[13:17:29.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.500]                     next
[13:17:29.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.500]                 }
[13:17:29.500]                 NAMES <- toupper(added)
[13:17:29.500]                 for (kk in seq_along(NAMES)) {
[13:17:29.500]                   name <- added[[kk]]
[13:17:29.500]                   NAME <- NAMES[[kk]]
[13:17:29.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.500]                     next
[13:17:29.500]                   args[[name]] <- ""
[13:17:29.500]                 }
[13:17:29.500]                 NAMES <- toupper(removed)
[13:17:29.500]                 for (kk in seq_along(NAMES)) {
[13:17:29.500]                   name <- removed[[kk]]
[13:17:29.500]                   NAME <- NAMES[[kk]]
[13:17:29.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.500]                     next
[13:17:29.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.500]                 }
[13:17:29.500]                 if (length(args) > 0) 
[13:17:29.500]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.500]             }
[13:17:29.500]             else {
[13:17:29.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.500]             }
[13:17:29.500]             {
[13:17:29.500]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.500]                   0L) {
[13:17:29.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.500]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.500]                   base::options(opts)
[13:17:29.500]                 }
[13:17:29.500]                 {
[13:17:29.500]                   {
[13:17:29.500]                     NULL
[13:17:29.500]                     RNGkind("Mersenne-Twister")
[13:17:29.500]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.500]                       inherits = FALSE)
[13:17:29.500]                   }
[13:17:29.500]                   options(future.plan = NULL)
[13:17:29.500]                   if (is.na(NA_character_)) 
[13:17:29.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.500]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:29.500]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:29.500]                     envir = parent.frame()) 
[13:17:29.500]                   {
[13:17:29.500]                     if (is.function(workers)) 
[13:17:29.500]                       workers <- workers()
[13:17:29.500]                     workers <- structure(as.integer(workers), 
[13:17:29.500]                       class = class(workers))
[13:17:29.500]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:29.500]                       workers >= 1)
[13:17:29.500]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:29.500]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:29.500]                     }
[13:17:29.500]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:29.500]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:29.500]                       envir = envir)
[13:17:29.500]                     if (!future$lazy) 
[13:17:29.500]                       future <- run(future)
[13:17:29.500]                     invisible(future)
[13:17:29.500]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.500]                 }
[13:17:29.500]             }
[13:17:29.500]         }
[13:17:29.500]     })
[13:17:29.500]     if (TRUE) {
[13:17:29.500]         base::sink(type = "output", split = FALSE)
[13:17:29.500]         if (TRUE) {
[13:17:29.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.500]         }
[13:17:29.500]         else {
[13:17:29.500]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.500]         }
[13:17:29.500]         base::close(...future.stdout)
[13:17:29.500]         ...future.stdout <- NULL
[13:17:29.500]     }
[13:17:29.500]     ...future.result$conditions <- ...future.conditions
[13:17:29.500]     ...future.result$finished <- base::Sys.time()
[13:17:29.500]     ...future.result
[13:17:29.500] }
[13:17:29.502] assign_globals() ...
[13:17:29.502] List of 5
[13:17:29.502]  $ ...future.FUN            :function (object, ...)  
[13:17:29.502]  $ future.call.arguments    : list()
[13:17:29.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.502]  $ ...future.elements_ii    :List of 3
[13:17:29.502]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.502]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.502]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.502]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.502]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.502]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.502]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.502]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.502]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.502]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.502]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.502]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.502]  $ ...future.seeds_ii       : NULL
[13:17:29.502]  $ ...future.globals.maxSize: NULL
[13:17:29.502]  - attr(*, "resolved")= logi FALSE
[13:17:29.502]  - attr(*, "total_size")= num 1240
[13:17:29.502]  - attr(*, "where")=List of 5
[13:17:29.502]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.502]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.502]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.502]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.502]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.502]  - attr(*, "already-done")= logi TRUE
[13:17:29.511] - copied ‘...future.FUN’ to environment
[13:17:29.511] - copied ‘future.call.arguments’ to environment
[13:17:29.511] - copied ‘...future.elements_ii’ to environment
[13:17:29.511] - copied ‘...future.seeds_ii’ to environment
[13:17:29.511] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.512] assign_globals() ... done
[13:17:29.512] plan(): Setting new future strategy stack:
[13:17:29.512] List of future strategies:
[13:17:29.512] 1. sequential:
[13:17:29.512]    - args: function (..., envir = parent.frame())
[13:17:29.512]    - tweaked: FALSE
[13:17:29.512]    - call: NULL
[13:17:29.512] plan(): nbrOfWorkers() = 1
[13:17:29.514] plan(): Setting new future strategy stack:
[13:17:29.514] List of future strategies:
[13:17:29.514] 1. multisession:
[13:17:29.514]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:29.514]    - tweaked: FALSE
[13:17:29.514]    - call: plan(strategy)
[13:17:29.518] plan(): nbrOfWorkers() = 1
[13:17:29.518] SequentialFuture started (and completed)
[13:17:29.519] - Launch lazy future ... done
[13:17:29.519] run() for ‘SequentialFuture’ ... done
[13:17:29.519] Created future:
[13:17:29.519] SequentialFuture:
[13:17:29.519] Label: ‘future_by-1’
[13:17:29.519] Expression:
[13:17:29.519] {
[13:17:29.519]     do.call(function(...) {
[13:17:29.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.519]             on.exit(options(oopts), add = TRUE)
[13:17:29.519]         }
[13:17:29.519]         {
[13:17:29.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.519]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.519]             })
[13:17:29.519]         }
[13:17:29.519]     }, args = future.call.arguments)
[13:17:29.519] }
[13:17:29.519] Lazy evaluation: FALSE
[13:17:29.519] Asynchronous evaluation: FALSE
[13:17:29.519] Local evaluation: TRUE
[13:17:29.519] Environment: 0x5609e9dc7bd0
[13:17:29.519] Capture standard output: TRUE
[13:17:29.519] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.519] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.519] Packages: <none>
[13:17:29.519] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.519] Resolved: TRUE
[13:17:29.519] Value: 5.37 KiB of class ‘list’
[13:17:29.519] Early signaling: FALSE
[13:17:29.519] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.519] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.521] Chunk #1 of 1 ... DONE
[13:17:29.521] Launching 1 futures (chunks) ... DONE
[13:17:29.521] Resolving 1 futures (chunks) ...
[13:17:29.521] resolve() on list ...
[13:17:29.521]  recursive: 0
[13:17:29.521]  length: 1
[13:17:29.521] 
[13:17:29.521] resolved() for ‘SequentialFuture’ ...
[13:17:29.522] - state: ‘finished’
[13:17:29.522] - run: TRUE
[13:17:29.522] - result: ‘FutureResult’
[13:17:29.522] resolved() for ‘SequentialFuture’ ... done
[13:17:29.522] Future #1
[13:17:29.522] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.522] - nx: 1
[13:17:29.522] - relay: TRUE
[13:17:29.522] - stdout: TRUE
[13:17:29.522] - signal: TRUE
[13:17:29.523] - resignal: FALSE
[13:17:29.523] - force: TRUE
[13:17:29.524] - relayed: [n=1] FALSE
[13:17:29.524] - queued futures: [n=1] FALSE
[13:17:29.524]  - until=1
[13:17:29.524]  - relaying element #1
[13:17:29.525] - relayed: [n=1] TRUE
[13:17:29.525] - queued futures: [n=1] TRUE
[13:17:29.525] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.525]  length: 0 (resolved future 1)
[13:17:29.525] Relaying remaining futures
[13:17:29.525] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.525] - nx: 1
[13:17:29.525] - relay: TRUE
[13:17:29.525] - stdout: TRUE
[13:17:29.526] - signal: TRUE
[13:17:29.526] - resignal: FALSE
[13:17:29.526] - force: TRUE
[13:17:29.526] - relayed: [n=1] TRUE
[13:17:29.526] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.526] - relayed: [n=1] TRUE
[13:17:29.526] - queued futures: [n=1] TRUE
[13:17:29.526] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.526] resolve() on list ... DONE
[13:17:29.527]  - Number of value chunks collected: 1
[13:17:29.527] Resolving 1 futures (chunks) ... DONE
[13:17:29.527] Reducing values from 1 chunks ...
[13:17:29.527]  - Number of values collected after concatenation: 3
[13:17:29.527]  - Number of values expected: 3
[13:17:29.527] Reducing values from 1 chunks ... DONE
[13:17:29.527] future_lapply() ... DONE
[13:17:29.527] future_by_internal() ... DONE
[13:17:29.528] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[13:17:29.529] plan(): Setting new future strategy stack:
[13:17:29.529] List of future strategies:
[13:17:29.529] 1. sequential:
[13:17:29.529]    - args: function (..., envir = parent.frame())
[13:17:29.529]    - tweaked: FALSE
[13:17:29.529]    - call: plan(strategy)
[13:17:29.530] plan(): nbrOfWorkers() = 1
[13:17:29.530] future_by_internal() ...
[13:17:29.530] future_lapply() ...
[13:17:29.531] Number of chunks: 1
[13:17:29.531] getGlobalsAndPackagesXApply() ...
[13:17:29.531]  - future.globals: TRUE
[13:17:29.531] getGlobalsAndPackages() ...
[13:17:29.531] Searching for globals...
[13:17:29.532] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.532] Searching for globals ... DONE
[13:17:29.532] Resolving globals: FALSE
[13:17:29.532] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.533] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.533] - globals: [1] ‘FUN’
[13:17:29.533] 
[13:17:29.533] getGlobalsAndPackages() ... DONE
[13:17:29.533]  - globals found/used: [n=1] ‘FUN’
[13:17:29.533]  - needed namespaces: [n=0] 
[13:17:29.533] Finding globals ... DONE
[13:17:29.534]  - use_args: TRUE
[13:17:29.534]  - Getting '...' globals ...
[13:17:29.534] resolve() on list ...
[13:17:29.534]  recursive: 0
[13:17:29.534]  length: 1
[13:17:29.534]  elements: ‘...’
[13:17:29.534]  length: 0 (resolved future 1)
[13:17:29.534] resolve() on list ... DONE
[13:17:29.534]    - '...' content: [n=0] 
[13:17:29.535] List of 1
[13:17:29.535]  $ ...: list()
[13:17:29.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.535]  - attr(*, "where")=List of 1
[13:17:29.535]   ..$ ...:<environment: 0x5609e93ab900> 
[13:17:29.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.535]  - attr(*, "resolved")= logi TRUE
[13:17:29.535]  - attr(*, "total_size")= num NA
[13:17:29.537]  - Getting '...' globals ... DONE
[13:17:29.537] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.537] List of 2
[13:17:29.537]  $ ...future.FUN:function (object, ...)  
[13:17:29.537]  $ ...          : list()
[13:17:29.537]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.537]  - attr(*, "where")=List of 2
[13:17:29.537]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.537]   ..$ ...          :<environment: 0x5609e93ab900> 
[13:17:29.537]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.537]  - attr(*, "resolved")= logi FALSE
[13:17:29.537]  - attr(*, "total_size")= num 1240
[13:17:29.540] Packages to be attached in all futures: [n=0] 
[13:17:29.540] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.540] Number of futures (= number of chunks): 1
[13:17:29.540] Launching 1 futures (chunks) ...
[13:17:29.540] Chunk #1 of 1 ...
[13:17:29.541]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.541] getGlobalsAndPackages() ...
[13:17:29.541] Searching for globals...
[13:17:29.541] 
[13:17:29.541] Searching for globals ... DONE
[13:17:29.541] - globals: [0] <none>
[13:17:29.541] getGlobalsAndPackages() ... DONE
[13:17:29.542]    + additional globals found: [n=0] 
[13:17:29.542]    + additional namespaces needed: [n=0] 
[13:17:29.542]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.542]  - seeds: <none>
[13:17:29.542] getGlobalsAndPackages() ...
[13:17:29.542] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.542] Resolving globals: FALSE
[13:17:29.542] Tweak future expression to call with '...' arguments ...
[13:17:29.542] {
[13:17:29.542]     do.call(function(...) {
[13:17:29.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.542]             on.exit(options(oopts), add = TRUE)
[13:17:29.542]         }
[13:17:29.542]         {
[13:17:29.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.542]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.542]             })
[13:17:29.542]         }
[13:17:29.542]     }, args = future.call.arguments)
[13:17:29.542] }
[13:17:29.543] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.543] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.543] 
[13:17:29.543] getGlobalsAndPackages() ... DONE
[13:17:29.544] run() for ‘Future’ ...
[13:17:29.544] - state: ‘created’
[13:17:29.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:29.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.546]   - Field: ‘label’
[13:17:29.546]   - Field: ‘local’
[13:17:29.546]   - Field: ‘owner’
[13:17:29.546]   - Field: ‘envir’
[13:17:29.546]   - Field: ‘packages’
[13:17:29.546]   - Field: ‘gc’
[13:17:29.546]   - Field: ‘conditions’
[13:17:29.546]   - Field: ‘expr’
[13:17:29.546]   - Field: ‘uuid’
[13:17:29.547]   - Field: ‘seed’
[13:17:29.547]   - Field: ‘version’
[13:17:29.547]   - Field: ‘result’
[13:17:29.547]   - Field: ‘asynchronous’
[13:17:29.547]   - Field: ‘calls’
[13:17:29.547]   - Field: ‘globals’
[13:17:29.547]   - Field: ‘stdout’
[13:17:29.547]   - Field: ‘earlySignal’
[13:17:29.547]   - Field: ‘lazy’
[13:17:29.547]   - Field: ‘state’
[13:17:29.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.548] - Launch lazy future ...
[13:17:29.548] Packages needed by the future expression (n = 0): <none>
[13:17:29.548] Packages needed by future strategies (n = 0): <none>
[13:17:29.548] {
[13:17:29.548]     {
[13:17:29.548]         {
[13:17:29.548]             ...future.startTime <- base::Sys.time()
[13:17:29.548]             {
[13:17:29.548]                 {
[13:17:29.548]                   {
[13:17:29.548]                     base::local({
[13:17:29.548]                       has_future <- base::requireNamespace("future", 
[13:17:29.548]                         quietly = TRUE)
[13:17:29.548]                       if (has_future) {
[13:17:29.548]                         ns <- base::getNamespace("future")
[13:17:29.548]                         version <- ns[[".package"]][["version"]]
[13:17:29.548]                         if (is.null(version)) 
[13:17:29.548]                           version <- utils::packageVersion("future")
[13:17:29.548]                       }
[13:17:29.548]                       else {
[13:17:29.548]                         version <- NULL
[13:17:29.548]                       }
[13:17:29.548]                       if (!has_future || version < "1.8.0") {
[13:17:29.548]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.548]                           "", base::R.version$version.string), 
[13:17:29.548]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.548]                             "release", "version")], collapse = " "), 
[13:17:29.548]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.548]                           info)
[13:17:29.548]                         info <- base::paste(info, collapse = "; ")
[13:17:29.548]                         if (!has_future) {
[13:17:29.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.548]                             info)
[13:17:29.548]                         }
[13:17:29.548]                         else {
[13:17:29.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.548]                             info, version)
[13:17:29.548]                         }
[13:17:29.548]                         base::stop(msg)
[13:17:29.548]                       }
[13:17:29.548]                     })
[13:17:29.548]                   }
[13:17:29.548]                   options(future.plan = NULL)
[13:17:29.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.548]                 }
[13:17:29.548]                 ...future.workdir <- getwd()
[13:17:29.548]             }
[13:17:29.548]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.548]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.548]         }
[13:17:29.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.548]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.548]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.548]             base::names(...future.oldOptions))
[13:17:29.548]     }
[13:17:29.548]     if (FALSE) {
[13:17:29.548]     }
[13:17:29.548]     else {
[13:17:29.548]         if (TRUE) {
[13:17:29.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.548]                 open = "w")
[13:17:29.548]         }
[13:17:29.548]         else {
[13:17:29.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.548]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.548]         }
[13:17:29.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.548]             base::sink(type = "output", split = FALSE)
[13:17:29.548]             base::close(...future.stdout)
[13:17:29.548]         }, add = TRUE)
[13:17:29.548]     }
[13:17:29.548]     ...future.frame <- base::sys.nframe()
[13:17:29.548]     ...future.conditions <- base::list()
[13:17:29.548]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.548]     if (FALSE) {
[13:17:29.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.548]     }
[13:17:29.548]     ...future.result <- base::tryCatch({
[13:17:29.548]         base::withCallingHandlers({
[13:17:29.548]             ...future.value <- base::withVisible(base::local({
[13:17:29.548]                 do.call(function(...) {
[13:17:29.548]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.548]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.548]                     ...future.globals.maxSize)) {
[13:17:29.548]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.548]                     on.exit(options(oopts), add = TRUE)
[13:17:29.548]                   }
[13:17:29.548]                   {
[13:17:29.548]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.548]                       FUN = function(jj) {
[13:17:29.548]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.548]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.548]                       })
[13:17:29.548]                   }
[13:17:29.548]                 }, args = future.call.arguments)
[13:17:29.548]             }))
[13:17:29.548]             future::FutureResult(value = ...future.value$value, 
[13:17:29.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.548]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.548]                     ...future.globalenv.names))
[13:17:29.548]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.548]         }, condition = base::local({
[13:17:29.548]             c <- base::c
[13:17:29.548]             inherits <- base::inherits
[13:17:29.548]             invokeRestart <- base::invokeRestart
[13:17:29.548]             length <- base::length
[13:17:29.548]             list <- base::list
[13:17:29.548]             seq.int <- base::seq.int
[13:17:29.548]             signalCondition <- base::signalCondition
[13:17:29.548]             sys.calls <- base::sys.calls
[13:17:29.548]             `[[` <- base::`[[`
[13:17:29.548]             `+` <- base::`+`
[13:17:29.548]             `<<-` <- base::`<<-`
[13:17:29.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.548]                   3L)]
[13:17:29.548]             }
[13:17:29.548]             function(cond) {
[13:17:29.548]                 is_error <- inherits(cond, "error")
[13:17:29.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.548]                   NULL)
[13:17:29.548]                 if (is_error) {
[13:17:29.548]                   sessionInformation <- function() {
[13:17:29.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.548]                       search = base::search(), system = base::Sys.info())
[13:17:29.548]                   }
[13:17:29.548]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.548]                     cond$call), session = sessionInformation(), 
[13:17:29.548]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.548]                   signalCondition(cond)
[13:17:29.548]                 }
[13:17:29.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.548]                 "immediateCondition"))) {
[13:17:29.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.548]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.548]                   if (TRUE && !signal) {
[13:17:29.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.548]                     {
[13:17:29.548]                       inherits <- base::inherits
[13:17:29.548]                       invokeRestart <- base::invokeRestart
[13:17:29.548]                       is.null <- base::is.null
[13:17:29.548]                       muffled <- FALSE
[13:17:29.548]                       if (inherits(cond, "message")) {
[13:17:29.548]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.548]                         if (muffled) 
[13:17:29.548]                           invokeRestart("muffleMessage")
[13:17:29.548]                       }
[13:17:29.548]                       else if (inherits(cond, "warning")) {
[13:17:29.548]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.548]                         if (muffled) 
[13:17:29.548]                           invokeRestart("muffleWarning")
[13:17:29.548]                       }
[13:17:29.548]                       else if (inherits(cond, "condition")) {
[13:17:29.548]                         if (!is.null(pattern)) {
[13:17:29.548]                           computeRestarts <- base::computeRestarts
[13:17:29.548]                           grepl <- base::grepl
[13:17:29.548]                           restarts <- computeRestarts(cond)
[13:17:29.548]                           for (restart in restarts) {
[13:17:29.548]                             name <- restart$name
[13:17:29.548]                             if (is.null(name)) 
[13:17:29.548]                               next
[13:17:29.548]                             if (!grepl(pattern, name)) 
[13:17:29.548]                               next
[13:17:29.548]                             invokeRestart(restart)
[13:17:29.548]                             muffled <- TRUE
[13:17:29.548]                             break
[13:17:29.548]                           }
[13:17:29.548]                         }
[13:17:29.548]                       }
[13:17:29.548]                       invisible(muffled)
[13:17:29.548]                     }
[13:17:29.548]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.548]                   }
[13:17:29.548]                 }
[13:17:29.548]                 else {
[13:17:29.548]                   if (TRUE) {
[13:17:29.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.548]                     {
[13:17:29.548]                       inherits <- base::inherits
[13:17:29.548]                       invokeRestart <- base::invokeRestart
[13:17:29.548]                       is.null <- base::is.null
[13:17:29.548]                       muffled <- FALSE
[13:17:29.548]                       if (inherits(cond, "message")) {
[13:17:29.548]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.548]                         if (muffled) 
[13:17:29.548]                           invokeRestart("muffleMessage")
[13:17:29.548]                       }
[13:17:29.548]                       else if (inherits(cond, "warning")) {
[13:17:29.548]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.548]                         if (muffled) 
[13:17:29.548]                           invokeRestart("muffleWarning")
[13:17:29.548]                       }
[13:17:29.548]                       else if (inherits(cond, "condition")) {
[13:17:29.548]                         if (!is.null(pattern)) {
[13:17:29.548]                           computeRestarts <- base::computeRestarts
[13:17:29.548]                           grepl <- base::grepl
[13:17:29.548]                           restarts <- computeRestarts(cond)
[13:17:29.548]                           for (restart in restarts) {
[13:17:29.548]                             name <- restart$name
[13:17:29.548]                             if (is.null(name)) 
[13:17:29.548]                               next
[13:17:29.548]                             if (!grepl(pattern, name)) 
[13:17:29.548]                               next
[13:17:29.548]                             invokeRestart(restart)
[13:17:29.548]                             muffled <- TRUE
[13:17:29.548]                             break
[13:17:29.548]                           }
[13:17:29.548]                         }
[13:17:29.548]                       }
[13:17:29.548]                       invisible(muffled)
[13:17:29.548]                     }
[13:17:29.548]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.548]                   }
[13:17:29.548]                 }
[13:17:29.548]             }
[13:17:29.548]         }))
[13:17:29.548]     }, error = function(ex) {
[13:17:29.548]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.548]                 ...future.rng), started = ...future.startTime, 
[13:17:29.548]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.548]             version = "1.8"), class = "FutureResult")
[13:17:29.548]     }, finally = {
[13:17:29.548]         if (!identical(...future.workdir, getwd())) 
[13:17:29.548]             setwd(...future.workdir)
[13:17:29.548]         {
[13:17:29.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.548]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.548]             }
[13:17:29.548]             base::options(...future.oldOptions)
[13:17:29.548]             if (.Platform$OS.type == "windows") {
[13:17:29.548]                 old_names <- names(...future.oldEnvVars)
[13:17:29.548]                 envs <- base::Sys.getenv()
[13:17:29.548]                 names <- names(envs)
[13:17:29.548]                 common <- intersect(names, old_names)
[13:17:29.548]                 added <- setdiff(names, old_names)
[13:17:29.548]                 removed <- setdiff(old_names, names)
[13:17:29.548]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.548]                   envs[common]]
[13:17:29.548]                 NAMES <- toupper(changed)
[13:17:29.548]                 args <- list()
[13:17:29.548]                 for (kk in seq_along(NAMES)) {
[13:17:29.548]                   name <- changed[[kk]]
[13:17:29.548]                   NAME <- NAMES[[kk]]
[13:17:29.548]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.548]                     next
[13:17:29.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.548]                 }
[13:17:29.548]                 NAMES <- toupper(added)
[13:17:29.548]                 for (kk in seq_along(NAMES)) {
[13:17:29.548]                   name <- added[[kk]]
[13:17:29.548]                   NAME <- NAMES[[kk]]
[13:17:29.548]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.548]                     next
[13:17:29.548]                   args[[name]] <- ""
[13:17:29.548]                 }
[13:17:29.548]                 NAMES <- toupper(removed)
[13:17:29.548]                 for (kk in seq_along(NAMES)) {
[13:17:29.548]                   name <- removed[[kk]]
[13:17:29.548]                   NAME <- NAMES[[kk]]
[13:17:29.548]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.548]                     next
[13:17:29.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.548]                 }
[13:17:29.548]                 if (length(args) > 0) 
[13:17:29.548]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.548]             }
[13:17:29.548]             else {
[13:17:29.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.548]             }
[13:17:29.548]             {
[13:17:29.548]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.548]                   0L) {
[13:17:29.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.548]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.548]                   base::options(opts)
[13:17:29.548]                 }
[13:17:29.548]                 {
[13:17:29.548]                   {
[13:17:29.548]                     NULL
[13:17:29.548]                     RNGkind("Mersenne-Twister")
[13:17:29.548]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.548]                       inherits = FALSE)
[13:17:29.548]                   }
[13:17:29.548]                   options(future.plan = NULL)
[13:17:29.548]                   if (is.na(NA_character_)) 
[13:17:29.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.548]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:29.548]                   {
[13:17:29.548]                     future <- SequentialFuture(..., envir = envir)
[13:17:29.548]                     if (!future$lazy) 
[13:17:29.548]                       future <- run(future)
[13:17:29.548]                     invisible(future)
[13:17:29.548]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.548]                 }
[13:17:29.548]             }
[13:17:29.548]         }
[13:17:29.548]     })
[13:17:29.548]     if (TRUE) {
[13:17:29.548]         base::sink(type = "output", split = FALSE)
[13:17:29.548]         if (TRUE) {
[13:17:29.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.548]         }
[13:17:29.548]         else {
[13:17:29.548]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.548]         }
[13:17:29.548]         base::close(...future.stdout)
[13:17:29.548]         ...future.stdout <- NULL
[13:17:29.548]     }
[13:17:29.548]     ...future.result$conditions <- ...future.conditions
[13:17:29.548]     ...future.result$finished <- base::Sys.time()
[13:17:29.548]     ...future.result
[13:17:29.548] }
[13:17:29.550] assign_globals() ...
[13:17:29.550] List of 5
[13:17:29.550]  $ ...future.FUN            :function (object, ...)  
[13:17:29.550]  $ future.call.arguments    : list()
[13:17:29.550]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.550]  $ ...future.elements_ii    :List of 3
[13:17:29.550]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.550]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.550]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.550]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.550]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.550]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.550]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.550]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.550]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.550]  $ ...future.seeds_ii       : NULL
[13:17:29.550]  $ ...future.globals.maxSize: NULL
[13:17:29.550]  - attr(*, "resolved")= logi FALSE
[13:17:29.550]  - attr(*, "total_size")= num 1240
[13:17:29.550]  - attr(*, "where")=List of 5
[13:17:29.550]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.550]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.550]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.550]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.550]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.550]  - attr(*, "already-done")= logi TRUE
[13:17:29.558] - copied ‘...future.FUN’ to environment
[13:17:29.558] - copied ‘future.call.arguments’ to environment
[13:17:29.558] - copied ‘...future.elements_ii’ to environment
[13:17:29.558] - copied ‘...future.seeds_ii’ to environment
[13:17:29.558] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.558] assign_globals() ... done
[13:17:29.558] plan(): Setting new future strategy stack:
[13:17:29.558] List of future strategies:
[13:17:29.558] 1. sequential:
[13:17:29.558]    - args: function (..., envir = parent.frame())
[13:17:29.558]    - tweaked: FALSE
[13:17:29.558]    - call: NULL
[13:17:29.559] plan(): nbrOfWorkers() = 1
[13:17:29.561] plan(): Setting new future strategy stack:
[13:17:29.561] List of future strategies:
[13:17:29.561] 1. sequential:
[13:17:29.561]    - args: function (..., envir = parent.frame())
[13:17:29.561]    - tweaked: FALSE
[13:17:29.561]    - call: plan(strategy)
[13:17:29.561] plan(): nbrOfWorkers() = 1
[13:17:29.561] SequentialFuture started (and completed)
[13:17:29.561] - Launch lazy future ... done
[13:17:29.562] run() for ‘SequentialFuture’ ... done
[13:17:29.562] Created future:
[13:17:29.562] SequentialFuture:
[13:17:29.562] Label: ‘future_by-1’
[13:17:29.562] Expression:
[13:17:29.562] {
[13:17:29.562]     do.call(function(...) {
[13:17:29.562]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.562]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.562]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.562]             on.exit(options(oopts), add = TRUE)
[13:17:29.562]         }
[13:17:29.562]         {
[13:17:29.562]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.562]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.562]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.562]             })
[13:17:29.562]         }
[13:17:29.562]     }, args = future.call.arguments)
[13:17:29.562] }
[13:17:29.562] Lazy evaluation: FALSE
[13:17:29.562] Asynchronous evaluation: FALSE
[13:17:29.562] Local evaluation: TRUE
[13:17:29.562] Environment: R_GlobalEnv
[13:17:29.562] Capture standard output: TRUE
[13:17:29.562] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.562] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.562] Packages: <none>
[13:17:29.562] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.562] Resolved: TRUE
[13:17:29.562] Value: 4.62 KiB of class ‘list’
[13:17:29.562] Early signaling: FALSE
[13:17:29.562] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.562] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.563] Chunk #1 of 1 ... DONE
[13:17:29.563] Launching 1 futures (chunks) ... DONE
[13:17:29.563] Resolving 1 futures (chunks) ...
[13:17:29.563] resolve() on list ...
[13:17:29.563]  recursive: 0
[13:17:29.563]  length: 1
[13:17:29.563] 
[13:17:29.564] resolved() for ‘SequentialFuture’ ...
[13:17:29.564] - state: ‘finished’
[13:17:29.564] - run: TRUE
[13:17:29.564] - result: ‘FutureResult’
[13:17:29.564] resolved() for ‘SequentialFuture’ ... done
[13:17:29.564] Future #1
[13:17:29.564] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.564] - nx: 1
[13:17:29.564] - relay: TRUE
[13:17:29.564] - stdout: TRUE
[13:17:29.565] - signal: TRUE
[13:17:29.565] - resignal: FALSE
[13:17:29.565] - force: TRUE
[13:17:29.565] - relayed: [n=1] FALSE
[13:17:29.565] - queued futures: [n=1] FALSE
[13:17:29.565]  - until=1
[13:17:29.565]  - relaying element #1
[13:17:29.565] - relayed: [n=1] TRUE
[13:17:29.565] - queued futures: [n=1] TRUE
[13:17:29.565] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.566]  length: 0 (resolved future 1)
[13:17:29.566] Relaying remaining futures
[13:17:29.566] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.567] - nx: 1
[13:17:29.567] - relay: TRUE
[13:17:29.567] - stdout: TRUE
[13:17:29.567] - signal: TRUE
[13:17:29.568] - resignal: FALSE
[13:17:29.568] - force: TRUE
[13:17:29.568] - relayed: [n=1] TRUE
[13:17:29.568] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.568] - relayed: [n=1] TRUE
[13:17:29.568] - queued futures: [n=1] TRUE
[13:17:29.568] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.568] resolve() on list ... DONE
[13:17:29.568]  - Number of value chunks collected: 1
[13:17:29.569] Resolving 1 futures (chunks) ... DONE
[13:17:29.569] Reducing values from 1 chunks ...
[13:17:29.569]  - Number of values collected after concatenation: 3
[13:17:29.569]  - Number of values expected: 3
[13:17:29.569] Reducing values from 1 chunks ... DONE
[13:17:29.569] future_lapply() ... DONE
[13:17:29.569] future_by_internal() ... DONE
[13:17:29.569] future_by_internal() ...
[13:17:29.570] future_lapply() ...
[13:17:29.570] Number of chunks: 1
[13:17:29.570] getGlobalsAndPackagesXApply() ...
[13:17:29.571]  - future.globals: TRUE
[13:17:29.571] getGlobalsAndPackages() ...
[13:17:29.571] Searching for globals...
[13:17:29.572] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.572] Searching for globals ... DONE
[13:17:29.572] Resolving globals: FALSE
[13:17:29.572] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.573] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.573] - globals: [1] ‘FUN’
[13:17:29.573] 
[13:17:29.573] getGlobalsAndPackages() ... DONE
[13:17:29.573]  - globals found/used: [n=1] ‘FUN’
[13:17:29.573]  - needed namespaces: [n=0] 
[13:17:29.573] Finding globals ... DONE
[13:17:29.573]  - use_args: TRUE
[13:17:29.573]  - Getting '...' globals ...
[13:17:29.574] resolve() on list ...
[13:17:29.574]  recursive: 0
[13:17:29.574]  length: 1
[13:17:29.574]  elements: ‘...’
[13:17:29.574]  length: 0 (resolved future 1)
[13:17:29.574] resolve() on list ... DONE
[13:17:29.574]    - '...' content: [n=1] ‘digits’
[13:17:29.574] List of 1
[13:17:29.574]  $ ...:List of 1
[13:17:29.574]   ..$ digits: int 2
[13:17:29.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.574]  - attr(*, "where")=List of 1
[13:17:29.574]   ..$ ...:<environment: 0x5609e8585db0> 
[13:17:29.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.574]  - attr(*, "resolved")= logi TRUE
[13:17:29.574]  - attr(*, "total_size")= num NA
[13:17:29.577]  - Getting '...' globals ... DONE
[13:17:29.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.578] List of 2
[13:17:29.578]  $ ...future.FUN:function (object, ...)  
[13:17:29.578]  $ ...          :List of 1
[13:17:29.578]   ..$ digits: int 2
[13:17:29.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.578]  - attr(*, "where")=List of 2
[13:17:29.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.578]   ..$ ...          :<environment: 0x5609e8585db0> 
[13:17:29.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.578]  - attr(*, "resolved")= logi FALSE
[13:17:29.578]  - attr(*, "total_size")= num 1296
[13:17:29.581] Packages to be attached in all futures: [n=0] 
[13:17:29.581] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.581] Number of futures (= number of chunks): 1
[13:17:29.581] Launching 1 futures (chunks) ...
[13:17:29.581] Chunk #1 of 1 ...
[13:17:29.581]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.581] getGlobalsAndPackages() ...
[13:17:29.581] Searching for globals...
[13:17:29.582] 
[13:17:29.582] Searching for globals ... DONE
[13:17:29.582] - globals: [0] <none>
[13:17:29.582] getGlobalsAndPackages() ... DONE
[13:17:29.582]    + additional globals found: [n=0] 
[13:17:29.582]    + additional namespaces needed: [n=0] 
[13:17:29.582]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.582]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[13:17:29.582]  - seeds: <none>
[13:17:29.582] getGlobalsAndPackages() ...
[13:17:29.583] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.583] Resolving globals: FALSE
[13:17:29.583] Tweak future expression to call with '...' arguments ...
[13:17:29.583] {
[13:17:29.583]     do.call(function(...) {
[13:17:29.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.583]             on.exit(options(oopts), add = TRUE)
[13:17:29.583]         }
[13:17:29.583]         {
[13:17:29.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.583]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.583]             })
[13:17:29.583]         }
[13:17:29.583]     }, args = future.call.arguments)
[13:17:29.583] }
[13:17:29.583] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.583] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.584] 
[13:17:29.584] getGlobalsAndPackages() ... DONE
[13:17:29.584] run() for ‘Future’ ...
[13:17:29.584] - state: ‘created’
[13:17:29.584] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:29.584] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.585]   - Field: ‘label’
[13:17:29.585]   - Field: ‘local’
[13:17:29.585]   - Field: ‘owner’
[13:17:29.585]   - Field: ‘envir’
[13:17:29.585]   - Field: ‘packages’
[13:17:29.585]   - Field: ‘gc’
[13:17:29.585]   - Field: ‘conditions’
[13:17:29.585]   - Field: ‘expr’
[13:17:29.585]   - Field: ‘uuid’
[13:17:29.585]   - Field: ‘seed’
[13:17:29.586]   - Field: ‘version’
[13:17:29.586]   - Field: ‘result’
[13:17:29.586]   - Field: ‘asynchronous’
[13:17:29.586]   - Field: ‘calls’
[13:17:29.586]   - Field: ‘globals’
[13:17:29.586]   - Field: ‘stdout’
[13:17:29.586]   - Field: ‘earlySignal’
[13:17:29.586]   - Field: ‘lazy’
[13:17:29.586]   - Field: ‘state’
[13:17:29.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.588] - Launch lazy future ...
[13:17:29.588] Packages needed by the future expression (n = 0): <none>
[13:17:29.588] Packages needed by future strategies (n = 0): <none>
[13:17:29.589] {
[13:17:29.589]     {
[13:17:29.589]         {
[13:17:29.589]             ...future.startTime <- base::Sys.time()
[13:17:29.589]             {
[13:17:29.589]                 {
[13:17:29.589]                   {
[13:17:29.589]                     base::local({
[13:17:29.589]                       has_future <- base::requireNamespace("future", 
[13:17:29.589]                         quietly = TRUE)
[13:17:29.589]                       if (has_future) {
[13:17:29.589]                         ns <- base::getNamespace("future")
[13:17:29.589]                         version <- ns[[".package"]][["version"]]
[13:17:29.589]                         if (is.null(version)) 
[13:17:29.589]                           version <- utils::packageVersion("future")
[13:17:29.589]                       }
[13:17:29.589]                       else {
[13:17:29.589]                         version <- NULL
[13:17:29.589]                       }
[13:17:29.589]                       if (!has_future || version < "1.8.0") {
[13:17:29.589]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.589]                           "", base::R.version$version.string), 
[13:17:29.589]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.589]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.589]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.589]                             "release", "version")], collapse = " "), 
[13:17:29.589]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.589]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.589]                           info)
[13:17:29.589]                         info <- base::paste(info, collapse = "; ")
[13:17:29.589]                         if (!has_future) {
[13:17:29.589]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.589]                             info)
[13:17:29.589]                         }
[13:17:29.589]                         else {
[13:17:29.589]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.589]                             info, version)
[13:17:29.589]                         }
[13:17:29.589]                         base::stop(msg)
[13:17:29.589]                       }
[13:17:29.589]                     })
[13:17:29.589]                   }
[13:17:29.589]                   options(future.plan = NULL)
[13:17:29.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.589]                 }
[13:17:29.589]                 ...future.workdir <- getwd()
[13:17:29.589]             }
[13:17:29.589]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.589]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.589]         }
[13:17:29.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.589]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[13:17:29.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.589]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.589]             base::names(...future.oldOptions))
[13:17:29.589]     }
[13:17:29.589]     if (FALSE) {
[13:17:29.589]     }
[13:17:29.589]     else {
[13:17:29.589]         if (TRUE) {
[13:17:29.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.589]                 open = "w")
[13:17:29.589]         }
[13:17:29.589]         else {
[13:17:29.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.589]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.589]         }
[13:17:29.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.589]             base::sink(type = "output", split = FALSE)
[13:17:29.589]             base::close(...future.stdout)
[13:17:29.589]         }, add = TRUE)
[13:17:29.589]     }
[13:17:29.589]     ...future.frame <- base::sys.nframe()
[13:17:29.589]     ...future.conditions <- base::list()
[13:17:29.589]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.589]     if (FALSE) {
[13:17:29.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.589]     }
[13:17:29.589]     ...future.result <- base::tryCatch({
[13:17:29.589]         base::withCallingHandlers({
[13:17:29.589]             ...future.value <- base::withVisible(base::local({
[13:17:29.589]                 do.call(function(...) {
[13:17:29.589]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.589]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.589]                     ...future.globals.maxSize)) {
[13:17:29.589]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.589]                     on.exit(options(oopts), add = TRUE)
[13:17:29.589]                   }
[13:17:29.589]                   {
[13:17:29.589]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.589]                       FUN = function(jj) {
[13:17:29.589]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.589]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.589]                       })
[13:17:29.589]                   }
[13:17:29.589]                 }, args = future.call.arguments)
[13:17:29.589]             }))
[13:17:29.589]             future::FutureResult(value = ...future.value$value, 
[13:17:29.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.589]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.589]                     ...future.globalenv.names))
[13:17:29.589]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.589]         }, condition = base::local({
[13:17:29.589]             c <- base::c
[13:17:29.589]             inherits <- base::inherits
[13:17:29.589]             invokeRestart <- base::invokeRestart
[13:17:29.589]             length <- base::length
[13:17:29.589]             list <- base::list
[13:17:29.589]             seq.int <- base::seq.int
[13:17:29.589]             signalCondition <- base::signalCondition
[13:17:29.589]             sys.calls <- base::sys.calls
[13:17:29.589]             `[[` <- base::`[[`
[13:17:29.589]             `+` <- base::`+`
[13:17:29.589]             `<<-` <- base::`<<-`
[13:17:29.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.589]                   3L)]
[13:17:29.589]             }
[13:17:29.589]             function(cond) {
[13:17:29.589]                 is_error <- inherits(cond, "error")
[13:17:29.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.589]                   NULL)
[13:17:29.589]                 if (is_error) {
[13:17:29.589]                   sessionInformation <- function() {
[13:17:29.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.589]                       search = base::search(), system = base::Sys.info())
[13:17:29.589]                   }
[13:17:29.589]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.589]                     cond$call), session = sessionInformation(), 
[13:17:29.589]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.589]                   signalCondition(cond)
[13:17:29.589]                 }
[13:17:29.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.589]                 "immediateCondition"))) {
[13:17:29.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.589]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.589]                   if (TRUE && !signal) {
[13:17:29.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.589]                     {
[13:17:29.589]                       inherits <- base::inherits
[13:17:29.589]                       invokeRestart <- base::invokeRestart
[13:17:29.589]                       is.null <- base::is.null
[13:17:29.589]                       muffled <- FALSE
[13:17:29.589]                       if (inherits(cond, "message")) {
[13:17:29.589]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.589]                         if (muffled) 
[13:17:29.589]                           invokeRestart("muffleMessage")
[13:17:29.589]                       }
[13:17:29.589]                       else if (inherits(cond, "warning")) {
[13:17:29.589]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.589]                         if (muffled) 
[13:17:29.589]                           invokeRestart("muffleWarning")
[13:17:29.589]                       }
[13:17:29.589]                       else if (inherits(cond, "condition")) {
[13:17:29.589]                         if (!is.null(pattern)) {
[13:17:29.589]                           computeRestarts <- base::computeRestarts
[13:17:29.589]                           grepl <- base::grepl
[13:17:29.589]                           restarts <- computeRestarts(cond)
[13:17:29.589]                           for (restart in restarts) {
[13:17:29.589]                             name <- restart$name
[13:17:29.589]                             if (is.null(name)) 
[13:17:29.589]                               next
[13:17:29.589]                             if (!grepl(pattern, name)) 
[13:17:29.589]                               next
[13:17:29.589]                             invokeRestart(restart)
[13:17:29.589]                             muffled <- TRUE
[13:17:29.589]                             break
[13:17:29.589]                           }
[13:17:29.589]                         }
[13:17:29.589]                       }
[13:17:29.589]                       invisible(muffled)
[13:17:29.589]                     }
[13:17:29.589]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.589]                   }
[13:17:29.589]                 }
[13:17:29.589]                 else {
[13:17:29.589]                   if (TRUE) {
[13:17:29.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.589]                     {
[13:17:29.589]                       inherits <- base::inherits
[13:17:29.589]                       invokeRestart <- base::invokeRestart
[13:17:29.589]                       is.null <- base::is.null
[13:17:29.589]                       muffled <- FALSE
[13:17:29.589]                       if (inherits(cond, "message")) {
[13:17:29.589]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.589]                         if (muffled) 
[13:17:29.589]                           invokeRestart("muffleMessage")
[13:17:29.589]                       }
[13:17:29.589]                       else if (inherits(cond, "warning")) {
[13:17:29.589]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.589]                         if (muffled) 
[13:17:29.589]                           invokeRestart("muffleWarning")
[13:17:29.589]                       }
[13:17:29.589]                       else if (inherits(cond, "condition")) {
[13:17:29.589]                         if (!is.null(pattern)) {
[13:17:29.589]                           computeRestarts <- base::computeRestarts
[13:17:29.589]                           grepl <- base::grepl
[13:17:29.589]                           restarts <- computeRestarts(cond)
[13:17:29.589]                           for (restart in restarts) {
[13:17:29.589]                             name <- restart$name
[13:17:29.589]                             if (is.null(name)) 
[13:17:29.589]                               next
[13:17:29.589]                             if (!grepl(pattern, name)) 
[13:17:29.589]                               next
[13:17:29.589]                             invokeRestart(restart)
[13:17:29.589]                             muffled <- TRUE
[13:17:29.589]                             break
[13:17:29.589]                           }
[13:17:29.589]                         }
[13:17:29.589]                       }
[13:17:29.589]                       invisible(muffled)
[13:17:29.589]                     }
[13:17:29.589]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.589]                   }
[13:17:29.589]                 }
[13:17:29.589]             }
[13:17:29.589]         }))
[13:17:29.589]     }, error = function(ex) {
[13:17:29.589]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.589]                 ...future.rng), started = ...future.startTime, 
[13:17:29.589]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.589]             version = "1.8"), class = "FutureResult")
[13:17:29.589]     }, finally = {
[13:17:29.589]         if (!identical(...future.workdir, getwd())) 
[13:17:29.589]             setwd(...future.workdir)
[13:17:29.589]         {
[13:17:29.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.589]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.589]             }
[13:17:29.589]             base::options(...future.oldOptions)
[13:17:29.589]             if (.Platform$OS.type == "windows") {
[13:17:29.589]                 old_names <- names(...future.oldEnvVars)
[13:17:29.589]                 envs <- base::Sys.getenv()
[13:17:29.589]                 names <- names(envs)
[13:17:29.589]                 common <- intersect(names, old_names)
[13:17:29.589]                 added <- setdiff(names, old_names)
[13:17:29.589]                 removed <- setdiff(old_names, names)
[13:17:29.589]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.589]                   envs[common]]
[13:17:29.589]                 NAMES <- toupper(changed)
[13:17:29.589]                 args <- list()
[13:17:29.589]                 for (kk in seq_along(NAMES)) {
[13:17:29.589]                   name <- changed[[kk]]
[13:17:29.589]                   NAME <- NAMES[[kk]]
[13:17:29.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.589]                     next
[13:17:29.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.589]                 }
[13:17:29.589]                 NAMES <- toupper(added)
[13:17:29.589]                 for (kk in seq_along(NAMES)) {
[13:17:29.589]                   name <- added[[kk]]
[13:17:29.589]                   NAME <- NAMES[[kk]]
[13:17:29.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.589]                     next
[13:17:29.589]                   args[[name]] <- ""
[13:17:29.589]                 }
[13:17:29.589]                 NAMES <- toupper(removed)
[13:17:29.589]                 for (kk in seq_along(NAMES)) {
[13:17:29.589]                   name <- removed[[kk]]
[13:17:29.589]                   NAME <- NAMES[[kk]]
[13:17:29.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.589]                     next
[13:17:29.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.589]                 }
[13:17:29.589]                 if (length(args) > 0) 
[13:17:29.589]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.589]             }
[13:17:29.589]             else {
[13:17:29.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.589]             }
[13:17:29.589]             {
[13:17:29.589]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.589]                   0L) {
[13:17:29.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.589]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.589]                   base::options(opts)
[13:17:29.589]                 }
[13:17:29.589]                 {
[13:17:29.589]                   {
[13:17:29.589]                     NULL
[13:17:29.589]                     RNGkind("Mersenne-Twister")
[13:17:29.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.589]                       inherits = FALSE)
[13:17:29.589]                   }
[13:17:29.589]                   options(future.plan = NULL)
[13:17:29.589]                   if (is.na(NA_character_)) 
[13:17:29.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.589]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:29.589]                   {
[13:17:29.589]                     future <- SequentialFuture(..., envir = envir)
[13:17:29.589]                     if (!future$lazy) 
[13:17:29.589]                       future <- run(future)
[13:17:29.589]                     invisible(future)
[13:17:29.589]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.589]                 }
[13:17:29.589]             }
[13:17:29.589]         }
[13:17:29.589]     })
[13:17:29.589]     if (TRUE) {
[13:17:29.589]         base::sink(type = "output", split = FALSE)
[13:17:29.589]         if (TRUE) {
[13:17:29.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.589]         }
[13:17:29.589]         else {
[13:17:29.589]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.589]         }
[13:17:29.589]         base::close(...future.stdout)
[13:17:29.589]         ...future.stdout <- NULL
[13:17:29.589]     }
[13:17:29.589]     ...future.result$conditions <- ...future.conditions
[13:17:29.589]     ...future.result$finished <- base::Sys.time()
[13:17:29.589]     ...future.result
[13:17:29.589] }
[13:17:29.590] assign_globals() ...
[13:17:29.590] List of 5
[13:17:29.590]  $ ...future.FUN            :function (object, ...)  
[13:17:29.590]  $ future.call.arguments    :List of 1
[13:17:29.590]   ..$ digits: int 2
[13:17:29.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.590]  $ ...future.elements_ii    :List of 6
[13:17:29.590]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:17:29.590]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:17:29.590]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:17:29.590]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:17:29.590]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:17:29.590]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:17:29.590]  $ ...future.seeds_ii       : NULL
[13:17:29.590]  $ ...future.globals.maxSize: NULL
[13:17:29.590]  - attr(*, "resolved")= logi FALSE
[13:17:29.590]  - attr(*, "total_size")= num 1296
[13:17:29.590]  - attr(*, "where")=List of 5
[13:17:29.590]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.590]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.590]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.590]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.590]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.590]  - attr(*, "already-done")= logi TRUE
[13:17:29.597] - copied ‘...future.FUN’ to environment
[13:17:29.597] - copied ‘future.call.arguments’ to environment
[13:17:29.597] - copied ‘...future.elements_ii’ to environment
[13:17:29.598] - copied ‘...future.seeds_ii’ to environment
[13:17:29.598] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.598] assign_globals() ... done
[13:17:29.598] plan(): Setting new future strategy stack:
[13:17:29.598] List of future strategies:
[13:17:29.598] 1. sequential:
[13:17:29.598]    - args: function (..., envir = parent.frame())
[13:17:29.598]    - tweaked: FALSE
[13:17:29.598]    - call: NULL
[13:17:29.598] plan(): nbrOfWorkers() = 1
[13:17:29.600] plan(): Setting new future strategy stack:
[13:17:29.600] List of future strategies:
[13:17:29.600] 1. sequential:
[13:17:29.600]    - args: function (..., envir = parent.frame())
[13:17:29.600]    - tweaked: FALSE
[13:17:29.600]    - call: plan(strategy)
[13:17:29.600] plan(): nbrOfWorkers() = 1
[13:17:29.600] SequentialFuture started (and completed)
[13:17:29.601] - Launch lazy future ... done
[13:17:29.601] run() for ‘SequentialFuture’ ... done
[13:17:29.601] Created future:
[13:17:29.601] SequentialFuture:
[13:17:29.601] Label: ‘future_by-1’
[13:17:29.601] Expression:
[13:17:29.601] {
[13:17:29.601]     do.call(function(...) {
[13:17:29.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.601]             on.exit(options(oopts), add = TRUE)
[13:17:29.601]         }
[13:17:29.601]         {
[13:17:29.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.601]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.601]             })
[13:17:29.601]         }
[13:17:29.601]     }, args = future.call.arguments)
[13:17:29.601] }
[13:17:29.601] Lazy evaluation: FALSE
[13:17:29.601] Asynchronous evaluation: FALSE
[13:17:29.601] Local evaluation: TRUE
[13:17:29.601] Environment: R_GlobalEnv
[13:17:29.601] Capture standard output: TRUE
[13:17:29.601] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.601] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.601] Packages: <none>
[13:17:29.601] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.601] Resolved: TRUE
[13:17:29.601] Value: 5.48 KiB of class ‘list’
[13:17:29.601] Early signaling: FALSE
[13:17:29.601] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.601] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.602] Chunk #1 of 1 ... DONE
[13:17:29.602] Launching 1 futures (chunks) ... DONE
[13:17:29.602] Resolving 1 futures (chunks) ...
[13:17:29.602] resolve() on list ...
[13:17:29.602]  recursive: 0
[13:17:29.602]  length: 1
[13:17:29.602] 
[13:17:29.603] resolved() for ‘SequentialFuture’ ...
[13:17:29.603] - state: ‘finished’
[13:17:29.603] - run: TRUE
[13:17:29.603] - result: ‘FutureResult’
[13:17:29.603] resolved() for ‘SequentialFuture’ ... done
[13:17:29.603] Future #1
[13:17:29.603] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.603] - nx: 1
[13:17:29.603] - relay: TRUE
[13:17:29.603] - stdout: TRUE
[13:17:29.603] - signal: TRUE
[13:17:29.604] - resignal: FALSE
[13:17:29.604] - force: TRUE
[13:17:29.604] - relayed: [n=1] FALSE
[13:17:29.604] - queued futures: [n=1] FALSE
[13:17:29.604]  - until=1
[13:17:29.604]  - relaying element #1
[13:17:29.604] - relayed: [n=1] TRUE
[13:17:29.604] - queued futures: [n=1] TRUE
[13:17:29.604] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.604]  length: 0 (resolved future 1)
[13:17:29.605] Relaying remaining futures
[13:17:29.605] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.605] - nx: 1
[13:17:29.605] - relay: TRUE
[13:17:29.605] - stdout: TRUE
[13:17:29.605] - signal: TRUE
[13:17:29.605] - resignal: FALSE
[13:17:29.605] - force: TRUE
[13:17:29.605] - relayed: [n=1] TRUE
[13:17:29.605] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.605] - relayed: [n=1] TRUE
[13:17:29.606] - queued futures: [n=1] TRUE
[13:17:29.606] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.606] resolve() on list ... DONE
[13:17:29.606]  - Number of value chunks collected: 1
[13:17:29.606] Resolving 1 futures (chunks) ... DONE
[13:17:29.606] Reducing values from 1 chunks ...
[13:17:29.606]  - Number of values collected after concatenation: 6
[13:17:29.606]  - Number of values expected: 6
[13:17:29.606] Reducing values from 1 chunks ... DONE
[13:17:29.606] future_lapply() ... DONE
[13:17:29.607] future_by_internal() ... DONE
[13:17:29.608] future_by_internal() ...
[13:17:29.610] future_lapply() ...
[13:17:29.610] Number of chunks: 1
[13:17:29.611] getGlobalsAndPackagesXApply() ...
[13:17:29.611]  - future.globals: TRUE
[13:17:29.611] getGlobalsAndPackages() ...
[13:17:29.611] Searching for globals...
[13:17:29.613] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:29.613] Searching for globals ... DONE
[13:17:29.613] Resolving globals: FALSE
[13:17:29.613] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:17:29.614] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:17:29.614] - globals: [1] ‘FUN’
[13:17:29.614] - packages: [1] ‘stats’
[13:17:29.614] getGlobalsAndPackages() ... DONE
[13:17:29.614]  - globals found/used: [n=1] ‘FUN’
[13:17:29.614]  - needed namespaces: [n=1] ‘stats’
[13:17:29.614] Finding globals ... DONE
[13:17:29.614]  - use_args: TRUE
[13:17:29.614]  - Getting '...' globals ...
[13:17:29.615] resolve() on list ...
[13:17:29.615]  recursive: 0
[13:17:29.615]  length: 1
[13:17:29.615]  elements: ‘...’
[13:17:29.615]  length: 0 (resolved future 1)
[13:17:29.615] resolve() on list ... DONE
[13:17:29.615]    - '...' content: [n=1] ‘singular.ok’
[13:17:29.615] List of 1
[13:17:29.615]  $ ...:List of 1
[13:17:29.615]   ..$ singular.ok: logi FALSE
[13:17:29.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.615]  - attr(*, "where")=List of 1
[13:17:29.615]   ..$ ...:<environment: 0x5609e8ad7008> 
[13:17:29.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.615]  - attr(*, "resolved")= logi TRUE
[13:17:29.615]  - attr(*, "total_size")= num NA
[13:17:29.618]  - Getting '...' globals ... DONE
[13:17:29.618] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.619] List of 2
[13:17:29.619]  $ ...future.FUN:function (x, ...)  
[13:17:29.619]  $ ...          :List of 1
[13:17:29.619]   ..$ singular.ok: logi FALSE
[13:17:29.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.619]  - attr(*, "where")=List of 2
[13:17:29.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.619]   ..$ ...          :<environment: 0x5609e8ad7008> 
[13:17:29.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.619]  - attr(*, "resolved")= logi FALSE
[13:17:29.619]  - attr(*, "total_size")= num 5384
[13:17:29.622] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:29.622] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.622] Number of futures (= number of chunks): 1
[13:17:29.622] Launching 1 futures (chunks) ...
[13:17:29.622] Chunk #1 of 1 ...
[13:17:29.622]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.622] getGlobalsAndPackages() ...
[13:17:29.622] Searching for globals...
[13:17:29.623] 
[13:17:29.623] Searching for globals ... DONE
[13:17:29.623] - globals: [0] <none>
[13:17:29.623] getGlobalsAndPackages() ... DONE
[13:17:29.623]    + additional globals found: [n=0] 
[13:17:29.623]    + additional namespaces needed: [n=0] 
[13:17:29.623]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.624]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.624]  - seeds: <none>
[13:17:29.624] getGlobalsAndPackages() ...
[13:17:29.624] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.624] Resolving globals: FALSE
[13:17:29.624] Tweak future expression to call with '...' arguments ...
[13:17:29.624] {
[13:17:29.624]     do.call(function(...) {
[13:17:29.624]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.624]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.624]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.624]             on.exit(options(oopts), add = TRUE)
[13:17:29.624]         }
[13:17:29.624]         {
[13:17:29.624]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.624]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.624]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.624]             })
[13:17:29.624]         }
[13:17:29.624]     }, args = future.call.arguments)
[13:17:29.624] }
[13:17:29.624] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.625] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.625] 
[13:17:29.625] getGlobalsAndPackages() ... DONE
[13:17:29.625] run() for ‘Future’ ...
[13:17:29.626] - state: ‘created’
[13:17:29.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:29.626] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.626]   - Field: ‘label’
[13:17:29.626]   - Field: ‘local’
[13:17:29.626]   - Field: ‘owner’
[13:17:29.626]   - Field: ‘envir’
[13:17:29.627]   - Field: ‘packages’
[13:17:29.627]   - Field: ‘gc’
[13:17:29.627]   - Field: ‘conditions’
[13:17:29.627]   - Field: ‘expr’
[13:17:29.627]   - Field: ‘uuid’
[13:17:29.627]   - Field: ‘seed’
[13:17:29.627]   - Field: ‘version’
[13:17:29.627]   - Field: ‘result’
[13:17:29.627]   - Field: ‘asynchronous’
[13:17:29.627]   - Field: ‘calls’
[13:17:29.627]   - Field: ‘globals’
[13:17:29.628]   - Field: ‘stdout’
[13:17:29.628]   - Field: ‘earlySignal’
[13:17:29.628]   - Field: ‘lazy’
[13:17:29.628]   - Field: ‘state’
[13:17:29.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.628] - Launch lazy future ...
[13:17:29.628] Packages needed by the future expression (n = 1): ‘stats’
[13:17:29.630] Packages needed by future strategies (n = 0): <none>
[13:17:29.631] {
[13:17:29.631]     {
[13:17:29.631]         {
[13:17:29.631]             ...future.startTime <- base::Sys.time()
[13:17:29.631]             {
[13:17:29.631]                 {
[13:17:29.631]                   {
[13:17:29.631]                     {
[13:17:29.631]                       base::local({
[13:17:29.631]                         has_future <- base::requireNamespace("future", 
[13:17:29.631]                           quietly = TRUE)
[13:17:29.631]                         if (has_future) {
[13:17:29.631]                           ns <- base::getNamespace("future")
[13:17:29.631]                           version <- ns[[".package"]][["version"]]
[13:17:29.631]                           if (is.null(version)) 
[13:17:29.631]                             version <- utils::packageVersion("future")
[13:17:29.631]                         }
[13:17:29.631]                         else {
[13:17:29.631]                           version <- NULL
[13:17:29.631]                         }
[13:17:29.631]                         if (!has_future || version < "1.8.0") {
[13:17:29.631]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.631]                             "", base::R.version$version.string), 
[13:17:29.631]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.631]                               "release", "version")], collapse = " "), 
[13:17:29.631]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.631]                             info)
[13:17:29.631]                           info <- base::paste(info, collapse = "; ")
[13:17:29.631]                           if (!has_future) {
[13:17:29.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.631]                               info)
[13:17:29.631]                           }
[13:17:29.631]                           else {
[13:17:29.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.631]                               info, version)
[13:17:29.631]                           }
[13:17:29.631]                           base::stop(msg)
[13:17:29.631]                         }
[13:17:29.631]                       })
[13:17:29.631]                     }
[13:17:29.631]                     base::local({
[13:17:29.631]                       for (pkg in "stats") {
[13:17:29.631]                         base::loadNamespace(pkg)
[13:17:29.631]                         base::library(pkg, character.only = TRUE)
[13:17:29.631]                       }
[13:17:29.631]                     })
[13:17:29.631]                   }
[13:17:29.631]                   options(future.plan = NULL)
[13:17:29.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.631]                 }
[13:17:29.631]                 ...future.workdir <- getwd()
[13:17:29.631]             }
[13:17:29.631]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.631]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.631]         }
[13:17:29.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.631]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.631]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.631]             base::names(...future.oldOptions))
[13:17:29.631]     }
[13:17:29.631]     if (FALSE) {
[13:17:29.631]     }
[13:17:29.631]     else {
[13:17:29.631]         if (TRUE) {
[13:17:29.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.631]                 open = "w")
[13:17:29.631]         }
[13:17:29.631]         else {
[13:17:29.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.631]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.631]         }
[13:17:29.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.631]             base::sink(type = "output", split = FALSE)
[13:17:29.631]             base::close(...future.stdout)
[13:17:29.631]         }, add = TRUE)
[13:17:29.631]     }
[13:17:29.631]     ...future.frame <- base::sys.nframe()
[13:17:29.631]     ...future.conditions <- base::list()
[13:17:29.631]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.631]     if (FALSE) {
[13:17:29.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.631]     }
[13:17:29.631]     ...future.result <- base::tryCatch({
[13:17:29.631]         base::withCallingHandlers({
[13:17:29.631]             ...future.value <- base::withVisible(base::local({
[13:17:29.631]                 do.call(function(...) {
[13:17:29.631]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.631]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.631]                     ...future.globals.maxSize)) {
[13:17:29.631]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.631]                     on.exit(options(oopts), add = TRUE)
[13:17:29.631]                   }
[13:17:29.631]                   {
[13:17:29.631]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.631]                       FUN = function(jj) {
[13:17:29.631]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.631]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.631]                       })
[13:17:29.631]                   }
[13:17:29.631]                 }, args = future.call.arguments)
[13:17:29.631]             }))
[13:17:29.631]             future::FutureResult(value = ...future.value$value, 
[13:17:29.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.631]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.631]                     ...future.globalenv.names))
[13:17:29.631]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.631]         }, condition = base::local({
[13:17:29.631]             c <- base::c
[13:17:29.631]             inherits <- base::inherits
[13:17:29.631]             invokeRestart <- base::invokeRestart
[13:17:29.631]             length <- base::length
[13:17:29.631]             list <- base::list
[13:17:29.631]             seq.int <- base::seq.int
[13:17:29.631]             signalCondition <- base::signalCondition
[13:17:29.631]             sys.calls <- base::sys.calls
[13:17:29.631]             `[[` <- base::`[[`
[13:17:29.631]             `+` <- base::`+`
[13:17:29.631]             `<<-` <- base::`<<-`
[13:17:29.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.631]                   3L)]
[13:17:29.631]             }
[13:17:29.631]             function(cond) {
[13:17:29.631]                 is_error <- inherits(cond, "error")
[13:17:29.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.631]                   NULL)
[13:17:29.631]                 if (is_error) {
[13:17:29.631]                   sessionInformation <- function() {
[13:17:29.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.631]                       search = base::search(), system = base::Sys.info())
[13:17:29.631]                   }
[13:17:29.631]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.631]                     cond$call), session = sessionInformation(), 
[13:17:29.631]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.631]                   signalCondition(cond)
[13:17:29.631]                 }
[13:17:29.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.631]                 "immediateCondition"))) {
[13:17:29.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.631]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.631]                   if (TRUE && !signal) {
[13:17:29.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.631]                     {
[13:17:29.631]                       inherits <- base::inherits
[13:17:29.631]                       invokeRestart <- base::invokeRestart
[13:17:29.631]                       is.null <- base::is.null
[13:17:29.631]                       muffled <- FALSE
[13:17:29.631]                       if (inherits(cond, "message")) {
[13:17:29.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.631]                         if (muffled) 
[13:17:29.631]                           invokeRestart("muffleMessage")
[13:17:29.631]                       }
[13:17:29.631]                       else if (inherits(cond, "warning")) {
[13:17:29.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.631]                         if (muffled) 
[13:17:29.631]                           invokeRestart("muffleWarning")
[13:17:29.631]                       }
[13:17:29.631]                       else if (inherits(cond, "condition")) {
[13:17:29.631]                         if (!is.null(pattern)) {
[13:17:29.631]                           computeRestarts <- base::computeRestarts
[13:17:29.631]                           grepl <- base::grepl
[13:17:29.631]                           restarts <- computeRestarts(cond)
[13:17:29.631]                           for (restart in restarts) {
[13:17:29.631]                             name <- restart$name
[13:17:29.631]                             if (is.null(name)) 
[13:17:29.631]                               next
[13:17:29.631]                             if (!grepl(pattern, name)) 
[13:17:29.631]                               next
[13:17:29.631]                             invokeRestart(restart)
[13:17:29.631]                             muffled <- TRUE
[13:17:29.631]                             break
[13:17:29.631]                           }
[13:17:29.631]                         }
[13:17:29.631]                       }
[13:17:29.631]                       invisible(muffled)
[13:17:29.631]                     }
[13:17:29.631]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.631]                   }
[13:17:29.631]                 }
[13:17:29.631]                 else {
[13:17:29.631]                   if (TRUE) {
[13:17:29.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.631]                     {
[13:17:29.631]                       inherits <- base::inherits
[13:17:29.631]                       invokeRestart <- base::invokeRestart
[13:17:29.631]                       is.null <- base::is.null
[13:17:29.631]                       muffled <- FALSE
[13:17:29.631]                       if (inherits(cond, "message")) {
[13:17:29.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.631]                         if (muffled) 
[13:17:29.631]                           invokeRestart("muffleMessage")
[13:17:29.631]                       }
[13:17:29.631]                       else if (inherits(cond, "warning")) {
[13:17:29.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.631]                         if (muffled) 
[13:17:29.631]                           invokeRestart("muffleWarning")
[13:17:29.631]                       }
[13:17:29.631]                       else if (inherits(cond, "condition")) {
[13:17:29.631]                         if (!is.null(pattern)) {
[13:17:29.631]                           computeRestarts <- base::computeRestarts
[13:17:29.631]                           grepl <- base::grepl
[13:17:29.631]                           restarts <- computeRestarts(cond)
[13:17:29.631]                           for (restart in restarts) {
[13:17:29.631]                             name <- restart$name
[13:17:29.631]                             if (is.null(name)) 
[13:17:29.631]                               next
[13:17:29.631]                             if (!grepl(pattern, name)) 
[13:17:29.631]                               next
[13:17:29.631]                             invokeRestart(restart)
[13:17:29.631]                             muffled <- TRUE
[13:17:29.631]                             break
[13:17:29.631]                           }
[13:17:29.631]                         }
[13:17:29.631]                       }
[13:17:29.631]                       invisible(muffled)
[13:17:29.631]                     }
[13:17:29.631]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.631]                   }
[13:17:29.631]                 }
[13:17:29.631]             }
[13:17:29.631]         }))
[13:17:29.631]     }, error = function(ex) {
[13:17:29.631]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.631]                 ...future.rng), started = ...future.startTime, 
[13:17:29.631]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.631]             version = "1.8"), class = "FutureResult")
[13:17:29.631]     }, finally = {
[13:17:29.631]         if (!identical(...future.workdir, getwd())) 
[13:17:29.631]             setwd(...future.workdir)
[13:17:29.631]         {
[13:17:29.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.631]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.631]             }
[13:17:29.631]             base::options(...future.oldOptions)
[13:17:29.631]             if (.Platform$OS.type == "windows") {
[13:17:29.631]                 old_names <- names(...future.oldEnvVars)
[13:17:29.631]                 envs <- base::Sys.getenv()
[13:17:29.631]                 names <- names(envs)
[13:17:29.631]                 common <- intersect(names, old_names)
[13:17:29.631]                 added <- setdiff(names, old_names)
[13:17:29.631]                 removed <- setdiff(old_names, names)
[13:17:29.631]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.631]                   envs[common]]
[13:17:29.631]                 NAMES <- toupper(changed)
[13:17:29.631]                 args <- list()
[13:17:29.631]                 for (kk in seq_along(NAMES)) {
[13:17:29.631]                   name <- changed[[kk]]
[13:17:29.631]                   NAME <- NAMES[[kk]]
[13:17:29.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.631]                     next
[13:17:29.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.631]                 }
[13:17:29.631]                 NAMES <- toupper(added)
[13:17:29.631]                 for (kk in seq_along(NAMES)) {
[13:17:29.631]                   name <- added[[kk]]
[13:17:29.631]                   NAME <- NAMES[[kk]]
[13:17:29.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.631]                     next
[13:17:29.631]                   args[[name]] <- ""
[13:17:29.631]                 }
[13:17:29.631]                 NAMES <- toupper(removed)
[13:17:29.631]                 for (kk in seq_along(NAMES)) {
[13:17:29.631]                   name <- removed[[kk]]
[13:17:29.631]                   NAME <- NAMES[[kk]]
[13:17:29.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.631]                     next
[13:17:29.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.631]                 }
[13:17:29.631]                 if (length(args) > 0) 
[13:17:29.631]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.631]             }
[13:17:29.631]             else {
[13:17:29.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.631]             }
[13:17:29.631]             {
[13:17:29.631]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.631]                   0L) {
[13:17:29.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.631]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.631]                   base::options(opts)
[13:17:29.631]                 }
[13:17:29.631]                 {
[13:17:29.631]                   {
[13:17:29.631]                     NULL
[13:17:29.631]                     RNGkind("Mersenne-Twister")
[13:17:29.631]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.631]                       inherits = FALSE)
[13:17:29.631]                   }
[13:17:29.631]                   options(future.plan = NULL)
[13:17:29.631]                   if (is.na(NA_character_)) 
[13:17:29.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.631]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:29.631]                   {
[13:17:29.631]                     future <- SequentialFuture(..., envir = envir)
[13:17:29.631]                     if (!future$lazy) 
[13:17:29.631]                       future <- run(future)
[13:17:29.631]                     invisible(future)
[13:17:29.631]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.631]                 }
[13:17:29.631]             }
[13:17:29.631]         }
[13:17:29.631]     })
[13:17:29.631]     if (TRUE) {
[13:17:29.631]         base::sink(type = "output", split = FALSE)
[13:17:29.631]         if (TRUE) {
[13:17:29.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.631]         }
[13:17:29.631]         else {
[13:17:29.631]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.631]         }
[13:17:29.631]         base::close(...future.stdout)
[13:17:29.631]         ...future.stdout <- NULL
[13:17:29.631]     }
[13:17:29.631]     ...future.result$conditions <- ...future.conditions
[13:17:29.631]     ...future.result$finished <- base::Sys.time()
[13:17:29.631]     ...future.result
[13:17:29.631] }
[13:17:29.633] assign_globals() ...
[13:17:29.633] List of 5
[13:17:29.633]  $ ...future.FUN            :function (x, ...)  
[13:17:29.633]  $ future.call.arguments    :List of 1
[13:17:29.633]   ..$ singular.ok: logi FALSE
[13:17:29.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.633]  $ ...future.elements_ii    :List of 3
[13:17:29.633]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.633]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.633]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.633]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.633]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.633]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.633]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.633]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.633]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.633]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.633]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.633]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.633]  $ ...future.seeds_ii       : NULL
[13:17:29.633]  $ ...future.globals.maxSize: NULL
[13:17:29.633]  - attr(*, "resolved")= logi FALSE
[13:17:29.633]  - attr(*, "total_size")= num 5384
[13:17:29.633]  - attr(*, "where")=List of 5
[13:17:29.633]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.633]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.633]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.633]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.633]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.633]  - attr(*, "already-done")= logi TRUE
[13:17:29.642] - reassign environment for ‘...future.FUN’
[13:17:29.643] - copied ‘...future.FUN’ to environment
[13:17:29.643] - copied ‘future.call.arguments’ to environment
[13:17:29.643] - copied ‘...future.elements_ii’ to environment
[13:17:29.643] - copied ‘...future.seeds_ii’ to environment
[13:17:29.643] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.643] assign_globals() ... done
[13:17:29.643] plan(): Setting new future strategy stack:
[13:17:29.644] List of future strategies:
[13:17:29.644] 1. sequential:
[13:17:29.644]    - args: function (..., envir = parent.frame())
[13:17:29.644]    - tweaked: FALSE
[13:17:29.644]    - call: NULL
[13:17:29.644] plan(): nbrOfWorkers() = 1
[13:17:29.647] plan(): Setting new future strategy stack:
[13:17:29.647] List of future strategies:
[13:17:29.647] 1. sequential:
[13:17:29.647]    - args: function (..., envir = parent.frame())
[13:17:29.647]    - tweaked: FALSE
[13:17:29.647]    - call: plan(strategy)
[13:17:29.647] plan(): nbrOfWorkers() = 1
[13:17:29.647] SequentialFuture started (and completed)
[13:17:29.647] - Launch lazy future ... done
[13:17:29.648] run() for ‘SequentialFuture’ ... done
[13:17:29.648] Created future:
[13:17:29.648] SequentialFuture:
[13:17:29.648] Label: ‘future_by-1’
[13:17:29.648] Expression:
[13:17:29.648] {
[13:17:29.648]     do.call(function(...) {
[13:17:29.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.648]             on.exit(options(oopts), add = TRUE)
[13:17:29.648]         }
[13:17:29.648]         {
[13:17:29.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.648]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.648]             })
[13:17:29.648]         }
[13:17:29.648]     }, args = future.call.arguments)
[13:17:29.648] }
[13:17:29.648] Lazy evaluation: FALSE
[13:17:29.648] Asynchronous evaluation: FALSE
[13:17:29.648] Local evaluation: TRUE
[13:17:29.648] Environment: R_GlobalEnv
[13:17:29.648] Capture standard output: TRUE
[13:17:29.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.648] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.648] Packages: 1 packages (‘stats’)
[13:17:29.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.648] Resolved: TRUE
[13:17:29.648] Value: 26.06 KiB of class ‘list’
[13:17:29.648] Early signaling: FALSE
[13:17:29.648] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.648] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.649] Chunk #1 of 1 ... DONE
[13:17:29.649] Launching 1 futures (chunks) ... DONE
[13:17:29.650] Resolving 1 futures (chunks) ...
[13:17:29.650] resolve() on list ...
[13:17:29.650]  recursive: 0
[13:17:29.650]  length: 1
[13:17:29.650] 
[13:17:29.650] resolved() for ‘SequentialFuture’ ...
[13:17:29.650] - state: ‘finished’
[13:17:29.650] - run: TRUE
[13:17:29.650] - result: ‘FutureResult’
[13:17:29.650] resolved() for ‘SequentialFuture’ ... done
[13:17:29.651] Future #1
[13:17:29.651] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.651] - nx: 1
[13:17:29.651] - relay: TRUE
[13:17:29.651] - stdout: TRUE
[13:17:29.651] - signal: TRUE
[13:17:29.651] - resignal: FALSE
[13:17:29.651] - force: TRUE
[13:17:29.653] - relayed: [n=1] FALSE
[13:17:29.653] - queued futures: [n=1] FALSE
[13:17:29.653]  - until=1
[13:17:29.653]  - relaying element #1
[13:17:29.653] - relayed: [n=1] TRUE
[13:17:29.653] - queued futures: [n=1] TRUE
[13:17:29.654] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.654]  length: 0 (resolved future 1)
[13:17:29.654] Relaying remaining futures
[13:17:29.654] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.654] - nx: 1
[13:17:29.654] - relay: TRUE
[13:17:29.654] - stdout: TRUE
[13:17:29.654] - signal: TRUE
[13:17:29.654] - resignal: FALSE
[13:17:29.654] - force: TRUE
[13:17:29.654] - relayed: [n=1] TRUE
[13:17:29.655] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.655] - relayed: [n=1] TRUE
[13:17:29.655] - queued futures: [n=1] TRUE
[13:17:29.655] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.655] resolve() on list ... DONE
[13:17:29.655]  - Number of value chunks collected: 1
[13:17:29.655] Resolving 1 futures (chunks) ... DONE
[13:17:29.655] Reducing values from 1 chunks ...
[13:17:29.656]  - Number of values collected after concatenation: 3
[13:17:29.656]  - Number of values expected: 3
[13:17:29.656] Reducing values from 1 chunks ... DONE
[13:17:29.656] future_lapply() ... DONE
[13:17:29.656] future_by_internal() ... DONE
[13:17:29.661] future_by_internal() ...
[13:17:29.661] future_lapply() ...
[13:17:29.662] Number of chunks: 1
[13:17:29.662] getGlobalsAndPackagesXApply() ...
[13:17:29.662]  - future.globals: TRUE
[13:17:29.662] getGlobalsAndPackages() ...
[13:17:29.662] Searching for globals...
[13:17:29.664] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:29.664] Searching for globals ... DONE
[13:17:29.664] Resolving globals: FALSE
[13:17:29.664] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:17:29.665] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:17:29.665] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:29.665] - packages: [1] ‘stats’
[13:17:29.665] getGlobalsAndPackages() ... DONE
[13:17:29.665]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:29.665]  - needed namespaces: [n=1] ‘stats’
[13:17:29.666] Finding globals ... DONE
[13:17:29.666]  - use_args: TRUE
[13:17:29.666]  - Getting '...' globals ...
[13:17:29.666] resolve() on list ...
[13:17:29.666]  recursive: 0
[13:17:29.666]  length: 1
[13:17:29.666]  elements: ‘...’
[13:17:29.666]  length: 0 (resolved future 1)
[13:17:29.667] resolve() on list ... DONE
[13:17:29.667]    - '...' content: [n=0] 
[13:17:29.667] List of 1
[13:17:29.667]  $ ...: list()
[13:17:29.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.667]  - attr(*, "where")=List of 1
[13:17:29.667]   ..$ ...:<environment: 0x5609e85cc458> 
[13:17:29.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.667]  - attr(*, "resolved")= logi TRUE
[13:17:29.667]  - attr(*, "total_size")= num NA
[13:17:29.669]  - Getting '...' globals ... DONE
[13:17:29.669] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:17:29.670] List of 4
[13:17:29.670]  $ ...future.FUN:function (x)  
[13:17:29.670]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:29.670]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.670]  $ ...          : list()
[13:17:29.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.670]  - attr(*, "where")=List of 4
[13:17:29.670]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.670]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:17:29.670]   ..$ wool         :<environment: R_EmptyEnv> 
[13:17:29.670]   ..$ ...          :<environment: 0x5609e85cc458> 
[13:17:29.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.670]  - attr(*, "resolved")= logi FALSE
[13:17:29.670]  - attr(*, "total_size")= num 2320
[13:17:29.675] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:29.676] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.676] Number of futures (= number of chunks): 1
[13:17:29.676] Launching 1 futures (chunks) ...
[13:17:29.676] Chunk #1 of 1 ...
[13:17:29.676]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.676] getGlobalsAndPackages() ...
[13:17:29.676] Searching for globals...
[13:17:29.677] 
[13:17:29.677] Searching for globals ... DONE
[13:17:29.677] - globals: [0] <none>
[13:17:29.677] getGlobalsAndPackages() ... DONE
[13:17:29.677]    + additional globals found: [n=0] 
[13:17:29.677]    + additional namespaces needed: [n=0] 
[13:17:29.677]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.678]  - seeds: <none>
[13:17:29.678] getGlobalsAndPackages() ...
[13:17:29.678] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.678] Resolving globals: FALSE
[13:17:29.678] Tweak future expression to call with '...' arguments ...
[13:17:29.678] {
[13:17:29.678]     do.call(function(...) {
[13:17:29.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.678]             on.exit(options(oopts), add = TRUE)
[13:17:29.678]         }
[13:17:29.678]         {
[13:17:29.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.678]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.678]             })
[13:17:29.678]         }
[13:17:29.678]     }, args = future.call.arguments)
[13:17:29.678] }
[13:17:29.678] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.679] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.679] 
[13:17:29.679] getGlobalsAndPackages() ... DONE
[13:17:29.679] run() for ‘Future’ ...
[13:17:29.679] - state: ‘created’
[13:17:29.680] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:29.680] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.680]   - Field: ‘label’
[13:17:29.680]   - Field: ‘local’
[13:17:29.680]   - Field: ‘owner’
[13:17:29.680]   - Field: ‘envir’
[13:17:29.681]   - Field: ‘packages’
[13:17:29.681]   - Field: ‘gc’
[13:17:29.681]   - Field: ‘conditions’
[13:17:29.681]   - Field: ‘expr’
[13:17:29.681]   - Field: ‘uuid’
[13:17:29.681]   - Field: ‘seed’
[13:17:29.681]   - Field: ‘version’
[13:17:29.681]   - Field: ‘result’
[13:17:29.681]   - Field: ‘asynchronous’
[13:17:29.681]   - Field: ‘calls’
[13:17:29.681]   - Field: ‘globals’
[13:17:29.682]   - Field: ‘stdout’
[13:17:29.682]   - Field: ‘earlySignal’
[13:17:29.682]   - Field: ‘lazy’
[13:17:29.682]   - Field: ‘state’
[13:17:29.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.682] - Launch lazy future ...
[13:17:29.682] Packages needed by the future expression (n = 1): ‘stats’
[13:17:29.682] Packages needed by future strategies (n = 0): <none>
[13:17:29.683] {
[13:17:29.683]     {
[13:17:29.683]         {
[13:17:29.683]             ...future.startTime <- base::Sys.time()
[13:17:29.683]             {
[13:17:29.683]                 {
[13:17:29.683]                   {
[13:17:29.683]                     {
[13:17:29.683]                       base::local({
[13:17:29.683]                         has_future <- base::requireNamespace("future", 
[13:17:29.683]                           quietly = TRUE)
[13:17:29.683]                         if (has_future) {
[13:17:29.683]                           ns <- base::getNamespace("future")
[13:17:29.683]                           version <- ns[[".package"]][["version"]]
[13:17:29.683]                           if (is.null(version)) 
[13:17:29.683]                             version <- utils::packageVersion("future")
[13:17:29.683]                         }
[13:17:29.683]                         else {
[13:17:29.683]                           version <- NULL
[13:17:29.683]                         }
[13:17:29.683]                         if (!has_future || version < "1.8.0") {
[13:17:29.683]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.683]                             "", base::R.version$version.string), 
[13:17:29.683]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.683]                               "release", "version")], collapse = " "), 
[13:17:29.683]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.683]                             info)
[13:17:29.683]                           info <- base::paste(info, collapse = "; ")
[13:17:29.683]                           if (!has_future) {
[13:17:29.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.683]                               info)
[13:17:29.683]                           }
[13:17:29.683]                           else {
[13:17:29.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.683]                               info, version)
[13:17:29.683]                           }
[13:17:29.683]                           base::stop(msg)
[13:17:29.683]                         }
[13:17:29.683]                       })
[13:17:29.683]                     }
[13:17:29.683]                     base::local({
[13:17:29.683]                       for (pkg in "stats") {
[13:17:29.683]                         base::loadNamespace(pkg)
[13:17:29.683]                         base::library(pkg, character.only = TRUE)
[13:17:29.683]                       }
[13:17:29.683]                     })
[13:17:29.683]                   }
[13:17:29.683]                   options(future.plan = NULL)
[13:17:29.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.683]                 }
[13:17:29.683]                 ...future.workdir <- getwd()
[13:17:29.683]             }
[13:17:29.683]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.683]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.683]         }
[13:17:29.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.683]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.683]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.683]             base::names(...future.oldOptions))
[13:17:29.683]     }
[13:17:29.683]     if (FALSE) {
[13:17:29.683]     }
[13:17:29.683]     else {
[13:17:29.683]         if (TRUE) {
[13:17:29.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.683]                 open = "w")
[13:17:29.683]         }
[13:17:29.683]         else {
[13:17:29.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.683]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.683]         }
[13:17:29.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.683]             base::sink(type = "output", split = FALSE)
[13:17:29.683]             base::close(...future.stdout)
[13:17:29.683]         }, add = TRUE)
[13:17:29.683]     }
[13:17:29.683]     ...future.frame <- base::sys.nframe()
[13:17:29.683]     ...future.conditions <- base::list()
[13:17:29.683]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.683]     if (FALSE) {
[13:17:29.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.683]     }
[13:17:29.683]     ...future.result <- base::tryCatch({
[13:17:29.683]         base::withCallingHandlers({
[13:17:29.683]             ...future.value <- base::withVisible(base::local({
[13:17:29.683]                 do.call(function(...) {
[13:17:29.683]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.683]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.683]                     ...future.globals.maxSize)) {
[13:17:29.683]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.683]                     on.exit(options(oopts), add = TRUE)
[13:17:29.683]                   }
[13:17:29.683]                   {
[13:17:29.683]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.683]                       FUN = function(jj) {
[13:17:29.683]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.683]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.683]                       })
[13:17:29.683]                   }
[13:17:29.683]                 }, args = future.call.arguments)
[13:17:29.683]             }))
[13:17:29.683]             future::FutureResult(value = ...future.value$value, 
[13:17:29.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.683]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.683]                     ...future.globalenv.names))
[13:17:29.683]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.683]         }, condition = base::local({
[13:17:29.683]             c <- base::c
[13:17:29.683]             inherits <- base::inherits
[13:17:29.683]             invokeRestart <- base::invokeRestart
[13:17:29.683]             length <- base::length
[13:17:29.683]             list <- base::list
[13:17:29.683]             seq.int <- base::seq.int
[13:17:29.683]             signalCondition <- base::signalCondition
[13:17:29.683]             sys.calls <- base::sys.calls
[13:17:29.683]             `[[` <- base::`[[`
[13:17:29.683]             `+` <- base::`+`
[13:17:29.683]             `<<-` <- base::`<<-`
[13:17:29.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.683]                   3L)]
[13:17:29.683]             }
[13:17:29.683]             function(cond) {
[13:17:29.683]                 is_error <- inherits(cond, "error")
[13:17:29.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.683]                   NULL)
[13:17:29.683]                 if (is_error) {
[13:17:29.683]                   sessionInformation <- function() {
[13:17:29.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.683]                       search = base::search(), system = base::Sys.info())
[13:17:29.683]                   }
[13:17:29.683]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.683]                     cond$call), session = sessionInformation(), 
[13:17:29.683]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.683]                   signalCondition(cond)
[13:17:29.683]                 }
[13:17:29.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.683]                 "immediateCondition"))) {
[13:17:29.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.683]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.683]                   if (TRUE && !signal) {
[13:17:29.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.683]                     {
[13:17:29.683]                       inherits <- base::inherits
[13:17:29.683]                       invokeRestart <- base::invokeRestart
[13:17:29.683]                       is.null <- base::is.null
[13:17:29.683]                       muffled <- FALSE
[13:17:29.683]                       if (inherits(cond, "message")) {
[13:17:29.683]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.683]                         if (muffled) 
[13:17:29.683]                           invokeRestart("muffleMessage")
[13:17:29.683]                       }
[13:17:29.683]                       else if (inherits(cond, "warning")) {
[13:17:29.683]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.683]                         if (muffled) 
[13:17:29.683]                           invokeRestart("muffleWarning")
[13:17:29.683]                       }
[13:17:29.683]                       else if (inherits(cond, "condition")) {
[13:17:29.683]                         if (!is.null(pattern)) {
[13:17:29.683]                           computeRestarts <- base::computeRestarts
[13:17:29.683]                           grepl <- base::grepl
[13:17:29.683]                           restarts <- computeRestarts(cond)
[13:17:29.683]                           for (restart in restarts) {
[13:17:29.683]                             name <- restart$name
[13:17:29.683]                             if (is.null(name)) 
[13:17:29.683]                               next
[13:17:29.683]                             if (!grepl(pattern, name)) 
[13:17:29.683]                               next
[13:17:29.683]                             invokeRestart(restart)
[13:17:29.683]                             muffled <- TRUE
[13:17:29.683]                             break
[13:17:29.683]                           }
[13:17:29.683]                         }
[13:17:29.683]                       }
[13:17:29.683]                       invisible(muffled)
[13:17:29.683]                     }
[13:17:29.683]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.683]                   }
[13:17:29.683]                 }
[13:17:29.683]                 else {
[13:17:29.683]                   if (TRUE) {
[13:17:29.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.683]                     {
[13:17:29.683]                       inherits <- base::inherits
[13:17:29.683]                       invokeRestart <- base::invokeRestart
[13:17:29.683]                       is.null <- base::is.null
[13:17:29.683]                       muffled <- FALSE
[13:17:29.683]                       if (inherits(cond, "message")) {
[13:17:29.683]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.683]                         if (muffled) 
[13:17:29.683]                           invokeRestart("muffleMessage")
[13:17:29.683]                       }
[13:17:29.683]                       else if (inherits(cond, "warning")) {
[13:17:29.683]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.683]                         if (muffled) 
[13:17:29.683]                           invokeRestart("muffleWarning")
[13:17:29.683]                       }
[13:17:29.683]                       else if (inherits(cond, "condition")) {
[13:17:29.683]                         if (!is.null(pattern)) {
[13:17:29.683]                           computeRestarts <- base::computeRestarts
[13:17:29.683]                           grepl <- base::grepl
[13:17:29.683]                           restarts <- computeRestarts(cond)
[13:17:29.683]                           for (restart in restarts) {
[13:17:29.683]                             name <- restart$name
[13:17:29.683]                             if (is.null(name)) 
[13:17:29.683]                               next
[13:17:29.683]                             if (!grepl(pattern, name)) 
[13:17:29.683]                               next
[13:17:29.683]                             invokeRestart(restart)
[13:17:29.683]                             muffled <- TRUE
[13:17:29.683]                             break
[13:17:29.683]                           }
[13:17:29.683]                         }
[13:17:29.683]                       }
[13:17:29.683]                       invisible(muffled)
[13:17:29.683]                     }
[13:17:29.683]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.683]                   }
[13:17:29.683]                 }
[13:17:29.683]             }
[13:17:29.683]         }))
[13:17:29.683]     }, error = function(ex) {
[13:17:29.683]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.683]                 ...future.rng), started = ...future.startTime, 
[13:17:29.683]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.683]             version = "1.8"), class = "FutureResult")
[13:17:29.683]     }, finally = {
[13:17:29.683]         if (!identical(...future.workdir, getwd())) 
[13:17:29.683]             setwd(...future.workdir)
[13:17:29.683]         {
[13:17:29.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.683]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.683]             }
[13:17:29.683]             base::options(...future.oldOptions)
[13:17:29.683]             if (.Platform$OS.type == "windows") {
[13:17:29.683]                 old_names <- names(...future.oldEnvVars)
[13:17:29.683]                 envs <- base::Sys.getenv()
[13:17:29.683]                 names <- names(envs)
[13:17:29.683]                 common <- intersect(names, old_names)
[13:17:29.683]                 added <- setdiff(names, old_names)
[13:17:29.683]                 removed <- setdiff(old_names, names)
[13:17:29.683]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.683]                   envs[common]]
[13:17:29.683]                 NAMES <- toupper(changed)
[13:17:29.683]                 args <- list()
[13:17:29.683]                 for (kk in seq_along(NAMES)) {
[13:17:29.683]                   name <- changed[[kk]]
[13:17:29.683]                   NAME <- NAMES[[kk]]
[13:17:29.683]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.683]                     next
[13:17:29.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.683]                 }
[13:17:29.683]                 NAMES <- toupper(added)
[13:17:29.683]                 for (kk in seq_along(NAMES)) {
[13:17:29.683]                   name <- added[[kk]]
[13:17:29.683]                   NAME <- NAMES[[kk]]
[13:17:29.683]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.683]                     next
[13:17:29.683]                   args[[name]] <- ""
[13:17:29.683]                 }
[13:17:29.683]                 NAMES <- toupper(removed)
[13:17:29.683]                 for (kk in seq_along(NAMES)) {
[13:17:29.683]                   name <- removed[[kk]]
[13:17:29.683]                   NAME <- NAMES[[kk]]
[13:17:29.683]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.683]                     next
[13:17:29.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.683]                 }
[13:17:29.683]                 if (length(args) > 0) 
[13:17:29.683]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.683]             }
[13:17:29.683]             else {
[13:17:29.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.683]             }
[13:17:29.683]             {
[13:17:29.683]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.683]                   0L) {
[13:17:29.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.683]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.683]                   base::options(opts)
[13:17:29.683]                 }
[13:17:29.683]                 {
[13:17:29.683]                   {
[13:17:29.683]                     NULL
[13:17:29.683]                     RNGkind("Mersenne-Twister")
[13:17:29.683]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.683]                       inherits = FALSE)
[13:17:29.683]                   }
[13:17:29.683]                   options(future.plan = NULL)
[13:17:29.683]                   if (is.na(NA_character_)) 
[13:17:29.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.683]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:29.683]                   {
[13:17:29.683]                     future <- SequentialFuture(..., envir = envir)
[13:17:29.683]                     if (!future$lazy) 
[13:17:29.683]                       future <- run(future)
[13:17:29.683]                     invisible(future)
[13:17:29.683]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.683]                 }
[13:17:29.683]             }
[13:17:29.683]         }
[13:17:29.683]     })
[13:17:29.683]     if (TRUE) {
[13:17:29.683]         base::sink(type = "output", split = FALSE)
[13:17:29.683]         if (TRUE) {
[13:17:29.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.683]         }
[13:17:29.683]         else {
[13:17:29.683]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.683]         }
[13:17:29.683]         base::close(...future.stdout)
[13:17:29.683]         ...future.stdout <- NULL
[13:17:29.683]     }
[13:17:29.683]     ...future.result$conditions <- ...future.conditions
[13:17:29.683]     ...future.result$finished <- base::Sys.time()
[13:17:29.683]     ...future.result
[13:17:29.683] }
[13:17:29.685] assign_globals() ...
[13:17:29.685] List of 7
[13:17:29.685]  $ ...future.FUN            :function (x)  
[13:17:29.685]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:29.685]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.685]  $ future.call.arguments    : list()
[13:17:29.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.685]  $ ...future.elements_ii    :List of 3
[13:17:29.685]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.685]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.685]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.685]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.685]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.685]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.685]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.685]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.685]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.685]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.685]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.685]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.685]  $ ...future.seeds_ii       : NULL
[13:17:29.685]  $ ...future.globals.maxSize: NULL
[13:17:29.685]  - attr(*, "resolved")= logi FALSE
[13:17:29.685]  - attr(*, "total_size")= num 2320
[13:17:29.685]  - attr(*, "where")=List of 7
[13:17:29.685]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.685]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:17:29.685]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:17:29.685]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.685]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.685]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.685]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.685]  - attr(*, "already-done")= logi TRUE
[13:17:29.696] - reassign environment for ‘...future.FUN’
[13:17:29.696] - copied ‘...future.FUN’ to environment
[13:17:29.696] - copied ‘breaks’ to environment
[13:17:29.696] - copied ‘wool’ to environment
[13:17:29.696] - copied ‘future.call.arguments’ to environment
[13:17:29.696] - copied ‘...future.elements_ii’ to environment
[13:17:29.697] - copied ‘...future.seeds_ii’ to environment
[13:17:29.697] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.697] assign_globals() ... done
[13:17:29.697] plan(): Setting new future strategy stack:
[13:17:29.698] List of future strategies:
[13:17:29.698] 1. sequential:
[13:17:29.698]    - args: function (..., envir = parent.frame())
[13:17:29.698]    - tweaked: FALSE
[13:17:29.698]    - call: NULL
[13:17:29.698] plan(): nbrOfWorkers() = 1
[13:17:29.702] plan(): Setting new future strategy stack:
[13:17:29.702] List of future strategies:
[13:17:29.702] 1. sequential:
[13:17:29.702]    - args: function (..., envir = parent.frame())
[13:17:29.702]    - tweaked: FALSE
[13:17:29.702]    - call: plan(strategy)
[13:17:29.703] plan(): nbrOfWorkers() = 1
[13:17:29.703] SequentialFuture started (and completed)
[13:17:29.703] - Launch lazy future ... done
[13:17:29.704] run() for ‘SequentialFuture’ ... done
[13:17:29.704] Created future:
[13:17:29.704] SequentialFuture:
[13:17:29.704] Label: ‘future_by-1’
[13:17:29.704] Expression:
[13:17:29.704] {
[13:17:29.704]     do.call(function(...) {
[13:17:29.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.704]             on.exit(options(oopts), add = TRUE)
[13:17:29.704]         }
[13:17:29.704]         {
[13:17:29.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.704]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.704]             })
[13:17:29.704]         }
[13:17:29.704]     }, args = future.call.arguments)
[13:17:29.704] }
[13:17:29.704] Lazy evaluation: FALSE
[13:17:29.704] Asynchronous evaluation: FALSE
[13:17:29.704] Local evaluation: TRUE
[13:17:29.704] Environment: 0x5609e860c828
[13:17:29.704] Capture standard output: TRUE
[13:17:29.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.704] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:17:29.704] Packages: 1 packages (‘stats’)
[13:17:29.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.704] Resolved: TRUE
[13:17:29.704] Value: 25.57 KiB of class ‘list’
[13:17:29.704] Early signaling: FALSE
[13:17:29.704] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.704] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.706] Chunk #1 of 1 ... DONE
[13:17:29.706] Launching 1 futures (chunks) ... DONE
[13:17:29.706] Resolving 1 futures (chunks) ...
[13:17:29.707] resolve() on list ...
[13:17:29.707]  recursive: 0
[13:17:29.707]  length: 1
[13:17:29.707] 
[13:17:29.707] resolved() for ‘SequentialFuture’ ...
[13:17:29.707] - state: ‘finished’
[13:17:29.707] - run: TRUE
[13:17:29.707] - result: ‘FutureResult’
[13:17:29.707] resolved() for ‘SequentialFuture’ ... done
[13:17:29.708] Future #1
[13:17:29.708] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.708] - nx: 1
[13:17:29.708] - relay: TRUE
[13:17:29.708] - stdout: TRUE
[13:17:29.708] - signal: TRUE
[13:17:29.708] - resignal: FALSE
[13:17:29.708] - force: TRUE
[13:17:29.708] - relayed: [n=1] FALSE
[13:17:29.708] - queued futures: [n=1] FALSE
[13:17:29.709]  - until=1
[13:17:29.709]  - relaying element #1
[13:17:29.709] - relayed: [n=1] TRUE
[13:17:29.709] - queued futures: [n=1] TRUE
[13:17:29.709] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.709]  length: 0 (resolved future 1)
[13:17:29.710] Relaying remaining futures
[13:17:29.710] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.710] - nx: 1
[13:17:29.710] - relay: TRUE
[13:17:29.710] - stdout: TRUE
[13:17:29.710] - signal: TRUE
[13:17:29.710] - resignal: FALSE
[13:17:29.710] - force: TRUE
[13:17:29.710] - relayed: [n=1] TRUE
[13:17:29.710] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.711] - relayed: [n=1] TRUE
[13:17:29.711] - queued futures: [n=1] TRUE
[13:17:29.711] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.711] resolve() on list ... DONE
[13:17:29.711]  - Number of value chunks collected: 1
[13:17:29.711] Resolving 1 futures (chunks) ... DONE
[13:17:29.711] Reducing values from 1 chunks ...
[13:17:29.712]  - Number of values collected after concatenation: 3
[13:17:29.712]  - Number of values expected: 3
[13:17:29.712] Reducing values from 1 chunks ... DONE
[13:17:29.712] future_lapply() ... DONE
[13:17:29.712] future_by_internal() ... DONE
[13:17:29.713] future_by_internal() ...
[13:17:29.713] future_lapply() ...
[13:17:29.714] Number of chunks: 1
[13:17:29.714] getGlobalsAndPackagesXApply() ...
[13:17:29.714]  - future.globals: TRUE
[13:17:29.714] getGlobalsAndPackages() ...
[13:17:29.714] Searching for globals...
[13:17:29.716] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.716] Searching for globals ... DONE
[13:17:29.716] Resolving globals: FALSE
[13:17:29.716] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.717] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.717] - globals: [1] ‘FUN’
[13:17:29.717] 
[13:17:29.717] getGlobalsAndPackages() ... DONE
[13:17:29.717]  - globals found/used: [n=1] ‘FUN’
[13:17:29.717]  - needed namespaces: [n=0] 
[13:17:29.717] Finding globals ... DONE
[13:17:29.719]  - use_args: TRUE
[13:17:29.720]  - Getting '...' globals ...
[13:17:29.720] resolve() on list ...
[13:17:29.720]  recursive: 0
[13:17:29.720]  length: 1
[13:17:29.720]  elements: ‘...’
[13:17:29.721]  length: 0 (resolved future 1)
[13:17:29.721] resolve() on list ... DONE
[13:17:29.721]    - '...' content: [n=0] 
[13:17:29.721] List of 1
[13:17:29.721]  $ ...: list()
[13:17:29.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.721]  - attr(*, "where")=List of 1
[13:17:29.721]   ..$ ...:<environment: 0x5609ea5ca750> 
[13:17:29.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.721]  - attr(*, "resolved")= logi TRUE
[13:17:29.721]  - attr(*, "total_size")= num NA
[13:17:29.724]  - Getting '...' globals ... DONE
[13:17:29.725] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.725] List of 2
[13:17:29.725]  $ ...future.FUN:function (object, ...)  
[13:17:29.725]  $ ...          : list()
[13:17:29.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.725]  - attr(*, "where")=List of 2
[13:17:29.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.725]   ..$ ...          :<environment: 0x5609ea5ca750> 
[13:17:29.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.725]  - attr(*, "resolved")= logi FALSE
[13:17:29.725]  - attr(*, "total_size")= num 1240
[13:17:29.728] Packages to be attached in all futures: [n=0] 
[13:17:29.728] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.728] Number of futures (= number of chunks): 1
[13:17:29.728] Launching 1 futures (chunks) ...
[13:17:29.728] Chunk #1 of 1 ...
[13:17:29.728]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.728] getGlobalsAndPackages() ...
[13:17:29.728] Searching for globals...
[13:17:29.729] 
[13:17:29.729] Searching for globals ... DONE
[13:17:29.729] - globals: [0] <none>
[13:17:29.729] getGlobalsAndPackages() ... DONE
[13:17:29.729]    + additional globals found: [n=0] 
[13:17:29.729]    + additional namespaces needed: [n=0] 
[13:17:29.730]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.730]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.730]  - seeds: <none>
[13:17:29.730] getGlobalsAndPackages() ...
[13:17:29.730] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.730] Resolving globals: FALSE
[13:17:29.730] Tweak future expression to call with '...' arguments ...
[13:17:29.730] {
[13:17:29.730]     do.call(function(...) {
[13:17:29.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.730]             on.exit(options(oopts), add = TRUE)
[13:17:29.730]         }
[13:17:29.730]         {
[13:17:29.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.730]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.730]             })
[13:17:29.730]         }
[13:17:29.730]     }, args = future.call.arguments)
[13:17:29.730] }
[13:17:29.731] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.731] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.731] 
[13:17:29.731] getGlobalsAndPackages() ... DONE
[13:17:29.732] run() for ‘Future’ ...
[13:17:29.732] - state: ‘created’
[13:17:29.732] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:29.732] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.732]   - Field: ‘label’
[13:17:29.732]   - Field: ‘local’
[13:17:29.732]   - Field: ‘owner’
[13:17:29.733]   - Field: ‘envir’
[13:17:29.733]   - Field: ‘packages’
[13:17:29.733]   - Field: ‘gc’
[13:17:29.733]   - Field: ‘conditions’
[13:17:29.733]   - Field: ‘expr’
[13:17:29.733]   - Field: ‘uuid’
[13:17:29.733]   - Field: ‘seed’
[13:17:29.733]   - Field: ‘version’
[13:17:29.733]   - Field: ‘result’
[13:17:29.733]   - Field: ‘asynchronous’
[13:17:29.734]   - Field: ‘calls’
[13:17:29.734]   - Field: ‘globals’
[13:17:29.734]   - Field: ‘stdout’
[13:17:29.734]   - Field: ‘earlySignal’
[13:17:29.734]   - Field: ‘lazy’
[13:17:29.734]   - Field: ‘state’
[13:17:29.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.734] - Launch lazy future ...
[13:17:29.734] Packages needed by the future expression (n = 0): <none>
[13:17:29.735] Packages needed by future strategies (n = 0): <none>
[13:17:29.735] {
[13:17:29.735]     {
[13:17:29.735]         {
[13:17:29.735]             ...future.startTime <- base::Sys.time()
[13:17:29.735]             {
[13:17:29.735]                 {
[13:17:29.735]                   {
[13:17:29.735]                     base::local({
[13:17:29.735]                       has_future <- base::requireNamespace("future", 
[13:17:29.735]                         quietly = TRUE)
[13:17:29.735]                       if (has_future) {
[13:17:29.735]                         ns <- base::getNamespace("future")
[13:17:29.735]                         version <- ns[[".package"]][["version"]]
[13:17:29.735]                         if (is.null(version)) 
[13:17:29.735]                           version <- utils::packageVersion("future")
[13:17:29.735]                       }
[13:17:29.735]                       else {
[13:17:29.735]                         version <- NULL
[13:17:29.735]                       }
[13:17:29.735]                       if (!has_future || version < "1.8.0") {
[13:17:29.735]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.735]                           "", base::R.version$version.string), 
[13:17:29.735]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.735]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.735]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.735]                             "release", "version")], collapse = " "), 
[13:17:29.735]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.735]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.735]                           info)
[13:17:29.735]                         info <- base::paste(info, collapse = "; ")
[13:17:29.735]                         if (!has_future) {
[13:17:29.735]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.735]                             info)
[13:17:29.735]                         }
[13:17:29.735]                         else {
[13:17:29.735]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.735]                             info, version)
[13:17:29.735]                         }
[13:17:29.735]                         base::stop(msg)
[13:17:29.735]                       }
[13:17:29.735]                     })
[13:17:29.735]                   }
[13:17:29.735]                   options(future.plan = NULL)
[13:17:29.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.735]                 }
[13:17:29.735]                 ...future.workdir <- getwd()
[13:17:29.735]             }
[13:17:29.735]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.735]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.735]         }
[13:17:29.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.735]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.735]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.735]             base::names(...future.oldOptions))
[13:17:29.735]     }
[13:17:29.735]     if (FALSE) {
[13:17:29.735]     }
[13:17:29.735]     else {
[13:17:29.735]         if (TRUE) {
[13:17:29.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.735]                 open = "w")
[13:17:29.735]         }
[13:17:29.735]         else {
[13:17:29.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.735]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.735]         }
[13:17:29.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.735]             base::sink(type = "output", split = FALSE)
[13:17:29.735]             base::close(...future.stdout)
[13:17:29.735]         }, add = TRUE)
[13:17:29.735]     }
[13:17:29.735]     ...future.frame <- base::sys.nframe()
[13:17:29.735]     ...future.conditions <- base::list()
[13:17:29.735]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.735]     if (FALSE) {
[13:17:29.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.735]     }
[13:17:29.735]     ...future.result <- base::tryCatch({
[13:17:29.735]         base::withCallingHandlers({
[13:17:29.735]             ...future.value <- base::withVisible(base::local({
[13:17:29.735]                 do.call(function(...) {
[13:17:29.735]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.735]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.735]                     ...future.globals.maxSize)) {
[13:17:29.735]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.735]                     on.exit(options(oopts), add = TRUE)
[13:17:29.735]                   }
[13:17:29.735]                   {
[13:17:29.735]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.735]                       FUN = function(jj) {
[13:17:29.735]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.735]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.735]                       })
[13:17:29.735]                   }
[13:17:29.735]                 }, args = future.call.arguments)
[13:17:29.735]             }))
[13:17:29.735]             future::FutureResult(value = ...future.value$value, 
[13:17:29.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.735]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.735]                     ...future.globalenv.names))
[13:17:29.735]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.735]         }, condition = base::local({
[13:17:29.735]             c <- base::c
[13:17:29.735]             inherits <- base::inherits
[13:17:29.735]             invokeRestart <- base::invokeRestart
[13:17:29.735]             length <- base::length
[13:17:29.735]             list <- base::list
[13:17:29.735]             seq.int <- base::seq.int
[13:17:29.735]             signalCondition <- base::signalCondition
[13:17:29.735]             sys.calls <- base::sys.calls
[13:17:29.735]             `[[` <- base::`[[`
[13:17:29.735]             `+` <- base::`+`
[13:17:29.735]             `<<-` <- base::`<<-`
[13:17:29.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.735]                   3L)]
[13:17:29.735]             }
[13:17:29.735]             function(cond) {
[13:17:29.735]                 is_error <- inherits(cond, "error")
[13:17:29.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.735]                   NULL)
[13:17:29.735]                 if (is_error) {
[13:17:29.735]                   sessionInformation <- function() {
[13:17:29.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.735]                       search = base::search(), system = base::Sys.info())
[13:17:29.735]                   }
[13:17:29.735]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.735]                     cond$call), session = sessionInformation(), 
[13:17:29.735]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.735]                   signalCondition(cond)
[13:17:29.735]                 }
[13:17:29.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.735]                 "immediateCondition"))) {
[13:17:29.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.735]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.735]                   if (TRUE && !signal) {
[13:17:29.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.735]                     {
[13:17:29.735]                       inherits <- base::inherits
[13:17:29.735]                       invokeRestart <- base::invokeRestart
[13:17:29.735]                       is.null <- base::is.null
[13:17:29.735]                       muffled <- FALSE
[13:17:29.735]                       if (inherits(cond, "message")) {
[13:17:29.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.735]                         if (muffled) 
[13:17:29.735]                           invokeRestart("muffleMessage")
[13:17:29.735]                       }
[13:17:29.735]                       else if (inherits(cond, "warning")) {
[13:17:29.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.735]                         if (muffled) 
[13:17:29.735]                           invokeRestart("muffleWarning")
[13:17:29.735]                       }
[13:17:29.735]                       else if (inherits(cond, "condition")) {
[13:17:29.735]                         if (!is.null(pattern)) {
[13:17:29.735]                           computeRestarts <- base::computeRestarts
[13:17:29.735]                           grepl <- base::grepl
[13:17:29.735]                           restarts <- computeRestarts(cond)
[13:17:29.735]                           for (restart in restarts) {
[13:17:29.735]                             name <- restart$name
[13:17:29.735]                             if (is.null(name)) 
[13:17:29.735]                               next
[13:17:29.735]                             if (!grepl(pattern, name)) 
[13:17:29.735]                               next
[13:17:29.735]                             invokeRestart(restart)
[13:17:29.735]                             muffled <- TRUE
[13:17:29.735]                             break
[13:17:29.735]                           }
[13:17:29.735]                         }
[13:17:29.735]                       }
[13:17:29.735]                       invisible(muffled)
[13:17:29.735]                     }
[13:17:29.735]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.735]                   }
[13:17:29.735]                 }
[13:17:29.735]                 else {
[13:17:29.735]                   if (TRUE) {
[13:17:29.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.735]                     {
[13:17:29.735]                       inherits <- base::inherits
[13:17:29.735]                       invokeRestart <- base::invokeRestart
[13:17:29.735]                       is.null <- base::is.null
[13:17:29.735]                       muffled <- FALSE
[13:17:29.735]                       if (inherits(cond, "message")) {
[13:17:29.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.735]                         if (muffled) 
[13:17:29.735]                           invokeRestart("muffleMessage")
[13:17:29.735]                       }
[13:17:29.735]                       else if (inherits(cond, "warning")) {
[13:17:29.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.735]                         if (muffled) 
[13:17:29.735]                           invokeRestart("muffleWarning")
[13:17:29.735]                       }
[13:17:29.735]                       else if (inherits(cond, "condition")) {
[13:17:29.735]                         if (!is.null(pattern)) {
[13:17:29.735]                           computeRestarts <- base::computeRestarts
[13:17:29.735]                           grepl <- base::grepl
[13:17:29.735]                           restarts <- computeRestarts(cond)
[13:17:29.735]                           for (restart in restarts) {
[13:17:29.735]                             name <- restart$name
[13:17:29.735]                             if (is.null(name)) 
[13:17:29.735]                               next
[13:17:29.735]                             if (!grepl(pattern, name)) 
[13:17:29.735]                               next
[13:17:29.735]                             invokeRestart(restart)
[13:17:29.735]                             muffled <- TRUE
[13:17:29.735]                             break
[13:17:29.735]                           }
[13:17:29.735]                         }
[13:17:29.735]                       }
[13:17:29.735]                       invisible(muffled)
[13:17:29.735]                     }
[13:17:29.735]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.735]                   }
[13:17:29.735]                 }
[13:17:29.735]             }
[13:17:29.735]         }))
[13:17:29.735]     }, error = function(ex) {
[13:17:29.735]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.735]                 ...future.rng), started = ...future.startTime, 
[13:17:29.735]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.735]             version = "1.8"), class = "FutureResult")
[13:17:29.735]     }, finally = {
[13:17:29.735]         if (!identical(...future.workdir, getwd())) 
[13:17:29.735]             setwd(...future.workdir)
[13:17:29.735]         {
[13:17:29.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.735]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.735]             }
[13:17:29.735]             base::options(...future.oldOptions)
[13:17:29.735]             if (.Platform$OS.type == "windows") {
[13:17:29.735]                 old_names <- names(...future.oldEnvVars)
[13:17:29.735]                 envs <- base::Sys.getenv()
[13:17:29.735]                 names <- names(envs)
[13:17:29.735]                 common <- intersect(names, old_names)
[13:17:29.735]                 added <- setdiff(names, old_names)
[13:17:29.735]                 removed <- setdiff(old_names, names)
[13:17:29.735]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.735]                   envs[common]]
[13:17:29.735]                 NAMES <- toupper(changed)
[13:17:29.735]                 args <- list()
[13:17:29.735]                 for (kk in seq_along(NAMES)) {
[13:17:29.735]                   name <- changed[[kk]]
[13:17:29.735]                   NAME <- NAMES[[kk]]
[13:17:29.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.735]                     next
[13:17:29.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.735]                 }
[13:17:29.735]                 NAMES <- toupper(added)
[13:17:29.735]                 for (kk in seq_along(NAMES)) {
[13:17:29.735]                   name <- added[[kk]]
[13:17:29.735]                   NAME <- NAMES[[kk]]
[13:17:29.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.735]                     next
[13:17:29.735]                   args[[name]] <- ""
[13:17:29.735]                 }
[13:17:29.735]                 NAMES <- toupper(removed)
[13:17:29.735]                 for (kk in seq_along(NAMES)) {
[13:17:29.735]                   name <- removed[[kk]]
[13:17:29.735]                   NAME <- NAMES[[kk]]
[13:17:29.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.735]                     next
[13:17:29.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.735]                 }
[13:17:29.735]                 if (length(args) > 0) 
[13:17:29.735]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.735]             }
[13:17:29.735]             else {
[13:17:29.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.735]             }
[13:17:29.735]             {
[13:17:29.735]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.735]                   0L) {
[13:17:29.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.735]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.735]                   base::options(opts)
[13:17:29.735]                 }
[13:17:29.735]                 {
[13:17:29.735]                   {
[13:17:29.735]                     NULL
[13:17:29.735]                     RNGkind("Mersenne-Twister")
[13:17:29.735]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.735]                       inherits = FALSE)
[13:17:29.735]                   }
[13:17:29.735]                   options(future.plan = NULL)
[13:17:29.735]                   if (is.na(NA_character_)) 
[13:17:29.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.735]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:29.735]                   {
[13:17:29.735]                     future <- SequentialFuture(..., envir = envir)
[13:17:29.735]                     if (!future$lazy) 
[13:17:29.735]                       future <- run(future)
[13:17:29.735]                     invisible(future)
[13:17:29.735]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.735]                 }
[13:17:29.735]             }
[13:17:29.735]         }
[13:17:29.735]     })
[13:17:29.735]     if (TRUE) {
[13:17:29.735]         base::sink(type = "output", split = FALSE)
[13:17:29.735]         if (TRUE) {
[13:17:29.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.735]         }
[13:17:29.735]         else {
[13:17:29.735]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.735]         }
[13:17:29.735]         base::close(...future.stdout)
[13:17:29.735]         ...future.stdout <- NULL
[13:17:29.735]     }
[13:17:29.735]     ...future.result$conditions <- ...future.conditions
[13:17:29.735]     ...future.result$finished <- base::Sys.time()
[13:17:29.735]     ...future.result
[13:17:29.735] }
[13:17:29.737] assign_globals() ...
[13:17:29.737] List of 5
[13:17:29.737]  $ ...future.FUN            :function (object, ...)  
[13:17:29.737]  $ future.call.arguments    : list()
[13:17:29.737]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.737]  $ ...future.elements_ii    :List of 3
[13:17:29.737]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.737]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.737]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.737]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.737]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.737]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.737]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.737]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.737]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.737]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.737]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.737]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.737]  $ ...future.seeds_ii       : NULL
[13:17:29.737]  $ ...future.globals.maxSize: NULL
[13:17:29.737]  - attr(*, "resolved")= logi FALSE
[13:17:29.737]  - attr(*, "total_size")= num 1240
[13:17:29.737]  - attr(*, "where")=List of 5
[13:17:29.737]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.737]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.737]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.737]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.737]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.737]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.737]  - attr(*, "already-done")= logi TRUE
[13:17:29.748] - copied ‘...future.FUN’ to environment
[13:17:29.748] - copied ‘future.call.arguments’ to environment
[13:17:29.748] - copied ‘...future.elements_ii’ to environment
[13:17:29.748] - copied ‘...future.seeds_ii’ to environment
[13:17:29.748] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.748] assign_globals() ... done
[13:17:29.748] plan(): Setting new future strategy stack:
[13:17:29.749] List of future strategies:
[13:17:29.749] 1. sequential:
[13:17:29.749]    - args: function (..., envir = parent.frame())
[13:17:29.749]    - tweaked: FALSE
[13:17:29.749]    - call: NULL
[13:17:29.749] plan(): nbrOfWorkers() = 1
[13:17:29.751] plan(): Setting new future strategy stack:
[13:17:29.751] List of future strategies:
[13:17:29.751] 1. sequential:
[13:17:29.751]    - args: function (..., envir = parent.frame())
[13:17:29.751]    - tweaked: FALSE
[13:17:29.751]    - call: plan(strategy)
[13:17:29.752] plan(): nbrOfWorkers() = 1
[13:17:29.752] SequentialFuture started (and completed)
[13:17:29.752] - Launch lazy future ... done
[13:17:29.752] run() for ‘SequentialFuture’ ... done
[13:17:29.752] Created future:
[13:17:29.752] SequentialFuture:
[13:17:29.752] Label: ‘future_by-1’
[13:17:29.752] Expression:
[13:17:29.752] {
[13:17:29.752]     do.call(function(...) {
[13:17:29.752]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.752]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.752]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.752]             on.exit(options(oopts), add = TRUE)
[13:17:29.752]         }
[13:17:29.752]         {
[13:17:29.752]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.752]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.752]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.752]             })
[13:17:29.752]         }
[13:17:29.752]     }, args = future.call.arguments)
[13:17:29.752] }
[13:17:29.752] Lazy evaluation: FALSE
[13:17:29.752] Asynchronous evaluation: FALSE
[13:17:29.752] Local evaluation: TRUE
[13:17:29.752] Environment: 0x5609ea581508
[13:17:29.752] Capture standard output: TRUE
[13:17:29.752] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.752] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.752] Packages: <none>
[13:17:29.752] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.752] Resolved: TRUE
[13:17:29.752] Value: 5.37 KiB of class ‘list’
[13:17:29.752] Early signaling: FALSE
[13:17:29.752] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.752] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.754] Chunk #1 of 1 ... DONE
[13:17:29.754] Launching 1 futures (chunks) ... DONE
[13:17:29.754] Resolving 1 futures (chunks) ...
[13:17:29.754] resolve() on list ...
[13:17:29.754]  recursive: 0
[13:17:29.754]  length: 1
[13:17:29.754] 
[13:17:29.755] resolved() for ‘SequentialFuture’ ...
[13:17:29.755] - state: ‘finished’
[13:17:29.755] - run: TRUE
[13:17:29.755] - result: ‘FutureResult’
[13:17:29.755] resolved() for ‘SequentialFuture’ ... done
[13:17:29.755] Future #1
[13:17:29.755] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.755] - nx: 1
[13:17:29.755] - relay: TRUE
[13:17:29.756] - stdout: TRUE
[13:17:29.756] - signal: TRUE
[13:17:29.756] - resignal: FALSE
[13:17:29.756] - force: TRUE
[13:17:29.756] - relayed: [n=1] FALSE
[13:17:29.756] - queued futures: [n=1] FALSE
[13:17:29.756]  - until=1
[13:17:29.756]  - relaying element #1
[13:17:29.756] - relayed: [n=1] TRUE
[13:17:29.756] - queued futures: [n=1] TRUE
[13:17:29.757] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.757]  length: 0 (resolved future 1)
[13:17:29.757] Relaying remaining futures
[13:17:29.757] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.757] - nx: 1
[13:17:29.757] - relay: TRUE
[13:17:29.757] - stdout: TRUE
[13:17:29.757] - signal: TRUE
[13:17:29.757] - resignal: FALSE
[13:17:29.757] - force: TRUE
[13:17:29.757] - relayed: [n=1] TRUE
[13:17:29.758] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.758] - relayed: [n=1] TRUE
[13:17:29.758] - queued futures: [n=1] TRUE
[13:17:29.758] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.758] resolve() on list ... DONE
[13:17:29.758]  - Number of value chunks collected: 1
[13:17:29.758] Resolving 1 futures (chunks) ... DONE
[13:17:29.758] Reducing values from 1 chunks ...
[13:17:29.758]  - Number of values collected after concatenation: 3
[13:17:29.759]  - Number of values expected: 3
[13:17:29.759] Reducing values from 1 chunks ... DONE
[13:17:29.759] future_lapply() ... DONE
[13:17:29.759] future_by_internal() ... DONE
[13:17:29.760] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:17:29.760] future_lapply() ...
[13:17:29.761] Number of chunks: 1
[13:17:29.761] getGlobalsAndPackagesXApply() ...
[13:17:29.761]  - future.globals: TRUE
[13:17:29.761] getGlobalsAndPackages() ...
[13:17:29.761] Searching for globals...
[13:17:29.763] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.764] Searching for globals ... DONE
[13:17:29.764] Resolving globals: FALSE
[13:17:29.764] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.764] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.765] - globals: [1] ‘FUN’
[13:17:29.765] 
[13:17:29.765] getGlobalsAndPackages() ... DONE
[13:17:29.765]  - globals found/used: [n=1] ‘FUN’
[13:17:29.765]  - needed namespaces: [n=0] 
[13:17:29.765] Finding globals ... DONE
[13:17:29.765]  - use_args: TRUE
[13:17:29.765]  - Getting '...' globals ...
[13:17:29.766] resolve() on list ...
[13:17:29.766]  recursive: 0
[13:17:29.766]  length: 1
[13:17:29.766]  elements: ‘...’
[13:17:29.766]  length: 0 (resolved future 1)
[13:17:29.766] resolve() on list ... DONE
[13:17:29.766]    - '...' content: [n=0] 
[13:17:29.766] List of 1
[13:17:29.766]  $ ...: list()
[13:17:29.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.766]  - attr(*, "where")=List of 1
[13:17:29.766]   ..$ ...:<environment: 0x5609eaa06fe8> 
[13:17:29.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.766]  - attr(*, "resolved")= logi TRUE
[13:17:29.766]  - attr(*, "total_size")= num NA
[13:17:29.769]  - Getting '...' globals ... DONE
[13:17:29.769] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.769] List of 2
[13:17:29.769]  $ ...future.FUN:function (object, ...)  
[13:17:29.769]  $ ...          : list()
[13:17:29.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.769]  - attr(*, "where")=List of 2
[13:17:29.769]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.769]   ..$ ...          :<environment: 0x5609eaa06fe8> 
[13:17:29.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.769]  - attr(*, "resolved")= logi FALSE
[13:17:29.769]  - attr(*, "total_size")= num 1240
[13:17:29.772] Packages to be attached in all futures: [n=0] 
[13:17:29.772] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.772] Number of futures (= number of chunks): 1
[13:17:29.772] Launching 1 futures (chunks) ...
[13:17:29.772] Chunk #1 of 1 ...
[13:17:29.773]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.773] getGlobalsAndPackages() ...
[13:17:29.773] Searching for globals...
[13:17:29.773] 
[13:17:29.773] Searching for globals ... DONE
[13:17:29.773] - globals: [0] <none>
[13:17:29.774] getGlobalsAndPackages() ... DONE
[13:17:29.774]    + additional globals found: [n=0] 
[13:17:29.774]    + additional namespaces needed: [n=0] 
[13:17:29.774]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.774]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.774]  - seeds: <none>
[13:17:29.774] getGlobalsAndPackages() ...
[13:17:29.774] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.774] Resolving globals: FALSE
[13:17:29.774] Tweak future expression to call with '...' arguments ...
[13:17:29.775] {
[13:17:29.775]     do.call(function(...) {
[13:17:29.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.775]             on.exit(options(oopts), add = TRUE)
[13:17:29.775]         }
[13:17:29.775]         {
[13:17:29.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.775]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.775]             })
[13:17:29.775]         }
[13:17:29.775]     }, args = future.call.arguments)
[13:17:29.775] }
[13:17:29.775] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.775] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.775] 
[13:17:29.775] getGlobalsAndPackages() ... DONE
[13:17:29.776] run() for ‘Future’ ...
[13:17:29.776] - state: ‘created’
[13:17:29.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:29.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:29.777]   - Field: ‘label’
[13:17:29.777]   - Field: ‘local’
[13:17:29.777]   - Field: ‘owner’
[13:17:29.777]   - Field: ‘envir’
[13:17:29.777]   - Field: ‘packages’
[13:17:29.777]   - Field: ‘gc’
[13:17:29.777]   - Field: ‘conditions’
[13:17:29.777]   - Field: ‘expr’
[13:17:29.777]   - Field: ‘uuid’
[13:17:29.778]   - Field: ‘seed’
[13:17:29.778]   - Field: ‘version’
[13:17:29.778]   - Field: ‘result’
[13:17:29.778]   - Field: ‘asynchronous’
[13:17:29.778]   - Field: ‘calls’
[13:17:29.778]   - Field: ‘globals’
[13:17:29.778]   - Field: ‘stdout’
[13:17:29.778]   - Field: ‘earlySignal’
[13:17:29.778]   - Field: ‘lazy’
[13:17:29.778]   - Field: ‘state’
[13:17:29.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:29.779] - Launch lazy future ...
[13:17:29.779] Packages needed by the future expression (n = 0): <none>
[13:17:29.779] Packages needed by future strategies (n = 0): <none>
[13:17:29.779] {
[13:17:29.779]     {
[13:17:29.779]         {
[13:17:29.779]             ...future.startTime <- base::Sys.time()
[13:17:29.779]             {
[13:17:29.779]                 {
[13:17:29.779]                   {
[13:17:29.779]                     base::local({
[13:17:29.779]                       has_future <- base::requireNamespace("future", 
[13:17:29.779]                         quietly = TRUE)
[13:17:29.779]                       if (has_future) {
[13:17:29.779]                         ns <- base::getNamespace("future")
[13:17:29.779]                         version <- ns[[".package"]][["version"]]
[13:17:29.779]                         if (is.null(version)) 
[13:17:29.779]                           version <- utils::packageVersion("future")
[13:17:29.779]                       }
[13:17:29.779]                       else {
[13:17:29.779]                         version <- NULL
[13:17:29.779]                       }
[13:17:29.779]                       if (!has_future || version < "1.8.0") {
[13:17:29.779]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.779]                           "", base::R.version$version.string), 
[13:17:29.779]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:29.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.779]                             "release", "version")], collapse = " "), 
[13:17:29.779]                           hostname = base::Sys.info()[["nodename"]])
[13:17:29.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.779]                           info)
[13:17:29.779]                         info <- base::paste(info, collapse = "; ")
[13:17:29.779]                         if (!has_future) {
[13:17:29.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.779]                             info)
[13:17:29.779]                         }
[13:17:29.779]                         else {
[13:17:29.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.779]                             info, version)
[13:17:29.779]                         }
[13:17:29.779]                         base::stop(msg)
[13:17:29.779]                       }
[13:17:29.779]                     })
[13:17:29.779]                   }
[13:17:29.779]                   options(future.plan = NULL)
[13:17:29.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.779]                 }
[13:17:29.779]                 ...future.workdir <- getwd()
[13:17:29.779]             }
[13:17:29.779]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.779]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.779]         }
[13:17:29.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.779]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.779]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.779]             base::names(...future.oldOptions))
[13:17:29.779]     }
[13:17:29.779]     if (FALSE) {
[13:17:29.779]     }
[13:17:29.779]     else {
[13:17:29.779]         if (TRUE) {
[13:17:29.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.779]                 open = "w")
[13:17:29.779]         }
[13:17:29.779]         else {
[13:17:29.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.779]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.779]         }
[13:17:29.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.779]             base::sink(type = "output", split = FALSE)
[13:17:29.779]             base::close(...future.stdout)
[13:17:29.779]         }, add = TRUE)
[13:17:29.779]     }
[13:17:29.779]     ...future.frame <- base::sys.nframe()
[13:17:29.779]     ...future.conditions <- base::list()
[13:17:29.779]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.779]     if (FALSE) {
[13:17:29.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.779]     }
[13:17:29.779]     ...future.result <- base::tryCatch({
[13:17:29.779]         base::withCallingHandlers({
[13:17:29.779]             ...future.value <- base::withVisible(base::local({
[13:17:29.779]                 do.call(function(...) {
[13:17:29.779]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.779]                   if (!identical(...future.globals.maxSize.org, 
[13:17:29.779]                     ...future.globals.maxSize)) {
[13:17:29.779]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.779]                     on.exit(options(oopts), add = TRUE)
[13:17:29.779]                   }
[13:17:29.779]                   {
[13:17:29.779]                     lapply(seq_along(...future.elements_ii), 
[13:17:29.779]                       FUN = function(jj) {
[13:17:29.779]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.779]                         ...future.FUN(...future.X_jj, ...)
[13:17:29.779]                       })
[13:17:29.779]                   }
[13:17:29.779]                 }, args = future.call.arguments)
[13:17:29.779]             }))
[13:17:29.779]             future::FutureResult(value = ...future.value$value, 
[13:17:29.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.779]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.779]                     ...future.globalenv.names))
[13:17:29.779]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.779]         }, condition = base::local({
[13:17:29.779]             c <- base::c
[13:17:29.779]             inherits <- base::inherits
[13:17:29.779]             invokeRestart <- base::invokeRestart
[13:17:29.779]             length <- base::length
[13:17:29.779]             list <- base::list
[13:17:29.779]             seq.int <- base::seq.int
[13:17:29.779]             signalCondition <- base::signalCondition
[13:17:29.779]             sys.calls <- base::sys.calls
[13:17:29.779]             `[[` <- base::`[[`
[13:17:29.779]             `+` <- base::`+`
[13:17:29.779]             `<<-` <- base::`<<-`
[13:17:29.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.779]                   3L)]
[13:17:29.779]             }
[13:17:29.779]             function(cond) {
[13:17:29.779]                 is_error <- inherits(cond, "error")
[13:17:29.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.779]                   NULL)
[13:17:29.779]                 if (is_error) {
[13:17:29.779]                   sessionInformation <- function() {
[13:17:29.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.779]                       search = base::search(), system = base::Sys.info())
[13:17:29.779]                   }
[13:17:29.779]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.779]                     cond$call), session = sessionInformation(), 
[13:17:29.779]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.779]                   signalCondition(cond)
[13:17:29.779]                 }
[13:17:29.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.779]                 "immediateCondition"))) {
[13:17:29.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.779]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.779]                   if (TRUE && !signal) {
[13:17:29.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.779]                     {
[13:17:29.779]                       inherits <- base::inherits
[13:17:29.779]                       invokeRestart <- base::invokeRestart
[13:17:29.779]                       is.null <- base::is.null
[13:17:29.779]                       muffled <- FALSE
[13:17:29.779]                       if (inherits(cond, "message")) {
[13:17:29.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.779]                         if (muffled) 
[13:17:29.779]                           invokeRestart("muffleMessage")
[13:17:29.779]                       }
[13:17:29.779]                       else if (inherits(cond, "warning")) {
[13:17:29.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.779]                         if (muffled) 
[13:17:29.779]                           invokeRestart("muffleWarning")
[13:17:29.779]                       }
[13:17:29.779]                       else if (inherits(cond, "condition")) {
[13:17:29.779]                         if (!is.null(pattern)) {
[13:17:29.779]                           computeRestarts <- base::computeRestarts
[13:17:29.779]                           grepl <- base::grepl
[13:17:29.779]                           restarts <- computeRestarts(cond)
[13:17:29.779]                           for (restart in restarts) {
[13:17:29.779]                             name <- restart$name
[13:17:29.779]                             if (is.null(name)) 
[13:17:29.779]                               next
[13:17:29.779]                             if (!grepl(pattern, name)) 
[13:17:29.779]                               next
[13:17:29.779]                             invokeRestart(restart)
[13:17:29.779]                             muffled <- TRUE
[13:17:29.779]                             break
[13:17:29.779]                           }
[13:17:29.779]                         }
[13:17:29.779]                       }
[13:17:29.779]                       invisible(muffled)
[13:17:29.779]                     }
[13:17:29.779]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.779]                   }
[13:17:29.779]                 }
[13:17:29.779]                 else {
[13:17:29.779]                   if (TRUE) {
[13:17:29.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.779]                     {
[13:17:29.779]                       inherits <- base::inherits
[13:17:29.779]                       invokeRestart <- base::invokeRestart
[13:17:29.779]                       is.null <- base::is.null
[13:17:29.779]                       muffled <- FALSE
[13:17:29.779]                       if (inherits(cond, "message")) {
[13:17:29.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.779]                         if (muffled) 
[13:17:29.779]                           invokeRestart("muffleMessage")
[13:17:29.779]                       }
[13:17:29.779]                       else if (inherits(cond, "warning")) {
[13:17:29.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.779]                         if (muffled) 
[13:17:29.779]                           invokeRestart("muffleWarning")
[13:17:29.779]                       }
[13:17:29.779]                       else if (inherits(cond, "condition")) {
[13:17:29.779]                         if (!is.null(pattern)) {
[13:17:29.779]                           computeRestarts <- base::computeRestarts
[13:17:29.779]                           grepl <- base::grepl
[13:17:29.779]                           restarts <- computeRestarts(cond)
[13:17:29.779]                           for (restart in restarts) {
[13:17:29.779]                             name <- restart$name
[13:17:29.779]                             if (is.null(name)) 
[13:17:29.779]                               next
[13:17:29.779]                             if (!grepl(pattern, name)) 
[13:17:29.779]                               next
[13:17:29.779]                             invokeRestart(restart)
[13:17:29.779]                             muffled <- TRUE
[13:17:29.779]                             break
[13:17:29.779]                           }
[13:17:29.779]                         }
[13:17:29.779]                       }
[13:17:29.779]                       invisible(muffled)
[13:17:29.779]                     }
[13:17:29.779]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.779]                   }
[13:17:29.779]                 }
[13:17:29.779]             }
[13:17:29.779]         }))
[13:17:29.779]     }, error = function(ex) {
[13:17:29.779]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.779]                 ...future.rng), started = ...future.startTime, 
[13:17:29.779]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.779]             version = "1.8"), class = "FutureResult")
[13:17:29.779]     }, finally = {
[13:17:29.779]         if (!identical(...future.workdir, getwd())) 
[13:17:29.779]             setwd(...future.workdir)
[13:17:29.779]         {
[13:17:29.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.779]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.779]             }
[13:17:29.779]             base::options(...future.oldOptions)
[13:17:29.779]             if (.Platform$OS.type == "windows") {
[13:17:29.779]                 old_names <- names(...future.oldEnvVars)
[13:17:29.779]                 envs <- base::Sys.getenv()
[13:17:29.779]                 names <- names(envs)
[13:17:29.779]                 common <- intersect(names, old_names)
[13:17:29.779]                 added <- setdiff(names, old_names)
[13:17:29.779]                 removed <- setdiff(old_names, names)
[13:17:29.779]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.779]                   envs[common]]
[13:17:29.779]                 NAMES <- toupper(changed)
[13:17:29.779]                 args <- list()
[13:17:29.779]                 for (kk in seq_along(NAMES)) {
[13:17:29.779]                   name <- changed[[kk]]
[13:17:29.779]                   NAME <- NAMES[[kk]]
[13:17:29.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.779]                     next
[13:17:29.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.779]                 }
[13:17:29.779]                 NAMES <- toupper(added)
[13:17:29.779]                 for (kk in seq_along(NAMES)) {
[13:17:29.779]                   name <- added[[kk]]
[13:17:29.779]                   NAME <- NAMES[[kk]]
[13:17:29.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.779]                     next
[13:17:29.779]                   args[[name]] <- ""
[13:17:29.779]                 }
[13:17:29.779]                 NAMES <- toupper(removed)
[13:17:29.779]                 for (kk in seq_along(NAMES)) {
[13:17:29.779]                   name <- removed[[kk]]
[13:17:29.779]                   NAME <- NAMES[[kk]]
[13:17:29.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.779]                     next
[13:17:29.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.779]                 }
[13:17:29.779]                 if (length(args) > 0) 
[13:17:29.779]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.779]             }
[13:17:29.779]             else {
[13:17:29.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.779]             }
[13:17:29.779]             {
[13:17:29.779]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.779]                   0L) {
[13:17:29.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.779]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.779]                   base::options(opts)
[13:17:29.779]                 }
[13:17:29.779]                 {
[13:17:29.779]                   {
[13:17:29.779]                     NULL
[13:17:29.779]                     RNGkind("Mersenne-Twister")
[13:17:29.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:29.779]                       inherits = FALSE)
[13:17:29.779]                   }
[13:17:29.779]                   options(future.plan = NULL)
[13:17:29.779]                   if (is.na(NA_character_)) 
[13:17:29.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.779]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:29.779]                   {
[13:17:29.779]                     future <- SequentialFuture(..., envir = envir)
[13:17:29.779]                     if (!future$lazy) 
[13:17:29.779]                       future <- run(future)
[13:17:29.779]                     invisible(future)
[13:17:29.779]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.779]                 }
[13:17:29.779]             }
[13:17:29.779]         }
[13:17:29.779]     })
[13:17:29.779]     if (TRUE) {
[13:17:29.779]         base::sink(type = "output", split = FALSE)
[13:17:29.779]         if (TRUE) {
[13:17:29.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.779]         }
[13:17:29.779]         else {
[13:17:29.779]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.779]         }
[13:17:29.779]         base::close(...future.stdout)
[13:17:29.779]         ...future.stdout <- NULL
[13:17:29.779]     }
[13:17:29.779]     ...future.result$conditions <- ...future.conditions
[13:17:29.779]     ...future.result$finished <- base::Sys.time()
[13:17:29.779]     ...future.result
[13:17:29.779] }
[13:17:29.781] assign_globals() ...
[13:17:29.781] List of 5
[13:17:29.781]  $ ...future.FUN            :function (object, ...)  
[13:17:29.781]  $ future.call.arguments    : list()
[13:17:29.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.781]  $ ...future.elements_ii    :List of 3
[13:17:29.781]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.781]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.781]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.781]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:29.781]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.781]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.781]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.781]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:29.781]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:29.781]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.781]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.781]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:29.781]  $ ...future.seeds_ii       : NULL
[13:17:29.781]  $ ...future.globals.maxSize: NULL
[13:17:29.781]  - attr(*, "resolved")= logi FALSE
[13:17:29.781]  - attr(*, "total_size")= num 1240
[13:17:29.781]  - attr(*, "where")=List of 5
[13:17:29.781]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.781]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.781]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.781]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.781]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.781]  - attr(*, "already-done")= logi TRUE
[13:17:29.792] - copied ‘...future.FUN’ to environment
[13:17:29.792] - copied ‘future.call.arguments’ to environment
[13:17:29.792] - copied ‘...future.elements_ii’ to environment
[13:17:29.792] - copied ‘...future.seeds_ii’ to environment
[13:17:29.792] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.792] assign_globals() ... done
[13:17:29.792] plan(): Setting new future strategy stack:
[13:17:29.792] List of future strategies:
[13:17:29.792] 1. sequential:
[13:17:29.792]    - args: function (..., envir = parent.frame())
[13:17:29.792]    - tweaked: FALSE
[13:17:29.792]    - call: NULL
[13:17:29.793] plan(): nbrOfWorkers() = 1
[13:17:29.795] plan(): Setting new future strategy stack:
[13:17:29.795] List of future strategies:
[13:17:29.795] 1. sequential:
[13:17:29.795]    - args: function (..., envir = parent.frame())
[13:17:29.795]    - tweaked: FALSE
[13:17:29.795]    - call: plan(strategy)
[13:17:29.796] plan(): nbrOfWorkers() = 1
[13:17:29.796] SequentialFuture started (and completed)
[13:17:29.796] - Launch lazy future ... done
[13:17:29.796] run() for ‘SequentialFuture’ ... done
[13:17:29.796] Created future:
[13:17:29.796] SequentialFuture:
[13:17:29.796] Label: ‘future_by-1’
[13:17:29.796] Expression:
[13:17:29.796] {
[13:17:29.796]     do.call(function(...) {
[13:17:29.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.796]             on.exit(options(oopts), add = TRUE)
[13:17:29.796]         }
[13:17:29.796]         {
[13:17:29.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.796]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.796]             })
[13:17:29.796]         }
[13:17:29.796]     }, args = future.call.arguments)
[13:17:29.796] }
[13:17:29.796] Lazy evaluation: FALSE
[13:17:29.796] Asynchronous evaluation: FALSE
[13:17:29.796] Local evaluation: TRUE
[13:17:29.796] Environment: 0x5609ea996b10
[13:17:29.796] Capture standard output: TRUE
[13:17:29.796] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.796] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.796] Packages: <none>
[13:17:29.796] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.796] Resolved: TRUE
[13:17:29.796] Value: 5.37 KiB of class ‘list’
[13:17:29.796] Early signaling: FALSE
[13:17:29.796] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.796] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:29.798] Chunk #1 of 1 ... DONE
[13:17:29.798] Launching 1 futures (chunks) ... DONE
[13:17:29.798] Resolving 1 futures (chunks) ...
[13:17:29.798] resolve() on list ...
[13:17:29.798]  recursive: 0
[13:17:29.798]  length: 1
[13:17:29.798] 
[13:17:29.798] resolved() for ‘SequentialFuture’ ...
[13:17:29.798] - state: ‘finished’
[13:17:29.798] - run: TRUE
[13:17:29.799] - result: ‘FutureResult’
[13:17:29.799] resolved() for ‘SequentialFuture’ ... done
[13:17:29.799] Future #1
[13:17:29.799] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:29.799] - nx: 1
[13:17:29.799] - relay: TRUE
[13:17:29.799] - stdout: TRUE
[13:17:29.799] - signal: TRUE
[13:17:29.799] - resignal: FALSE
[13:17:29.799] - force: TRUE
[13:17:29.799] - relayed: [n=1] FALSE
[13:17:29.800] - queued futures: [n=1] FALSE
[13:17:29.800]  - until=1
[13:17:29.800]  - relaying element #1
[13:17:29.800] - relayed: [n=1] TRUE
[13:17:29.800] - queued futures: [n=1] TRUE
[13:17:29.800] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:29.800]  length: 0 (resolved future 1)
[13:17:29.800] Relaying remaining futures
[13:17:29.800] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.801] - nx: 1
[13:17:29.801] - relay: TRUE
[13:17:29.801] - stdout: TRUE
[13:17:29.801] - signal: TRUE
[13:17:29.801] - resignal: FALSE
[13:17:29.801] - force: TRUE
[13:17:29.801] - relayed: [n=1] TRUE
[13:17:29.801] - queued futures: [n=1] TRUE
 - flush all
[13:17:29.801] - relayed: [n=1] TRUE
[13:17:29.801] - queued futures: [n=1] TRUE
[13:17:29.802] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.802] resolve() on list ... DONE
[13:17:29.802]  - Number of value chunks collected: 1
[13:17:29.802] Resolving 1 futures (chunks) ... DONE
[13:17:29.802] Reducing values from 1 chunks ...
[13:17:29.802]  - Number of values collected after concatenation: 3
[13:17:29.802]  - Number of values expected: 3
[13:17:29.802] Reducing values from 1 chunks ... DONE
[13:17:29.802] future_lapply() ... DONE
[13:17:29.802] future_by_internal() ... DONE
[13:17:29.805] future_by_internal() ...
- plan('multicore') ...
[13:17:29.805] plan(): Setting new future strategy stack:
[13:17:29.805] List of future strategies:
[13:17:29.805] 1. multicore:
[13:17:29.805]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.805]    - tweaked: FALSE
[13:17:29.805]    - call: plan(strategy)
[13:17:29.809] plan(): nbrOfWorkers() = 2
[13:17:29.809] future_by_internal() ...
[13:17:29.810] future_lapply() ...
[13:17:29.815] Number of chunks: 2
[13:17:29.815] getGlobalsAndPackagesXApply() ...
[13:17:29.815]  - future.globals: TRUE
[13:17:29.815] getGlobalsAndPackages() ...
[13:17:29.815] Searching for globals...
[13:17:29.817] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.817] Searching for globals ... DONE
[13:17:29.817] Resolving globals: FALSE
[13:17:29.817] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.818] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.818] - globals: [1] ‘FUN’
[13:17:29.818] 
[13:17:29.818] getGlobalsAndPackages() ... DONE
[13:17:29.818]  - globals found/used: [n=1] ‘FUN’
[13:17:29.818]  - needed namespaces: [n=0] 
[13:17:29.818] Finding globals ... DONE
[13:17:29.818]  - use_args: TRUE
[13:17:29.818]  - Getting '...' globals ...
[13:17:29.819] resolve() on list ...
[13:17:29.819]  recursive: 0
[13:17:29.819]  length: 1
[13:17:29.819]  elements: ‘...’
[13:17:29.819]  length: 0 (resolved future 1)
[13:17:29.819] resolve() on list ... DONE
[13:17:29.819]    - '...' content: [n=0] 
[13:17:29.819] List of 1
[13:17:29.819]  $ ...: list()
[13:17:29.819]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.819]  - attr(*, "where")=List of 1
[13:17:29.819]   ..$ ...:<environment: 0x5609ead46e30> 
[13:17:29.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.819]  - attr(*, "resolved")= logi TRUE
[13:17:29.819]  - attr(*, "total_size")= num NA
[13:17:29.822]  - Getting '...' globals ... DONE
[13:17:29.822] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.822] List of 2
[13:17:29.822]  $ ...future.FUN:function (object, ...)  
[13:17:29.822]  $ ...          : list()
[13:17:29.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.822]  - attr(*, "where")=List of 2
[13:17:29.822]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.822]   ..$ ...          :<environment: 0x5609ead46e30> 
[13:17:29.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.822]  - attr(*, "resolved")= logi FALSE
[13:17:29.822]  - attr(*, "total_size")= num 1240
[13:17:29.825] Packages to be attached in all futures: [n=0] 
[13:17:29.825] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.825] Number of futures (= number of chunks): 2
[13:17:29.825] Launching 2 futures (chunks) ...
[13:17:29.825] Chunk #1 of 2 ...
[13:17:29.825]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.825] getGlobalsAndPackages() ...
[13:17:29.825] Searching for globals...
[13:17:29.826] 
[13:17:29.826] Searching for globals ... DONE
[13:17:29.826] - globals: [0] <none>
[13:17:29.826] getGlobalsAndPackages() ... DONE
[13:17:29.826]    + additional globals found: [n=0] 
[13:17:29.826]    + additional namespaces needed: [n=0] 
[13:17:29.826]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.826]  - seeds: <none>
[13:17:29.827] getGlobalsAndPackages() ...
[13:17:29.827] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.827] Resolving globals: FALSE
[13:17:29.827] Tweak future expression to call with '...' arguments ...
[13:17:29.827] {
[13:17:29.827]     do.call(function(...) {
[13:17:29.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.827]             on.exit(options(oopts), add = TRUE)
[13:17:29.827]         }
[13:17:29.827]         {
[13:17:29.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.827]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.827]             })
[13:17:29.827]         }
[13:17:29.827]     }, args = future.call.arguments)
[13:17:29.827] }
[13:17:29.827] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.828] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.828] 
[13:17:29.829] getGlobalsAndPackages() ... DONE
[13:17:29.830] run() for ‘Future’ ...
[13:17:29.830] - state: ‘created’
[13:17:29.830] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.834] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:29.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:29.834]   - Field: ‘label’
[13:17:29.834]   - Field: ‘local’
[13:17:29.834]   - Field: ‘owner’
[13:17:29.834]   - Field: ‘envir’
[13:17:29.834]   - Field: ‘workers’
[13:17:29.834]   - Field: ‘packages’
[13:17:29.835]   - Field: ‘gc’
[13:17:29.835]   - Field: ‘job’
[13:17:29.835]   - Field: ‘conditions’
[13:17:29.835]   - Field: ‘expr’
[13:17:29.835]   - Field: ‘uuid’
[13:17:29.835]   - Field: ‘seed’
[13:17:29.835]   - Field: ‘version’
[13:17:29.835]   - Field: ‘result’
[13:17:29.835]   - Field: ‘asynchronous’
[13:17:29.835]   - Field: ‘calls’
[13:17:29.836]   - Field: ‘globals’
[13:17:29.836]   - Field: ‘stdout’
[13:17:29.836]   - Field: ‘earlySignal’
[13:17:29.836]   - Field: ‘lazy’
[13:17:29.836]   - Field: ‘state’
[13:17:29.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:29.836] - Launch lazy future ...
[13:17:29.837] Packages needed by the future expression (n = 0): <none>
[13:17:29.837] Packages needed by future strategies (n = 0): <none>
[13:17:29.838] {
[13:17:29.838]     {
[13:17:29.838]         {
[13:17:29.838]             ...future.startTime <- base::Sys.time()
[13:17:29.838]             {
[13:17:29.838]                 {
[13:17:29.838]                   {
[13:17:29.838]                     {
[13:17:29.838]                       base::local({
[13:17:29.838]                         has_future <- base::requireNamespace("future", 
[13:17:29.838]                           quietly = TRUE)
[13:17:29.838]                         if (has_future) {
[13:17:29.838]                           ns <- base::getNamespace("future")
[13:17:29.838]                           version <- ns[[".package"]][["version"]]
[13:17:29.838]                           if (is.null(version)) 
[13:17:29.838]                             version <- utils::packageVersion("future")
[13:17:29.838]                         }
[13:17:29.838]                         else {
[13:17:29.838]                           version <- NULL
[13:17:29.838]                         }
[13:17:29.838]                         if (!has_future || version < "1.8.0") {
[13:17:29.838]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.838]                             "", base::R.version$version.string), 
[13:17:29.838]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.838]                               "release", "version")], collapse = " "), 
[13:17:29.838]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.838]                             info)
[13:17:29.838]                           info <- base::paste(info, collapse = "; ")
[13:17:29.838]                           if (!has_future) {
[13:17:29.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.838]                               info)
[13:17:29.838]                           }
[13:17:29.838]                           else {
[13:17:29.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.838]                               info, version)
[13:17:29.838]                           }
[13:17:29.838]                           base::stop(msg)
[13:17:29.838]                         }
[13:17:29.838]                       })
[13:17:29.838]                     }
[13:17:29.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:29.838]                     base::options(mc.cores = 1L)
[13:17:29.838]                   }
[13:17:29.838]                   options(future.plan = NULL)
[13:17:29.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.838]                 }
[13:17:29.838]                 ...future.workdir <- getwd()
[13:17:29.838]             }
[13:17:29.838]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.838]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.838]         }
[13:17:29.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:29.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.838]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.838]             base::names(...future.oldOptions))
[13:17:29.838]     }
[13:17:29.838]     if (FALSE) {
[13:17:29.838]     }
[13:17:29.838]     else {
[13:17:29.838]         if (TRUE) {
[13:17:29.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.838]                 open = "w")
[13:17:29.838]         }
[13:17:29.838]         else {
[13:17:29.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.838]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.838]         }
[13:17:29.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.838]             base::sink(type = "output", split = FALSE)
[13:17:29.838]             base::close(...future.stdout)
[13:17:29.838]         }, add = TRUE)
[13:17:29.838]     }
[13:17:29.838]     ...future.frame <- base::sys.nframe()
[13:17:29.838]     ...future.conditions <- base::list()
[13:17:29.838]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.838]     if (FALSE) {
[13:17:29.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.838]     }
[13:17:29.838]     ...future.result <- base::tryCatch({
[13:17:29.838]         base::withCallingHandlers({
[13:17:29.838]             ...future.value <- base::withVisible(base::local({
[13:17:29.838]                 withCallingHandlers({
[13:17:29.838]                   {
[13:17:29.838]                     do.call(function(...) {
[13:17:29.838]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.838]                       if (!identical(...future.globals.maxSize.org, 
[13:17:29.838]                         ...future.globals.maxSize)) {
[13:17:29.838]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.838]                         on.exit(options(oopts), add = TRUE)
[13:17:29.838]                       }
[13:17:29.838]                       {
[13:17:29.838]                         lapply(seq_along(...future.elements_ii), 
[13:17:29.838]                           FUN = function(jj) {
[13:17:29.838]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.838]                             ...future.FUN(...future.X_jj, ...)
[13:17:29.838]                           })
[13:17:29.838]                       }
[13:17:29.838]                     }, args = future.call.arguments)
[13:17:29.838]                   }
[13:17:29.838]                 }, immediateCondition = function(cond) {
[13:17:29.838]                   save_rds <- function (object, pathname, ...) 
[13:17:29.838]                   {
[13:17:29.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:29.838]                     if (file_test("-f", pathname_tmp)) {
[13:17:29.838]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:29.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.838]                         fi_tmp[["mtime"]])
[13:17:29.838]                     }
[13:17:29.838]                     tryCatch({
[13:17:29.838]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:29.838]                     }, error = function(ex) {
[13:17:29.838]                       msg <- conditionMessage(ex)
[13:17:29.838]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:29.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.838]                         fi_tmp[["mtime"]], msg)
[13:17:29.838]                       ex$message <- msg
[13:17:29.838]                       stop(ex)
[13:17:29.838]                     })
[13:17:29.838]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:29.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:29.838]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:29.838]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.838]                       fi <- file.info(pathname)
[13:17:29.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:29.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:29.838]                         fi[["size"]], fi[["mtime"]])
[13:17:29.838]                       stop(msg)
[13:17:29.838]                     }
[13:17:29.838]                     invisible(pathname)
[13:17:29.838]                   }
[13:17:29.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:29.838]                     rootPath = tempdir()) 
[13:17:29.838]                   {
[13:17:29.838]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:29.838]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:29.838]                       tmpdir = path, fileext = ".rds")
[13:17:29.838]                     save_rds(obj, file)
[13:17:29.838]                   }
[13:17:29.838]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:29.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.838]                   {
[13:17:29.838]                     inherits <- base::inherits
[13:17:29.838]                     invokeRestart <- base::invokeRestart
[13:17:29.838]                     is.null <- base::is.null
[13:17:29.838]                     muffled <- FALSE
[13:17:29.838]                     if (inherits(cond, "message")) {
[13:17:29.838]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:29.838]                       if (muffled) 
[13:17:29.838]                         invokeRestart("muffleMessage")
[13:17:29.838]                     }
[13:17:29.838]                     else if (inherits(cond, "warning")) {
[13:17:29.838]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:29.838]                       if (muffled) 
[13:17:29.838]                         invokeRestart("muffleWarning")
[13:17:29.838]                     }
[13:17:29.838]                     else if (inherits(cond, "condition")) {
[13:17:29.838]                       if (!is.null(pattern)) {
[13:17:29.838]                         computeRestarts <- base::computeRestarts
[13:17:29.838]                         grepl <- base::grepl
[13:17:29.838]                         restarts <- computeRestarts(cond)
[13:17:29.838]                         for (restart in restarts) {
[13:17:29.838]                           name <- restart$name
[13:17:29.838]                           if (is.null(name)) 
[13:17:29.838]                             next
[13:17:29.838]                           if (!grepl(pattern, name)) 
[13:17:29.838]                             next
[13:17:29.838]                           invokeRestart(restart)
[13:17:29.838]                           muffled <- TRUE
[13:17:29.838]                           break
[13:17:29.838]                         }
[13:17:29.838]                       }
[13:17:29.838]                     }
[13:17:29.838]                     invisible(muffled)
[13:17:29.838]                   }
[13:17:29.838]                   muffleCondition(cond)
[13:17:29.838]                 })
[13:17:29.838]             }))
[13:17:29.838]             future::FutureResult(value = ...future.value$value, 
[13:17:29.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.838]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.838]                     ...future.globalenv.names))
[13:17:29.838]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.838]         }, condition = base::local({
[13:17:29.838]             c <- base::c
[13:17:29.838]             inherits <- base::inherits
[13:17:29.838]             invokeRestart <- base::invokeRestart
[13:17:29.838]             length <- base::length
[13:17:29.838]             list <- base::list
[13:17:29.838]             seq.int <- base::seq.int
[13:17:29.838]             signalCondition <- base::signalCondition
[13:17:29.838]             sys.calls <- base::sys.calls
[13:17:29.838]             `[[` <- base::`[[`
[13:17:29.838]             `+` <- base::`+`
[13:17:29.838]             `<<-` <- base::`<<-`
[13:17:29.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.838]                   3L)]
[13:17:29.838]             }
[13:17:29.838]             function(cond) {
[13:17:29.838]                 is_error <- inherits(cond, "error")
[13:17:29.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.838]                   NULL)
[13:17:29.838]                 if (is_error) {
[13:17:29.838]                   sessionInformation <- function() {
[13:17:29.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.838]                       search = base::search(), system = base::Sys.info())
[13:17:29.838]                   }
[13:17:29.838]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.838]                     cond$call), session = sessionInformation(), 
[13:17:29.838]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.838]                   signalCondition(cond)
[13:17:29.838]                 }
[13:17:29.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.838]                 "immediateCondition"))) {
[13:17:29.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.838]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.838]                   if (TRUE && !signal) {
[13:17:29.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.838]                     {
[13:17:29.838]                       inherits <- base::inherits
[13:17:29.838]                       invokeRestart <- base::invokeRestart
[13:17:29.838]                       is.null <- base::is.null
[13:17:29.838]                       muffled <- FALSE
[13:17:29.838]                       if (inherits(cond, "message")) {
[13:17:29.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.838]                         if (muffled) 
[13:17:29.838]                           invokeRestart("muffleMessage")
[13:17:29.838]                       }
[13:17:29.838]                       else if (inherits(cond, "warning")) {
[13:17:29.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.838]                         if (muffled) 
[13:17:29.838]                           invokeRestart("muffleWarning")
[13:17:29.838]                       }
[13:17:29.838]                       else if (inherits(cond, "condition")) {
[13:17:29.838]                         if (!is.null(pattern)) {
[13:17:29.838]                           computeRestarts <- base::computeRestarts
[13:17:29.838]                           grepl <- base::grepl
[13:17:29.838]                           restarts <- computeRestarts(cond)
[13:17:29.838]                           for (restart in restarts) {
[13:17:29.838]                             name <- restart$name
[13:17:29.838]                             if (is.null(name)) 
[13:17:29.838]                               next
[13:17:29.838]                             if (!grepl(pattern, name)) 
[13:17:29.838]                               next
[13:17:29.838]                             invokeRestart(restart)
[13:17:29.838]                             muffled <- TRUE
[13:17:29.838]                             break
[13:17:29.838]                           }
[13:17:29.838]                         }
[13:17:29.838]                       }
[13:17:29.838]                       invisible(muffled)
[13:17:29.838]                     }
[13:17:29.838]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.838]                   }
[13:17:29.838]                 }
[13:17:29.838]                 else {
[13:17:29.838]                   if (TRUE) {
[13:17:29.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.838]                     {
[13:17:29.838]                       inherits <- base::inherits
[13:17:29.838]                       invokeRestart <- base::invokeRestart
[13:17:29.838]                       is.null <- base::is.null
[13:17:29.838]                       muffled <- FALSE
[13:17:29.838]                       if (inherits(cond, "message")) {
[13:17:29.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.838]                         if (muffled) 
[13:17:29.838]                           invokeRestart("muffleMessage")
[13:17:29.838]                       }
[13:17:29.838]                       else if (inherits(cond, "warning")) {
[13:17:29.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.838]                         if (muffled) 
[13:17:29.838]                           invokeRestart("muffleWarning")
[13:17:29.838]                       }
[13:17:29.838]                       else if (inherits(cond, "condition")) {
[13:17:29.838]                         if (!is.null(pattern)) {
[13:17:29.838]                           computeRestarts <- base::computeRestarts
[13:17:29.838]                           grepl <- base::grepl
[13:17:29.838]                           restarts <- computeRestarts(cond)
[13:17:29.838]                           for (restart in restarts) {
[13:17:29.838]                             name <- restart$name
[13:17:29.838]                             if (is.null(name)) 
[13:17:29.838]                               next
[13:17:29.838]                             if (!grepl(pattern, name)) 
[13:17:29.838]                               next
[13:17:29.838]                             invokeRestart(restart)
[13:17:29.838]                             muffled <- TRUE
[13:17:29.838]                             break
[13:17:29.838]                           }
[13:17:29.838]                         }
[13:17:29.838]                       }
[13:17:29.838]                       invisible(muffled)
[13:17:29.838]                     }
[13:17:29.838]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.838]                   }
[13:17:29.838]                 }
[13:17:29.838]             }
[13:17:29.838]         }))
[13:17:29.838]     }, error = function(ex) {
[13:17:29.838]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.838]                 ...future.rng), started = ...future.startTime, 
[13:17:29.838]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.838]             version = "1.8"), class = "FutureResult")
[13:17:29.838]     }, finally = {
[13:17:29.838]         if (!identical(...future.workdir, getwd())) 
[13:17:29.838]             setwd(...future.workdir)
[13:17:29.838]         {
[13:17:29.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.838]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.838]             }
[13:17:29.838]             base::options(...future.oldOptions)
[13:17:29.838]             if (.Platform$OS.type == "windows") {
[13:17:29.838]                 old_names <- names(...future.oldEnvVars)
[13:17:29.838]                 envs <- base::Sys.getenv()
[13:17:29.838]                 names <- names(envs)
[13:17:29.838]                 common <- intersect(names, old_names)
[13:17:29.838]                 added <- setdiff(names, old_names)
[13:17:29.838]                 removed <- setdiff(old_names, names)
[13:17:29.838]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.838]                   envs[common]]
[13:17:29.838]                 NAMES <- toupper(changed)
[13:17:29.838]                 args <- list()
[13:17:29.838]                 for (kk in seq_along(NAMES)) {
[13:17:29.838]                   name <- changed[[kk]]
[13:17:29.838]                   NAME <- NAMES[[kk]]
[13:17:29.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.838]                     next
[13:17:29.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.838]                 }
[13:17:29.838]                 NAMES <- toupper(added)
[13:17:29.838]                 for (kk in seq_along(NAMES)) {
[13:17:29.838]                   name <- added[[kk]]
[13:17:29.838]                   NAME <- NAMES[[kk]]
[13:17:29.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.838]                     next
[13:17:29.838]                   args[[name]] <- ""
[13:17:29.838]                 }
[13:17:29.838]                 NAMES <- toupper(removed)
[13:17:29.838]                 for (kk in seq_along(NAMES)) {
[13:17:29.838]                   name <- removed[[kk]]
[13:17:29.838]                   NAME <- NAMES[[kk]]
[13:17:29.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.838]                     next
[13:17:29.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.838]                 }
[13:17:29.838]                 if (length(args) > 0) 
[13:17:29.838]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.838]             }
[13:17:29.838]             else {
[13:17:29.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.838]             }
[13:17:29.838]             {
[13:17:29.838]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.838]                   0L) {
[13:17:29.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.838]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.838]                   base::options(opts)
[13:17:29.838]                 }
[13:17:29.838]                 {
[13:17:29.838]                   {
[13:17:29.838]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:29.838]                     NULL
[13:17:29.838]                   }
[13:17:29.838]                   options(future.plan = NULL)
[13:17:29.838]                   if (is.na(NA_character_)) 
[13:17:29.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.838]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:29.838]                     envir = parent.frame()) 
[13:17:29.838]                   {
[13:17:29.838]                     default_workers <- missing(workers)
[13:17:29.838]                     if (is.function(workers)) 
[13:17:29.838]                       workers <- workers()
[13:17:29.838]                     workers <- structure(as.integer(workers), 
[13:17:29.838]                       class = class(workers))
[13:17:29.838]                     stop_if_not(is.finite(workers), workers >= 
[13:17:29.838]                       1L)
[13:17:29.838]                     if ((workers == 1L && !inherits(workers, 
[13:17:29.838]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:29.838]                       if (default_workers) 
[13:17:29.838]                         supportsMulticore(warn = TRUE)
[13:17:29.838]                       return(sequential(..., envir = envir))
[13:17:29.838]                     }
[13:17:29.838]                     oopts <- options(mc.cores = workers)
[13:17:29.838]                     on.exit(options(oopts))
[13:17:29.838]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:29.838]                       envir = envir)
[13:17:29.838]                     if (!future$lazy) 
[13:17:29.838]                       future <- run(future)
[13:17:29.838]                     invisible(future)
[13:17:29.838]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.838]                 }
[13:17:29.838]             }
[13:17:29.838]         }
[13:17:29.838]     })
[13:17:29.838]     if (TRUE) {
[13:17:29.838]         base::sink(type = "output", split = FALSE)
[13:17:29.838]         if (TRUE) {
[13:17:29.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.838]         }
[13:17:29.838]         else {
[13:17:29.838]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.838]         }
[13:17:29.838]         base::close(...future.stdout)
[13:17:29.838]         ...future.stdout <- NULL
[13:17:29.838]     }
[13:17:29.838]     ...future.result$conditions <- ...future.conditions
[13:17:29.838]     ...future.result$finished <- base::Sys.time()
[13:17:29.838]     ...future.result
[13:17:29.838] }
[13:17:29.840] assign_globals() ...
[13:17:29.840] List of 5
[13:17:29.840]  $ ...future.FUN            :function (object, ...)  
[13:17:29.840]  $ future.call.arguments    : list()
[13:17:29.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.840]  $ ...future.elements_ii    :List of 1
[13:17:29.840]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.840]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:29.840]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.840]  $ ...future.seeds_ii       : NULL
[13:17:29.840]  $ ...future.globals.maxSize: NULL
[13:17:29.840]  - attr(*, "where")=List of 5
[13:17:29.840]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.840]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.840]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.840]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.840]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.840]  - attr(*, "resolved")= logi FALSE
[13:17:29.840]  - attr(*, "total_size")= num 1240
[13:17:29.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.840]  - attr(*, "already-done")= logi TRUE
[13:17:29.846] - copied ‘...future.FUN’ to environment
[13:17:29.846] - copied ‘future.call.arguments’ to environment
[13:17:29.846] - copied ‘...future.elements_ii’ to environment
[13:17:29.846] - copied ‘...future.seeds_ii’ to environment
[13:17:29.846] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.846] assign_globals() ... done
[13:17:29.846] requestCore(): workers = 2
[13:17:29.849] MulticoreFuture started
[13:17:29.850] - Launch lazy future ... done
[13:17:29.850] plan(): Setting new future strategy stack:
[13:17:29.850] run() for ‘MulticoreFuture’ ... done
[13:17:29.850] Created future:
[13:17:29.850] List of future strategies:
[13:17:29.850] 1. sequential:
[13:17:29.850]    - args: function (..., envir = parent.frame())
[13:17:29.850]    - tweaked: FALSE
[13:17:29.850]    - call: NULL
[13:17:29.851] plan(): nbrOfWorkers() = 1
[13:17:29.854] plan(): Setting new future strategy stack:
[13:17:29.855] List of future strategies:
[13:17:29.855] 1. multicore:
[13:17:29.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.855]    - tweaked: FALSE
[13:17:29.855]    - call: plan(strategy)
[13:17:29.860] plan(): nbrOfWorkers() = 2
[13:17:29.851] MulticoreFuture:
[13:17:29.851] Label: ‘future_by-1’
[13:17:29.851] Expression:
[13:17:29.851] {
[13:17:29.851]     do.call(function(...) {
[13:17:29.851]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.851]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.851]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.851]             on.exit(options(oopts), add = TRUE)
[13:17:29.851]         }
[13:17:29.851]         {
[13:17:29.851]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.851]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.851]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.851]             })
[13:17:29.851]         }
[13:17:29.851]     }, args = future.call.arguments)
[13:17:29.851] }
[13:17:29.851] Lazy evaluation: FALSE
[13:17:29.851] Asynchronous evaluation: TRUE
[13:17:29.851] Local evaluation: TRUE
[13:17:29.851] Environment: R_GlobalEnv
[13:17:29.851] Capture standard output: TRUE
[13:17:29.851] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.851] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.851] Packages: <none>
[13:17:29.851] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.851] Resolved: TRUE
[13:17:29.851] Value: <not collected>
[13:17:29.851] Conditions captured: <none>
[13:17:29.851] Early signaling: FALSE
[13:17:29.851] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.851] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:29.861] Chunk #1 of 2 ... DONE
[13:17:29.861] Chunk #2 of 2 ...
[13:17:29.861]  - Finding globals in 'X' for chunk #2 ...
[13:17:29.862] getGlobalsAndPackages() ...
[13:17:29.862] Searching for globals...
[13:17:29.862] 
[13:17:29.863] Searching for globals ... DONE
[13:17:29.863] - globals: [0] <none>
[13:17:29.863] getGlobalsAndPackages() ... DONE
[13:17:29.863]    + additional globals found: [n=0] 
[13:17:29.863]    + additional namespaces needed: [n=0] 
[13:17:29.863]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:29.864]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:29.864]  - seeds: <none>
[13:17:29.864] getGlobalsAndPackages() ...
[13:17:29.864] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.864] Resolving globals: FALSE
[13:17:29.864] Tweak future expression to call with '...' arguments ...
[13:17:29.865] {
[13:17:29.865]     do.call(function(...) {
[13:17:29.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.865]             on.exit(options(oopts), add = TRUE)
[13:17:29.865]         }
[13:17:29.865]         {
[13:17:29.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.865]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.865]             })
[13:17:29.865]         }
[13:17:29.865]     }, args = future.call.arguments)
[13:17:29.865] }
[13:17:29.865] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.866] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.866] 
[13:17:29.866] getGlobalsAndPackages() ... DONE
[13:17:29.871] run() for ‘Future’ ...
[13:17:29.871] - state: ‘created’
[13:17:29.872] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.877] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:29.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:29.878]   - Field: ‘label’
[13:17:29.878]   - Field: ‘local’
[13:17:29.878]   - Field: ‘owner’
[13:17:29.878]   - Field: ‘envir’
[13:17:29.879]   - Field: ‘workers’
[13:17:29.879]   - Field: ‘packages’
[13:17:29.879]   - Field: ‘gc’
[13:17:29.879]   - Field: ‘job’
[13:17:29.880]   - Field: ‘conditions’
[13:17:29.880]   - Field: ‘expr’
[13:17:29.880]   - Field: ‘uuid’
[13:17:29.880]   - Field: ‘seed’
[13:17:29.880]   - Field: ‘version’
[13:17:29.881]   - Field: ‘result’
[13:17:29.881]   - Field: ‘asynchronous’
[13:17:29.881]   - Field: ‘calls’
[13:17:29.881]   - Field: ‘globals’
[13:17:29.881]   - Field: ‘stdout’
[13:17:29.881]   - Field: ‘earlySignal’
[13:17:29.881]   - Field: ‘lazy’
[13:17:29.882]   - Field: ‘state’
[13:17:29.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:29.882] - Launch lazy future ...
[13:17:29.882] Packages needed by the future expression (n = 0): <none>
[13:17:29.883] Packages needed by future strategies (n = 0): <none>
[13:17:29.884] {
[13:17:29.884]     {
[13:17:29.884]         {
[13:17:29.884]             ...future.startTime <- base::Sys.time()
[13:17:29.884]             {
[13:17:29.884]                 {
[13:17:29.884]                   {
[13:17:29.884]                     {
[13:17:29.884]                       base::local({
[13:17:29.884]                         has_future <- base::requireNamespace("future", 
[13:17:29.884]                           quietly = TRUE)
[13:17:29.884]                         if (has_future) {
[13:17:29.884]                           ns <- base::getNamespace("future")
[13:17:29.884]                           version <- ns[[".package"]][["version"]]
[13:17:29.884]                           if (is.null(version)) 
[13:17:29.884]                             version <- utils::packageVersion("future")
[13:17:29.884]                         }
[13:17:29.884]                         else {
[13:17:29.884]                           version <- NULL
[13:17:29.884]                         }
[13:17:29.884]                         if (!has_future || version < "1.8.0") {
[13:17:29.884]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.884]                             "", base::R.version$version.string), 
[13:17:29.884]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.884]                               "release", "version")], collapse = " "), 
[13:17:29.884]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.884]                             info)
[13:17:29.884]                           info <- base::paste(info, collapse = "; ")
[13:17:29.884]                           if (!has_future) {
[13:17:29.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.884]                               info)
[13:17:29.884]                           }
[13:17:29.884]                           else {
[13:17:29.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.884]                               info, version)
[13:17:29.884]                           }
[13:17:29.884]                           base::stop(msg)
[13:17:29.884]                         }
[13:17:29.884]                       })
[13:17:29.884]                     }
[13:17:29.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:29.884]                     base::options(mc.cores = 1L)
[13:17:29.884]                   }
[13:17:29.884]                   options(future.plan = NULL)
[13:17:29.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.884]                 }
[13:17:29.884]                 ...future.workdir <- getwd()
[13:17:29.884]             }
[13:17:29.884]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.884]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.884]         }
[13:17:29.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.884]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:29.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.884]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.884]             base::names(...future.oldOptions))
[13:17:29.884]     }
[13:17:29.884]     if (FALSE) {
[13:17:29.884]     }
[13:17:29.884]     else {
[13:17:29.884]         if (TRUE) {
[13:17:29.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.884]                 open = "w")
[13:17:29.884]         }
[13:17:29.884]         else {
[13:17:29.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.884]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.884]         }
[13:17:29.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.884]             base::sink(type = "output", split = FALSE)
[13:17:29.884]             base::close(...future.stdout)
[13:17:29.884]         }, add = TRUE)
[13:17:29.884]     }
[13:17:29.884]     ...future.frame <- base::sys.nframe()
[13:17:29.884]     ...future.conditions <- base::list()
[13:17:29.884]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.884]     if (FALSE) {
[13:17:29.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.884]     }
[13:17:29.884]     ...future.result <- base::tryCatch({
[13:17:29.884]         base::withCallingHandlers({
[13:17:29.884]             ...future.value <- base::withVisible(base::local({
[13:17:29.884]                 withCallingHandlers({
[13:17:29.884]                   {
[13:17:29.884]                     do.call(function(...) {
[13:17:29.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.884]                       if (!identical(...future.globals.maxSize.org, 
[13:17:29.884]                         ...future.globals.maxSize)) {
[13:17:29.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.884]                         on.exit(options(oopts), add = TRUE)
[13:17:29.884]                       }
[13:17:29.884]                       {
[13:17:29.884]                         lapply(seq_along(...future.elements_ii), 
[13:17:29.884]                           FUN = function(jj) {
[13:17:29.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.884]                             ...future.FUN(...future.X_jj, ...)
[13:17:29.884]                           })
[13:17:29.884]                       }
[13:17:29.884]                     }, args = future.call.arguments)
[13:17:29.884]                   }
[13:17:29.884]                 }, immediateCondition = function(cond) {
[13:17:29.884]                   save_rds <- function (object, pathname, ...) 
[13:17:29.884]                   {
[13:17:29.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:29.884]                     if (file_test("-f", pathname_tmp)) {
[13:17:29.884]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:29.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.884]                         fi_tmp[["mtime"]])
[13:17:29.884]                     }
[13:17:29.884]                     tryCatch({
[13:17:29.884]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:29.884]                     }, error = function(ex) {
[13:17:29.884]                       msg <- conditionMessage(ex)
[13:17:29.884]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:29.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.884]                         fi_tmp[["mtime"]], msg)
[13:17:29.884]                       ex$message <- msg
[13:17:29.884]                       stop(ex)
[13:17:29.884]                     })
[13:17:29.884]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:29.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:29.884]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:29.884]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.884]                       fi <- file.info(pathname)
[13:17:29.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:29.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:29.884]                         fi[["size"]], fi[["mtime"]])
[13:17:29.884]                       stop(msg)
[13:17:29.884]                     }
[13:17:29.884]                     invisible(pathname)
[13:17:29.884]                   }
[13:17:29.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:29.884]                     rootPath = tempdir()) 
[13:17:29.884]                   {
[13:17:29.884]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:29.884]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:29.884]                       tmpdir = path, fileext = ".rds")
[13:17:29.884]                     save_rds(obj, file)
[13:17:29.884]                   }
[13:17:29.884]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:29.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.884]                   {
[13:17:29.884]                     inherits <- base::inherits
[13:17:29.884]                     invokeRestart <- base::invokeRestart
[13:17:29.884]                     is.null <- base::is.null
[13:17:29.884]                     muffled <- FALSE
[13:17:29.884]                     if (inherits(cond, "message")) {
[13:17:29.884]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:29.884]                       if (muffled) 
[13:17:29.884]                         invokeRestart("muffleMessage")
[13:17:29.884]                     }
[13:17:29.884]                     else if (inherits(cond, "warning")) {
[13:17:29.884]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:29.884]                       if (muffled) 
[13:17:29.884]                         invokeRestart("muffleWarning")
[13:17:29.884]                     }
[13:17:29.884]                     else if (inherits(cond, "condition")) {
[13:17:29.884]                       if (!is.null(pattern)) {
[13:17:29.884]                         computeRestarts <- base::computeRestarts
[13:17:29.884]                         grepl <- base::grepl
[13:17:29.884]                         restarts <- computeRestarts(cond)
[13:17:29.884]                         for (restart in restarts) {
[13:17:29.884]                           name <- restart$name
[13:17:29.884]                           if (is.null(name)) 
[13:17:29.884]                             next
[13:17:29.884]                           if (!grepl(pattern, name)) 
[13:17:29.884]                             next
[13:17:29.884]                           invokeRestart(restart)
[13:17:29.884]                           muffled <- TRUE
[13:17:29.884]                           break
[13:17:29.884]                         }
[13:17:29.884]                       }
[13:17:29.884]                     }
[13:17:29.884]                     invisible(muffled)
[13:17:29.884]                   }
[13:17:29.884]                   muffleCondition(cond)
[13:17:29.884]                 })
[13:17:29.884]             }))
[13:17:29.884]             future::FutureResult(value = ...future.value$value, 
[13:17:29.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.884]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.884]                     ...future.globalenv.names))
[13:17:29.884]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.884]         }, condition = base::local({
[13:17:29.884]             c <- base::c
[13:17:29.884]             inherits <- base::inherits
[13:17:29.884]             invokeRestart <- base::invokeRestart
[13:17:29.884]             length <- base::length
[13:17:29.884]             list <- base::list
[13:17:29.884]             seq.int <- base::seq.int
[13:17:29.884]             signalCondition <- base::signalCondition
[13:17:29.884]             sys.calls <- base::sys.calls
[13:17:29.884]             `[[` <- base::`[[`
[13:17:29.884]             `+` <- base::`+`
[13:17:29.884]             `<<-` <- base::`<<-`
[13:17:29.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.884]                   3L)]
[13:17:29.884]             }
[13:17:29.884]             function(cond) {
[13:17:29.884]                 is_error <- inherits(cond, "error")
[13:17:29.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.884]                   NULL)
[13:17:29.884]                 if (is_error) {
[13:17:29.884]                   sessionInformation <- function() {
[13:17:29.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.884]                       search = base::search(), system = base::Sys.info())
[13:17:29.884]                   }
[13:17:29.884]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.884]                     cond$call), session = sessionInformation(), 
[13:17:29.884]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.884]                   signalCondition(cond)
[13:17:29.884]                 }
[13:17:29.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.884]                 "immediateCondition"))) {
[13:17:29.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.884]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.884]                   if (TRUE && !signal) {
[13:17:29.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.884]                     {
[13:17:29.884]                       inherits <- base::inherits
[13:17:29.884]                       invokeRestart <- base::invokeRestart
[13:17:29.884]                       is.null <- base::is.null
[13:17:29.884]                       muffled <- FALSE
[13:17:29.884]                       if (inherits(cond, "message")) {
[13:17:29.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.884]                         if (muffled) 
[13:17:29.884]                           invokeRestart("muffleMessage")
[13:17:29.884]                       }
[13:17:29.884]                       else if (inherits(cond, "warning")) {
[13:17:29.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.884]                         if (muffled) 
[13:17:29.884]                           invokeRestart("muffleWarning")
[13:17:29.884]                       }
[13:17:29.884]                       else if (inherits(cond, "condition")) {
[13:17:29.884]                         if (!is.null(pattern)) {
[13:17:29.884]                           computeRestarts <- base::computeRestarts
[13:17:29.884]                           grepl <- base::grepl
[13:17:29.884]                           restarts <- computeRestarts(cond)
[13:17:29.884]                           for (restart in restarts) {
[13:17:29.884]                             name <- restart$name
[13:17:29.884]                             if (is.null(name)) 
[13:17:29.884]                               next
[13:17:29.884]                             if (!grepl(pattern, name)) 
[13:17:29.884]                               next
[13:17:29.884]                             invokeRestart(restart)
[13:17:29.884]                             muffled <- TRUE
[13:17:29.884]                             break
[13:17:29.884]                           }
[13:17:29.884]                         }
[13:17:29.884]                       }
[13:17:29.884]                       invisible(muffled)
[13:17:29.884]                     }
[13:17:29.884]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.884]                   }
[13:17:29.884]                 }
[13:17:29.884]                 else {
[13:17:29.884]                   if (TRUE) {
[13:17:29.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.884]                     {
[13:17:29.884]                       inherits <- base::inherits
[13:17:29.884]                       invokeRestart <- base::invokeRestart
[13:17:29.884]                       is.null <- base::is.null
[13:17:29.884]                       muffled <- FALSE
[13:17:29.884]                       if (inherits(cond, "message")) {
[13:17:29.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.884]                         if (muffled) 
[13:17:29.884]                           invokeRestart("muffleMessage")
[13:17:29.884]                       }
[13:17:29.884]                       else if (inherits(cond, "warning")) {
[13:17:29.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.884]                         if (muffled) 
[13:17:29.884]                           invokeRestart("muffleWarning")
[13:17:29.884]                       }
[13:17:29.884]                       else if (inherits(cond, "condition")) {
[13:17:29.884]                         if (!is.null(pattern)) {
[13:17:29.884]                           computeRestarts <- base::computeRestarts
[13:17:29.884]                           grepl <- base::grepl
[13:17:29.884]                           restarts <- computeRestarts(cond)
[13:17:29.884]                           for (restart in restarts) {
[13:17:29.884]                             name <- restart$name
[13:17:29.884]                             if (is.null(name)) 
[13:17:29.884]                               next
[13:17:29.884]                             if (!grepl(pattern, name)) 
[13:17:29.884]                               next
[13:17:29.884]                             invokeRestart(restart)
[13:17:29.884]                             muffled <- TRUE
[13:17:29.884]                             break
[13:17:29.884]                           }
[13:17:29.884]                         }
[13:17:29.884]                       }
[13:17:29.884]                       invisible(muffled)
[13:17:29.884]                     }
[13:17:29.884]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.884]                   }
[13:17:29.884]                 }
[13:17:29.884]             }
[13:17:29.884]         }))
[13:17:29.884]     }, error = function(ex) {
[13:17:29.884]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.884]                 ...future.rng), started = ...future.startTime, 
[13:17:29.884]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.884]             version = "1.8"), class = "FutureResult")
[13:17:29.884]     }, finally = {
[13:17:29.884]         if (!identical(...future.workdir, getwd())) 
[13:17:29.884]             setwd(...future.workdir)
[13:17:29.884]         {
[13:17:29.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.884]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.884]             }
[13:17:29.884]             base::options(...future.oldOptions)
[13:17:29.884]             if (.Platform$OS.type == "windows") {
[13:17:29.884]                 old_names <- names(...future.oldEnvVars)
[13:17:29.884]                 envs <- base::Sys.getenv()
[13:17:29.884]                 names <- names(envs)
[13:17:29.884]                 common <- intersect(names, old_names)
[13:17:29.884]                 added <- setdiff(names, old_names)
[13:17:29.884]                 removed <- setdiff(old_names, names)
[13:17:29.884]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.884]                   envs[common]]
[13:17:29.884]                 NAMES <- toupper(changed)
[13:17:29.884]                 args <- list()
[13:17:29.884]                 for (kk in seq_along(NAMES)) {
[13:17:29.884]                   name <- changed[[kk]]
[13:17:29.884]                   NAME <- NAMES[[kk]]
[13:17:29.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.884]                     next
[13:17:29.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.884]                 }
[13:17:29.884]                 NAMES <- toupper(added)
[13:17:29.884]                 for (kk in seq_along(NAMES)) {
[13:17:29.884]                   name <- added[[kk]]
[13:17:29.884]                   NAME <- NAMES[[kk]]
[13:17:29.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.884]                     next
[13:17:29.884]                   args[[name]] <- ""
[13:17:29.884]                 }
[13:17:29.884]                 NAMES <- toupper(removed)
[13:17:29.884]                 for (kk in seq_along(NAMES)) {
[13:17:29.884]                   name <- removed[[kk]]
[13:17:29.884]                   NAME <- NAMES[[kk]]
[13:17:29.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.884]                     next
[13:17:29.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.884]                 }
[13:17:29.884]                 if (length(args) > 0) 
[13:17:29.884]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.884]             }
[13:17:29.884]             else {
[13:17:29.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.884]             }
[13:17:29.884]             {
[13:17:29.884]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.884]                   0L) {
[13:17:29.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.884]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.884]                   base::options(opts)
[13:17:29.884]                 }
[13:17:29.884]                 {
[13:17:29.884]                   {
[13:17:29.884]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:29.884]                     NULL
[13:17:29.884]                   }
[13:17:29.884]                   options(future.plan = NULL)
[13:17:29.884]                   if (is.na(NA_character_)) 
[13:17:29.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.884]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:29.884]                     envir = parent.frame()) 
[13:17:29.884]                   {
[13:17:29.884]                     default_workers <- missing(workers)
[13:17:29.884]                     if (is.function(workers)) 
[13:17:29.884]                       workers <- workers()
[13:17:29.884]                     workers <- structure(as.integer(workers), 
[13:17:29.884]                       class = class(workers))
[13:17:29.884]                     stop_if_not(is.finite(workers), workers >= 
[13:17:29.884]                       1L)
[13:17:29.884]                     if ((workers == 1L && !inherits(workers, 
[13:17:29.884]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:29.884]                       if (default_workers) 
[13:17:29.884]                         supportsMulticore(warn = TRUE)
[13:17:29.884]                       return(sequential(..., envir = envir))
[13:17:29.884]                     }
[13:17:29.884]                     oopts <- options(mc.cores = workers)
[13:17:29.884]                     on.exit(options(oopts))
[13:17:29.884]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:29.884]                       envir = envir)
[13:17:29.884]                     if (!future$lazy) 
[13:17:29.884]                       future <- run(future)
[13:17:29.884]                     invisible(future)
[13:17:29.884]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.884]                 }
[13:17:29.884]             }
[13:17:29.884]         }
[13:17:29.884]     })
[13:17:29.884]     if (TRUE) {
[13:17:29.884]         base::sink(type = "output", split = FALSE)
[13:17:29.884]         if (TRUE) {
[13:17:29.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.884]         }
[13:17:29.884]         else {
[13:17:29.884]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.884]         }
[13:17:29.884]         base::close(...future.stdout)
[13:17:29.884]         ...future.stdout <- NULL
[13:17:29.884]     }
[13:17:29.884]     ...future.result$conditions <- ...future.conditions
[13:17:29.884]     ...future.result$finished <- base::Sys.time()
[13:17:29.884]     ...future.result
[13:17:29.884] }
[13:17:29.887] assign_globals() ...
[13:17:29.887] List of 5
[13:17:29.887]  $ ...future.FUN            :function (object, ...)  
[13:17:29.887]  $ future.call.arguments    : list()
[13:17:29.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.887]  $ ...future.elements_ii    :List of 2
[13:17:29.887]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.887]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:29.887]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.887]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:17:29.887]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:29.887]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:29.887]  $ ...future.seeds_ii       : NULL
[13:17:29.887]  $ ...future.globals.maxSize: NULL
[13:17:29.887]  - attr(*, "resolved")= logi FALSE
[13:17:29.887]  - attr(*, "total_size")= num 1240
[13:17:29.887]  - attr(*, "where")=List of 5
[13:17:29.887]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.887]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.887]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.887]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.887]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.887]  - attr(*, "already-done")= logi TRUE
[13:17:29.896] - copied ‘...future.FUN’ to environment
[13:17:29.896] - copied ‘future.call.arguments’ to environment
[13:17:29.896] - copied ‘...future.elements_ii’ to environment
[13:17:29.896] - copied ‘...future.seeds_ii’ to environment
[13:17:29.896] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.896] assign_globals() ... done
[13:17:29.896] requestCore(): workers = 2
[13:17:29.901] MulticoreFuture started
[13:17:29.901] - Launch lazy future ... done
[13:17:29.901] run() for ‘MulticoreFuture’ ... done
[13:17:29.902] Created future:
[13:17:29.902] plan(): Setting new future strategy stack:
[13:17:29.902] List of future strategies:
[13:17:29.902] 1. sequential:
[13:17:29.902]    - args: function (..., envir = parent.frame())
[13:17:29.902]    - tweaked: FALSE
[13:17:29.902]    - call: NULL
[13:17:29.903] plan(): nbrOfWorkers() = 1
[13:17:29.915] plan(): Setting new future strategy stack:
[13:17:29.915] List of future strategies:
[13:17:29.915] 1. multicore:
[13:17:29.915]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.915]    - tweaked: FALSE
[13:17:29.915]    - call: plan(strategy)
[13:17:29.920] plan(): nbrOfWorkers() = 2
[13:17:29.902] MulticoreFuture:
[13:17:29.902] Label: ‘future_by-2’
[13:17:29.902] Expression:
[13:17:29.902] {
[13:17:29.902]     do.call(function(...) {
[13:17:29.902]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.902]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.902]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.902]             on.exit(options(oopts), add = TRUE)
[13:17:29.902]         }
[13:17:29.902]         {
[13:17:29.902]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.902]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.902]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.902]             })
[13:17:29.902]         }
[13:17:29.902]     }, args = future.call.arguments)
[13:17:29.902] }
[13:17:29.902] Lazy evaluation: FALSE
[13:17:29.902] Asynchronous evaluation: TRUE
[13:17:29.902] Local evaluation: TRUE
[13:17:29.902] Environment: R_GlobalEnv
[13:17:29.902] Capture standard output: TRUE
[13:17:29.902] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.902] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.902] Packages: <none>
[13:17:29.902] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.902] Resolved: TRUE
[13:17:29.902] Value: <not collected>
[13:17:29.902] Conditions captured: <none>
[13:17:29.902] Early signaling: FALSE
[13:17:29.902] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.902] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:29.921] Chunk #2 of 2 ... DONE
[13:17:29.922] Launching 2 futures (chunks) ... DONE
[13:17:29.922] Resolving 2 futures (chunks) ...
[13:17:29.922] resolve() on list ...
[13:17:29.922]  recursive: 0
[13:17:29.922]  length: 2
[13:17:29.922] 
[13:17:29.922] Future #1
[13:17:29.925] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:29.925] - nx: 2
[13:17:29.925] - relay: TRUE
[13:17:29.925] - stdout: TRUE
[13:17:29.925] - signal: TRUE
[13:17:29.925] - resignal: FALSE
[13:17:29.926] - force: TRUE
[13:17:29.926] - relayed: [n=2] FALSE, FALSE
[13:17:29.926] - queued futures: [n=2] FALSE, FALSE
[13:17:29.926]  - until=1
[13:17:29.926]  - relaying element #1
[13:17:29.927] - relayed: [n=2] TRUE, FALSE
[13:17:29.927] - queued futures: [n=2] TRUE, FALSE
[13:17:29.927] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:29.927]  length: 1 (resolved future 1)
[13:17:29.928] Future #2
[13:17:29.929] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:29.929] - nx: 2
[13:17:29.929] - relay: TRUE
[13:17:29.929] - stdout: TRUE
[13:17:29.929] - signal: TRUE
[13:17:29.929] - resignal: FALSE
[13:17:29.930] - force: TRUE
[13:17:29.930] - relayed: [n=2] TRUE, FALSE
[13:17:29.930] - queued futures: [n=2] TRUE, FALSE
[13:17:29.930]  - until=2
[13:17:29.930]  - relaying element #2
[13:17:29.930] - relayed: [n=2] TRUE, TRUE
[13:17:29.930] - queued futures: [n=2] TRUE, TRUE
[13:17:29.931] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:29.931]  length: 0 (resolved future 2)
[13:17:29.931] Relaying remaining futures
[13:17:29.931] signalConditionsASAP(NULL, pos=0) ...
[13:17:29.931] - nx: 2
[13:17:29.931] - relay: TRUE
[13:17:29.931] - stdout: TRUE
[13:17:29.931] - signal: TRUE
[13:17:29.931] - resignal: FALSE
[13:17:29.932] - force: TRUE
[13:17:29.932] - relayed: [n=2] TRUE, TRUE
[13:17:29.932] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:29.932] - relayed: [n=2] TRUE, TRUE
[13:17:29.932] - queued futures: [n=2] TRUE, TRUE
[13:17:29.932] signalConditionsASAP(NULL, pos=0) ... done
[13:17:29.932] resolve() on list ... DONE
[13:17:29.932]  - Number of value chunks collected: 2
[13:17:29.933] Resolving 2 futures (chunks) ... DONE
[13:17:29.933] Reducing values from 2 chunks ...
[13:17:29.933]  - Number of values collected after concatenation: 3
[13:17:29.933]  - Number of values expected: 3
[13:17:29.933] Reducing values from 2 chunks ... DONE
[13:17:29.933] future_lapply() ... DONE
[13:17:29.933] future_by_internal() ... DONE
[13:17:29.934] future_by_internal() ...
[13:17:29.934] future_lapply() ...
[13:17:29.939] Number of chunks: 2
[13:17:29.939] getGlobalsAndPackagesXApply() ...
[13:17:29.939]  - future.globals: TRUE
[13:17:29.939] getGlobalsAndPackages() ...
[13:17:29.939] Searching for globals...
[13:17:29.940] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:29.940] Searching for globals ... DONE
[13:17:29.940] Resolving globals: FALSE
[13:17:29.941] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:29.941] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:29.941] - globals: [1] ‘FUN’
[13:17:29.942] 
[13:17:29.942] getGlobalsAndPackages() ... DONE
[13:17:29.942]  - globals found/used: [n=1] ‘FUN’
[13:17:29.942]  - needed namespaces: [n=0] 
[13:17:29.942] Finding globals ... DONE
[13:17:29.942]  - use_args: TRUE
[13:17:29.942]  - Getting '...' globals ...
[13:17:29.942] resolve() on list ...
[13:17:29.943]  recursive: 0
[13:17:29.943]  length: 1
[13:17:29.943]  elements: ‘...’
[13:17:29.943]  length: 0 (resolved future 1)
[13:17:29.943] resolve() on list ... DONE
[13:17:29.943]    - '...' content: [n=1] ‘digits’
[13:17:29.943] List of 1
[13:17:29.943]  $ ...:List of 1
[13:17:29.943]   ..$ digits: int 2
[13:17:29.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.943]  - attr(*, "where")=List of 1
[13:17:29.943]   ..$ ...:<environment: 0x5609e8da7d70> 
[13:17:29.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.943]  - attr(*, "resolved")= logi TRUE
[13:17:29.943]  - attr(*, "total_size")= num NA
[13:17:29.946]  - Getting '...' globals ... DONE
[13:17:29.947] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:29.947] List of 2
[13:17:29.947]  $ ...future.FUN:function (object, ...)  
[13:17:29.947]  $ ...          :List of 1
[13:17:29.947]   ..$ digits: int 2
[13:17:29.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.947]  - attr(*, "where")=List of 2
[13:17:29.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:29.947]   ..$ ...          :<environment: 0x5609e8da7d70> 
[13:17:29.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.947]  - attr(*, "resolved")= logi FALSE
[13:17:29.947]  - attr(*, "total_size")= num 1296
[13:17:29.952] Packages to be attached in all futures: [n=0] 
[13:17:29.952] getGlobalsAndPackagesXApply() ... DONE
[13:17:29.952] Number of futures (= number of chunks): 2
[13:17:29.952] Launching 2 futures (chunks) ...
[13:17:29.952] Chunk #1 of 2 ...
[13:17:29.953]  - Finding globals in 'X' for chunk #1 ...
[13:17:29.953] getGlobalsAndPackages() ...
[13:17:29.953] Searching for globals...
[13:17:29.953] 
[13:17:29.953] Searching for globals ... DONE
[13:17:29.953] - globals: [0] <none>
[13:17:29.953] getGlobalsAndPackages() ... DONE
[13:17:29.954]    + additional globals found: [n=0] 
[13:17:29.954]    + additional namespaces needed: [n=0] 
[13:17:29.954]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:29.954]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.954]  - seeds: <none>
[13:17:29.954] getGlobalsAndPackages() ...
[13:17:29.954] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.954] Resolving globals: FALSE
[13:17:29.954] Tweak future expression to call with '...' arguments ...
[13:17:29.955] {
[13:17:29.955]     do.call(function(...) {
[13:17:29.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.955]             on.exit(options(oopts), add = TRUE)
[13:17:29.955]         }
[13:17:29.955]         {
[13:17:29.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.955]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.955]             })
[13:17:29.955]         }
[13:17:29.955]     }, args = future.call.arguments)
[13:17:29.955] }
[13:17:29.955] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.955] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.955] 
[13:17:29.955] getGlobalsAndPackages() ... DONE
[13:17:29.956] run() for ‘Future’ ...
[13:17:29.956] - state: ‘created’
[13:17:29.956] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:29.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:29.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:29.960]   - Field: ‘label’
[13:17:29.960]   - Field: ‘local’
[13:17:29.960]   - Field: ‘owner’
[13:17:29.960]   - Field: ‘envir’
[13:17:29.960]   - Field: ‘workers’
[13:17:29.960]   - Field: ‘packages’
[13:17:29.960]   - Field: ‘gc’
[13:17:29.960]   - Field: ‘job’
[13:17:29.960]   - Field: ‘conditions’
[13:17:29.960]   - Field: ‘expr’
[13:17:29.961]   - Field: ‘uuid’
[13:17:29.961]   - Field: ‘seed’
[13:17:29.961]   - Field: ‘version’
[13:17:29.961]   - Field: ‘result’
[13:17:29.961]   - Field: ‘asynchronous’
[13:17:29.961]   - Field: ‘calls’
[13:17:29.961]   - Field: ‘globals’
[13:17:29.961]   - Field: ‘stdout’
[13:17:29.961]   - Field: ‘earlySignal’
[13:17:29.961]   - Field: ‘lazy’
[13:17:29.962]   - Field: ‘state’
[13:17:29.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:29.962] - Launch lazy future ...
[13:17:29.962] Packages needed by the future expression (n = 0): <none>
[13:17:29.962] Packages needed by future strategies (n = 0): <none>
[13:17:29.963] {
[13:17:29.963]     {
[13:17:29.963]         {
[13:17:29.963]             ...future.startTime <- base::Sys.time()
[13:17:29.963]             {
[13:17:29.963]                 {
[13:17:29.963]                   {
[13:17:29.963]                     {
[13:17:29.963]                       base::local({
[13:17:29.963]                         has_future <- base::requireNamespace("future", 
[13:17:29.963]                           quietly = TRUE)
[13:17:29.963]                         if (has_future) {
[13:17:29.963]                           ns <- base::getNamespace("future")
[13:17:29.963]                           version <- ns[[".package"]][["version"]]
[13:17:29.963]                           if (is.null(version)) 
[13:17:29.963]                             version <- utils::packageVersion("future")
[13:17:29.963]                         }
[13:17:29.963]                         else {
[13:17:29.963]                           version <- NULL
[13:17:29.963]                         }
[13:17:29.963]                         if (!has_future || version < "1.8.0") {
[13:17:29.963]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:29.963]                             "", base::R.version$version.string), 
[13:17:29.963]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:29.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:29.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:29.963]                               "release", "version")], collapse = " "), 
[13:17:29.963]                             hostname = base::Sys.info()[["nodename"]])
[13:17:29.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:29.963]                             info)
[13:17:29.963]                           info <- base::paste(info, collapse = "; ")
[13:17:29.963]                           if (!has_future) {
[13:17:29.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:29.963]                               info)
[13:17:29.963]                           }
[13:17:29.963]                           else {
[13:17:29.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:29.963]                               info, version)
[13:17:29.963]                           }
[13:17:29.963]                           base::stop(msg)
[13:17:29.963]                         }
[13:17:29.963]                       })
[13:17:29.963]                     }
[13:17:29.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:29.963]                     base::options(mc.cores = 1L)
[13:17:29.963]                   }
[13:17:29.963]                   options(future.plan = NULL)
[13:17:29.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:29.963]                 }
[13:17:29.963]                 ...future.workdir <- getwd()
[13:17:29.963]             }
[13:17:29.963]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:29.963]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:29.963]         }
[13:17:29.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:29.963]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:29.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:29.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:29.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:29.963]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:29.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:29.963]             base::names(...future.oldOptions))
[13:17:29.963]     }
[13:17:29.963]     if (FALSE) {
[13:17:29.963]     }
[13:17:29.963]     else {
[13:17:29.963]         if (TRUE) {
[13:17:29.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:29.963]                 open = "w")
[13:17:29.963]         }
[13:17:29.963]         else {
[13:17:29.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:29.963]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:29.963]         }
[13:17:29.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:29.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:29.963]             base::sink(type = "output", split = FALSE)
[13:17:29.963]             base::close(...future.stdout)
[13:17:29.963]         }, add = TRUE)
[13:17:29.963]     }
[13:17:29.963]     ...future.frame <- base::sys.nframe()
[13:17:29.963]     ...future.conditions <- base::list()
[13:17:29.963]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:29.963]     if (FALSE) {
[13:17:29.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:29.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:29.963]     }
[13:17:29.963]     ...future.result <- base::tryCatch({
[13:17:29.963]         base::withCallingHandlers({
[13:17:29.963]             ...future.value <- base::withVisible(base::local({
[13:17:29.963]                 withCallingHandlers({
[13:17:29.963]                   {
[13:17:29.963]                     do.call(function(...) {
[13:17:29.963]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.963]                       if (!identical(...future.globals.maxSize.org, 
[13:17:29.963]                         ...future.globals.maxSize)) {
[13:17:29.963]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.963]                         on.exit(options(oopts), add = TRUE)
[13:17:29.963]                       }
[13:17:29.963]                       {
[13:17:29.963]                         lapply(seq_along(...future.elements_ii), 
[13:17:29.963]                           FUN = function(jj) {
[13:17:29.963]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.963]                             ...future.FUN(...future.X_jj, ...)
[13:17:29.963]                           })
[13:17:29.963]                       }
[13:17:29.963]                     }, args = future.call.arguments)
[13:17:29.963]                   }
[13:17:29.963]                 }, immediateCondition = function(cond) {
[13:17:29.963]                   save_rds <- function (object, pathname, ...) 
[13:17:29.963]                   {
[13:17:29.963]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:29.963]                     if (file_test("-f", pathname_tmp)) {
[13:17:29.963]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.963]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:29.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.963]                         fi_tmp[["mtime"]])
[13:17:29.963]                     }
[13:17:29.963]                     tryCatch({
[13:17:29.963]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:29.963]                     }, error = function(ex) {
[13:17:29.963]                       msg <- conditionMessage(ex)
[13:17:29.963]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.963]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:29.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.963]                         fi_tmp[["mtime"]], msg)
[13:17:29.963]                       ex$message <- msg
[13:17:29.963]                       stop(ex)
[13:17:29.963]                     })
[13:17:29.963]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:29.963]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:29.963]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:29.963]                       fi_tmp <- file.info(pathname_tmp)
[13:17:29.963]                       fi <- file.info(pathname)
[13:17:29.963]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:29.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:29.963]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:29.963]                         fi[["size"]], fi[["mtime"]])
[13:17:29.963]                       stop(msg)
[13:17:29.963]                     }
[13:17:29.963]                     invisible(pathname)
[13:17:29.963]                   }
[13:17:29.963]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:29.963]                     rootPath = tempdir()) 
[13:17:29.963]                   {
[13:17:29.963]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:29.963]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:29.963]                       tmpdir = path, fileext = ".rds")
[13:17:29.963]                     save_rds(obj, file)
[13:17:29.963]                   }
[13:17:29.963]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:29.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.963]                   {
[13:17:29.963]                     inherits <- base::inherits
[13:17:29.963]                     invokeRestart <- base::invokeRestart
[13:17:29.963]                     is.null <- base::is.null
[13:17:29.963]                     muffled <- FALSE
[13:17:29.963]                     if (inherits(cond, "message")) {
[13:17:29.963]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:29.963]                       if (muffled) 
[13:17:29.963]                         invokeRestart("muffleMessage")
[13:17:29.963]                     }
[13:17:29.963]                     else if (inherits(cond, "warning")) {
[13:17:29.963]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:29.963]                       if (muffled) 
[13:17:29.963]                         invokeRestart("muffleWarning")
[13:17:29.963]                     }
[13:17:29.963]                     else if (inherits(cond, "condition")) {
[13:17:29.963]                       if (!is.null(pattern)) {
[13:17:29.963]                         computeRestarts <- base::computeRestarts
[13:17:29.963]                         grepl <- base::grepl
[13:17:29.963]                         restarts <- computeRestarts(cond)
[13:17:29.963]                         for (restart in restarts) {
[13:17:29.963]                           name <- restart$name
[13:17:29.963]                           if (is.null(name)) 
[13:17:29.963]                             next
[13:17:29.963]                           if (!grepl(pattern, name)) 
[13:17:29.963]                             next
[13:17:29.963]                           invokeRestart(restart)
[13:17:29.963]                           muffled <- TRUE
[13:17:29.963]                           break
[13:17:29.963]                         }
[13:17:29.963]                       }
[13:17:29.963]                     }
[13:17:29.963]                     invisible(muffled)
[13:17:29.963]                   }
[13:17:29.963]                   muffleCondition(cond)
[13:17:29.963]                 })
[13:17:29.963]             }))
[13:17:29.963]             future::FutureResult(value = ...future.value$value, 
[13:17:29.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.963]                   ...future.rng), globalenv = if (FALSE) 
[13:17:29.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:29.963]                     ...future.globalenv.names))
[13:17:29.963]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:29.963]         }, condition = base::local({
[13:17:29.963]             c <- base::c
[13:17:29.963]             inherits <- base::inherits
[13:17:29.963]             invokeRestart <- base::invokeRestart
[13:17:29.963]             length <- base::length
[13:17:29.963]             list <- base::list
[13:17:29.963]             seq.int <- base::seq.int
[13:17:29.963]             signalCondition <- base::signalCondition
[13:17:29.963]             sys.calls <- base::sys.calls
[13:17:29.963]             `[[` <- base::`[[`
[13:17:29.963]             `+` <- base::`+`
[13:17:29.963]             `<<-` <- base::`<<-`
[13:17:29.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:29.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:29.963]                   3L)]
[13:17:29.963]             }
[13:17:29.963]             function(cond) {
[13:17:29.963]                 is_error <- inherits(cond, "error")
[13:17:29.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:29.963]                   NULL)
[13:17:29.963]                 if (is_error) {
[13:17:29.963]                   sessionInformation <- function() {
[13:17:29.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:29.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:29.963]                       search = base::search(), system = base::Sys.info())
[13:17:29.963]                   }
[13:17:29.963]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:29.963]                     cond$call), session = sessionInformation(), 
[13:17:29.963]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:29.963]                   signalCondition(cond)
[13:17:29.963]                 }
[13:17:29.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:29.963]                 "immediateCondition"))) {
[13:17:29.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:29.963]                   ...future.conditions[[length(...future.conditions) + 
[13:17:29.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:29.963]                   if (TRUE && !signal) {
[13:17:29.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.963]                     {
[13:17:29.963]                       inherits <- base::inherits
[13:17:29.963]                       invokeRestart <- base::invokeRestart
[13:17:29.963]                       is.null <- base::is.null
[13:17:29.963]                       muffled <- FALSE
[13:17:29.963]                       if (inherits(cond, "message")) {
[13:17:29.963]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.963]                         if (muffled) 
[13:17:29.963]                           invokeRestart("muffleMessage")
[13:17:29.963]                       }
[13:17:29.963]                       else if (inherits(cond, "warning")) {
[13:17:29.963]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.963]                         if (muffled) 
[13:17:29.963]                           invokeRestart("muffleWarning")
[13:17:29.963]                       }
[13:17:29.963]                       else if (inherits(cond, "condition")) {
[13:17:29.963]                         if (!is.null(pattern)) {
[13:17:29.963]                           computeRestarts <- base::computeRestarts
[13:17:29.963]                           grepl <- base::grepl
[13:17:29.963]                           restarts <- computeRestarts(cond)
[13:17:29.963]                           for (restart in restarts) {
[13:17:29.963]                             name <- restart$name
[13:17:29.963]                             if (is.null(name)) 
[13:17:29.963]                               next
[13:17:29.963]                             if (!grepl(pattern, name)) 
[13:17:29.963]                               next
[13:17:29.963]                             invokeRestart(restart)
[13:17:29.963]                             muffled <- TRUE
[13:17:29.963]                             break
[13:17:29.963]                           }
[13:17:29.963]                         }
[13:17:29.963]                       }
[13:17:29.963]                       invisible(muffled)
[13:17:29.963]                     }
[13:17:29.963]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.963]                   }
[13:17:29.963]                 }
[13:17:29.963]                 else {
[13:17:29.963]                   if (TRUE) {
[13:17:29.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:29.963]                     {
[13:17:29.963]                       inherits <- base::inherits
[13:17:29.963]                       invokeRestart <- base::invokeRestart
[13:17:29.963]                       is.null <- base::is.null
[13:17:29.963]                       muffled <- FALSE
[13:17:29.963]                       if (inherits(cond, "message")) {
[13:17:29.963]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:29.963]                         if (muffled) 
[13:17:29.963]                           invokeRestart("muffleMessage")
[13:17:29.963]                       }
[13:17:29.963]                       else if (inherits(cond, "warning")) {
[13:17:29.963]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:29.963]                         if (muffled) 
[13:17:29.963]                           invokeRestart("muffleWarning")
[13:17:29.963]                       }
[13:17:29.963]                       else if (inherits(cond, "condition")) {
[13:17:29.963]                         if (!is.null(pattern)) {
[13:17:29.963]                           computeRestarts <- base::computeRestarts
[13:17:29.963]                           grepl <- base::grepl
[13:17:29.963]                           restarts <- computeRestarts(cond)
[13:17:29.963]                           for (restart in restarts) {
[13:17:29.963]                             name <- restart$name
[13:17:29.963]                             if (is.null(name)) 
[13:17:29.963]                               next
[13:17:29.963]                             if (!grepl(pattern, name)) 
[13:17:29.963]                               next
[13:17:29.963]                             invokeRestart(restart)
[13:17:29.963]                             muffled <- TRUE
[13:17:29.963]                             break
[13:17:29.963]                           }
[13:17:29.963]                         }
[13:17:29.963]                       }
[13:17:29.963]                       invisible(muffled)
[13:17:29.963]                     }
[13:17:29.963]                     muffleCondition(cond, pattern = "^muffle")
[13:17:29.963]                   }
[13:17:29.963]                 }
[13:17:29.963]             }
[13:17:29.963]         }))
[13:17:29.963]     }, error = function(ex) {
[13:17:29.963]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:29.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:29.963]                 ...future.rng), started = ...future.startTime, 
[13:17:29.963]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:29.963]             version = "1.8"), class = "FutureResult")
[13:17:29.963]     }, finally = {
[13:17:29.963]         if (!identical(...future.workdir, getwd())) 
[13:17:29.963]             setwd(...future.workdir)
[13:17:29.963]         {
[13:17:29.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:29.963]                 ...future.oldOptions$nwarnings <- NULL
[13:17:29.963]             }
[13:17:29.963]             base::options(...future.oldOptions)
[13:17:29.963]             if (.Platform$OS.type == "windows") {
[13:17:29.963]                 old_names <- names(...future.oldEnvVars)
[13:17:29.963]                 envs <- base::Sys.getenv()
[13:17:29.963]                 names <- names(envs)
[13:17:29.963]                 common <- intersect(names, old_names)
[13:17:29.963]                 added <- setdiff(names, old_names)
[13:17:29.963]                 removed <- setdiff(old_names, names)
[13:17:29.963]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:29.963]                   envs[common]]
[13:17:29.963]                 NAMES <- toupper(changed)
[13:17:29.963]                 args <- list()
[13:17:29.963]                 for (kk in seq_along(NAMES)) {
[13:17:29.963]                   name <- changed[[kk]]
[13:17:29.963]                   NAME <- NAMES[[kk]]
[13:17:29.963]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.963]                     next
[13:17:29.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.963]                 }
[13:17:29.963]                 NAMES <- toupper(added)
[13:17:29.963]                 for (kk in seq_along(NAMES)) {
[13:17:29.963]                   name <- added[[kk]]
[13:17:29.963]                   NAME <- NAMES[[kk]]
[13:17:29.963]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.963]                     next
[13:17:29.963]                   args[[name]] <- ""
[13:17:29.963]                 }
[13:17:29.963]                 NAMES <- toupper(removed)
[13:17:29.963]                 for (kk in seq_along(NAMES)) {
[13:17:29.963]                   name <- removed[[kk]]
[13:17:29.963]                   NAME <- NAMES[[kk]]
[13:17:29.963]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:29.963]                     next
[13:17:29.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:29.963]                 }
[13:17:29.963]                 if (length(args) > 0) 
[13:17:29.963]                   base::do.call(base::Sys.setenv, args = args)
[13:17:29.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:29.963]             }
[13:17:29.963]             else {
[13:17:29.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:29.963]             }
[13:17:29.963]             {
[13:17:29.963]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:29.963]                   0L) {
[13:17:29.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:29.963]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:29.963]                   base::options(opts)
[13:17:29.963]                 }
[13:17:29.963]                 {
[13:17:29.963]                   {
[13:17:29.963]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:29.963]                     NULL
[13:17:29.963]                   }
[13:17:29.963]                   options(future.plan = NULL)
[13:17:29.963]                   if (is.na(NA_character_)) 
[13:17:29.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:29.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:29.963]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:29.963]                     envir = parent.frame()) 
[13:17:29.963]                   {
[13:17:29.963]                     default_workers <- missing(workers)
[13:17:29.963]                     if (is.function(workers)) 
[13:17:29.963]                       workers <- workers()
[13:17:29.963]                     workers <- structure(as.integer(workers), 
[13:17:29.963]                       class = class(workers))
[13:17:29.963]                     stop_if_not(is.finite(workers), workers >= 
[13:17:29.963]                       1L)
[13:17:29.963]                     if ((workers == 1L && !inherits(workers, 
[13:17:29.963]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:29.963]                       if (default_workers) 
[13:17:29.963]                         supportsMulticore(warn = TRUE)
[13:17:29.963]                       return(sequential(..., envir = envir))
[13:17:29.963]                     }
[13:17:29.963]                     oopts <- options(mc.cores = workers)
[13:17:29.963]                     on.exit(options(oopts))
[13:17:29.963]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:29.963]                       envir = envir)
[13:17:29.963]                     if (!future$lazy) 
[13:17:29.963]                       future <- run(future)
[13:17:29.963]                     invisible(future)
[13:17:29.963]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:29.963]                 }
[13:17:29.963]             }
[13:17:29.963]         }
[13:17:29.963]     })
[13:17:29.963]     if (TRUE) {
[13:17:29.963]         base::sink(type = "output", split = FALSE)
[13:17:29.963]         if (TRUE) {
[13:17:29.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:29.963]         }
[13:17:29.963]         else {
[13:17:29.963]             ...future.result["stdout"] <- base::list(NULL)
[13:17:29.963]         }
[13:17:29.963]         base::close(...future.stdout)
[13:17:29.963]         ...future.stdout <- NULL
[13:17:29.963]     }
[13:17:29.963]     ...future.result$conditions <- ...future.conditions
[13:17:29.963]     ...future.result$finished <- base::Sys.time()
[13:17:29.963]     ...future.result
[13:17:29.963] }
[13:17:29.965] assign_globals() ...
[13:17:29.965] List of 5
[13:17:29.965]  $ ...future.FUN            :function (object, ...)  
[13:17:29.965]  $ future.call.arguments    :List of 1
[13:17:29.965]   ..$ digits: int 2
[13:17:29.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:29.965]  $ ...future.elements_ii    :List of 3
[13:17:29.965]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:17:29.965]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:17:29.965]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:17:29.965]  $ ...future.seeds_ii       : NULL
[13:17:29.965]  $ ...future.globals.maxSize: NULL
[13:17:29.965]  - attr(*, "resolved")= logi FALSE
[13:17:29.965]  - attr(*, "total_size")= num 1296
[13:17:29.965]  - attr(*, "where")=List of 5
[13:17:29.965]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:29.965]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:29.965]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:29.965]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:29.965]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:29.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:29.965]  - attr(*, "already-done")= logi TRUE
[13:17:29.971] - copied ‘...future.FUN’ to environment
[13:17:29.971] - copied ‘future.call.arguments’ to environment
[13:17:29.971] - copied ‘...future.elements_ii’ to environment
[13:17:29.971] - copied ‘...future.seeds_ii’ to environment
[13:17:29.971] - copied ‘...future.globals.maxSize’ to environment
[13:17:29.973] assign_globals() ... done
[13:17:29.973] requestCore(): workers = 2
[13:17:29.975] MulticoreFuture started
[13:17:29.976] - Launch lazy future ... done
[13:17:29.976] plan(): Setting new future strategy stack:
[13:17:29.976] run() for ‘MulticoreFuture’ ... done
[13:17:29.977] Created future:
[13:17:29.977] List of future strategies:
[13:17:29.977] 1. sequential:
[13:17:29.977]    - args: function (..., envir = parent.frame())
[13:17:29.977]    - tweaked: FALSE
[13:17:29.977]    - call: NULL
[13:17:29.978] plan(): nbrOfWorkers() = 1
[13:17:29.982] plan(): Setting new future strategy stack:
[13:17:29.982] List of future strategies:
[13:17:29.982] 1. multicore:
[13:17:29.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:29.982]    - tweaked: FALSE
[13:17:29.982]    - call: plan(strategy)
[13:17:29.988] plan(): nbrOfWorkers() = 2
[13:17:29.977] MulticoreFuture:
[13:17:29.977] Label: ‘future_by-1’
[13:17:29.977] Expression:
[13:17:29.977] {
[13:17:29.977]     do.call(function(...) {
[13:17:29.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.977]             on.exit(options(oopts), add = TRUE)
[13:17:29.977]         }
[13:17:29.977]         {
[13:17:29.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.977]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.977]             })
[13:17:29.977]         }
[13:17:29.977]     }, args = future.call.arguments)
[13:17:29.977] }
[13:17:29.977] Lazy evaluation: FALSE
[13:17:29.977] Asynchronous evaluation: TRUE
[13:17:29.977] Local evaluation: TRUE
[13:17:29.977] Environment: R_GlobalEnv
[13:17:29.977] Capture standard output: TRUE
[13:17:29.977] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:29.977] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:29.977] Packages: <none>
[13:17:29.977] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:29.977] Resolved: TRUE
[13:17:29.977] Value: <not collected>
[13:17:29.977] Conditions captured: <none>
[13:17:29.977] Early signaling: FALSE
[13:17:29.977] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:29.977] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:29.989] Chunk #1 of 2 ... DONE
[13:17:29.990] Chunk #2 of 2 ...
[13:17:29.990]  - Finding globals in 'X' for chunk #2 ...
[13:17:29.990] getGlobalsAndPackages() ...
[13:17:29.990] Searching for globals...
[13:17:29.991] 
[13:17:29.991] Searching for globals ... DONE
[13:17:29.991] - globals: [0] <none>
[13:17:29.991] getGlobalsAndPackages() ... DONE
[13:17:29.992]    + additional globals found: [n=0] 
[13:17:29.992]    + additional namespaces needed: [n=0] 
[13:17:29.992]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:29.992]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:29.992]  - seeds: <none>
[13:17:29.993] getGlobalsAndPackages() ...
[13:17:29.993] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.993] Resolving globals: FALSE
[13:17:29.993] Tweak future expression to call with '...' arguments ...
[13:17:29.994] {
[13:17:29.994]     do.call(function(...) {
[13:17:29.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:29.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:29.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:29.994]             on.exit(options(oopts), add = TRUE)
[13:17:29.994]         }
[13:17:29.994]         {
[13:17:29.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:29.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:29.994]                 ...future.FUN(...future.X_jj, ...)
[13:17:29.994]             })
[13:17:29.994]         }
[13:17:29.994]     }, args = future.call.arguments)
[13:17:29.994] }
[13:17:29.994] Tweak future expression to call with '...' arguments ... DONE
[13:17:29.995] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:29.995] 
[13:17:29.996] getGlobalsAndPackages() ... DONE
[13:17:29.996] run() for ‘Future’ ...
[13:17:29.996] - state: ‘created’
[13:17:29.997] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.001] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.002]   - Field: ‘label’
[13:17:30.002]   - Field: ‘local’
[13:17:30.002]   - Field: ‘owner’
[13:17:30.002]   - Field: ‘envir’
[13:17:30.002]   - Field: ‘workers’
[13:17:30.003]   - Field: ‘packages’
[13:17:30.003]   - Field: ‘gc’
[13:17:30.003]   - Field: ‘job’
[13:17:30.003]   - Field: ‘conditions’
[13:17:30.003]   - Field: ‘expr’
[13:17:30.003]   - Field: ‘uuid’
[13:17:30.004]   - Field: ‘seed’
[13:17:30.004]   - Field: ‘version’
[13:17:30.004]   - Field: ‘result’
[13:17:30.004]   - Field: ‘asynchronous’
[13:17:30.004]   - Field: ‘calls’
[13:17:30.004]   - Field: ‘globals’
[13:17:30.004]   - Field: ‘stdout’
[13:17:30.005]   - Field: ‘earlySignal’
[13:17:30.005]   - Field: ‘lazy’
[13:17:30.005]   - Field: ‘state’
[13:17:30.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.005] - Launch lazy future ...
[13:17:30.006] Packages needed by the future expression (n = 0): <none>
[13:17:30.006] Packages needed by future strategies (n = 0): <none>
[13:17:30.006] {
[13:17:30.006]     {
[13:17:30.006]         {
[13:17:30.006]             ...future.startTime <- base::Sys.time()
[13:17:30.006]             {
[13:17:30.006]                 {
[13:17:30.006]                   {
[13:17:30.006]                     {
[13:17:30.006]                       base::local({
[13:17:30.006]                         has_future <- base::requireNamespace("future", 
[13:17:30.006]                           quietly = TRUE)
[13:17:30.006]                         if (has_future) {
[13:17:30.006]                           ns <- base::getNamespace("future")
[13:17:30.006]                           version <- ns[[".package"]][["version"]]
[13:17:30.006]                           if (is.null(version)) 
[13:17:30.006]                             version <- utils::packageVersion("future")
[13:17:30.006]                         }
[13:17:30.006]                         else {
[13:17:30.006]                           version <- NULL
[13:17:30.006]                         }
[13:17:30.006]                         if (!has_future || version < "1.8.0") {
[13:17:30.006]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.006]                             "", base::R.version$version.string), 
[13:17:30.006]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:30.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:30.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.006]                               "release", "version")], collapse = " "), 
[13:17:30.006]                             hostname = base::Sys.info()[["nodename"]])
[13:17:30.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.006]                             info)
[13:17:30.006]                           info <- base::paste(info, collapse = "; ")
[13:17:30.006]                           if (!has_future) {
[13:17:30.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.006]                               info)
[13:17:30.006]                           }
[13:17:30.006]                           else {
[13:17:30.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.006]                               info, version)
[13:17:30.006]                           }
[13:17:30.006]                           base::stop(msg)
[13:17:30.006]                         }
[13:17:30.006]                       })
[13:17:30.006]                     }
[13:17:30.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.006]                     base::options(mc.cores = 1L)
[13:17:30.006]                   }
[13:17:30.006]                   options(future.plan = NULL)
[13:17:30.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.006]                 }
[13:17:30.006]                 ...future.workdir <- getwd()
[13:17:30.006]             }
[13:17:30.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.006]         }
[13:17:30.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.006]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:30.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.006]             base::names(...future.oldOptions))
[13:17:30.006]     }
[13:17:30.006]     if (FALSE) {
[13:17:30.006]     }
[13:17:30.006]     else {
[13:17:30.006]         if (TRUE) {
[13:17:30.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.006]                 open = "w")
[13:17:30.006]         }
[13:17:30.006]         else {
[13:17:30.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.006]         }
[13:17:30.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.006]             base::sink(type = "output", split = FALSE)
[13:17:30.006]             base::close(...future.stdout)
[13:17:30.006]         }, add = TRUE)
[13:17:30.006]     }
[13:17:30.006]     ...future.frame <- base::sys.nframe()
[13:17:30.006]     ...future.conditions <- base::list()
[13:17:30.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.006]     if (FALSE) {
[13:17:30.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.006]     }
[13:17:30.006]     ...future.result <- base::tryCatch({
[13:17:30.006]         base::withCallingHandlers({
[13:17:30.006]             ...future.value <- base::withVisible(base::local({
[13:17:30.006]                 withCallingHandlers({
[13:17:30.006]                   {
[13:17:30.006]                     do.call(function(...) {
[13:17:30.006]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.006]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.006]                         ...future.globals.maxSize)) {
[13:17:30.006]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.006]                         on.exit(options(oopts), add = TRUE)
[13:17:30.006]                       }
[13:17:30.006]                       {
[13:17:30.006]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.006]                           FUN = function(jj) {
[13:17:30.006]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.006]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.006]                           })
[13:17:30.006]                       }
[13:17:30.006]                     }, args = future.call.arguments)
[13:17:30.006]                   }
[13:17:30.006]                 }, immediateCondition = function(cond) {
[13:17:30.006]                   save_rds <- function (object, pathname, ...) 
[13:17:30.006]                   {
[13:17:30.006]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.006]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.006]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.006]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.006]                         fi_tmp[["mtime"]])
[13:17:30.006]                     }
[13:17:30.006]                     tryCatch({
[13:17:30.006]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.006]                     }, error = function(ex) {
[13:17:30.006]                       msg <- conditionMessage(ex)
[13:17:30.006]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.006]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.006]                         fi_tmp[["mtime"]], msg)
[13:17:30.006]                       ex$message <- msg
[13:17:30.006]                       stop(ex)
[13:17:30.006]                     })
[13:17:30.006]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.006]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.006]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.006]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.006]                       fi <- file.info(pathname)
[13:17:30.006]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.006]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.006]                         fi[["size"]], fi[["mtime"]])
[13:17:30.006]                       stop(msg)
[13:17:30.006]                     }
[13:17:30.006]                     invisible(pathname)
[13:17:30.006]                   }
[13:17:30.006]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.006]                     rootPath = tempdir()) 
[13:17:30.006]                   {
[13:17:30.006]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.006]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.006]                       tmpdir = path, fileext = ".rds")
[13:17:30.006]                     save_rds(obj, file)
[13:17:30.006]                   }
[13:17:30.006]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.006]                   {
[13:17:30.006]                     inherits <- base::inherits
[13:17:30.006]                     invokeRestart <- base::invokeRestart
[13:17:30.006]                     is.null <- base::is.null
[13:17:30.006]                     muffled <- FALSE
[13:17:30.006]                     if (inherits(cond, "message")) {
[13:17:30.006]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.006]                       if (muffled) 
[13:17:30.006]                         invokeRestart("muffleMessage")
[13:17:30.006]                     }
[13:17:30.006]                     else if (inherits(cond, "warning")) {
[13:17:30.006]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.006]                       if (muffled) 
[13:17:30.006]                         invokeRestart("muffleWarning")
[13:17:30.006]                     }
[13:17:30.006]                     else if (inherits(cond, "condition")) {
[13:17:30.006]                       if (!is.null(pattern)) {
[13:17:30.006]                         computeRestarts <- base::computeRestarts
[13:17:30.006]                         grepl <- base::grepl
[13:17:30.006]                         restarts <- computeRestarts(cond)
[13:17:30.006]                         for (restart in restarts) {
[13:17:30.006]                           name <- restart$name
[13:17:30.006]                           if (is.null(name)) 
[13:17:30.006]                             next
[13:17:30.006]                           if (!grepl(pattern, name)) 
[13:17:30.006]                             next
[13:17:30.006]                           invokeRestart(restart)
[13:17:30.006]                           muffled <- TRUE
[13:17:30.006]                           break
[13:17:30.006]                         }
[13:17:30.006]                       }
[13:17:30.006]                     }
[13:17:30.006]                     invisible(muffled)
[13:17:30.006]                   }
[13:17:30.006]                   muffleCondition(cond)
[13:17:30.006]                 })
[13:17:30.006]             }))
[13:17:30.006]             future::FutureResult(value = ...future.value$value, 
[13:17:30.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.006]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.006]                     ...future.globalenv.names))
[13:17:30.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.006]         }, condition = base::local({
[13:17:30.006]             c <- base::c
[13:17:30.006]             inherits <- base::inherits
[13:17:30.006]             invokeRestart <- base::invokeRestart
[13:17:30.006]             length <- base::length
[13:17:30.006]             list <- base::list
[13:17:30.006]             seq.int <- base::seq.int
[13:17:30.006]             signalCondition <- base::signalCondition
[13:17:30.006]             sys.calls <- base::sys.calls
[13:17:30.006]             `[[` <- base::`[[`
[13:17:30.006]             `+` <- base::`+`
[13:17:30.006]             `<<-` <- base::`<<-`
[13:17:30.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.006]                   3L)]
[13:17:30.006]             }
[13:17:30.006]             function(cond) {
[13:17:30.006]                 is_error <- inherits(cond, "error")
[13:17:30.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.006]                   NULL)
[13:17:30.006]                 if (is_error) {
[13:17:30.006]                   sessionInformation <- function() {
[13:17:30.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.006]                       search = base::search(), system = base::Sys.info())
[13:17:30.006]                   }
[13:17:30.006]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.006]                     cond$call), session = sessionInformation(), 
[13:17:30.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.006]                   signalCondition(cond)
[13:17:30.006]                 }
[13:17:30.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.006]                 "immediateCondition"))) {
[13:17:30.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.006]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.006]                   if (TRUE && !signal) {
[13:17:30.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.006]                     {
[13:17:30.006]                       inherits <- base::inherits
[13:17:30.006]                       invokeRestart <- base::invokeRestart
[13:17:30.006]                       is.null <- base::is.null
[13:17:30.006]                       muffled <- FALSE
[13:17:30.006]                       if (inherits(cond, "message")) {
[13:17:30.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.006]                         if (muffled) 
[13:17:30.006]                           invokeRestart("muffleMessage")
[13:17:30.006]                       }
[13:17:30.006]                       else if (inherits(cond, "warning")) {
[13:17:30.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.006]                         if (muffled) 
[13:17:30.006]                           invokeRestart("muffleWarning")
[13:17:30.006]                       }
[13:17:30.006]                       else if (inherits(cond, "condition")) {
[13:17:30.006]                         if (!is.null(pattern)) {
[13:17:30.006]                           computeRestarts <- base::computeRestarts
[13:17:30.006]                           grepl <- base::grepl
[13:17:30.006]                           restarts <- computeRestarts(cond)
[13:17:30.006]                           for (restart in restarts) {
[13:17:30.006]                             name <- restart$name
[13:17:30.006]                             if (is.null(name)) 
[13:17:30.006]                               next
[13:17:30.006]                             if (!grepl(pattern, name)) 
[13:17:30.006]                               next
[13:17:30.006]                             invokeRestart(restart)
[13:17:30.006]                             muffled <- TRUE
[13:17:30.006]                             break
[13:17:30.006]                           }
[13:17:30.006]                         }
[13:17:30.006]                       }
[13:17:30.006]                       invisible(muffled)
[13:17:30.006]                     }
[13:17:30.006]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.006]                   }
[13:17:30.006]                 }
[13:17:30.006]                 else {
[13:17:30.006]                   if (TRUE) {
[13:17:30.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.006]                     {
[13:17:30.006]                       inherits <- base::inherits
[13:17:30.006]                       invokeRestart <- base::invokeRestart
[13:17:30.006]                       is.null <- base::is.null
[13:17:30.006]                       muffled <- FALSE
[13:17:30.006]                       if (inherits(cond, "message")) {
[13:17:30.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.006]                         if (muffled) 
[13:17:30.006]                           invokeRestart("muffleMessage")
[13:17:30.006]                       }
[13:17:30.006]                       else if (inherits(cond, "warning")) {
[13:17:30.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.006]                         if (muffled) 
[13:17:30.006]                           invokeRestart("muffleWarning")
[13:17:30.006]                       }
[13:17:30.006]                       else if (inherits(cond, "condition")) {
[13:17:30.006]                         if (!is.null(pattern)) {
[13:17:30.006]                           computeRestarts <- base::computeRestarts
[13:17:30.006]                           grepl <- base::grepl
[13:17:30.006]                           restarts <- computeRestarts(cond)
[13:17:30.006]                           for (restart in restarts) {
[13:17:30.006]                             name <- restart$name
[13:17:30.006]                             if (is.null(name)) 
[13:17:30.006]                               next
[13:17:30.006]                             if (!grepl(pattern, name)) 
[13:17:30.006]                               next
[13:17:30.006]                             invokeRestart(restart)
[13:17:30.006]                             muffled <- TRUE
[13:17:30.006]                             break
[13:17:30.006]                           }
[13:17:30.006]                         }
[13:17:30.006]                       }
[13:17:30.006]                       invisible(muffled)
[13:17:30.006]                     }
[13:17:30.006]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.006]                   }
[13:17:30.006]                 }
[13:17:30.006]             }
[13:17:30.006]         }))
[13:17:30.006]     }, error = function(ex) {
[13:17:30.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.006]                 ...future.rng), started = ...future.startTime, 
[13:17:30.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.006]             version = "1.8"), class = "FutureResult")
[13:17:30.006]     }, finally = {
[13:17:30.006]         if (!identical(...future.workdir, getwd())) 
[13:17:30.006]             setwd(...future.workdir)
[13:17:30.006]         {
[13:17:30.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.006]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.006]             }
[13:17:30.006]             base::options(...future.oldOptions)
[13:17:30.006]             if (.Platform$OS.type == "windows") {
[13:17:30.006]                 old_names <- names(...future.oldEnvVars)
[13:17:30.006]                 envs <- base::Sys.getenv()
[13:17:30.006]                 names <- names(envs)
[13:17:30.006]                 common <- intersect(names, old_names)
[13:17:30.006]                 added <- setdiff(names, old_names)
[13:17:30.006]                 removed <- setdiff(old_names, names)
[13:17:30.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.006]                   envs[common]]
[13:17:30.006]                 NAMES <- toupper(changed)
[13:17:30.006]                 args <- list()
[13:17:30.006]                 for (kk in seq_along(NAMES)) {
[13:17:30.006]                   name <- changed[[kk]]
[13:17:30.006]                   NAME <- NAMES[[kk]]
[13:17:30.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.006]                     next
[13:17:30.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.006]                 }
[13:17:30.006]                 NAMES <- toupper(added)
[13:17:30.006]                 for (kk in seq_along(NAMES)) {
[13:17:30.006]                   name <- added[[kk]]
[13:17:30.006]                   NAME <- NAMES[[kk]]
[13:17:30.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.006]                     next
[13:17:30.006]                   args[[name]] <- ""
[13:17:30.006]                 }
[13:17:30.006]                 NAMES <- toupper(removed)
[13:17:30.006]                 for (kk in seq_along(NAMES)) {
[13:17:30.006]                   name <- removed[[kk]]
[13:17:30.006]                   NAME <- NAMES[[kk]]
[13:17:30.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.006]                     next
[13:17:30.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.006]                 }
[13:17:30.006]                 if (length(args) > 0) 
[13:17:30.006]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.006]             }
[13:17:30.006]             else {
[13:17:30.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.006]             }
[13:17:30.006]             {
[13:17:30.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.006]                   0L) {
[13:17:30.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.006]                   base::options(opts)
[13:17:30.006]                 }
[13:17:30.006]                 {
[13:17:30.006]                   {
[13:17:30.006]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.006]                     NULL
[13:17:30.006]                   }
[13:17:30.006]                   options(future.plan = NULL)
[13:17:30.006]                   if (is.na(NA_character_)) 
[13:17:30.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.006]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.006]                     envir = parent.frame()) 
[13:17:30.006]                   {
[13:17:30.006]                     default_workers <- missing(workers)
[13:17:30.006]                     if (is.function(workers)) 
[13:17:30.006]                       workers <- workers()
[13:17:30.006]                     workers <- structure(as.integer(workers), 
[13:17:30.006]                       class = class(workers))
[13:17:30.006]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.006]                       1L)
[13:17:30.006]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.006]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.006]                       if (default_workers) 
[13:17:30.006]                         supportsMulticore(warn = TRUE)
[13:17:30.006]                       return(sequential(..., envir = envir))
[13:17:30.006]                     }
[13:17:30.006]                     oopts <- options(mc.cores = workers)
[13:17:30.006]                     on.exit(options(oopts))
[13:17:30.006]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.006]                       envir = envir)
[13:17:30.006]                     if (!future$lazy) 
[13:17:30.006]                       future <- run(future)
[13:17:30.006]                     invisible(future)
[13:17:30.006]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.006]                 }
[13:17:30.006]             }
[13:17:30.006]         }
[13:17:30.006]     })
[13:17:30.006]     if (TRUE) {
[13:17:30.006]         base::sink(type = "output", split = FALSE)
[13:17:30.006]         if (TRUE) {
[13:17:30.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.006]         }
[13:17:30.006]         else {
[13:17:30.006]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.006]         }
[13:17:30.006]         base::close(...future.stdout)
[13:17:30.006]         ...future.stdout <- NULL
[13:17:30.006]     }
[13:17:30.006]     ...future.result$conditions <- ...future.conditions
[13:17:30.006]     ...future.result$finished <- base::Sys.time()
[13:17:30.006]     ...future.result
[13:17:30.006] }
[13:17:30.010] assign_globals() ...
[13:17:30.010] List of 5
[13:17:30.010]  $ ...future.FUN            :function (object, ...)  
[13:17:30.010]  $ future.call.arguments    :List of 1
[13:17:30.010]   ..$ digits: int 2
[13:17:30.010]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.010]  $ ...future.elements_ii    :List of 3
[13:17:30.010]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:17:30.010]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:17:30.010]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:17:30.010]  $ ...future.seeds_ii       : NULL
[13:17:30.010]  $ ...future.globals.maxSize: NULL
[13:17:30.010]  - attr(*, "resolved")= logi FALSE
[13:17:30.010]  - attr(*, "total_size")= num 1296
[13:17:30.010]  - attr(*, "where")=List of 5
[13:17:30.010]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.010]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.010]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.010]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.010]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.010]  - attr(*, "already-done")= logi TRUE
[13:17:30.017] - copied ‘...future.FUN’ to environment
[13:17:30.017] - copied ‘future.call.arguments’ to environment
[13:17:30.017] - copied ‘...future.elements_ii’ to environment
[13:17:30.017] - copied ‘...future.seeds_ii’ to environment
[13:17:30.017] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.018] assign_globals() ... done
[13:17:30.018] requestCore(): workers = 2
[13:17:30.020] MulticoreFuture started
[13:17:30.020] - Launch lazy future ... done
[13:17:30.020] run() for ‘MulticoreFuture’ ... done
[13:17:30.021] Created future:
[13:17:30.021] plan(): Setting new future strategy stack:
[13:17:30.021] List of future strategies:
[13:17:30.021] 1. sequential:
[13:17:30.021]    - args: function (..., envir = parent.frame())
[13:17:30.021]    - tweaked: FALSE
[13:17:30.021]    - call: NULL
[13:17:30.022] plan(): nbrOfWorkers() = 1
[13:17:30.029] plan(): Setting new future strategy stack:
[13:17:30.029] List of future strategies:
[13:17:30.029] 1. multicore:
[13:17:30.029]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.029]    - tweaked: FALSE
[13:17:30.029]    - call: plan(strategy)
[13:17:30.035] plan(): nbrOfWorkers() = 2
[13:17:30.021] MulticoreFuture:
[13:17:30.021] Label: ‘future_by-2’
[13:17:30.021] Expression:
[13:17:30.021] {
[13:17:30.021]     do.call(function(...) {
[13:17:30.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.021]             on.exit(options(oopts), add = TRUE)
[13:17:30.021]         }
[13:17:30.021]         {
[13:17:30.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.021]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.021]             })
[13:17:30.021]         }
[13:17:30.021]     }, args = future.call.arguments)
[13:17:30.021] }
[13:17:30.021] Lazy evaluation: FALSE
[13:17:30.021] Asynchronous evaluation: TRUE
[13:17:30.021] Local evaluation: TRUE
[13:17:30.021] Environment: R_GlobalEnv
[13:17:30.021] Capture standard output: TRUE
[13:17:30.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.021] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.021] Packages: <none>
[13:17:30.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.021] Resolved: TRUE
[13:17:30.021] Value: <not collected>
[13:17:30.021] Conditions captured: <none>
[13:17:30.021] Early signaling: FALSE
[13:17:30.021] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.021] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.037] Chunk #2 of 2 ... DONE
[13:17:30.037] Launching 2 futures (chunks) ... DONE
[13:17:30.037] Resolving 2 futures (chunks) ...
[13:17:30.037] resolve() on list ...
[13:17:30.037]  recursive: 0
[13:17:30.038]  length: 2
[13:17:30.038] 
[13:17:30.038] Future #1
[13:17:30.039] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:30.040] - nx: 2
[13:17:30.040] - relay: TRUE
[13:17:30.040] - stdout: TRUE
[13:17:30.040] - signal: TRUE
[13:17:30.040] - resignal: FALSE
[13:17:30.041] - force: TRUE
[13:17:30.041] - relayed: [n=2] FALSE, FALSE
[13:17:30.041] - queued futures: [n=2] FALSE, FALSE
[13:17:30.042]  - until=1
[13:17:30.042]  - relaying element #1
[13:17:30.042] - relayed: [n=2] TRUE, FALSE
[13:17:30.043] - queued futures: [n=2] TRUE, FALSE
[13:17:30.043] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:30.043]  length: 1 (resolved future 1)
[13:17:30.044] Future #2
[13:17:30.045] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:30.045] - nx: 2
[13:17:30.045] - relay: TRUE
[13:17:30.045] - stdout: TRUE
[13:17:30.046] - signal: TRUE
[13:17:30.046] - resignal: FALSE
[13:17:30.046] - force: TRUE
[13:17:30.046] - relayed: [n=2] TRUE, FALSE
[13:17:30.046] - queued futures: [n=2] TRUE, FALSE
[13:17:30.046]  - until=2
[13:17:30.046]  - relaying element #2
[13:17:30.047] - relayed: [n=2] TRUE, TRUE
[13:17:30.047] - queued futures: [n=2] TRUE, TRUE
[13:17:30.047] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:30.047]  length: 0 (resolved future 2)
[13:17:30.047] Relaying remaining futures
[13:17:30.047] signalConditionsASAP(NULL, pos=0) ...
[13:17:30.048] - nx: 2
[13:17:30.048] - relay: TRUE
[13:17:30.048] - stdout: TRUE
[13:17:30.048] - signal: TRUE
[13:17:30.048] - resignal: FALSE
[13:17:30.048] - force: TRUE
[13:17:30.048] - relayed: [n=2] TRUE, TRUE
[13:17:30.048] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:30.048] - relayed: [n=2] TRUE, TRUE
[13:17:30.049] - queued futures: [n=2] TRUE, TRUE
[13:17:30.049] signalConditionsASAP(NULL, pos=0) ... done
[13:17:30.049] resolve() on list ... DONE
[13:17:30.049]  - Number of value chunks collected: 2
[13:17:30.049] Resolving 2 futures (chunks) ... DONE
[13:17:30.049] Reducing values from 2 chunks ...
[13:17:30.049]  - Number of values collected after concatenation: 6
[13:17:30.049]  - Number of values expected: 6
[13:17:30.050] Reducing values from 2 chunks ... DONE
[13:17:30.050] future_lapply() ... DONE
[13:17:30.050] future_by_internal() ... DONE
[13:17:30.051] future_by_internal() ...
[13:17:30.052] future_lapply() ...
[13:17:30.056] Number of chunks: 2
[13:17:30.056] getGlobalsAndPackagesXApply() ...
[13:17:30.057]  - future.globals: TRUE
[13:17:30.057] getGlobalsAndPackages() ...
[13:17:30.057] Searching for globals...
[13:17:30.058] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:30.059] Searching for globals ... DONE
[13:17:30.059] Resolving globals: FALSE
[13:17:30.059] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:17:30.060] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:17:30.060] - globals: [1] ‘FUN’
[13:17:30.060] - packages: [1] ‘stats’
[13:17:30.060] getGlobalsAndPackages() ... DONE
[13:17:30.060]  - globals found/used: [n=1] ‘FUN’
[13:17:30.060]  - needed namespaces: [n=1] ‘stats’
[13:17:30.060] Finding globals ... DONE
[13:17:30.060]  - use_args: TRUE
[13:17:30.060]  - Getting '...' globals ...
[13:17:30.061] resolve() on list ...
[13:17:30.061]  recursive: 0
[13:17:30.061]  length: 1
[13:17:30.061]  elements: ‘...’
[13:17:30.061]  length: 0 (resolved future 1)
[13:17:30.061] resolve() on list ... DONE
[13:17:30.062]    - '...' content: [n=1] ‘singular.ok’
[13:17:30.062] List of 1
[13:17:30.062]  $ ...:List of 1
[13:17:30.062]   ..$ singular.ok: logi FALSE
[13:17:30.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.062]  - attr(*, "where")=List of 1
[13:17:30.062]   ..$ ...:<environment: 0x5609e8698720> 
[13:17:30.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.062]  - attr(*, "resolved")= logi TRUE
[13:17:30.062]  - attr(*, "total_size")= num NA
[13:17:30.068]  - Getting '...' globals ... DONE
[13:17:30.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:30.068] List of 2
[13:17:30.068]  $ ...future.FUN:function (x, ...)  
[13:17:30.068]  $ ...          :List of 1
[13:17:30.068]   ..$ singular.ok: logi FALSE
[13:17:30.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.068]  - attr(*, "where")=List of 2
[13:17:30.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:30.068]   ..$ ...          :<environment: 0x5609e8698720> 
[13:17:30.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.068]  - attr(*, "resolved")= logi FALSE
[13:17:30.068]  - attr(*, "total_size")= num 5384
[13:17:30.072] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:30.072] getGlobalsAndPackagesXApply() ... DONE
[13:17:30.072] Number of futures (= number of chunks): 2
[13:17:30.073] Launching 2 futures (chunks) ...
[13:17:30.073] Chunk #1 of 2 ...
[13:17:30.073]  - Finding globals in 'X' for chunk #1 ...
[13:17:30.073] getGlobalsAndPackages() ...
[13:17:30.073] Searching for globals...
[13:17:30.073] 
[13:17:30.074] Searching for globals ... DONE
[13:17:30.074] - globals: [0] <none>
[13:17:30.074] getGlobalsAndPackages() ... DONE
[13:17:30.074]    + additional globals found: [n=0] 
[13:17:30.074]    + additional namespaces needed: [n=0] 
[13:17:30.074]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:30.074]  - seeds: <none>
[13:17:30.074] getGlobalsAndPackages() ...
[13:17:30.074] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.074] Resolving globals: FALSE
[13:17:30.075] Tweak future expression to call with '...' arguments ...
[13:17:30.075] {
[13:17:30.075]     do.call(function(...) {
[13:17:30.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.075]             on.exit(options(oopts), add = TRUE)
[13:17:30.075]         }
[13:17:30.075]         {
[13:17:30.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.075]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.075]             })
[13:17:30.075]         }
[13:17:30.075]     }, args = future.call.arguments)
[13:17:30.075] }
[13:17:30.075] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.075] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.075] 
[13:17:30.076] getGlobalsAndPackages() ... DONE
[13:17:30.076] run() for ‘Future’ ...
[13:17:30.076] - state: ‘created’
[13:17:30.076] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.080] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.080]   - Field: ‘label’
[13:17:30.080]   - Field: ‘local’
[13:17:30.080]   - Field: ‘owner’
[13:17:30.080]   - Field: ‘envir’
[13:17:30.081]   - Field: ‘workers’
[13:17:30.081]   - Field: ‘packages’
[13:17:30.081]   - Field: ‘gc’
[13:17:30.081]   - Field: ‘job’
[13:17:30.081]   - Field: ‘conditions’
[13:17:30.081]   - Field: ‘expr’
[13:17:30.081]   - Field: ‘uuid’
[13:17:30.081]   - Field: ‘seed’
[13:17:30.081]   - Field: ‘version’
[13:17:30.082]   - Field: ‘result’
[13:17:30.082]   - Field: ‘asynchronous’
[13:17:30.082]   - Field: ‘calls’
[13:17:30.082]   - Field: ‘globals’
[13:17:30.082]   - Field: ‘stdout’
[13:17:30.082]   - Field: ‘earlySignal’
[13:17:30.082]   - Field: ‘lazy’
[13:17:30.082]   - Field: ‘state’
[13:17:30.082] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.082] - Launch lazy future ...
[13:17:30.083] Packages needed by the future expression (n = 1): ‘stats’
[13:17:30.083] Packages needed by future strategies (n = 0): <none>
[13:17:30.083] {
[13:17:30.083]     {
[13:17:30.083]         {
[13:17:30.083]             ...future.startTime <- base::Sys.time()
[13:17:30.083]             {
[13:17:30.083]                 {
[13:17:30.083]                   {
[13:17:30.083]                     {
[13:17:30.083]                       {
[13:17:30.083]                         base::local({
[13:17:30.083]                           has_future <- base::requireNamespace("future", 
[13:17:30.083]                             quietly = TRUE)
[13:17:30.083]                           if (has_future) {
[13:17:30.083]                             ns <- base::getNamespace("future")
[13:17:30.083]                             version <- ns[[".package"]][["version"]]
[13:17:30.083]                             if (is.null(version)) 
[13:17:30.083]                               version <- utils::packageVersion("future")
[13:17:30.083]                           }
[13:17:30.083]                           else {
[13:17:30.083]                             version <- NULL
[13:17:30.083]                           }
[13:17:30.083]                           if (!has_future || version < "1.8.0") {
[13:17:30.083]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.083]                               "", base::R.version$version.string), 
[13:17:30.083]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:30.083]                                 base::R.version$platform, 8 * 
[13:17:30.083]                                   base::.Machine$sizeof.pointer), 
[13:17:30.083]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.083]                                 "release", "version")], collapse = " "), 
[13:17:30.083]                               hostname = base::Sys.info()[["nodename"]])
[13:17:30.083]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.083]                               info)
[13:17:30.083]                             info <- base::paste(info, collapse = "; ")
[13:17:30.083]                             if (!has_future) {
[13:17:30.083]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.083]                                 info)
[13:17:30.083]                             }
[13:17:30.083]                             else {
[13:17:30.083]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.083]                                 info, version)
[13:17:30.083]                             }
[13:17:30.083]                             base::stop(msg)
[13:17:30.083]                           }
[13:17:30.083]                         })
[13:17:30.083]                       }
[13:17:30.083]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.083]                       base::options(mc.cores = 1L)
[13:17:30.083]                     }
[13:17:30.083]                     base::local({
[13:17:30.083]                       for (pkg in "stats") {
[13:17:30.083]                         base::loadNamespace(pkg)
[13:17:30.083]                         base::library(pkg, character.only = TRUE)
[13:17:30.083]                       }
[13:17:30.083]                     })
[13:17:30.083]                   }
[13:17:30.083]                   options(future.plan = NULL)
[13:17:30.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.083]                 }
[13:17:30.083]                 ...future.workdir <- getwd()
[13:17:30.083]             }
[13:17:30.083]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.083]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.083]         }
[13:17:30.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:30.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.083]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.083]             base::names(...future.oldOptions))
[13:17:30.083]     }
[13:17:30.083]     if (FALSE) {
[13:17:30.083]     }
[13:17:30.083]     else {
[13:17:30.083]         if (TRUE) {
[13:17:30.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.083]                 open = "w")
[13:17:30.083]         }
[13:17:30.083]         else {
[13:17:30.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.083]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.083]         }
[13:17:30.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.083]             base::sink(type = "output", split = FALSE)
[13:17:30.083]             base::close(...future.stdout)
[13:17:30.083]         }, add = TRUE)
[13:17:30.083]     }
[13:17:30.083]     ...future.frame <- base::sys.nframe()
[13:17:30.083]     ...future.conditions <- base::list()
[13:17:30.083]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.083]     if (FALSE) {
[13:17:30.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.083]     }
[13:17:30.083]     ...future.result <- base::tryCatch({
[13:17:30.083]         base::withCallingHandlers({
[13:17:30.083]             ...future.value <- base::withVisible(base::local({
[13:17:30.083]                 withCallingHandlers({
[13:17:30.083]                   {
[13:17:30.083]                     do.call(function(...) {
[13:17:30.083]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.083]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.083]                         ...future.globals.maxSize)) {
[13:17:30.083]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.083]                         on.exit(options(oopts), add = TRUE)
[13:17:30.083]                       }
[13:17:30.083]                       {
[13:17:30.083]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.083]                           FUN = function(jj) {
[13:17:30.083]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.083]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.083]                           })
[13:17:30.083]                       }
[13:17:30.083]                     }, args = future.call.arguments)
[13:17:30.083]                   }
[13:17:30.083]                 }, immediateCondition = function(cond) {
[13:17:30.083]                   save_rds <- function (object, pathname, ...) 
[13:17:30.083]                   {
[13:17:30.083]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.083]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.083]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.083]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.083]                         fi_tmp[["mtime"]])
[13:17:30.083]                     }
[13:17:30.083]                     tryCatch({
[13:17:30.083]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.083]                     }, error = function(ex) {
[13:17:30.083]                       msg <- conditionMessage(ex)
[13:17:30.083]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.083]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.083]                         fi_tmp[["mtime"]], msg)
[13:17:30.083]                       ex$message <- msg
[13:17:30.083]                       stop(ex)
[13:17:30.083]                     })
[13:17:30.083]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.083]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.083]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.083]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.083]                       fi <- file.info(pathname)
[13:17:30.083]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.083]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.083]                         fi[["size"]], fi[["mtime"]])
[13:17:30.083]                       stop(msg)
[13:17:30.083]                     }
[13:17:30.083]                     invisible(pathname)
[13:17:30.083]                   }
[13:17:30.083]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.083]                     rootPath = tempdir()) 
[13:17:30.083]                   {
[13:17:30.083]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.083]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.083]                       tmpdir = path, fileext = ".rds")
[13:17:30.083]                     save_rds(obj, file)
[13:17:30.083]                   }
[13:17:30.083]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.083]                   {
[13:17:30.083]                     inherits <- base::inherits
[13:17:30.083]                     invokeRestart <- base::invokeRestart
[13:17:30.083]                     is.null <- base::is.null
[13:17:30.083]                     muffled <- FALSE
[13:17:30.083]                     if (inherits(cond, "message")) {
[13:17:30.083]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.083]                       if (muffled) 
[13:17:30.083]                         invokeRestart("muffleMessage")
[13:17:30.083]                     }
[13:17:30.083]                     else if (inherits(cond, "warning")) {
[13:17:30.083]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.083]                       if (muffled) 
[13:17:30.083]                         invokeRestart("muffleWarning")
[13:17:30.083]                     }
[13:17:30.083]                     else if (inherits(cond, "condition")) {
[13:17:30.083]                       if (!is.null(pattern)) {
[13:17:30.083]                         computeRestarts <- base::computeRestarts
[13:17:30.083]                         grepl <- base::grepl
[13:17:30.083]                         restarts <- computeRestarts(cond)
[13:17:30.083]                         for (restart in restarts) {
[13:17:30.083]                           name <- restart$name
[13:17:30.083]                           if (is.null(name)) 
[13:17:30.083]                             next
[13:17:30.083]                           if (!grepl(pattern, name)) 
[13:17:30.083]                             next
[13:17:30.083]                           invokeRestart(restart)
[13:17:30.083]                           muffled <- TRUE
[13:17:30.083]                           break
[13:17:30.083]                         }
[13:17:30.083]                       }
[13:17:30.083]                     }
[13:17:30.083]                     invisible(muffled)
[13:17:30.083]                   }
[13:17:30.083]                   muffleCondition(cond)
[13:17:30.083]                 })
[13:17:30.083]             }))
[13:17:30.083]             future::FutureResult(value = ...future.value$value, 
[13:17:30.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.083]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.083]                     ...future.globalenv.names))
[13:17:30.083]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.083]         }, condition = base::local({
[13:17:30.083]             c <- base::c
[13:17:30.083]             inherits <- base::inherits
[13:17:30.083]             invokeRestart <- base::invokeRestart
[13:17:30.083]             length <- base::length
[13:17:30.083]             list <- base::list
[13:17:30.083]             seq.int <- base::seq.int
[13:17:30.083]             signalCondition <- base::signalCondition
[13:17:30.083]             sys.calls <- base::sys.calls
[13:17:30.083]             `[[` <- base::`[[`
[13:17:30.083]             `+` <- base::`+`
[13:17:30.083]             `<<-` <- base::`<<-`
[13:17:30.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.083]                   3L)]
[13:17:30.083]             }
[13:17:30.083]             function(cond) {
[13:17:30.083]                 is_error <- inherits(cond, "error")
[13:17:30.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.083]                   NULL)
[13:17:30.083]                 if (is_error) {
[13:17:30.083]                   sessionInformation <- function() {
[13:17:30.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.083]                       search = base::search(), system = base::Sys.info())
[13:17:30.083]                   }
[13:17:30.083]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.083]                     cond$call), session = sessionInformation(), 
[13:17:30.083]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.083]                   signalCondition(cond)
[13:17:30.083]                 }
[13:17:30.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.083]                 "immediateCondition"))) {
[13:17:30.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.083]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.083]                   if (TRUE && !signal) {
[13:17:30.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.083]                     {
[13:17:30.083]                       inherits <- base::inherits
[13:17:30.083]                       invokeRestart <- base::invokeRestart
[13:17:30.083]                       is.null <- base::is.null
[13:17:30.083]                       muffled <- FALSE
[13:17:30.083]                       if (inherits(cond, "message")) {
[13:17:30.083]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.083]                         if (muffled) 
[13:17:30.083]                           invokeRestart("muffleMessage")
[13:17:30.083]                       }
[13:17:30.083]                       else if (inherits(cond, "warning")) {
[13:17:30.083]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.083]                         if (muffled) 
[13:17:30.083]                           invokeRestart("muffleWarning")
[13:17:30.083]                       }
[13:17:30.083]                       else if (inherits(cond, "condition")) {
[13:17:30.083]                         if (!is.null(pattern)) {
[13:17:30.083]                           computeRestarts <- base::computeRestarts
[13:17:30.083]                           grepl <- base::grepl
[13:17:30.083]                           restarts <- computeRestarts(cond)
[13:17:30.083]                           for (restart in restarts) {
[13:17:30.083]                             name <- restart$name
[13:17:30.083]                             if (is.null(name)) 
[13:17:30.083]                               next
[13:17:30.083]                             if (!grepl(pattern, name)) 
[13:17:30.083]                               next
[13:17:30.083]                             invokeRestart(restart)
[13:17:30.083]                             muffled <- TRUE
[13:17:30.083]                             break
[13:17:30.083]                           }
[13:17:30.083]                         }
[13:17:30.083]                       }
[13:17:30.083]                       invisible(muffled)
[13:17:30.083]                     }
[13:17:30.083]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.083]                   }
[13:17:30.083]                 }
[13:17:30.083]                 else {
[13:17:30.083]                   if (TRUE) {
[13:17:30.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.083]                     {
[13:17:30.083]                       inherits <- base::inherits
[13:17:30.083]                       invokeRestart <- base::invokeRestart
[13:17:30.083]                       is.null <- base::is.null
[13:17:30.083]                       muffled <- FALSE
[13:17:30.083]                       if (inherits(cond, "message")) {
[13:17:30.083]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.083]                         if (muffled) 
[13:17:30.083]                           invokeRestart("muffleMessage")
[13:17:30.083]                       }
[13:17:30.083]                       else if (inherits(cond, "warning")) {
[13:17:30.083]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.083]                         if (muffled) 
[13:17:30.083]                           invokeRestart("muffleWarning")
[13:17:30.083]                       }
[13:17:30.083]                       else if (inherits(cond, "condition")) {
[13:17:30.083]                         if (!is.null(pattern)) {
[13:17:30.083]                           computeRestarts <- base::computeRestarts
[13:17:30.083]                           grepl <- base::grepl
[13:17:30.083]                           restarts <- computeRestarts(cond)
[13:17:30.083]                           for (restart in restarts) {
[13:17:30.083]                             name <- restart$name
[13:17:30.083]                             if (is.null(name)) 
[13:17:30.083]                               next
[13:17:30.083]                             if (!grepl(pattern, name)) 
[13:17:30.083]                               next
[13:17:30.083]                             invokeRestart(restart)
[13:17:30.083]                             muffled <- TRUE
[13:17:30.083]                             break
[13:17:30.083]                           }
[13:17:30.083]                         }
[13:17:30.083]                       }
[13:17:30.083]                       invisible(muffled)
[13:17:30.083]                     }
[13:17:30.083]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.083]                   }
[13:17:30.083]                 }
[13:17:30.083]             }
[13:17:30.083]         }))
[13:17:30.083]     }, error = function(ex) {
[13:17:30.083]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.083]                 ...future.rng), started = ...future.startTime, 
[13:17:30.083]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.083]             version = "1.8"), class = "FutureResult")
[13:17:30.083]     }, finally = {
[13:17:30.083]         if (!identical(...future.workdir, getwd())) 
[13:17:30.083]             setwd(...future.workdir)
[13:17:30.083]         {
[13:17:30.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.083]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.083]             }
[13:17:30.083]             base::options(...future.oldOptions)
[13:17:30.083]             if (.Platform$OS.type == "windows") {
[13:17:30.083]                 old_names <- names(...future.oldEnvVars)
[13:17:30.083]                 envs <- base::Sys.getenv()
[13:17:30.083]                 names <- names(envs)
[13:17:30.083]                 common <- intersect(names, old_names)
[13:17:30.083]                 added <- setdiff(names, old_names)
[13:17:30.083]                 removed <- setdiff(old_names, names)
[13:17:30.083]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.083]                   envs[common]]
[13:17:30.083]                 NAMES <- toupper(changed)
[13:17:30.083]                 args <- list()
[13:17:30.083]                 for (kk in seq_along(NAMES)) {
[13:17:30.083]                   name <- changed[[kk]]
[13:17:30.083]                   NAME <- NAMES[[kk]]
[13:17:30.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.083]                     next
[13:17:30.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.083]                 }
[13:17:30.083]                 NAMES <- toupper(added)
[13:17:30.083]                 for (kk in seq_along(NAMES)) {
[13:17:30.083]                   name <- added[[kk]]
[13:17:30.083]                   NAME <- NAMES[[kk]]
[13:17:30.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.083]                     next
[13:17:30.083]                   args[[name]] <- ""
[13:17:30.083]                 }
[13:17:30.083]                 NAMES <- toupper(removed)
[13:17:30.083]                 for (kk in seq_along(NAMES)) {
[13:17:30.083]                   name <- removed[[kk]]
[13:17:30.083]                   NAME <- NAMES[[kk]]
[13:17:30.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.083]                     next
[13:17:30.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.083]                 }
[13:17:30.083]                 if (length(args) > 0) 
[13:17:30.083]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.083]             }
[13:17:30.083]             else {
[13:17:30.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.083]             }
[13:17:30.083]             {
[13:17:30.083]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.083]                   0L) {
[13:17:30.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.083]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.083]                   base::options(opts)
[13:17:30.083]                 }
[13:17:30.083]                 {
[13:17:30.083]                   {
[13:17:30.083]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.083]                     NULL
[13:17:30.083]                   }
[13:17:30.083]                   options(future.plan = NULL)
[13:17:30.083]                   if (is.na(NA_character_)) 
[13:17:30.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.083]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.083]                     envir = parent.frame()) 
[13:17:30.083]                   {
[13:17:30.083]                     default_workers <- missing(workers)
[13:17:30.083]                     if (is.function(workers)) 
[13:17:30.083]                       workers <- workers()
[13:17:30.083]                     workers <- structure(as.integer(workers), 
[13:17:30.083]                       class = class(workers))
[13:17:30.083]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.083]                       1L)
[13:17:30.083]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.083]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.083]                       if (default_workers) 
[13:17:30.083]                         supportsMulticore(warn = TRUE)
[13:17:30.083]                       return(sequential(..., envir = envir))
[13:17:30.083]                     }
[13:17:30.083]                     oopts <- options(mc.cores = workers)
[13:17:30.083]                     on.exit(options(oopts))
[13:17:30.083]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.083]                       envir = envir)
[13:17:30.083]                     if (!future$lazy) 
[13:17:30.083]                       future <- run(future)
[13:17:30.083]                     invisible(future)
[13:17:30.083]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.083]                 }
[13:17:30.083]             }
[13:17:30.083]         }
[13:17:30.083]     })
[13:17:30.083]     if (TRUE) {
[13:17:30.083]         base::sink(type = "output", split = FALSE)
[13:17:30.083]         if (TRUE) {
[13:17:30.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.083]         }
[13:17:30.083]         else {
[13:17:30.083]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.083]         }
[13:17:30.083]         base::close(...future.stdout)
[13:17:30.083]         ...future.stdout <- NULL
[13:17:30.083]     }
[13:17:30.083]     ...future.result$conditions <- ...future.conditions
[13:17:30.083]     ...future.result$finished <- base::Sys.time()
[13:17:30.083]     ...future.result
[13:17:30.083] }
[13:17:30.086] assign_globals() ...
[13:17:30.086] List of 5
[13:17:30.086]  $ ...future.FUN            :function (x, ...)  
[13:17:30.086]  $ future.call.arguments    :List of 1
[13:17:30.086]   ..$ singular.ok: logi FALSE
[13:17:30.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.086]  $ ...future.elements_ii    :List of 1
[13:17:30.086]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.086]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:30.086]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.086]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.086]  $ ...future.seeds_ii       : NULL
[13:17:30.086]  $ ...future.globals.maxSize: NULL
[13:17:30.086]  - attr(*, "where")=List of 5
[13:17:30.086]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.086]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.086]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.086]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.086]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.086]  - attr(*, "resolved")= logi FALSE
[13:17:30.086]  - attr(*, "total_size")= num 5384
[13:17:30.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.086]  - attr(*, "already-done")= logi TRUE
[13:17:30.095] - reassign environment for ‘...future.FUN’
[13:17:30.095] - copied ‘...future.FUN’ to environment
[13:17:30.095] - copied ‘future.call.arguments’ to environment
[13:17:30.095] - copied ‘...future.elements_ii’ to environment
[13:17:30.096] - copied ‘...future.seeds_ii’ to environment
[13:17:30.096] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.096] assign_globals() ... done
[13:17:30.096] requestCore(): workers = 2
[13:17:30.098] MulticoreFuture started
[13:17:30.099] - Launch lazy future ... done
[13:17:30.100] run() for ‘MulticoreFuture’ ... done
[13:17:30.100] Created future:
[13:17:30.100] plan(): Setting new future strategy stack:
[13:17:30.101] List of future strategies:
[13:17:30.101] 1. sequential:
[13:17:30.101]    - args: function (..., envir = parent.frame())
[13:17:30.101]    - tweaked: FALSE
[13:17:30.101]    - call: NULL
[13:17:30.102] plan(): nbrOfWorkers() = 1
[13:17:30.107] plan(): Setting new future strategy stack:
[13:17:30.107] List of future strategies:
[13:17:30.107] 1. multicore:
[13:17:30.107]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.107]    - tweaked: FALSE
[13:17:30.107]    - call: plan(strategy)
[13:17:30.113] plan(): nbrOfWorkers() = 2
[13:17:30.101] MulticoreFuture:
[13:17:30.101] Label: ‘future_by-1’
[13:17:30.101] Expression:
[13:17:30.101] {
[13:17:30.101]     do.call(function(...) {
[13:17:30.101]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.101]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.101]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.101]             on.exit(options(oopts), add = TRUE)
[13:17:30.101]         }
[13:17:30.101]         {
[13:17:30.101]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.101]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.101]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.101]             })
[13:17:30.101]         }
[13:17:30.101]     }, args = future.call.arguments)
[13:17:30.101] }
[13:17:30.101] Lazy evaluation: FALSE
[13:17:30.101] Asynchronous evaluation: TRUE
[13:17:30.101] Local evaluation: TRUE
[13:17:30.101] Environment: R_GlobalEnv
[13:17:30.101] Capture standard output: TRUE
[13:17:30.101] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.101] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.101] Packages: 1 packages (‘stats’)
[13:17:30.101] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.101] Resolved: FALSE
[13:17:30.101] Value: <not collected>
[13:17:30.101] Conditions captured: <none>
[13:17:30.101] Early signaling: FALSE
[13:17:30.101] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.101] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.115] Chunk #1 of 2 ... DONE
[13:17:30.115] Chunk #2 of 2 ...
[13:17:30.115]  - Finding globals in 'X' for chunk #2 ...
[13:17:30.115] getGlobalsAndPackages() ...
[13:17:30.116] Searching for globals...
[13:17:30.116] 
[13:17:30.116] Searching for globals ... DONE
[13:17:30.117] - globals: [0] <none>
[13:17:30.117] getGlobalsAndPackages() ... DONE
[13:17:30.117]    + additional globals found: [n=0] 
[13:17:30.117]    + additional namespaces needed: [n=0] 
[13:17:30.117]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:30.117]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:30.118]  - seeds: <none>
[13:17:30.118] getGlobalsAndPackages() ...
[13:17:30.118] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.118] Resolving globals: FALSE
[13:17:30.118] Tweak future expression to call with '...' arguments ...
[13:17:30.118] {
[13:17:30.118]     do.call(function(...) {
[13:17:30.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.118]             on.exit(options(oopts), add = TRUE)
[13:17:30.118]         }
[13:17:30.118]         {
[13:17:30.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.118]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.118]             })
[13:17:30.118]         }
[13:17:30.118]     }, args = future.call.arguments)
[13:17:30.118] }
[13:17:30.119] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.119] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.120] 
[13:17:30.120] getGlobalsAndPackages() ... DONE
[13:17:30.120] run() for ‘Future’ ...
[13:17:30.121] - state: ‘created’
[13:17:30.121] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.125] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.126]   - Field: ‘label’
[13:17:30.126]   - Field: ‘local’
[13:17:30.126]   - Field: ‘owner’
[13:17:30.126]   - Field: ‘envir’
[13:17:30.126]   - Field: ‘workers’
[13:17:30.126]   - Field: ‘packages’
[13:17:30.126]   - Field: ‘gc’
[13:17:30.127]   - Field: ‘job’
[13:17:30.127]   - Field: ‘conditions’
[13:17:30.127]   - Field: ‘expr’
[13:17:30.127]   - Field: ‘uuid’
[13:17:30.127]   - Field: ‘seed’
[13:17:30.127]   - Field: ‘version’
[13:17:30.127]   - Field: ‘result’
[13:17:30.128]   - Field: ‘asynchronous’
[13:17:30.128]   - Field: ‘calls’
[13:17:30.128]   - Field: ‘globals’
[13:17:30.128]   - Field: ‘stdout’
[13:17:30.128]   - Field: ‘earlySignal’
[13:17:30.128]   - Field: ‘lazy’
[13:17:30.128]   - Field: ‘state’
[13:17:30.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.129] - Launch lazy future ...
[13:17:30.129] Packages needed by the future expression (n = 1): ‘stats’
[13:17:30.129] Packages needed by future strategies (n = 0): <none>
[13:17:30.130] {
[13:17:30.130]     {
[13:17:30.130]         {
[13:17:30.130]             ...future.startTime <- base::Sys.time()
[13:17:30.130]             {
[13:17:30.130]                 {
[13:17:30.130]                   {
[13:17:30.130]                     {
[13:17:30.130]                       {
[13:17:30.130]                         base::local({
[13:17:30.130]                           has_future <- base::requireNamespace("future", 
[13:17:30.130]                             quietly = TRUE)
[13:17:30.130]                           if (has_future) {
[13:17:30.130]                             ns <- base::getNamespace("future")
[13:17:30.130]                             version <- ns[[".package"]][["version"]]
[13:17:30.130]                             if (is.null(version)) 
[13:17:30.130]                               version <- utils::packageVersion("future")
[13:17:30.130]                           }
[13:17:30.130]                           else {
[13:17:30.130]                             version <- NULL
[13:17:30.130]                           }
[13:17:30.130]                           if (!has_future || version < "1.8.0") {
[13:17:30.130]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.130]                               "", base::R.version$version.string), 
[13:17:30.130]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:30.130]                                 base::R.version$platform, 8 * 
[13:17:30.130]                                   base::.Machine$sizeof.pointer), 
[13:17:30.130]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.130]                                 "release", "version")], collapse = " "), 
[13:17:30.130]                               hostname = base::Sys.info()[["nodename"]])
[13:17:30.130]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.130]                               info)
[13:17:30.130]                             info <- base::paste(info, collapse = "; ")
[13:17:30.130]                             if (!has_future) {
[13:17:30.130]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.130]                                 info)
[13:17:30.130]                             }
[13:17:30.130]                             else {
[13:17:30.130]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.130]                                 info, version)
[13:17:30.130]                             }
[13:17:30.130]                             base::stop(msg)
[13:17:30.130]                           }
[13:17:30.130]                         })
[13:17:30.130]                       }
[13:17:30.130]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.130]                       base::options(mc.cores = 1L)
[13:17:30.130]                     }
[13:17:30.130]                     base::local({
[13:17:30.130]                       for (pkg in "stats") {
[13:17:30.130]                         base::loadNamespace(pkg)
[13:17:30.130]                         base::library(pkg, character.only = TRUE)
[13:17:30.130]                       }
[13:17:30.130]                     })
[13:17:30.130]                   }
[13:17:30.130]                   options(future.plan = NULL)
[13:17:30.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.130]                 }
[13:17:30.130]                 ...future.workdir <- getwd()
[13:17:30.130]             }
[13:17:30.130]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.130]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.130]         }
[13:17:30.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.130]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:30.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.130]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.130]             base::names(...future.oldOptions))
[13:17:30.130]     }
[13:17:30.130]     if (FALSE) {
[13:17:30.130]     }
[13:17:30.130]     else {
[13:17:30.130]         if (TRUE) {
[13:17:30.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.130]                 open = "w")
[13:17:30.130]         }
[13:17:30.130]         else {
[13:17:30.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.130]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.130]         }
[13:17:30.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.130]             base::sink(type = "output", split = FALSE)
[13:17:30.130]             base::close(...future.stdout)
[13:17:30.130]         }, add = TRUE)
[13:17:30.130]     }
[13:17:30.130]     ...future.frame <- base::sys.nframe()
[13:17:30.130]     ...future.conditions <- base::list()
[13:17:30.130]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.130]     if (FALSE) {
[13:17:30.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.130]     }
[13:17:30.130]     ...future.result <- base::tryCatch({
[13:17:30.130]         base::withCallingHandlers({
[13:17:30.130]             ...future.value <- base::withVisible(base::local({
[13:17:30.130]                 withCallingHandlers({
[13:17:30.130]                   {
[13:17:30.130]                     do.call(function(...) {
[13:17:30.130]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.130]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.130]                         ...future.globals.maxSize)) {
[13:17:30.130]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.130]                         on.exit(options(oopts), add = TRUE)
[13:17:30.130]                       }
[13:17:30.130]                       {
[13:17:30.130]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.130]                           FUN = function(jj) {
[13:17:30.130]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.130]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.130]                           })
[13:17:30.130]                       }
[13:17:30.130]                     }, args = future.call.arguments)
[13:17:30.130]                   }
[13:17:30.130]                 }, immediateCondition = function(cond) {
[13:17:30.130]                   save_rds <- function (object, pathname, ...) 
[13:17:30.130]                   {
[13:17:30.130]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.130]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.130]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.130]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.130]                         fi_tmp[["mtime"]])
[13:17:30.130]                     }
[13:17:30.130]                     tryCatch({
[13:17:30.130]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.130]                     }, error = function(ex) {
[13:17:30.130]                       msg <- conditionMessage(ex)
[13:17:30.130]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.130]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.130]                         fi_tmp[["mtime"]], msg)
[13:17:30.130]                       ex$message <- msg
[13:17:30.130]                       stop(ex)
[13:17:30.130]                     })
[13:17:30.130]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.130]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.130]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.130]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.130]                       fi <- file.info(pathname)
[13:17:30.130]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.130]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.130]                         fi[["size"]], fi[["mtime"]])
[13:17:30.130]                       stop(msg)
[13:17:30.130]                     }
[13:17:30.130]                     invisible(pathname)
[13:17:30.130]                   }
[13:17:30.130]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.130]                     rootPath = tempdir()) 
[13:17:30.130]                   {
[13:17:30.130]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.130]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.130]                       tmpdir = path, fileext = ".rds")
[13:17:30.130]                     save_rds(obj, file)
[13:17:30.130]                   }
[13:17:30.130]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.130]                   {
[13:17:30.130]                     inherits <- base::inherits
[13:17:30.130]                     invokeRestart <- base::invokeRestart
[13:17:30.130]                     is.null <- base::is.null
[13:17:30.130]                     muffled <- FALSE
[13:17:30.130]                     if (inherits(cond, "message")) {
[13:17:30.130]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.130]                       if (muffled) 
[13:17:30.130]                         invokeRestart("muffleMessage")
[13:17:30.130]                     }
[13:17:30.130]                     else if (inherits(cond, "warning")) {
[13:17:30.130]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.130]                       if (muffled) 
[13:17:30.130]                         invokeRestart("muffleWarning")
[13:17:30.130]                     }
[13:17:30.130]                     else if (inherits(cond, "condition")) {
[13:17:30.130]                       if (!is.null(pattern)) {
[13:17:30.130]                         computeRestarts <- base::computeRestarts
[13:17:30.130]                         grepl <- base::grepl
[13:17:30.130]                         restarts <- computeRestarts(cond)
[13:17:30.130]                         for (restart in restarts) {
[13:17:30.130]                           name <- restart$name
[13:17:30.130]                           if (is.null(name)) 
[13:17:30.130]                             next
[13:17:30.130]                           if (!grepl(pattern, name)) 
[13:17:30.130]                             next
[13:17:30.130]                           invokeRestart(restart)
[13:17:30.130]                           muffled <- TRUE
[13:17:30.130]                           break
[13:17:30.130]                         }
[13:17:30.130]                       }
[13:17:30.130]                     }
[13:17:30.130]                     invisible(muffled)
[13:17:30.130]                   }
[13:17:30.130]                   muffleCondition(cond)
[13:17:30.130]                 })
[13:17:30.130]             }))
[13:17:30.130]             future::FutureResult(value = ...future.value$value, 
[13:17:30.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.130]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.130]                     ...future.globalenv.names))
[13:17:30.130]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.130]         }, condition = base::local({
[13:17:30.130]             c <- base::c
[13:17:30.130]             inherits <- base::inherits
[13:17:30.130]             invokeRestart <- base::invokeRestart
[13:17:30.130]             length <- base::length
[13:17:30.130]             list <- base::list
[13:17:30.130]             seq.int <- base::seq.int
[13:17:30.130]             signalCondition <- base::signalCondition
[13:17:30.130]             sys.calls <- base::sys.calls
[13:17:30.130]             `[[` <- base::`[[`
[13:17:30.130]             `+` <- base::`+`
[13:17:30.130]             `<<-` <- base::`<<-`
[13:17:30.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.130]                   3L)]
[13:17:30.130]             }
[13:17:30.130]             function(cond) {
[13:17:30.130]                 is_error <- inherits(cond, "error")
[13:17:30.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.130]                   NULL)
[13:17:30.130]                 if (is_error) {
[13:17:30.130]                   sessionInformation <- function() {
[13:17:30.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.130]                       search = base::search(), system = base::Sys.info())
[13:17:30.130]                   }
[13:17:30.130]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.130]                     cond$call), session = sessionInformation(), 
[13:17:30.130]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.130]                   signalCondition(cond)
[13:17:30.130]                 }
[13:17:30.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.130]                 "immediateCondition"))) {
[13:17:30.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.130]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.130]                   if (TRUE && !signal) {
[13:17:30.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.130]                     {
[13:17:30.130]                       inherits <- base::inherits
[13:17:30.130]                       invokeRestart <- base::invokeRestart
[13:17:30.130]                       is.null <- base::is.null
[13:17:30.130]                       muffled <- FALSE
[13:17:30.130]                       if (inherits(cond, "message")) {
[13:17:30.130]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.130]                         if (muffled) 
[13:17:30.130]                           invokeRestart("muffleMessage")
[13:17:30.130]                       }
[13:17:30.130]                       else if (inherits(cond, "warning")) {
[13:17:30.130]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.130]                         if (muffled) 
[13:17:30.130]                           invokeRestart("muffleWarning")
[13:17:30.130]                       }
[13:17:30.130]                       else if (inherits(cond, "condition")) {
[13:17:30.130]                         if (!is.null(pattern)) {
[13:17:30.130]                           computeRestarts <- base::computeRestarts
[13:17:30.130]                           grepl <- base::grepl
[13:17:30.130]                           restarts <- computeRestarts(cond)
[13:17:30.130]                           for (restart in restarts) {
[13:17:30.130]                             name <- restart$name
[13:17:30.130]                             if (is.null(name)) 
[13:17:30.130]                               next
[13:17:30.130]                             if (!grepl(pattern, name)) 
[13:17:30.130]                               next
[13:17:30.130]                             invokeRestart(restart)
[13:17:30.130]                             muffled <- TRUE
[13:17:30.130]                             break
[13:17:30.130]                           }
[13:17:30.130]                         }
[13:17:30.130]                       }
[13:17:30.130]                       invisible(muffled)
[13:17:30.130]                     }
[13:17:30.130]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.130]                   }
[13:17:30.130]                 }
[13:17:30.130]                 else {
[13:17:30.130]                   if (TRUE) {
[13:17:30.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.130]                     {
[13:17:30.130]                       inherits <- base::inherits
[13:17:30.130]                       invokeRestart <- base::invokeRestart
[13:17:30.130]                       is.null <- base::is.null
[13:17:30.130]                       muffled <- FALSE
[13:17:30.130]                       if (inherits(cond, "message")) {
[13:17:30.130]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.130]                         if (muffled) 
[13:17:30.130]                           invokeRestart("muffleMessage")
[13:17:30.130]                       }
[13:17:30.130]                       else if (inherits(cond, "warning")) {
[13:17:30.130]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.130]                         if (muffled) 
[13:17:30.130]                           invokeRestart("muffleWarning")
[13:17:30.130]                       }
[13:17:30.130]                       else if (inherits(cond, "condition")) {
[13:17:30.130]                         if (!is.null(pattern)) {
[13:17:30.130]                           computeRestarts <- base::computeRestarts
[13:17:30.130]                           grepl <- base::grepl
[13:17:30.130]                           restarts <- computeRestarts(cond)
[13:17:30.130]                           for (restart in restarts) {
[13:17:30.130]                             name <- restart$name
[13:17:30.130]                             if (is.null(name)) 
[13:17:30.130]                               next
[13:17:30.130]                             if (!grepl(pattern, name)) 
[13:17:30.130]                               next
[13:17:30.130]                             invokeRestart(restart)
[13:17:30.130]                             muffled <- TRUE
[13:17:30.130]                             break
[13:17:30.130]                           }
[13:17:30.130]                         }
[13:17:30.130]                       }
[13:17:30.130]                       invisible(muffled)
[13:17:30.130]                     }
[13:17:30.130]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.130]                   }
[13:17:30.130]                 }
[13:17:30.130]             }
[13:17:30.130]         }))
[13:17:30.130]     }, error = function(ex) {
[13:17:30.130]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.130]                 ...future.rng), started = ...future.startTime, 
[13:17:30.130]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.130]             version = "1.8"), class = "FutureResult")
[13:17:30.130]     }, finally = {
[13:17:30.130]         if (!identical(...future.workdir, getwd())) 
[13:17:30.130]             setwd(...future.workdir)
[13:17:30.130]         {
[13:17:30.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.130]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.130]             }
[13:17:30.130]             base::options(...future.oldOptions)
[13:17:30.130]             if (.Platform$OS.type == "windows") {
[13:17:30.130]                 old_names <- names(...future.oldEnvVars)
[13:17:30.130]                 envs <- base::Sys.getenv()
[13:17:30.130]                 names <- names(envs)
[13:17:30.130]                 common <- intersect(names, old_names)
[13:17:30.130]                 added <- setdiff(names, old_names)
[13:17:30.130]                 removed <- setdiff(old_names, names)
[13:17:30.130]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.130]                   envs[common]]
[13:17:30.130]                 NAMES <- toupper(changed)
[13:17:30.130]                 args <- list()
[13:17:30.130]                 for (kk in seq_along(NAMES)) {
[13:17:30.130]                   name <- changed[[kk]]
[13:17:30.130]                   NAME <- NAMES[[kk]]
[13:17:30.130]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.130]                     next
[13:17:30.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.130]                 }
[13:17:30.130]                 NAMES <- toupper(added)
[13:17:30.130]                 for (kk in seq_along(NAMES)) {
[13:17:30.130]                   name <- added[[kk]]
[13:17:30.130]                   NAME <- NAMES[[kk]]
[13:17:30.130]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.130]                     next
[13:17:30.130]                   args[[name]] <- ""
[13:17:30.130]                 }
[13:17:30.130]                 NAMES <- toupper(removed)
[13:17:30.130]                 for (kk in seq_along(NAMES)) {
[13:17:30.130]                   name <- removed[[kk]]
[13:17:30.130]                   NAME <- NAMES[[kk]]
[13:17:30.130]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.130]                     next
[13:17:30.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.130]                 }
[13:17:30.130]                 if (length(args) > 0) 
[13:17:30.130]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.130]             }
[13:17:30.130]             else {
[13:17:30.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.130]             }
[13:17:30.130]             {
[13:17:30.130]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.130]                   0L) {
[13:17:30.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.130]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.130]                   base::options(opts)
[13:17:30.130]                 }
[13:17:30.130]                 {
[13:17:30.130]                   {
[13:17:30.130]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.130]                     NULL
[13:17:30.130]                   }
[13:17:30.130]                   options(future.plan = NULL)
[13:17:30.130]                   if (is.na(NA_character_)) 
[13:17:30.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.130]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.130]                     envir = parent.frame()) 
[13:17:30.130]                   {
[13:17:30.130]                     default_workers <- missing(workers)
[13:17:30.130]                     if (is.function(workers)) 
[13:17:30.130]                       workers <- workers()
[13:17:30.130]                     workers <- structure(as.integer(workers), 
[13:17:30.130]                       class = class(workers))
[13:17:30.130]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.130]                       1L)
[13:17:30.130]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.130]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.130]                       if (default_workers) 
[13:17:30.130]                         supportsMulticore(warn = TRUE)
[13:17:30.130]                       return(sequential(..., envir = envir))
[13:17:30.130]                     }
[13:17:30.130]                     oopts <- options(mc.cores = workers)
[13:17:30.130]                     on.exit(options(oopts))
[13:17:30.130]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.130]                       envir = envir)
[13:17:30.130]                     if (!future$lazy) 
[13:17:30.130]                       future <- run(future)
[13:17:30.130]                     invisible(future)
[13:17:30.130]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.130]                 }
[13:17:30.130]             }
[13:17:30.130]         }
[13:17:30.130]     })
[13:17:30.130]     if (TRUE) {
[13:17:30.130]         base::sink(type = "output", split = FALSE)
[13:17:30.130]         if (TRUE) {
[13:17:30.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.130]         }
[13:17:30.130]         else {
[13:17:30.130]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.130]         }
[13:17:30.130]         base::close(...future.stdout)
[13:17:30.130]         ...future.stdout <- NULL
[13:17:30.130]     }
[13:17:30.130]     ...future.result$conditions <- ...future.conditions
[13:17:30.130]     ...future.result$finished <- base::Sys.time()
[13:17:30.130]     ...future.result
[13:17:30.130] }
[13:17:30.133] assign_globals() ...
[13:17:30.134] List of 5
[13:17:30.134]  $ ...future.FUN            :function (x, ...)  
[13:17:30.134]  $ future.call.arguments    :List of 1
[13:17:30.134]   ..$ singular.ok: logi FALSE
[13:17:30.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.134]  $ ...future.elements_ii    :List of 2
[13:17:30.134]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.134]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:30.134]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.134]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:30.134]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.134]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:30.134]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.134]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:30.134]  $ ...future.seeds_ii       : NULL
[13:17:30.134]  $ ...future.globals.maxSize: NULL
[13:17:30.134]  - attr(*, "resolved")= logi FALSE
[13:17:30.134]  - attr(*, "total_size")= num 5384
[13:17:30.134]  - attr(*, "where")=List of 5
[13:17:30.134]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.134]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.134]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.134]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.134]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.134]  - attr(*, "already-done")= logi TRUE
[13:17:30.148] - reassign environment for ‘...future.FUN’
[13:17:30.148] - copied ‘...future.FUN’ to environment
[13:17:30.148] - copied ‘future.call.arguments’ to environment
[13:17:30.148] - copied ‘...future.elements_ii’ to environment
[13:17:30.148] - copied ‘...future.seeds_ii’ to environment
[13:17:30.148] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.148] assign_globals() ... done
[13:17:30.148] requestCore(): workers = 2
[13:17:30.151] MulticoreFuture started
[13:17:30.151] - Launch lazy future ... done
[13:17:30.152] run() for ‘MulticoreFuture’ ... done
[13:17:30.152] Created future:
[13:17:30.153] plan(): Setting new future strategy stack:
[13:17:30.153] List of future strategies:
[13:17:30.153] 1. sequential:
[13:17:30.153]    - args: function (..., envir = parent.frame())
[13:17:30.153]    - tweaked: FALSE
[13:17:30.153]    - call: NULL
[13:17:30.154] plan(): nbrOfWorkers() = 1
[13:17:30.160] plan(): Setting new future strategy stack:
[13:17:30.160] List of future strategies:
[13:17:30.160] 1. multicore:
[13:17:30.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.160]    - tweaked: FALSE
[13:17:30.160]    - call: plan(strategy)
[13:17:30.165] plan(): nbrOfWorkers() = 2
[13:17:30.152] MulticoreFuture:
[13:17:30.152] Label: ‘future_by-2’
[13:17:30.152] Expression:
[13:17:30.152] {
[13:17:30.152]     do.call(function(...) {
[13:17:30.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.152]             on.exit(options(oopts), add = TRUE)
[13:17:30.152]         }
[13:17:30.152]         {
[13:17:30.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.152]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.152]             })
[13:17:30.152]         }
[13:17:30.152]     }, args = future.call.arguments)
[13:17:30.152] }
[13:17:30.152] Lazy evaluation: FALSE
[13:17:30.152] Asynchronous evaluation: TRUE
[13:17:30.152] Local evaluation: TRUE
[13:17:30.152] Environment: R_GlobalEnv
[13:17:30.152] Capture standard output: TRUE
[13:17:30.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.152] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.152] Packages: 1 packages (‘stats’)
[13:17:30.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.152] Resolved: FALSE
[13:17:30.152] Value: <not collected>
[13:17:30.152] Conditions captured: <none>
[13:17:30.152] Early signaling: FALSE
[13:17:30.152] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.152] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.166] Chunk #2 of 2 ... DONE
[13:17:30.166] Launching 2 futures (chunks) ... DONE
[13:17:30.166] Resolving 2 futures (chunks) ...
[13:17:30.167] resolve() on list ...
[13:17:30.167]  recursive: 0
[13:17:30.167]  length: 2
[13:17:30.167] 
[13:17:30.167] Future #1
[13:17:30.169] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:30.169] - nx: 2
[13:17:30.169] - relay: TRUE
[13:17:30.169] - stdout: TRUE
[13:17:30.170] - signal: TRUE
[13:17:30.170] - resignal: FALSE
[13:17:30.170] - force: TRUE
[13:17:30.170] - relayed: [n=2] FALSE, FALSE
[13:17:30.170] - queued futures: [n=2] FALSE, FALSE
[13:17:30.170]  - until=1
[13:17:30.170]  - relaying element #1
[13:17:30.171] - relayed: [n=2] TRUE, FALSE
[13:17:30.171] - queued futures: [n=2] TRUE, FALSE
[13:17:30.171] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:30.171]  length: 1 (resolved future 1)
[13:17:30.171] Future #2
[13:17:30.173] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:30.173] - nx: 2
[13:17:30.173] - relay: TRUE
[13:17:30.173] - stdout: TRUE
[13:17:30.173] - signal: TRUE
[13:17:30.173] - resignal: FALSE
[13:17:30.174] - force: TRUE
[13:17:30.174] - relayed: [n=2] TRUE, FALSE
[13:17:30.174] - queued futures: [n=2] TRUE, FALSE
[13:17:30.174]  - until=2
[13:17:30.174]  - relaying element #2
[13:17:30.174] - relayed: [n=2] TRUE, TRUE
[13:17:30.174] - queued futures: [n=2] TRUE, TRUE
[13:17:30.175] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:30.175]  length: 0 (resolved future 2)
[13:17:30.175] Relaying remaining futures
[13:17:30.175] signalConditionsASAP(NULL, pos=0) ...
[13:17:30.175] - nx: 2
[13:17:30.175] - relay: TRUE
[13:17:30.175] - stdout: TRUE
[13:17:30.175] - signal: TRUE
[13:17:30.175] - resignal: FALSE
[13:17:30.176] - force: TRUE
[13:17:30.176] - relayed: [n=2] TRUE, TRUE
[13:17:30.176] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:30.176] - relayed: [n=2] TRUE, TRUE
[13:17:30.176] - queued futures: [n=2] TRUE, TRUE
[13:17:30.176] signalConditionsASAP(NULL, pos=0) ... done
[13:17:30.176] resolve() on list ... DONE
[13:17:30.177]  - Number of value chunks collected: 2
[13:17:30.177] Resolving 2 futures (chunks) ... DONE
[13:17:30.177] Reducing values from 2 chunks ...
[13:17:30.177]  - Number of values collected after concatenation: 3
[13:17:30.177]  - Number of values expected: 3
[13:17:30.177] Reducing values from 2 chunks ... DONE
[13:17:30.177] future_lapply() ... DONE
[13:17:30.178] future_by_internal() ... DONE
[13:17:30.186] future_by_internal() ...
[13:17:30.187] future_lapply() ...
[13:17:30.193] Number of chunks: 2
[13:17:30.193] getGlobalsAndPackagesXApply() ...
[13:17:30.193]  - future.globals: TRUE
[13:17:30.193] getGlobalsAndPackages() ...
[13:17:30.193] Searching for globals...
[13:17:30.195] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:30.195] Searching for globals ... DONE
[13:17:30.195] Resolving globals: FALSE
[13:17:30.196] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:17:30.196] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:17:30.196] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:30.197] - packages: [1] ‘stats’
[13:17:30.197] getGlobalsAndPackages() ... DONE
[13:17:30.197]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:30.197]  - needed namespaces: [n=1] ‘stats’
[13:17:30.197] Finding globals ... DONE
[13:17:30.197]  - use_args: TRUE
[13:17:30.197]  - Getting '...' globals ...
[13:17:30.198] resolve() on list ...
[13:17:30.198]  recursive: 0
[13:17:30.198]  length: 1
[13:17:30.198]  elements: ‘...’
[13:17:30.198]  length: 0 (resolved future 1)
[13:17:30.198] resolve() on list ... DONE
[13:17:30.198]    - '...' content: [n=0] 
[13:17:30.198] List of 1
[13:17:30.198]  $ ...: list()
[13:17:30.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.198]  - attr(*, "where")=List of 1
[13:17:30.198]   ..$ ...:<environment: 0x5609eada0da8> 
[13:17:30.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.198]  - attr(*, "resolved")= logi TRUE
[13:17:30.198]  - attr(*, "total_size")= num NA
[13:17:30.201]  - Getting '...' globals ... DONE
[13:17:30.201] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:17:30.201] List of 4
[13:17:30.201]  $ ...future.FUN:function (x)  
[13:17:30.201]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:30.201]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.201]  $ ...          : list()
[13:17:30.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.201]  - attr(*, "where")=List of 4
[13:17:30.201]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:30.201]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:17:30.201]   ..$ wool         :<environment: R_EmptyEnv> 
[13:17:30.201]   ..$ ...          :<environment: 0x5609eada0da8> 
[13:17:30.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.201]  - attr(*, "resolved")= logi FALSE
[13:17:30.201]  - attr(*, "total_size")= num 2320
[13:17:30.208] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:30.208] getGlobalsAndPackagesXApply() ... DONE
[13:17:30.208] Number of futures (= number of chunks): 2
[13:17:30.208] Launching 2 futures (chunks) ...
[13:17:30.209] Chunk #1 of 2 ...
[13:17:30.209]  - Finding globals in 'X' for chunk #1 ...
[13:17:30.209] getGlobalsAndPackages() ...
[13:17:30.209] Searching for globals...
[13:17:30.209] 
[13:17:30.210] Searching for globals ... DONE
[13:17:30.210] - globals: [0] <none>
[13:17:30.210] getGlobalsAndPackages() ... DONE
[13:17:30.210]    + additional globals found: [n=0] 
[13:17:30.210]    + additional namespaces needed: [n=0] 
[13:17:30.210]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:30.210]  - seeds: <none>
[13:17:30.210] getGlobalsAndPackages() ...
[13:17:30.210] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.211] Resolving globals: FALSE
[13:17:30.211] Tweak future expression to call with '...' arguments ...
[13:17:30.211] {
[13:17:30.211]     do.call(function(...) {
[13:17:30.211]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.211]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.211]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.211]             on.exit(options(oopts), add = TRUE)
[13:17:30.211]         }
[13:17:30.211]         {
[13:17:30.211]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.211]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.211]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.211]             })
[13:17:30.211]         }
[13:17:30.211]     }, args = future.call.arguments)
[13:17:30.211] }
[13:17:30.211] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.212] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.212] 
[13:17:30.212] getGlobalsAndPackages() ... DONE
[13:17:30.212] run() for ‘Future’ ...
[13:17:30.212] - state: ‘created’
[13:17:30.212] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.217] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.217]   - Field: ‘label’
[13:17:30.217]   - Field: ‘local’
[13:17:30.217]   - Field: ‘owner’
[13:17:30.217]   - Field: ‘envir’
[13:17:30.218]   - Field: ‘workers’
[13:17:30.218]   - Field: ‘packages’
[13:17:30.218]   - Field: ‘gc’
[13:17:30.218]   - Field: ‘job’
[13:17:30.218]   - Field: ‘conditions’
[13:17:30.218]   - Field: ‘expr’
[13:17:30.218]   - Field: ‘uuid’
[13:17:30.218]   - Field: ‘seed’
[13:17:30.218]   - Field: ‘version’
[13:17:30.219]   - Field: ‘result’
[13:17:30.219]   - Field: ‘asynchronous’
[13:17:30.219]   - Field: ‘calls’
[13:17:30.219]   - Field: ‘globals’
[13:17:30.219]   - Field: ‘stdout’
[13:17:30.219]   - Field: ‘earlySignal’
[13:17:30.219]   - Field: ‘lazy’
[13:17:30.219]   - Field: ‘state’
[13:17:30.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.219] - Launch lazy future ...
[13:17:30.220] Packages needed by the future expression (n = 1): ‘stats’
[13:17:30.220] Packages needed by future strategies (n = 0): <none>
[13:17:30.220] {
[13:17:30.220]     {
[13:17:30.220]         {
[13:17:30.220]             ...future.startTime <- base::Sys.time()
[13:17:30.220]             {
[13:17:30.220]                 {
[13:17:30.220]                   {
[13:17:30.220]                     {
[13:17:30.220]                       {
[13:17:30.220]                         base::local({
[13:17:30.220]                           has_future <- base::requireNamespace("future", 
[13:17:30.220]                             quietly = TRUE)
[13:17:30.220]                           if (has_future) {
[13:17:30.220]                             ns <- base::getNamespace("future")
[13:17:30.220]                             version <- ns[[".package"]][["version"]]
[13:17:30.220]                             if (is.null(version)) 
[13:17:30.220]                               version <- utils::packageVersion("future")
[13:17:30.220]                           }
[13:17:30.220]                           else {
[13:17:30.220]                             version <- NULL
[13:17:30.220]                           }
[13:17:30.220]                           if (!has_future || version < "1.8.0") {
[13:17:30.220]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.220]                               "", base::R.version$version.string), 
[13:17:30.220]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:30.220]                                 base::R.version$platform, 8 * 
[13:17:30.220]                                   base::.Machine$sizeof.pointer), 
[13:17:30.220]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.220]                                 "release", "version")], collapse = " "), 
[13:17:30.220]                               hostname = base::Sys.info()[["nodename"]])
[13:17:30.220]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.220]                               info)
[13:17:30.220]                             info <- base::paste(info, collapse = "; ")
[13:17:30.220]                             if (!has_future) {
[13:17:30.220]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.220]                                 info)
[13:17:30.220]                             }
[13:17:30.220]                             else {
[13:17:30.220]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.220]                                 info, version)
[13:17:30.220]                             }
[13:17:30.220]                             base::stop(msg)
[13:17:30.220]                           }
[13:17:30.220]                         })
[13:17:30.220]                       }
[13:17:30.220]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.220]                       base::options(mc.cores = 1L)
[13:17:30.220]                     }
[13:17:30.220]                     base::local({
[13:17:30.220]                       for (pkg in "stats") {
[13:17:30.220]                         base::loadNamespace(pkg)
[13:17:30.220]                         base::library(pkg, character.only = TRUE)
[13:17:30.220]                       }
[13:17:30.220]                     })
[13:17:30.220]                   }
[13:17:30.220]                   options(future.plan = NULL)
[13:17:30.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.220]                 }
[13:17:30.220]                 ...future.workdir <- getwd()
[13:17:30.220]             }
[13:17:30.220]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.220]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.220]         }
[13:17:30.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:30.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.220]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.220]             base::names(...future.oldOptions))
[13:17:30.220]     }
[13:17:30.220]     if (FALSE) {
[13:17:30.220]     }
[13:17:30.220]     else {
[13:17:30.220]         if (TRUE) {
[13:17:30.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.220]                 open = "w")
[13:17:30.220]         }
[13:17:30.220]         else {
[13:17:30.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.220]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.220]         }
[13:17:30.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.220]             base::sink(type = "output", split = FALSE)
[13:17:30.220]             base::close(...future.stdout)
[13:17:30.220]         }, add = TRUE)
[13:17:30.220]     }
[13:17:30.220]     ...future.frame <- base::sys.nframe()
[13:17:30.220]     ...future.conditions <- base::list()
[13:17:30.220]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.220]     if (FALSE) {
[13:17:30.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.220]     }
[13:17:30.220]     ...future.result <- base::tryCatch({
[13:17:30.220]         base::withCallingHandlers({
[13:17:30.220]             ...future.value <- base::withVisible(base::local({
[13:17:30.220]                 withCallingHandlers({
[13:17:30.220]                   {
[13:17:30.220]                     do.call(function(...) {
[13:17:30.220]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.220]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.220]                         ...future.globals.maxSize)) {
[13:17:30.220]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.220]                         on.exit(options(oopts), add = TRUE)
[13:17:30.220]                       }
[13:17:30.220]                       {
[13:17:30.220]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.220]                           FUN = function(jj) {
[13:17:30.220]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.220]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.220]                           })
[13:17:30.220]                       }
[13:17:30.220]                     }, args = future.call.arguments)
[13:17:30.220]                   }
[13:17:30.220]                 }, immediateCondition = function(cond) {
[13:17:30.220]                   save_rds <- function (object, pathname, ...) 
[13:17:30.220]                   {
[13:17:30.220]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.220]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.220]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.220]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.220]                         fi_tmp[["mtime"]])
[13:17:30.220]                     }
[13:17:30.220]                     tryCatch({
[13:17:30.220]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.220]                     }, error = function(ex) {
[13:17:30.220]                       msg <- conditionMessage(ex)
[13:17:30.220]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.220]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.220]                         fi_tmp[["mtime"]], msg)
[13:17:30.220]                       ex$message <- msg
[13:17:30.220]                       stop(ex)
[13:17:30.220]                     })
[13:17:30.220]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.220]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.220]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.220]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.220]                       fi <- file.info(pathname)
[13:17:30.220]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.220]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.220]                         fi[["size"]], fi[["mtime"]])
[13:17:30.220]                       stop(msg)
[13:17:30.220]                     }
[13:17:30.220]                     invisible(pathname)
[13:17:30.220]                   }
[13:17:30.220]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.220]                     rootPath = tempdir()) 
[13:17:30.220]                   {
[13:17:30.220]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.220]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.220]                       tmpdir = path, fileext = ".rds")
[13:17:30.220]                     save_rds(obj, file)
[13:17:30.220]                   }
[13:17:30.220]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.220]                   {
[13:17:30.220]                     inherits <- base::inherits
[13:17:30.220]                     invokeRestart <- base::invokeRestart
[13:17:30.220]                     is.null <- base::is.null
[13:17:30.220]                     muffled <- FALSE
[13:17:30.220]                     if (inherits(cond, "message")) {
[13:17:30.220]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.220]                       if (muffled) 
[13:17:30.220]                         invokeRestart("muffleMessage")
[13:17:30.220]                     }
[13:17:30.220]                     else if (inherits(cond, "warning")) {
[13:17:30.220]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.220]                       if (muffled) 
[13:17:30.220]                         invokeRestart("muffleWarning")
[13:17:30.220]                     }
[13:17:30.220]                     else if (inherits(cond, "condition")) {
[13:17:30.220]                       if (!is.null(pattern)) {
[13:17:30.220]                         computeRestarts <- base::computeRestarts
[13:17:30.220]                         grepl <- base::grepl
[13:17:30.220]                         restarts <- computeRestarts(cond)
[13:17:30.220]                         for (restart in restarts) {
[13:17:30.220]                           name <- restart$name
[13:17:30.220]                           if (is.null(name)) 
[13:17:30.220]                             next
[13:17:30.220]                           if (!grepl(pattern, name)) 
[13:17:30.220]                             next
[13:17:30.220]                           invokeRestart(restart)
[13:17:30.220]                           muffled <- TRUE
[13:17:30.220]                           break
[13:17:30.220]                         }
[13:17:30.220]                       }
[13:17:30.220]                     }
[13:17:30.220]                     invisible(muffled)
[13:17:30.220]                   }
[13:17:30.220]                   muffleCondition(cond)
[13:17:30.220]                 })
[13:17:30.220]             }))
[13:17:30.220]             future::FutureResult(value = ...future.value$value, 
[13:17:30.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.220]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.220]                     ...future.globalenv.names))
[13:17:30.220]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.220]         }, condition = base::local({
[13:17:30.220]             c <- base::c
[13:17:30.220]             inherits <- base::inherits
[13:17:30.220]             invokeRestart <- base::invokeRestart
[13:17:30.220]             length <- base::length
[13:17:30.220]             list <- base::list
[13:17:30.220]             seq.int <- base::seq.int
[13:17:30.220]             signalCondition <- base::signalCondition
[13:17:30.220]             sys.calls <- base::sys.calls
[13:17:30.220]             `[[` <- base::`[[`
[13:17:30.220]             `+` <- base::`+`
[13:17:30.220]             `<<-` <- base::`<<-`
[13:17:30.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.220]                   3L)]
[13:17:30.220]             }
[13:17:30.220]             function(cond) {
[13:17:30.220]                 is_error <- inherits(cond, "error")
[13:17:30.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.220]                   NULL)
[13:17:30.220]                 if (is_error) {
[13:17:30.220]                   sessionInformation <- function() {
[13:17:30.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.220]                       search = base::search(), system = base::Sys.info())
[13:17:30.220]                   }
[13:17:30.220]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.220]                     cond$call), session = sessionInformation(), 
[13:17:30.220]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.220]                   signalCondition(cond)
[13:17:30.220]                 }
[13:17:30.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.220]                 "immediateCondition"))) {
[13:17:30.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.220]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.220]                   if (TRUE && !signal) {
[13:17:30.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.220]                     {
[13:17:30.220]                       inherits <- base::inherits
[13:17:30.220]                       invokeRestart <- base::invokeRestart
[13:17:30.220]                       is.null <- base::is.null
[13:17:30.220]                       muffled <- FALSE
[13:17:30.220]                       if (inherits(cond, "message")) {
[13:17:30.220]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.220]                         if (muffled) 
[13:17:30.220]                           invokeRestart("muffleMessage")
[13:17:30.220]                       }
[13:17:30.220]                       else if (inherits(cond, "warning")) {
[13:17:30.220]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.220]                         if (muffled) 
[13:17:30.220]                           invokeRestart("muffleWarning")
[13:17:30.220]                       }
[13:17:30.220]                       else if (inherits(cond, "condition")) {
[13:17:30.220]                         if (!is.null(pattern)) {
[13:17:30.220]                           computeRestarts <- base::computeRestarts
[13:17:30.220]                           grepl <- base::grepl
[13:17:30.220]                           restarts <- computeRestarts(cond)
[13:17:30.220]                           for (restart in restarts) {
[13:17:30.220]                             name <- restart$name
[13:17:30.220]                             if (is.null(name)) 
[13:17:30.220]                               next
[13:17:30.220]                             if (!grepl(pattern, name)) 
[13:17:30.220]                               next
[13:17:30.220]                             invokeRestart(restart)
[13:17:30.220]                             muffled <- TRUE
[13:17:30.220]                             break
[13:17:30.220]                           }
[13:17:30.220]                         }
[13:17:30.220]                       }
[13:17:30.220]                       invisible(muffled)
[13:17:30.220]                     }
[13:17:30.220]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.220]                   }
[13:17:30.220]                 }
[13:17:30.220]                 else {
[13:17:30.220]                   if (TRUE) {
[13:17:30.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.220]                     {
[13:17:30.220]                       inherits <- base::inherits
[13:17:30.220]                       invokeRestart <- base::invokeRestart
[13:17:30.220]                       is.null <- base::is.null
[13:17:30.220]                       muffled <- FALSE
[13:17:30.220]                       if (inherits(cond, "message")) {
[13:17:30.220]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.220]                         if (muffled) 
[13:17:30.220]                           invokeRestart("muffleMessage")
[13:17:30.220]                       }
[13:17:30.220]                       else if (inherits(cond, "warning")) {
[13:17:30.220]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.220]                         if (muffled) 
[13:17:30.220]                           invokeRestart("muffleWarning")
[13:17:30.220]                       }
[13:17:30.220]                       else if (inherits(cond, "condition")) {
[13:17:30.220]                         if (!is.null(pattern)) {
[13:17:30.220]                           computeRestarts <- base::computeRestarts
[13:17:30.220]                           grepl <- base::grepl
[13:17:30.220]                           restarts <- computeRestarts(cond)
[13:17:30.220]                           for (restart in restarts) {
[13:17:30.220]                             name <- restart$name
[13:17:30.220]                             if (is.null(name)) 
[13:17:30.220]                               next
[13:17:30.220]                             if (!grepl(pattern, name)) 
[13:17:30.220]                               next
[13:17:30.220]                             invokeRestart(restart)
[13:17:30.220]                             muffled <- TRUE
[13:17:30.220]                             break
[13:17:30.220]                           }
[13:17:30.220]                         }
[13:17:30.220]                       }
[13:17:30.220]                       invisible(muffled)
[13:17:30.220]                     }
[13:17:30.220]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.220]                   }
[13:17:30.220]                 }
[13:17:30.220]             }
[13:17:30.220]         }))
[13:17:30.220]     }, error = function(ex) {
[13:17:30.220]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.220]                 ...future.rng), started = ...future.startTime, 
[13:17:30.220]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.220]             version = "1.8"), class = "FutureResult")
[13:17:30.220]     }, finally = {
[13:17:30.220]         if (!identical(...future.workdir, getwd())) 
[13:17:30.220]             setwd(...future.workdir)
[13:17:30.220]         {
[13:17:30.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.220]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.220]             }
[13:17:30.220]             base::options(...future.oldOptions)
[13:17:30.220]             if (.Platform$OS.type == "windows") {
[13:17:30.220]                 old_names <- names(...future.oldEnvVars)
[13:17:30.220]                 envs <- base::Sys.getenv()
[13:17:30.220]                 names <- names(envs)
[13:17:30.220]                 common <- intersect(names, old_names)
[13:17:30.220]                 added <- setdiff(names, old_names)
[13:17:30.220]                 removed <- setdiff(old_names, names)
[13:17:30.220]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.220]                   envs[common]]
[13:17:30.220]                 NAMES <- toupper(changed)
[13:17:30.220]                 args <- list()
[13:17:30.220]                 for (kk in seq_along(NAMES)) {
[13:17:30.220]                   name <- changed[[kk]]
[13:17:30.220]                   NAME <- NAMES[[kk]]
[13:17:30.220]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.220]                     next
[13:17:30.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.220]                 }
[13:17:30.220]                 NAMES <- toupper(added)
[13:17:30.220]                 for (kk in seq_along(NAMES)) {
[13:17:30.220]                   name <- added[[kk]]
[13:17:30.220]                   NAME <- NAMES[[kk]]
[13:17:30.220]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.220]                     next
[13:17:30.220]                   args[[name]] <- ""
[13:17:30.220]                 }
[13:17:30.220]                 NAMES <- toupper(removed)
[13:17:30.220]                 for (kk in seq_along(NAMES)) {
[13:17:30.220]                   name <- removed[[kk]]
[13:17:30.220]                   NAME <- NAMES[[kk]]
[13:17:30.220]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.220]                     next
[13:17:30.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.220]                 }
[13:17:30.220]                 if (length(args) > 0) 
[13:17:30.220]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.220]             }
[13:17:30.220]             else {
[13:17:30.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.220]             }
[13:17:30.220]             {
[13:17:30.220]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.220]                   0L) {
[13:17:30.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.220]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.220]                   base::options(opts)
[13:17:30.220]                 }
[13:17:30.220]                 {
[13:17:30.220]                   {
[13:17:30.220]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.220]                     NULL
[13:17:30.220]                   }
[13:17:30.220]                   options(future.plan = NULL)
[13:17:30.220]                   if (is.na(NA_character_)) 
[13:17:30.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.220]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.220]                     envir = parent.frame()) 
[13:17:30.220]                   {
[13:17:30.220]                     default_workers <- missing(workers)
[13:17:30.220]                     if (is.function(workers)) 
[13:17:30.220]                       workers <- workers()
[13:17:30.220]                     workers <- structure(as.integer(workers), 
[13:17:30.220]                       class = class(workers))
[13:17:30.220]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.220]                       1L)
[13:17:30.220]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.220]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.220]                       if (default_workers) 
[13:17:30.220]                         supportsMulticore(warn = TRUE)
[13:17:30.220]                       return(sequential(..., envir = envir))
[13:17:30.220]                     }
[13:17:30.220]                     oopts <- options(mc.cores = workers)
[13:17:30.220]                     on.exit(options(oopts))
[13:17:30.220]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.220]                       envir = envir)
[13:17:30.220]                     if (!future$lazy) 
[13:17:30.220]                       future <- run(future)
[13:17:30.220]                     invisible(future)
[13:17:30.220]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.220]                 }
[13:17:30.220]             }
[13:17:30.220]         }
[13:17:30.220]     })
[13:17:30.220]     if (TRUE) {
[13:17:30.220]         base::sink(type = "output", split = FALSE)
[13:17:30.220]         if (TRUE) {
[13:17:30.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.220]         }
[13:17:30.220]         else {
[13:17:30.220]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.220]         }
[13:17:30.220]         base::close(...future.stdout)
[13:17:30.220]         ...future.stdout <- NULL
[13:17:30.220]     }
[13:17:30.220]     ...future.result$conditions <- ...future.conditions
[13:17:30.220]     ...future.result$finished <- base::Sys.time()
[13:17:30.220]     ...future.result
[13:17:30.220] }
[13:17:30.223] assign_globals() ...
[13:17:30.223] List of 7
[13:17:30.223]  $ ...future.FUN            :function (x)  
[13:17:30.223]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:30.223]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.223]  $ future.call.arguments    : list()
[13:17:30.223]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.223]  $ ...future.elements_ii    :List of 1
[13:17:30.223]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.223]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:30.223]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.223]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.223]  $ ...future.seeds_ii       : NULL
[13:17:30.223]  $ ...future.globals.maxSize: NULL
[13:17:30.223]  - attr(*, "where")=List of 7
[13:17:30.223]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.223]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:17:30.223]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:17:30.223]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.223]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.223]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.223]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.223]  - attr(*, "resolved")= logi FALSE
[13:17:30.223]  - attr(*, "total_size")= num 2320
[13:17:30.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.223]  - attr(*, "already-done")= logi TRUE
[13:17:30.233] - reassign environment for ‘...future.FUN’
[13:17:30.233] - copied ‘...future.FUN’ to environment
[13:17:30.233] - copied ‘breaks’ to environment
[13:17:30.233] - copied ‘wool’ to environment
[13:17:30.233] - copied ‘future.call.arguments’ to environment
[13:17:30.233] - copied ‘...future.elements_ii’ to environment
[13:17:30.234] - copied ‘...future.seeds_ii’ to environment
[13:17:30.234] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.234] assign_globals() ... done
[13:17:30.234] requestCore(): workers = 2
[13:17:30.236] MulticoreFuture started
[13:17:30.237] - Launch lazy future ... done
[13:17:30.238] run() for ‘MulticoreFuture’ ... done
[13:17:30.238] Created future:
[13:17:30.238] plan(): Setting new future strategy stack:
[13:17:30.239] List of future strategies:
[13:17:30.239] 1. sequential:
[13:17:30.239]    - args: function (..., envir = parent.frame())
[13:17:30.239]    - tweaked: FALSE
[13:17:30.239]    - call: NULL
[13:17:30.240] plan(): nbrOfWorkers() = 1
[13:17:30.245] plan(): Setting new future strategy stack:
[13:17:30.246] List of future strategies:
[13:17:30.246] 1. multicore:
[13:17:30.246]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.246]    - tweaked: FALSE
[13:17:30.246]    - call: plan(strategy)
[13:17:30.252] plan(): nbrOfWorkers() = 2
[13:17:30.239] MulticoreFuture:
[13:17:30.239] Label: ‘future_by-1’
[13:17:30.239] Expression:
[13:17:30.239] {
[13:17:30.239]     do.call(function(...) {
[13:17:30.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.239]             on.exit(options(oopts), add = TRUE)
[13:17:30.239]         }
[13:17:30.239]         {
[13:17:30.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.239]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.239]             })
[13:17:30.239]         }
[13:17:30.239]     }, args = future.call.arguments)
[13:17:30.239] }
[13:17:30.239] Lazy evaluation: FALSE
[13:17:30.239] Asynchronous evaluation: TRUE
[13:17:30.239] Local evaluation: TRUE
[13:17:30.239] Environment: 0x5609ea25f3a8
[13:17:30.239] Capture standard output: TRUE
[13:17:30.239] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.239] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[13:17:30.239] Packages: 1 packages (‘stats’)
[13:17:30.239] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.239] Resolved: FALSE
[13:17:30.239] Value: <not collected>
[13:17:30.239] Conditions captured: <none>
[13:17:30.239] Early signaling: FALSE
[13:17:30.239] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.239] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.254] Chunk #1 of 2 ... DONE
[13:17:30.254] Chunk #2 of 2 ...
[13:17:30.254]  - Finding globals in 'X' for chunk #2 ...
[13:17:30.254] getGlobalsAndPackages() ...
[13:17:30.254] Searching for globals...
[13:17:30.255] 
[13:17:30.256] Searching for globals ... DONE
[13:17:30.256] - globals: [0] <none>
[13:17:30.256] getGlobalsAndPackages() ... DONE
[13:17:30.256]    + additional globals found: [n=0] 
[13:17:30.256]    + additional namespaces needed: [n=0] 
[13:17:30.256]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:30.257]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:30.257]  - seeds: <none>
[13:17:30.257] getGlobalsAndPackages() ...
[13:17:30.257] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.258] Resolving globals: FALSE
[13:17:30.258] Tweak future expression to call with '...' arguments ...
[13:17:30.258] {
[13:17:30.258]     do.call(function(...) {
[13:17:30.258]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.258]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.258]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.258]             on.exit(options(oopts), add = TRUE)
[13:17:30.258]         }
[13:17:30.258]         {
[13:17:30.258]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.258]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.258]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.258]             })
[13:17:30.258]         }
[13:17:30.258]     }, args = future.call.arguments)
[13:17:30.258] }
[13:17:30.258] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.259] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.259] 
[13:17:30.260] getGlobalsAndPackages() ... DONE
[13:17:30.260] run() for ‘Future’ ...
[13:17:30.260] - state: ‘created’
[13:17:30.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.266]   - Field: ‘label’
[13:17:30.266]   - Field: ‘local’
[13:17:30.266]   - Field: ‘owner’
[13:17:30.266]   - Field: ‘envir’
[13:17:30.266]   - Field: ‘workers’
[13:17:30.267]   - Field: ‘packages’
[13:17:30.267]   - Field: ‘gc’
[13:17:30.267]   - Field: ‘job’
[13:17:30.267]   - Field: ‘conditions’
[13:17:30.267]   - Field: ‘expr’
[13:17:30.267]   - Field: ‘uuid’
[13:17:30.267]   - Field: ‘seed’
[13:17:30.268]   - Field: ‘version’
[13:17:30.268]   - Field: ‘result’
[13:17:30.268]   - Field: ‘asynchronous’
[13:17:30.268]   - Field: ‘calls’
[13:17:30.268]   - Field: ‘globals’
[13:17:30.268]   - Field: ‘stdout’
[13:17:30.268]   - Field: ‘earlySignal’
[13:17:30.268]   - Field: ‘lazy’
[13:17:30.269]   - Field: ‘state’
[13:17:30.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.269] - Launch lazy future ...
[13:17:30.269] Packages needed by the future expression (n = 1): ‘stats’
[13:17:30.269] Packages needed by future strategies (n = 0): <none>
[13:17:30.270] {
[13:17:30.270]     {
[13:17:30.270]         {
[13:17:30.270]             ...future.startTime <- base::Sys.time()
[13:17:30.270]             {
[13:17:30.270]                 {
[13:17:30.270]                   {
[13:17:30.270]                     {
[13:17:30.270]                       {
[13:17:30.270]                         base::local({
[13:17:30.270]                           has_future <- base::requireNamespace("future", 
[13:17:30.270]                             quietly = TRUE)
[13:17:30.270]                           if (has_future) {
[13:17:30.270]                             ns <- base::getNamespace("future")
[13:17:30.270]                             version <- ns[[".package"]][["version"]]
[13:17:30.270]                             if (is.null(version)) 
[13:17:30.270]                               version <- utils::packageVersion("future")
[13:17:30.270]                           }
[13:17:30.270]                           else {
[13:17:30.270]                             version <- NULL
[13:17:30.270]                           }
[13:17:30.270]                           if (!has_future || version < "1.8.0") {
[13:17:30.270]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.270]                               "", base::R.version$version.string), 
[13:17:30.270]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:30.270]                                 base::R.version$platform, 8 * 
[13:17:30.270]                                   base::.Machine$sizeof.pointer), 
[13:17:30.270]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.270]                                 "release", "version")], collapse = " "), 
[13:17:30.270]                               hostname = base::Sys.info()[["nodename"]])
[13:17:30.270]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.270]                               info)
[13:17:30.270]                             info <- base::paste(info, collapse = "; ")
[13:17:30.270]                             if (!has_future) {
[13:17:30.270]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.270]                                 info)
[13:17:30.270]                             }
[13:17:30.270]                             else {
[13:17:30.270]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.270]                                 info, version)
[13:17:30.270]                             }
[13:17:30.270]                             base::stop(msg)
[13:17:30.270]                           }
[13:17:30.270]                         })
[13:17:30.270]                       }
[13:17:30.270]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.270]                       base::options(mc.cores = 1L)
[13:17:30.270]                     }
[13:17:30.270]                     base::local({
[13:17:30.270]                       for (pkg in "stats") {
[13:17:30.270]                         base::loadNamespace(pkg)
[13:17:30.270]                         base::library(pkg, character.only = TRUE)
[13:17:30.270]                       }
[13:17:30.270]                     })
[13:17:30.270]                   }
[13:17:30.270]                   options(future.plan = NULL)
[13:17:30.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.270]                 }
[13:17:30.270]                 ...future.workdir <- getwd()
[13:17:30.270]             }
[13:17:30.270]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.270]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.270]         }
[13:17:30.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.270]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:30.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.270]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.270]             base::names(...future.oldOptions))
[13:17:30.270]     }
[13:17:30.270]     if (FALSE) {
[13:17:30.270]     }
[13:17:30.270]     else {
[13:17:30.270]         if (TRUE) {
[13:17:30.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.270]                 open = "w")
[13:17:30.270]         }
[13:17:30.270]         else {
[13:17:30.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.270]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.270]         }
[13:17:30.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.270]             base::sink(type = "output", split = FALSE)
[13:17:30.270]             base::close(...future.stdout)
[13:17:30.270]         }, add = TRUE)
[13:17:30.270]     }
[13:17:30.270]     ...future.frame <- base::sys.nframe()
[13:17:30.270]     ...future.conditions <- base::list()
[13:17:30.270]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.270]     if (FALSE) {
[13:17:30.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.270]     }
[13:17:30.270]     ...future.result <- base::tryCatch({
[13:17:30.270]         base::withCallingHandlers({
[13:17:30.270]             ...future.value <- base::withVisible(base::local({
[13:17:30.270]                 withCallingHandlers({
[13:17:30.270]                   {
[13:17:30.270]                     do.call(function(...) {
[13:17:30.270]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.270]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.270]                         ...future.globals.maxSize)) {
[13:17:30.270]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.270]                         on.exit(options(oopts), add = TRUE)
[13:17:30.270]                       }
[13:17:30.270]                       {
[13:17:30.270]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.270]                           FUN = function(jj) {
[13:17:30.270]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.270]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.270]                           })
[13:17:30.270]                       }
[13:17:30.270]                     }, args = future.call.arguments)
[13:17:30.270]                   }
[13:17:30.270]                 }, immediateCondition = function(cond) {
[13:17:30.270]                   save_rds <- function (object, pathname, ...) 
[13:17:30.270]                   {
[13:17:30.270]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.270]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.270]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.270]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.270]                         fi_tmp[["mtime"]])
[13:17:30.270]                     }
[13:17:30.270]                     tryCatch({
[13:17:30.270]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.270]                     }, error = function(ex) {
[13:17:30.270]                       msg <- conditionMessage(ex)
[13:17:30.270]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.270]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.270]                         fi_tmp[["mtime"]], msg)
[13:17:30.270]                       ex$message <- msg
[13:17:30.270]                       stop(ex)
[13:17:30.270]                     })
[13:17:30.270]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.270]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.270]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.270]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.270]                       fi <- file.info(pathname)
[13:17:30.270]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.270]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.270]                         fi[["size"]], fi[["mtime"]])
[13:17:30.270]                       stop(msg)
[13:17:30.270]                     }
[13:17:30.270]                     invisible(pathname)
[13:17:30.270]                   }
[13:17:30.270]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.270]                     rootPath = tempdir()) 
[13:17:30.270]                   {
[13:17:30.270]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.270]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.270]                       tmpdir = path, fileext = ".rds")
[13:17:30.270]                     save_rds(obj, file)
[13:17:30.270]                   }
[13:17:30.270]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.270]                   {
[13:17:30.270]                     inherits <- base::inherits
[13:17:30.270]                     invokeRestart <- base::invokeRestart
[13:17:30.270]                     is.null <- base::is.null
[13:17:30.270]                     muffled <- FALSE
[13:17:30.270]                     if (inherits(cond, "message")) {
[13:17:30.270]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.270]                       if (muffled) 
[13:17:30.270]                         invokeRestart("muffleMessage")
[13:17:30.270]                     }
[13:17:30.270]                     else if (inherits(cond, "warning")) {
[13:17:30.270]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.270]                       if (muffled) 
[13:17:30.270]                         invokeRestart("muffleWarning")
[13:17:30.270]                     }
[13:17:30.270]                     else if (inherits(cond, "condition")) {
[13:17:30.270]                       if (!is.null(pattern)) {
[13:17:30.270]                         computeRestarts <- base::computeRestarts
[13:17:30.270]                         grepl <- base::grepl
[13:17:30.270]                         restarts <- computeRestarts(cond)
[13:17:30.270]                         for (restart in restarts) {
[13:17:30.270]                           name <- restart$name
[13:17:30.270]                           if (is.null(name)) 
[13:17:30.270]                             next
[13:17:30.270]                           if (!grepl(pattern, name)) 
[13:17:30.270]                             next
[13:17:30.270]                           invokeRestart(restart)
[13:17:30.270]                           muffled <- TRUE
[13:17:30.270]                           break
[13:17:30.270]                         }
[13:17:30.270]                       }
[13:17:30.270]                     }
[13:17:30.270]                     invisible(muffled)
[13:17:30.270]                   }
[13:17:30.270]                   muffleCondition(cond)
[13:17:30.270]                 })
[13:17:30.270]             }))
[13:17:30.270]             future::FutureResult(value = ...future.value$value, 
[13:17:30.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.270]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.270]                     ...future.globalenv.names))
[13:17:30.270]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.270]         }, condition = base::local({
[13:17:30.270]             c <- base::c
[13:17:30.270]             inherits <- base::inherits
[13:17:30.270]             invokeRestart <- base::invokeRestart
[13:17:30.270]             length <- base::length
[13:17:30.270]             list <- base::list
[13:17:30.270]             seq.int <- base::seq.int
[13:17:30.270]             signalCondition <- base::signalCondition
[13:17:30.270]             sys.calls <- base::sys.calls
[13:17:30.270]             `[[` <- base::`[[`
[13:17:30.270]             `+` <- base::`+`
[13:17:30.270]             `<<-` <- base::`<<-`
[13:17:30.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.270]                   3L)]
[13:17:30.270]             }
[13:17:30.270]             function(cond) {
[13:17:30.270]                 is_error <- inherits(cond, "error")
[13:17:30.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.270]                   NULL)
[13:17:30.270]                 if (is_error) {
[13:17:30.270]                   sessionInformation <- function() {
[13:17:30.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.270]                       search = base::search(), system = base::Sys.info())
[13:17:30.270]                   }
[13:17:30.270]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.270]                     cond$call), session = sessionInformation(), 
[13:17:30.270]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.270]                   signalCondition(cond)
[13:17:30.270]                 }
[13:17:30.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.270]                 "immediateCondition"))) {
[13:17:30.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.270]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.270]                   if (TRUE && !signal) {
[13:17:30.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.270]                     {
[13:17:30.270]                       inherits <- base::inherits
[13:17:30.270]                       invokeRestart <- base::invokeRestart
[13:17:30.270]                       is.null <- base::is.null
[13:17:30.270]                       muffled <- FALSE
[13:17:30.270]                       if (inherits(cond, "message")) {
[13:17:30.270]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.270]                         if (muffled) 
[13:17:30.270]                           invokeRestart("muffleMessage")
[13:17:30.270]                       }
[13:17:30.270]                       else if (inherits(cond, "warning")) {
[13:17:30.270]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.270]                         if (muffled) 
[13:17:30.270]                           invokeRestart("muffleWarning")
[13:17:30.270]                       }
[13:17:30.270]                       else if (inherits(cond, "condition")) {
[13:17:30.270]                         if (!is.null(pattern)) {
[13:17:30.270]                           computeRestarts <- base::computeRestarts
[13:17:30.270]                           grepl <- base::grepl
[13:17:30.270]                           restarts <- computeRestarts(cond)
[13:17:30.270]                           for (restart in restarts) {
[13:17:30.270]                             name <- restart$name
[13:17:30.270]                             if (is.null(name)) 
[13:17:30.270]                               next
[13:17:30.270]                             if (!grepl(pattern, name)) 
[13:17:30.270]                               next
[13:17:30.270]                             invokeRestart(restart)
[13:17:30.270]                             muffled <- TRUE
[13:17:30.270]                             break
[13:17:30.270]                           }
[13:17:30.270]                         }
[13:17:30.270]                       }
[13:17:30.270]                       invisible(muffled)
[13:17:30.270]                     }
[13:17:30.270]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.270]                   }
[13:17:30.270]                 }
[13:17:30.270]                 else {
[13:17:30.270]                   if (TRUE) {
[13:17:30.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.270]                     {
[13:17:30.270]                       inherits <- base::inherits
[13:17:30.270]                       invokeRestart <- base::invokeRestart
[13:17:30.270]                       is.null <- base::is.null
[13:17:30.270]                       muffled <- FALSE
[13:17:30.270]                       if (inherits(cond, "message")) {
[13:17:30.270]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.270]                         if (muffled) 
[13:17:30.270]                           invokeRestart("muffleMessage")
[13:17:30.270]                       }
[13:17:30.270]                       else if (inherits(cond, "warning")) {
[13:17:30.270]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.270]                         if (muffled) 
[13:17:30.270]                           invokeRestart("muffleWarning")
[13:17:30.270]                       }
[13:17:30.270]                       else if (inherits(cond, "condition")) {
[13:17:30.270]                         if (!is.null(pattern)) {
[13:17:30.270]                           computeRestarts <- base::computeRestarts
[13:17:30.270]                           grepl <- base::grepl
[13:17:30.270]                           restarts <- computeRestarts(cond)
[13:17:30.270]                           for (restart in restarts) {
[13:17:30.270]                             name <- restart$name
[13:17:30.270]                             if (is.null(name)) 
[13:17:30.270]                               next
[13:17:30.270]                             if (!grepl(pattern, name)) 
[13:17:30.270]                               next
[13:17:30.270]                             invokeRestart(restart)
[13:17:30.270]                             muffled <- TRUE
[13:17:30.270]                             break
[13:17:30.270]                           }
[13:17:30.270]                         }
[13:17:30.270]                       }
[13:17:30.270]                       invisible(muffled)
[13:17:30.270]                     }
[13:17:30.270]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.270]                   }
[13:17:30.270]                 }
[13:17:30.270]             }
[13:17:30.270]         }))
[13:17:30.270]     }, error = function(ex) {
[13:17:30.270]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.270]                 ...future.rng), started = ...future.startTime, 
[13:17:30.270]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.270]             version = "1.8"), class = "FutureResult")
[13:17:30.270]     }, finally = {
[13:17:30.270]         if (!identical(...future.workdir, getwd())) 
[13:17:30.270]             setwd(...future.workdir)
[13:17:30.270]         {
[13:17:30.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.270]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.270]             }
[13:17:30.270]             base::options(...future.oldOptions)
[13:17:30.270]             if (.Platform$OS.type == "windows") {
[13:17:30.270]                 old_names <- names(...future.oldEnvVars)
[13:17:30.270]                 envs <- base::Sys.getenv()
[13:17:30.270]                 names <- names(envs)
[13:17:30.270]                 common <- intersect(names, old_names)
[13:17:30.270]                 added <- setdiff(names, old_names)
[13:17:30.270]                 removed <- setdiff(old_names, names)
[13:17:30.270]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.270]                   envs[common]]
[13:17:30.270]                 NAMES <- toupper(changed)
[13:17:30.270]                 args <- list()
[13:17:30.270]                 for (kk in seq_along(NAMES)) {
[13:17:30.270]                   name <- changed[[kk]]
[13:17:30.270]                   NAME <- NAMES[[kk]]
[13:17:30.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.270]                     next
[13:17:30.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.270]                 }
[13:17:30.270]                 NAMES <- toupper(added)
[13:17:30.270]                 for (kk in seq_along(NAMES)) {
[13:17:30.270]                   name <- added[[kk]]
[13:17:30.270]                   NAME <- NAMES[[kk]]
[13:17:30.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.270]                     next
[13:17:30.270]                   args[[name]] <- ""
[13:17:30.270]                 }
[13:17:30.270]                 NAMES <- toupper(removed)
[13:17:30.270]                 for (kk in seq_along(NAMES)) {
[13:17:30.270]                   name <- removed[[kk]]
[13:17:30.270]                   NAME <- NAMES[[kk]]
[13:17:30.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.270]                     next
[13:17:30.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.270]                 }
[13:17:30.270]                 if (length(args) > 0) 
[13:17:30.270]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.270]             }
[13:17:30.270]             else {
[13:17:30.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.270]             }
[13:17:30.270]             {
[13:17:30.270]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.270]                   0L) {
[13:17:30.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.270]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.270]                   base::options(opts)
[13:17:30.270]                 }
[13:17:30.270]                 {
[13:17:30.270]                   {
[13:17:30.270]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.270]                     NULL
[13:17:30.270]                   }
[13:17:30.270]                   options(future.plan = NULL)
[13:17:30.270]                   if (is.na(NA_character_)) 
[13:17:30.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.270]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.270]                     envir = parent.frame()) 
[13:17:30.270]                   {
[13:17:30.270]                     default_workers <- missing(workers)
[13:17:30.270]                     if (is.function(workers)) 
[13:17:30.270]                       workers <- workers()
[13:17:30.270]                     workers <- structure(as.integer(workers), 
[13:17:30.270]                       class = class(workers))
[13:17:30.270]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.270]                       1L)
[13:17:30.270]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.270]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.270]                       if (default_workers) 
[13:17:30.270]                         supportsMulticore(warn = TRUE)
[13:17:30.270]                       return(sequential(..., envir = envir))
[13:17:30.270]                     }
[13:17:30.270]                     oopts <- options(mc.cores = workers)
[13:17:30.270]                     on.exit(options(oopts))
[13:17:30.270]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.270]                       envir = envir)
[13:17:30.270]                     if (!future$lazy) 
[13:17:30.270]                       future <- run(future)
[13:17:30.270]                     invisible(future)
[13:17:30.270]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.270]                 }
[13:17:30.270]             }
[13:17:30.270]         }
[13:17:30.270]     })
[13:17:30.270]     if (TRUE) {
[13:17:30.270]         base::sink(type = "output", split = FALSE)
[13:17:30.270]         if (TRUE) {
[13:17:30.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.270]         }
[13:17:30.270]         else {
[13:17:30.270]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.270]         }
[13:17:30.270]         base::close(...future.stdout)
[13:17:30.270]         ...future.stdout <- NULL
[13:17:30.270]     }
[13:17:30.270]     ...future.result$conditions <- ...future.conditions
[13:17:30.270]     ...future.result$finished <- base::Sys.time()
[13:17:30.270]     ...future.result
[13:17:30.270] }
[13:17:30.274] assign_globals() ...
[13:17:30.274] List of 7
[13:17:30.274]  $ ...future.FUN            :function (x)  
[13:17:30.274]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:30.274]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.274]  $ future.call.arguments    : list()
[13:17:30.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.274]  $ ...future.elements_ii    :List of 2
[13:17:30.274]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.274]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:30.274]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.274]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:30.274]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.274]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:30.274]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.274]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:30.274]  $ ...future.seeds_ii       : NULL
[13:17:30.274]  $ ...future.globals.maxSize: NULL
[13:17:30.274]  - attr(*, "resolved")= logi FALSE
[13:17:30.274]  - attr(*, "total_size")= num 2320
[13:17:30.274]  - attr(*, "where")=List of 7
[13:17:30.274]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.274]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:17:30.274]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:17:30.274]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.274]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.274]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.274]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.274]  - attr(*, "already-done")= logi TRUE
[13:17:30.288] - reassign environment for ‘...future.FUN’
[13:17:30.288] - copied ‘...future.FUN’ to environment
[13:17:30.288] - copied ‘breaks’ to environment
[13:17:30.288] - copied ‘wool’ to environment
[13:17:30.288] - copied ‘future.call.arguments’ to environment
[13:17:30.288] - copied ‘...future.elements_ii’ to environment
[13:17:30.288] - copied ‘...future.seeds_ii’ to environment
[13:17:30.289] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.289] assign_globals() ... done
[13:17:30.289] requestCore(): workers = 2
[13:17:30.291] MulticoreFuture started
[13:17:30.292] - Launch lazy future ... done
[13:17:30.293] run() for ‘MulticoreFuture’ ... done
[13:17:30.293] Created future:
[13:17:30.293] plan(): Setting new future strategy stack:
[13:17:30.294] List of future strategies:
[13:17:30.294] 1. sequential:
[13:17:30.294]    - args: function (..., envir = parent.frame())
[13:17:30.294]    - tweaked: FALSE
[13:17:30.294]    - call: NULL
[13:17:30.295] plan(): nbrOfWorkers() = 1
[13:17:30.300] plan(): Setting new future strategy stack:
[13:17:30.301] List of future strategies:
[13:17:30.301] 1. multicore:
[13:17:30.301]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.301]    - tweaked: FALSE
[13:17:30.301]    - call: plan(strategy)
[13:17:30.306] plan(): nbrOfWorkers() = 2
[13:17:30.293] MulticoreFuture:
[13:17:30.293] Label: ‘future_by-2’
[13:17:30.293] Expression:
[13:17:30.293] {
[13:17:30.293]     do.call(function(...) {
[13:17:30.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.293]             on.exit(options(oopts), add = TRUE)
[13:17:30.293]         }
[13:17:30.293]         {
[13:17:30.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.293]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.293]             })
[13:17:30.293]         }
[13:17:30.293]     }, args = future.call.arguments)
[13:17:30.293] }
[13:17:30.293] Lazy evaluation: FALSE
[13:17:30.293] Asynchronous evaluation: TRUE
[13:17:30.293] Local evaluation: TRUE
[13:17:30.293] Environment: 0x5609ea25f3a8
[13:17:30.293] Capture standard output: TRUE
[13:17:30.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.293] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[13:17:30.293] Packages: 1 packages (‘stats’)
[13:17:30.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.293] Resolved: FALSE
[13:17:30.293] Value: <not collected>
[13:17:30.293] Conditions captured: <none>
[13:17:30.293] Early signaling: FALSE
[13:17:30.293] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.293] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.308] Chunk #2 of 2 ... DONE
[13:17:30.308] Launching 2 futures (chunks) ... DONE
[13:17:30.308] Resolving 2 futures (chunks) ...
[13:17:30.308] resolve() on list ...
[13:17:30.308]  recursive: 0
[13:17:30.308]  length: 2
[13:17:30.309] 
[13:17:30.309] Future #1
[13:17:30.311] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:30.311] - nx: 2
[13:17:30.311] - relay: TRUE
[13:17:30.311] - stdout: TRUE
[13:17:30.311] - signal: TRUE
[13:17:30.311] - resignal: FALSE
[13:17:30.311] - force: TRUE
[13:17:30.311] - relayed: [n=2] FALSE, FALSE
[13:17:30.312] - queued futures: [n=2] FALSE, FALSE
[13:17:30.312]  - until=1
[13:17:30.312]  - relaying element #1
[13:17:30.312] - relayed: [n=2] TRUE, FALSE
[13:17:30.312] - queued futures: [n=2] TRUE, FALSE
[13:17:30.312] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:30.313]  length: 1 (resolved future 1)
[13:17:30.313] Future #2
[13:17:30.314] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:30.314] - nx: 2
[13:17:30.314] - relay: TRUE
[13:17:30.315] - stdout: TRUE
[13:17:30.315] - signal: TRUE
[13:17:30.315] - resignal: FALSE
[13:17:30.315] - force: TRUE
[13:17:30.315] - relayed: [n=2] TRUE, FALSE
[13:17:30.315] - queued futures: [n=2] TRUE, FALSE
[13:17:30.315]  - until=2
[13:17:30.315]  - relaying element #2
[13:17:30.316] - relayed: [n=2] TRUE, TRUE
[13:17:30.316] - queued futures: [n=2] TRUE, TRUE
[13:17:30.316] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:30.316]  length: 0 (resolved future 2)
[13:17:30.316] Relaying remaining futures
[13:17:30.316] signalConditionsASAP(NULL, pos=0) ...
[13:17:30.316] - nx: 2
[13:17:30.316] - relay: TRUE
[13:17:30.317] - stdout: TRUE
[13:17:30.317] - signal: TRUE
[13:17:30.317] - resignal: FALSE
[13:17:30.317] - force: TRUE
[13:17:30.317] - relayed: [n=2] TRUE, TRUE
[13:17:30.317] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:30.317] - relayed: [n=2] TRUE, TRUE
[13:17:30.317] - queued futures: [n=2] TRUE, TRUE
[13:17:30.318] signalConditionsASAP(NULL, pos=0) ... done
[13:17:30.318] resolve() on list ... DONE
[13:17:30.318]  - Number of value chunks collected: 2
[13:17:30.318] Resolving 2 futures (chunks) ... DONE
[13:17:30.318] Reducing values from 2 chunks ...
[13:17:30.318]  - Number of values collected after concatenation: 3
[13:17:30.318]  - Number of values expected: 3
[13:17:30.318] Reducing values from 2 chunks ... DONE
[13:17:30.319] future_lapply() ... DONE
[13:17:30.319] future_by_internal() ... DONE
[13:17:30.319] future_by_internal() ...
[13:17:30.320] future_lapply() ...
[13:17:30.324] Number of chunks: 2
[13:17:30.324] getGlobalsAndPackagesXApply() ...
[13:17:30.325]  - future.globals: TRUE
[13:17:30.365] getGlobalsAndPackages() ...
[13:17:30.365] Searching for globals...
[13:17:30.366] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:30.366] Searching for globals ... DONE
[13:17:30.367] Resolving globals: FALSE
[13:17:30.367] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:30.367] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:30.367] - globals: [1] ‘FUN’
[13:17:30.367] 
[13:17:30.367] getGlobalsAndPackages() ... DONE
[13:17:30.368]  - globals found/used: [n=1] ‘FUN’
[13:17:30.368]  - needed namespaces: [n=0] 
[13:17:30.368] Finding globals ... DONE
[13:17:30.368]  - use_args: TRUE
[13:17:30.368]  - Getting '...' globals ...
[13:17:30.368] resolve() on list ...
[13:17:30.368]  recursive: 0
[13:17:30.368]  length: 1
[13:17:30.368]  elements: ‘...’
[13:17:30.369]  length: 0 (resolved future 1)
[13:17:30.369] resolve() on list ... DONE
[13:17:30.369]    - '...' content: [n=0] 
[13:17:30.369] List of 1
[13:17:30.369]  $ ...: list()
[13:17:30.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.369]  - attr(*, "where")=List of 1
[13:17:30.369]   ..$ ...:<environment: 0x5609ea557f38> 
[13:17:30.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.369]  - attr(*, "resolved")= logi TRUE
[13:17:30.369]  - attr(*, "total_size")= num NA
[13:17:30.371]  - Getting '...' globals ... DONE
[13:17:30.372] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:30.372] List of 2
[13:17:30.372]  $ ...future.FUN:function (object, ...)  
[13:17:30.372]  $ ...          : list()
[13:17:30.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.372]  - attr(*, "where")=List of 2
[13:17:30.372]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:30.372]   ..$ ...          :<environment: 0x5609ea557f38> 
[13:17:30.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.372]  - attr(*, "resolved")= logi FALSE
[13:17:30.372]  - attr(*, "total_size")= num 1240
[13:17:30.374] Packages to be attached in all futures: [n=0] 
[13:17:30.374] getGlobalsAndPackagesXApply() ... DONE
[13:17:30.374] Number of futures (= number of chunks): 2
[13:17:30.375] Launching 2 futures (chunks) ...
[13:17:30.375] Chunk #1 of 2 ...
[13:17:30.375]  - Finding globals in 'X' for chunk #1 ...
[13:17:30.375] getGlobalsAndPackages() ...
[13:17:30.375] Searching for globals...
[13:17:30.375] 
[13:17:30.375] Searching for globals ... DONE
[13:17:30.375] - globals: [0] <none>
[13:17:30.376] getGlobalsAndPackages() ... DONE
[13:17:30.376]    + additional globals found: [n=0] 
[13:17:30.376]    + additional namespaces needed: [n=0] 
[13:17:30.376]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:30.376]  - seeds: <none>
[13:17:30.376] getGlobalsAndPackages() ...
[13:17:30.376] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.376] Resolving globals: FALSE
[13:17:30.376] Tweak future expression to call with '...' arguments ...
[13:17:30.376] {
[13:17:30.376]     do.call(function(...) {
[13:17:30.376]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.376]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.376]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.376]             on.exit(options(oopts), add = TRUE)
[13:17:30.376]         }
[13:17:30.376]         {
[13:17:30.376]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.376]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.376]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.376]             })
[13:17:30.376]         }
[13:17:30.376]     }, args = future.call.arguments)
[13:17:30.376] }
[13:17:30.377] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.377] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.377] 
[13:17:30.377] getGlobalsAndPackages() ... DONE
[13:17:30.378] run() for ‘Future’ ...
[13:17:30.378] - state: ‘created’
[13:17:30.378] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.382] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.382]   - Field: ‘label’
[13:17:30.382]   - Field: ‘local’
[13:17:30.382]   - Field: ‘owner’
[13:17:30.382]   - Field: ‘envir’
[13:17:30.382]   - Field: ‘workers’
[13:17:30.382]   - Field: ‘packages’
[13:17:30.382]   - Field: ‘gc’
[13:17:30.382]   - Field: ‘job’
[13:17:30.382]   - Field: ‘conditions’
[13:17:30.383]   - Field: ‘expr’
[13:17:30.383]   - Field: ‘uuid’
[13:17:30.383]   - Field: ‘seed’
[13:17:30.383]   - Field: ‘version’
[13:17:30.383]   - Field: ‘result’
[13:17:30.383]   - Field: ‘asynchronous’
[13:17:30.383]   - Field: ‘calls’
[13:17:30.383]   - Field: ‘globals’
[13:17:30.383]   - Field: ‘stdout’
[13:17:30.383]   - Field: ‘earlySignal’
[13:17:30.384]   - Field: ‘lazy’
[13:17:30.384]   - Field: ‘state’
[13:17:30.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.384] - Launch lazy future ...
[13:17:30.384] Packages needed by the future expression (n = 0): <none>
[13:17:30.384] Packages needed by future strategies (n = 0): <none>
[13:17:30.385] {
[13:17:30.385]     {
[13:17:30.385]         {
[13:17:30.385]             ...future.startTime <- base::Sys.time()
[13:17:30.385]             {
[13:17:30.385]                 {
[13:17:30.385]                   {
[13:17:30.385]                     {
[13:17:30.385]                       base::local({
[13:17:30.385]                         has_future <- base::requireNamespace("future", 
[13:17:30.385]                           quietly = TRUE)
[13:17:30.385]                         if (has_future) {
[13:17:30.385]                           ns <- base::getNamespace("future")
[13:17:30.385]                           version <- ns[[".package"]][["version"]]
[13:17:30.385]                           if (is.null(version)) 
[13:17:30.385]                             version <- utils::packageVersion("future")
[13:17:30.385]                         }
[13:17:30.385]                         else {
[13:17:30.385]                           version <- NULL
[13:17:30.385]                         }
[13:17:30.385]                         if (!has_future || version < "1.8.0") {
[13:17:30.385]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.385]                             "", base::R.version$version.string), 
[13:17:30.385]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:30.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:30.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.385]                               "release", "version")], collapse = " "), 
[13:17:30.385]                             hostname = base::Sys.info()[["nodename"]])
[13:17:30.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.385]                             info)
[13:17:30.385]                           info <- base::paste(info, collapse = "; ")
[13:17:30.385]                           if (!has_future) {
[13:17:30.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.385]                               info)
[13:17:30.385]                           }
[13:17:30.385]                           else {
[13:17:30.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.385]                               info, version)
[13:17:30.385]                           }
[13:17:30.385]                           base::stop(msg)
[13:17:30.385]                         }
[13:17:30.385]                       })
[13:17:30.385]                     }
[13:17:30.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.385]                     base::options(mc.cores = 1L)
[13:17:30.385]                   }
[13:17:30.385]                   options(future.plan = NULL)
[13:17:30.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.385]                 }
[13:17:30.385]                 ...future.workdir <- getwd()
[13:17:30.385]             }
[13:17:30.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.385]         }
[13:17:30.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:30.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.385]             base::names(...future.oldOptions))
[13:17:30.385]     }
[13:17:30.385]     if (FALSE) {
[13:17:30.385]     }
[13:17:30.385]     else {
[13:17:30.385]         if (TRUE) {
[13:17:30.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.385]                 open = "w")
[13:17:30.385]         }
[13:17:30.385]         else {
[13:17:30.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.385]         }
[13:17:30.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.385]             base::sink(type = "output", split = FALSE)
[13:17:30.385]             base::close(...future.stdout)
[13:17:30.385]         }, add = TRUE)
[13:17:30.385]     }
[13:17:30.385]     ...future.frame <- base::sys.nframe()
[13:17:30.385]     ...future.conditions <- base::list()
[13:17:30.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.385]     if (FALSE) {
[13:17:30.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.385]     }
[13:17:30.385]     ...future.result <- base::tryCatch({
[13:17:30.385]         base::withCallingHandlers({
[13:17:30.385]             ...future.value <- base::withVisible(base::local({
[13:17:30.385]                 withCallingHandlers({
[13:17:30.385]                   {
[13:17:30.385]                     do.call(function(...) {
[13:17:30.385]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.385]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.385]                         ...future.globals.maxSize)) {
[13:17:30.385]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.385]                         on.exit(options(oopts), add = TRUE)
[13:17:30.385]                       }
[13:17:30.385]                       {
[13:17:30.385]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.385]                           FUN = function(jj) {
[13:17:30.385]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.385]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.385]                           })
[13:17:30.385]                       }
[13:17:30.385]                     }, args = future.call.arguments)
[13:17:30.385]                   }
[13:17:30.385]                 }, immediateCondition = function(cond) {
[13:17:30.385]                   save_rds <- function (object, pathname, ...) 
[13:17:30.385]                   {
[13:17:30.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.385]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.385]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.385]                         fi_tmp[["mtime"]])
[13:17:30.385]                     }
[13:17:30.385]                     tryCatch({
[13:17:30.385]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.385]                     }, error = function(ex) {
[13:17:30.385]                       msg <- conditionMessage(ex)
[13:17:30.385]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.385]                         fi_tmp[["mtime"]], msg)
[13:17:30.385]                       ex$message <- msg
[13:17:30.385]                       stop(ex)
[13:17:30.385]                     })
[13:17:30.385]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.385]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.385]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.385]                       fi <- file.info(pathname)
[13:17:30.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.385]                         fi[["size"]], fi[["mtime"]])
[13:17:30.385]                       stop(msg)
[13:17:30.385]                     }
[13:17:30.385]                     invisible(pathname)
[13:17:30.385]                   }
[13:17:30.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.385]                     rootPath = tempdir()) 
[13:17:30.385]                   {
[13:17:30.385]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.385]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.385]                       tmpdir = path, fileext = ".rds")
[13:17:30.385]                     save_rds(obj, file)
[13:17:30.385]                   }
[13:17:30.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.385]                   {
[13:17:30.385]                     inherits <- base::inherits
[13:17:30.385]                     invokeRestart <- base::invokeRestart
[13:17:30.385]                     is.null <- base::is.null
[13:17:30.385]                     muffled <- FALSE
[13:17:30.385]                     if (inherits(cond, "message")) {
[13:17:30.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.385]                       if (muffled) 
[13:17:30.385]                         invokeRestart("muffleMessage")
[13:17:30.385]                     }
[13:17:30.385]                     else if (inherits(cond, "warning")) {
[13:17:30.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.385]                       if (muffled) 
[13:17:30.385]                         invokeRestart("muffleWarning")
[13:17:30.385]                     }
[13:17:30.385]                     else if (inherits(cond, "condition")) {
[13:17:30.385]                       if (!is.null(pattern)) {
[13:17:30.385]                         computeRestarts <- base::computeRestarts
[13:17:30.385]                         grepl <- base::grepl
[13:17:30.385]                         restarts <- computeRestarts(cond)
[13:17:30.385]                         for (restart in restarts) {
[13:17:30.385]                           name <- restart$name
[13:17:30.385]                           if (is.null(name)) 
[13:17:30.385]                             next
[13:17:30.385]                           if (!grepl(pattern, name)) 
[13:17:30.385]                             next
[13:17:30.385]                           invokeRestart(restart)
[13:17:30.385]                           muffled <- TRUE
[13:17:30.385]                           break
[13:17:30.385]                         }
[13:17:30.385]                       }
[13:17:30.385]                     }
[13:17:30.385]                     invisible(muffled)
[13:17:30.385]                   }
[13:17:30.385]                   muffleCondition(cond)
[13:17:30.385]                 })
[13:17:30.385]             }))
[13:17:30.385]             future::FutureResult(value = ...future.value$value, 
[13:17:30.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.385]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.385]                     ...future.globalenv.names))
[13:17:30.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.385]         }, condition = base::local({
[13:17:30.385]             c <- base::c
[13:17:30.385]             inherits <- base::inherits
[13:17:30.385]             invokeRestart <- base::invokeRestart
[13:17:30.385]             length <- base::length
[13:17:30.385]             list <- base::list
[13:17:30.385]             seq.int <- base::seq.int
[13:17:30.385]             signalCondition <- base::signalCondition
[13:17:30.385]             sys.calls <- base::sys.calls
[13:17:30.385]             `[[` <- base::`[[`
[13:17:30.385]             `+` <- base::`+`
[13:17:30.385]             `<<-` <- base::`<<-`
[13:17:30.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.385]                   3L)]
[13:17:30.385]             }
[13:17:30.385]             function(cond) {
[13:17:30.385]                 is_error <- inherits(cond, "error")
[13:17:30.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.385]                   NULL)
[13:17:30.385]                 if (is_error) {
[13:17:30.385]                   sessionInformation <- function() {
[13:17:30.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.385]                       search = base::search(), system = base::Sys.info())
[13:17:30.385]                   }
[13:17:30.385]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.385]                     cond$call), session = sessionInformation(), 
[13:17:30.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.385]                   signalCondition(cond)
[13:17:30.385]                 }
[13:17:30.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.385]                 "immediateCondition"))) {
[13:17:30.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.385]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.385]                   if (TRUE && !signal) {
[13:17:30.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.385]                     {
[13:17:30.385]                       inherits <- base::inherits
[13:17:30.385]                       invokeRestart <- base::invokeRestart
[13:17:30.385]                       is.null <- base::is.null
[13:17:30.385]                       muffled <- FALSE
[13:17:30.385]                       if (inherits(cond, "message")) {
[13:17:30.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.385]                         if (muffled) 
[13:17:30.385]                           invokeRestart("muffleMessage")
[13:17:30.385]                       }
[13:17:30.385]                       else if (inherits(cond, "warning")) {
[13:17:30.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.385]                         if (muffled) 
[13:17:30.385]                           invokeRestart("muffleWarning")
[13:17:30.385]                       }
[13:17:30.385]                       else if (inherits(cond, "condition")) {
[13:17:30.385]                         if (!is.null(pattern)) {
[13:17:30.385]                           computeRestarts <- base::computeRestarts
[13:17:30.385]                           grepl <- base::grepl
[13:17:30.385]                           restarts <- computeRestarts(cond)
[13:17:30.385]                           for (restart in restarts) {
[13:17:30.385]                             name <- restart$name
[13:17:30.385]                             if (is.null(name)) 
[13:17:30.385]                               next
[13:17:30.385]                             if (!grepl(pattern, name)) 
[13:17:30.385]                               next
[13:17:30.385]                             invokeRestart(restart)
[13:17:30.385]                             muffled <- TRUE
[13:17:30.385]                             break
[13:17:30.385]                           }
[13:17:30.385]                         }
[13:17:30.385]                       }
[13:17:30.385]                       invisible(muffled)
[13:17:30.385]                     }
[13:17:30.385]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.385]                   }
[13:17:30.385]                 }
[13:17:30.385]                 else {
[13:17:30.385]                   if (TRUE) {
[13:17:30.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.385]                     {
[13:17:30.385]                       inherits <- base::inherits
[13:17:30.385]                       invokeRestart <- base::invokeRestart
[13:17:30.385]                       is.null <- base::is.null
[13:17:30.385]                       muffled <- FALSE
[13:17:30.385]                       if (inherits(cond, "message")) {
[13:17:30.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.385]                         if (muffled) 
[13:17:30.385]                           invokeRestart("muffleMessage")
[13:17:30.385]                       }
[13:17:30.385]                       else if (inherits(cond, "warning")) {
[13:17:30.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.385]                         if (muffled) 
[13:17:30.385]                           invokeRestart("muffleWarning")
[13:17:30.385]                       }
[13:17:30.385]                       else if (inherits(cond, "condition")) {
[13:17:30.385]                         if (!is.null(pattern)) {
[13:17:30.385]                           computeRestarts <- base::computeRestarts
[13:17:30.385]                           grepl <- base::grepl
[13:17:30.385]                           restarts <- computeRestarts(cond)
[13:17:30.385]                           for (restart in restarts) {
[13:17:30.385]                             name <- restart$name
[13:17:30.385]                             if (is.null(name)) 
[13:17:30.385]                               next
[13:17:30.385]                             if (!grepl(pattern, name)) 
[13:17:30.385]                               next
[13:17:30.385]                             invokeRestart(restart)
[13:17:30.385]                             muffled <- TRUE
[13:17:30.385]                             break
[13:17:30.385]                           }
[13:17:30.385]                         }
[13:17:30.385]                       }
[13:17:30.385]                       invisible(muffled)
[13:17:30.385]                     }
[13:17:30.385]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.385]                   }
[13:17:30.385]                 }
[13:17:30.385]             }
[13:17:30.385]         }))
[13:17:30.385]     }, error = function(ex) {
[13:17:30.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.385]                 ...future.rng), started = ...future.startTime, 
[13:17:30.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.385]             version = "1.8"), class = "FutureResult")
[13:17:30.385]     }, finally = {
[13:17:30.385]         if (!identical(...future.workdir, getwd())) 
[13:17:30.385]             setwd(...future.workdir)
[13:17:30.385]         {
[13:17:30.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.385]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.385]             }
[13:17:30.385]             base::options(...future.oldOptions)
[13:17:30.385]             if (.Platform$OS.type == "windows") {
[13:17:30.385]                 old_names <- names(...future.oldEnvVars)
[13:17:30.385]                 envs <- base::Sys.getenv()
[13:17:30.385]                 names <- names(envs)
[13:17:30.385]                 common <- intersect(names, old_names)
[13:17:30.385]                 added <- setdiff(names, old_names)
[13:17:30.385]                 removed <- setdiff(old_names, names)
[13:17:30.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.385]                   envs[common]]
[13:17:30.385]                 NAMES <- toupper(changed)
[13:17:30.385]                 args <- list()
[13:17:30.385]                 for (kk in seq_along(NAMES)) {
[13:17:30.385]                   name <- changed[[kk]]
[13:17:30.385]                   NAME <- NAMES[[kk]]
[13:17:30.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.385]                     next
[13:17:30.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.385]                 }
[13:17:30.385]                 NAMES <- toupper(added)
[13:17:30.385]                 for (kk in seq_along(NAMES)) {
[13:17:30.385]                   name <- added[[kk]]
[13:17:30.385]                   NAME <- NAMES[[kk]]
[13:17:30.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.385]                     next
[13:17:30.385]                   args[[name]] <- ""
[13:17:30.385]                 }
[13:17:30.385]                 NAMES <- toupper(removed)
[13:17:30.385]                 for (kk in seq_along(NAMES)) {
[13:17:30.385]                   name <- removed[[kk]]
[13:17:30.385]                   NAME <- NAMES[[kk]]
[13:17:30.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.385]                     next
[13:17:30.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.385]                 }
[13:17:30.385]                 if (length(args) > 0) 
[13:17:30.385]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.385]             }
[13:17:30.385]             else {
[13:17:30.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.385]             }
[13:17:30.385]             {
[13:17:30.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.385]                   0L) {
[13:17:30.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.385]                   base::options(opts)
[13:17:30.385]                 }
[13:17:30.385]                 {
[13:17:30.385]                   {
[13:17:30.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.385]                     NULL
[13:17:30.385]                   }
[13:17:30.385]                   options(future.plan = NULL)
[13:17:30.385]                   if (is.na(NA_character_)) 
[13:17:30.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.385]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.385]                     envir = parent.frame()) 
[13:17:30.385]                   {
[13:17:30.385]                     default_workers <- missing(workers)
[13:17:30.385]                     if (is.function(workers)) 
[13:17:30.385]                       workers <- workers()
[13:17:30.385]                     workers <- structure(as.integer(workers), 
[13:17:30.385]                       class = class(workers))
[13:17:30.385]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.385]                       1L)
[13:17:30.385]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.385]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.385]                       if (default_workers) 
[13:17:30.385]                         supportsMulticore(warn = TRUE)
[13:17:30.385]                       return(sequential(..., envir = envir))
[13:17:30.385]                     }
[13:17:30.385]                     oopts <- options(mc.cores = workers)
[13:17:30.385]                     on.exit(options(oopts))
[13:17:30.385]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.385]                       envir = envir)
[13:17:30.385]                     if (!future$lazy) 
[13:17:30.385]                       future <- run(future)
[13:17:30.385]                     invisible(future)
[13:17:30.385]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.385]                 }
[13:17:30.385]             }
[13:17:30.385]         }
[13:17:30.385]     })
[13:17:30.385]     if (TRUE) {
[13:17:30.385]         base::sink(type = "output", split = FALSE)
[13:17:30.385]         if (TRUE) {
[13:17:30.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.385]         }
[13:17:30.385]         else {
[13:17:30.385]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.385]         }
[13:17:30.385]         base::close(...future.stdout)
[13:17:30.385]         ...future.stdout <- NULL
[13:17:30.385]     }
[13:17:30.385]     ...future.result$conditions <- ...future.conditions
[13:17:30.385]     ...future.result$finished <- base::Sys.time()
[13:17:30.385]     ...future.result
[13:17:30.385] }
[13:17:30.387] assign_globals() ...
[13:17:30.387] List of 5
[13:17:30.387]  $ ...future.FUN            :function (object, ...)  
[13:17:30.387]  $ future.call.arguments    : list()
[13:17:30.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.387]  $ ...future.elements_ii    :List of 1
[13:17:30.387]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.387]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:30.387]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.387]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.387]  $ ...future.seeds_ii       : NULL
[13:17:30.387]  $ ...future.globals.maxSize: NULL
[13:17:30.387]  - attr(*, "where")=List of 5
[13:17:30.387]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.387]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.387]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.387]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.387]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.387]  - attr(*, "resolved")= logi FALSE
[13:17:30.387]  - attr(*, "total_size")= num 1240
[13:17:30.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.387]  - attr(*, "already-done")= logi TRUE
[13:17:30.393] - copied ‘...future.FUN’ to environment
[13:17:30.393] - copied ‘future.call.arguments’ to environment
[13:17:30.393] - copied ‘...future.elements_ii’ to environment
[13:17:30.393] - copied ‘...future.seeds_ii’ to environment
[13:17:30.393] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.394] assign_globals() ... done
[13:17:30.394] requestCore(): workers = 2
[13:17:30.396] MulticoreFuture started
[13:17:30.396] - Launch lazy future ... done
[13:17:30.396] run() for ‘MulticoreFuture’ ... done
[13:17:30.397] Created future:
[13:17:30.397] plan(): Setting new future strategy stack:
[13:17:30.397] List of future strategies:
[13:17:30.397] 1. sequential:
[13:17:30.397]    - args: function (..., envir = parent.frame())
[13:17:30.397]    - tweaked: FALSE
[13:17:30.397]    - call: NULL
[13:17:30.398] plan(): nbrOfWorkers() = 1
[13:17:30.401] plan(): Setting new future strategy stack:
[13:17:30.401] List of future strategies:
[13:17:30.401] 1. multicore:
[13:17:30.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.401]    - tweaked: FALSE
[13:17:30.401]    - call: plan(strategy)
[13:17:30.407] plan(): nbrOfWorkers() = 2
[13:17:30.397] MulticoreFuture:
[13:17:30.397] Label: ‘future_by-1’
[13:17:30.397] Expression:
[13:17:30.397] {
[13:17:30.397]     do.call(function(...) {
[13:17:30.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.397]             on.exit(options(oopts), add = TRUE)
[13:17:30.397]         }
[13:17:30.397]         {
[13:17:30.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.397]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.397]             })
[13:17:30.397]         }
[13:17:30.397]     }, args = future.call.arguments)
[13:17:30.397] }
[13:17:30.397] Lazy evaluation: FALSE
[13:17:30.397] Asynchronous evaluation: TRUE
[13:17:30.397] Local evaluation: TRUE
[13:17:30.397] Environment: 0x5609ea496c08
[13:17:30.397] Capture standard output: TRUE
[13:17:30.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.397] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.397] Packages: <none>
[13:17:30.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.397] Resolved: TRUE
[13:17:30.397] Value: <not collected>
[13:17:30.397] Conditions captured: <none>
[13:17:30.397] Early signaling: FALSE
[13:17:30.397] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.397] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.408] Chunk #1 of 2 ... DONE
[13:17:30.408] Chunk #2 of 2 ...
[13:17:30.408]  - Finding globals in 'X' for chunk #2 ...
[13:17:30.408] getGlobalsAndPackages() ...
[13:17:30.408] Searching for globals...
[13:17:30.409] 
[13:17:30.409] Searching for globals ... DONE
[13:17:30.409] - globals: [0] <none>
[13:17:30.409] getGlobalsAndPackages() ... DONE
[13:17:30.409]    + additional globals found: [n=0] 
[13:17:30.410]    + additional namespaces needed: [n=0] 
[13:17:30.410]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:30.410]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:30.410]  - seeds: <none>
[13:17:30.410] getGlobalsAndPackages() ...
[13:17:30.410] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.411] Resolving globals: FALSE
[13:17:30.411] Tweak future expression to call with '...' arguments ...
[13:17:30.411] {
[13:17:30.411]     do.call(function(...) {
[13:17:30.411]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.411]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.411]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.411]             on.exit(options(oopts), add = TRUE)
[13:17:30.411]         }
[13:17:30.411]         {
[13:17:30.411]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.411]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.411]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.411]             })
[13:17:30.411]         }
[13:17:30.411]     }, args = future.call.arguments)
[13:17:30.411] }
[13:17:30.411] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.412] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.412] 
[13:17:30.412] getGlobalsAndPackages() ... DONE
[13:17:30.413] run() for ‘Future’ ...
[13:17:30.413] - state: ‘created’
[13:17:30.413] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.418]   - Field: ‘label’
[13:17:30.418]   - Field: ‘local’
[13:17:30.418]   - Field: ‘owner’
[13:17:30.418]   - Field: ‘envir’
[13:17:30.419]   - Field: ‘workers’
[13:17:30.419]   - Field: ‘packages’
[13:17:30.419]   - Field: ‘gc’
[13:17:30.419]   - Field: ‘job’
[13:17:30.419]   - Field: ‘conditions’
[13:17:30.419]   - Field: ‘expr’
[13:17:30.419]   - Field: ‘uuid’
[13:17:30.419]   - Field: ‘seed’
[13:17:30.420]   - Field: ‘version’
[13:17:30.420]   - Field: ‘result’
[13:17:30.420]   - Field: ‘asynchronous’
[13:17:30.420]   - Field: ‘calls’
[13:17:30.420]   - Field: ‘globals’
[13:17:30.420]   - Field: ‘stdout’
[13:17:30.420]   - Field: ‘earlySignal’
[13:17:30.420]   - Field: ‘lazy’
[13:17:30.421]   - Field: ‘state’
[13:17:30.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.421] - Launch lazy future ...
[13:17:30.421] Packages needed by the future expression (n = 0): <none>
[13:17:30.422] Packages needed by future strategies (n = 0): <none>
[13:17:30.422] {
[13:17:30.422]     {
[13:17:30.422]         {
[13:17:30.422]             ...future.startTime <- base::Sys.time()
[13:17:30.422]             {
[13:17:30.422]                 {
[13:17:30.422]                   {
[13:17:30.422]                     {
[13:17:30.422]                       base::local({
[13:17:30.422]                         has_future <- base::requireNamespace("future", 
[13:17:30.422]                           quietly = TRUE)
[13:17:30.422]                         if (has_future) {
[13:17:30.422]                           ns <- base::getNamespace("future")
[13:17:30.422]                           version <- ns[[".package"]][["version"]]
[13:17:30.422]                           if (is.null(version)) 
[13:17:30.422]                             version <- utils::packageVersion("future")
[13:17:30.422]                         }
[13:17:30.422]                         else {
[13:17:30.422]                           version <- NULL
[13:17:30.422]                         }
[13:17:30.422]                         if (!has_future || version < "1.8.0") {
[13:17:30.422]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.422]                             "", base::R.version$version.string), 
[13:17:30.422]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:30.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:30.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.422]                               "release", "version")], collapse = " "), 
[13:17:30.422]                             hostname = base::Sys.info()[["nodename"]])
[13:17:30.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.422]                             info)
[13:17:30.422]                           info <- base::paste(info, collapse = "; ")
[13:17:30.422]                           if (!has_future) {
[13:17:30.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.422]                               info)
[13:17:30.422]                           }
[13:17:30.422]                           else {
[13:17:30.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.422]                               info, version)
[13:17:30.422]                           }
[13:17:30.422]                           base::stop(msg)
[13:17:30.422]                         }
[13:17:30.422]                       })
[13:17:30.422]                     }
[13:17:30.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.422]                     base::options(mc.cores = 1L)
[13:17:30.422]                   }
[13:17:30.422]                   options(future.plan = NULL)
[13:17:30.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.422]                 }
[13:17:30.422]                 ...future.workdir <- getwd()
[13:17:30.422]             }
[13:17:30.422]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.422]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.422]         }
[13:17:30.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.422]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:30.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.422]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.422]             base::names(...future.oldOptions))
[13:17:30.422]     }
[13:17:30.422]     if (FALSE) {
[13:17:30.422]     }
[13:17:30.422]     else {
[13:17:30.422]         if (TRUE) {
[13:17:30.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.422]                 open = "w")
[13:17:30.422]         }
[13:17:30.422]         else {
[13:17:30.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.422]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.422]         }
[13:17:30.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.422]             base::sink(type = "output", split = FALSE)
[13:17:30.422]             base::close(...future.stdout)
[13:17:30.422]         }, add = TRUE)
[13:17:30.422]     }
[13:17:30.422]     ...future.frame <- base::sys.nframe()
[13:17:30.422]     ...future.conditions <- base::list()
[13:17:30.422]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.422]     if (FALSE) {
[13:17:30.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.422]     }
[13:17:30.422]     ...future.result <- base::tryCatch({
[13:17:30.422]         base::withCallingHandlers({
[13:17:30.422]             ...future.value <- base::withVisible(base::local({
[13:17:30.422]                 withCallingHandlers({
[13:17:30.422]                   {
[13:17:30.422]                     do.call(function(...) {
[13:17:30.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.422]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.422]                         ...future.globals.maxSize)) {
[13:17:30.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.422]                         on.exit(options(oopts), add = TRUE)
[13:17:30.422]                       }
[13:17:30.422]                       {
[13:17:30.422]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.422]                           FUN = function(jj) {
[13:17:30.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.422]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.422]                           })
[13:17:30.422]                       }
[13:17:30.422]                     }, args = future.call.arguments)
[13:17:30.422]                   }
[13:17:30.422]                 }, immediateCondition = function(cond) {
[13:17:30.422]                   save_rds <- function (object, pathname, ...) 
[13:17:30.422]                   {
[13:17:30.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.422]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.422]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.422]                         fi_tmp[["mtime"]])
[13:17:30.422]                     }
[13:17:30.422]                     tryCatch({
[13:17:30.422]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.422]                     }, error = function(ex) {
[13:17:30.422]                       msg <- conditionMessage(ex)
[13:17:30.422]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.422]                         fi_tmp[["mtime"]], msg)
[13:17:30.422]                       ex$message <- msg
[13:17:30.422]                       stop(ex)
[13:17:30.422]                     })
[13:17:30.422]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.422]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.422]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.422]                       fi <- file.info(pathname)
[13:17:30.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.422]                         fi[["size"]], fi[["mtime"]])
[13:17:30.422]                       stop(msg)
[13:17:30.422]                     }
[13:17:30.422]                     invisible(pathname)
[13:17:30.422]                   }
[13:17:30.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.422]                     rootPath = tempdir()) 
[13:17:30.422]                   {
[13:17:30.422]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.422]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.422]                       tmpdir = path, fileext = ".rds")
[13:17:30.422]                     save_rds(obj, file)
[13:17:30.422]                   }
[13:17:30.422]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.422]                   {
[13:17:30.422]                     inherits <- base::inherits
[13:17:30.422]                     invokeRestart <- base::invokeRestart
[13:17:30.422]                     is.null <- base::is.null
[13:17:30.422]                     muffled <- FALSE
[13:17:30.422]                     if (inherits(cond, "message")) {
[13:17:30.422]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.422]                       if (muffled) 
[13:17:30.422]                         invokeRestart("muffleMessage")
[13:17:30.422]                     }
[13:17:30.422]                     else if (inherits(cond, "warning")) {
[13:17:30.422]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.422]                       if (muffled) 
[13:17:30.422]                         invokeRestart("muffleWarning")
[13:17:30.422]                     }
[13:17:30.422]                     else if (inherits(cond, "condition")) {
[13:17:30.422]                       if (!is.null(pattern)) {
[13:17:30.422]                         computeRestarts <- base::computeRestarts
[13:17:30.422]                         grepl <- base::grepl
[13:17:30.422]                         restarts <- computeRestarts(cond)
[13:17:30.422]                         for (restart in restarts) {
[13:17:30.422]                           name <- restart$name
[13:17:30.422]                           if (is.null(name)) 
[13:17:30.422]                             next
[13:17:30.422]                           if (!grepl(pattern, name)) 
[13:17:30.422]                             next
[13:17:30.422]                           invokeRestart(restart)
[13:17:30.422]                           muffled <- TRUE
[13:17:30.422]                           break
[13:17:30.422]                         }
[13:17:30.422]                       }
[13:17:30.422]                     }
[13:17:30.422]                     invisible(muffled)
[13:17:30.422]                   }
[13:17:30.422]                   muffleCondition(cond)
[13:17:30.422]                 })
[13:17:30.422]             }))
[13:17:30.422]             future::FutureResult(value = ...future.value$value, 
[13:17:30.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.422]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.422]                     ...future.globalenv.names))
[13:17:30.422]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.422]         }, condition = base::local({
[13:17:30.422]             c <- base::c
[13:17:30.422]             inherits <- base::inherits
[13:17:30.422]             invokeRestart <- base::invokeRestart
[13:17:30.422]             length <- base::length
[13:17:30.422]             list <- base::list
[13:17:30.422]             seq.int <- base::seq.int
[13:17:30.422]             signalCondition <- base::signalCondition
[13:17:30.422]             sys.calls <- base::sys.calls
[13:17:30.422]             `[[` <- base::`[[`
[13:17:30.422]             `+` <- base::`+`
[13:17:30.422]             `<<-` <- base::`<<-`
[13:17:30.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.422]                   3L)]
[13:17:30.422]             }
[13:17:30.422]             function(cond) {
[13:17:30.422]                 is_error <- inherits(cond, "error")
[13:17:30.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.422]                   NULL)
[13:17:30.422]                 if (is_error) {
[13:17:30.422]                   sessionInformation <- function() {
[13:17:30.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.422]                       search = base::search(), system = base::Sys.info())
[13:17:30.422]                   }
[13:17:30.422]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.422]                     cond$call), session = sessionInformation(), 
[13:17:30.422]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.422]                   signalCondition(cond)
[13:17:30.422]                 }
[13:17:30.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.422]                 "immediateCondition"))) {
[13:17:30.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.422]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.422]                   if (TRUE && !signal) {
[13:17:30.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.422]                     {
[13:17:30.422]                       inherits <- base::inherits
[13:17:30.422]                       invokeRestart <- base::invokeRestart
[13:17:30.422]                       is.null <- base::is.null
[13:17:30.422]                       muffled <- FALSE
[13:17:30.422]                       if (inherits(cond, "message")) {
[13:17:30.422]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.422]                         if (muffled) 
[13:17:30.422]                           invokeRestart("muffleMessage")
[13:17:30.422]                       }
[13:17:30.422]                       else if (inherits(cond, "warning")) {
[13:17:30.422]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.422]                         if (muffled) 
[13:17:30.422]                           invokeRestart("muffleWarning")
[13:17:30.422]                       }
[13:17:30.422]                       else if (inherits(cond, "condition")) {
[13:17:30.422]                         if (!is.null(pattern)) {
[13:17:30.422]                           computeRestarts <- base::computeRestarts
[13:17:30.422]                           grepl <- base::grepl
[13:17:30.422]                           restarts <- computeRestarts(cond)
[13:17:30.422]                           for (restart in restarts) {
[13:17:30.422]                             name <- restart$name
[13:17:30.422]                             if (is.null(name)) 
[13:17:30.422]                               next
[13:17:30.422]                             if (!grepl(pattern, name)) 
[13:17:30.422]                               next
[13:17:30.422]                             invokeRestart(restart)
[13:17:30.422]                             muffled <- TRUE
[13:17:30.422]                             break
[13:17:30.422]                           }
[13:17:30.422]                         }
[13:17:30.422]                       }
[13:17:30.422]                       invisible(muffled)
[13:17:30.422]                     }
[13:17:30.422]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.422]                   }
[13:17:30.422]                 }
[13:17:30.422]                 else {
[13:17:30.422]                   if (TRUE) {
[13:17:30.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.422]                     {
[13:17:30.422]                       inherits <- base::inherits
[13:17:30.422]                       invokeRestart <- base::invokeRestart
[13:17:30.422]                       is.null <- base::is.null
[13:17:30.422]                       muffled <- FALSE
[13:17:30.422]                       if (inherits(cond, "message")) {
[13:17:30.422]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.422]                         if (muffled) 
[13:17:30.422]                           invokeRestart("muffleMessage")
[13:17:30.422]                       }
[13:17:30.422]                       else if (inherits(cond, "warning")) {
[13:17:30.422]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.422]                         if (muffled) 
[13:17:30.422]                           invokeRestart("muffleWarning")
[13:17:30.422]                       }
[13:17:30.422]                       else if (inherits(cond, "condition")) {
[13:17:30.422]                         if (!is.null(pattern)) {
[13:17:30.422]                           computeRestarts <- base::computeRestarts
[13:17:30.422]                           grepl <- base::grepl
[13:17:30.422]                           restarts <- computeRestarts(cond)
[13:17:30.422]                           for (restart in restarts) {
[13:17:30.422]                             name <- restart$name
[13:17:30.422]                             if (is.null(name)) 
[13:17:30.422]                               next
[13:17:30.422]                             if (!grepl(pattern, name)) 
[13:17:30.422]                               next
[13:17:30.422]                             invokeRestart(restart)
[13:17:30.422]                             muffled <- TRUE
[13:17:30.422]                             break
[13:17:30.422]                           }
[13:17:30.422]                         }
[13:17:30.422]                       }
[13:17:30.422]                       invisible(muffled)
[13:17:30.422]                     }
[13:17:30.422]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.422]                   }
[13:17:30.422]                 }
[13:17:30.422]             }
[13:17:30.422]         }))
[13:17:30.422]     }, error = function(ex) {
[13:17:30.422]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.422]                 ...future.rng), started = ...future.startTime, 
[13:17:30.422]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.422]             version = "1.8"), class = "FutureResult")
[13:17:30.422]     }, finally = {
[13:17:30.422]         if (!identical(...future.workdir, getwd())) 
[13:17:30.422]             setwd(...future.workdir)
[13:17:30.422]         {
[13:17:30.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.422]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.422]             }
[13:17:30.422]             base::options(...future.oldOptions)
[13:17:30.422]             if (.Platform$OS.type == "windows") {
[13:17:30.422]                 old_names <- names(...future.oldEnvVars)
[13:17:30.422]                 envs <- base::Sys.getenv()
[13:17:30.422]                 names <- names(envs)
[13:17:30.422]                 common <- intersect(names, old_names)
[13:17:30.422]                 added <- setdiff(names, old_names)
[13:17:30.422]                 removed <- setdiff(old_names, names)
[13:17:30.422]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.422]                   envs[common]]
[13:17:30.422]                 NAMES <- toupper(changed)
[13:17:30.422]                 args <- list()
[13:17:30.422]                 for (kk in seq_along(NAMES)) {
[13:17:30.422]                   name <- changed[[kk]]
[13:17:30.422]                   NAME <- NAMES[[kk]]
[13:17:30.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.422]                     next
[13:17:30.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.422]                 }
[13:17:30.422]                 NAMES <- toupper(added)
[13:17:30.422]                 for (kk in seq_along(NAMES)) {
[13:17:30.422]                   name <- added[[kk]]
[13:17:30.422]                   NAME <- NAMES[[kk]]
[13:17:30.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.422]                     next
[13:17:30.422]                   args[[name]] <- ""
[13:17:30.422]                 }
[13:17:30.422]                 NAMES <- toupper(removed)
[13:17:30.422]                 for (kk in seq_along(NAMES)) {
[13:17:30.422]                   name <- removed[[kk]]
[13:17:30.422]                   NAME <- NAMES[[kk]]
[13:17:30.422]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.422]                     next
[13:17:30.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.422]                 }
[13:17:30.422]                 if (length(args) > 0) 
[13:17:30.422]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.422]             }
[13:17:30.422]             else {
[13:17:30.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.422]             }
[13:17:30.422]             {
[13:17:30.422]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.422]                   0L) {
[13:17:30.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.422]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.422]                   base::options(opts)
[13:17:30.422]                 }
[13:17:30.422]                 {
[13:17:30.422]                   {
[13:17:30.422]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.422]                     NULL
[13:17:30.422]                   }
[13:17:30.422]                   options(future.plan = NULL)
[13:17:30.422]                   if (is.na(NA_character_)) 
[13:17:30.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.422]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.422]                     envir = parent.frame()) 
[13:17:30.422]                   {
[13:17:30.422]                     default_workers <- missing(workers)
[13:17:30.422]                     if (is.function(workers)) 
[13:17:30.422]                       workers <- workers()
[13:17:30.422]                     workers <- structure(as.integer(workers), 
[13:17:30.422]                       class = class(workers))
[13:17:30.422]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.422]                       1L)
[13:17:30.422]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.422]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.422]                       if (default_workers) 
[13:17:30.422]                         supportsMulticore(warn = TRUE)
[13:17:30.422]                       return(sequential(..., envir = envir))
[13:17:30.422]                     }
[13:17:30.422]                     oopts <- options(mc.cores = workers)
[13:17:30.422]                     on.exit(options(oopts))
[13:17:30.422]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.422]                       envir = envir)
[13:17:30.422]                     if (!future$lazy) 
[13:17:30.422]                       future <- run(future)
[13:17:30.422]                     invisible(future)
[13:17:30.422]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.422]                 }
[13:17:30.422]             }
[13:17:30.422]         }
[13:17:30.422]     })
[13:17:30.422]     if (TRUE) {
[13:17:30.422]         base::sink(type = "output", split = FALSE)
[13:17:30.422]         if (TRUE) {
[13:17:30.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.422]         }
[13:17:30.422]         else {
[13:17:30.422]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.422]         }
[13:17:30.422]         base::close(...future.stdout)
[13:17:30.422]         ...future.stdout <- NULL
[13:17:30.422]     }
[13:17:30.422]     ...future.result$conditions <- ...future.conditions
[13:17:30.422]     ...future.result$finished <- base::Sys.time()
[13:17:30.422]     ...future.result
[13:17:30.422] }
[13:17:30.425] assign_globals() ...
[13:17:30.425] List of 5
[13:17:30.425]  $ ...future.FUN            :function (object, ...)  
[13:17:30.425]  $ future.call.arguments    : list()
[13:17:30.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.425]  $ ...future.elements_ii    :List of 2
[13:17:30.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.425]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:30.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:30.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.425]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:30.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:30.425]  $ ...future.seeds_ii       : NULL
[13:17:30.425]  $ ...future.globals.maxSize: NULL
[13:17:30.425]  - attr(*, "resolved")= logi FALSE
[13:17:30.425]  - attr(*, "total_size")= num 1240
[13:17:30.425]  - attr(*, "where")=List of 5
[13:17:30.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.425]  - attr(*, "already-done")= logi TRUE
[13:17:30.436] - copied ‘...future.FUN’ to environment
[13:17:30.436] - copied ‘future.call.arguments’ to environment
[13:17:30.436] - copied ‘...future.elements_ii’ to environment
[13:17:30.436] - copied ‘...future.seeds_ii’ to environment
[13:17:30.436] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.436] assign_globals() ... done
[13:17:30.437] requestCore(): workers = 2
[13:17:30.439] MulticoreFuture started
[13:17:30.440] - Launch lazy future ... done
[13:17:30.440] run() for ‘MulticoreFuture’ ... done
[13:17:30.440] Created future:
[13:17:30.440] plan(): Setting new future strategy stack:
[13:17:30.441] List of future strategies:
[13:17:30.441] 1. sequential:
[13:17:30.441]    - args: function (..., envir = parent.frame())
[13:17:30.441]    - tweaked: FALSE
[13:17:30.441]    - call: NULL
[13:17:30.442] plan(): nbrOfWorkers() = 1
[13:17:30.446] plan(): Setting new future strategy stack:
[13:17:30.446] List of future strategies:
[13:17:30.446] 1. multicore:
[13:17:30.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.446]    - tweaked: FALSE
[13:17:30.446]    - call: plan(strategy)
[13:17:30.451] plan(): nbrOfWorkers() = 2
[13:17:30.440] MulticoreFuture:
[13:17:30.440] Label: ‘future_by-2’
[13:17:30.440] Expression:
[13:17:30.440] {
[13:17:30.440]     do.call(function(...) {
[13:17:30.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.440]             on.exit(options(oopts), add = TRUE)
[13:17:30.440]         }
[13:17:30.440]         {
[13:17:30.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.440]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.440]             })
[13:17:30.440]         }
[13:17:30.440]     }, args = future.call.arguments)
[13:17:30.440] }
[13:17:30.440] Lazy evaluation: FALSE
[13:17:30.440] Asynchronous evaluation: TRUE
[13:17:30.440] Local evaluation: TRUE
[13:17:30.440] Environment: 0x5609ea496c08
[13:17:30.440] Capture standard output: TRUE
[13:17:30.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.440] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.440] Packages: <none>
[13:17:30.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.440] Resolved: TRUE
[13:17:30.440] Value: <not collected>
[13:17:30.440] Conditions captured: <none>
[13:17:30.440] Early signaling: FALSE
[13:17:30.440] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.452] Chunk #2 of 2 ... DONE
[13:17:30.452] Launching 2 futures (chunks) ... DONE
[13:17:30.452] Resolving 2 futures (chunks) ...
[13:17:30.453] resolve() on list ...
[13:17:30.453]  recursive: 0
[13:17:30.453]  length: 2
[13:17:30.453] 
[13:17:30.454] Future #1
[13:17:30.455] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:30.455] - nx: 2
[13:17:30.455] - relay: TRUE
[13:17:30.455] - stdout: TRUE
[13:17:30.455] - signal: TRUE
[13:17:30.456] - resignal: FALSE
[13:17:30.456] - force: TRUE
[13:17:30.456] - relayed: [n=2] FALSE, FALSE
[13:17:30.456] - queued futures: [n=2] FALSE, FALSE
[13:17:30.456]  - until=1
[13:17:30.456]  - relaying element #1
[13:17:30.457] - relayed: [n=2] TRUE, FALSE
[13:17:30.457] - queued futures: [n=2] TRUE, FALSE
[13:17:30.457] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:30.457]  length: 1 (resolved future 1)
[13:17:30.458] Future #2
[13:17:30.459] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:30.459] - nx: 2
[13:17:30.459] - relay: TRUE
[13:17:30.459] - stdout: TRUE
[13:17:30.459] - signal: TRUE
[13:17:30.459] - resignal: FALSE
[13:17:30.459] - force: TRUE
[13:17:30.460] - relayed: [n=2] TRUE, FALSE
[13:17:30.460] - queued futures: [n=2] TRUE, FALSE
[13:17:30.460]  - until=2
[13:17:30.460]  - relaying element #2
[13:17:30.460] - relayed: [n=2] TRUE, TRUE
[13:17:30.460] - queued futures: [n=2] TRUE, TRUE
[13:17:30.460] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:30.461]  length: 0 (resolved future 2)
[13:17:30.461] Relaying remaining futures
[13:17:30.461] signalConditionsASAP(NULL, pos=0) ...
[13:17:30.461] - nx: 2
[13:17:30.461] - relay: TRUE
[13:17:30.461] - stdout: TRUE
[13:17:30.461] - signal: TRUE
[13:17:30.461] - resignal: FALSE
[13:17:30.462] - force: TRUE
[13:17:30.462] - relayed: [n=2] TRUE, TRUE
[13:17:30.462] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:30.462] - relayed: [n=2] TRUE, TRUE
[13:17:30.462] - queued futures: [n=2] TRUE, TRUE
[13:17:30.462] signalConditionsASAP(NULL, pos=0) ... done
[13:17:30.462] resolve() on list ... DONE
[13:17:30.463]  - Number of value chunks collected: 2
[13:17:30.463] Resolving 2 futures (chunks) ... DONE
[13:17:30.463] Reducing values from 2 chunks ...
[13:17:30.463]  - Number of values collected after concatenation: 3
[13:17:30.463]  - Number of values expected: 3
[13:17:30.463] Reducing values from 2 chunks ... DONE
[13:17:30.463] future_lapply() ... DONE
[13:17:30.464] future_by_internal() ... DONE
[13:17:30.465] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:17:30.465] future_lapply() ...
[13:17:30.471] Number of chunks: 2
[13:17:30.471] getGlobalsAndPackagesXApply() ...
[13:17:30.471]  - future.globals: TRUE
[13:17:30.471] getGlobalsAndPackages() ...
[13:17:30.471] Searching for globals...
[13:17:30.473] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:30.473] Searching for globals ... DONE
[13:17:30.473] Resolving globals: FALSE
[13:17:30.473] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:30.474] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:30.474] - globals: [1] ‘FUN’
[13:17:30.474] 
[13:17:30.474] getGlobalsAndPackages() ... DONE
[13:17:30.474]  - globals found/used: [n=1] ‘FUN’
[13:17:30.475]  - needed namespaces: [n=0] 
[13:17:30.475] Finding globals ... DONE
[13:17:30.475]  - use_args: TRUE
[13:17:30.475]  - Getting '...' globals ...
[13:17:30.475] resolve() on list ...
[13:17:30.476]  recursive: 0
[13:17:30.476]  length: 1
[13:17:30.476]  elements: ‘...’
[13:17:30.476]  length: 0 (resolved future 1)
[13:17:30.476] resolve() on list ... DONE
[13:17:30.476]    - '...' content: [n=0] 
[13:17:30.476] List of 1
[13:17:30.476]  $ ...: list()
[13:17:30.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.476]  - attr(*, "where")=List of 1
[13:17:30.476]   ..$ ...:<environment: 0x5609ec1e97c0> 
[13:17:30.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.476]  - attr(*, "resolved")= logi TRUE
[13:17:30.476]  - attr(*, "total_size")= num NA
[13:17:30.480]  - Getting '...' globals ... DONE
[13:17:30.480] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:30.480] List of 2
[13:17:30.480]  $ ...future.FUN:function (object, ...)  
[13:17:30.480]  $ ...          : list()
[13:17:30.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.480]  - attr(*, "where")=List of 2
[13:17:30.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:30.480]   ..$ ...          :<environment: 0x5609ec1e97c0> 
[13:17:30.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.480]  - attr(*, "resolved")= logi FALSE
[13:17:30.480]  - attr(*, "total_size")= num 1240
[13:17:30.484] Packages to be attached in all futures: [n=0] 
[13:17:30.484] getGlobalsAndPackagesXApply() ... DONE
[13:17:30.484] Number of futures (= number of chunks): 2
[13:17:30.484] Launching 2 futures (chunks) ...
[13:17:30.484] Chunk #1 of 2 ...
[13:17:30.484]  - Finding globals in 'X' for chunk #1 ...
[13:17:30.484] getGlobalsAndPackages() ...
[13:17:30.485] Searching for globals...
[13:17:30.485] 
[13:17:30.485] Searching for globals ... DONE
[13:17:30.485] - globals: [0] <none>
[13:17:30.485] getGlobalsAndPackages() ... DONE
[13:17:30.486]    + additional globals found: [n=0] 
[13:17:30.486]    + additional namespaces needed: [n=0] 
[13:17:30.486]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:30.486]  - seeds: <none>
[13:17:30.486] getGlobalsAndPackages() ...
[13:17:30.486] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.486] Resolving globals: FALSE
[13:17:30.486] Tweak future expression to call with '...' arguments ...
[13:17:30.487] {
[13:17:30.487]     do.call(function(...) {
[13:17:30.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.487]             on.exit(options(oopts), add = TRUE)
[13:17:30.487]         }
[13:17:30.487]         {
[13:17:30.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.487]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.487]             })
[13:17:30.487]         }
[13:17:30.487]     }, args = future.call.arguments)
[13:17:30.487] }
[13:17:30.487] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.487] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.487] 
[13:17:30.488] getGlobalsAndPackages() ... DONE
[13:17:30.488] run() for ‘Future’ ...
[13:17:30.488] - state: ‘created’
[13:17:30.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.493]   - Field: ‘label’
[13:17:30.493]   - Field: ‘local’
[13:17:30.493]   - Field: ‘owner’
[13:17:30.494]   - Field: ‘envir’
[13:17:30.494]   - Field: ‘workers’
[13:17:30.494]   - Field: ‘packages’
[13:17:30.494]   - Field: ‘gc’
[13:17:30.494]   - Field: ‘job’
[13:17:30.494]   - Field: ‘conditions’
[13:17:30.494]   - Field: ‘expr’
[13:17:30.494]   - Field: ‘uuid’
[13:17:30.495]   - Field: ‘seed’
[13:17:30.495]   - Field: ‘version’
[13:17:30.495]   - Field: ‘result’
[13:17:30.495]   - Field: ‘asynchronous’
[13:17:30.495]   - Field: ‘calls’
[13:17:30.495]   - Field: ‘globals’
[13:17:30.495]   - Field: ‘stdout’
[13:17:30.495]   - Field: ‘earlySignal’
[13:17:30.496]   - Field: ‘lazy’
[13:17:30.496]   - Field: ‘state’
[13:17:30.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.496] - Launch lazy future ...
[13:17:30.496] Packages needed by the future expression (n = 0): <none>
[13:17:30.496] Packages needed by future strategies (n = 0): <none>
[13:17:30.497] {
[13:17:30.497]     {
[13:17:30.497]         {
[13:17:30.497]             ...future.startTime <- base::Sys.time()
[13:17:30.497]             {
[13:17:30.497]                 {
[13:17:30.497]                   {
[13:17:30.497]                     {
[13:17:30.497]                       base::local({
[13:17:30.497]                         has_future <- base::requireNamespace("future", 
[13:17:30.497]                           quietly = TRUE)
[13:17:30.497]                         if (has_future) {
[13:17:30.497]                           ns <- base::getNamespace("future")
[13:17:30.497]                           version <- ns[[".package"]][["version"]]
[13:17:30.497]                           if (is.null(version)) 
[13:17:30.497]                             version <- utils::packageVersion("future")
[13:17:30.497]                         }
[13:17:30.497]                         else {
[13:17:30.497]                           version <- NULL
[13:17:30.497]                         }
[13:17:30.497]                         if (!has_future || version < "1.8.0") {
[13:17:30.497]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.497]                             "", base::R.version$version.string), 
[13:17:30.497]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:30.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:30.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.497]                               "release", "version")], collapse = " "), 
[13:17:30.497]                             hostname = base::Sys.info()[["nodename"]])
[13:17:30.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.497]                             info)
[13:17:30.497]                           info <- base::paste(info, collapse = "; ")
[13:17:30.497]                           if (!has_future) {
[13:17:30.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.497]                               info)
[13:17:30.497]                           }
[13:17:30.497]                           else {
[13:17:30.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.497]                               info, version)
[13:17:30.497]                           }
[13:17:30.497]                           base::stop(msg)
[13:17:30.497]                         }
[13:17:30.497]                       })
[13:17:30.497]                     }
[13:17:30.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.497]                     base::options(mc.cores = 1L)
[13:17:30.497]                   }
[13:17:30.497]                   options(future.plan = NULL)
[13:17:30.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.497]                 }
[13:17:30.497]                 ...future.workdir <- getwd()
[13:17:30.497]             }
[13:17:30.497]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.497]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.497]         }
[13:17:30.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:30.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.497]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.497]             base::names(...future.oldOptions))
[13:17:30.497]     }
[13:17:30.497]     if (FALSE) {
[13:17:30.497]     }
[13:17:30.497]     else {
[13:17:30.497]         if (TRUE) {
[13:17:30.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.497]                 open = "w")
[13:17:30.497]         }
[13:17:30.497]         else {
[13:17:30.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.497]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.497]         }
[13:17:30.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.497]             base::sink(type = "output", split = FALSE)
[13:17:30.497]             base::close(...future.stdout)
[13:17:30.497]         }, add = TRUE)
[13:17:30.497]     }
[13:17:30.497]     ...future.frame <- base::sys.nframe()
[13:17:30.497]     ...future.conditions <- base::list()
[13:17:30.497]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.497]     if (FALSE) {
[13:17:30.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.497]     }
[13:17:30.497]     ...future.result <- base::tryCatch({
[13:17:30.497]         base::withCallingHandlers({
[13:17:30.497]             ...future.value <- base::withVisible(base::local({
[13:17:30.497]                 withCallingHandlers({
[13:17:30.497]                   {
[13:17:30.497]                     do.call(function(...) {
[13:17:30.497]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.497]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.497]                         ...future.globals.maxSize)) {
[13:17:30.497]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.497]                         on.exit(options(oopts), add = TRUE)
[13:17:30.497]                       }
[13:17:30.497]                       {
[13:17:30.497]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.497]                           FUN = function(jj) {
[13:17:30.497]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.497]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.497]                           })
[13:17:30.497]                       }
[13:17:30.497]                     }, args = future.call.arguments)
[13:17:30.497]                   }
[13:17:30.497]                 }, immediateCondition = function(cond) {
[13:17:30.497]                   save_rds <- function (object, pathname, ...) 
[13:17:30.497]                   {
[13:17:30.497]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.497]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.497]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.497]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.497]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.497]                         fi_tmp[["mtime"]])
[13:17:30.497]                     }
[13:17:30.497]                     tryCatch({
[13:17:30.497]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.497]                     }, error = function(ex) {
[13:17:30.497]                       msg <- conditionMessage(ex)
[13:17:30.497]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.497]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.497]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.497]                         fi_tmp[["mtime"]], msg)
[13:17:30.497]                       ex$message <- msg
[13:17:30.497]                       stop(ex)
[13:17:30.497]                     })
[13:17:30.497]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.497]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.497]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.497]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.497]                       fi <- file.info(pathname)
[13:17:30.497]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.497]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.497]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.497]                         fi[["size"]], fi[["mtime"]])
[13:17:30.497]                       stop(msg)
[13:17:30.497]                     }
[13:17:30.497]                     invisible(pathname)
[13:17:30.497]                   }
[13:17:30.497]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.497]                     rootPath = tempdir()) 
[13:17:30.497]                   {
[13:17:30.497]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.497]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.497]                       tmpdir = path, fileext = ".rds")
[13:17:30.497]                     save_rds(obj, file)
[13:17:30.497]                   }
[13:17:30.497]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.497]                   {
[13:17:30.497]                     inherits <- base::inherits
[13:17:30.497]                     invokeRestart <- base::invokeRestart
[13:17:30.497]                     is.null <- base::is.null
[13:17:30.497]                     muffled <- FALSE
[13:17:30.497]                     if (inherits(cond, "message")) {
[13:17:30.497]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.497]                       if (muffled) 
[13:17:30.497]                         invokeRestart("muffleMessage")
[13:17:30.497]                     }
[13:17:30.497]                     else if (inherits(cond, "warning")) {
[13:17:30.497]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.497]                       if (muffled) 
[13:17:30.497]                         invokeRestart("muffleWarning")
[13:17:30.497]                     }
[13:17:30.497]                     else if (inherits(cond, "condition")) {
[13:17:30.497]                       if (!is.null(pattern)) {
[13:17:30.497]                         computeRestarts <- base::computeRestarts
[13:17:30.497]                         grepl <- base::grepl
[13:17:30.497]                         restarts <- computeRestarts(cond)
[13:17:30.497]                         for (restart in restarts) {
[13:17:30.497]                           name <- restart$name
[13:17:30.497]                           if (is.null(name)) 
[13:17:30.497]                             next
[13:17:30.497]                           if (!grepl(pattern, name)) 
[13:17:30.497]                             next
[13:17:30.497]                           invokeRestart(restart)
[13:17:30.497]                           muffled <- TRUE
[13:17:30.497]                           break
[13:17:30.497]                         }
[13:17:30.497]                       }
[13:17:30.497]                     }
[13:17:30.497]                     invisible(muffled)
[13:17:30.497]                   }
[13:17:30.497]                   muffleCondition(cond)
[13:17:30.497]                 })
[13:17:30.497]             }))
[13:17:30.497]             future::FutureResult(value = ...future.value$value, 
[13:17:30.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.497]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.497]                     ...future.globalenv.names))
[13:17:30.497]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.497]         }, condition = base::local({
[13:17:30.497]             c <- base::c
[13:17:30.497]             inherits <- base::inherits
[13:17:30.497]             invokeRestart <- base::invokeRestart
[13:17:30.497]             length <- base::length
[13:17:30.497]             list <- base::list
[13:17:30.497]             seq.int <- base::seq.int
[13:17:30.497]             signalCondition <- base::signalCondition
[13:17:30.497]             sys.calls <- base::sys.calls
[13:17:30.497]             `[[` <- base::`[[`
[13:17:30.497]             `+` <- base::`+`
[13:17:30.497]             `<<-` <- base::`<<-`
[13:17:30.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.497]                   3L)]
[13:17:30.497]             }
[13:17:30.497]             function(cond) {
[13:17:30.497]                 is_error <- inherits(cond, "error")
[13:17:30.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.497]                   NULL)
[13:17:30.497]                 if (is_error) {
[13:17:30.497]                   sessionInformation <- function() {
[13:17:30.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.497]                       search = base::search(), system = base::Sys.info())
[13:17:30.497]                   }
[13:17:30.497]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.497]                     cond$call), session = sessionInformation(), 
[13:17:30.497]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.497]                   signalCondition(cond)
[13:17:30.497]                 }
[13:17:30.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.497]                 "immediateCondition"))) {
[13:17:30.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.497]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.497]                   if (TRUE && !signal) {
[13:17:30.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.497]                     {
[13:17:30.497]                       inherits <- base::inherits
[13:17:30.497]                       invokeRestart <- base::invokeRestart
[13:17:30.497]                       is.null <- base::is.null
[13:17:30.497]                       muffled <- FALSE
[13:17:30.497]                       if (inherits(cond, "message")) {
[13:17:30.497]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.497]                         if (muffled) 
[13:17:30.497]                           invokeRestart("muffleMessage")
[13:17:30.497]                       }
[13:17:30.497]                       else if (inherits(cond, "warning")) {
[13:17:30.497]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.497]                         if (muffled) 
[13:17:30.497]                           invokeRestart("muffleWarning")
[13:17:30.497]                       }
[13:17:30.497]                       else if (inherits(cond, "condition")) {
[13:17:30.497]                         if (!is.null(pattern)) {
[13:17:30.497]                           computeRestarts <- base::computeRestarts
[13:17:30.497]                           grepl <- base::grepl
[13:17:30.497]                           restarts <- computeRestarts(cond)
[13:17:30.497]                           for (restart in restarts) {
[13:17:30.497]                             name <- restart$name
[13:17:30.497]                             if (is.null(name)) 
[13:17:30.497]                               next
[13:17:30.497]                             if (!grepl(pattern, name)) 
[13:17:30.497]                               next
[13:17:30.497]                             invokeRestart(restart)
[13:17:30.497]                             muffled <- TRUE
[13:17:30.497]                             break
[13:17:30.497]                           }
[13:17:30.497]                         }
[13:17:30.497]                       }
[13:17:30.497]                       invisible(muffled)
[13:17:30.497]                     }
[13:17:30.497]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.497]                   }
[13:17:30.497]                 }
[13:17:30.497]                 else {
[13:17:30.497]                   if (TRUE) {
[13:17:30.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.497]                     {
[13:17:30.497]                       inherits <- base::inherits
[13:17:30.497]                       invokeRestart <- base::invokeRestart
[13:17:30.497]                       is.null <- base::is.null
[13:17:30.497]                       muffled <- FALSE
[13:17:30.497]                       if (inherits(cond, "message")) {
[13:17:30.497]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.497]                         if (muffled) 
[13:17:30.497]                           invokeRestart("muffleMessage")
[13:17:30.497]                       }
[13:17:30.497]                       else if (inherits(cond, "warning")) {
[13:17:30.497]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.497]                         if (muffled) 
[13:17:30.497]                           invokeRestart("muffleWarning")
[13:17:30.497]                       }
[13:17:30.497]                       else if (inherits(cond, "condition")) {
[13:17:30.497]                         if (!is.null(pattern)) {
[13:17:30.497]                           computeRestarts <- base::computeRestarts
[13:17:30.497]                           grepl <- base::grepl
[13:17:30.497]                           restarts <- computeRestarts(cond)
[13:17:30.497]                           for (restart in restarts) {
[13:17:30.497]                             name <- restart$name
[13:17:30.497]                             if (is.null(name)) 
[13:17:30.497]                               next
[13:17:30.497]                             if (!grepl(pattern, name)) 
[13:17:30.497]                               next
[13:17:30.497]                             invokeRestart(restart)
[13:17:30.497]                             muffled <- TRUE
[13:17:30.497]                             break
[13:17:30.497]                           }
[13:17:30.497]                         }
[13:17:30.497]                       }
[13:17:30.497]                       invisible(muffled)
[13:17:30.497]                     }
[13:17:30.497]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.497]                   }
[13:17:30.497]                 }
[13:17:30.497]             }
[13:17:30.497]         }))
[13:17:30.497]     }, error = function(ex) {
[13:17:30.497]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.497]                 ...future.rng), started = ...future.startTime, 
[13:17:30.497]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.497]             version = "1.8"), class = "FutureResult")
[13:17:30.497]     }, finally = {
[13:17:30.497]         if (!identical(...future.workdir, getwd())) 
[13:17:30.497]             setwd(...future.workdir)
[13:17:30.497]         {
[13:17:30.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.497]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.497]             }
[13:17:30.497]             base::options(...future.oldOptions)
[13:17:30.497]             if (.Platform$OS.type == "windows") {
[13:17:30.497]                 old_names <- names(...future.oldEnvVars)
[13:17:30.497]                 envs <- base::Sys.getenv()
[13:17:30.497]                 names <- names(envs)
[13:17:30.497]                 common <- intersect(names, old_names)
[13:17:30.497]                 added <- setdiff(names, old_names)
[13:17:30.497]                 removed <- setdiff(old_names, names)
[13:17:30.497]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.497]                   envs[common]]
[13:17:30.497]                 NAMES <- toupper(changed)
[13:17:30.497]                 args <- list()
[13:17:30.497]                 for (kk in seq_along(NAMES)) {
[13:17:30.497]                   name <- changed[[kk]]
[13:17:30.497]                   NAME <- NAMES[[kk]]
[13:17:30.497]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.497]                     next
[13:17:30.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.497]                 }
[13:17:30.497]                 NAMES <- toupper(added)
[13:17:30.497]                 for (kk in seq_along(NAMES)) {
[13:17:30.497]                   name <- added[[kk]]
[13:17:30.497]                   NAME <- NAMES[[kk]]
[13:17:30.497]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.497]                     next
[13:17:30.497]                   args[[name]] <- ""
[13:17:30.497]                 }
[13:17:30.497]                 NAMES <- toupper(removed)
[13:17:30.497]                 for (kk in seq_along(NAMES)) {
[13:17:30.497]                   name <- removed[[kk]]
[13:17:30.497]                   NAME <- NAMES[[kk]]
[13:17:30.497]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.497]                     next
[13:17:30.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.497]                 }
[13:17:30.497]                 if (length(args) > 0) 
[13:17:30.497]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.497]             }
[13:17:30.497]             else {
[13:17:30.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.497]             }
[13:17:30.497]             {
[13:17:30.497]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.497]                   0L) {
[13:17:30.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.497]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.497]                   base::options(opts)
[13:17:30.497]                 }
[13:17:30.497]                 {
[13:17:30.497]                   {
[13:17:30.497]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.497]                     NULL
[13:17:30.497]                   }
[13:17:30.497]                   options(future.plan = NULL)
[13:17:30.497]                   if (is.na(NA_character_)) 
[13:17:30.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.497]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.497]                     envir = parent.frame()) 
[13:17:30.497]                   {
[13:17:30.497]                     default_workers <- missing(workers)
[13:17:30.497]                     if (is.function(workers)) 
[13:17:30.497]                       workers <- workers()
[13:17:30.497]                     workers <- structure(as.integer(workers), 
[13:17:30.497]                       class = class(workers))
[13:17:30.497]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.497]                       1L)
[13:17:30.497]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.497]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.497]                       if (default_workers) 
[13:17:30.497]                         supportsMulticore(warn = TRUE)
[13:17:30.497]                       return(sequential(..., envir = envir))
[13:17:30.497]                     }
[13:17:30.497]                     oopts <- options(mc.cores = workers)
[13:17:30.497]                     on.exit(options(oopts))
[13:17:30.497]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.497]                       envir = envir)
[13:17:30.497]                     if (!future$lazy) 
[13:17:30.497]                       future <- run(future)
[13:17:30.497]                     invisible(future)
[13:17:30.497]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.497]                 }
[13:17:30.497]             }
[13:17:30.497]         }
[13:17:30.497]     })
[13:17:30.497]     if (TRUE) {
[13:17:30.497]         base::sink(type = "output", split = FALSE)
[13:17:30.497]         if (TRUE) {
[13:17:30.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.497]         }
[13:17:30.497]         else {
[13:17:30.497]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.497]         }
[13:17:30.497]         base::close(...future.stdout)
[13:17:30.497]         ...future.stdout <- NULL
[13:17:30.497]     }
[13:17:30.497]     ...future.result$conditions <- ...future.conditions
[13:17:30.497]     ...future.result$finished <- base::Sys.time()
[13:17:30.497]     ...future.result
[13:17:30.497] }
[13:17:30.500] assign_globals() ...
[13:17:30.500] List of 5
[13:17:30.500]  $ ...future.FUN            :function (object, ...)  
[13:17:30.500]  $ future.call.arguments    : list()
[13:17:30.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.500]  $ ...future.elements_ii    :List of 1
[13:17:30.500]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.500]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:17:30.500]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.500]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:30.500]  $ ...future.seeds_ii       : NULL
[13:17:30.500]  $ ...future.globals.maxSize: NULL
[13:17:30.500]  - attr(*, "where")=List of 5
[13:17:30.500]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.500]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.500]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.500]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.500]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.500]  - attr(*, "resolved")= logi FALSE
[13:17:30.500]  - attr(*, "total_size")= num 1240
[13:17:30.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.500]  - attr(*, "already-done")= logi TRUE
[13:17:30.510] - copied ‘...future.FUN’ to environment
[13:17:30.510] - copied ‘future.call.arguments’ to environment
[13:17:30.510] - copied ‘...future.elements_ii’ to environment
[13:17:30.510] - copied ‘...future.seeds_ii’ to environment
[13:17:30.510] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.510] assign_globals() ... done
[13:17:30.510] requestCore(): workers = 2
[13:17:30.513] MulticoreFuture started
[13:17:30.513] - Launch lazy future ... done
[13:17:30.513] run() for ‘MulticoreFuture’ ... done
[13:17:30.514] Created future:
[13:17:30.514] plan(): Setting new future strategy stack:
[13:17:30.514] List of future strategies:
[13:17:30.514] 1. sequential:
[13:17:30.514]    - args: function (..., envir = parent.frame())
[13:17:30.514]    - tweaked: FALSE
[13:17:30.514]    - call: NULL
[13:17:30.515] plan(): nbrOfWorkers() = 1
[13:17:30.518] plan(): Setting new future strategy stack:
[13:17:30.519] List of future strategies:
[13:17:30.519] 1. multicore:
[13:17:30.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.519]    - tweaked: FALSE
[13:17:30.519]    - call: plan(strategy)
[13:17:30.524] plan(): nbrOfWorkers() = 2
[13:17:30.514] MulticoreFuture:
[13:17:30.514] Label: ‘future_by-1’
[13:17:30.514] Expression:
[13:17:30.514] {
[13:17:30.514]     do.call(function(...) {
[13:17:30.514]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.514]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.514]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.514]             on.exit(options(oopts), add = TRUE)
[13:17:30.514]         }
[13:17:30.514]         {
[13:17:30.514]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.514]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.514]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.514]             })
[13:17:30.514]         }
[13:17:30.514]     }, args = future.call.arguments)
[13:17:30.514] }
[13:17:30.514] Lazy evaluation: FALSE
[13:17:30.514] Asynchronous evaluation: TRUE
[13:17:30.514] Local evaluation: TRUE
[13:17:30.514] Environment: 0x5609ec1ba658
[13:17:30.514] Capture standard output: TRUE
[13:17:30.514] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.514] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.514] Packages: <none>
[13:17:30.514] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.514] Resolved: TRUE
[13:17:30.514] Value: <not collected>
[13:17:30.514] Conditions captured: <none>
[13:17:30.514] Early signaling: FALSE
[13:17:30.514] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.514] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.525] Chunk #1 of 2 ... DONE
[13:17:30.525] Chunk #2 of 2 ...
[13:17:30.525]  - Finding globals in 'X' for chunk #2 ...
[13:17:30.525] getGlobalsAndPackages() ...
[13:17:30.526] Searching for globals...
[13:17:30.526] 
[13:17:30.526] Searching for globals ... DONE
[13:17:30.527] - globals: [0] <none>
[13:17:30.527] getGlobalsAndPackages() ... DONE
[13:17:30.527]    + additional globals found: [n=0] 
[13:17:30.527]    + additional namespaces needed: [n=0] 
[13:17:30.527]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:30.527]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:30.527]  - seeds: <none>
[13:17:30.528] getGlobalsAndPackages() ...
[13:17:30.528] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.528] Resolving globals: FALSE
[13:17:30.528] Tweak future expression to call with '...' arguments ...
[13:17:30.528] {
[13:17:30.528]     do.call(function(...) {
[13:17:30.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.528]             on.exit(options(oopts), add = TRUE)
[13:17:30.528]         }
[13:17:30.528]         {
[13:17:30.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.528]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.528]             })
[13:17:30.528]         }
[13:17:30.528]     }, args = future.call.arguments)
[13:17:30.528] }
[13:17:30.529] Tweak future expression to call with '...' arguments ... DONE
[13:17:30.529] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:30.530] 
[13:17:30.530] getGlobalsAndPackages() ... DONE
[13:17:30.530] run() for ‘Future’ ...
[13:17:30.530] - state: ‘created’
[13:17:30.531] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:30.535] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:30.536]   - Field: ‘label’
[13:17:30.536]   - Field: ‘local’
[13:17:30.536]   - Field: ‘owner’
[13:17:30.536]   - Field: ‘envir’
[13:17:30.536]   - Field: ‘workers’
[13:17:30.537]   - Field: ‘packages’
[13:17:30.537]   - Field: ‘gc’
[13:17:30.537]   - Field: ‘job’
[13:17:30.537]   - Field: ‘conditions’
[13:17:30.537]   - Field: ‘expr’
[13:17:30.537]   - Field: ‘uuid’
[13:17:30.537]   - Field: ‘seed’
[13:17:30.538]   - Field: ‘version’
[13:17:30.538]   - Field: ‘result’
[13:17:30.538]   - Field: ‘asynchronous’
[13:17:30.538]   - Field: ‘calls’
[13:17:30.538]   - Field: ‘globals’
[13:17:30.538]   - Field: ‘stdout’
[13:17:30.538]   - Field: ‘earlySignal’
[13:17:30.539]   - Field: ‘lazy’
[13:17:30.539]   - Field: ‘state’
[13:17:30.539] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:30.539] - Launch lazy future ...
[13:17:30.540] Packages needed by the future expression (n = 0): <none>
[13:17:30.540] Packages needed by future strategies (n = 0): <none>
[13:17:30.541] {
[13:17:30.541]     {
[13:17:30.541]         {
[13:17:30.541]             ...future.startTime <- base::Sys.time()
[13:17:30.541]             {
[13:17:30.541]                 {
[13:17:30.541]                   {
[13:17:30.541]                     {
[13:17:30.541]                       base::local({
[13:17:30.541]                         has_future <- base::requireNamespace("future", 
[13:17:30.541]                           quietly = TRUE)
[13:17:30.541]                         if (has_future) {
[13:17:30.541]                           ns <- base::getNamespace("future")
[13:17:30.541]                           version <- ns[[".package"]][["version"]]
[13:17:30.541]                           if (is.null(version)) 
[13:17:30.541]                             version <- utils::packageVersion("future")
[13:17:30.541]                         }
[13:17:30.541]                         else {
[13:17:30.541]                           version <- NULL
[13:17:30.541]                         }
[13:17:30.541]                         if (!has_future || version < "1.8.0") {
[13:17:30.541]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:30.541]                             "", base::R.version$version.string), 
[13:17:30.541]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:30.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:30.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:30.541]                               "release", "version")], collapse = " "), 
[13:17:30.541]                             hostname = base::Sys.info()[["nodename"]])
[13:17:30.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:30.541]                             info)
[13:17:30.541]                           info <- base::paste(info, collapse = "; ")
[13:17:30.541]                           if (!has_future) {
[13:17:30.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:30.541]                               info)
[13:17:30.541]                           }
[13:17:30.541]                           else {
[13:17:30.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:30.541]                               info, version)
[13:17:30.541]                           }
[13:17:30.541]                           base::stop(msg)
[13:17:30.541]                         }
[13:17:30.541]                       })
[13:17:30.541]                     }
[13:17:30.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:30.541]                     base::options(mc.cores = 1L)
[13:17:30.541]                   }
[13:17:30.541]                   options(future.plan = NULL)
[13:17:30.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:30.541]                 }
[13:17:30.541]                 ...future.workdir <- getwd()
[13:17:30.541]             }
[13:17:30.541]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:30.541]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:30.541]         }
[13:17:30.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:30.541]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:30.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:30.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:30.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:30.541]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:30.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:30.541]             base::names(...future.oldOptions))
[13:17:30.541]     }
[13:17:30.541]     if (FALSE) {
[13:17:30.541]     }
[13:17:30.541]     else {
[13:17:30.541]         if (TRUE) {
[13:17:30.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:30.541]                 open = "w")
[13:17:30.541]         }
[13:17:30.541]         else {
[13:17:30.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:30.541]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:30.541]         }
[13:17:30.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:30.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:30.541]             base::sink(type = "output", split = FALSE)
[13:17:30.541]             base::close(...future.stdout)
[13:17:30.541]         }, add = TRUE)
[13:17:30.541]     }
[13:17:30.541]     ...future.frame <- base::sys.nframe()
[13:17:30.541]     ...future.conditions <- base::list()
[13:17:30.541]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:30.541]     if (FALSE) {
[13:17:30.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:30.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:30.541]     }
[13:17:30.541]     ...future.result <- base::tryCatch({
[13:17:30.541]         base::withCallingHandlers({
[13:17:30.541]             ...future.value <- base::withVisible(base::local({
[13:17:30.541]                 withCallingHandlers({
[13:17:30.541]                   {
[13:17:30.541]                     do.call(function(...) {
[13:17:30.541]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.541]                       if (!identical(...future.globals.maxSize.org, 
[13:17:30.541]                         ...future.globals.maxSize)) {
[13:17:30.541]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.541]                         on.exit(options(oopts), add = TRUE)
[13:17:30.541]                       }
[13:17:30.541]                       {
[13:17:30.541]                         lapply(seq_along(...future.elements_ii), 
[13:17:30.541]                           FUN = function(jj) {
[13:17:30.541]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.541]                             ...future.FUN(...future.X_jj, ...)
[13:17:30.541]                           })
[13:17:30.541]                       }
[13:17:30.541]                     }, args = future.call.arguments)
[13:17:30.541]                   }
[13:17:30.541]                 }, immediateCondition = function(cond) {
[13:17:30.541]                   save_rds <- function (object, pathname, ...) 
[13:17:30.541]                   {
[13:17:30.541]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:30.541]                     if (file_test("-f", pathname_tmp)) {
[13:17:30.541]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.541]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:30.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.541]                         fi_tmp[["mtime"]])
[13:17:30.541]                     }
[13:17:30.541]                     tryCatch({
[13:17:30.541]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:30.541]                     }, error = function(ex) {
[13:17:30.541]                       msg <- conditionMessage(ex)
[13:17:30.541]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.541]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:30.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.541]                         fi_tmp[["mtime"]], msg)
[13:17:30.541]                       ex$message <- msg
[13:17:30.541]                       stop(ex)
[13:17:30.541]                     })
[13:17:30.541]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:30.541]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:30.541]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:30.541]                       fi_tmp <- file.info(pathname_tmp)
[13:17:30.541]                       fi <- file.info(pathname)
[13:17:30.541]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:30.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:30.541]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:30.541]                         fi[["size"]], fi[["mtime"]])
[13:17:30.541]                       stop(msg)
[13:17:30.541]                     }
[13:17:30.541]                     invisible(pathname)
[13:17:30.541]                   }
[13:17:30.541]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:30.541]                     rootPath = tempdir()) 
[13:17:30.541]                   {
[13:17:30.541]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:30.541]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:30.541]                       tmpdir = path, fileext = ".rds")
[13:17:30.541]                     save_rds(obj, file)
[13:17:30.541]                   }
[13:17:30.541]                   saveImmediateCondition(cond, path = "/tmp/RtmpSVaOtz/.future/immediateConditions")
[13:17:30.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.541]                   {
[13:17:30.541]                     inherits <- base::inherits
[13:17:30.541]                     invokeRestart <- base::invokeRestart
[13:17:30.541]                     is.null <- base::is.null
[13:17:30.541]                     muffled <- FALSE
[13:17:30.541]                     if (inherits(cond, "message")) {
[13:17:30.541]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:30.541]                       if (muffled) 
[13:17:30.541]                         invokeRestart("muffleMessage")
[13:17:30.541]                     }
[13:17:30.541]                     else if (inherits(cond, "warning")) {
[13:17:30.541]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:30.541]                       if (muffled) 
[13:17:30.541]                         invokeRestart("muffleWarning")
[13:17:30.541]                     }
[13:17:30.541]                     else if (inherits(cond, "condition")) {
[13:17:30.541]                       if (!is.null(pattern)) {
[13:17:30.541]                         computeRestarts <- base::computeRestarts
[13:17:30.541]                         grepl <- base::grepl
[13:17:30.541]                         restarts <- computeRestarts(cond)
[13:17:30.541]                         for (restart in restarts) {
[13:17:30.541]                           name <- restart$name
[13:17:30.541]                           if (is.null(name)) 
[13:17:30.541]                             next
[13:17:30.541]                           if (!grepl(pattern, name)) 
[13:17:30.541]                             next
[13:17:30.541]                           invokeRestart(restart)
[13:17:30.541]                           muffled <- TRUE
[13:17:30.541]                           break
[13:17:30.541]                         }
[13:17:30.541]                       }
[13:17:30.541]                     }
[13:17:30.541]                     invisible(muffled)
[13:17:30.541]                   }
[13:17:30.541]                   muffleCondition(cond)
[13:17:30.541]                 })
[13:17:30.541]             }))
[13:17:30.541]             future::FutureResult(value = ...future.value$value, 
[13:17:30.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.541]                   ...future.rng), globalenv = if (FALSE) 
[13:17:30.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:30.541]                     ...future.globalenv.names))
[13:17:30.541]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:30.541]         }, condition = base::local({
[13:17:30.541]             c <- base::c
[13:17:30.541]             inherits <- base::inherits
[13:17:30.541]             invokeRestart <- base::invokeRestart
[13:17:30.541]             length <- base::length
[13:17:30.541]             list <- base::list
[13:17:30.541]             seq.int <- base::seq.int
[13:17:30.541]             signalCondition <- base::signalCondition
[13:17:30.541]             sys.calls <- base::sys.calls
[13:17:30.541]             `[[` <- base::`[[`
[13:17:30.541]             `+` <- base::`+`
[13:17:30.541]             `<<-` <- base::`<<-`
[13:17:30.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:30.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:30.541]                   3L)]
[13:17:30.541]             }
[13:17:30.541]             function(cond) {
[13:17:30.541]                 is_error <- inherits(cond, "error")
[13:17:30.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:30.541]                   NULL)
[13:17:30.541]                 if (is_error) {
[13:17:30.541]                   sessionInformation <- function() {
[13:17:30.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:30.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:30.541]                       search = base::search(), system = base::Sys.info())
[13:17:30.541]                   }
[13:17:30.541]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:30.541]                     cond$call), session = sessionInformation(), 
[13:17:30.541]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:30.541]                   signalCondition(cond)
[13:17:30.541]                 }
[13:17:30.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:30.541]                 "immediateCondition"))) {
[13:17:30.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:30.541]                   ...future.conditions[[length(...future.conditions) + 
[13:17:30.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:30.541]                   if (TRUE && !signal) {
[13:17:30.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.541]                     {
[13:17:30.541]                       inherits <- base::inherits
[13:17:30.541]                       invokeRestart <- base::invokeRestart
[13:17:30.541]                       is.null <- base::is.null
[13:17:30.541]                       muffled <- FALSE
[13:17:30.541]                       if (inherits(cond, "message")) {
[13:17:30.541]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.541]                         if (muffled) 
[13:17:30.541]                           invokeRestart("muffleMessage")
[13:17:30.541]                       }
[13:17:30.541]                       else if (inherits(cond, "warning")) {
[13:17:30.541]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.541]                         if (muffled) 
[13:17:30.541]                           invokeRestart("muffleWarning")
[13:17:30.541]                       }
[13:17:30.541]                       else if (inherits(cond, "condition")) {
[13:17:30.541]                         if (!is.null(pattern)) {
[13:17:30.541]                           computeRestarts <- base::computeRestarts
[13:17:30.541]                           grepl <- base::grepl
[13:17:30.541]                           restarts <- computeRestarts(cond)
[13:17:30.541]                           for (restart in restarts) {
[13:17:30.541]                             name <- restart$name
[13:17:30.541]                             if (is.null(name)) 
[13:17:30.541]                               next
[13:17:30.541]                             if (!grepl(pattern, name)) 
[13:17:30.541]                               next
[13:17:30.541]                             invokeRestart(restart)
[13:17:30.541]                             muffled <- TRUE
[13:17:30.541]                             break
[13:17:30.541]                           }
[13:17:30.541]                         }
[13:17:30.541]                       }
[13:17:30.541]                       invisible(muffled)
[13:17:30.541]                     }
[13:17:30.541]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.541]                   }
[13:17:30.541]                 }
[13:17:30.541]                 else {
[13:17:30.541]                   if (TRUE) {
[13:17:30.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:30.541]                     {
[13:17:30.541]                       inherits <- base::inherits
[13:17:30.541]                       invokeRestart <- base::invokeRestart
[13:17:30.541]                       is.null <- base::is.null
[13:17:30.541]                       muffled <- FALSE
[13:17:30.541]                       if (inherits(cond, "message")) {
[13:17:30.541]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:30.541]                         if (muffled) 
[13:17:30.541]                           invokeRestart("muffleMessage")
[13:17:30.541]                       }
[13:17:30.541]                       else if (inherits(cond, "warning")) {
[13:17:30.541]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:30.541]                         if (muffled) 
[13:17:30.541]                           invokeRestart("muffleWarning")
[13:17:30.541]                       }
[13:17:30.541]                       else if (inherits(cond, "condition")) {
[13:17:30.541]                         if (!is.null(pattern)) {
[13:17:30.541]                           computeRestarts <- base::computeRestarts
[13:17:30.541]                           grepl <- base::grepl
[13:17:30.541]                           restarts <- computeRestarts(cond)
[13:17:30.541]                           for (restart in restarts) {
[13:17:30.541]                             name <- restart$name
[13:17:30.541]                             if (is.null(name)) 
[13:17:30.541]                               next
[13:17:30.541]                             if (!grepl(pattern, name)) 
[13:17:30.541]                               next
[13:17:30.541]                             invokeRestart(restart)
[13:17:30.541]                             muffled <- TRUE
[13:17:30.541]                             break
[13:17:30.541]                           }
[13:17:30.541]                         }
[13:17:30.541]                       }
[13:17:30.541]                       invisible(muffled)
[13:17:30.541]                     }
[13:17:30.541]                     muffleCondition(cond, pattern = "^muffle")
[13:17:30.541]                   }
[13:17:30.541]                 }
[13:17:30.541]             }
[13:17:30.541]         }))
[13:17:30.541]     }, error = function(ex) {
[13:17:30.541]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:30.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:30.541]                 ...future.rng), started = ...future.startTime, 
[13:17:30.541]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:30.541]             version = "1.8"), class = "FutureResult")
[13:17:30.541]     }, finally = {
[13:17:30.541]         if (!identical(...future.workdir, getwd())) 
[13:17:30.541]             setwd(...future.workdir)
[13:17:30.541]         {
[13:17:30.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:30.541]                 ...future.oldOptions$nwarnings <- NULL
[13:17:30.541]             }
[13:17:30.541]             base::options(...future.oldOptions)
[13:17:30.541]             if (.Platform$OS.type == "windows") {
[13:17:30.541]                 old_names <- names(...future.oldEnvVars)
[13:17:30.541]                 envs <- base::Sys.getenv()
[13:17:30.541]                 names <- names(envs)
[13:17:30.541]                 common <- intersect(names, old_names)
[13:17:30.541]                 added <- setdiff(names, old_names)
[13:17:30.541]                 removed <- setdiff(old_names, names)
[13:17:30.541]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:30.541]                   envs[common]]
[13:17:30.541]                 NAMES <- toupper(changed)
[13:17:30.541]                 args <- list()
[13:17:30.541]                 for (kk in seq_along(NAMES)) {
[13:17:30.541]                   name <- changed[[kk]]
[13:17:30.541]                   NAME <- NAMES[[kk]]
[13:17:30.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.541]                     next
[13:17:30.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.541]                 }
[13:17:30.541]                 NAMES <- toupper(added)
[13:17:30.541]                 for (kk in seq_along(NAMES)) {
[13:17:30.541]                   name <- added[[kk]]
[13:17:30.541]                   NAME <- NAMES[[kk]]
[13:17:30.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.541]                     next
[13:17:30.541]                   args[[name]] <- ""
[13:17:30.541]                 }
[13:17:30.541]                 NAMES <- toupper(removed)
[13:17:30.541]                 for (kk in seq_along(NAMES)) {
[13:17:30.541]                   name <- removed[[kk]]
[13:17:30.541]                   NAME <- NAMES[[kk]]
[13:17:30.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:30.541]                     next
[13:17:30.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:30.541]                 }
[13:17:30.541]                 if (length(args) > 0) 
[13:17:30.541]                   base::do.call(base::Sys.setenv, args = args)
[13:17:30.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:30.541]             }
[13:17:30.541]             else {
[13:17:30.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:30.541]             }
[13:17:30.541]             {
[13:17:30.541]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:30.541]                   0L) {
[13:17:30.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:30.541]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:30.541]                   base::options(opts)
[13:17:30.541]                 }
[13:17:30.541]                 {
[13:17:30.541]                   {
[13:17:30.541]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:30.541]                     NULL
[13:17:30.541]                   }
[13:17:30.541]                   options(future.plan = NULL)
[13:17:30.541]                   if (is.na(NA_character_)) 
[13:17:30.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:30.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:30.541]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:30.541]                     envir = parent.frame()) 
[13:17:30.541]                   {
[13:17:30.541]                     default_workers <- missing(workers)
[13:17:30.541]                     if (is.function(workers)) 
[13:17:30.541]                       workers <- workers()
[13:17:30.541]                     workers <- structure(as.integer(workers), 
[13:17:30.541]                       class = class(workers))
[13:17:30.541]                     stop_if_not(is.finite(workers), workers >= 
[13:17:30.541]                       1L)
[13:17:30.541]                     if ((workers == 1L && !inherits(workers, 
[13:17:30.541]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:30.541]                       if (default_workers) 
[13:17:30.541]                         supportsMulticore(warn = TRUE)
[13:17:30.541]                       return(sequential(..., envir = envir))
[13:17:30.541]                     }
[13:17:30.541]                     oopts <- options(mc.cores = workers)
[13:17:30.541]                     on.exit(options(oopts))
[13:17:30.541]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:30.541]                       envir = envir)
[13:17:30.541]                     if (!future$lazy) 
[13:17:30.541]                       future <- run(future)
[13:17:30.541]                     invisible(future)
[13:17:30.541]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:30.541]                 }
[13:17:30.541]             }
[13:17:30.541]         }
[13:17:30.541]     })
[13:17:30.541]     if (TRUE) {
[13:17:30.541]         base::sink(type = "output", split = FALSE)
[13:17:30.541]         if (TRUE) {
[13:17:30.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:30.541]         }
[13:17:30.541]         else {
[13:17:30.541]             ...future.result["stdout"] <- base::list(NULL)
[13:17:30.541]         }
[13:17:30.541]         base::close(...future.stdout)
[13:17:30.541]         ...future.stdout <- NULL
[13:17:30.541]     }
[13:17:30.541]     ...future.result$conditions <- ...future.conditions
[13:17:30.541]     ...future.result$finished <- base::Sys.time()
[13:17:30.541]     ...future.result
[13:17:30.541] }
[13:17:30.544] assign_globals() ...
[13:17:30.544] List of 5
[13:17:30.544]  $ ...future.FUN            :function (object, ...)  
[13:17:30.544]  $ future.call.arguments    : list()
[13:17:30.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:30.544]  $ ...future.elements_ii    :List of 2
[13:17:30.544]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.544]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:17:30.544]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.544]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:17:30.544]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:17:30.544]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:17:30.544]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:17:30.544]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:17:30.544]  $ ...future.seeds_ii       : NULL
[13:17:30.544]  $ ...future.globals.maxSize: NULL
[13:17:30.544]  - attr(*, "resolved")= logi FALSE
[13:17:30.544]  - attr(*, "total_size")= num 1240
[13:17:30.544]  - attr(*, "where")=List of 5
[13:17:30.544]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:30.544]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:30.544]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:30.544]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:30.544]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:30.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:30.544]  - attr(*, "already-done")= logi TRUE
[13:17:30.556] - copied ‘...future.FUN’ to environment
[13:17:30.556] - copied ‘future.call.arguments’ to environment
[13:17:30.556] - copied ‘...future.elements_ii’ to environment
[13:17:30.556] - copied ‘...future.seeds_ii’ to environment
[13:17:30.556] - copied ‘...future.globals.maxSize’ to environment
[13:17:30.556] assign_globals() ... done
[13:17:30.557] requestCore(): workers = 2
[13:17:30.560] MulticoreFuture started
[13:17:30.560] - Launch lazy future ... done
[13:17:30.560] run() for ‘MulticoreFuture’ ... done
[13:17:30.561] Created future:
[13:17:30.561] plan(): Setting new future strategy stack:
[13:17:30.561] List of future strategies:
[13:17:30.561] 1. sequential:
[13:17:30.561]    - args: function (..., envir = parent.frame())
[13:17:30.561]    - tweaked: FALSE
[13:17:30.561]    - call: NULL
[13:17:30.562] plan(): nbrOfWorkers() = 1
[13:17:30.567] plan(): Setting new future strategy stack:
[13:17:30.567] List of future strategies:
[13:17:30.567] 1. multicore:
[13:17:30.567]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:30.567]    - tweaked: FALSE
[13:17:30.567]    - call: plan(strategy)
[13:17:30.572] plan(): nbrOfWorkers() = 2
[13:17:30.561] MulticoreFuture:
[13:17:30.561] Label: ‘future_by-2’
[13:17:30.561] Expression:
[13:17:30.561] {
[13:17:30.561]     do.call(function(...) {
[13:17:30.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:30.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:30.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:30.561]             on.exit(options(oopts), add = TRUE)
[13:17:30.561]         }
[13:17:30.561]         {
[13:17:30.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:30.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:30.561]                 ...future.FUN(...future.X_jj, ...)
[13:17:30.561]             })
[13:17:30.561]         }
[13:17:30.561]     }, args = future.call.arguments)
[13:17:30.561] }
[13:17:30.561] Lazy evaluation: FALSE
[13:17:30.561] Asynchronous evaluation: TRUE
[13:17:30.561] Local evaluation: TRUE
[13:17:30.561] Environment: 0x5609ec1ba658
[13:17:30.561] Capture standard output: TRUE
[13:17:30.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:30.561] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:30.561] Packages: <none>
[13:17:30.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:30.561] Resolved: TRUE
[13:17:30.561] Value: <not collected>
[13:17:30.561] Conditions captured: <none>
[13:17:30.561] Early signaling: FALSE
[13:17:30.561] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:30.561] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:30.574] Chunk #2 of 2 ... DONE
[13:17:30.574] Launching 2 futures (chunks) ... DONE
[13:17:30.574] Resolving 2 futures (chunks) ...
[13:17:30.574] resolve() on list ...
[13:17:30.574]  recursive: 0
[13:17:30.575]  length: 2
[13:17:30.575] 
[13:17:30.575] Future #1
[13:17:30.576] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:30.576] - nx: 2
[13:17:30.577] - relay: TRUE
[13:17:30.577] - stdout: TRUE
[13:17:30.577] - signal: TRUE
[13:17:30.577] - resignal: FALSE
[13:17:30.577] - force: TRUE
[13:17:30.577] - relayed: [n=2] FALSE, FALSE
[13:17:30.577] - queued futures: [n=2] FALSE, FALSE
[13:17:30.578]  - until=1
[13:17:30.578]  - relaying element #1
[13:17:30.578] - relayed: [n=2] TRUE, FALSE
[13:17:30.578] - queued futures: [n=2] TRUE, FALSE
[13:17:30.578] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:30.578]  length: 1 (resolved future 1)
[13:17:30.579] Future #2
[13:17:30.580] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:30.580] - nx: 2
[13:17:30.580] - relay: TRUE
[13:17:30.580] - stdout: TRUE
[13:17:30.580] - signal: TRUE
[13:17:30.580] - resignal: FALSE
[13:17:30.580] - force: TRUE
[13:17:30.580] - relayed: [n=2] TRUE, FALSE
[13:17:30.580] - queued futures: [n=2] TRUE, FALSE
[13:17:30.581]  - until=2
[13:17:30.581]  - relaying element #2
[13:17:30.581] - relayed: [n=2] TRUE, TRUE
[13:17:30.581] - queued futures: [n=2] TRUE, TRUE
[13:17:30.581] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:30.581]  length: 0 (resolved future 2)
[13:17:30.582] Relaying remaining futures
[13:17:30.582] signalConditionsASAP(NULL, pos=0) ...
[13:17:30.582] - nx: 2
[13:17:30.582] - relay: TRUE
[13:17:30.582] - stdout: TRUE
[13:17:30.582] - signal: TRUE
[13:17:30.582] - resignal: FALSE
[13:17:30.582] - force: TRUE
[13:17:30.582] - relayed: [n=2] TRUE, TRUE
[13:17:30.583] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:30.583] - relayed: [n=2] TRUE, TRUE
[13:17:30.583] - queued futures: [n=2] TRUE, TRUE
[13:17:30.583] signalConditionsASAP(NULL, pos=0) ... done
[13:17:30.583] resolve() on list ... DONE
[13:17:30.583]  - Number of value chunks collected: 2
[13:17:30.583] Resolving 2 futures (chunks) ... DONE
[13:17:30.583] Reducing values from 2 chunks ...
[13:17:30.584]  - Number of values collected after concatenation: 3
[13:17:30.584]  - Number of values expected: 3
[13:17:30.584] Reducing values from 2 chunks ... DONE
[13:17:30.584] future_lapply() ... DONE
[13:17:30.584] future_by_internal() ... DONE
[13:17:30.585] future_by_internal() ...
- plan('multisession') ...
[13:17:30.586] plan(): Setting new future strategy stack:
[13:17:30.586] List of future strategies:
[13:17:30.586] 1. multisession:
[13:17:30.586]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:30.586]    - tweaked: FALSE
[13:17:30.586]    - call: plan(strategy)
[13:17:30.587] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:17:30.587] multisession:
[13:17:30.587] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:30.587] - tweaked: FALSE
[13:17:30.587] - call: plan(strategy)
[13:17:30.594] getGlobalsAndPackages() ...
[13:17:30.594] Not searching for globals
[13:17:30.594] - globals: [0] <none>
[13:17:30.594] getGlobalsAndPackages() ... DONE
[13:17:30.595] [local output] makeClusterPSOCK() ...
[13:17:30.645] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:17:30.651] [local output] Base port: 11228
[13:17:30.651] [local output] Getting setup options for 2 cluster nodes ...
[13:17:30.651] [local output]  - Node 1 of 2 ...
[13:17:30.651] [local output] localMachine=TRUE => revtunnel=FALSE

[13:17:30.652] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpSVaOtz/worker.rank=1.parallelly.parent=70328.112b8609546ae.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpSVaOtz/worker.rank=1.parallelly.parent=70328.112b8609546ae.pid")'’
[13:17:30.848] - Possible to infer worker's PID: TRUE
[13:17:30.848] [local output] Rscript port: 11228

[13:17:30.848] [local output]  - Node 2 of 2 ...
[13:17:30.849] [local output] localMachine=TRUE => revtunnel=FALSE

[13:17:30.849] [local output] Rscript port: 11228

[13:17:30.850] [local output] Getting setup options for 2 cluster nodes ... done
[13:17:30.850] [local output]  - Parallel setup requested for some PSOCK nodes
[13:17:30.850] [local output] Setting up PSOCK nodes in parallel
[13:17:30.851] List of 36
[13:17:30.851]  $ worker          : chr "localhost"
[13:17:30.851]   ..- attr(*, "localhost")= logi TRUE
[13:17:30.851]  $ master          : chr "localhost"
[13:17:30.851]  $ port            : int 11228
[13:17:30.851]  $ connectTimeout  : num 120
[13:17:30.851]  $ timeout         : num 2592000
[13:17:30.851]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:17:30.851]  $ homogeneous     : logi TRUE
[13:17:30.851]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:17:30.851]  $ rscript_envs    : NULL
[13:17:30.851]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:17:30.851]  $ rscript_startup : NULL
[13:17:30.851]  $ rscript_sh      : chr "sh"
[13:17:30.851]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:17:30.851]  $ methods         : logi TRUE
[13:17:30.851]  $ socketOptions   : chr "no-delay"
[13:17:30.851]  $ useXDR          : logi FALSE
[13:17:30.851]  $ outfile         : chr "/dev/null"
[13:17:30.851]  $ renice          : int NA
[13:17:30.851]  $ rshcmd          : NULL
[13:17:30.851]  $ user            : chr(0) 
[13:17:30.851]  $ revtunnel       : logi FALSE
[13:17:30.851]  $ rshlogfile      : NULL
[13:17:30.851]  $ rshopts         : chr(0) 
[13:17:30.851]  $ rank            : int 1
[13:17:30.851]  $ manual          : logi FALSE
[13:17:30.851]  $ dryrun          : logi FALSE
[13:17:30.851]  $ quiet           : logi FALSE
[13:17:30.851]  $ setup_strategy  : chr "parallel"
[13:17:30.851]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:17:30.851]  $ pidfile         : chr "/tmp/RtmpSVaOtz/worker.rank=1.parallelly.parent=70328.112b8609546ae.pid"
[13:17:30.851]  $ rshcmd_label    : NULL
[13:17:30.851]  $ rsh_call        : NULL
[13:17:30.851]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:17:30.851]  $ localMachine    : logi TRUE
[13:17:30.851]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:17:30.851]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:17:30.851]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:17:30.851]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:17:30.851]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:17:30.851]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:17:30.851]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:17:30.851]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:17:30.851]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:17:30.851]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:17:30.851]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:17:30.851]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:17:30.851]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:17:30.851]  $ arguments       :List of 28
[13:17:30.851]   ..$ worker          : chr "localhost"
[13:17:30.851]   ..$ master          : NULL
[13:17:30.851]   ..$ port            : int 11228
[13:17:30.851]   ..$ connectTimeout  : num 120
[13:17:30.851]   ..$ timeout         : num 2592000
[13:17:30.851]   ..$ rscript         : NULL
[13:17:30.851]   ..$ homogeneous     : NULL
[13:17:30.851]   ..$ rscript_args    : NULL
[13:17:30.851]   ..$ rscript_envs    : NULL
[13:17:30.851]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:17:30.851]   ..$ rscript_startup : NULL
[13:17:30.851]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:17:30.851]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:17:30.851]   ..$ methods         : logi TRUE
[13:17:30.851]   ..$ socketOptions   : chr "no-delay"
[13:17:30.851]   ..$ useXDR          : logi FALSE
[13:17:30.851]   ..$ outfile         : chr "/dev/null"
[13:17:30.851]   ..$ renice          : int NA
[13:17:30.851]   ..$ rshcmd          : NULL
[13:17:30.851]   ..$ user            : NULL
[13:17:30.851]   ..$ revtunnel       : logi NA
[13:17:30.851]   ..$ rshlogfile      : NULL
[13:17:30.851]   ..$ rshopts         : NULL
[13:17:30.851]   ..$ rank            : int 1
[13:17:30.851]   ..$ manual          : logi FALSE
[13:17:30.851]   ..$ dryrun          : logi FALSE
[13:17:30.851]   ..$ quiet           : logi FALSE
[13:17:30.851]   ..$ setup_strategy  : chr "parallel"
[13:17:30.851]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:17:30.868] [local output] System call to launch all workers:
[13:17:30.868] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpSVaOtz/worker.rank=1.parallelly.parent=70328.112b8609546ae.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11228 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:17:30.868] [local output] Starting PSOCK main server
[13:17:30.869] [local output] Workers launched
[13:17:30.869] [local output] Waiting for workers to connect back
[13:17:30.870]  - [local output] 0 workers out of 2 ready
[13:17:31.133]  - [local output] 0 workers out of 2 ready
[13:17:31.134]  - [local output] 1 workers out of 2 ready
[13:17:31.147]  - [local output] 1 workers out of 2 ready
[13:17:31.147]  - [local output] 2 workers out of 2 ready
[13:17:31.147] [local output] Launching of workers completed
[13:17:31.147] [local output] Collecting session information from workers
[13:17:31.148] [local output]  - Worker #1 of 2
[13:17:31.149] [local output]  - Worker #2 of 2
[13:17:31.149] [local output] makeClusterPSOCK() ... done
[13:17:31.160] Packages needed by the future expression (n = 0): <none>
[13:17:31.160] Packages needed by future strategies (n = 0): <none>
[13:17:31.161] {
[13:17:31.161]     {
[13:17:31.161]         {
[13:17:31.161]             ...future.startTime <- base::Sys.time()
[13:17:31.161]             {
[13:17:31.161]                 {
[13:17:31.161]                   {
[13:17:31.161]                     {
[13:17:31.161]                       base::local({
[13:17:31.161]                         has_future <- base::requireNamespace("future", 
[13:17:31.161]                           quietly = TRUE)
[13:17:31.161]                         if (has_future) {
[13:17:31.161]                           ns <- base::getNamespace("future")
[13:17:31.161]                           version <- ns[[".package"]][["version"]]
[13:17:31.161]                           if (is.null(version)) 
[13:17:31.161]                             version <- utils::packageVersion("future")
[13:17:31.161]                         }
[13:17:31.161]                         else {
[13:17:31.161]                           version <- NULL
[13:17:31.161]                         }
[13:17:31.161]                         if (!has_future || version < "1.8.0") {
[13:17:31.161]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.161]                             "", base::R.version$version.string), 
[13:17:31.161]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:31.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:31.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.161]                               "release", "version")], collapse = " "), 
[13:17:31.161]                             hostname = base::Sys.info()[["nodename"]])
[13:17:31.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.161]                             info)
[13:17:31.161]                           info <- base::paste(info, collapse = "; ")
[13:17:31.161]                           if (!has_future) {
[13:17:31.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.161]                               info)
[13:17:31.161]                           }
[13:17:31.161]                           else {
[13:17:31.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.161]                               info, version)
[13:17:31.161]                           }
[13:17:31.161]                           base::stop(msg)
[13:17:31.161]                         }
[13:17:31.161]                       })
[13:17:31.161]                     }
[13:17:31.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.161]                     base::options(mc.cores = 1L)
[13:17:31.161]                   }
[13:17:31.161]                   options(future.plan = NULL)
[13:17:31.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.161]                 }
[13:17:31.161]                 ...future.workdir <- getwd()
[13:17:31.161]             }
[13:17:31.161]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.161]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.161]         }
[13:17:31.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:31.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.161]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.161]             base::names(...future.oldOptions))
[13:17:31.161]     }
[13:17:31.161]     if (FALSE) {
[13:17:31.161]     }
[13:17:31.161]     else {
[13:17:31.161]         if (TRUE) {
[13:17:31.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.161]                 open = "w")
[13:17:31.161]         }
[13:17:31.161]         else {
[13:17:31.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.161]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.161]         }
[13:17:31.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.161]             base::sink(type = "output", split = FALSE)
[13:17:31.161]             base::close(...future.stdout)
[13:17:31.161]         }, add = TRUE)
[13:17:31.161]     }
[13:17:31.161]     ...future.frame <- base::sys.nframe()
[13:17:31.161]     ...future.conditions <- base::list()
[13:17:31.161]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.161]     if (FALSE) {
[13:17:31.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.161]     }
[13:17:31.161]     ...future.result <- base::tryCatch({
[13:17:31.161]         base::withCallingHandlers({
[13:17:31.161]             ...future.value <- base::withVisible(base::local({
[13:17:31.161]                 ...future.makeSendCondition <- local({
[13:17:31.161]                   sendCondition <- NULL
[13:17:31.161]                   function(frame = 1L) {
[13:17:31.161]                     if (is.function(sendCondition)) 
[13:17:31.161]                       return(sendCondition)
[13:17:31.161]                     ns <- getNamespace("parallel")
[13:17:31.161]                     if (exists("sendData", mode = "function", 
[13:17:31.161]                       envir = ns)) {
[13:17:31.161]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.161]                         envir = ns)
[13:17:31.161]                       envir <- sys.frame(frame)
[13:17:31.161]                       master <- NULL
[13:17:31.161]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.161]                         !identical(envir, emptyenv())) {
[13:17:31.161]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.161]                           inherits = FALSE)) {
[13:17:31.161]                           master <- get("master", mode = "list", 
[13:17:31.161]                             envir = envir, inherits = FALSE)
[13:17:31.161]                           if (inherits(master, c("SOCKnode", 
[13:17:31.161]                             "SOCK0node"))) {
[13:17:31.161]                             sendCondition <<- function(cond) {
[13:17:31.161]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.161]                                 success = TRUE)
[13:17:31.161]                               parallel_sendData(master, data)
[13:17:31.161]                             }
[13:17:31.161]                             return(sendCondition)
[13:17:31.161]                           }
[13:17:31.161]                         }
[13:17:31.161]                         frame <- frame + 1L
[13:17:31.161]                         envir <- sys.frame(frame)
[13:17:31.161]                       }
[13:17:31.161]                     }
[13:17:31.161]                     sendCondition <<- function(cond) NULL
[13:17:31.161]                   }
[13:17:31.161]                 })
[13:17:31.161]                 withCallingHandlers({
[13:17:31.161]                   NA
[13:17:31.161]                 }, immediateCondition = function(cond) {
[13:17:31.161]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.161]                   sendCondition(cond)
[13:17:31.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.161]                   {
[13:17:31.161]                     inherits <- base::inherits
[13:17:31.161]                     invokeRestart <- base::invokeRestart
[13:17:31.161]                     is.null <- base::is.null
[13:17:31.161]                     muffled <- FALSE
[13:17:31.161]                     if (inherits(cond, "message")) {
[13:17:31.161]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.161]                       if (muffled) 
[13:17:31.161]                         invokeRestart("muffleMessage")
[13:17:31.161]                     }
[13:17:31.161]                     else if (inherits(cond, "warning")) {
[13:17:31.161]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.161]                       if (muffled) 
[13:17:31.161]                         invokeRestart("muffleWarning")
[13:17:31.161]                     }
[13:17:31.161]                     else if (inherits(cond, "condition")) {
[13:17:31.161]                       if (!is.null(pattern)) {
[13:17:31.161]                         computeRestarts <- base::computeRestarts
[13:17:31.161]                         grepl <- base::grepl
[13:17:31.161]                         restarts <- computeRestarts(cond)
[13:17:31.161]                         for (restart in restarts) {
[13:17:31.161]                           name <- restart$name
[13:17:31.161]                           if (is.null(name)) 
[13:17:31.161]                             next
[13:17:31.161]                           if (!grepl(pattern, name)) 
[13:17:31.161]                             next
[13:17:31.161]                           invokeRestart(restart)
[13:17:31.161]                           muffled <- TRUE
[13:17:31.161]                           break
[13:17:31.161]                         }
[13:17:31.161]                       }
[13:17:31.161]                     }
[13:17:31.161]                     invisible(muffled)
[13:17:31.161]                   }
[13:17:31.161]                   muffleCondition(cond)
[13:17:31.161]                 })
[13:17:31.161]             }))
[13:17:31.161]             future::FutureResult(value = ...future.value$value, 
[13:17:31.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.161]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.161]                     ...future.globalenv.names))
[13:17:31.161]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.161]         }, condition = base::local({
[13:17:31.161]             c <- base::c
[13:17:31.161]             inherits <- base::inherits
[13:17:31.161]             invokeRestart <- base::invokeRestart
[13:17:31.161]             length <- base::length
[13:17:31.161]             list <- base::list
[13:17:31.161]             seq.int <- base::seq.int
[13:17:31.161]             signalCondition <- base::signalCondition
[13:17:31.161]             sys.calls <- base::sys.calls
[13:17:31.161]             `[[` <- base::`[[`
[13:17:31.161]             `+` <- base::`+`
[13:17:31.161]             `<<-` <- base::`<<-`
[13:17:31.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.161]                   3L)]
[13:17:31.161]             }
[13:17:31.161]             function(cond) {
[13:17:31.161]                 is_error <- inherits(cond, "error")
[13:17:31.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.161]                   NULL)
[13:17:31.161]                 if (is_error) {
[13:17:31.161]                   sessionInformation <- function() {
[13:17:31.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.161]                       search = base::search(), system = base::Sys.info())
[13:17:31.161]                   }
[13:17:31.161]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.161]                     cond$call), session = sessionInformation(), 
[13:17:31.161]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.161]                   signalCondition(cond)
[13:17:31.161]                 }
[13:17:31.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.161]                 "immediateCondition"))) {
[13:17:31.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.161]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.161]                   if (TRUE && !signal) {
[13:17:31.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.161]                     {
[13:17:31.161]                       inherits <- base::inherits
[13:17:31.161]                       invokeRestart <- base::invokeRestart
[13:17:31.161]                       is.null <- base::is.null
[13:17:31.161]                       muffled <- FALSE
[13:17:31.161]                       if (inherits(cond, "message")) {
[13:17:31.161]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.161]                         if (muffled) 
[13:17:31.161]                           invokeRestart("muffleMessage")
[13:17:31.161]                       }
[13:17:31.161]                       else if (inherits(cond, "warning")) {
[13:17:31.161]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.161]                         if (muffled) 
[13:17:31.161]                           invokeRestart("muffleWarning")
[13:17:31.161]                       }
[13:17:31.161]                       else if (inherits(cond, "condition")) {
[13:17:31.161]                         if (!is.null(pattern)) {
[13:17:31.161]                           computeRestarts <- base::computeRestarts
[13:17:31.161]                           grepl <- base::grepl
[13:17:31.161]                           restarts <- computeRestarts(cond)
[13:17:31.161]                           for (restart in restarts) {
[13:17:31.161]                             name <- restart$name
[13:17:31.161]                             if (is.null(name)) 
[13:17:31.161]                               next
[13:17:31.161]                             if (!grepl(pattern, name)) 
[13:17:31.161]                               next
[13:17:31.161]                             invokeRestart(restart)
[13:17:31.161]                             muffled <- TRUE
[13:17:31.161]                             break
[13:17:31.161]                           }
[13:17:31.161]                         }
[13:17:31.161]                       }
[13:17:31.161]                       invisible(muffled)
[13:17:31.161]                     }
[13:17:31.161]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.161]                   }
[13:17:31.161]                 }
[13:17:31.161]                 else {
[13:17:31.161]                   if (TRUE) {
[13:17:31.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.161]                     {
[13:17:31.161]                       inherits <- base::inherits
[13:17:31.161]                       invokeRestart <- base::invokeRestart
[13:17:31.161]                       is.null <- base::is.null
[13:17:31.161]                       muffled <- FALSE
[13:17:31.161]                       if (inherits(cond, "message")) {
[13:17:31.161]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.161]                         if (muffled) 
[13:17:31.161]                           invokeRestart("muffleMessage")
[13:17:31.161]                       }
[13:17:31.161]                       else if (inherits(cond, "warning")) {
[13:17:31.161]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.161]                         if (muffled) 
[13:17:31.161]                           invokeRestart("muffleWarning")
[13:17:31.161]                       }
[13:17:31.161]                       else if (inherits(cond, "condition")) {
[13:17:31.161]                         if (!is.null(pattern)) {
[13:17:31.161]                           computeRestarts <- base::computeRestarts
[13:17:31.161]                           grepl <- base::grepl
[13:17:31.161]                           restarts <- computeRestarts(cond)
[13:17:31.161]                           for (restart in restarts) {
[13:17:31.161]                             name <- restart$name
[13:17:31.161]                             if (is.null(name)) 
[13:17:31.161]                               next
[13:17:31.161]                             if (!grepl(pattern, name)) 
[13:17:31.161]                               next
[13:17:31.161]                             invokeRestart(restart)
[13:17:31.161]                             muffled <- TRUE
[13:17:31.161]                             break
[13:17:31.161]                           }
[13:17:31.161]                         }
[13:17:31.161]                       }
[13:17:31.161]                       invisible(muffled)
[13:17:31.161]                     }
[13:17:31.161]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.161]                   }
[13:17:31.161]                 }
[13:17:31.161]             }
[13:17:31.161]         }))
[13:17:31.161]     }, error = function(ex) {
[13:17:31.161]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.161]                 ...future.rng), started = ...future.startTime, 
[13:17:31.161]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.161]             version = "1.8"), class = "FutureResult")
[13:17:31.161]     }, finally = {
[13:17:31.161]         if (!identical(...future.workdir, getwd())) 
[13:17:31.161]             setwd(...future.workdir)
[13:17:31.161]         {
[13:17:31.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.161]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.161]             }
[13:17:31.161]             base::options(...future.oldOptions)
[13:17:31.161]             if (.Platform$OS.type == "windows") {
[13:17:31.161]                 old_names <- names(...future.oldEnvVars)
[13:17:31.161]                 envs <- base::Sys.getenv()
[13:17:31.161]                 names <- names(envs)
[13:17:31.161]                 common <- intersect(names, old_names)
[13:17:31.161]                 added <- setdiff(names, old_names)
[13:17:31.161]                 removed <- setdiff(old_names, names)
[13:17:31.161]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.161]                   envs[common]]
[13:17:31.161]                 NAMES <- toupper(changed)
[13:17:31.161]                 args <- list()
[13:17:31.161]                 for (kk in seq_along(NAMES)) {
[13:17:31.161]                   name <- changed[[kk]]
[13:17:31.161]                   NAME <- NAMES[[kk]]
[13:17:31.161]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.161]                     next
[13:17:31.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.161]                 }
[13:17:31.161]                 NAMES <- toupper(added)
[13:17:31.161]                 for (kk in seq_along(NAMES)) {
[13:17:31.161]                   name <- added[[kk]]
[13:17:31.161]                   NAME <- NAMES[[kk]]
[13:17:31.161]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.161]                     next
[13:17:31.161]                   args[[name]] <- ""
[13:17:31.161]                 }
[13:17:31.161]                 NAMES <- toupper(removed)
[13:17:31.161]                 for (kk in seq_along(NAMES)) {
[13:17:31.161]                   name <- removed[[kk]]
[13:17:31.161]                   NAME <- NAMES[[kk]]
[13:17:31.161]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.161]                     next
[13:17:31.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.161]                 }
[13:17:31.161]                 if (length(args) > 0) 
[13:17:31.161]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.161]             }
[13:17:31.161]             else {
[13:17:31.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.161]             }
[13:17:31.161]             {
[13:17:31.161]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.161]                   0L) {
[13:17:31.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.161]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.161]                   base::options(opts)
[13:17:31.161]                 }
[13:17:31.161]                 {
[13:17:31.161]                   {
[13:17:31.161]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.161]                     NULL
[13:17:31.161]                   }
[13:17:31.161]                   options(future.plan = NULL)
[13:17:31.161]                   if (is.na(NA_character_)) 
[13:17:31.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.161]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.161]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.161]                     envir = parent.frame()) 
[13:17:31.161]                   {
[13:17:31.161]                     if (is.function(workers)) 
[13:17:31.161]                       workers <- workers()
[13:17:31.161]                     workers <- structure(as.integer(workers), 
[13:17:31.161]                       class = class(workers))
[13:17:31.161]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.161]                       workers >= 1)
[13:17:31.161]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.161]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.161]                     }
[13:17:31.161]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.161]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.161]                       envir = envir)
[13:17:31.161]                     if (!future$lazy) 
[13:17:31.161]                       future <- run(future)
[13:17:31.161]                     invisible(future)
[13:17:31.161]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.161]                 }
[13:17:31.161]             }
[13:17:31.161]         }
[13:17:31.161]     })
[13:17:31.161]     if (TRUE) {
[13:17:31.161]         base::sink(type = "output", split = FALSE)
[13:17:31.161]         if (TRUE) {
[13:17:31.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.161]         }
[13:17:31.161]         else {
[13:17:31.161]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.161]         }
[13:17:31.161]         base::close(...future.stdout)
[13:17:31.161]         ...future.stdout <- NULL
[13:17:31.161]     }
[13:17:31.161]     ...future.result$conditions <- ...future.conditions
[13:17:31.161]     ...future.result$finished <- base::Sys.time()
[13:17:31.161]     ...future.result
[13:17:31.161] }
[13:17:31.232] MultisessionFuture started
[13:17:31.232] result() for ClusterFuture ...
[13:17:31.233] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.233] - Validating connection of MultisessionFuture
[13:17:31.264] - received message: FutureResult
[13:17:31.264] - Received FutureResult
[13:17:31.264] - Erased future from FutureRegistry
[13:17:31.264] result() for ClusterFuture ...
[13:17:31.264] - result already collected: FutureResult
[13:17:31.265] result() for ClusterFuture ... done
[13:17:31.265] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.265] result() for ClusterFuture ... done
[13:17:31.265] result() for ClusterFuture ...
[13:17:31.265] - result already collected: FutureResult
[13:17:31.265] result() for ClusterFuture ... done
[13:17:31.265] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:17:31.268] plan(): nbrOfWorkers() = 2
[13:17:31.269] future_by_internal() ...
[13:17:31.269] future_lapply() ...
[13:17:31.273] Number of chunks: 2
[13:17:31.273] getGlobalsAndPackagesXApply() ...
[13:17:31.273]  - future.globals: TRUE
[13:17:31.273] getGlobalsAndPackages() ...
[13:17:31.273] Searching for globals...
[13:17:31.274] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:31.274] Searching for globals ... DONE
[13:17:31.274] Resolving globals: FALSE
[13:17:31.275] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:31.275] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:31.275] - globals: [1] ‘FUN’
[13:17:31.275] 
[13:17:31.275] getGlobalsAndPackages() ... DONE
[13:17:31.275]  - globals found/used: [n=1] ‘FUN’
[13:17:31.275]  - needed namespaces: [n=0] 
[13:17:31.276] Finding globals ... DONE
[13:17:31.276]  - use_args: TRUE
[13:17:31.276]  - Getting '...' globals ...
[13:17:31.276] resolve() on list ...
[13:17:31.276]  recursive: 0
[13:17:31.276]  length: 1
[13:17:31.276]  elements: ‘...’
[13:17:31.276]  length: 0 (resolved future 1)
[13:17:31.276] resolve() on list ... DONE
[13:17:31.277]    - '...' content: [n=0] 
[13:17:31.277] List of 1
[13:17:31.277]  $ ...: list()
[13:17:31.277]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.277]  - attr(*, "where")=List of 1
[13:17:31.277]   ..$ ...:<environment: 0x5609ebd725e0> 
[13:17:31.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.277]  - attr(*, "resolved")= logi TRUE
[13:17:31.277]  - attr(*, "total_size")= num NA
[13:17:31.279]  - Getting '...' globals ... DONE
[13:17:31.279] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:31.279] List of 2
[13:17:31.279]  $ ...future.FUN:function (object, ...)  
[13:17:31.279]  $ ...          : list()
[13:17:31.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.279]  - attr(*, "where")=List of 2
[13:17:31.279]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:31.279]   ..$ ...          :<environment: 0x5609ebd725e0> 
[13:17:31.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.279]  - attr(*, "resolved")= logi FALSE
[13:17:31.279]  - attr(*, "total_size")= num 1240
[13:17:31.282] Packages to be attached in all futures: [n=0] 
[13:17:31.282] getGlobalsAndPackagesXApply() ... DONE
[13:17:31.282] Number of futures (= number of chunks): 2
[13:17:31.282] Launching 2 futures (chunks) ...
[13:17:31.282] Chunk #1 of 2 ...
[13:17:31.283]  - Finding globals in 'X' for chunk #1 ...
[13:17:31.283] getGlobalsAndPackages() ...
[13:17:31.283] Searching for globals...
[13:17:31.283] 
[13:17:31.283] Searching for globals ... DONE
[13:17:31.283] - globals: [0] <none>
[13:17:31.283] getGlobalsAndPackages() ... DONE
[13:17:31.283]    + additional globals found: [n=0] 
[13:17:31.284]    + additional namespaces needed: [n=0] 
[13:17:31.284]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:31.284]  - seeds: <none>
[13:17:31.284] getGlobalsAndPackages() ...
[13:17:31.284] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.284] Resolving globals: FALSE
[13:17:31.284] Tweak future expression to call with '...' arguments ...
[13:17:31.284] {
[13:17:31.284]     do.call(function(...) {
[13:17:31.284]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.284]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.284]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.284]             on.exit(options(oopts), add = TRUE)
[13:17:31.284]         }
[13:17:31.284]         {
[13:17:31.284]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.284]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.284]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.284]             })
[13:17:31.284]         }
[13:17:31.284]     }, args = future.call.arguments)
[13:17:31.284] }
[13:17:31.284] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.285] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.285] 
[13:17:31.285] getGlobalsAndPackages() ... DONE
[13:17:31.285] run() for ‘Future’ ...
[13:17:31.285] - state: ‘created’
[13:17:31.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.300]   - Field: ‘node’
[13:17:31.300]   - Field: ‘label’
[13:17:31.300]   - Field: ‘local’
[13:17:31.300]   - Field: ‘owner’
[13:17:31.300]   - Field: ‘envir’
[13:17:31.300]   - Field: ‘workers’
[13:17:31.301]   - Field: ‘packages’
[13:17:31.301]   - Field: ‘gc’
[13:17:31.301]   - Field: ‘conditions’
[13:17:31.301]   - Field: ‘persistent’
[13:17:31.301]   - Field: ‘expr’
[13:17:31.301]   - Field: ‘uuid’
[13:17:31.301]   - Field: ‘seed’
[13:17:31.301]   - Field: ‘version’
[13:17:31.301]   - Field: ‘result’
[13:17:31.301]   - Field: ‘asynchronous’
[13:17:31.301]   - Field: ‘calls’
[13:17:31.302]   - Field: ‘globals’
[13:17:31.302]   - Field: ‘stdout’
[13:17:31.302]   - Field: ‘earlySignal’
[13:17:31.302]   - Field: ‘lazy’
[13:17:31.302]   - Field: ‘state’
[13:17:31.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.302] - Launch lazy future ...
[13:17:31.302] Packages needed by the future expression (n = 0): <none>
[13:17:31.302] Packages needed by future strategies (n = 0): <none>
[13:17:31.303] {
[13:17:31.303]     {
[13:17:31.303]         {
[13:17:31.303]             ...future.startTime <- base::Sys.time()
[13:17:31.303]             {
[13:17:31.303]                 {
[13:17:31.303]                   {
[13:17:31.303]                     {
[13:17:31.303]                       base::local({
[13:17:31.303]                         has_future <- base::requireNamespace("future", 
[13:17:31.303]                           quietly = TRUE)
[13:17:31.303]                         if (has_future) {
[13:17:31.303]                           ns <- base::getNamespace("future")
[13:17:31.303]                           version <- ns[[".package"]][["version"]]
[13:17:31.303]                           if (is.null(version)) 
[13:17:31.303]                             version <- utils::packageVersion("future")
[13:17:31.303]                         }
[13:17:31.303]                         else {
[13:17:31.303]                           version <- NULL
[13:17:31.303]                         }
[13:17:31.303]                         if (!has_future || version < "1.8.0") {
[13:17:31.303]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.303]                             "", base::R.version$version.string), 
[13:17:31.303]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:31.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:31.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.303]                               "release", "version")], collapse = " "), 
[13:17:31.303]                             hostname = base::Sys.info()[["nodename"]])
[13:17:31.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.303]                             info)
[13:17:31.303]                           info <- base::paste(info, collapse = "; ")
[13:17:31.303]                           if (!has_future) {
[13:17:31.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.303]                               info)
[13:17:31.303]                           }
[13:17:31.303]                           else {
[13:17:31.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.303]                               info, version)
[13:17:31.303]                           }
[13:17:31.303]                           base::stop(msg)
[13:17:31.303]                         }
[13:17:31.303]                       })
[13:17:31.303]                     }
[13:17:31.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.303]                     base::options(mc.cores = 1L)
[13:17:31.303]                   }
[13:17:31.303]                   options(future.plan = NULL)
[13:17:31.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.303]                 }
[13:17:31.303]                 ...future.workdir <- getwd()
[13:17:31.303]             }
[13:17:31.303]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.303]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.303]         }
[13:17:31.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:31.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.303]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.303]             base::names(...future.oldOptions))
[13:17:31.303]     }
[13:17:31.303]     if (FALSE) {
[13:17:31.303]     }
[13:17:31.303]     else {
[13:17:31.303]         if (TRUE) {
[13:17:31.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.303]                 open = "w")
[13:17:31.303]         }
[13:17:31.303]         else {
[13:17:31.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.303]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.303]         }
[13:17:31.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.303]             base::sink(type = "output", split = FALSE)
[13:17:31.303]             base::close(...future.stdout)
[13:17:31.303]         }, add = TRUE)
[13:17:31.303]     }
[13:17:31.303]     ...future.frame <- base::sys.nframe()
[13:17:31.303]     ...future.conditions <- base::list()
[13:17:31.303]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.303]     if (FALSE) {
[13:17:31.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.303]     }
[13:17:31.303]     ...future.result <- base::tryCatch({
[13:17:31.303]         base::withCallingHandlers({
[13:17:31.303]             ...future.value <- base::withVisible(base::local({
[13:17:31.303]                 ...future.makeSendCondition <- local({
[13:17:31.303]                   sendCondition <- NULL
[13:17:31.303]                   function(frame = 1L) {
[13:17:31.303]                     if (is.function(sendCondition)) 
[13:17:31.303]                       return(sendCondition)
[13:17:31.303]                     ns <- getNamespace("parallel")
[13:17:31.303]                     if (exists("sendData", mode = "function", 
[13:17:31.303]                       envir = ns)) {
[13:17:31.303]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.303]                         envir = ns)
[13:17:31.303]                       envir <- sys.frame(frame)
[13:17:31.303]                       master <- NULL
[13:17:31.303]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.303]                         !identical(envir, emptyenv())) {
[13:17:31.303]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.303]                           inherits = FALSE)) {
[13:17:31.303]                           master <- get("master", mode = "list", 
[13:17:31.303]                             envir = envir, inherits = FALSE)
[13:17:31.303]                           if (inherits(master, c("SOCKnode", 
[13:17:31.303]                             "SOCK0node"))) {
[13:17:31.303]                             sendCondition <<- function(cond) {
[13:17:31.303]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.303]                                 success = TRUE)
[13:17:31.303]                               parallel_sendData(master, data)
[13:17:31.303]                             }
[13:17:31.303]                             return(sendCondition)
[13:17:31.303]                           }
[13:17:31.303]                         }
[13:17:31.303]                         frame <- frame + 1L
[13:17:31.303]                         envir <- sys.frame(frame)
[13:17:31.303]                       }
[13:17:31.303]                     }
[13:17:31.303]                     sendCondition <<- function(cond) NULL
[13:17:31.303]                   }
[13:17:31.303]                 })
[13:17:31.303]                 withCallingHandlers({
[13:17:31.303]                   {
[13:17:31.303]                     do.call(function(...) {
[13:17:31.303]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.303]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.303]                         ...future.globals.maxSize)) {
[13:17:31.303]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.303]                         on.exit(options(oopts), add = TRUE)
[13:17:31.303]                       }
[13:17:31.303]                       {
[13:17:31.303]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.303]                           FUN = function(jj) {
[13:17:31.303]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.303]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.303]                           })
[13:17:31.303]                       }
[13:17:31.303]                     }, args = future.call.arguments)
[13:17:31.303]                   }
[13:17:31.303]                 }, immediateCondition = function(cond) {
[13:17:31.303]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.303]                   sendCondition(cond)
[13:17:31.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.303]                   {
[13:17:31.303]                     inherits <- base::inherits
[13:17:31.303]                     invokeRestart <- base::invokeRestart
[13:17:31.303]                     is.null <- base::is.null
[13:17:31.303]                     muffled <- FALSE
[13:17:31.303]                     if (inherits(cond, "message")) {
[13:17:31.303]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.303]                       if (muffled) 
[13:17:31.303]                         invokeRestart("muffleMessage")
[13:17:31.303]                     }
[13:17:31.303]                     else if (inherits(cond, "warning")) {
[13:17:31.303]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.303]                       if (muffled) 
[13:17:31.303]                         invokeRestart("muffleWarning")
[13:17:31.303]                     }
[13:17:31.303]                     else if (inherits(cond, "condition")) {
[13:17:31.303]                       if (!is.null(pattern)) {
[13:17:31.303]                         computeRestarts <- base::computeRestarts
[13:17:31.303]                         grepl <- base::grepl
[13:17:31.303]                         restarts <- computeRestarts(cond)
[13:17:31.303]                         for (restart in restarts) {
[13:17:31.303]                           name <- restart$name
[13:17:31.303]                           if (is.null(name)) 
[13:17:31.303]                             next
[13:17:31.303]                           if (!grepl(pattern, name)) 
[13:17:31.303]                             next
[13:17:31.303]                           invokeRestart(restart)
[13:17:31.303]                           muffled <- TRUE
[13:17:31.303]                           break
[13:17:31.303]                         }
[13:17:31.303]                       }
[13:17:31.303]                     }
[13:17:31.303]                     invisible(muffled)
[13:17:31.303]                   }
[13:17:31.303]                   muffleCondition(cond)
[13:17:31.303]                 })
[13:17:31.303]             }))
[13:17:31.303]             future::FutureResult(value = ...future.value$value, 
[13:17:31.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.303]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.303]                     ...future.globalenv.names))
[13:17:31.303]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.303]         }, condition = base::local({
[13:17:31.303]             c <- base::c
[13:17:31.303]             inherits <- base::inherits
[13:17:31.303]             invokeRestart <- base::invokeRestart
[13:17:31.303]             length <- base::length
[13:17:31.303]             list <- base::list
[13:17:31.303]             seq.int <- base::seq.int
[13:17:31.303]             signalCondition <- base::signalCondition
[13:17:31.303]             sys.calls <- base::sys.calls
[13:17:31.303]             `[[` <- base::`[[`
[13:17:31.303]             `+` <- base::`+`
[13:17:31.303]             `<<-` <- base::`<<-`
[13:17:31.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.303]                   3L)]
[13:17:31.303]             }
[13:17:31.303]             function(cond) {
[13:17:31.303]                 is_error <- inherits(cond, "error")
[13:17:31.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.303]                   NULL)
[13:17:31.303]                 if (is_error) {
[13:17:31.303]                   sessionInformation <- function() {
[13:17:31.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.303]                       search = base::search(), system = base::Sys.info())
[13:17:31.303]                   }
[13:17:31.303]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.303]                     cond$call), session = sessionInformation(), 
[13:17:31.303]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.303]                   signalCondition(cond)
[13:17:31.303]                 }
[13:17:31.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.303]                 "immediateCondition"))) {
[13:17:31.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.303]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.303]                   if (TRUE && !signal) {
[13:17:31.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.303]                     {
[13:17:31.303]                       inherits <- base::inherits
[13:17:31.303]                       invokeRestart <- base::invokeRestart
[13:17:31.303]                       is.null <- base::is.null
[13:17:31.303]                       muffled <- FALSE
[13:17:31.303]                       if (inherits(cond, "message")) {
[13:17:31.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.303]                         if (muffled) 
[13:17:31.303]                           invokeRestart("muffleMessage")
[13:17:31.303]                       }
[13:17:31.303]                       else if (inherits(cond, "warning")) {
[13:17:31.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.303]                         if (muffled) 
[13:17:31.303]                           invokeRestart("muffleWarning")
[13:17:31.303]                       }
[13:17:31.303]                       else if (inherits(cond, "condition")) {
[13:17:31.303]                         if (!is.null(pattern)) {
[13:17:31.303]                           computeRestarts <- base::computeRestarts
[13:17:31.303]                           grepl <- base::grepl
[13:17:31.303]                           restarts <- computeRestarts(cond)
[13:17:31.303]                           for (restart in restarts) {
[13:17:31.303]                             name <- restart$name
[13:17:31.303]                             if (is.null(name)) 
[13:17:31.303]                               next
[13:17:31.303]                             if (!grepl(pattern, name)) 
[13:17:31.303]                               next
[13:17:31.303]                             invokeRestart(restart)
[13:17:31.303]                             muffled <- TRUE
[13:17:31.303]                             break
[13:17:31.303]                           }
[13:17:31.303]                         }
[13:17:31.303]                       }
[13:17:31.303]                       invisible(muffled)
[13:17:31.303]                     }
[13:17:31.303]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.303]                   }
[13:17:31.303]                 }
[13:17:31.303]                 else {
[13:17:31.303]                   if (TRUE) {
[13:17:31.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.303]                     {
[13:17:31.303]                       inherits <- base::inherits
[13:17:31.303]                       invokeRestart <- base::invokeRestart
[13:17:31.303]                       is.null <- base::is.null
[13:17:31.303]                       muffled <- FALSE
[13:17:31.303]                       if (inherits(cond, "message")) {
[13:17:31.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.303]                         if (muffled) 
[13:17:31.303]                           invokeRestart("muffleMessage")
[13:17:31.303]                       }
[13:17:31.303]                       else if (inherits(cond, "warning")) {
[13:17:31.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.303]                         if (muffled) 
[13:17:31.303]                           invokeRestart("muffleWarning")
[13:17:31.303]                       }
[13:17:31.303]                       else if (inherits(cond, "condition")) {
[13:17:31.303]                         if (!is.null(pattern)) {
[13:17:31.303]                           computeRestarts <- base::computeRestarts
[13:17:31.303]                           grepl <- base::grepl
[13:17:31.303]                           restarts <- computeRestarts(cond)
[13:17:31.303]                           for (restart in restarts) {
[13:17:31.303]                             name <- restart$name
[13:17:31.303]                             if (is.null(name)) 
[13:17:31.303]                               next
[13:17:31.303]                             if (!grepl(pattern, name)) 
[13:17:31.303]                               next
[13:17:31.303]                             invokeRestart(restart)
[13:17:31.303]                             muffled <- TRUE
[13:17:31.303]                             break
[13:17:31.303]                           }
[13:17:31.303]                         }
[13:17:31.303]                       }
[13:17:31.303]                       invisible(muffled)
[13:17:31.303]                     }
[13:17:31.303]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.303]                   }
[13:17:31.303]                 }
[13:17:31.303]             }
[13:17:31.303]         }))
[13:17:31.303]     }, error = function(ex) {
[13:17:31.303]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.303]                 ...future.rng), started = ...future.startTime, 
[13:17:31.303]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.303]             version = "1.8"), class = "FutureResult")
[13:17:31.303]     }, finally = {
[13:17:31.303]         if (!identical(...future.workdir, getwd())) 
[13:17:31.303]             setwd(...future.workdir)
[13:17:31.303]         {
[13:17:31.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.303]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.303]             }
[13:17:31.303]             base::options(...future.oldOptions)
[13:17:31.303]             if (.Platform$OS.type == "windows") {
[13:17:31.303]                 old_names <- names(...future.oldEnvVars)
[13:17:31.303]                 envs <- base::Sys.getenv()
[13:17:31.303]                 names <- names(envs)
[13:17:31.303]                 common <- intersect(names, old_names)
[13:17:31.303]                 added <- setdiff(names, old_names)
[13:17:31.303]                 removed <- setdiff(old_names, names)
[13:17:31.303]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.303]                   envs[common]]
[13:17:31.303]                 NAMES <- toupper(changed)
[13:17:31.303]                 args <- list()
[13:17:31.303]                 for (kk in seq_along(NAMES)) {
[13:17:31.303]                   name <- changed[[kk]]
[13:17:31.303]                   NAME <- NAMES[[kk]]
[13:17:31.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.303]                     next
[13:17:31.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.303]                 }
[13:17:31.303]                 NAMES <- toupper(added)
[13:17:31.303]                 for (kk in seq_along(NAMES)) {
[13:17:31.303]                   name <- added[[kk]]
[13:17:31.303]                   NAME <- NAMES[[kk]]
[13:17:31.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.303]                     next
[13:17:31.303]                   args[[name]] <- ""
[13:17:31.303]                 }
[13:17:31.303]                 NAMES <- toupper(removed)
[13:17:31.303]                 for (kk in seq_along(NAMES)) {
[13:17:31.303]                   name <- removed[[kk]]
[13:17:31.303]                   NAME <- NAMES[[kk]]
[13:17:31.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.303]                     next
[13:17:31.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.303]                 }
[13:17:31.303]                 if (length(args) > 0) 
[13:17:31.303]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.303]             }
[13:17:31.303]             else {
[13:17:31.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.303]             }
[13:17:31.303]             {
[13:17:31.303]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.303]                   0L) {
[13:17:31.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.303]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.303]                   base::options(opts)
[13:17:31.303]                 }
[13:17:31.303]                 {
[13:17:31.303]                   {
[13:17:31.303]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.303]                     NULL
[13:17:31.303]                   }
[13:17:31.303]                   options(future.plan = NULL)
[13:17:31.303]                   if (is.na(NA_character_)) 
[13:17:31.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.303]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.303]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.303]                     envir = parent.frame()) 
[13:17:31.303]                   {
[13:17:31.303]                     if (is.function(workers)) 
[13:17:31.303]                       workers <- workers()
[13:17:31.303]                     workers <- structure(as.integer(workers), 
[13:17:31.303]                       class = class(workers))
[13:17:31.303]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.303]                       workers >= 1)
[13:17:31.303]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.303]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.303]                     }
[13:17:31.303]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.303]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.303]                       envir = envir)
[13:17:31.303]                     if (!future$lazy) 
[13:17:31.303]                       future <- run(future)
[13:17:31.303]                     invisible(future)
[13:17:31.303]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.303]                 }
[13:17:31.303]             }
[13:17:31.303]         }
[13:17:31.303]     })
[13:17:31.303]     if (TRUE) {
[13:17:31.303]         base::sink(type = "output", split = FALSE)
[13:17:31.303]         if (TRUE) {
[13:17:31.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.303]         }
[13:17:31.303]         else {
[13:17:31.303]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.303]         }
[13:17:31.303]         base::close(...future.stdout)
[13:17:31.303]         ...future.stdout <- NULL
[13:17:31.303]     }
[13:17:31.303]     ...future.result$conditions <- ...future.conditions
[13:17:31.303]     ...future.result$finished <- base::Sys.time()
[13:17:31.303]     ...future.result
[13:17:31.303] }
[13:17:31.306] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:17:31.306] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:17:31.306] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:17:31.307] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:31.307] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.307] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[13:17:31.307] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[13:17:31.308] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:31.308] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.308] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:31.308] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.308] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:17:31.309] MultisessionFuture started
[13:17:31.309] - Launch lazy future ... done
[13:17:31.309] run() for ‘MultisessionFuture’ ... done
[13:17:31.309] Created future:
[13:17:31.309] MultisessionFuture:
[13:17:31.309] Label: ‘future_by-1’
[13:17:31.309] Expression:
[13:17:31.309] {
[13:17:31.309]     do.call(function(...) {
[13:17:31.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.309]             on.exit(options(oopts), add = TRUE)
[13:17:31.309]         }
[13:17:31.309]         {
[13:17:31.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.309]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.309]             })
[13:17:31.309]         }
[13:17:31.309]     }, args = future.call.arguments)
[13:17:31.309] }
[13:17:31.309] Lazy evaluation: FALSE
[13:17:31.309] Asynchronous evaluation: TRUE
[13:17:31.309] Local evaluation: TRUE
[13:17:31.309] Environment: R_GlobalEnv
[13:17:31.309] Capture standard output: TRUE
[13:17:31.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.309] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.309] Packages: <none>
[13:17:31.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.309] Resolved: FALSE
[13:17:31.309] Value: <not collected>
[13:17:31.309] Conditions captured: <none>
[13:17:31.309] Early signaling: FALSE
[13:17:31.309] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.309] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.321] Chunk #1 of 2 ... DONE
[13:17:31.321] Chunk #2 of 2 ...
[13:17:31.322]  - Finding globals in 'X' for chunk #2 ...
[13:17:31.322] getGlobalsAndPackages() ...
[13:17:31.322] Searching for globals...
[13:17:31.322] 
[13:17:31.322] Searching for globals ... DONE
[13:17:31.322] - globals: [0] <none>
[13:17:31.322] getGlobalsAndPackages() ... DONE
[13:17:31.323]    + additional globals found: [n=0] 
[13:17:31.323]    + additional namespaces needed: [n=0] 
[13:17:31.323]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:31.323]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:31.323]  - seeds: <none>
[13:17:31.323] getGlobalsAndPackages() ...
[13:17:31.323] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.323] Resolving globals: FALSE
[13:17:31.323] Tweak future expression to call with '...' arguments ...
[13:17:31.324] {
[13:17:31.324]     do.call(function(...) {
[13:17:31.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.324]             on.exit(options(oopts), add = TRUE)
[13:17:31.324]         }
[13:17:31.324]         {
[13:17:31.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.324]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.324]             })
[13:17:31.324]         }
[13:17:31.324]     }, args = future.call.arguments)
[13:17:31.324] }
[13:17:31.324] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.324] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.324] 
[13:17:31.324] getGlobalsAndPackages() ... DONE
[13:17:31.325] run() for ‘Future’ ...
[13:17:31.325] - state: ‘created’
[13:17:31.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.341] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.341]   - Field: ‘node’
[13:17:31.341]   - Field: ‘label’
[13:17:31.342]   - Field: ‘local’
[13:17:31.342]   - Field: ‘owner’
[13:17:31.342]   - Field: ‘envir’
[13:17:31.342]   - Field: ‘workers’
[13:17:31.342]   - Field: ‘packages’
[13:17:31.342]   - Field: ‘gc’
[13:17:31.342]   - Field: ‘conditions’
[13:17:31.342]   - Field: ‘persistent’
[13:17:31.342]   - Field: ‘expr’
[13:17:31.342]   - Field: ‘uuid’
[13:17:31.342]   - Field: ‘seed’
[13:17:31.343]   - Field: ‘version’
[13:17:31.343]   - Field: ‘result’
[13:17:31.343]   - Field: ‘asynchronous’
[13:17:31.343]   - Field: ‘calls’
[13:17:31.343]   - Field: ‘globals’
[13:17:31.343]   - Field: ‘stdout’
[13:17:31.343]   - Field: ‘earlySignal’
[13:17:31.343]   - Field: ‘lazy’
[13:17:31.343]   - Field: ‘state’
[13:17:31.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.343] - Launch lazy future ...
[13:17:31.344] Packages needed by the future expression (n = 0): <none>
[13:17:31.344] Packages needed by future strategies (n = 0): <none>
[13:17:31.344] {
[13:17:31.344]     {
[13:17:31.344]         {
[13:17:31.344]             ...future.startTime <- base::Sys.time()
[13:17:31.344]             {
[13:17:31.344]                 {
[13:17:31.344]                   {
[13:17:31.344]                     {
[13:17:31.344]                       base::local({
[13:17:31.344]                         has_future <- base::requireNamespace("future", 
[13:17:31.344]                           quietly = TRUE)
[13:17:31.344]                         if (has_future) {
[13:17:31.344]                           ns <- base::getNamespace("future")
[13:17:31.344]                           version <- ns[[".package"]][["version"]]
[13:17:31.344]                           if (is.null(version)) 
[13:17:31.344]                             version <- utils::packageVersion("future")
[13:17:31.344]                         }
[13:17:31.344]                         else {
[13:17:31.344]                           version <- NULL
[13:17:31.344]                         }
[13:17:31.344]                         if (!has_future || version < "1.8.0") {
[13:17:31.344]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.344]                             "", base::R.version$version.string), 
[13:17:31.344]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:31.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:31.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.344]                               "release", "version")], collapse = " "), 
[13:17:31.344]                             hostname = base::Sys.info()[["nodename"]])
[13:17:31.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.344]                             info)
[13:17:31.344]                           info <- base::paste(info, collapse = "; ")
[13:17:31.344]                           if (!has_future) {
[13:17:31.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.344]                               info)
[13:17:31.344]                           }
[13:17:31.344]                           else {
[13:17:31.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.344]                               info, version)
[13:17:31.344]                           }
[13:17:31.344]                           base::stop(msg)
[13:17:31.344]                         }
[13:17:31.344]                       })
[13:17:31.344]                     }
[13:17:31.344]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.344]                     base::options(mc.cores = 1L)
[13:17:31.344]                   }
[13:17:31.344]                   options(future.plan = NULL)
[13:17:31.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.344]                 }
[13:17:31.344]                 ...future.workdir <- getwd()
[13:17:31.344]             }
[13:17:31.344]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.344]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.344]         }
[13:17:31.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.344]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:31.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.344]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.344]             base::names(...future.oldOptions))
[13:17:31.344]     }
[13:17:31.344]     if (FALSE) {
[13:17:31.344]     }
[13:17:31.344]     else {
[13:17:31.344]         if (TRUE) {
[13:17:31.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.344]                 open = "w")
[13:17:31.344]         }
[13:17:31.344]         else {
[13:17:31.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.344]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.344]         }
[13:17:31.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.344]             base::sink(type = "output", split = FALSE)
[13:17:31.344]             base::close(...future.stdout)
[13:17:31.344]         }, add = TRUE)
[13:17:31.344]     }
[13:17:31.344]     ...future.frame <- base::sys.nframe()
[13:17:31.344]     ...future.conditions <- base::list()
[13:17:31.344]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.344]     if (FALSE) {
[13:17:31.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.344]     }
[13:17:31.344]     ...future.result <- base::tryCatch({
[13:17:31.344]         base::withCallingHandlers({
[13:17:31.344]             ...future.value <- base::withVisible(base::local({
[13:17:31.344]                 ...future.makeSendCondition <- local({
[13:17:31.344]                   sendCondition <- NULL
[13:17:31.344]                   function(frame = 1L) {
[13:17:31.344]                     if (is.function(sendCondition)) 
[13:17:31.344]                       return(sendCondition)
[13:17:31.344]                     ns <- getNamespace("parallel")
[13:17:31.344]                     if (exists("sendData", mode = "function", 
[13:17:31.344]                       envir = ns)) {
[13:17:31.344]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.344]                         envir = ns)
[13:17:31.344]                       envir <- sys.frame(frame)
[13:17:31.344]                       master <- NULL
[13:17:31.344]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.344]                         !identical(envir, emptyenv())) {
[13:17:31.344]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.344]                           inherits = FALSE)) {
[13:17:31.344]                           master <- get("master", mode = "list", 
[13:17:31.344]                             envir = envir, inherits = FALSE)
[13:17:31.344]                           if (inherits(master, c("SOCKnode", 
[13:17:31.344]                             "SOCK0node"))) {
[13:17:31.344]                             sendCondition <<- function(cond) {
[13:17:31.344]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.344]                                 success = TRUE)
[13:17:31.344]                               parallel_sendData(master, data)
[13:17:31.344]                             }
[13:17:31.344]                             return(sendCondition)
[13:17:31.344]                           }
[13:17:31.344]                         }
[13:17:31.344]                         frame <- frame + 1L
[13:17:31.344]                         envir <- sys.frame(frame)
[13:17:31.344]                       }
[13:17:31.344]                     }
[13:17:31.344]                     sendCondition <<- function(cond) NULL
[13:17:31.344]                   }
[13:17:31.344]                 })
[13:17:31.344]                 withCallingHandlers({
[13:17:31.344]                   {
[13:17:31.344]                     do.call(function(...) {
[13:17:31.344]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.344]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.344]                         ...future.globals.maxSize)) {
[13:17:31.344]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.344]                         on.exit(options(oopts), add = TRUE)
[13:17:31.344]                       }
[13:17:31.344]                       {
[13:17:31.344]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.344]                           FUN = function(jj) {
[13:17:31.344]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.344]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.344]                           })
[13:17:31.344]                       }
[13:17:31.344]                     }, args = future.call.arguments)
[13:17:31.344]                   }
[13:17:31.344]                 }, immediateCondition = function(cond) {
[13:17:31.344]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.344]                   sendCondition(cond)
[13:17:31.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.344]                   {
[13:17:31.344]                     inherits <- base::inherits
[13:17:31.344]                     invokeRestart <- base::invokeRestart
[13:17:31.344]                     is.null <- base::is.null
[13:17:31.344]                     muffled <- FALSE
[13:17:31.344]                     if (inherits(cond, "message")) {
[13:17:31.344]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.344]                       if (muffled) 
[13:17:31.344]                         invokeRestart("muffleMessage")
[13:17:31.344]                     }
[13:17:31.344]                     else if (inherits(cond, "warning")) {
[13:17:31.344]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.344]                       if (muffled) 
[13:17:31.344]                         invokeRestart("muffleWarning")
[13:17:31.344]                     }
[13:17:31.344]                     else if (inherits(cond, "condition")) {
[13:17:31.344]                       if (!is.null(pattern)) {
[13:17:31.344]                         computeRestarts <- base::computeRestarts
[13:17:31.344]                         grepl <- base::grepl
[13:17:31.344]                         restarts <- computeRestarts(cond)
[13:17:31.344]                         for (restart in restarts) {
[13:17:31.344]                           name <- restart$name
[13:17:31.344]                           if (is.null(name)) 
[13:17:31.344]                             next
[13:17:31.344]                           if (!grepl(pattern, name)) 
[13:17:31.344]                             next
[13:17:31.344]                           invokeRestart(restart)
[13:17:31.344]                           muffled <- TRUE
[13:17:31.344]                           break
[13:17:31.344]                         }
[13:17:31.344]                       }
[13:17:31.344]                     }
[13:17:31.344]                     invisible(muffled)
[13:17:31.344]                   }
[13:17:31.344]                   muffleCondition(cond)
[13:17:31.344]                 })
[13:17:31.344]             }))
[13:17:31.344]             future::FutureResult(value = ...future.value$value, 
[13:17:31.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.344]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.344]                     ...future.globalenv.names))
[13:17:31.344]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.344]         }, condition = base::local({
[13:17:31.344]             c <- base::c
[13:17:31.344]             inherits <- base::inherits
[13:17:31.344]             invokeRestart <- base::invokeRestart
[13:17:31.344]             length <- base::length
[13:17:31.344]             list <- base::list
[13:17:31.344]             seq.int <- base::seq.int
[13:17:31.344]             signalCondition <- base::signalCondition
[13:17:31.344]             sys.calls <- base::sys.calls
[13:17:31.344]             `[[` <- base::`[[`
[13:17:31.344]             `+` <- base::`+`
[13:17:31.344]             `<<-` <- base::`<<-`
[13:17:31.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.344]                   3L)]
[13:17:31.344]             }
[13:17:31.344]             function(cond) {
[13:17:31.344]                 is_error <- inherits(cond, "error")
[13:17:31.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.344]                   NULL)
[13:17:31.344]                 if (is_error) {
[13:17:31.344]                   sessionInformation <- function() {
[13:17:31.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.344]                       search = base::search(), system = base::Sys.info())
[13:17:31.344]                   }
[13:17:31.344]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.344]                     cond$call), session = sessionInformation(), 
[13:17:31.344]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.344]                   signalCondition(cond)
[13:17:31.344]                 }
[13:17:31.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.344]                 "immediateCondition"))) {
[13:17:31.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.344]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.344]                   if (TRUE && !signal) {
[13:17:31.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.344]                     {
[13:17:31.344]                       inherits <- base::inherits
[13:17:31.344]                       invokeRestart <- base::invokeRestart
[13:17:31.344]                       is.null <- base::is.null
[13:17:31.344]                       muffled <- FALSE
[13:17:31.344]                       if (inherits(cond, "message")) {
[13:17:31.344]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.344]                         if (muffled) 
[13:17:31.344]                           invokeRestart("muffleMessage")
[13:17:31.344]                       }
[13:17:31.344]                       else if (inherits(cond, "warning")) {
[13:17:31.344]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.344]                         if (muffled) 
[13:17:31.344]                           invokeRestart("muffleWarning")
[13:17:31.344]                       }
[13:17:31.344]                       else if (inherits(cond, "condition")) {
[13:17:31.344]                         if (!is.null(pattern)) {
[13:17:31.344]                           computeRestarts <- base::computeRestarts
[13:17:31.344]                           grepl <- base::grepl
[13:17:31.344]                           restarts <- computeRestarts(cond)
[13:17:31.344]                           for (restart in restarts) {
[13:17:31.344]                             name <- restart$name
[13:17:31.344]                             if (is.null(name)) 
[13:17:31.344]                               next
[13:17:31.344]                             if (!grepl(pattern, name)) 
[13:17:31.344]                               next
[13:17:31.344]                             invokeRestart(restart)
[13:17:31.344]                             muffled <- TRUE
[13:17:31.344]                             break
[13:17:31.344]                           }
[13:17:31.344]                         }
[13:17:31.344]                       }
[13:17:31.344]                       invisible(muffled)
[13:17:31.344]                     }
[13:17:31.344]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.344]                   }
[13:17:31.344]                 }
[13:17:31.344]                 else {
[13:17:31.344]                   if (TRUE) {
[13:17:31.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.344]                     {
[13:17:31.344]                       inherits <- base::inherits
[13:17:31.344]                       invokeRestart <- base::invokeRestart
[13:17:31.344]                       is.null <- base::is.null
[13:17:31.344]                       muffled <- FALSE
[13:17:31.344]                       if (inherits(cond, "message")) {
[13:17:31.344]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.344]                         if (muffled) 
[13:17:31.344]                           invokeRestart("muffleMessage")
[13:17:31.344]                       }
[13:17:31.344]                       else if (inherits(cond, "warning")) {
[13:17:31.344]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.344]                         if (muffled) 
[13:17:31.344]                           invokeRestart("muffleWarning")
[13:17:31.344]                       }
[13:17:31.344]                       else if (inherits(cond, "condition")) {
[13:17:31.344]                         if (!is.null(pattern)) {
[13:17:31.344]                           computeRestarts <- base::computeRestarts
[13:17:31.344]                           grepl <- base::grepl
[13:17:31.344]                           restarts <- computeRestarts(cond)
[13:17:31.344]                           for (restart in restarts) {
[13:17:31.344]                             name <- restart$name
[13:17:31.344]                             if (is.null(name)) 
[13:17:31.344]                               next
[13:17:31.344]                             if (!grepl(pattern, name)) 
[13:17:31.344]                               next
[13:17:31.344]                             invokeRestart(restart)
[13:17:31.344]                             muffled <- TRUE
[13:17:31.344]                             break
[13:17:31.344]                           }
[13:17:31.344]                         }
[13:17:31.344]                       }
[13:17:31.344]                       invisible(muffled)
[13:17:31.344]                     }
[13:17:31.344]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.344]                   }
[13:17:31.344]                 }
[13:17:31.344]             }
[13:17:31.344]         }))
[13:17:31.344]     }, error = function(ex) {
[13:17:31.344]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.344]                 ...future.rng), started = ...future.startTime, 
[13:17:31.344]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.344]             version = "1.8"), class = "FutureResult")
[13:17:31.344]     }, finally = {
[13:17:31.344]         if (!identical(...future.workdir, getwd())) 
[13:17:31.344]             setwd(...future.workdir)
[13:17:31.344]         {
[13:17:31.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.344]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.344]             }
[13:17:31.344]             base::options(...future.oldOptions)
[13:17:31.344]             if (.Platform$OS.type == "windows") {
[13:17:31.344]                 old_names <- names(...future.oldEnvVars)
[13:17:31.344]                 envs <- base::Sys.getenv()
[13:17:31.344]                 names <- names(envs)
[13:17:31.344]                 common <- intersect(names, old_names)
[13:17:31.344]                 added <- setdiff(names, old_names)
[13:17:31.344]                 removed <- setdiff(old_names, names)
[13:17:31.344]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.344]                   envs[common]]
[13:17:31.344]                 NAMES <- toupper(changed)
[13:17:31.344]                 args <- list()
[13:17:31.344]                 for (kk in seq_along(NAMES)) {
[13:17:31.344]                   name <- changed[[kk]]
[13:17:31.344]                   NAME <- NAMES[[kk]]
[13:17:31.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.344]                     next
[13:17:31.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.344]                 }
[13:17:31.344]                 NAMES <- toupper(added)
[13:17:31.344]                 for (kk in seq_along(NAMES)) {
[13:17:31.344]                   name <- added[[kk]]
[13:17:31.344]                   NAME <- NAMES[[kk]]
[13:17:31.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.344]                     next
[13:17:31.344]                   args[[name]] <- ""
[13:17:31.344]                 }
[13:17:31.344]                 NAMES <- toupper(removed)
[13:17:31.344]                 for (kk in seq_along(NAMES)) {
[13:17:31.344]                   name <- removed[[kk]]
[13:17:31.344]                   NAME <- NAMES[[kk]]
[13:17:31.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.344]                     next
[13:17:31.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.344]                 }
[13:17:31.344]                 if (length(args) > 0) 
[13:17:31.344]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.344]             }
[13:17:31.344]             else {
[13:17:31.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.344]             }
[13:17:31.344]             {
[13:17:31.344]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.344]                   0L) {
[13:17:31.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.344]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.344]                   base::options(opts)
[13:17:31.344]                 }
[13:17:31.344]                 {
[13:17:31.344]                   {
[13:17:31.344]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.344]                     NULL
[13:17:31.344]                   }
[13:17:31.344]                   options(future.plan = NULL)
[13:17:31.344]                   if (is.na(NA_character_)) 
[13:17:31.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.344]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.344]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.344]                     envir = parent.frame()) 
[13:17:31.344]                   {
[13:17:31.344]                     if (is.function(workers)) 
[13:17:31.344]                       workers <- workers()
[13:17:31.344]                     workers <- structure(as.integer(workers), 
[13:17:31.344]                       class = class(workers))
[13:17:31.344]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.344]                       workers >= 1)
[13:17:31.344]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.344]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.344]                     }
[13:17:31.344]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.344]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.344]                       envir = envir)
[13:17:31.344]                     if (!future$lazy) 
[13:17:31.344]                       future <- run(future)
[13:17:31.344]                     invisible(future)
[13:17:31.344]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.344]                 }
[13:17:31.344]             }
[13:17:31.344]         }
[13:17:31.344]     })
[13:17:31.344]     if (TRUE) {
[13:17:31.344]         base::sink(type = "output", split = FALSE)
[13:17:31.344]         if (TRUE) {
[13:17:31.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.344]         }
[13:17:31.344]         else {
[13:17:31.344]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.344]         }
[13:17:31.344]         base::close(...future.stdout)
[13:17:31.344]         ...future.stdout <- NULL
[13:17:31.344]     }
[13:17:31.344]     ...future.result$conditions <- ...future.conditions
[13:17:31.344]     ...future.result$finished <- base::Sys.time()
[13:17:31.344]     ...future.result
[13:17:31.344] }
[13:17:31.415] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:17:31.416] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:17:31.416] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:17:31.416] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:31.417] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.417] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[13:17:31.417] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[13:17:31.417] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:31.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.418] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:31.418] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.418] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:17:31.419] MultisessionFuture started
[13:17:31.419] - Launch lazy future ... done
[13:17:31.419] run() for ‘MultisessionFuture’ ... done
[13:17:31.419] Created future:
[13:17:31.419] MultisessionFuture:
[13:17:31.419] Label: ‘future_by-2’
[13:17:31.419] Expression:
[13:17:31.419] {
[13:17:31.419]     do.call(function(...) {
[13:17:31.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.419]             on.exit(options(oopts), add = TRUE)
[13:17:31.419]         }
[13:17:31.419]         {
[13:17:31.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.419]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.419]             })
[13:17:31.419]         }
[13:17:31.419]     }, args = future.call.arguments)
[13:17:31.419] }
[13:17:31.419] Lazy evaluation: FALSE
[13:17:31.419] Asynchronous evaluation: TRUE
[13:17:31.419] Local evaluation: TRUE
[13:17:31.419] Environment: R_GlobalEnv
[13:17:31.419] Capture standard output: TRUE
[13:17:31.419] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.419] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.419] Packages: <none>
[13:17:31.419] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.419] Resolved: FALSE
[13:17:31.419] Value: <not collected>
[13:17:31.419] Conditions captured: <none>
[13:17:31.419] Early signaling: FALSE
[13:17:31.419] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.419] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.431] Chunk #2 of 2 ... DONE
[13:17:31.431] Launching 2 futures (chunks) ... DONE
[13:17:31.432] Resolving 2 futures (chunks) ...
[13:17:31.432] resolve() on list ...
[13:17:31.432]  recursive: 0
[13:17:31.432]  length: 2
[13:17:31.432] 
[13:17:31.433] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.433] - Validating connection of MultisessionFuture
[13:17:31.433] - received message: FutureResult
[13:17:31.433] - Received FutureResult
[13:17:31.433] - Erased future from FutureRegistry
[13:17:31.433] result() for ClusterFuture ...
[13:17:31.433] - result already collected: FutureResult
[13:17:31.433] result() for ClusterFuture ... done
[13:17:31.434] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.434] Future #1
[13:17:31.434] result() for ClusterFuture ...
[13:17:31.434] - result already collected: FutureResult
[13:17:31.434] result() for ClusterFuture ... done
[13:17:31.434] result() for ClusterFuture ...
[13:17:31.434] - result already collected: FutureResult
[13:17:31.434] result() for ClusterFuture ... done
[13:17:31.434] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:31.434] - nx: 2
[13:17:31.435] - relay: TRUE
[13:17:31.435] - stdout: TRUE
[13:17:31.435] - signal: TRUE
[13:17:31.435] - resignal: FALSE
[13:17:31.435] - force: TRUE
[13:17:31.435] - relayed: [n=2] FALSE, FALSE
[13:17:31.435] - queued futures: [n=2] FALSE, FALSE
[13:17:31.435]  - until=1
[13:17:31.438]  - relaying element #1
[13:17:31.438] result() for ClusterFuture ...
[13:17:31.438] - result already collected: FutureResult
[13:17:31.438] result() for ClusterFuture ... done
[13:17:31.438] result() for ClusterFuture ...
[13:17:31.438] - result already collected: FutureResult
[13:17:31.438] result() for ClusterFuture ... done
[13:17:31.438] result() for ClusterFuture ...
[13:17:31.438] - result already collected: FutureResult
[13:17:31.438] result() for ClusterFuture ... done
[13:17:31.438] result() for ClusterFuture ...
[13:17:31.439] - result already collected: FutureResult
[13:17:31.439] result() for ClusterFuture ... done
[13:17:31.439] - relayed: [n=2] TRUE, FALSE
[13:17:31.439] - queued futures: [n=2] TRUE, FALSE
[13:17:31.439] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:31.439]  length: 1 (resolved future 1)
[13:17:31.501] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.502] - Validating connection of MultisessionFuture
[13:17:31.502] - received message: FutureResult
[13:17:31.502] - Received FutureResult
[13:17:31.502] - Erased future from FutureRegistry
[13:17:31.502] result() for ClusterFuture ...
[13:17:31.502] - result already collected: FutureResult
[13:17:31.502] result() for ClusterFuture ... done
[13:17:31.502] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.502] Future #2
[13:17:31.503] result() for ClusterFuture ...
[13:17:31.503] - result already collected: FutureResult
[13:17:31.503] result() for ClusterFuture ... done
[13:17:31.503] result() for ClusterFuture ...
[13:17:31.503] - result already collected: FutureResult
[13:17:31.503] result() for ClusterFuture ... done
[13:17:31.503] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:31.503] - nx: 2
[13:17:31.503] - relay: TRUE
[13:17:31.503] - stdout: TRUE
[13:17:31.503] - signal: TRUE
[13:17:31.503] - resignal: FALSE
[13:17:31.504] - force: TRUE
[13:17:31.504] - relayed: [n=2] TRUE, FALSE
[13:17:31.504] - queued futures: [n=2] TRUE, FALSE
[13:17:31.504]  - until=2
[13:17:31.504]  - relaying element #2
[13:17:31.504] result() for ClusterFuture ...
[13:17:31.504] - result already collected: FutureResult
[13:17:31.504] result() for ClusterFuture ... done
[13:17:31.504] result() for ClusterFuture ...
[13:17:31.504] - result already collected: FutureResult
[13:17:31.504] result() for ClusterFuture ... done
[13:17:31.505] result() for ClusterFuture ...
[13:17:31.505] - result already collected: FutureResult
[13:17:31.505] result() for ClusterFuture ... done
[13:17:31.505] result() for ClusterFuture ...
[13:17:31.505] - result already collected: FutureResult
[13:17:31.505] result() for ClusterFuture ... done
[13:17:31.505] - relayed: [n=2] TRUE, TRUE
[13:17:31.505] - queued futures: [n=2] TRUE, TRUE
[13:17:31.505] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:31.505]  length: 0 (resolved future 2)
[13:17:31.505] Relaying remaining futures
[13:17:31.506] signalConditionsASAP(NULL, pos=0) ...
[13:17:31.506] - nx: 2
[13:17:31.506] - relay: TRUE
[13:17:31.506] - stdout: TRUE
[13:17:31.506] - signal: TRUE
[13:17:31.506] - resignal: FALSE
[13:17:31.506] - force: TRUE
[13:17:31.506] - relayed: [n=2] TRUE, TRUE
[13:17:31.506] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:31.506] - relayed: [n=2] TRUE, TRUE
[13:17:31.506] - queued futures: [n=2] TRUE, TRUE
[13:17:31.506] signalConditionsASAP(NULL, pos=0) ... done
[13:17:31.507] resolve() on list ... DONE
[13:17:31.507] result() for ClusterFuture ...
[13:17:31.507] - result already collected: FutureResult
[13:17:31.507] result() for ClusterFuture ... done
[13:17:31.507] result() for ClusterFuture ...
[13:17:31.507] - result already collected: FutureResult
[13:17:31.507] result() for ClusterFuture ... done
[13:17:31.507] result() for ClusterFuture ...
[13:17:31.507] - result already collected: FutureResult
[13:17:31.507] result() for ClusterFuture ... done
[13:17:31.507] result() for ClusterFuture ...
[13:17:31.508] - result already collected: FutureResult
[13:17:31.508] result() for ClusterFuture ... done
[13:17:31.508]  - Number of value chunks collected: 2
[13:17:31.508] Resolving 2 futures (chunks) ... DONE
[13:17:31.508] Reducing values from 2 chunks ...
[13:17:31.508]  - Number of values collected after concatenation: 3
[13:17:31.508]  - Number of values expected: 3
[13:17:31.508] Reducing values from 2 chunks ... DONE
[13:17:31.508] future_lapply() ... DONE
[13:17:31.508] future_by_internal() ... DONE
[13:17:31.509] future_by_internal() ...
[13:17:31.509] future_lapply() ...
[13:17:31.513] Number of chunks: 2
[13:17:31.513] getGlobalsAndPackagesXApply() ...
[13:17:31.513]  - future.globals: TRUE
[13:17:31.513] getGlobalsAndPackages() ...
[13:17:31.513] Searching for globals...
[13:17:31.514] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:31.514] Searching for globals ... DONE
[13:17:31.515] Resolving globals: FALSE
[13:17:31.515] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:31.515] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:31.515] - globals: [1] ‘FUN’
[13:17:31.515] 
[13:17:31.515] getGlobalsAndPackages() ... DONE
[13:17:31.516]  - globals found/used: [n=1] ‘FUN’
[13:17:31.516]  - needed namespaces: [n=0] 
[13:17:31.516] Finding globals ... DONE
[13:17:31.516]  - use_args: TRUE
[13:17:31.516]  - Getting '...' globals ...
[13:17:31.516] resolve() on list ...
[13:17:31.516]  recursive: 0
[13:17:31.516]  length: 1
[13:17:31.517]  elements: ‘...’
[13:17:31.517]  length: 0 (resolved future 1)
[13:17:31.517] resolve() on list ... DONE
[13:17:31.517]    - '...' content: [n=1] ‘digits’
[13:17:31.517] List of 1
[13:17:31.517]  $ ...:List of 1
[13:17:31.517]   ..$ digits: int 2
[13:17:31.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.517]  - attr(*, "where")=List of 1
[13:17:31.517]   ..$ ...:<environment: 0x5609ec7a67e8> 
[13:17:31.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.517]  - attr(*, "resolved")= logi TRUE
[13:17:31.517]  - attr(*, "total_size")= num NA
[13:17:31.520]  - Getting '...' globals ... DONE
[13:17:31.520] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:31.520] List of 2
[13:17:31.520]  $ ...future.FUN:function (object, ...)  
[13:17:31.520]  $ ...          :List of 1
[13:17:31.520]   ..$ digits: int 2
[13:17:31.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.520]  - attr(*, "where")=List of 2
[13:17:31.520]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:31.520]   ..$ ...          :<environment: 0x5609ec7a67e8> 
[13:17:31.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.520]  - attr(*, "resolved")= logi FALSE
[13:17:31.520]  - attr(*, "total_size")= num 1296
[13:17:31.523] Packages to be attached in all futures: [n=0] 
[13:17:31.523] getGlobalsAndPackagesXApply() ... DONE
[13:17:31.523] Number of futures (= number of chunks): 2
[13:17:31.524] Launching 2 futures (chunks) ...
[13:17:31.524] Chunk #1 of 2 ...
[13:17:31.524]  - Finding globals in 'X' for chunk #1 ...
[13:17:31.524] getGlobalsAndPackages() ...
[13:17:31.524] Searching for globals...
[13:17:31.524] 
[13:17:31.524] Searching for globals ... DONE
[13:17:31.524] - globals: [0] <none>
[13:17:31.524] getGlobalsAndPackages() ... DONE
[13:17:31.525]    + additional globals found: [n=0] 
[13:17:31.525]    + additional namespaces needed: [n=0] 
[13:17:31.525]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:31.525]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:31.525]  - seeds: <none>
[13:17:31.525] getGlobalsAndPackages() ...
[13:17:31.525] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.525] Resolving globals: FALSE
[13:17:31.525] Tweak future expression to call with '...' arguments ...
[13:17:31.525] {
[13:17:31.525]     do.call(function(...) {
[13:17:31.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.525]             on.exit(options(oopts), add = TRUE)
[13:17:31.525]         }
[13:17:31.525]         {
[13:17:31.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.525]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.525]             })
[13:17:31.525]         }
[13:17:31.525]     }, args = future.call.arguments)
[13:17:31.525] }
[13:17:31.526] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.526] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.526] 
[13:17:31.526] getGlobalsAndPackages() ... DONE
[13:17:31.526] run() for ‘Future’ ...
[13:17:31.527] - state: ‘created’
[13:17:31.527] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.541] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.541]   - Field: ‘node’
[13:17:31.541]   - Field: ‘label’
[13:17:31.541]   - Field: ‘local’
[13:17:31.541]   - Field: ‘owner’
[13:17:31.541]   - Field: ‘envir’
[13:17:31.541]   - Field: ‘workers’
[13:17:31.542]   - Field: ‘packages’
[13:17:31.542]   - Field: ‘gc’
[13:17:31.542]   - Field: ‘conditions’
[13:17:31.542]   - Field: ‘persistent’
[13:17:31.542]   - Field: ‘expr’
[13:17:31.542]   - Field: ‘uuid’
[13:17:31.542]   - Field: ‘seed’
[13:17:31.542]   - Field: ‘version’
[13:17:31.542]   - Field: ‘result’
[13:17:31.542]   - Field: ‘asynchronous’
[13:17:31.542]   - Field: ‘calls’
[13:17:31.542]   - Field: ‘globals’
[13:17:31.543]   - Field: ‘stdout’
[13:17:31.543]   - Field: ‘earlySignal’
[13:17:31.543]   - Field: ‘lazy’
[13:17:31.543]   - Field: ‘state’
[13:17:31.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.543] - Launch lazy future ...
[13:17:31.543] Packages needed by the future expression (n = 0): <none>
[13:17:31.543] Packages needed by future strategies (n = 0): <none>
[13:17:31.544] {
[13:17:31.544]     {
[13:17:31.544]         {
[13:17:31.544]             ...future.startTime <- base::Sys.time()
[13:17:31.544]             {
[13:17:31.544]                 {
[13:17:31.544]                   {
[13:17:31.544]                     {
[13:17:31.544]                       base::local({
[13:17:31.544]                         has_future <- base::requireNamespace("future", 
[13:17:31.544]                           quietly = TRUE)
[13:17:31.544]                         if (has_future) {
[13:17:31.544]                           ns <- base::getNamespace("future")
[13:17:31.544]                           version <- ns[[".package"]][["version"]]
[13:17:31.544]                           if (is.null(version)) 
[13:17:31.544]                             version <- utils::packageVersion("future")
[13:17:31.544]                         }
[13:17:31.544]                         else {
[13:17:31.544]                           version <- NULL
[13:17:31.544]                         }
[13:17:31.544]                         if (!has_future || version < "1.8.0") {
[13:17:31.544]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.544]                             "", base::R.version$version.string), 
[13:17:31.544]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:31.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:31.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.544]                               "release", "version")], collapse = " "), 
[13:17:31.544]                             hostname = base::Sys.info()[["nodename"]])
[13:17:31.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.544]                             info)
[13:17:31.544]                           info <- base::paste(info, collapse = "; ")
[13:17:31.544]                           if (!has_future) {
[13:17:31.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.544]                               info)
[13:17:31.544]                           }
[13:17:31.544]                           else {
[13:17:31.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.544]                               info, version)
[13:17:31.544]                           }
[13:17:31.544]                           base::stop(msg)
[13:17:31.544]                         }
[13:17:31.544]                       })
[13:17:31.544]                     }
[13:17:31.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.544]                     base::options(mc.cores = 1L)
[13:17:31.544]                   }
[13:17:31.544]                   options(future.plan = NULL)
[13:17:31.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.544]                 }
[13:17:31.544]                 ...future.workdir <- getwd()
[13:17:31.544]             }
[13:17:31.544]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.544]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.544]         }
[13:17:31.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.544]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:31.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.544]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.544]             base::names(...future.oldOptions))
[13:17:31.544]     }
[13:17:31.544]     if (FALSE) {
[13:17:31.544]     }
[13:17:31.544]     else {
[13:17:31.544]         if (TRUE) {
[13:17:31.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.544]                 open = "w")
[13:17:31.544]         }
[13:17:31.544]         else {
[13:17:31.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.544]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.544]         }
[13:17:31.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.544]             base::sink(type = "output", split = FALSE)
[13:17:31.544]             base::close(...future.stdout)
[13:17:31.544]         }, add = TRUE)
[13:17:31.544]     }
[13:17:31.544]     ...future.frame <- base::sys.nframe()
[13:17:31.544]     ...future.conditions <- base::list()
[13:17:31.544]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.544]     if (FALSE) {
[13:17:31.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.544]     }
[13:17:31.544]     ...future.result <- base::tryCatch({
[13:17:31.544]         base::withCallingHandlers({
[13:17:31.544]             ...future.value <- base::withVisible(base::local({
[13:17:31.544]                 ...future.makeSendCondition <- local({
[13:17:31.544]                   sendCondition <- NULL
[13:17:31.544]                   function(frame = 1L) {
[13:17:31.544]                     if (is.function(sendCondition)) 
[13:17:31.544]                       return(sendCondition)
[13:17:31.544]                     ns <- getNamespace("parallel")
[13:17:31.544]                     if (exists("sendData", mode = "function", 
[13:17:31.544]                       envir = ns)) {
[13:17:31.544]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.544]                         envir = ns)
[13:17:31.544]                       envir <- sys.frame(frame)
[13:17:31.544]                       master <- NULL
[13:17:31.544]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.544]                         !identical(envir, emptyenv())) {
[13:17:31.544]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.544]                           inherits = FALSE)) {
[13:17:31.544]                           master <- get("master", mode = "list", 
[13:17:31.544]                             envir = envir, inherits = FALSE)
[13:17:31.544]                           if (inherits(master, c("SOCKnode", 
[13:17:31.544]                             "SOCK0node"))) {
[13:17:31.544]                             sendCondition <<- function(cond) {
[13:17:31.544]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.544]                                 success = TRUE)
[13:17:31.544]                               parallel_sendData(master, data)
[13:17:31.544]                             }
[13:17:31.544]                             return(sendCondition)
[13:17:31.544]                           }
[13:17:31.544]                         }
[13:17:31.544]                         frame <- frame + 1L
[13:17:31.544]                         envir <- sys.frame(frame)
[13:17:31.544]                       }
[13:17:31.544]                     }
[13:17:31.544]                     sendCondition <<- function(cond) NULL
[13:17:31.544]                   }
[13:17:31.544]                 })
[13:17:31.544]                 withCallingHandlers({
[13:17:31.544]                   {
[13:17:31.544]                     do.call(function(...) {
[13:17:31.544]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.544]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.544]                         ...future.globals.maxSize)) {
[13:17:31.544]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.544]                         on.exit(options(oopts), add = TRUE)
[13:17:31.544]                       }
[13:17:31.544]                       {
[13:17:31.544]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.544]                           FUN = function(jj) {
[13:17:31.544]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.544]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.544]                           })
[13:17:31.544]                       }
[13:17:31.544]                     }, args = future.call.arguments)
[13:17:31.544]                   }
[13:17:31.544]                 }, immediateCondition = function(cond) {
[13:17:31.544]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.544]                   sendCondition(cond)
[13:17:31.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.544]                   {
[13:17:31.544]                     inherits <- base::inherits
[13:17:31.544]                     invokeRestart <- base::invokeRestart
[13:17:31.544]                     is.null <- base::is.null
[13:17:31.544]                     muffled <- FALSE
[13:17:31.544]                     if (inherits(cond, "message")) {
[13:17:31.544]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.544]                       if (muffled) 
[13:17:31.544]                         invokeRestart("muffleMessage")
[13:17:31.544]                     }
[13:17:31.544]                     else if (inherits(cond, "warning")) {
[13:17:31.544]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.544]                       if (muffled) 
[13:17:31.544]                         invokeRestart("muffleWarning")
[13:17:31.544]                     }
[13:17:31.544]                     else if (inherits(cond, "condition")) {
[13:17:31.544]                       if (!is.null(pattern)) {
[13:17:31.544]                         computeRestarts <- base::computeRestarts
[13:17:31.544]                         grepl <- base::grepl
[13:17:31.544]                         restarts <- computeRestarts(cond)
[13:17:31.544]                         for (restart in restarts) {
[13:17:31.544]                           name <- restart$name
[13:17:31.544]                           if (is.null(name)) 
[13:17:31.544]                             next
[13:17:31.544]                           if (!grepl(pattern, name)) 
[13:17:31.544]                             next
[13:17:31.544]                           invokeRestart(restart)
[13:17:31.544]                           muffled <- TRUE
[13:17:31.544]                           break
[13:17:31.544]                         }
[13:17:31.544]                       }
[13:17:31.544]                     }
[13:17:31.544]                     invisible(muffled)
[13:17:31.544]                   }
[13:17:31.544]                   muffleCondition(cond)
[13:17:31.544]                 })
[13:17:31.544]             }))
[13:17:31.544]             future::FutureResult(value = ...future.value$value, 
[13:17:31.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.544]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.544]                     ...future.globalenv.names))
[13:17:31.544]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.544]         }, condition = base::local({
[13:17:31.544]             c <- base::c
[13:17:31.544]             inherits <- base::inherits
[13:17:31.544]             invokeRestart <- base::invokeRestart
[13:17:31.544]             length <- base::length
[13:17:31.544]             list <- base::list
[13:17:31.544]             seq.int <- base::seq.int
[13:17:31.544]             signalCondition <- base::signalCondition
[13:17:31.544]             sys.calls <- base::sys.calls
[13:17:31.544]             `[[` <- base::`[[`
[13:17:31.544]             `+` <- base::`+`
[13:17:31.544]             `<<-` <- base::`<<-`
[13:17:31.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.544]                   3L)]
[13:17:31.544]             }
[13:17:31.544]             function(cond) {
[13:17:31.544]                 is_error <- inherits(cond, "error")
[13:17:31.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.544]                   NULL)
[13:17:31.544]                 if (is_error) {
[13:17:31.544]                   sessionInformation <- function() {
[13:17:31.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.544]                       search = base::search(), system = base::Sys.info())
[13:17:31.544]                   }
[13:17:31.544]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.544]                     cond$call), session = sessionInformation(), 
[13:17:31.544]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.544]                   signalCondition(cond)
[13:17:31.544]                 }
[13:17:31.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.544]                 "immediateCondition"))) {
[13:17:31.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.544]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.544]                   if (TRUE && !signal) {
[13:17:31.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.544]                     {
[13:17:31.544]                       inherits <- base::inherits
[13:17:31.544]                       invokeRestart <- base::invokeRestart
[13:17:31.544]                       is.null <- base::is.null
[13:17:31.544]                       muffled <- FALSE
[13:17:31.544]                       if (inherits(cond, "message")) {
[13:17:31.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.544]                         if (muffled) 
[13:17:31.544]                           invokeRestart("muffleMessage")
[13:17:31.544]                       }
[13:17:31.544]                       else if (inherits(cond, "warning")) {
[13:17:31.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.544]                         if (muffled) 
[13:17:31.544]                           invokeRestart("muffleWarning")
[13:17:31.544]                       }
[13:17:31.544]                       else if (inherits(cond, "condition")) {
[13:17:31.544]                         if (!is.null(pattern)) {
[13:17:31.544]                           computeRestarts <- base::computeRestarts
[13:17:31.544]                           grepl <- base::grepl
[13:17:31.544]                           restarts <- computeRestarts(cond)
[13:17:31.544]                           for (restart in restarts) {
[13:17:31.544]                             name <- restart$name
[13:17:31.544]                             if (is.null(name)) 
[13:17:31.544]                               next
[13:17:31.544]                             if (!grepl(pattern, name)) 
[13:17:31.544]                               next
[13:17:31.544]                             invokeRestart(restart)
[13:17:31.544]                             muffled <- TRUE
[13:17:31.544]                             break
[13:17:31.544]                           }
[13:17:31.544]                         }
[13:17:31.544]                       }
[13:17:31.544]                       invisible(muffled)
[13:17:31.544]                     }
[13:17:31.544]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.544]                   }
[13:17:31.544]                 }
[13:17:31.544]                 else {
[13:17:31.544]                   if (TRUE) {
[13:17:31.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.544]                     {
[13:17:31.544]                       inherits <- base::inherits
[13:17:31.544]                       invokeRestart <- base::invokeRestart
[13:17:31.544]                       is.null <- base::is.null
[13:17:31.544]                       muffled <- FALSE
[13:17:31.544]                       if (inherits(cond, "message")) {
[13:17:31.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.544]                         if (muffled) 
[13:17:31.544]                           invokeRestart("muffleMessage")
[13:17:31.544]                       }
[13:17:31.544]                       else if (inherits(cond, "warning")) {
[13:17:31.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.544]                         if (muffled) 
[13:17:31.544]                           invokeRestart("muffleWarning")
[13:17:31.544]                       }
[13:17:31.544]                       else if (inherits(cond, "condition")) {
[13:17:31.544]                         if (!is.null(pattern)) {
[13:17:31.544]                           computeRestarts <- base::computeRestarts
[13:17:31.544]                           grepl <- base::grepl
[13:17:31.544]                           restarts <- computeRestarts(cond)
[13:17:31.544]                           for (restart in restarts) {
[13:17:31.544]                             name <- restart$name
[13:17:31.544]                             if (is.null(name)) 
[13:17:31.544]                               next
[13:17:31.544]                             if (!grepl(pattern, name)) 
[13:17:31.544]                               next
[13:17:31.544]                             invokeRestart(restart)
[13:17:31.544]                             muffled <- TRUE
[13:17:31.544]                             break
[13:17:31.544]                           }
[13:17:31.544]                         }
[13:17:31.544]                       }
[13:17:31.544]                       invisible(muffled)
[13:17:31.544]                     }
[13:17:31.544]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.544]                   }
[13:17:31.544]                 }
[13:17:31.544]             }
[13:17:31.544]         }))
[13:17:31.544]     }, error = function(ex) {
[13:17:31.544]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.544]                 ...future.rng), started = ...future.startTime, 
[13:17:31.544]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.544]             version = "1.8"), class = "FutureResult")
[13:17:31.544]     }, finally = {
[13:17:31.544]         if (!identical(...future.workdir, getwd())) 
[13:17:31.544]             setwd(...future.workdir)
[13:17:31.544]         {
[13:17:31.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.544]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.544]             }
[13:17:31.544]             base::options(...future.oldOptions)
[13:17:31.544]             if (.Platform$OS.type == "windows") {
[13:17:31.544]                 old_names <- names(...future.oldEnvVars)
[13:17:31.544]                 envs <- base::Sys.getenv()
[13:17:31.544]                 names <- names(envs)
[13:17:31.544]                 common <- intersect(names, old_names)
[13:17:31.544]                 added <- setdiff(names, old_names)
[13:17:31.544]                 removed <- setdiff(old_names, names)
[13:17:31.544]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.544]                   envs[common]]
[13:17:31.544]                 NAMES <- toupper(changed)
[13:17:31.544]                 args <- list()
[13:17:31.544]                 for (kk in seq_along(NAMES)) {
[13:17:31.544]                   name <- changed[[kk]]
[13:17:31.544]                   NAME <- NAMES[[kk]]
[13:17:31.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.544]                     next
[13:17:31.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.544]                 }
[13:17:31.544]                 NAMES <- toupper(added)
[13:17:31.544]                 for (kk in seq_along(NAMES)) {
[13:17:31.544]                   name <- added[[kk]]
[13:17:31.544]                   NAME <- NAMES[[kk]]
[13:17:31.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.544]                     next
[13:17:31.544]                   args[[name]] <- ""
[13:17:31.544]                 }
[13:17:31.544]                 NAMES <- toupper(removed)
[13:17:31.544]                 for (kk in seq_along(NAMES)) {
[13:17:31.544]                   name <- removed[[kk]]
[13:17:31.544]                   NAME <- NAMES[[kk]]
[13:17:31.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.544]                     next
[13:17:31.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.544]                 }
[13:17:31.544]                 if (length(args) > 0) 
[13:17:31.544]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.544]             }
[13:17:31.544]             else {
[13:17:31.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.544]             }
[13:17:31.544]             {
[13:17:31.544]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.544]                   0L) {
[13:17:31.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.544]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.544]                   base::options(opts)
[13:17:31.544]                 }
[13:17:31.544]                 {
[13:17:31.544]                   {
[13:17:31.544]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.544]                     NULL
[13:17:31.544]                   }
[13:17:31.544]                   options(future.plan = NULL)
[13:17:31.544]                   if (is.na(NA_character_)) 
[13:17:31.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.544]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.544]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.544]                     envir = parent.frame()) 
[13:17:31.544]                   {
[13:17:31.544]                     if (is.function(workers)) 
[13:17:31.544]                       workers <- workers()
[13:17:31.544]                     workers <- structure(as.integer(workers), 
[13:17:31.544]                       class = class(workers))
[13:17:31.544]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.544]                       workers >= 1)
[13:17:31.544]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.544]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.544]                     }
[13:17:31.544]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.544]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.544]                       envir = envir)
[13:17:31.544]                     if (!future$lazy) 
[13:17:31.544]                       future <- run(future)
[13:17:31.544]                     invisible(future)
[13:17:31.544]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.544]                 }
[13:17:31.544]             }
[13:17:31.544]         }
[13:17:31.544]     })
[13:17:31.544]     if (TRUE) {
[13:17:31.544]         base::sink(type = "output", split = FALSE)
[13:17:31.544]         if (TRUE) {
[13:17:31.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.544]         }
[13:17:31.544]         else {
[13:17:31.544]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.544]         }
[13:17:31.544]         base::close(...future.stdout)
[13:17:31.544]         ...future.stdout <- NULL
[13:17:31.544]     }
[13:17:31.544]     ...future.result$conditions <- ...future.conditions
[13:17:31.544]     ...future.result$finished <- base::Sys.time()
[13:17:31.544]     ...future.result
[13:17:31.544] }
[13:17:31.547] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[13:17:31.547] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:17:31.547] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:17:31.547] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:17:31.548] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:17:31.548] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[13:17:31.548] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[13:17:31.548] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:31.549] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.549] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:31.549] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.549] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[13:17:31.550] MultisessionFuture started
[13:17:31.550] - Launch lazy future ... done
[13:17:31.550] run() for ‘MultisessionFuture’ ... done
[13:17:31.551] Created future:
[13:17:31.551] MultisessionFuture:
[13:17:31.551] Label: ‘future_by-1’
[13:17:31.551] Expression:
[13:17:31.551] {
[13:17:31.551]     do.call(function(...) {
[13:17:31.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.551]             on.exit(options(oopts), add = TRUE)
[13:17:31.551]         }
[13:17:31.551]         {
[13:17:31.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.551]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.551]             })
[13:17:31.551]         }
[13:17:31.551]     }, args = future.call.arguments)
[13:17:31.551] }
[13:17:31.551] Lazy evaluation: FALSE
[13:17:31.551] Asynchronous evaluation: TRUE
[13:17:31.551] Local evaluation: TRUE
[13:17:31.551] Environment: R_GlobalEnv
[13:17:31.551] Capture standard output: TRUE
[13:17:31.551] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.551] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.551] Packages: <none>
[13:17:31.551] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.551] Resolved: FALSE
[13:17:31.551] Value: <not collected>
[13:17:31.551] Conditions captured: <none>
[13:17:31.551] Early signaling: FALSE
[13:17:31.551] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.551] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.562] Chunk #1 of 2 ... DONE
[13:17:31.562] Chunk #2 of 2 ...
[13:17:31.562]  - Finding globals in 'X' for chunk #2 ...
[13:17:31.562] getGlobalsAndPackages() ...
[13:17:31.562] Searching for globals...
[13:17:31.563] 
[13:17:31.563] Searching for globals ... DONE
[13:17:31.563] - globals: [0] <none>
[13:17:31.563] getGlobalsAndPackages() ... DONE
[13:17:31.563]    + additional globals found: [n=0] 
[13:17:31.563]    + additional namespaces needed: [n=0] 
[13:17:31.563]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:31.563]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:31.564]  - seeds: <none>
[13:17:31.564] getGlobalsAndPackages() ...
[13:17:31.564] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.564] Resolving globals: FALSE
[13:17:31.564] Tweak future expression to call with '...' arguments ...
[13:17:31.564] {
[13:17:31.564]     do.call(function(...) {
[13:17:31.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.564]             on.exit(options(oopts), add = TRUE)
[13:17:31.564]         }
[13:17:31.564]         {
[13:17:31.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.564]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.564]             })
[13:17:31.564]         }
[13:17:31.564]     }, args = future.call.arguments)
[13:17:31.564] }
[13:17:31.564] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.565] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.565] 
[13:17:31.565] getGlobalsAndPackages() ... DONE
[13:17:31.565] run() for ‘Future’ ...
[13:17:31.565] - state: ‘created’
[13:17:31.565] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.579] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.580]   - Field: ‘node’
[13:17:31.580]   - Field: ‘label’
[13:17:31.580]   - Field: ‘local’
[13:17:31.580]   - Field: ‘owner’
[13:17:31.580]   - Field: ‘envir’
[13:17:31.580]   - Field: ‘workers’
[13:17:31.580]   - Field: ‘packages’
[13:17:31.580]   - Field: ‘gc’
[13:17:31.581]   - Field: ‘conditions’
[13:17:31.581]   - Field: ‘persistent’
[13:17:31.581]   - Field: ‘expr’
[13:17:31.581]   - Field: ‘uuid’
[13:17:31.581]   - Field: ‘seed’
[13:17:31.581]   - Field: ‘version’
[13:17:31.581]   - Field: ‘result’
[13:17:31.581]   - Field: ‘asynchronous’
[13:17:31.581]   - Field: ‘calls’
[13:17:31.581]   - Field: ‘globals’
[13:17:31.581]   - Field: ‘stdout’
[13:17:31.582]   - Field: ‘earlySignal’
[13:17:31.582]   - Field: ‘lazy’
[13:17:31.582]   - Field: ‘state’
[13:17:31.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.582] - Launch lazy future ...
[13:17:31.582] Packages needed by the future expression (n = 0): <none>
[13:17:31.582] Packages needed by future strategies (n = 0): <none>
[13:17:31.583] {
[13:17:31.583]     {
[13:17:31.583]         {
[13:17:31.583]             ...future.startTime <- base::Sys.time()
[13:17:31.583]             {
[13:17:31.583]                 {
[13:17:31.583]                   {
[13:17:31.583]                     {
[13:17:31.583]                       base::local({
[13:17:31.583]                         has_future <- base::requireNamespace("future", 
[13:17:31.583]                           quietly = TRUE)
[13:17:31.583]                         if (has_future) {
[13:17:31.583]                           ns <- base::getNamespace("future")
[13:17:31.583]                           version <- ns[[".package"]][["version"]]
[13:17:31.583]                           if (is.null(version)) 
[13:17:31.583]                             version <- utils::packageVersion("future")
[13:17:31.583]                         }
[13:17:31.583]                         else {
[13:17:31.583]                           version <- NULL
[13:17:31.583]                         }
[13:17:31.583]                         if (!has_future || version < "1.8.0") {
[13:17:31.583]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.583]                             "", base::R.version$version.string), 
[13:17:31.583]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:31.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:31.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.583]                               "release", "version")], collapse = " "), 
[13:17:31.583]                             hostname = base::Sys.info()[["nodename"]])
[13:17:31.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.583]                             info)
[13:17:31.583]                           info <- base::paste(info, collapse = "; ")
[13:17:31.583]                           if (!has_future) {
[13:17:31.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.583]                               info)
[13:17:31.583]                           }
[13:17:31.583]                           else {
[13:17:31.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.583]                               info, version)
[13:17:31.583]                           }
[13:17:31.583]                           base::stop(msg)
[13:17:31.583]                         }
[13:17:31.583]                       })
[13:17:31.583]                     }
[13:17:31.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.583]                     base::options(mc.cores = 1L)
[13:17:31.583]                   }
[13:17:31.583]                   options(future.plan = NULL)
[13:17:31.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.583]                 }
[13:17:31.583]                 ...future.workdir <- getwd()
[13:17:31.583]             }
[13:17:31.583]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.583]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.583]         }
[13:17:31.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.583]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:31.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.583]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.583]             base::names(...future.oldOptions))
[13:17:31.583]     }
[13:17:31.583]     if (FALSE) {
[13:17:31.583]     }
[13:17:31.583]     else {
[13:17:31.583]         if (TRUE) {
[13:17:31.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.583]                 open = "w")
[13:17:31.583]         }
[13:17:31.583]         else {
[13:17:31.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.583]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.583]         }
[13:17:31.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.583]             base::sink(type = "output", split = FALSE)
[13:17:31.583]             base::close(...future.stdout)
[13:17:31.583]         }, add = TRUE)
[13:17:31.583]     }
[13:17:31.583]     ...future.frame <- base::sys.nframe()
[13:17:31.583]     ...future.conditions <- base::list()
[13:17:31.583]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.583]     if (FALSE) {
[13:17:31.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.583]     }
[13:17:31.583]     ...future.result <- base::tryCatch({
[13:17:31.583]         base::withCallingHandlers({
[13:17:31.583]             ...future.value <- base::withVisible(base::local({
[13:17:31.583]                 ...future.makeSendCondition <- local({
[13:17:31.583]                   sendCondition <- NULL
[13:17:31.583]                   function(frame = 1L) {
[13:17:31.583]                     if (is.function(sendCondition)) 
[13:17:31.583]                       return(sendCondition)
[13:17:31.583]                     ns <- getNamespace("parallel")
[13:17:31.583]                     if (exists("sendData", mode = "function", 
[13:17:31.583]                       envir = ns)) {
[13:17:31.583]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.583]                         envir = ns)
[13:17:31.583]                       envir <- sys.frame(frame)
[13:17:31.583]                       master <- NULL
[13:17:31.583]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.583]                         !identical(envir, emptyenv())) {
[13:17:31.583]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.583]                           inherits = FALSE)) {
[13:17:31.583]                           master <- get("master", mode = "list", 
[13:17:31.583]                             envir = envir, inherits = FALSE)
[13:17:31.583]                           if (inherits(master, c("SOCKnode", 
[13:17:31.583]                             "SOCK0node"))) {
[13:17:31.583]                             sendCondition <<- function(cond) {
[13:17:31.583]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.583]                                 success = TRUE)
[13:17:31.583]                               parallel_sendData(master, data)
[13:17:31.583]                             }
[13:17:31.583]                             return(sendCondition)
[13:17:31.583]                           }
[13:17:31.583]                         }
[13:17:31.583]                         frame <- frame + 1L
[13:17:31.583]                         envir <- sys.frame(frame)
[13:17:31.583]                       }
[13:17:31.583]                     }
[13:17:31.583]                     sendCondition <<- function(cond) NULL
[13:17:31.583]                   }
[13:17:31.583]                 })
[13:17:31.583]                 withCallingHandlers({
[13:17:31.583]                   {
[13:17:31.583]                     do.call(function(...) {
[13:17:31.583]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.583]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.583]                         ...future.globals.maxSize)) {
[13:17:31.583]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.583]                         on.exit(options(oopts), add = TRUE)
[13:17:31.583]                       }
[13:17:31.583]                       {
[13:17:31.583]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.583]                           FUN = function(jj) {
[13:17:31.583]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.583]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.583]                           })
[13:17:31.583]                       }
[13:17:31.583]                     }, args = future.call.arguments)
[13:17:31.583]                   }
[13:17:31.583]                 }, immediateCondition = function(cond) {
[13:17:31.583]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.583]                   sendCondition(cond)
[13:17:31.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.583]                   {
[13:17:31.583]                     inherits <- base::inherits
[13:17:31.583]                     invokeRestart <- base::invokeRestart
[13:17:31.583]                     is.null <- base::is.null
[13:17:31.583]                     muffled <- FALSE
[13:17:31.583]                     if (inherits(cond, "message")) {
[13:17:31.583]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.583]                       if (muffled) 
[13:17:31.583]                         invokeRestart("muffleMessage")
[13:17:31.583]                     }
[13:17:31.583]                     else if (inherits(cond, "warning")) {
[13:17:31.583]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.583]                       if (muffled) 
[13:17:31.583]                         invokeRestart("muffleWarning")
[13:17:31.583]                     }
[13:17:31.583]                     else if (inherits(cond, "condition")) {
[13:17:31.583]                       if (!is.null(pattern)) {
[13:17:31.583]                         computeRestarts <- base::computeRestarts
[13:17:31.583]                         grepl <- base::grepl
[13:17:31.583]                         restarts <- computeRestarts(cond)
[13:17:31.583]                         for (restart in restarts) {
[13:17:31.583]                           name <- restart$name
[13:17:31.583]                           if (is.null(name)) 
[13:17:31.583]                             next
[13:17:31.583]                           if (!grepl(pattern, name)) 
[13:17:31.583]                             next
[13:17:31.583]                           invokeRestart(restart)
[13:17:31.583]                           muffled <- TRUE
[13:17:31.583]                           break
[13:17:31.583]                         }
[13:17:31.583]                       }
[13:17:31.583]                     }
[13:17:31.583]                     invisible(muffled)
[13:17:31.583]                   }
[13:17:31.583]                   muffleCondition(cond)
[13:17:31.583]                 })
[13:17:31.583]             }))
[13:17:31.583]             future::FutureResult(value = ...future.value$value, 
[13:17:31.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.583]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.583]                     ...future.globalenv.names))
[13:17:31.583]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.583]         }, condition = base::local({
[13:17:31.583]             c <- base::c
[13:17:31.583]             inherits <- base::inherits
[13:17:31.583]             invokeRestart <- base::invokeRestart
[13:17:31.583]             length <- base::length
[13:17:31.583]             list <- base::list
[13:17:31.583]             seq.int <- base::seq.int
[13:17:31.583]             signalCondition <- base::signalCondition
[13:17:31.583]             sys.calls <- base::sys.calls
[13:17:31.583]             `[[` <- base::`[[`
[13:17:31.583]             `+` <- base::`+`
[13:17:31.583]             `<<-` <- base::`<<-`
[13:17:31.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.583]                   3L)]
[13:17:31.583]             }
[13:17:31.583]             function(cond) {
[13:17:31.583]                 is_error <- inherits(cond, "error")
[13:17:31.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.583]                   NULL)
[13:17:31.583]                 if (is_error) {
[13:17:31.583]                   sessionInformation <- function() {
[13:17:31.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.583]                       search = base::search(), system = base::Sys.info())
[13:17:31.583]                   }
[13:17:31.583]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.583]                     cond$call), session = sessionInformation(), 
[13:17:31.583]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.583]                   signalCondition(cond)
[13:17:31.583]                 }
[13:17:31.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.583]                 "immediateCondition"))) {
[13:17:31.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.583]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.583]                   if (TRUE && !signal) {
[13:17:31.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.583]                     {
[13:17:31.583]                       inherits <- base::inherits
[13:17:31.583]                       invokeRestart <- base::invokeRestart
[13:17:31.583]                       is.null <- base::is.null
[13:17:31.583]                       muffled <- FALSE
[13:17:31.583]                       if (inherits(cond, "message")) {
[13:17:31.583]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.583]                         if (muffled) 
[13:17:31.583]                           invokeRestart("muffleMessage")
[13:17:31.583]                       }
[13:17:31.583]                       else if (inherits(cond, "warning")) {
[13:17:31.583]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.583]                         if (muffled) 
[13:17:31.583]                           invokeRestart("muffleWarning")
[13:17:31.583]                       }
[13:17:31.583]                       else if (inherits(cond, "condition")) {
[13:17:31.583]                         if (!is.null(pattern)) {
[13:17:31.583]                           computeRestarts <- base::computeRestarts
[13:17:31.583]                           grepl <- base::grepl
[13:17:31.583]                           restarts <- computeRestarts(cond)
[13:17:31.583]                           for (restart in restarts) {
[13:17:31.583]                             name <- restart$name
[13:17:31.583]                             if (is.null(name)) 
[13:17:31.583]                               next
[13:17:31.583]                             if (!grepl(pattern, name)) 
[13:17:31.583]                               next
[13:17:31.583]                             invokeRestart(restart)
[13:17:31.583]                             muffled <- TRUE
[13:17:31.583]                             break
[13:17:31.583]                           }
[13:17:31.583]                         }
[13:17:31.583]                       }
[13:17:31.583]                       invisible(muffled)
[13:17:31.583]                     }
[13:17:31.583]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.583]                   }
[13:17:31.583]                 }
[13:17:31.583]                 else {
[13:17:31.583]                   if (TRUE) {
[13:17:31.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.583]                     {
[13:17:31.583]                       inherits <- base::inherits
[13:17:31.583]                       invokeRestart <- base::invokeRestart
[13:17:31.583]                       is.null <- base::is.null
[13:17:31.583]                       muffled <- FALSE
[13:17:31.583]                       if (inherits(cond, "message")) {
[13:17:31.583]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.583]                         if (muffled) 
[13:17:31.583]                           invokeRestart("muffleMessage")
[13:17:31.583]                       }
[13:17:31.583]                       else if (inherits(cond, "warning")) {
[13:17:31.583]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.583]                         if (muffled) 
[13:17:31.583]                           invokeRestart("muffleWarning")
[13:17:31.583]                       }
[13:17:31.583]                       else if (inherits(cond, "condition")) {
[13:17:31.583]                         if (!is.null(pattern)) {
[13:17:31.583]                           computeRestarts <- base::computeRestarts
[13:17:31.583]                           grepl <- base::grepl
[13:17:31.583]                           restarts <- computeRestarts(cond)
[13:17:31.583]                           for (restart in restarts) {
[13:17:31.583]                             name <- restart$name
[13:17:31.583]                             if (is.null(name)) 
[13:17:31.583]                               next
[13:17:31.583]                             if (!grepl(pattern, name)) 
[13:17:31.583]                               next
[13:17:31.583]                             invokeRestart(restart)
[13:17:31.583]                             muffled <- TRUE
[13:17:31.583]                             break
[13:17:31.583]                           }
[13:17:31.583]                         }
[13:17:31.583]                       }
[13:17:31.583]                       invisible(muffled)
[13:17:31.583]                     }
[13:17:31.583]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.583]                   }
[13:17:31.583]                 }
[13:17:31.583]             }
[13:17:31.583]         }))
[13:17:31.583]     }, error = function(ex) {
[13:17:31.583]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.583]                 ...future.rng), started = ...future.startTime, 
[13:17:31.583]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.583]             version = "1.8"), class = "FutureResult")
[13:17:31.583]     }, finally = {
[13:17:31.583]         if (!identical(...future.workdir, getwd())) 
[13:17:31.583]             setwd(...future.workdir)
[13:17:31.583]         {
[13:17:31.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.583]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.583]             }
[13:17:31.583]             base::options(...future.oldOptions)
[13:17:31.583]             if (.Platform$OS.type == "windows") {
[13:17:31.583]                 old_names <- names(...future.oldEnvVars)
[13:17:31.583]                 envs <- base::Sys.getenv()
[13:17:31.583]                 names <- names(envs)
[13:17:31.583]                 common <- intersect(names, old_names)
[13:17:31.583]                 added <- setdiff(names, old_names)
[13:17:31.583]                 removed <- setdiff(old_names, names)
[13:17:31.583]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.583]                   envs[common]]
[13:17:31.583]                 NAMES <- toupper(changed)
[13:17:31.583]                 args <- list()
[13:17:31.583]                 for (kk in seq_along(NAMES)) {
[13:17:31.583]                   name <- changed[[kk]]
[13:17:31.583]                   NAME <- NAMES[[kk]]
[13:17:31.583]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.583]                     next
[13:17:31.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.583]                 }
[13:17:31.583]                 NAMES <- toupper(added)
[13:17:31.583]                 for (kk in seq_along(NAMES)) {
[13:17:31.583]                   name <- added[[kk]]
[13:17:31.583]                   NAME <- NAMES[[kk]]
[13:17:31.583]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.583]                     next
[13:17:31.583]                   args[[name]] <- ""
[13:17:31.583]                 }
[13:17:31.583]                 NAMES <- toupper(removed)
[13:17:31.583]                 for (kk in seq_along(NAMES)) {
[13:17:31.583]                   name <- removed[[kk]]
[13:17:31.583]                   NAME <- NAMES[[kk]]
[13:17:31.583]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.583]                     next
[13:17:31.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.583]                 }
[13:17:31.583]                 if (length(args) > 0) 
[13:17:31.583]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.583]             }
[13:17:31.583]             else {
[13:17:31.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.583]             }
[13:17:31.583]             {
[13:17:31.583]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.583]                   0L) {
[13:17:31.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.583]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.583]                   base::options(opts)
[13:17:31.583]                 }
[13:17:31.583]                 {
[13:17:31.583]                   {
[13:17:31.583]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.583]                     NULL
[13:17:31.583]                   }
[13:17:31.583]                   options(future.plan = NULL)
[13:17:31.583]                   if (is.na(NA_character_)) 
[13:17:31.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.583]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.583]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.583]                     envir = parent.frame()) 
[13:17:31.583]                   {
[13:17:31.583]                     if (is.function(workers)) 
[13:17:31.583]                       workers <- workers()
[13:17:31.583]                     workers <- structure(as.integer(workers), 
[13:17:31.583]                       class = class(workers))
[13:17:31.583]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.583]                       workers >= 1)
[13:17:31.583]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.583]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.583]                     }
[13:17:31.583]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.583]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.583]                       envir = envir)
[13:17:31.583]                     if (!future$lazy) 
[13:17:31.583]                       future <- run(future)
[13:17:31.583]                     invisible(future)
[13:17:31.583]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.583]                 }
[13:17:31.583]             }
[13:17:31.583]         }
[13:17:31.583]     })
[13:17:31.583]     if (TRUE) {
[13:17:31.583]         base::sink(type = "output", split = FALSE)
[13:17:31.583]         if (TRUE) {
[13:17:31.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.583]         }
[13:17:31.583]         else {
[13:17:31.583]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.583]         }
[13:17:31.583]         base::close(...future.stdout)
[13:17:31.583]         ...future.stdout <- NULL
[13:17:31.583]     }
[13:17:31.583]     ...future.result$conditions <- ...future.conditions
[13:17:31.583]     ...future.result$finished <- base::Sys.time()
[13:17:31.583]     ...future.result
[13:17:31.583] }
[13:17:31.585] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[13:17:31.586] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:17:31.586] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:17:31.586] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[13:17:31.586] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[13:17:31.587] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[13:17:31.587] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[13:17:31.587] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:31.587] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.587] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:31.588] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.588] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[13:17:31.588] MultisessionFuture started
[13:17:31.588] - Launch lazy future ... done
[13:17:31.589] run() for ‘MultisessionFuture’ ... done
[13:17:31.589] Created future:
[13:17:31.589] MultisessionFuture:
[13:17:31.589] Label: ‘future_by-2’
[13:17:31.589] Expression:
[13:17:31.589] {
[13:17:31.589]     do.call(function(...) {
[13:17:31.589]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.589]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.589]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.589]             on.exit(options(oopts), add = TRUE)
[13:17:31.589]         }
[13:17:31.589]         {
[13:17:31.589]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.589]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.589]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.589]             })
[13:17:31.589]         }
[13:17:31.589]     }, args = future.call.arguments)
[13:17:31.589] }
[13:17:31.589] Lazy evaluation: FALSE
[13:17:31.589] Asynchronous evaluation: TRUE
[13:17:31.589] Local evaluation: TRUE
[13:17:31.589] Environment: R_GlobalEnv
[13:17:31.589] Capture standard output: TRUE
[13:17:31.589] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.589] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.589] Packages: <none>
[13:17:31.589] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.589] Resolved: FALSE
[13:17:31.589] Value: <not collected>
[13:17:31.589] Conditions captured: <none>
[13:17:31.589] Early signaling: FALSE
[13:17:31.589] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.589] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.600] Chunk #2 of 2 ... DONE
[13:17:31.600] Launching 2 futures (chunks) ... DONE
[13:17:31.600] Resolving 2 futures (chunks) ...
[13:17:31.601] resolve() on list ...
[13:17:31.601]  recursive: 0
[13:17:31.601]  length: 2
[13:17:31.601] 
[13:17:31.601] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.602] - Validating connection of MultisessionFuture
[13:17:31.602] - received message: FutureResult
[13:17:31.602] - Received FutureResult
[13:17:31.602] - Erased future from FutureRegistry
[13:17:31.602] result() for ClusterFuture ...
[13:17:31.602] - result already collected: FutureResult
[13:17:31.602] result() for ClusterFuture ... done
[13:17:31.602] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.602] Future #1
[13:17:31.603] result() for ClusterFuture ...
[13:17:31.603] - result already collected: FutureResult
[13:17:31.603] result() for ClusterFuture ... done
[13:17:31.603] result() for ClusterFuture ...
[13:17:31.603] - result already collected: FutureResult
[13:17:31.603] result() for ClusterFuture ... done
[13:17:31.603] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:31.603] - nx: 2
[13:17:31.603] - relay: TRUE
[13:17:31.603] - stdout: TRUE
[13:17:31.603] - signal: TRUE
[13:17:31.603] - resignal: FALSE
[13:17:31.604] - force: TRUE
[13:17:31.604] - relayed: [n=2] FALSE, FALSE
[13:17:31.604] - queued futures: [n=2] FALSE, FALSE
[13:17:31.604]  - until=1
[13:17:31.604]  - relaying element #1
[13:17:31.604] result() for ClusterFuture ...
[13:17:31.604] - result already collected: FutureResult
[13:17:31.604] result() for ClusterFuture ... done
[13:17:31.604] result() for ClusterFuture ...
[13:17:31.604] - result already collected: FutureResult
[13:17:31.604] result() for ClusterFuture ... done
[13:17:31.605] result() for ClusterFuture ...
[13:17:31.605] - result already collected: FutureResult
[13:17:31.605] result() for ClusterFuture ... done
[13:17:31.605] result() for ClusterFuture ...
[13:17:31.605] - result already collected: FutureResult
[13:17:31.605] result() for ClusterFuture ... done
[13:17:31.605] - relayed: [n=2] TRUE, FALSE
[13:17:31.605] - queued futures: [n=2] TRUE, FALSE
[13:17:31.605] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:31.605]  length: 1 (resolved future 1)
[13:17:31.634] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.634] - Validating connection of MultisessionFuture
[13:17:31.634] - received message: FutureResult
[13:17:31.635] - Received FutureResult
[13:17:31.635] - Erased future from FutureRegistry
[13:17:31.635] result() for ClusterFuture ...
[13:17:31.635] - result already collected: FutureResult
[13:17:31.635] result() for ClusterFuture ... done
[13:17:31.635] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.635] Future #2
[13:17:31.635] result() for ClusterFuture ...
[13:17:31.635] - result already collected: FutureResult
[13:17:31.635] result() for ClusterFuture ... done
[13:17:31.636] result() for ClusterFuture ...
[13:17:31.636] - result already collected: FutureResult
[13:17:31.636] result() for ClusterFuture ... done
[13:17:31.636] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:31.636] - nx: 2
[13:17:31.636] - relay: TRUE
[13:17:31.636] - stdout: TRUE
[13:17:31.636] - signal: TRUE
[13:17:31.636] - resignal: FALSE
[13:17:31.636] - force: TRUE
[13:17:31.636] - relayed: [n=2] TRUE, FALSE
[13:17:31.636] - queued futures: [n=2] TRUE, FALSE
[13:17:31.637]  - until=2
[13:17:31.637]  - relaying element #2
[13:17:31.637] result() for ClusterFuture ...
[13:17:31.637] - result already collected: FutureResult
[13:17:31.637] result() for ClusterFuture ... done
[13:17:31.637] result() for ClusterFuture ...
[13:17:31.637] - result already collected: FutureResult
[13:17:31.637] result() for ClusterFuture ... done
[13:17:31.637] result() for ClusterFuture ...
[13:17:31.637] - result already collected: FutureResult
[13:17:31.637] result() for ClusterFuture ... done
[13:17:31.638] result() for ClusterFuture ...
[13:17:31.638] - result already collected: FutureResult
[13:17:31.638] result() for ClusterFuture ... done
[13:17:31.638] - relayed: [n=2] TRUE, TRUE
[13:17:31.638] - queued futures: [n=2] TRUE, TRUE
[13:17:31.638] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:31.638]  length: 0 (resolved future 2)
[13:17:31.638] Relaying remaining futures
[13:17:31.638] signalConditionsASAP(NULL, pos=0) ...
[13:17:31.638] - nx: 2
[13:17:31.638] - relay: TRUE
[13:17:31.638] - stdout: TRUE
[13:17:31.639] - signal: TRUE
[13:17:31.639] - resignal: FALSE
[13:17:31.639] - force: TRUE
[13:17:31.639] - relayed: [n=2] TRUE, TRUE
[13:17:31.639] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:31.639] - relayed: [n=2] TRUE, TRUE
[13:17:31.639] - queued futures: [n=2] TRUE, TRUE
[13:17:31.639] signalConditionsASAP(NULL, pos=0) ... done
[13:17:31.639] resolve() on list ... DONE
[13:17:31.639] result() for ClusterFuture ...
[13:17:31.639] - result already collected: FutureResult
[13:17:31.640] result() for ClusterFuture ... done
[13:17:31.640] result() for ClusterFuture ...
[13:17:31.640] - result already collected: FutureResult
[13:17:31.640] result() for ClusterFuture ... done
[13:17:31.640] result() for ClusterFuture ...
[13:17:31.640] - result already collected: FutureResult
[13:17:31.640] result() for ClusterFuture ... done
[13:17:31.640] result() for ClusterFuture ...
[13:17:31.640] - result already collected: FutureResult
[13:17:31.640] result() for ClusterFuture ... done
[13:17:31.640]  - Number of value chunks collected: 2
[13:17:31.641] Resolving 2 futures (chunks) ... DONE
[13:17:31.641] Reducing values from 2 chunks ...
[13:17:31.641]  - Number of values collected after concatenation: 6
[13:17:31.641]  - Number of values expected: 6
[13:17:31.641] Reducing values from 2 chunks ... DONE
[13:17:31.641] future_lapply() ... DONE
[13:17:31.641] future_by_internal() ... DONE
[13:17:31.642] future_by_internal() ...
[13:17:31.643] future_lapply() ...
[13:17:31.647] Number of chunks: 2
[13:17:31.647] getGlobalsAndPackagesXApply() ...
[13:17:31.647]  - future.globals: TRUE
[13:17:31.647] getGlobalsAndPackages() ...
[13:17:31.647] Searching for globals...
[13:17:31.649] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:31.649] Searching for globals ... DONE
[13:17:31.649] Resolving globals: FALSE
[13:17:31.649] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:17:31.650] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:17:31.650] - globals: [1] ‘FUN’
[13:17:31.650] - packages: [1] ‘stats’
[13:17:31.650] getGlobalsAndPackages() ... DONE
[13:17:31.650]  - globals found/used: [n=1] ‘FUN’
[13:17:31.650]  - needed namespaces: [n=1] ‘stats’
[13:17:31.650] Finding globals ... DONE
[13:17:31.650]  - use_args: TRUE
[13:17:31.651]  - Getting '...' globals ...
[13:17:31.651] resolve() on list ...
[13:17:31.651]  recursive: 0
[13:17:31.651]  length: 1
[13:17:31.651]  elements: ‘...’
[13:17:31.651]  length: 0 (resolved future 1)
[13:17:31.651] resolve() on list ... DONE
[13:17:31.651]    - '...' content: [n=1] ‘singular.ok’
[13:17:31.652] List of 1
[13:17:31.652]  $ ...:List of 1
[13:17:31.652]   ..$ singular.ok: logi FALSE
[13:17:31.652]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.652]  - attr(*, "where")=List of 1
[13:17:31.652]   ..$ ...:<environment: 0x5609ea6edef0> 
[13:17:31.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.652]  - attr(*, "resolved")= logi TRUE
[13:17:31.652]  - attr(*, "total_size")= num NA
[13:17:31.654]  - Getting '...' globals ... DONE
[13:17:31.657] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:31.657] List of 2
[13:17:31.657]  $ ...future.FUN:function (x, ...)  
[13:17:31.657]  $ ...          :List of 1
[13:17:31.657]   ..$ singular.ok: logi FALSE
[13:17:31.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.657]  - attr(*, "where")=List of 2
[13:17:31.657]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:31.657]   ..$ ...          :<environment: 0x5609ea6edef0> 
[13:17:31.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.657]  - attr(*, "resolved")= logi FALSE
[13:17:31.657]  - attr(*, "total_size")= num 5384
[13:17:31.660] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:31.660] getGlobalsAndPackagesXApply() ... DONE
[13:17:31.660] Number of futures (= number of chunks): 2
[13:17:31.660] Launching 2 futures (chunks) ...
[13:17:31.660] Chunk #1 of 2 ...
[13:17:31.660]  - Finding globals in 'X' for chunk #1 ...
[13:17:31.660] getGlobalsAndPackages() ...
[13:17:31.661] Searching for globals...
[13:17:31.661] 
[13:17:31.661] Searching for globals ... DONE
[13:17:31.661] - globals: [0] <none>
[13:17:31.661] getGlobalsAndPackages() ... DONE
[13:17:31.661]    + additional globals found: [n=0] 
[13:17:31.661]    + additional namespaces needed: [n=0] 
[13:17:31.661]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:31.662]  - seeds: <none>
[13:17:31.662] getGlobalsAndPackages() ...
[13:17:31.662] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.662] Resolving globals: FALSE
[13:17:31.662] Tweak future expression to call with '...' arguments ...
[13:17:31.662] {
[13:17:31.662]     do.call(function(...) {
[13:17:31.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.662]             on.exit(options(oopts), add = TRUE)
[13:17:31.662]         }
[13:17:31.662]         {
[13:17:31.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.662]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.662]             })
[13:17:31.662]         }
[13:17:31.662]     }, args = future.call.arguments)
[13:17:31.662] }
[13:17:31.662] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.663] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.663] 
[13:17:31.663] getGlobalsAndPackages() ... DONE
[13:17:31.663] run() for ‘Future’ ...
[13:17:31.663] - state: ‘created’
[13:17:31.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.678]   - Field: ‘node’
[13:17:31.678]   - Field: ‘label’
[13:17:31.678]   - Field: ‘local’
[13:17:31.678]   - Field: ‘owner’
[13:17:31.678]   - Field: ‘envir’
[13:17:31.678]   - Field: ‘workers’
[13:17:31.678]   - Field: ‘packages’
[13:17:31.678]   - Field: ‘gc’
[13:17:31.678]   - Field: ‘conditions’
[13:17:31.678]   - Field: ‘persistent’
[13:17:31.678]   - Field: ‘expr’
[13:17:31.679]   - Field: ‘uuid’
[13:17:31.679]   - Field: ‘seed’
[13:17:31.679]   - Field: ‘version’
[13:17:31.679]   - Field: ‘result’
[13:17:31.679]   - Field: ‘asynchronous’
[13:17:31.679]   - Field: ‘calls’
[13:17:31.679]   - Field: ‘globals’
[13:17:31.679]   - Field: ‘stdout’
[13:17:31.679]   - Field: ‘earlySignal’
[13:17:31.679]   - Field: ‘lazy’
[13:17:31.679]   - Field: ‘state’
[13:17:31.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.680] - Launch lazy future ...
[13:17:31.680] Packages needed by the future expression (n = 1): ‘stats’
[13:17:31.680] Packages needed by future strategies (n = 0): <none>
[13:17:31.681] {
[13:17:31.681]     {
[13:17:31.681]         {
[13:17:31.681]             ...future.startTime <- base::Sys.time()
[13:17:31.681]             {
[13:17:31.681]                 {
[13:17:31.681]                   {
[13:17:31.681]                     {
[13:17:31.681]                       {
[13:17:31.681]                         base::local({
[13:17:31.681]                           has_future <- base::requireNamespace("future", 
[13:17:31.681]                             quietly = TRUE)
[13:17:31.681]                           if (has_future) {
[13:17:31.681]                             ns <- base::getNamespace("future")
[13:17:31.681]                             version <- ns[[".package"]][["version"]]
[13:17:31.681]                             if (is.null(version)) 
[13:17:31.681]                               version <- utils::packageVersion("future")
[13:17:31.681]                           }
[13:17:31.681]                           else {
[13:17:31.681]                             version <- NULL
[13:17:31.681]                           }
[13:17:31.681]                           if (!has_future || version < "1.8.0") {
[13:17:31.681]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.681]                               "", base::R.version$version.string), 
[13:17:31.681]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:31.681]                                 base::R.version$platform, 8 * 
[13:17:31.681]                                   base::.Machine$sizeof.pointer), 
[13:17:31.681]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.681]                                 "release", "version")], collapse = " "), 
[13:17:31.681]                               hostname = base::Sys.info()[["nodename"]])
[13:17:31.681]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.681]                               info)
[13:17:31.681]                             info <- base::paste(info, collapse = "; ")
[13:17:31.681]                             if (!has_future) {
[13:17:31.681]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.681]                                 info)
[13:17:31.681]                             }
[13:17:31.681]                             else {
[13:17:31.681]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.681]                                 info, version)
[13:17:31.681]                             }
[13:17:31.681]                             base::stop(msg)
[13:17:31.681]                           }
[13:17:31.681]                         })
[13:17:31.681]                       }
[13:17:31.681]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.681]                       base::options(mc.cores = 1L)
[13:17:31.681]                     }
[13:17:31.681]                     base::local({
[13:17:31.681]                       for (pkg in "stats") {
[13:17:31.681]                         base::loadNamespace(pkg)
[13:17:31.681]                         base::library(pkg, character.only = TRUE)
[13:17:31.681]                       }
[13:17:31.681]                     })
[13:17:31.681]                   }
[13:17:31.681]                   options(future.plan = NULL)
[13:17:31.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.681]                 }
[13:17:31.681]                 ...future.workdir <- getwd()
[13:17:31.681]             }
[13:17:31.681]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.681]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.681]         }
[13:17:31.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.681]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:31.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.681]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.681]             base::names(...future.oldOptions))
[13:17:31.681]     }
[13:17:31.681]     if (FALSE) {
[13:17:31.681]     }
[13:17:31.681]     else {
[13:17:31.681]         if (TRUE) {
[13:17:31.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.681]                 open = "w")
[13:17:31.681]         }
[13:17:31.681]         else {
[13:17:31.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.681]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.681]         }
[13:17:31.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.681]             base::sink(type = "output", split = FALSE)
[13:17:31.681]             base::close(...future.stdout)
[13:17:31.681]         }, add = TRUE)
[13:17:31.681]     }
[13:17:31.681]     ...future.frame <- base::sys.nframe()
[13:17:31.681]     ...future.conditions <- base::list()
[13:17:31.681]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.681]     if (FALSE) {
[13:17:31.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.681]     }
[13:17:31.681]     ...future.result <- base::tryCatch({
[13:17:31.681]         base::withCallingHandlers({
[13:17:31.681]             ...future.value <- base::withVisible(base::local({
[13:17:31.681]                 ...future.makeSendCondition <- local({
[13:17:31.681]                   sendCondition <- NULL
[13:17:31.681]                   function(frame = 1L) {
[13:17:31.681]                     if (is.function(sendCondition)) 
[13:17:31.681]                       return(sendCondition)
[13:17:31.681]                     ns <- getNamespace("parallel")
[13:17:31.681]                     if (exists("sendData", mode = "function", 
[13:17:31.681]                       envir = ns)) {
[13:17:31.681]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.681]                         envir = ns)
[13:17:31.681]                       envir <- sys.frame(frame)
[13:17:31.681]                       master <- NULL
[13:17:31.681]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.681]                         !identical(envir, emptyenv())) {
[13:17:31.681]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.681]                           inherits = FALSE)) {
[13:17:31.681]                           master <- get("master", mode = "list", 
[13:17:31.681]                             envir = envir, inherits = FALSE)
[13:17:31.681]                           if (inherits(master, c("SOCKnode", 
[13:17:31.681]                             "SOCK0node"))) {
[13:17:31.681]                             sendCondition <<- function(cond) {
[13:17:31.681]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.681]                                 success = TRUE)
[13:17:31.681]                               parallel_sendData(master, data)
[13:17:31.681]                             }
[13:17:31.681]                             return(sendCondition)
[13:17:31.681]                           }
[13:17:31.681]                         }
[13:17:31.681]                         frame <- frame + 1L
[13:17:31.681]                         envir <- sys.frame(frame)
[13:17:31.681]                       }
[13:17:31.681]                     }
[13:17:31.681]                     sendCondition <<- function(cond) NULL
[13:17:31.681]                   }
[13:17:31.681]                 })
[13:17:31.681]                 withCallingHandlers({
[13:17:31.681]                   {
[13:17:31.681]                     do.call(function(...) {
[13:17:31.681]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.681]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.681]                         ...future.globals.maxSize)) {
[13:17:31.681]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.681]                         on.exit(options(oopts), add = TRUE)
[13:17:31.681]                       }
[13:17:31.681]                       {
[13:17:31.681]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.681]                           FUN = function(jj) {
[13:17:31.681]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.681]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.681]                           })
[13:17:31.681]                       }
[13:17:31.681]                     }, args = future.call.arguments)
[13:17:31.681]                   }
[13:17:31.681]                 }, immediateCondition = function(cond) {
[13:17:31.681]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.681]                   sendCondition(cond)
[13:17:31.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.681]                   {
[13:17:31.681]                     inherits <- base::inherits
[13:17:31.681]                     invokeRestart <- base::invokeRestart
[13:17:31.681]                     is.null <- base::is.null
[13:17:31.681]                     muffled <- FALSE
[13:17:31.681]                     if (inherits(cond, "message")) {
[13:17:31.681]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.681]                       if (muffled) 
[13:17:31.681]                         invokeRestart("muffleMessage")
[13:17:31.681]                     }
[13:17:31.681]                     else if (inherits(cond, "warning")) {
[13:17:31.681]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.681]                       if (muffled) 
[13:17:31.681]                         invokeRestart("muffleWarning")
[13:17:31.681]                     }
[13:17:31.681]                     else if (inherits(cond, "condition")) {
[13:17:31.681]                       if (!is.null(pattern)) {
[13:17:31.681]                         computeRestarts <- base::computeRestarts
[13:17:31.681]                         grepl <- base::grepl
[13:17:31.681]                         restarts <- computeRestarts(cond)
[13:17:31.681]                         for (restart in restarts) {
[13:17:31.681]                           name <- restart$name
[13:17:31.681]                           if (is.null(name)) 
[13:17:31.681]                             next
[13:17:31.681]                           if (!grepl(pattern, name)) 
[13:17:31.681]                             next
[13:17:31.681]                           invokeRestart(restart)
[13:17:31.681]                           muffled <- TRUE
[13:17:31.681]                           break
[13:17:31.681]                         }
[13:17:31.681]                       }
[13:17:31.681]                     }
[13:17:31.681]                     invisible(muffled)
[13:17:31.681]                   }
[13:17:31.681]                   muffleCondition(cond)
[13:17:31.681]                 })
[13:17:31.681]             }))
[13:17:31.681]             future::FutureResult(value = ...future.value$value, 
[13:17:31.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.681]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.681]                     ...future.globalenv.names))
[13:17:31.681]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.681]         }, condition = base::local({
[13:17:31.681]             c <- base::c
[13:17:31.681]             inherits <- base::inherits
[13:17:31.681]             invokeRestart <- base::invokeRestart
[13:17:31.681]             length <- base::length
[13:17:31.681]             list <- base::list
[13:17:31.681]             seq.int <- base::seq.int
[13:17:31.681]             signalCondition <- base::signalCondition
[13:17:31.681]             sys.calls <- base::sys.calls
[13:17:31.681]             `[[` <- base::`[[`
[13:17:31.681]             `+` <- base::`+`
[13:17:31.681]             `<<-` <- base::`<<-`
[13:17:31.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.681]                   3L)]
[13:17:31.681]             }
[13:17:31.681]             function(cond) {
[13:17:31.681]                 is_error <- inherits(cond, "error")
[13:17:31.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.681]                   NULL)
[13:17:31.681]                 if (is_error) {
[13:17:31.681]                   sessionInformation <- function() {
[13:17:31.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.681]                       search = base::search(), system = base::Sys.info())
[13:17:31.681]                   }
[13:17:31.681]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.681]                     cond$call), session = sessionInformation(), 
[13:17:31.681]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.681]                   signalCondition(cond)
[13:17:31.681]                 }
[13:17:31.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.681]                 "immediateCondition"))) {
[13:17:31.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.681]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.681]                   if (TRUE && !signal) {
[13:17:31.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.681]                     {
[13:17:31.681]                       inherits <- base::inherits
[13:17:31.681]                       invokeRestart <- base::invokeRestart
[13:17:31.681]                       is.null <- base::is.null
[13:17:31.681]                       muffled <- FALSE
[13:17:31.681]                       if (inherits(cond, "message")) {
[13:17:31.681]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.681]                         if (muffled) 
[13:17:31.681]                           invokeRestart("muffleMessage")
[13:17:31.681]                       }
[13:17:31.681]                       else if (inherits(cond, "warning")) {
[13:17:31.681]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.681]                         if (muffled) 
[13:17:31.681]                           invokeRestart("muffleWarning")
[13:17:31.681]                       }
[13:17:31.681]                       else if (inherits(cond, "condition")) {
[13:17:31.681]                         if (!is.null(pattern)) {
[13:17:31.681]                           computeRestarts <- base::computeRestarts
[13:17:31.681]                           grepl <- base::grepl
[13:17:31.681]                           restarts <- computeRestarts(cond)
[13:17:31.681]                           for (restart in restarts) {
[13:17:31.681]                             name <- restart$name
[13:17:31.681]                             if (is.null(name)) 
[13:17:31.681]                               next
[13:17:31.681]                             if (!grepl(pattern, name)) 
[13:17:31.681]                               next
[13:17:31.681]                             invokeRestart(restart)
[13:17:31.681]                             muffled <- TRUE
[13:17:31.681]                             break
[13:17:31.681]                           }
[13:17:31.681]                         }
[13:17:31.681]                       }
[13:17:31.681]                       invisible(muffled)
[13:17:31.681]                     }
[13:17:31.681]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.681]                   }
[13:17:31.681]                 }
[13:17:31.681]                 else {
[13:17:31.681]                   if (TRUE) {
[13:17:31.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.681]                     {
[13:17:31.681]                       inherits <- base::inherits
[13:17:31.681]                       invokeRestart <- base::invokeRestart
[13:17:31.681]                       is.null <- base::is.null
[13:17:31.681]                       muffled <- FALSE
[13:17:31.681]                       if (inherits(cond, "message")) {
[13:17:31.681]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.681]                         if (muffled) 
[13:17:31.681]                           invokeRestart("muffleMessage")
[13:17:31.681]                       }
[13:17:31.681]                       else if (inherits(cond, "warning")) {
[13:17:31.681]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.681]                         if (muffled) 
[13:17:31.681]                           invokeRestart("muffleWarning")
[13:17:31.681]                       }
[13:17:31.681]                       else if (inherits(cond, "condition")) {
[13:17:31.681]                         if (!is.null(pattern)) {
[13:17:31.681]                           computeRestarts <- base::computeRestarts
[13:17:31.681]                           grepl <- base::grepl
[13:17:31.681]                           restarts <- computeRestarts(cond)
[13:17:31.681]                           for (restart in restarts) {
[13:17:31.681]                             name <- restart$name
[13:17:31.681]                             if (is.null(name)) 
[13:17:31.681]                               next
[13:17:31.681]                             if (!grepl(pattern, name)) 
[13:17:31.681]                               next
[13:17:31.681]                             invokeRestart(restart)
[13:17:31.681]                             muffled <- TRUE
[13:17:31.681]                             break
[13:17:31.681]                           }
[13:17:31.681]                         }
[13:17:31.681]                       }
[13:17:31.681]                       invisible(muffled)
[13:17:31.681]                     }
[13:17:31.681]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.681]                   }
[13:17:31.681]                 }
[13:17:31.681]             }
[13:17:31.681]         }))
[13:17:31.681]     }, error = function(ex) {
[13:17:31.681]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.681]                 ...future.rng), started = ...future.startTime, 
[13:17:31.681]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.681]             version = "1.8"), class = "FutureResult")
[13:17:31.681]     }, finally = {
[13:17:31.681]         if (!identical(...future.workdir, getwd())) 
[13:17:31.681]             setwd(...future.workdir)
[13:17:31.681]         {
[13:17:31.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.681]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.681]             }
[13:17:31.681]             base::options(...future.oldOptions)
[13:17:31.681]             if (.Platform$OS.type == "windows") {
[13:17:31.681]                 old_names <- names(...future.oldEnvVars)
[13:17:31.681]                 envs <- base::Sys.getenv()
[13:17:31.681]                 names <- names(envs)
[13:17:31.681]                 common <- intersect(names, old_names)
[13:17:31.681]                 added <- setdiff(names, old_names)
[13:17:31.681]                 removed <- setdiff(old_names, names)
[13:17:31.681]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.681]                   envs[common]]
[13:17:31.681]                 NAMES <- toupper(changed)
[13:17:31.681]                 args <- list()
[13:17:31.681]                 for (kk in seq_along(NAMES)) {
[13:17:31.681]                   name <- changed[[kk]]
[13:17:31.681]                   NAME <- NAMES[[kk]]
[13:17:31.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.681]                     next
[13:17:31.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.681]                 }
[13:17:31.681]                 NAMES <- toupper(added)
[13:17:31.681]                 for (kk in seq_along(NAMES)) {
[13:17:31.681]                   name <- added[[kk]]
[13:17:31.681]                   NAME <- NAMES[[kk]]
[13:17:31.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.681]                     next
[13:17:31.681]                   args[[name]] <- ""
[13:17:31.681]                 }
[13:17:31.681]                 NAMES <- toupper(removed)
[13:17:31.681]                 for (kk in seq_along(NAMES)) {
[13:17:31.681]                   name <- removed[[kk]]
[13:17:31.681]                   NAME <- NAMES[[kk]]
[13:17:31.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.681]                     next
[13:17:31.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.681]                 }
[13:17:31.681]                 if (length(args) > 0) 
[13:17:31.681]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.681]             }
[13:17:31.681]             else {
[13:17:31.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.681]             }
[13:17:31.681]             {
[13:17:31.681]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.681]                   0L) {
[13:17:31.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.681]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.681]                   base::options(opts)
[13:17:31.681]                 }
[13:17:31.681]                 {
[13:17:31.681]                   {
[13:17:31.681]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.681]                     NULL
[13:17:31.681]                   }
[13:17:31.681]                   options(future.plan = NULL)
[13:17:31.681]                   if (is.na(NA_character_)) 
[13:17:31.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.681]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.681]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.681]                     envir = parent.frame()) 
[13:17:31.681]                   {
[13:17:31.681]                     if (is.function(workers)) 
[13:17:31.681]                       workers <- workers()
[13:17:31.681]                     workers <- structure(as.integer(workers), 
[13:17:31.681]                       class = class(workers))
[13:17:31.681]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.681]                       workers >= 1)
[13:17:31.681]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.681]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.681]                     }
[13:17:31.681]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.681]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.681]                       envir = envir)
[13:17:31.681]                     if (!future$lazy) 
[13:17:31.681]                       future <- run(future)
[13:17:31.681]                     invisible(future)
[13:17:31.681]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.681]                 }
[13:17:31.681]             }
[13:17:31.681]         }
[13:17:31.681]     })
[13:17:31.681]     if (TRUE) {
[13:17:31.681]         base::sink(type = "output", split = FALSE)
[13:17:31.681]         if (TRUE) {
[13:17:31.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.681]         }
[13:17:31.681]         else {
[13:17:31.681]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.681]         }
[13:17:31.681]         base::close(...future.stdout)
[13:17:31.681]         ...future.stdout <- NULL
[13:17:31.681]     }
[13:17:31.681]     ...future.result$conditions <- ...future.conditions
[13:17:31.681]     ...future.result$finished <- base::Sys.time()
[13:17:31.681]     ...future.result
[13:17:31.681] }
[13:17:31.683] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[13:17:31.684] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[13:17:31.684] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[13:17:31.684] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:17:31.685] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:17:31.685] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:17:31.685] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:17:31.685] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:31.686] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.686] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:31.686] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.686] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[13:17:31.687] MultisessionFuture started
[13:17:31.687] - Launch lazy future ... done
[13:17:31.687] run() for ‘MultisessionFuture’ ... done
[13:17:31.687] Created future:
[13:17:31.687] MultisessionFuture:
[13:17:31.687] Label: ‘future_by-1’
[13:17:31.687] Expression:
[13:17:31.687] {
[13:17:31.687]     do.call(function(...) {
[13:17:31.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.687]             on.exit(options(oopts), add = TRUE)
[13:17:31.687]         }
[13:17:31.687]         {
[13:17:31.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.687]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.687]             })
[13:17:31.687]         }
[13:17:31.687]     }, args = future.call.arguments)
[13:17:31.687] }
[13:17:31.687] Lazy evaluation: FALSE
[13:17:31.687] Asynchronous evaluation: TRUE
[13:17:31.687] Local evaluation: TRUE
[13:17:31.687] Environment: R_GlobalEnv
[13:17:31.687] Capture standard output: TRUE
[13:17:31.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.687] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.687] Packages: 1 packages (‘stats’)
[13:17:31.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.687] Resolved: FALSE
[13:17:31.687] Value: <not collected>
[13:17:31.687] Conditions captured: <none>
[13:17:31.687] Early signaling: FALSE
[13:17:31.687] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.687] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.698] Chunk #1 of 2 ... DONE
[13:17:31.699] Chunk #2 of 2 ...
[13:17:31.699]  - Finding globals in 'X' for chunk #2 ...
[13:17:31.699] getGlobalsAndPackages() ...
[13:17:31.699] Searching for globals...
[13:17:31.699] 
[13:17:31.700] Searching for globals ... DONE
[13:17:31.700] - globals: [0] <none>
[13:17:31.700] getGlobalsAndPackages() ... DONE
[13:17:31.700]    + additional globals found: [n=0] 
[13:17:31.700]    + additional namespaces needed: [n=0] 
[13:17:31.700]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:31.700]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:31.700]  - seeds: <none>
[13:17:31.700] getGlobalsAndPackages() ...
[13:17:31.700] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.701] Resolving globals: FALSE
[13:17:31.701] Tweak future expression to call with '...' arguments ...
[13:17:31.701] {
[13:17:31.701]     do.call(function(...) {
[13:17:31.701]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.701]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.701]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.701]             on.exit(options(oopts), add = TRUE)
[13:17:31.701]         }
[13:17:31.701]         {
[13:17:31.701]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.701]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.701]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.701]             })
[13:17:31.701]         }
[13:17:31.701]     }, args = future.call.arguments)
[13:17:31.701] }
[13:17:31.701] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.701] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.702] 
[13:17:31.702] getGlobalsAndPackages() ... DONE
[13:17:31.702] run() for ‘Future’ ...
[13:17:31.702] - state: ‘created’
[13:17:31.702] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.717] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.717]   - Field: ‘node’
[13:17:31.717]   - Field: ‘label’
[13:17:31.717]   - Field: ‘local’
[13:17:31.717]   - Field: ‘owner’
[13:17:31.718]   - Field: ‘envir’
[13:17:31.718]   - Field: ‘workers’
[13:17:31.718]   - Field: ‘packages’
[13:17:31.718]   - Field: ‘gc’
[13:17:31.718]   - Field: ‘conditions’
[13:17:31.718]   - Field: ‘persistent’
[13:17:31.718]   - Field: ‘expr’
[13:17:31.718]   - Field: ‘uuid’
[13:17:31.719]   - Field: ‘seed’
[13:17:31.719]   - Field: ‘version’
[13:17:31.719]   - Field: ‘result’
[13:17:31.719]   - Field: ‘asynchronous’
[13:17:31.719]   - Field: ‘calls’
[13:17:31.719]   - Field: ‘globals’
[13:17:31.719]   - Field: ‘stdout’
[13:17:31.719]   - Field: ‘earlySignal’
[13:17:31.720]   - Field: ‘lazy’
[13:17:31.720]   - Field: ‘state’
[13:17:31.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.720] - Launch lazy future ...
[13:17:31.720] Packages needed by the future expression (n = 1): ‘stats’
[13:17:31.720] Packages needed by future strategies (n = 0): <none>
[13:17:31.721] {
[13:17:31.721]     {
[13:17:31.721]         {
[13:17:31.721]             ...future.startTime <- base::Sys.time()
[13:17:31.721]             {
[13:17:31.721]                 {
[13:17:31.721]                   {
[13:17:31.721]                     {
[13:17:31.721]                       {
[13:17:31.721]                         base::local({
[13:17:31.721]                           has_future <- base::requireNamespace("future", 
[13:17:31.721]                             quietly = TRUE)
[13:17:31.721]                           if (has_future) {
[13:17:31.721]                             ns <- base::getNamespace("future")
[13:17:31.721]                             version <- ns[[".package"]][["version"]]
[13:17:31.721]                             if (is.null(version)) 
[13:17:31.721]                               version <- utils::packageVersion("future")
[13:17:31.721]                           }
[13:17:31.721]                           else {
[13:17:31.721]                             version <- NULL
[13:17:31.721]                           }
[13:17:31.721]                           if (!has_future || version < "1.8.0") {
[13:17:31.721]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.721]                               "", base::R.version$version.string), 
[13:17:31.721]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:31.721]                                 base::R.version$platform, 8 * 
[13:17:31.721]                                   base::.Machine$sizeof.pointer), 
[13:17:31.721]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.721]                                 "release", "version")], collapse = " "), 
[13:17:31.721]                               hostname = base::Sys.info()[["nodename"]])
[13:17:31.721]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.721]                               info)
[13:17:31.721]                             info <- base::paste(info, collapse = "; ")
[13:17:31.721]                             if (!has_future) {
[13:17:31.721]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.721]                                 info)
[13:17:31.721]                             }
[13:17:31.721]                             else {
[13:17:31.721]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.721]                                 info, version)
[13:17:31.721]                             }
[13:17:31.721]                             base::stop(msg)
[13:17:31.721]                           }
[13:17:31.721]                         })
[13:17:31.721]                       }
[13:17:31.721]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.721]                       base::options(mc.cores = 1L)
[13:17:31.721]                     }
[13:17:31.721]                     base::local({
[13:17:31.721]                       for (pkg in "stats") {
[13:17:31.721]                         base::loadNamespace(pkg)
[13:17:31.721]                         base::library(pkg, character.only = TRUE)
[13:17:31.721]                       }
[13:17:31.721]                     })
[13:17:31.721]                   }
[13:17:31.721]                   options(future.plan = NULL)
[13:17:31.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.721]                 }
[13:17:31.721]                 ...future.workdir <- getwd()
[13:17:31.721]             }
[13:17:31.721]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.721]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.721]         }
[13:17:31.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.721]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:31.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.721]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.721]             base::names(...future.oldOptions))
[13:17:31.721]     }
[13:17:31.721]     if (FALSE) {
[13:17:31.721]     }
[13:17:31.721]     else {
[13:17:31.721]         if (TRUE) {
[13:17:31.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.721]                 open = "w")
[13:17:31.721]         }
[13:17:31.721]         else {
[13:17:31.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.721]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.721]         }
[13:17:31.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.721]             base::sink(type = "output", split = FALSE)
[13:17:31.721]             base::close(...future.stdout)
[13:17:31.721]         }, add = TRUE)
[13:17:31.721]     }
[13:17:31.721]     ...future.frame <- base::sys.nframe()
[13:17:31.721]     ...future.conditions <- base::list()
[13:17:31.721]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.721]     if (FALSE) {
[13:17:31.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.721]     }
[13:17:31.721]     ...future.result <- base::tryCatch({
[13:17:31.721]         base::withCallingHandlers({
[13:17:31.721]             ...future.value <- base::withVisible(base::local({
[13:17:31.721]                 ...future.makeSendCondition <- local({
[13:17:31.721]                   sendCondition <- NULL
[13:17:31.721]                   function(frame = 1L) {
[13:17:31.721]                     if (is.function(sendCondition)) 
[13:17:31.721]                       return(sendCondition)
[13:17:31.721]                     ns <- getNamespace("parallel")
[13:17:31.721]                     if (exists("sendData", mode = "function", 
[13:17:31.721]                       envir = ns)) {
[13:17:31.721]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.721]                         envir = ns)
[13:17:31.721]                       envir <- sys.frame(frame)
[13:17:31.721]                       master <- NULL
[13:17:31.721]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.721]                         !identical(envir, emptyenv())) {
[13:17:31.721]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.721]                           inherits = FALSE)) {
[13:17:31.721]                           master <- get("master", mode = "list", 
[13:17:31.721]                             envir = envir, inherits = FALSE)
[13:17:31.721]                           if (inherits(master, c("SOCKnode", 
[13:17:31.721]                             "SOCK0node"))) {
[13:17:31.721]                             sendCondition <<- function(cond) {
[13:17:31.721]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.721]                                 success = TRUE)
[13:17:31.721]                               parallel_sendData(master, data)
[13:17:31.721]                             }
[13:17:31.721]                             return(sendCondition)
[13:17:31.721]                           }
[13:17:31.721]                         }
[13:17:31.721]                         frame <- frame + 1L
[13:17:31.721]                         envir <- sys.frame(frame)
[13:17:31.721]                       }
[13:17:31.721]                     }
[13:17:31.721]                     sendCondition <<- function(cond) NULL
[13:17:31.721]                   }
[13:17:31.721]                 })
[13:17:31.721]                 withCallingHandlers({
[13:17:31.721]                   {
[13:17:31.721]                     do.call(function(...) {
[13:17:31.721]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.721]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.721]                         ...future.globals.maxSize)) {
[13:17:31.721]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.721]                         on.exit(options(oopts), add = TRUE)
[13:17:31.721]                       }
[13:17:31.721]                       {
[13:17:31.721]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.721]                           FUN = function(jj) {
[13:17:31.721]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.721]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.721]                           })
[13:17:31.721]                       }
[13:17:31.721]                     }, args = future.call.arguments)
[13:17:31.721]                   }
[13:17:31.721]                 }, immediateCondition = function(cond) {
[13:17:31.721]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.721]                   sendCondition(cond)
[13:17:31.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.721]                   {
[13:17:31.721]                     inherits <- base::inherits
[13:17:31.721]                     invokeRestart <- base::invokeRestart
[13:17:31.721]                     is.null <- base::is.null
[13:17:31.721]                     muffled <- FALSE
[13:17:31.721]                     if (inherits(cond, "message")) {
[13:17:31.721]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.721]                       if (muffled) 
[13:17:31.721]                         invokeRestart("muffleMessage")
[13:17:31.721]                     }
[13:17:31.721]                     else if (inherits(cond, "warning")) {
[13:17:31.721]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.721]                       if (muffled) 
[13:17:31.721]                         invokeRestart("muffleWarning")
[13:17:31.721]                     }
[13:17:31.721]                     else if (inherits(cond, "condition")) {
[13:17:31.721]                       if (!is.null(pattern)) {
[13:17:31.721]                         computeRestarts <- base::computeRestarts
[13:17:31.721]                         grepl <- base::grepl
[13:17:31.721]                         restarts <- computeRestarts(cond)
[13:17:31.721]                         for (restart in restarts) {
[13:17:31.721]                           name <- restart$name
[13:17:31.721]                           if (is.null(name)) 
[13:17:31.721]                             next
[13:17:31.721]                           if (!grepl(pattern, name)) 
[13:17:31.721]                             next
[13:17:31.721]                           invokeRestart(restart)
[13:17:31.721]                           muffled <- TRUE
[13:17:31.721]                           break
[13:17:31.721]                         }
[13:17:31.721]                       }
[13:17:31.721]                     }
[13:17:31.721]                     invisible(muffled)
[13:17:31.721]                   }
[13:17:31.721]                   muffleCondition(cond)
[13:17:31.721]                 })
[13:17:31.721]             }))
[13:17:31.721]             future::FutureResult(value = ...future.value$value, 
[13:17:31.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.721]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.721]                     ...future.globalenv.names))
[13:17:31.721]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.721]         }, condition = base::local({
[13:17:31.721]             c <- base::c
[13:17:31.721]             inherits <- base::inherits
[13:17:31.721]             invokeRestart <- base::invokeRestart
[13:17:31.721]             length <- base::length
[13:17:31.721]             list <- base::list
[13:17:31.721]             seq.int <- base::seq.int
[13:17:31.721]             signalCondition <- base::signalCondition
[13:17:31.721]             sys.calls <- base::sys.calls
[13:17:31.721]             `[[` <- base::`[[`
[13:17:31.721]             `+` <- base::`+`
[13:17:31.721]             `<<-` <- base::`<<-`
[13:17:31.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.721]                   3L)]
[13:17:31.721]             }
[13:17:31.721]             function(cond) {
[13:17:31.721]                 is_error <- inherits(cond, "error")
[13:17:31.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.721]                   NULL)
[13:17:31.721]                 if (is_error) {
[13:17:31.721]                   sessionInformation <- function() {
[13:17:31.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.721]                       search = base::search(), system = base::Sys.info())
[13:17:31.721]                   }
[13:17:31.721]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.721]                     cond$call), session = sessionInformation(), 
[13:17:31.721]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.721]                   signalCondition(cond)
[13:17:31.721]                 }
[13:17:31.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.721]                 "immediateCondition"))) {
[13:17:31.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.721]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.721]                   if (TRUE && !signal) {
[13:17:31.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.721]                     {
[13:17:31.721]                       inherits <- base::inherits
[13:17:31.721]                       invokeRestart <- base::invokeRestart
[13:17:31.721]                       is.null <- base::is.null
[13:17:31.721]                       muffled <- FALSE
[13:17:31.721]                       if (inherits(cond, "message")) {
[13:17:31.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.721]                         if (muffled) 
[13:17:31.721]                           invokeRestart("muffleMessage")
[13:17:31.721]                       }
[13:17:31.721]                       else if (inherits(cond, "warning")) {
[13:17:31.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.721]                         if (muffled) 
[13:17:31.721]                           invokeRestart("muffleWarning")
[13:17:31.721]                       }
[13:17:31.721]                       else if (inherits(cond, "condition")) {
[13:17:31.721]                         if (!is.null(pattern)) {
[13:17:31.721]                           computeRestarts <- base::computeRestarts
[13:17:31.721]                           grepl <- base::grepl
[13:17:31.721]                           restarts <- computeRestarts(cond)
[13:17:31.721]                           for (restart in restarts) {
[13:17:31.721]                             name <- restart$name
[13:17:31.721]                             if (is.null(name)) 
[13:17:31.721]                               next
[13:17:31.721]                             if (!grepl(pattern, name)) 
[13:17:31.721]                               next
[13:17:31.721]                             invokeRestart(restart)
[13:17:31.721]                             muffled <- TRUE
[13:17:31.721]                             break
[13:17:31.721]                           }
[13:17:31.721]                         }
[13:17:31.721]                       }
[13:17:31.721]                       invisible(muffled)
[13:17:31.721]                     }
[13:17:31.721]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.721]                   }
[13:17:31.721]                 }
[13:17:31.721]                 else {
[13:17:31.721]                   if (TRUE) {
[13:17:31.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.721]                     {
[13:17:31.721]                       inherits <- base::inherits
[13:17:31.721]                       invokeRestart <- base::invokeRestart
[13:17:31.721]                       is.null <- base::is.null
[13:17:31.721]                       muffled <- FALSE
[13:17:31.721]                       if (inherits(cond, "message")) {
[13:17:31.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.721]                         if (muffled) 
[13:17:31.721]                           invokeRestart("muffleMessage")
[13:17:31.721]                       }
[13:17:31.721]                       else if (inherits(cond, "warning")) {
[13:17:31.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.721]                         if (muffled) 
[13:17:31.721]                           invokeRestart("muffleWarning")
[13:17:31.721]                       }
[13:17:31.721]                       else if (inherits(cond, "condition")) {
[13:17:31.721]                         if (!is.null(pattern)) {
[13:17:31.721]                           computeRestarts <- base::computeRestarts
[13:17:31.721]                           grepl <- base::grepl
[13:17:31.721]                           restarts <- computeRestarts(cond)
[13:17:31.721]                           for (restart in restarts) {
[13:17:31.721]                             name <- restart$name
[13:17:31.721]                             if (is.null(name)) 
[13:17:31.721]                               next
[13:17:31.721]                             if (!grepl(pattern, name)) 
[13:17:31.721]                               next
[13:17:31.721]                             invokeRestart(restart)
[13:17:31.721]                             muffled <- TRUE
[13:17:31.721]                             break
[13:17:31.721]                           }
[13:17:31.721]                         }
[13:17:31.721]                       }
[13:17:31.721]                       invisible(muffled)
[13:17:31.721]                     }
[13:17:31.721]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.721]                   }
[13:17:31.721]                 }
[13:17:31.721]             }
[13:17:31.721]         }))
[13:17:31.721]     }, error = function(ex) {
[13:17:31.721]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.721]                 ...future.rng), started = ...future.startTime, 
[13:17:31.721]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.721]             version = "1.8"), class = "FutureResult")
[13:17:31.721]     }, finally = {
[13:17:31.721]         if (!identical(...future.workdir, getwd())) 
[13:17:31.721]             setwd(...future.workdir)
[13:17:31.721]         {
[13:17:31.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.721]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.721]             }
[13:17:31.721]             base::options(...future.oldOptions)
[13:17:31.721]             if (.Platform$OS.type == "windows") {
[13:17:31.721]                 old_names <- names(...future.oldEnvVars)
[13:17:31.721]                 envs <- base::Sys.getenv()
[13:17:31.721]                 names <- names(envs)
[13:17:31.721]                 common <- intersect(names, old_names)
[13:17:31.721]                 added <- setdiff(names, old_names)
[13:17:31.721]                 removed <- setdiff(old_names, names)
[13:17:31.721]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.721]                   envs[common]]
[13:17:31.721]                 NAMES <- toupper(changed)
[13:17:31.721]                 args <- list()
[13:17:31.721]                 for (kk in seq_along(NAMES)) {
[13:17:31.721]                   name <- changed[[kk]]
[13:17:31.721]                   NAME <- NAMES[[kk]]
[13:17:31.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.721]                     next
[13:17:31.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.721]                 }
[13:17:31.721]                 NAMES <- toupper(added)
[13:17:31.721]                 for (kk in seq_along(NAMES)) {
[13:17:31.721]                   name <- added[[kk]]
[13:17:31.721]                   NAME <- NAMES[[kk]]
[13:17:31.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.721]                     next
[13:17:31.721]                   args[[name]] <- ""
[13:17:31.721]                 }
[13:17:31.721]                 NAMES <- toupper(removed)
[13:17:31.721]                 for (kk in seq_along(NAMES)) {
[13:17:31.721]                   name <- removed[[kk]]
[13:17:31.721]                   NAME <- NAMES[[kk]]
[13:17:31.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.721]                     next
[13:17:31.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.721]                 }
[13:17:31.721]                 if (length(args) > 0) 
[13:17:31.721]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.721]             }
[13:17:31.721]             else {
[13:17:31.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.721]             }
[13:17:31.721]             {
[13:17:31.721]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.721]                   0L) {
[13:17:31.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.721]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.721]                   base::options(opts)
[13:17:31.721]                 }
[13:17:31.721]                 {
[13:17:31.721]                   {
[13:17:31.721]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.721]                     NULL
[13:17:31.721]                   }
[13:17:31.721]                   options(future.plan = NULL)
[13:17:31.721]                   if (is.na(NA_character_)) 
[13:17:31.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.721]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.721]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.721]                     envir = parent.frame()) 
[13:17:31.721]                   {
[13:17:31.721]                     if (is.function(workers)) 
[13:17:31.721]                       workers <- workers()
[13:17:31.721]                     workers <- structure(as.integer(workers), 
[13:17:31.721]                       class = class(workers))
[13:17:31.721]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.721]                       workers >= 1)
[13:17:31.721]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.721]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.721]                     }
[13:17:31.721]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.721]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.721]                       envir = envir)
[13:17:31.721]                     if (!future$lazy) 
[13:17:31.721]                       future <- run(future)
[13:17:31.721]                     invisible(future)
[13:17:31.721]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.721]                 }
[13:17:31.721]             }
[13:17:31.721]         }
[13:17:31.721]     })
[13:17:31.721]     if (TRUE) {
[13:17:31.721]         base::sink(type = "output", split = FALSE)
[13:17:31.721]         if (TRUE) {
[13:17:31.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.721]         }
[13:17:31.721]         else {
[13:17:31.721]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.721]         }
[13:17:31.721]         base::close(...future.stdout)
[13:17:31.721]         ...future.stdout <- NULL
[13:17:31.721]     }
[13:17:31.721]     ...future.result$conditions <- ...future.conditions
[13:17:31.721]     ...future.result$finished <- base::Sys.time()
[13:17:31.721]     ...future.result
[13:17:31.721] }
[13:17:31.725] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[13:17:31.725] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[13:17:31.725] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[13:17:31.726] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[13:17:31.726] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[13:17:31.726] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:17:31.726] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:17:31.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:31.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:31.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.727] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[13:17:31.728] MultisessionFuture started
[13:17:31.728] - Launch lazy future ... done
[13:17:31.728] run() for ‘MultisessionFuture’ ... done
[13:17:31.728] Created future:
[13:17:31.728] MultisessionFuture:
[13:17:31.728] Label: ‘future_by-2’
[13:17:31.728] Expression:
[13:17:31.728] {
[13:17:31.728]     do.call(function(...) {
[13:17:31.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.728]             on.exit(options(oopts), add = TRUE)
[13:17:31.728]         }
[13:17:31.728]         {
[13:17:31.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.728]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.728]             })
[13:17:31.728]         }
[13:17:31.728]     }, args = future.call.arguments)
[13:17:31.728] }
[13:17:31.728] Lazy evaluation: FALSE
[13:17:31.728] Asynchronous evaluation: TRUE
[13:17:31.728] Local evaluation: TRUE
[13:17:31.728] Environment: R_GlobalEnv
[13:17:31.728] Capture standard output: TRUE
[13:17:31.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.728] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.728] Packages: 1 packages (‘stats’)
[13:17:31.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.728] Resolved: FALSE
[13:17:31.728] Value: <not collected>
[13:17:31.728] Conditions captured: <none>
[13:17:31.728] Early signaling: FALSE
[13:17:31.728] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.728] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.740] Chunk #2 of 2 ... DONE
[13:17:31.740] Launching 2 futures (chunks) ... DONE
[13:17:31.740] Resolving 2 futures (chunks) ...
[13:17:31.740] resolve() on list ...
[13:17:31.740]  recursive: 0
[13:17:31.741]  length: 2
[13:17:31.741] 
[13:17:31.741] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.741] - Validating connection of MultisessionFuture
[13:17:31.742] - received message: FutureResult
[13:17:31.742] - Received FutureResult
[13:17:31.742] - Erased future from FutureRegistry
[13:17:31.742] result() for ClusterFuture ...
[13:17:31.742] - result already collected: FutureResult
[13:17:31.742] result() for ClusterFuture ... done
[13:17:31.742] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.742] Future #1
[13:17:31.743] result() for ClusterFuture ...
[13:17:31.743] - result already collected: FutureResult
[13:17:31.743] result() for ClusterFuture ... done
[13:17:31.743] result() for ClusterFuture ...
[13:17:31.743] - result already collected: FutureResult
[13:17:31.743] result() for ClusterFuture ... done
[13:17:31.743] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:31.743] - nx: 2
[13:17:31.743] - relay: TRUE
[13:17:31.743] - stdout: TRUE
[13:17:31.743] - signal: TRUE
[13:17:31.743] - resignal: FALSE
[13:17:31.744] - force: TRUE
[13:17:31.744] - relayed: [n=2] FALSE, FALSE
[13:17:31.744] - queued futures: [n=2] FALSE, FALSE
[13:17:31.744]  - until=1
[13:17:31.744]  - relaying element #1
[13:17:31.744] result() for ClusterFuture ...
[13:17:31.744] - result already collected: FutureResult
[13:17:31.744] result() for ClusterFuture ... done
[13:17:31.744] result() for ClusterFuture ...
[13:17:31.744] - result already collected: FutureResult
[13:17:31.744] result() for ClusterFuture ... done
[13:17:31.745] result() for ClusterFuture ...
[13:17:31.745] - result already collected: FutureResult
[13:17:31.745] result() for ClusterFuture ... done
[13:17:31.745] result() for ClusterFuture ...
[13:17:31.745] - result already collected: FutureResult
[13:17:31.745] result() for ClusterFuture ... done
[13:17:31.745] - relayed: [n=2] TRUE, FALSE
[13:17:31.745] - queued futures: [n=2] TRUE, FALSE
[13:17:31.745] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:31.745]  length: 1 (resolved future 1)
[13:17:31.787] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.787] - Validating connection of MultisessionFuture
[13:17:31.787] - received message: FutureResult
[13:17:31.788] - Received FutureResult
[13:17:31.788] - Erased future from FutureRegistry
[13:17:31.788] result() for ClusterFuture ...
[13:17:31.788] - result already collected: FutureResult
[13:17:31.788] result() for ClusterFuture ... done
[13:17:31.788] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.788] Future #2
[13:17:31.788] result() for ClusterFuture ...
[13:17:31.788] - result already collected: FutureResult
[13:17:31.788] result() for ClusterFuture ... done
[13:17:31.788] result() for ClusterFuture ...
[13:17:31.789] - result already collected: FutureResult
[13:17:31.789] result() for ClusterFuture ... done
[13:17:31.789] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:31.789] - nx: 2
[13:17:31.789] - relay: TRUE
[13:17:31.789] - stdout: TRUE
[13:17:31.789] - signal: TRUE
[13:17:31.789] - resignal: FALSE
[13:17:31.789] - force: TRUE
[13:17:31.789] - relayed: [n=2] TRUE, FALSE
[13:17:31.789] - queued futures: [n=2] TRUE, FALSE
[13:17:31.790]  - until=2
[13:17:31.790]  - relaying element #2
[13:17:31.790] result() for ClusterFuture ...
[13:17:31.790] - result already collected: FutureResult
[13:17:31.790] result() for ClusterFuture ... done
[13:17:31.790] result() for ClusterFuture ...
[13:17:31.790] - result already collected: FutureResult
[13:17:31.790] result() for ClusterFuture ... done
[13:17:31.790] result() for ClusterFuture ...
[13:17:31.790] - result already collected: FutureResult
[13:17:31.790] result() for ClusterFuture ... done
[13:17:31.791] result() for ClusterFuture ...
[13:17:31.791] - result already collected: FutureResult
[13:17:31.791] result() for ClusterFuture ... done
[13:17:31.791] - relayed: [n=2] TRUE, TRUE
[13:17:31.791] - queued futures: [n=2] TRUE, TRUE
[13:17:31.791] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:31.791]  length: 0 (resolved future 2)
[13:17:31.791] Relaying remaining futures
[13:17:31.791] signalConditionsASAP(NULL, pos=0) ...
[13:17:31.791] - nx: 2
[13:17:31.791] - relay: TRUE
[13:17:31.791] - stdout: TRUE
[13:17:31.792] - signal: TRUE
[13:17:31.792] - resignal: FALSE
[13:17:31.792] - force: TRUE
[13:17:31.792] - relayed: [n=2] TRUE, TRUE
[13:17:31.792] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:31.792] - relayed: [n=2] TRUE, TRUE
[13:17:31.792] - queued futures: [n=2] TRUE, TRUE
[13:17:31.792] signalConditionsASAP(NULL, pos=0) ... done
[13:17:31.792] resolve() on list ... DONE
[13:17:31.792] result() for ClusterFuture ...
[13:17:31.792] - result already collected: FutureResult
[13:17:31.792] result() for ClusterFuture ... done
[13:17:31.793] result() for ClusterFuture ...
[13:17:31.793] - result already collected: FutureResult
[13:17:31.793] result() for ClusterFuture ... done
[13:17:31.793] result() for ClusterFuture ...
[13:17:31.793] - result already collected: FutureResult
[13:17:31.793] result() for ClusterFuture ... done
[13:17:31.793] result() for ClusterFuture ...
[13:17:31.793] - result already collected: FutureResult
[13:17:31.793] result() for ClusterFuture ... done
[13:17:31.793]  - Number of value chunks collected: 2
[13:17:31.794] Resolving 2 futures (chunks) ... DONE
[13:17:31.794] Reducing values from 2 chunks ...
[13:17:31.794]  - Number of values collected after concatenation: 3
[13:17:31.794]  - Number of values expected: 3
[13:17:31.794] Reducing values from 2 chunks ... DONE
[13:17:31.794] future_lapply() ... DONE
[13:17:31.794] future_by_internal() ... DONE
[13:17:31.798] future_by_internal() ...
[13:17:31.798] future_lapply() ...
[13:17:31.803] Number of chunks: 2
[13:17:31.803] getGlobalsAndPackagesXApply() ...
[13:17:31.803]  - future.globals: TRUE
[13:17:31.803] getGlobalsAndPackages() ...
[13:17:31.803] Searching for globals...
[13:17:31.805] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:17:31.805] Searching for globals ... DONE
[13:17:31.805] Resolving globals: FALSE
[13:17:31.805] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:17:31.806] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:17:31.806] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:31.806] - packages: [1] ‘stats’
[13:17:31.806] getGlobalsAndPackages() ... DONE
[13:17:31.806]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:17:31.806]  - needed namespaces: [n=1] ‘stats’
[13:17:31.806] Finding globals ... DONE
[13:17:31.807]  - use_args: TRUE
[13:17:31.807]  - Getting '...' globals ...
[13:17:31.807] resolve() on list ...
[13:17:31.807]  recursive: 0
[13:17:31.807]  length: 1
[13:17:31.807]  elements: ‘...’
[13:17:31.807]  length: 0 (resolved future 1)
[13:17:31.807] resolve() on list ... DONE
[13:17:31.808]    - '...' content: [n=0] 
[13:17:31.808] List of 1
[13:17:31.808]  $ ...: list()
[13:17:31.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.808]  - attr(*, "where")=List of 1
[13:17:31.808]   ..$ ...:<environment: 0x5609eb1e19c0> 
[13:17:31.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.808]  - attr(*, "resolved")= logi TRUE
[13:17:31.808]  - attr(*, "total_size")= num NA
[13:17:31.810]  - Getting '...' globals ... DONE
[13:17:31.810] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:17:31.810] List of 4
[13:17:31.810]  $ ...future.FUN:function (x)  
[13:17:31.810]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:17:31.810]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:17:31.810]  $ ...          : list()
[13:17:31.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.810]  - attr(*, "where")=List of 4
[13:17:31.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:31.810]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:17:31.810]   ..$ wool         :<environment: R_EmptyEnv> 
[13:17:31.810]   ..$ ...          :<environment: 0x5609eb1e19c0> 
[13:17:31.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.810]  - attr(*, "resolved")= logi FALSE
[13:17:31.810]  - attr(*, "total_size")= num 2320
[13:17:31.814] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:31.814] getGlobalsAndPackagesXApply() ... DONE
[13:17:31.814] Number of futures (= number of chunks): 2
[13:17:31.815] Launching 2 futures (chunks) ...
[13:17:31.815] Chunk #1 of 2 ...
[13:17:31.815]  - Finding globals in 'X' for chunk #1 ...
[13:17:31.815] getGlobalsAndPackages() ...
[13:17:31.815] Searching for globals...
[13:17:31.815] 
[13:17:31.815] Searching for globals ... DONE
[13:17:31.816] - globals: [0] <none>
[13:17:31.816] getGlobalsAndPackages() ... DONE
[13:17:31.816]    + additional globals found: [n=0] 
[13:17:31.816]    + additional namespaces needed: [n=0] 
[13:17:31.816]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:31.816]  - seeds: <none>
[13:17:31.816] getGlobalsAndPackages() ...
[13:17:31.816] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.816] Resolving globals: FALSE
[13:17:31.816] Tweak future expression to call with '...' arguments ...
[13:17:31.816] {
[13:17:31.816]     do.call(function(...) {
[13:17:31.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.816]             on.exit(options(oopts), add = TRUE)
[13:17:31.816]         }
[13:17:31.816]         {
[13:17:31.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.816]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.816]             })
[13:17:31.816]         }
[13:17:31.816]     }, args = future.call.arguments)
[13:17:31.816] }
[13:17:31.817] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.817] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.817] 
[13:17:31.817] getGlobalsAndPackages() ... DONE
[13:17:31.818] run() for ‘Future’ ...
[13:17:31.818] - state: ‘created’
[13:17:31.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.832]   - Field: ‘node’
[13:17:31.833]   - Field: ‘label’
[13:17:31.833]   - Field: ‘local’
[13:17:31.833]   - Field: ‘owner’
[13:17:31.833]   - Field: ‘envir’
[13:17:31.833]   - Field: ‘workers’
[13:17:31.833]   - Field: ‘packages’
[13:17:31.833]   - Field: ‘gc’
[13:17:31.833]   - Field: ‘conditions’
[13:17:31.833]   - Field: ‘persistent’
[13:17:31.833]   - Field: ‘expr’
[13:17:31.834]   - Field: ‘uuid’
[13:17:31.834]   - Field: ‘seed’
[13:17:31.834]   - Field: ‘version’
[13:17:31.834]   - Field: ‘result’
[13:17:31.834]   - Field: ‘asynchronous’
[13:17:31.834]   - Field: ‘calls’
[13:17:31.834]   - Field: ‘globals’
[13:17:31.834]   - Field: ‘stdout’
[13:17:31.834]   - Field: ‘earlySignal’
[13:17:31.834]   - Field: ‘lazy’
[13:17:31.834]   - Field: ‘state’
[13:17:31.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.835] - Launch lazy future ...
[13:17:31.835] Packages needed by the future expression (n = 1): ‘stats’
[13:17:31.835] Packages needed by future strategies (n = 0): <none>
[13:17:31.838] {
[13:17:31.838]     {
[13:17:31.838]         {
[13:17:31.838]             ...future.startTime <- base::Sys.time()
[13:17:31.838]             {
[13:17:31.838]                 {
[13:17:31.838]                   {
[13:17:31.838]                     {
[13:17:31.838]                       {
[13:17:31.838]                         base::local({
[13:17:31.838]                           has_future <- base::requireNamespace("future", 
[13:17:31.838]                             quietly = TRUE)
[13:17:31.838]                           if (has_future) {
[13:17:31.838]                             ns <- base::getNamespace("future")
[13:17:31.838]                             version <- ns[[".package"]][["version"]]
[13:17:31.838]                             if (is.null(version)) 
[13:17:31.838]                               version <- utils::packageVersion("future")
[13:17:31.838]                           }
[13:17:31.838]                           else {
[13:17:31.838]                             version <- NULL
[13:17:31.838]                           }
[13:17:31.838]                           if (!has_future || version < "1.8.0") {
[13:17:31.838]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.838]                               "", base::R.version$version.string), 
[13:17:31.838]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:31.838]                                 base::R.version$platform, 8 * 
[13:17:31.838]                                   base::.Machine$sizeof.pointer), 
[13:17:31.838]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.838]                                 "release", "version")], collapse = " "), 
[13:17:31.838]                               hostname = base::Sys.info()[["nodename"]])
[13:17:31.838]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.838]                               info)
[13:17:31.838]                             info <- base::paste(info, collapse = "; ")
[13:17:31.838]                             if (!has_future) {
[13:17:31.838]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.838]                                 info)
[13:17:31.838]                             }
[13:17:31.838]                             else {
[13:17:31.838]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.838]                                 info, version)
[13:17:31.838]                             }
[13:17:31.838]                             base::stop(msg)
[13:17:31.838]                           }
[13:17:31.838]                         })
[13:17:31.838]                       }
[13:17:31.838]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.838]                       base::options(mc.cores = 1L)
[13:17:31.838]                     }
[13:17:31.838]                     base::local({
[13:17:31.838]                       for (pkg in "stats") {
[13:17:31.838]                         base::loadNamespace(pkg)
[13:17:31.838]                         base::library(pkg, character.only = TRUE)
[13:17:31.838]                       }
[13:17:31.838]                     })
[13:17:31.838]                   }
[13:17:31.838]                   options(future.plan = NULL)
[13:17:31.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.838]                 }
[13:17:31.838]                 ...future.workdir <- getwd()
[13:17:31.838]             }
[13:17:31.838]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.838]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.838]         }
[13:17:31.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:31.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.838]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.838]             base::names(...future.oldOptions))
[13:17:31.838]     }
[13:17:31.838]     if (FALSE) {
[13:17:31.838]     }
[13:17:31.838]     else {
[13:17:31.838]         if (TRUE) {
[13:17:31.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.838]                 open = "w")
[13:17:31.838]         }
[13:17:31.838]         else {
[13:17:31.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.838]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.838]         }
[13:17:31.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.838]             base::sink(type = "output", split = FALSE)
[13:17:31.838]             base::close(...future.stdout)
[13:17:31.838]         }, add = TRUE)
[13:17:31.838]     }
[13:17:31.838]     ...future.frame <- base::sys.nframe()
[13:17:31.838]     ...future.conditions <- base::list()
[13:17:31.838]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.838]     if (FALSE) {
[13:17:31.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.838]     }
[13:17:31.838]     ...future.result <- base::tryCatch({
[13:17:31.838]         base::withCallingHandlers({
[13:17:31.838]             ...future.value <- base::withVisible(base::local({
[13:17:31.838]                 ...future.makeSendCondition <- local({
[13:17:31.838]                   sendCondition <- NULL
[13:17:31.838]                   function(frame = 1L) {
[13:17:31.838]                     if (is.function(sendCondition)) 
[13:17:31.838]                       return(sendCondition)
[13:17:31.838]                     ns <- getNamespace("parallel")
[13:17:31.838]                     if (exists("sendData", mode = "function", 
[13:17:31.838]                       envir = ns)) {
[13:17:31.838]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.838]                         envir = ns)
[13:17:31.838]                       envir <- sys.frame(frame)
[13:17:31.838]                       master <- NULL
[13:17:31.838]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.838]                         !identical(envir, emptyenv())) {
[13:17:31.838]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.838]                           inherits = FALSE)) {
[13:17:31.838]                           master <- get("master", mode = "list", 
[13:17:31.838]                             envir = envir, inherits = FALSE)
[13:17:31.838]                           if (inherits(master, c("SOCKnode", 
[13:17:31.838]                             "SOCK0node"))) {
[13:17:31.838]                             sendCondition <<- function(cond) {
[13:17:31.838]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.838]                                 success = TRUE)
[13:17:31.838]                               parallel_sendData(master, data)
[13:17:31.838]                             }
[13:17:31.838]                             return(sendCondition)
[13:17:31.838]                           }
[13:17:31.838]                         }
[13:17:31.838]                         frame <- frame + 1L
[13:17:31.838]                         envir <- sys.frame(frame)
[13:17:31.838]                       }
[13:17:31.838]                     }
[13:17:31.838]                     sendCondition <<- function(cond) NULL
[13:17:31.838]                   }
[13:17:31.838]                 })
[13:17:31.838]                 withCallingHandlers({
[13:17:31.838]                   {
[13:17:31.838]                     do.call(function(...) {
[13:17:31.838]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.838]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.838]                         ...future.globals.maxSize)) {
[13:17:31.838]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.838]                         on.exit(options(oopts), add = TRUE)
[13:17:31.838]                       }
[13:17:31.838]                       {
[13:17:31.838]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.838]                           FUN = function(jj) {
[13:17:31.838]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.838]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.838]                           })
[13:17:31.838]                       }
[13:17:31.838]                     }, args = future.call.arguments)
[13:17:31.838]                   }
[13:17:31.838]                 }, immediateCondition = function(cond) {
[13:17:31.838]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.838]                   sendCondition(cond)
[13:17:31.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.838]                   {
[13:17:31.838]                     inherits <- base::inherits
[13:17:31.838]                     invokeRestart <- base::invokeRestart
[13:17:31.838]                     is.null <- base::is.null
[13:17:31.838]                     muffled <- FALSE
[13:17:31.838]                     if (inherits(cond, "message")) {
[13:17:31.838]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.838]                       if (muffled) 
[13:17:31.838]                         invokeRestart("muffleMessage")
[13:17:31.838]                     }
[13:17:31.838]                     else if (inherits(cond, "warning")) {
[13:17:31.838]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.838]                       if (muffled) 
[13:17:31.838]                         invokeRestart("muffleWarning")
[13:17:31.838]                     }
[13:17:31.838]                     else if (inherits(cond, "condition")) {
[13:17:31.838]                       if (!is.null(pattern)) {
[13:17:31.838]                         computeRestarts <- base::computeRestarts
[13:17:31.838]                         grepl <- base::grepl
[13:17:31.838]                         restarts <- computeRestarts(cond)
[13:17:31.838]                         for (restart in restarts) {
[13:17:31.838]                           name <- restart$name
[13:17:31.838]                           if (is.null(name)) 
[13:17:31.838]                             next
[13:17:31.838]                           if (!grepl(pattern, name)) 
[13:17:31.838]                             next
[13:17:31.838]                           invokeRestart(restart)
[13:17:31.838]                           muffled <- TRUE
[13:17:31.838]                           break
[13:17:31.838]                         }
[13:17:31.838]                       }
[13:17:31.838]                     }
[13:17:31.838]                     invisible(muffled)
[13:17:31.838]                   }
[13:17:31.838]                   muffleCondition(cond)
[13:17:31.838]                 })
[13:17:31.838]             }))
[13:17:31.838]             future::FutureResult(value = ...future.value$value, 
[13:17:31.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.838]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.838]                     ...future.globalenv.names))
[13:17:31.838]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.838]         }, condition = base::local({
[13:17:31.838]             c <- base::c
[13:17:31.838]             inherits <- base::inherits
[13:17:31.838]             invokeRestart <- base::invokeRestart
[13:17:31.838]             length <- base::length
[13:17:31.838]             list <- base::list
[13:17:31.838]             seq.int <- base::seq.int
[13:17:31.838]             signalCondition <- base::signalCondition
[13:17:31.838]             sys.calls <- base::sys.calls
[13:17:31.838]             `[[` <- base::`[[`
[13:17:31.838]             `+` <- base::`+`
[13:17:31.838]             `<<-` <- base::`<<-`
[13:17:31.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.838]                   3L)]
[13:17:31.838]             }
[13:17:31.838]             function(cond) {
[13:17:31.838]                 is_error <- inherits(cond, "error")
[13:17:31.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.838]                   NULL)
[13:17:31.838]                 if (is_error) {
[13:17:31.838]                   sessionInformation <- function() {
[13:17:31.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.838]                       search = base::search(), system = base::Sys.info())
[13:17:31.838]                   }
[13:17:31.838]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.838]                     cond$call), session = sessionInformation(), 
[13:17:31.838]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.838]                   signalCondition(cond)
[13:17:31.838]                 }
[13:17:31.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.838]                 "immediateCondition"))) {
[13:17:31.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.838]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.838]                   if (TRUE && !signal) {
[13:17:31.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.838]                     {
[13:17:31.838]                       inherits <- base::inherits
[13:17:31.838]                       invokeRestart <- base::invokeRestart
[13:17:31.838]                       is.null <- base::is.null
[13:17:31.838]                       muffled <- FALSE
[13:17:31.838]                       if (inherits(cond, "message")) {
[13:17:31.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.838]                         if (muffled) 
[13:17:31.838]                           invokeRestart("muffleMessage")
[13:17:31.838]                       }
[13:17:31.838]                       else if (inherits(cond, "warning")) {
[13:17:31.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.838]                         if (muffled) 
[13:17:31.838]                           invokeRestart("muffleWarning")
[13:17:31.838]                       }
[13:17:31.838]                       else if (inherits(cond, "condition")) {
[13:17:31.838]                         if (!is.null(pattern)) {
[13:17:31.838]                           computeRestarts <- base::computeRestarts
[13:17:31.838]                           grepl <- base::grepl
[13:17:31.838]                           restarts <- computeRestarts(cond)
[13:17:31.838]                           for (restart in restarts) {
[13:17:31.838]                             name <- restart$name
[13:17:31.838]                             if (is.null(name)) 
[13:17:31.838]                               next
[13:17:31.838]                             if (!grepl(pattern, name)) 
[13:17:31.838]                               next
[13:17:31.838]                             invokeRestart(restart)
[13:17:31.838]                             muffled <- TRUE
[13:17:31.838]                             break
[13:17:31.838]                           }
[13:17:31.838]                         }
[13:17:31.838]                       }
[13:17:31.838]                       invisible(muffled)
[13:17:31.838]                     }
[13:17:31.838]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.838]                   }
[13:17:31.838]                 }
[13:17:31.838]                 else {
[13:17:31.838]                   if (TRUE) {
[13:17:31.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.838]                     {
[13:17:31.838]                       inherits <- base::inherits
[13:17:31.838]                       invokeRestart <- base::invokeRestart
[13:17:31.838]                       is.null <- base::is.null
[13:17:31.838]                       muffled <- FALSE
[13:17:31.838]                       if (inherits(cond, "message")) {
[13:17:31.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.838]                         if (muffled) 
[13:17:31.838]                           invokeRestart("muffleMessage")
[13:17:31.838]                       }
[13:17:31.838]                       else if (inherits(cond, "warning")) {
[13:17:31.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.838]                         if (muffled) 
[13:17:31.838]                           invokeRestart("muffleWarning")
[13:17:31.838]                       }
[13:17:31.838]                       else if (inherits(cond, "condition")) {
[13:17:31.838]                         if (!is.null(pattern)) {
[13:17:31.838]                           computeRestarts <- base::computeRestarts
[13:17:31.838]                           grepl <- base::grepl
[13:17:31.838]                           restarts <- computeRestarts(cond)
[13:17:31.838]                           for (restart in restarts) {
[13:17:31.838]                             name <- restart$name
[13:17:31.838]                             if (is.null(name)) 
[13:17:31.838]                               next
[13:17:31.838]                             if (!grepl(pattern, name)) 
[13:17:31.838]                               next
[13:17:31.838]                             invokeRestart(restart)
[13:17:31.838]                             muffled <- TRUE
[13:17:31.838]                             break
[13:17:31.838]                           }
[13:17:31.838]                         }
[13:17:31.838]                       }
[13:17:31.838]                       invisible(muffled)
[13:17:31.838]                     }
[13:17:31.838]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.838]                   }
[13:17:31.838]                 }
[13:17:31.838]             }
[13:17:31.838]         }))
[13:17:31.838]     }, error = function(ex) {
[13:17:31.838]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.838]                 ...future.rng), started = ...future.startTime, 
[13:17:31.838]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.838]             version = "1.8"), class = "FutureResult")
[13:17:31.838]     }, finally = {
[13:17:31.838]         if (!identical(...future.workdir, getwd())) 
[13:17:31.838]             setwd(...future.workdir)
[13:17:31.838]         {
[13:17:31.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.838]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.838]             }
[13:17:31.838]             base::options(...future.oldOptions)
[13:17:31.838]             if (.Platform$OS.type == "windows") {
[13:17:31.838]                 old_names <- names(...future.oldEnvVars)
[13:17:31.838]                 envs <- base::Sys.getenv()
[13:17:31.838]                 names <- names(envs)
[13:17:31.838]                 common <- intersect(names, old_names)
[13:17:31.838]                 added <- setdiff(names, old_names)
[13:17:31.838]                 removed <- setdiff(old_names, names)
[13:17:31.838]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.838]                   envs[common]]
[13:17:31.838]                 NAMES <- toupper(changed)
[13:17:31.838]                 args <- list()
[13:17:31.838]                 for (kk in seq_along(NAMES)) {
[13:17:31.838]                   name <- changed[[kk]]
[13:17:31.838]                   NAME <- NAMES[[kk]]
[13:17:31.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.838]                     next
[13:17:31.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.838]                 }
[13:17:31.838]                 NAMES <- toupper(added)
[13:17:31.838]                 for (kk in seq_along(NAMES)) {
[13:17:31.838]                   name <- added[[kk]]
[13:17:31.838]                   NAME <- NAMES[[kk]]
[13:17:31.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.838]                     next
[13:17:31.838]                   args[[name]] <- ""
[13:17:31.838]                 }
[13:17:31.838]                 NAMES <- toupper(removed)
[13:17:31.838]                 for (kk in seq_along(NAMES)) {
[13:17:31.838]                   name <- removed[[kk]]
[13:17:31.838]                   NAME <- NAMES[[kk]]
[13:17:31.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.838]                     next
[13:17:31.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.838]                 }
[13:17:31.838]                 if (length(args) > 0) 
[13:17:31.838]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.838]             }
[13:17:31.838]             else {
[13:17:31.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.838]             }
[13:17:31.838]             {
[13:17:31.838]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.838]                   0L) {
[13:17:31.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.838]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.838]                   base::options(opts)
[13:17:31.838]                 }
[13:17:31.838]                 {
[13:17:31.838]                   {
[13:17:31.838]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.838]                     NULL
[13:17:31.838]                   }
[13:17:31.838]                   options(future.plan = NULL)
[13:17:31.838]                   if (is.na(NA_character_)) 
[13:17:31.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.838]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.838]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.838]                     envir = parent.frame()) 
[13:17:31.838]                   {
[13:17:31.838]                     if (is.function(workers)) 
[13:17:31.838]                       workers <- workers()
[13:17:31.838]                     workers <- structure(as.integer(workers), 
[13:17:31.838]                       class = class(workers))
[13:17:31.838]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.838]                       workers >= 1)
[13:17:31.838]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.838]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.838]                     }
[13:17:31.838]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.838]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.838]                       envir = envir)
[13:17:31.838]                     if (!future$lazy) 
[13:17:31.838]                       future <- run(future)
[13:17:31.838]                     invisible(future)
[13:17:31.838]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.838]                 }
[13:17:31.838]             }
[13:17:31.838]         }
[13:17:31.838]     })
[13:17:31.838]     if (TRUE) {
[13:17:31.838]         base::sink(type = "output", split = FALSE)
[13:17:31.838]         if (TRUE) {
[13:17:31.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.838]         }
[13:17:31.838]         else {
[13:17:31.838]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.838]         }
[13:17:31.838]         base::close(...future.stdout)
[13:17:31.838]         ...future.stdout <- NULL
[13:17:31.838]     }
[13:17:31.838]     ...future.result$conditions <- ...future.conditions
[13:17:31.838]     ...future.result$finished <- base::Sys.time()
[13:17:31.838]     ...future.result
[13:17:31.838] }
[13:17:31.840] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[13:17:31.841] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[13:17:31.841] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[13:17:31.841] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[13:17:31.841] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[13:17:31.842] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[13:17:31.842] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[13:17:31.842] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:31.842] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.843] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:17:31.843] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:17:31.843] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:31.843] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.843] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:31.844] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.844] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[13:17:31.844] MultisessionFuture started
[13:17:31.844] - Launch lazy future ... done
[13:17:31.844] run() for ‘MultisessionFuture’ ... done
[13:17:31.845] Created future:
[13:17:31.845] MultisessionFuture:
[13:17:31.845] Label: ‘future_by-1’
[13:17:31.845] Expression:
[13:17:31.845] {
[13:17:31.845]     do.call(function(...) {
[13:17:31.845]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.845]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.845]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.845]             on.exit(options(oopts), add = TRUE)
[13:17:31.845]         }
[13:17:31.845]         {
[13:17:31.845]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.845]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.845]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.845]             })
[13:17:31.845]         }
[13:17:31.845]     }, args = future.call.arguments)
[13:17:31.845] }
[13:17:31.845] Lazy evaluation: FALSE
[13:17:31.845] Asynchronous evaluation: TRUE
[13:17:31.845] Local evaluation: TRUE
[13:17:31.845] Environment: 0x5609eb5e9c30
[13:17:31.845] Capture standard output: TRUE
[13:17:31.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.845] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[13:17:31.845] Packages: 1 packages (‘stats’)
[13:17:31.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.845] Resolved: FALSE
[13:17:31.845] Value: <not collected>
[13:17:31.845] Conditions captured: <none>
[13:17:31.845] Early signaling: FALSE
[13:17:31.845] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.845] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.856] Chunk #1 of 2 ... DONE
[13:17:31.856] Chunk #2 of 2 ...
[13:17:31.857]  - Finding globals in 'X' for chunk #2 ...
[13:17:31.857] getGlobalsAndPackages() ...
[13:17:31.857] Searching for globals...
[13:17:31.857] 
[13:17:31.857] Searching for globals ... DONE
[13:17:31.857] - globals: [0] <none>
[13:17:31.857] getGlobalsAndPackages() ... DONE
[13:17:31.858]    + additional globals found: [n=0] 
[13:17:31.858]    + additional namespaces needed: [n=0] 
[13:17:31.858]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:31.858]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:31.858]  - seeds: <none>
[13:17:31.858] getGlobalsAndPackages() ...
[13:17:31.858] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.858] Resolving globals: FALSE
[13:17:31.858] Tweak future expression to call with '...' arguments ...
[13:17:31.858] {
[13:17:31.858]     do.call(function(...) {
[13:17:31.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.858]             on.exit(options(oopts), add = TRUE)
[13:17:31.858]         }
[13:17:31.858]         {
[13:17:31.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.858]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.858]             })
[13:17:31.858]         }
[13:17:31.858]     }, args = future.call.arguments)
[13:17:31.858] }
[13:17:31.859] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.859] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.859] 
[13:17:31.859] getGlobalsAndPackages() ... DONE
[13:17:31.860] run() for ‘Future’ ...
[13:17:31.860] - state: ‘created’
[13:17:31.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.874] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.874]   - Field: ‘node’
[13:17:31.874]   - Field: ‘label’
[13:17:31.874]   - Field: ‘local’
[13:17:31.874]   - Field: ‘owner’
[13:17:31.874]   - Field: ‘envir’
[13:17:31.874]   - Field: ‘workers’
[13:17:31.875]   - Field: ‘packages’
[13:17:31.875]   - Field: ‘gc’
[13:17:31.875]   - Field: ‘conditions’
[13:17:31.875]   - Field: ‘persistent’
[13:17:31.875]   - Field: ‘expr’
[13:17:31.875]   - Field: ‘uuid’
[13:17:31.875]   - Field: ‘seed’
[13:17:31.875]   - Field: ‘version’
[13:17:31.875]   - Field: ‘result’
[13:17:31.875]   - Field: ‘asynchronous’
[13:17:31.875]   - Field: ‘calls’
[13:17:31.876]   - Field: ‘globals’
[13:17:31.876]   - Field: ‘stdout’
[13:17:31.876]   - Field: ‘earlySignal’
[13:17:31.876]   - Field: ‘lazy’
[13:17:31.876]   - Field: ‘state’
[13:17:31.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.876] - Launch lazy future ...
[13:17:31.876] Packages needed by the future expression (n = 1): ‘stats’
[13:17:31.876] Packages needed by future strategies (n = 0): <none>
[13:17:31.877] {
[13:17:31.877]     {
[13:17:31.877]         {
[13:17:31.877]             ...future.startTime <- base::Sys.time()
[13:17:31.877]             {
[13:17:31.877]                 {
[13:17:31.877]                   {
[13:17:31.877]                     {
[13:17:31.877]                       {
[13:17:31.877]                         base::local({
[13:17:31.877]                           has_future <- base::requireNamespace("future", 
[13:17:31.877]                             quietly = TRUE)
[13:17:31.877]                           if (has_future) {
[13:17:31.877]                             ns <- base::getNamespace("future")
[13:17:31.877]                             version <- ns[[".package"]][["version"]]
[13:17:31.877]                             if (is.null(version)) 
[13:17:31.877]                               version <- utils::packageVersion("future")
[13:17:31.877]                           }
[13:17:31.877]                           else {
[13:17:31.877]                             version <- NULL
[13:17:31.877]                           }
[13:17:31.877]                           if (!has_future || version < "1.8.0") {
[13:17:31.877]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.877]                               "", base::R.version$version.string), 
[13:17:31.877]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:31.877]                                 base::R.version$platform, 8 * 
[13:17:31.877]                                   base::.Machine$sizeof.pointer), 
[13:17:31.877]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.877]                                 "release", "version")], collapse = " "), 
[13:17:31.877]                               hostname = base::Sys.info()[["nodename"]])
[13:17:31.877]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.877]                               info)
[13:17:31.877]                             info <- base::paste(info, collapse = "; ")
[13:17:31.877]                             if (!has_future) {
[13:17:31.877]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.877]                                 info)
[13:17:31.877]                             }
[13:17:31.877]                             else {
[13:17:31.877]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.877]                                 info, version)
[13:17:31.877]                             }
[13:17:31.877]                             base::stop(msg)
[13:17:31.877]                           }
[13:17:31.877]                         })
[13:17:31.877]                       }
[13:17:31.877]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.877]                       base::options(mc.cores = 1L)
[13:17:31.877]                     }
[13:17:31.877]                     base::local({
[13:17:31.877]                       for (pkg in "stats") {
[13:17:31.877]                         base::loadNamespace(pkg)
[13:17:31.877]                         base::library(pkg, character.only = TRUE)
[13:17:31.877]                       }
[13:17:31.877]                     })
[13:17:31.877]                   }
[13:17:31.877]                   options(future.plan = NULL)
[13:17:31.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.877]                 }
[13:17:31.877]                 ...future.workdir <- getwd()
[13:17:31.877]             }
[13:17:31.877]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.877]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.877]         }
[13:17:31.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.877]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:31.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.877]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.877]             base::names(...future.oldOptions))
[13:17:31.877]     }
[13:17:31.877]     if (FALSE) {
[13:17:31.877]     }
[13:17:31.877]     else {
[13:17:31.877]         if (TRUE) {
[13:17:31.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.877]                 open = "w")
[13:17:31.877]         }
[13:17:31.877]         else {
[13:17:31.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.877]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.877]         }
[13:17:31.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.877]             base::sink(type = "output", split = FALSE)
[13:17:31.877]             base::close(...future.stdout)
[13:17:31.877]         }, add = TRUE)
[13:17:31.877]     }
[13:17:31.877]     ...future.frame <- base::sys.nframe()
[13:17:31.877]     ...future.conditions <- base::list()
[13:17:31.877]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.877]     if (FALSE) {
[13:17:31.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.877]     }
[13:17:31.877]     ...future.result <- base::tryCatch({
[13:17:31.877]         base::withCallingHandlers({
[13:17:31.877]             ...future.value <- base::withVisible(base::local({
[13:17:31.877]                 ...future.makeSendCondition <- local({
[13:17:31.877]                   sendCondition <- NULL
[13:17:31.877]                   function(frame = 1L) {
[13:17:31.877]                     if (is.function(sendCondition)) 
[13:17:31.877]                       return(sendCondition)
[13:17:31.877]                     ns <- getNamespace("parallel")
[13:17:31.877]                     if (exists("sendData", mode = "function", 
[13:17:31.877]                       envir = ns)) {
[13:17:31.877]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.877]                         envir = ns)
[13:17:31.877]                       envir <- sys.frame(frame)
[13:17:31.877]                       master <- NULL
[13:17:31.877]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.877]                         !identical(envir, emptyenv())) {
[13:17:31.877]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.877]                           inherits = FALSE)) {
[13:17:31.877]                           master <- get("master", mode = "list", 
[13:17:31.877]                             envir = envir, inherits = FALSE)
[13:17:31.877]                           if (inherits(master, c("SOCKnode", 
[13:17:31.877]                             "SOCK0node"))) {
[13:17:31.877]                             sendCondition <<- function(cond) {
[13:17:31.877]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.877]                                 success = TRUE)
[13:17:31.877]                               parallel_sendData(master, data)
[13:17:31.877]                             }
[13:17:31.877]                             return(sendCondition)
[13:17:31.877]                           }
[13:17:31.877]                         }
[13:17:31.877]                         frame <- frame + 1L
[13:17:31.877]                         envir <- sys.frame(frame)
[13:17:31.877]                       }
[13:17:31.877]                     }
[13:17:31.877]                     sendCondition <<- function(cond) NULL
[13:17:31.877]                   }
[13:17:31.877]                 })
[13:17:31.877]                 withCallingHandlers({
[13:17:31.877]                   {
[13:17:31.877]                     do.call(function(...) {
[13:17:31.877]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.877]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.877]                         ...future.globals.maxSize)) {
[13:17:31.877]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.877]                         on.exit(options(oopts), add = TRUE)
[13:17:31.877]                       }
[13:17:31.877]                       {
[13:17:31.877]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.877]                           FUN = function(jj) {
[13:17:31.877]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.877]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.877]                           })
[13:17:31.877]                       }
[13:17:31.877]                     }, args = future.call.arguments)
[13:17:31.877]                   }
[13:17:31.877]                 }, immediateCondition = function(cond) {
[13:17:31.877]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.877]                   sendCondition(cond)
[13:17:31.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.877]                   {
[13:17:31.877]                     inherits <- base::inherits
[13:17:31.877]                     invokeRestart <- base::invokeRestart
[13:17:31.877]                     is.null <- base::is.null
[13:17:31.877]                     muffled <- FALSE
[13:17:31.877]                     if (inherits(cond, "message")) {
[13:17:31.877]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.877]                       if (muffled) 
[13:17:31.877]                         invokeRestart("muffleMessage")
[13:17:31.877]                     }
[13:17:31.877]                     else if (inherits(cond, "warning")) {
[13:17:31.877]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.877]                       if (muffled) 
[13:17:31.877]                         invokeRestart("muffleWarning")
[13:17:31.877]                     }
[13:17:31.877]                     else if (inherits(cond, "condition")) {
[13:17:31.877]                       if (!is.null(pattern)) {
[13:17:31.877]                         computeRestarts <- base::computeRestarts
[13:17:31.877]                         grepl <- base::grepl
[13:17:31.877]                         restarts <- computeRestarts(cond)
[13:17:31.877]                         for (restart in restarts) {
[13:17:31.877]                           name <- restart$name
[13:17:31.877]                           if (is.null(name)) 
[13:17:31.877]                             next
[13:17:31.877]                           if (!grepl(pattern, name)) 
[13:17:31.877]                             next
[13:17:31.877]                           invokeRestart(restart)
[13:17:31.877]                           muffled <- TRUE
[13:17:31.877]                           break
[13:17:31.877]                         }
[13:17:31.877]                       }
[13:17:31.877]                     }
[13:17:31.877]                     invisible(muffled)
[13:17:31.877]                   }
[13:17:31.877]                   muffleCondition(cond)
[13:17:31.877]                 })
[13:17:31.877]             }))
[13:17:31.877]             future::FutureResult(value = ...future.value$value, 
[13:17:31.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.877]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.877]                     ...future.globalenv.names))
[13:17:31.877]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.877]         }, condition = base::local({
[13:17:31.877]             c <- base::c
[13:17:31.877]             inherits <- base::inherits
[13:17:31.877]             invokeRestart <- base::invokeRestart
[13:17:31.877]             length <- base::length
[13:17:31.877]             list <- base::list
[13:17:31.877]             seq.int <- base::seq.int
[13:17:31.877]             signalCondition <- base::signalCondition
[13:17:31.877]             sys.calls <- base::sys.calls
[13:17:31.877]             `[[` <- base::`[[`
[13:17:31.877]             `+` <- base::`+`
[13:17:31.877]             `<<-` <- base::`<<-`
[13:17:31.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.877]                   3L)]
[13:17:31.877]             }
[13:17:31.877]             function(cond) {
[13:17:31.877]                 is_error <- inherits(cond, "error")
[13:17:31.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.877]                   NULL)
[13:17:31.877]                 if (is_error) {
[13:17:31.877]                   sessionInformation <- function() {
[13:17:31.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.877]                       search = base::search(), system = base::Sys.info())
[13:17:31.877]                   }
[13:17:31.877]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.877]                     cond$call), session = sessionInformation(), 
[13:17:31.877]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.877]                   signalCondition(cond)
[13:17:31.877]                 }
[13:17:31.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.877]                 "immediateCondition"))) {
[13:17:31.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.877]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.877]                   if (TRUE && !signal) {
[13:17:31.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.877]                     {
[13:17:31.877]                       inherits <- base::inherits
[13:17:31.877]                       invokeRestart <- base::invokeRestart
[13:17:31.877]                       is.null <- base::is.null
[13:17:31.877]                       muffled <- FALSE
[13:17:31.877]                       if (inherits(cond, "message")) {
[13:17:31.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.877]                         if (muffled) 
[13:17:31.877]                           invokeRestart("muffleMessage")
[13:17:31.877]                       }
[13:17:31.877]                       else if (inherits(cond, "warning")) {
[13:17:31.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.877]                         if (muffled) 
[13:17:31.877]                           invokeRestart("muffleWarning")
[13:17:31.877]                       }
[13:17:31.877]                       else if (inherits(cond, "condition")) {
[13:17:31.877]                         if (!is.null(pattern)) {
[13:17:31.877]                           computeRestarts <- base::computeRestarts
[13:17:31.877]                           grepl <- base::grepl
[13:17:31.877]                           restarts <- computeRestarts(cond)
[13:17:31.877]                           for (restart in restarts) {
[13:17:31.877]                             name <- restart$name
[13:17:31.877]                             if (is.null(name)) 
[13:17:31.877]                               next
[13:17:31.877]                             if (!grepl(pattern, name)) 
[13:17:31.877]                               next
[13:17:31.877]                             invokeRestart(restart)
[13:17:31.877]                             muffled <- TRUE
[13:17:31.877]                             break
[13:17:31.877]                           }
[13:17:31.877]                         }
[13:17:31.877]                       }
[13:17:31.877]                       invisible(muffled)
[13:17:31.877]                     }
[13:17:31.877]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.877]                   }
[13:17:31.877]                 }
[13:17:31.877]                 else {
[13:17:31.877]                   if (TRUE) {
[13:17:31.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.877]                     {
[13:17:31.877]                       inherits <- base::inherits
[13:17:31.877]                       invokeRestart <- base::invokeRestart
[13:17:31.877]                       is.null <- base::is.null
[13:17:31.877]                       muffled <- FALSE
[13:17:31.877]                       if (inherits(cond, "message")) {
[13:17:31.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.877]                         if (muffled) 
[13:17:31.877]                           invokeRestart("muffleMessage")
[13:17:31.877]                       }
[13:17:31.877]                       else if (inherits(cond, "warning")) {
[13:17:31.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.877]                         if (muffled) 
[13:17:31.877]                           invokeRestart("muffleWarning")
[13:17:31.877]                       }
[13:17:31.877]                       else if (inherits(cond, "condition")) {
[13:17:31.877]                         if (!is.null(pattern)) {
[13:17:31.877]                           computeRestarts <- base::computeRestarts
[13:17:31.877]                           grepl <- base::grepl
[13:17:31.877]                           restarts <- computeRestarts(cond)
[13:17:31.877]                           for (restart in restarts) {
[13:17:31.877]                             name <- restart$name
[13:17:31.877]                             if (is.null(name)) 
[13:17:31.877]                               next
[13:17:31.877]                             if (!grepl(pattern, name)) 
[13:17:31.877]                               next
[13:17:31.877]                             invokeRestart(restart)
[13:17:31.877]                             muffled <- TRUE
[13:17:31.877]                             break
[13:17:31.877]                           }
[13:17:31.877]                         }
[13:17:31.877]                       }
[13:17:31.877]                       invisible(muffled)
[13:17:31.877]                     }
[13:17:31.877]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.877]                   }
[13:17:31.877]                 }
[13:17:31.877]             }
[13:17:31.877]         }))
[13:17:31.877]     }, error = function(ex) {
[13:17:31.877]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.877]                 ...future.rng), started = ...future.startTime, 
[13:17:31.877]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.877]             version = "1.8"), class = "FutureResult")
[13:17:31.877]     }, finally = {
[13:17:31.877]         if (!identical(...future.workdir, getwd())) 
[13:17:31.877]             setwd(...future.workdir)
[13:17:31.877]         {
[13:17:31.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.877]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.877]             }
[13:17:31.877]             base::options(...future.oldOptions)
[13:17:31.877]             if (.Platform$OS.type == "windows") {
[13:17:31.877]                 old_names <- names(...future.oldEnvVars)
[13:17:31.877]                 envs <- base::Sys.getenv()
[13:17:31.877]                 names <- names(envs)
[13:17:31.877]                 common <- intersect(names, old_names)
[13:17:31.877]                 added <- setdiff(names, old_names)
[13:17:31.877]                 removed <- setdiff(old_names, names)
[13:17:31.877]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.877]                   envs[common]]
[13:17:31.877]                 NAMES <- toupper(changed)
[13:17:31.877]                 args <- list()
[13:17:31.877]                 for (kk in seq_along(NAMES)) {
[13:17:31.877]                   name <- changed[[kk]]
[13:17:31.877]                   NAME <- NAMES[[kk]]
[13:17:31.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.877]                     next
[13:17:31.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.877]                 }
[13:17:31.877]                 NAMES <- toupper(added)
[13:17:31.877]                 for (kk in seq_along(NAMES)) {
[13:17:31.877]                   name <- added[[kk]]
[13:17:31.877]                   NAME <- NAMES[[kk]]
[13:17:31.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.877]                     next
[13:17:31.877]                   args[[name]] <- ""
[13:17:31.877]                 }
[13:17:31.877]                 NAMES <- toupper(removed)
[13:17:31.877]                 for (kk in seq_along(NAMES)) {
[13:17:31.877]                   name <- removed[[kk]]
[13:17:31.877]                   NAME <- NAMES[[kk]]
[13:17:31.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.877]                     next
[13:17:31.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.877]                 }
[13:17:31.877]                 if (length(args) > 0) 
[13:17:31.877]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.877]             }
[13:17:31.877]             else {
[13:17:31.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.877]             }
[13:17:31.877]             {
[13:17:31.877]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.877]                   0L) {
[13:17:31.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.877]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.877]                   base::options(opts)
[13:17:31.877]                 }
[13:17:31.877]                 {
[13:17:31.877]                   {
[13:17:31.877]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.877]                     NULL
[13:17:31.877]                   }
[13:17:31.877]                   options(future.plan = NULL)
[13:17:31.877]                   if (is.na(NA_character_)) 
[13:17:31.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.877]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.877]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.877]                     envir = parent.frame()) 
[13:17:31.877]                   {
[13:17:31.877]                     if (is.function(workers)) 
[13:17:31.877]                       workers <- workers()
[13:17:31.877]                     workers <- structure(as.integer(workers), 
[13:17:31.877]                       class = class(workers))
[13:17:31.877]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.877]                       workers >= 1)
[13:17:31.877]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.877]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.877]                     }
[13:17:31.877]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.877]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.877]                       envir = envir)
[13:17:31.877]                     if (!future$lazy) 
[13:17:31.877]                       future <- run(future)
[13:17:31.877]                     invisible(future)
[13:17:31.877]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.877]                 }
[13:17:31.877]             }
[13:17:31.877]         }
[13:17:31.877]     })
[13:17:31.877]     if (TRUE) {
[13:17:31.877]         base::sink(type = "output", split = FALSE)
[13:17:31.877]         if (TRUE) {
[13:17:31.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.877]         }
[13:17:31.877]         else {
[13:17:31.877]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.877]         }
[13:17:31.877]         base::close(...future.stdout)
[13:17:31.877]         ...future.stdout <- NULL
[13:17:31.877]     }
[13:17:31.877]     ...future.result$conditions <- ...future.conditions
[13:17:31.877]     ...future.result$finished <- base::Sys.time()
[13:17:31.877]     ...future.result
[13:17:31.877] }
[13:17:31.880] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[13:17:31.880] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[13:17:31.880] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[13:17:31.880] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[13:17:31.881] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[13:17:31.881] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[13:17:31.881] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[13:17:31.881] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:31.882] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.882] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:17:31.882] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:17:31.882] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:31.883] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:31.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:31.883] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[13:17:31.884] MultisessionFuture started
[13:17:31.884] - Launch lazy future ... done
[13:17:31.884] run() for ‘MultisessionFuture’ ... done
[13:17:31.884] Created future:
[13:17:31.884] MultisessionFuture:
[13:17:31.884] Label: ‘future_by-2’
[13:17:31.884] Expression:
[13:17:31.884] {
[13:17:31.884]     do.call(function(...) {
[13:17:31.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.884]             on.exit(options(oopts), add = TRUE)
[13:17:31.884]         }
[13:17:31.884]         {
[13:17:31.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.884]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.884]             })
[13:17:31.884]         }
[13:17:31.884]     }, args = future.call.arguments)
[13:17:31.884] }
[13:17:31.884] Lazy evaluation: FALSE
[13:17:31.884] Asynchronous evaluation: TRUE
[13:17:31.884] Local evaluation: TRUE
[13:17:31.884] Environment: 0x5609eb5e9c30
[13:17:31.884] Capture standard output: TRUE
[13:17:31.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.884] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[13:17:31.884] Packages: 1 packages (‘stats’)
[13:17:31.884] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.884] Resolved: FALSE
[13:17:31.884] Value: <not collected>
[13:17:31.884] Conditions captured: <none>
[13:17:31.884] Early signaling: FALSE
[13:17:31.884] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.884] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.896] Chunk #2 of 2 ... DONE
[13:17:31.896] Launching 2 futures (chunks) ... DONE
[13:17:31.896] Resolving 2 futures (chunks) ...
[13:17:31.896] resolve() on list ...
[13:17:31.896]  recursive: 0
[13:17:31.896]  length: 2
[13:17:31.896] 
[13:17:31.897] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.897] - Validating connection of MultisessionFuture
[13:17:31.897] - received message: FutureResult
[13:17:31.897] - Received FutureResult
[13:17:31.897] - Erased future from FutureRegistry
[13:17:31.898] result() for ClusterFuture ...
[13:17:31.898] - result already collected: FutureResult
[13:17:31.898] result() for ClusterFuture ... done
[13:17:31.898] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.898] Future #1
[13:17:31.898] result() for ClusterFuture ...
[13:17:31.898] - result already collected: FutureResult
[13:17:31.898] result() for ClusterFuture ... done
[13:17:31.898] result() for ClusterFuture ...
[13:17:31.898] - result already collected: FutureResult
[13:17:31.898] result() for ClusterFuture ... done
[13:17:31.899] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:31.899] - nx: 2
[13:17:31.899] - relay: TRUE
[13:17:31.899] - stdout: TRUE
[13:17:31.899] - signal: TRUE
[13:17:31.899] - resignal: FALSE
[13:17:31.899] - force: TRUE
[13:17:31.899] - relayed: [n=2] FALSE, FALSE
[13:17:31.899] - queued futures: [n=2] FALSE, FALSE
[13:17:31.899]  - until=1
[13:17:31.899]  - relaying element #1
[13:17:31.899] result() for ClusterFuture ...
[13:17:31.900] - result already collected: FutureResult
[13:17:31.900] result() for ClusterFuture ... done
[13:17:31.900] result() for ClusterFuture ...
[13:17:31.900] - result already collected: FutureResult
[13:17:31.900] result() for ClusterFuture ... done
[13:17:31.900] result() for ClusterFuture ...
[13:17:31.900] - result already collected: FutureResult
[13:17:31.900] result() for ClusterFuture ... done
[13:17:31.900] result() for ClusterFuture ...
[13:17:31.900] - result already collected: FutureResult
[13:17:31.900] result() for ClusterFuture ... done
[13:17:31.900] - relayed: [n=2] TRUE, FALSE
[13:17:31.901] - queued futures: [n=2] TRUE, FALSE
[13:17:31.901] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:31.901]  length: 1 (resolved future 1)
[13:17:31.931] receiveMessageFromWorker() for ClusterFuture ...
[13:17:31.931] - Validating connection of MultisessionFuture
[13:17:31.931] - received message: FutureResult
[13:17:31.931] - Received FutureResult
[13:17:31.932] - Erased future from FutureRegistry
[13:17:31.932] result() for ClusterFuture ...
[13:17:31.932] - result already collected: FutureResult
[13:17:31.932] result() for ClusterFuture ... done
[13:17:31.932] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:31.932] Future #2
[13:17:31.932] result() for ClusterFuture ...
[13:17:31.932] - result already collected: FutureResult
[13:17:31.932] result() for ClusterFuture ... done
[13:17:31.932] result() for ClusterFuture ...
[13:17:31.932] - result already collected: FutureResult
[13:17:31.933] result() for ClusterFuture ... done
[13:17:31.933] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:31.933] - nx: 2
[13:17:31.933] - relay: TRUE
[13:17:31.933] - stdout: TRUE
[13:17:31.933] - signal: TRUE
[13:17:31.933] - resignal: FALSE
[13:17:31.933] - force: TRUE
[13:17:31.933] - relayed: [n=2] TRUE, FALSE
[13:17:31.933] - queued futures: [n=2] TRUE, FALSE
[13:17:31.933]  - until=2
[13:17:31.933]  - relaying element #2
[13:17:31.934] result() for ClusterFuture ...
[13:17:31.934] - result already collected: FutureResult
[13:17:31.934] result() for ClusterFuture ... done
[13:17:31.934] result() for ClusterFuture ...
[13:17:31.934] - result already collected: FutureResult
[13:17:31.934] result() for ClusterFuture ... done
[13:17:31.934] result() for ClusterFuture ...
[13:17:31.934] - result already collected: FutureResult
[13:17:31.934] result() for ClusterFuture ... done
[13:17:31.934] result() for ClusterFuture ...
[13:17:31.934] - result already collected: FutureResult
[13:17:31.935] result() for ClusterFuture ... done
[13:17:31.935] - relayed: [n=2] TRUE, TRUE
[13:17:31.935] - queued futures: [n=2] TRUE, TRUE
[13:17:31.935] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:31.935]  length: 0 (resolved future 2)
[13:17:31.935] Relaying remaining futures
[13:17:31.935] signalConditionsASAP(NULL, pos=0) ...
[13:17:31.935] - nx: 2
[13:17:31.935] - relay: TRUE
[13:17:31.935] - stdout: TRUE
[13:17:31.935] - signal: TRUE
[13:17:31.935] - resignal: FALSE
[13:17:31.935] - force: TRUE
[13:17:31.936] - relayed: [n=2] TRUE, TRUE
[13:17:31.936] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:31.936] - relayed: [n=2] TRUE, TRUE
[13:17:31.936] - queued futures: [n=2] TRUE, TRUE
[13:17:31.936] signalConditionsASAP(NULL, pos=0) ... done
[13:17:31.936] resolve() on list ... DONE
[13:17:31.936] result() for ClusterFuture ...
[13:17:31.936] - result already collected: FutureResult
[13:17:31.936] result() for ClusterFuture ... done
[13:17:31.936] result() for ClusterFuture ...
[13:17:31.936] - result already collected: FutureResult
[13:17:31.937] result() for ClusterFuture ... done
[13:17:31.937] result() for ClusterFuture ...
[13:17:31.937] - result already collected: FutureResult
[13:17:31.937] result() for ClusterFuture ... done
[13:17:31.937] result() for ClusterFuture ...
[13:17:31.937] - result already collected: FutureResult
[13:17:31.937] result() for ClusterFuture ... done
[13:17:31.937]  - Number of value chunks collected: 2
[13:17:31.937] Resolving 2 futures (chunks) ... DONE
[13:17:31.937] Reducing values from 2 chunks ...
[13:17:31.938]  - Number of values collected after concatenation: 3
[13:17:31.938]  - Number of values expected: 3
[13:17:31.938] Reducing values from 2 chunks ... DONE
[13:17:31.938] future_lapply() ... DONE
[13:17:31.938] future_by_internal() ... DONE
[13:17:31.938] future_by_internal() ...
[13:17:31.939] future_lapply() ...
[13:17:31.943] Number of chunks: 2
[13:17:31.943] getGlobalsAndPackagesXApply() ...
[13:17:31.943]  - future.globals: TRUE
[13:17:31.943] getGlobalsAndPackages() ...
[13:17:31.943] Searching for globals...
[13:17:31.944] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:31.944] Searching for globals ... DONE
[13:17:31.944] Resolving globals: FALSE
[13:17:31.945] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:31.945] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:31.945] - globals: [1] ‘FUN’
[13:17:31.945] 
[13:17:31.945] getGlobalsAndPackages() ... DONE
[13:17:31.945]  - globals found/used: [n=1] ‘FUN’
[13:17:31.945]  - needed namespaces: [n=0] 
[13:17:31.945] Finding globals ... DONE
[13:17:31.946]  - use_args: TRUE
[13:17:31.946]  - Getting '...' globals ...
[13:17:31.946] resolve() on list ...
[13:17:31.946]  recursive: 0
[13:17:31.946]  length: 1
[13:17:31.946]  elements: ‘...’
[13:17:31.946]  length: 0 (resolved future 1)
[13:17:31.946] resolve() on list ... DONE
[13:17:31.946]    - '...' content: [n=0] 
[13:17:31.947] List of 1
[13:17:31.947]  $ ...: list()
[13:17:31.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.947]  - attr(*, "where")=List of 1
[13:17:31.947]   ..$ ...:<environment: 0x5609ebdb8ee8> 
[13:17:31.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.947]  - attr(*, "resolved")= logi TRUE
[13:17:31.947]  - attr(*, "total_size")= num NA
[13:17:31.949]  - Getting '...' globals ... DONE
[13:17:31.949] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:31.949] List of 2
[13:17:31.949]  $ ...future.FUN:function (object, ...)  
[13:17:31.949]  $ ...          : list()
[13:17:31.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:31.949]  - attr(*, "where")=List of 2
[13:17:31.949]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:31.949]   ..$ ...          :<environment: 0x5609ebdb8ee8> 
[13:17:31.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:31.949]  - attr(*, "resolved")= logi FALSE
[13:17:31.949]  - attr(*, "total_size")= num 1240
[13:17:31.952] Packages to be attached in all futures: [n=0] 
[13:17:31.952] getGlobalsAndPackagesXApply() ... DONE
[13:17:31.952] Number of futures (= number of chunks): 2
[13:17:31.952] Launching 2 futures (chunks) ...
[13:17:31.952] Chunk #1 of 2 ...
[13:17:31.953]  - Finding globals in 'X' for chunk #1 ...
[13:17:31.953] getGlobalsAndPackages() ...
[13:17:31.953] Searching for globals...
[13:17:31.953] 
[13:17:31.953] Searching for globals ... DONE
[13:17:31.953] - globals: [0] <none>
[13:17:31.953] getGlobalsAndPackages() ... DONE
[13:17:31.953]    + additional globals found: [n=0] 
[13:17:31.953]    + additional namespaces needed: [n=0] 
[13:17:31.954]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:31.954]  - seeds: <none>
[13:17:31.954] getGlobalsAndPackages() ...
[13:17:31.954] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.954] Resolving globals: FALSE
[13:17:31.954] Tweak future expression to call with '...' arguments ...
[13:17:31.954] {
[13:17:31.954]     do.call(function(...) {
[13:17:31.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.954]             on.exit(options(oopts), add = TRUE)
[13:17:31.954]         }
[13:17:31.954]         {
[13:17:31.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.954]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.954]             })
[13:17:31.954]         }
[13:17:31.954]     }, args = future.call.arguments)
[13:17:31.954] }
[13:17:31.954] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.955] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.955] 
[13:17:31.955] getGlobalsAndPackages() ... DONE
[13:17:31.955] run() for ‘Future’ ...
[13:17:31.955] - state: ‘created’
[13:17:31.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:31.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:31.970]   - Field: ‘node’
[13:17:31.970]   - Field: ‘label’
[13:17:31.970]   - Field: ‘local’
[13:17:31.970]   - Field: ‘owner’
[13:17:31.970]   - Field: ‘envir’
[13:17:31.970]   - Field: ‘workers’
[13:17:31.970]   - Field: ‘packages’
[13:17:31.970]   - Field: ‘gc’
[13:17:31.970]   - Field: ‘conditions’
[13:17:31.970]   - Field: ‘persistent’
[13:17:31.971]   - Field: ‘expr’
[13:17:31.971]   - Field: ‘uuid’
[13:17:31.971]   - Field: ‘seed’
[13:17:31.971]   - Field: ‘version’
[13:17:31.971]   - Field: ‘result’
[13:17:31.971]   - Field: ‘asynchronous’
[13:17:31.971]   - Field: ‘calls’
[13:17:31.971]   - Field: ‘globals’
[13:17:31.971]   - Field: ‘stdout’
[13:17:31.971]   - Field: ‘earlySignal’
[13:17:31.971]   - Field: ‘lazy’
[13:17:31.972]   - Field: ‘state’
[13:17:31.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:31.972] - Launch lazy future ...
[13:17:31.972] Packages needed by the future expression (n = 0): <none>
[13:17:31.972] Packages needed by future strategies (n = 0): <none>
[13:17:31.973] {
[13:17:31.973]     {
[13:17:31.973]         {
[13:17:31.973]             ...future.startTime <- base::Sys.time()
[13:17:31.973]             {
[13:17:31.973]                 {
[13:17:31.973]                   {
[13:17:31.973]                     {
[13:17:31.973]                       base::local({
[13:17:31.973]                         has_future <- base::requireNamespace("future", 
[13:17:31.973]                           quietly = TRUE)
[13:17:31.973]                         if (has_future) {
[13:17:31.973]                           ns <- base::getNamespace("future")
[13:17:31.973]                           version <- ns[[".package"]][["version"]]
[13:17:31.973]                           if (is.null(version)) 
[13:17:31.973]                             version <- utils::packageVersion("future")
[13:17:31.973]                         }
[13:17:31.973]                         else {
[13:17:31.973]                           version <- NULL
[13:17:31.973]                         }
[13:17:31.973]                         if (!has_future || version < "1.8.0") {
[13:17:31.973]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:31.973]                             "", base::R.version$version.string), 
[13:17:31.973]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:31.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:31.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:31.973]                               "release", "version")], collapse = " "), 
[13:17:31.973]                             hostname = base::Sys.info()[["nodename"]])
[13:17:31.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:31.973]                             info)
[13:17:31.973]                           info <- base::paste(info, collapse = "; ")
[13:17:31.973]                           if (!has_future) {
[13:17:31.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:31.973]                               info)
[13:17:31.973]                           }
[13:17:31.973]                           else {
[13:17:31.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:31.973]                               info, version)
[13:17:31.973]                           }
[13:17:31.973]                           base::stop(msg)
[13:17:31.973]                         }
[13:17:31.973]                       })
[13:17:31.973]                     }
[13:17:31.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:31.973]                     base::options(mc.cores = 1L)
[13:17:31.973]                   }
[13:17:31.973]                   options(future.plan = NULL)
[13:17:31.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:31.973]                 }
[13:17:31.973]                 ...future.workdir <- getwd()
[13:17:31.973]             }
[13:17:31.973]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:31.973]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:31.973]         }
[13:17:31.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:31.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:31.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:31.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:31.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:31.973]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:31.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:31.973]             base::names(...future.oldOptions))
[13:17:31.973]     }
[13:17:31.973]     if (FALSE) {
[13:17:31.973]     }
[13:17:31.973]     else {
[13:17:31.973]         if (TRUE) {
[13:17:31.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:31.973]                 open = "w")
[13:17:31.973]         }
[13:17:31.973]         else {
[13:17:31.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:31.973]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:31.973]         }
[13:17:31.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:31.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:31.973]             base::sink(type = "output", split = FALSE)
[13:17:31.973]             base::close(...future.stdout)
[13:17:31.973]         }, add = TRUE)
[13:17:31.973]     }
[13:17:31.973]     ...future.frame <- base::sys.nframe()
[13:17:31.973]     ...future.conditions <- base::list()
[13:17:31.973]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:31.973]     if (FALSE) {
[13:17:31.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:31.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:31.973]     }
[13:17:31.973]     ...future.result <- base::tryCatch({
[13:17:31.973]         base::withCallingHandlers({
[13:17:31.973]             ...future.value <- base::withVisible(base::local({
[13:17:31.973]                 ...future.makeSendCondition <- local({
[13:17:31.973]                   sendCondition <- NULL
[13:17:31.973]                   function(frame = 1L) {
[13:17:31.973]                     if (is.function(sendCondition)) 
[13:17:31.973]                       return(sendCondition)
[13:17:31.973]                     ns <- getNamespace("parallel")
[13:17:31.973]                     if (exists("sendData", mode = "function", 
[13:17:31.973]                       envir = ns)) {
[13:17:31.973]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:31.973]                         envir = ns)
[13:17:31.973]                       envir <- sys.frame(frame)
[13:17:31.973]                       master <- NULL
[13:17:31.973]                       while (!identical(envir, .GlobalEnv) && 
[13:17:31.973]                         !identical(envir, emptyenv())) {
[13:17:31.973]                         if (exists("master", mode = "list", envir = envir, 
[13:17:31.973]                           inherits = FALSE)) {
[13:17:31.973]                           master <- get("master", mode = "list", 
[13:17:31.973]                             envir = envir, inherits = FALSE)
[13:17:31.973]                           if (inherits(master, c("SOCKnode", 
[13:17:31.973]                             "SOCK0node"))) {
[13:17:31.973]                             sendCondition <<- function(cond) {
[13:17:31.973]                               data <- list(type = "VALUE", value = cond, 
[13:17:31.973]                                 success = TRUE)
[13:17:31.973]                               parallel_sendData(master, data)
[13:17:31.973]                             }
[13:17:31.973]                             return(sendCondition)
[13:17:31.973]                           }
[13:17:31.973]                         }
[13:17:31.973]                         frame <- frame + 1L
[13:17:31.973]                         envir <- sys.frame(frame)
[13:17:31.973]                       }
[13:17:31.973]                     }
[13:17:31.973]                     sendCondition <<- function(cond) NULL
[13:17:31.973]                   }
[13:17:31.973]                 })
[13:17:31.973]                 withCallingHandlers({
[13:17:31.973]                   {
[13:17:31.973]                     do.call(function(...) {
[13:17:31.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.973]                       if (!identical(...future.globals.maxSize.org, 
[13:17:31.973]                         ...future.globals.maxSize)) {
[13:17:31.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.973]                         on.exit(options(oopts), add = TRUE)
[13:17:31.973]                       }
[13:17:31.973]                       {
[13:17:31.973]                         lapply(seq_along(...future.elements_ii), 
[13:17:31.973]                           FUN = function(jj) {
[13:17:31.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.973]                             ...future.FUN(...future.X_jj, ...)
[13:17:31.973]                           })
[13:17:31.973]                       }
[13:17:31.973]                     }, args = future.call.arguments)
[13:17:31.973]                   }
[13:17:31.973]                 }, immediateCondition = function(cond) {
[13:17:31.973]                   sendCondition <- ...future.makeSendCondition()
[13:17:31.973]                   sendCondition(cond)
[13:17:31.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.973]                   {
[13:17:31.973]                     inherits <- base::inherits
[13:17:31.973]                     invokeRestart <- base::invokeRestart
[13:17:31.973]                     is.null <- base::is.null
[13:17:31.973]                     muffled <- FALSE
[13:17:31.973]                     if (inherits(cond, "message")) {
[13:17:31.973]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:31.973]                       if (muffled) 
[13:17:31.973]                         invokeRestart("muffleMessage")
[13:17:31.973]                     }
[13:17:31.973]                     else if (inherits(cond, "warning")) {
[13:17:31.973]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:31.973]                       if (muffled) 
[13:17:31.973]                         invokeRestart("muffleWarning")
[13:17:31.973]                     }
[13:17:31.973]                     else if (inherits(cond, "condition")) {
[13:17:31.973]                       if (!is.null(pattern)) {
[13:17:31.973]                         computeRestarts <- base::computeRestarts
[13:17:31.973]                         grepl <- base::grepl
[13:17:31.973]                         restarts <- computeRestarts(cond)
[13:17:31.973]                         for (restart in restarts) {
[13:17:31.973]                           name <- restart$name
[13:17:31.973]                           if (is.null(name)) 
[13:17:31.973]                             next
[13:17:31.973]                           if (!grepl(pattern, name)) 
[13:17:31.973]                             next
[13:17:31.973]                           invokeRestart(restart)
[13:17:31.973]                           muffled <- TRUE
[13:17:31.973]                           break
[13:17:31.973]                         }
[13:17:31.973]                       }
[13:17:31.973]                     }
[13:17:31.973]                     invisible(muffled)
[13:17:31.973]                   }
[13:17:31.973]                   muffleCondition(cond)
[13:17:31.973]                 })
[13:17:31.973]             }))
[13:17:31.973]             future::FutureResult(value = ...future.value$value, 
[13:17:31.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.973]                   ...future.rng), globalenv = if (FALSE) 
[13:17:31.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:31.973]                     ...future.globalenv.names))
[13:17:31.973]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:31.973]         }, condition = base::local({
[13:17:31.973]             c <- base::c
[13:17:31.973]             inherits <- base::inherits
[13:17:31.973]             invokeRestart <- base::invokeRestart
[13:17:31.973]             length <- base::length
[13:17:31.973]             list <- base::list
[13:17:31.973]             seq.int <- base::seq.int
[13:17:31.973]             signalCondition <- base::signalCondition
[13:17:31.973]             sys.calls <- base::sys.calls
[13:17:31.973]             `[[` <- base::`[[`
[13:17:31.973]             `+` <- base::`+`
[13:17:31.973]             `<<-` <- base::`<<-`
[13:17:31.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:31.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:31.973]                   3L)]
[13:17:31.973]             }
[13:17:31.973]             function(cond) {
[13:17:31.973]                 is_error <- inherits(cond, "error")
[13:17:31.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:31.973]                   NULL)
[13:17:31.973]                 if (is_error) {
[13:17:31.973]                   sessionInformation <- function() {
[13:17:31.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:31.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:31.973]                       search = base::search(), system = base::Sys.info())
[13:17:31.973]                   }
[13:17:31.973]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:31.973]                     cond$call), session = sessionInformation(), 
[13:17:31.973]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:31.973]                   signalCondition(cond)
[13:17:31.973]                 }
[13:17:31.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:31.973]                 "immediateCondition"))) {
[13:17:31.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:31.973]                   ...future.conditions[[length(...future.conditions) + 
[13:17:31.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:31.973]                   if (TRUE && !signal) {
[13:17:31.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.973]                     {
[13:17:31.973]                       inherits <- base::inherits
[13:17:31.973]                       invokeRestart <- base::invokeRestart
[13:17:31.973]                       is.null <- base::is.null
[13:17:31.973]                       muffled <- FALSE
[13:17:31.973]                       if (inherits(cond, "message")) {
[13:17:31.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.973]                         if (muffled) 
[13:17:31.973]                           invokeRestart("muffleMessage")
[13:17:31.973]                       }
[13:17:31.973]                       else if (inherits(cond, "warning")) {
[13:17:31.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.973]                         if (muffled) 
[13:17:31.973]                           invokeRestart("muffleWarning")
[13:17:31.973]                       }
[13:17:31.973]                       else if (inherits(cond, "condition")) {
[13:17:31.973]                         if (!is.null(pattern)) {
[13:17:31.973]                           computeRestarts <- base::computeRestarts
[13:17:31.973]                           grepl <- base::grepl
[13:17:31.973]                           restarts <- computeRestarts(cond)
[13:17:31.973]                           for (restart in restarts) {
[13:17:31.973]                             name <- restart$name
[13:17:31.973]                             if (is.null(name)) 
[13:17:31.973]                               next
[13:17:31.973]                             if (!grepl(pattern, name)) 
[13:17:31.973]                               next
[13:17:31.973]                             invokeRestart(restart)
[13:17:31.973]                             muffled <- TRUE
[13:17:31.973]                             break
[13:17:31.973]                           }
[13:17:31.973]                         }
[13:17:31.973]                       }
[13:17:31.973]                       invisible(muffled)
[13:17:31.973]                     }
[13:17:31.973]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.973]                   }
[13:17:31.973]                 }
[13:17:31.973]                 else {
[13:17:31.973]                   if (TRUE) {
[13:17:31.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:31.973]                     {
[13:17:31.973]                       inherits <- base::inherits
[13:17:31.973]                       invokeRestart <- base::invokeRestart
[13:17:31.973]                       is.null <- base::is.null
[13:17:31.973]                       muffled <- FALSE
[13:17:31.973]                       if (inherits(cond, "message")) {
[13:17:31.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:31.973]                         if (muffled) 
[13:17:31.973]                           invokeRestart("muffleMessage")
[13:17:31.973]                       }
[13:17:31.973]                       else if (inherits(cond, "warning")) {
[13:17:31.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:31.973]                         if (muffled) 
[13:17:31.973]                           invokeRestart("muffleWarning")
[13:17:31.973]                       }
[13:17:31.973]                       else if (inherits(cond, "condition")) {
[13:17:31.973]                         if (!is.null(pattern)) {
[13:17:31.973]                           computeRestarts <- base::computeRestarts
[13:17:31.973]                           grepl <- base::grepl
[13:17:31.973]                           restarts <- computeRestarts(cond)
[13:17:31.973]                           for (restart in restarts) {
[13:17:31.973]                             name <- restart$name
[13:17:31.973]                             if (is.null(name)) 
[13:17:31.973]                               next
[13:17:31.973]                             if (!grepl(pattern, name)) 
[13:17:31.973]                               next
[13:17:31.973]                             invokeRestart(restart)
[13:17:31.973]                             muffled <- TRUE
[13:17:31.973]                             break
[13:17:31.973]                           }
[13:17:31.973]                         }
[13:17:31.973]                       }
[13:17:31.973]                       invisible(muffled)
[13:17:31.973]                     }
[13:17:31.973]                     muffleCondition(cond, pattern = "^muffle")
[13:17:31.973]                   }
[13:17:31.973]                 }
[13:17:31.973]             }
[13:17:31.973]         }))
[13:17:31.973]     }, error = function(ex) {
[13:17:31.973]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:31.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:31.973]                 ...future.rng), started = ...future.startTime, 
[13:17:31.973]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:31.973]             version = "1.8"), class = "FutureResult")
[13:17:31.973]     }, finally = {
[13:17:31.973]         if (!identical(...future.workdir, getwd())) 
[13:17:31.973]             setwd(...future.workdir)
[13:17:31.973]         {
[13:17:31.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:31.973]                 ...future.oldOptions$nwarnings <- NULL
[13:17:31.973]             }
[13:17:31.973]             base::options(...future.oldOptions)
[13:17:31.973]             if (.Platform$OS.type == "windows") {
[13:17:31.973]                 old_names <- names(...future.oldEnvVars)
[13:17:31.973]                 envs <- base::Sys.getenv()
[13:17:31.973]                 names <- names(envs)
[13:17:31.973]                 common <- intersect(names, old_names)
[13:17:31.973]                 added <- setdiff(names, old_names)
[13:17:31.973]                 removed <- setdiff(old_names, names)
[13:17:31.973]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:31.973]                   envs[common]]
[13:17:31.973]                 NAMES <- toupper(changed)
[13:17:31.973]                 args <- list()
[13:17:31.973]                 for (kk in seq_along(NAMES)) {
[13:17:31.973]                   name <- changed[[kk]]
[13:17:31.973]                   NAME <- NAMES[[kk]]
[13:17:31.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.973]                     next
[13:17:31.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.973]                 }
[13:17:31.973]                 NAMES <- toupper(added)
[13:17:31.973]                 for (kk in seq_along(NAMES)) {
[13:17:31.973]                   name <- added[[kk]]
[13:17:31.973]                   NAME <- NAMES[[kk]]
[13:17:31.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.973]                     next
[13:17:31.973]                   args[[name]] <- ""
[13:17:31.973]                 }
[13:17:31.973]                 NAMES <- toupper(removed)
[13:17:31.973]                 for (kk in seq_along(NAMES)) {
[13:17:31.973]                   name <- removed[[kk]]
[13:17:31.973]                   NAME <- NAMES[[kk]]
[13:17:31.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:31.973]                     next
[13:17:31.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:31.973]                 }
[13:17:31.973]                 if (length(args) > 0) 
[13:17:31.973]                   base::do.call(base::Sys.setenv, args = args)
[13:17:31.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:31.973]             }
[13:17:31.973]             else {
[13:17:31.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:31.973]             }
[13:17:31.973]             {
[13:17:31.973]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:31.973]                   0L) {
[13:17:31.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:31.973]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:31.973]                   base::options(opts)
[13:17:31.973]                 }
[13:17:31.973]                 {
[13:17:31.973]                   {
[13:17:31.973]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:31.973]                     NULL
[13:17:31.973]                   }
[13:17:31.973]                   options(future.plan = NULL)
[13:17:31.973]                   if (is.na(NA_character_)) 
[13:17:31.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:31.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:31.973]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:31.973]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:31.973]                     envir = parent.frame()) 
[13:17:31.973]                   {
[13:17:31.973]                     if (is.function(workers)) 
[13:17:31.973]                       workers <- workers()
[13:17:31.973]                     workers <- structure(as.integer(workers), 
[13:17:31.973]                       class = class(workers))
[13:17:31.973]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:31.973]                       workers >= 1)
[13:17:31.973]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:31.973]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:31.973]                     }
[13:17:31.973]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:31.973]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:31.973]                       envir = envir)
[13:17:31.973]                     if (!future$lazy) 
[13:17:31.973]                       future <- run(future)
[13:17:31.973]                     invisible(future)
[13:17:31.973]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:31.973]                 }
[13:17:31.973]             }
[13:17:31.973]         }
[13:17:31.973]     })
[13:17:31.973]     if (TRUE) {
[13:17:31.973]         base::sink(type = "output", split = FALSE)
[13:17:31.973]         if (TRUE) {
[13:17:31.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:31.973]         }
[13:17:31.973]         else {
[13:17:31.973]             ...future.result["stdout"] <- base::list(NULL)
[13:17:31.973]         }
[13:17:31.973]         base::close(...future.stdout)
[13:17:31.973]         ...future.stdout <- NULL
[13:17:31.973]     }
[13:17:31.973]     ...future.result$conditions <- ...future.conditions
[13:17:31.973]     ...future.result$finished <- base::Sys.time()
[13:17:31.973]     ...future.result
[13:17:31.973] }
[13:17:31.975] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:17:31.975] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:17:31.976] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:17:31.976] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:31.976] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.977] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:17:31.977] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:17:31.977] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:31.977] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.978] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:31.978] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:31.978] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:17:31.978] MultisessionFuture started
[13:17:31.978] - Launch lazy future ... done
[13:17:31.979] run() for ‘MultisessionFuture’ ... done
[13:17:31.979] Created future:
[13:17:31.979] MultisessionFuture:
[13:17:31.979] Label: ‘future_by-1’
[13:17:31.979] Expression:
[13:17:31.979] {
[13:17:31.979]     do.call(function(...) {
[13:17:31.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.979]             on.exit(options(oopts), add = TRUE)
[13:17:31.979]         }
[13:17:31.979]         {
[13:17:31.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.979]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.979]             })
[13:17:31.979]         }
[13:17:31.979]     }, args = future.call.arguments)
[13:17:31.979] }
[13:17:31.979] Lazy evaluation: FALSE
[13:17:31.979] Asynchronous evaluation: TRUE
[13:17:31.979] Local evaluation: TRUE
[13:17:31.979] Environment: 0x5609ebde37b8
[13:17:31.979] Capture standard output: TRUE
[13:17:31.979] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:31.979] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:31.979] Packages: <none>
[13:17:31.979] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:31.979] Resolved: FALSE
[13:17:31.979] Value: <not collected>
[13:17:31.979] Conditions captured: <none>
[13:17:31.979] Early signaling: FALSE
[13:17:31.979] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:31.979] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:31.990] Chunk #1 of 2 ... DONE
[13:17:31.990] Chunk #2 of 2 ...
[13:17:31.991]  - Finding globals in 'X' for chunk #2 ...
[13:17:31.991] getGlobalsAndPackages() ...
[13:17:31.991] Searching for globals...
[13:17:31.991] 
[13:17:31.991] Searching for globals ... DONE
[13:17:31.991] - globals: [0] <none>
[13:17:31.992] getGlobalsAndPackages() ... DONE
[13:17:31.992]    + additional globals found: [n=0] 
[13:17:31.992]    + additional namespaces needed: [n=0] 
[13:17:31.992]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:31.992]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:31.992]  - seeds: <none>
[13:17:31.992] getGlobalsAndPackages() ...
[13:17:31.992] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.992] Resolving globals: FALSE
[13:17:31.992] Tweak future expression to call with '...' arguments ...
[13:17:31.993] {
[13:17:31.993]     do.call(function(...) {
[13:17:31.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:31.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:31.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:31.993]             on.exit(options(oopts), add = TRUE)
[13:17:31.993]         }
[13:17:31.993]         {
[13:17:31.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:31.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:31.993]                 ...future.FUN(...future.X_jj, ...)
[13:17:31.993]             })
[13:17:31.993]         }
[13:17:31.993]     }, args = future.call.arguments)
[13:17:31.993] }
[13:17:31.993] Tweak future expression to call with '...' arguments ... DONE
[13:17:31.993] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:31.993] 
[13:17:31.993] getGlobalsAndPackages() ... DONE
[13:17:31.994] run() for ‘Future’ ...
[13:17:31.994] - state: ‘created’
[13:17:31.994] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.009] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:32.009]   - Field: ‘node’
[13:17:32.009]   - Field: ‘label’
[13:17:32.009]   - Field: ‘local’
[13:17:32.009]   - Field: ‘owner’
[13:17:32.010]   - Field: ‘envir’
[13:17:32.010]   - Field: ‘workers’
[13:17:32.010]   - Field: ‘packages’
[13:17:32.010]   - Field: ‘gc’
[13:17:32.010]   - Field: ‘conditions’
[13:17:32.010]   - Field: ‘persistent’
[13:17:32.010]   - Field: ‘expr’
[13:17:32.010]   - Field: ‘uuid’
[13:17:32.010]   - Field: ‘seed’
[13:17:32.010]   - Field: ‘version’
[13:17:32.010]   - Field: ‘result’
[13:17:32.011]   - Field: ‘asynchronous’
[13:17:32.011]   - Field: ‘calls’
[13:17:32.011]   - Field: ‘globals’
[13:17:32.011]   - Field: ‘stdout’
[13:17:32.011]   - Field: ‘earlySignal’
[13:17:32.011]   - Field: ‘lazy’
[13:17:32.011]   - Field: ‘state’
[13:17:32.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:32.011] - Launch lazy future ...
[13:17:32.012] Packages needed by the future expression (n = 0): <none>
[13:17:32.012] Packages needed by future strategies (n = 0): <none>
[13:17:32.012] {
[13:17:32.012]     {
[13:17:32.012]         {
[13:17:32.012]             ...future.startTime <- base::Sys.time()
[13:17:32.012]             {
[13:17:32.012]                 {
[13:17:32.012]                   {
[13:17:32.012]                     {
[13:17:32.012]                       base::local({
[13:17:32.012]                         has_future <- base::requireNamespace("future", 
[13:17:32.012]                           quietly = TRUE)
[13:17:32.012]                         if (has_future) {
[13:17:32.012]                           ns <- base::getNamespace("future")
[13:17:32.012]                           version <- ns[[".package"]][["version"]]
[13:17:32.012]                           if (is.null(version)) 
[13:17:32.012]                             version <- utils::packageVersion("future")
[13:17:32.012]                         }
[13:17:32.012]                         else {
[13:17:32.012]                           version <- NULL
[13:17:32.012]                         }
[13:17:32.012]                         if (!has_future || version < "1.8.0") {
[13:17:32.012]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.012]                             "", base::R.version$version.string), 
[13:17:32.012]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.012]                               "release", "version")], collapse = " "), 
[13:17:32.012]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.012]                             info)
[13:17:32.012]                           info <- base::paste(info, collapse = "; ")
[13:17:32.012]                           if (!has_future) {
[13:17:32.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.012]                               info)
[13:17:32.012]                           }
[13:17:32.012]                           else {
[13:17:32.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.012]                               info, version)
[13:17:32.012]                           }
[13:17:32.012]                           base::stop(msg)
[13:17:32.012]                         }
[13:17:32.012]                       })
[13:17:32.012]                     }
[13:17:32.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.012]                     base::options(mc.cores = 1L)
[13:17:32.012]                   }
[13:17:32.012]                   options(future.plan = NULL)
[13:17:32.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.012]                 }
[13:17:32.012]                 ...future.workdir <- getwd()
[13:17:32.012]             }
[13:17:32.012]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.012]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.012]         }
[13:17:32.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.012]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:32.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.012]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.012]             base::names(...future.oldOptions))
[13:17:32.012]     }
[13:17:32.012]     if (FALSE) {
[13:17:32.012]     }
[13:17:32.012]     else {
[13:17:32.012]         if (TRUE) {
[13:17:32.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.012]                 open = "w")
[13:17:32.012]         }
[13:17:32.012]         else {
[13:17:32.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.012]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.012]         }
[13:17:32.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.012]             base::sink(type = "output", split = FALSE)
[13:17:32.012]             base::close(...future.stdout)
[13:17:32.012]         }, add = TRUE)
[13:17:32.012]     }
[13:17:32.012]     ...future.frame <- base::sys.nframe()
[13:17:32.012]     ...future.conditions <- base::list()
[13:17:32.012]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.012]     if (FALSE) {
[13:17:32.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.012]     }
[13:17:32.012]     ...future.result <- base::tryCatch({
[13:17:32.012]         base::withCallingHandlers({
[13:17:32.012]             ...future.value <- base::withVisible(base::local({
[13:17:32.012]                 ...future.makeSendCondition <- local({
[13:17:32.012]                   sendCondition <- NULL
[13:17:32.012]                   function(frame = 1L) {
[13:17:32.012]                     if (is.function(sendCondition)) 
[13:17:32.012]                       return(sendCondition)
[13:17:32.012]                     ns <- getNamespace("parallel")
[13:17:32.012]                     if (exists("sendData", mode = "function", 
[13:17:32.012]                       envir = ns)) {
[13:17:32.012]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:32.012]                         envir = ns)
[13:17:32.012]                       envir <- sys.frame(frame)
[13:17:32.012]                       master <- NULL
[13:17:32.012]                       while (!identical(envir, .GlobalEnv) && 
[13:17:32.012]                         !identical(envir, emptyenv())) {
[13:17:32.012]                         if (exists("master", mode = "list", envir = envir, 
[13:17:32.012]                           inherits = FALSE)) {
[13:17:32.012]                           master <- get("master", mode = "list", 
[13:17:32.012]                             envir = envir, inherits = FALSE)
[13:17:32.012]                           if (inherits(master, c("SOCKnode", 
[13:17:32.012]                             "SOCK0node"))) {
[13:17:32.012]                             sendCondition <<- function(cond) {
[13:17:32.012]                               data <- list(type = "VALUE", value = cond, 
[13:17:32.012]                                 success = TRUE)
[13:17:32.012]                               parallel_sendData(master, data)
[13:17:32.012]                             }
[13:17:32.012]                             return(sendCondition)
[13:17:32.012]                           }
[13:17:32.012]                         }
[13:17:32.012]                         frame <- frame + 1L
[13:17:32.012]                         envir <- sys.frame(frame)
[13:17:32.012]                       }
[13:17:32.012]                     }
[13:17:32.012]                     sendCondition <<- function(cond) NULL
[13:17:32.012]                   }
[13:17:32.012]                 })
[13:17:32.012]                 withCallingHandlers({
[13:17:32.012]                   {
[13:17:32.012]                     do.call(function(...) {
[13:17:32.012]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.012]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.012]                         ...future.globals.maxSize)) {
[13:17:32.012]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.012]                         on.exit(options(oopts), add = TRUE)
[13:17:32.012]                       }
[13:17:32.012]                       {
[13:17:32.012]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.012]                           FUN = function(jj) {
[13:17:32.012]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.012]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.012]                           })
[13:17:32.012]                       }
[13:17:32.012]                     }, args = future.call.arguments)
[13:17:32.012]                   }
[13:17:32.012]                 }, immediateCondition = function(cond) {
[13:17:32.012]                   sendCondition <- ...future.makeSendCondition()
[13:17:32.012]                   sendCondition(cond)
[13:17:32.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.012]                   {
[13:17:32.012]                     inherits <- base::inherits
[13:17:32.012]                     invokeRestart <- base::invokeRestart
[13:17:32.012]                     is.null <- base::is.null
[13:17:32.012]                     muffled <- FALSE
[13:17:32.012]                     if (inherits(cond, "message")) {
[13:17:32.012]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.012]                       if (muffled) 
[13:17:32.012]                         invokeRestart("muffleMessage")
[13:17:32.012]                     }
[13:17:32.012]                     else if (inherits(cond, "warning")) {
[13:17:32.012]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.012]                       if (muffled) 
[13:17:32.012]                         invokeRestart("muffleWarning")
[13:17:32.012]                     }
[13:17:32.012]                     else if (inherits(cond, "condition")) {
[13:17:32.012]                       if (!is.null(pattern)) {
[13:17:32.012]                         computeRestarts <- base::computeRestarts
[13:17:32.012]                         grepl <- base::grepl
[13:17:32.012]                         restarts <- computeRestarts(cond)
[13:17:32.012]                         for (restart in restarts) {
[13:17:32.012]                           name <- restart$name
[13:17:32.012]                           if (is.null(name)) 
[13:17:32.012]                             next
[13:17:32.012]                           if (!grepl(pattern, name)) 
[13:17:32.012]                             next
[13:17:32.012]                           invokeRestart(restart)
[13:17:32.012]                           muffled <- TRUE
[13:17:32.012]                           break
[13:17:32.012]                         }
[13:17:32.012]                       }
[13:17:32.012]                     }
[13:17:32.012]                     invisible(muffled)
[13:17:32.012]                   }
[13:17:32.012]                   muffleCondition(cond)
[13:17:32.012]                 })
[13:17:32.012]             }))
[13:17:32.012]             future::FutureResult(value = ...future.value$value, 
[13:17:32.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.012]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.012]                     ...future.globalenv.names))
[13:17:32.012]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.012]         }, condition = base::local({
[13:17:32.012]             c <- base::c
[13:17:32.012]             inherits <- base::inherits
[13:17:32.012]             invokeRestart <- base::invokeRestart
[13:17:32.012]             length <- base::length
[13:17:32.012]             list <- base::list
[13:17:32.012]             seq.int <- base::seq.int
[13:17:32.012]             signalCondition <- base::signalCondition
[13:17:32.012]             sys.calls <- base::sys.calls
[13:17:32.012]             `[[` <- base::`[[`
[13:17:32.012]             `+` <- base::`+`
[13:17:32.012]             `<<-` <- base::`<<-`
[13:17:32.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.012]                   3L)]
[13:17:32.012]             }
[13:17:32.012]             function(cond) {
[13:17:32.012]                 is_error <- inherits(cond, "error")
[13:17:32.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.012]                   NULL)
[13:17:32.012]                 if (is_error) {
[13:17:32.012]                   sessionInformation <- function() {
[13:17:32.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.012]                       search = base::search(), system = base::Sys.info())
[13:17:32.012]                   }
[13:17:32.012]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.012]                     cond$call), session = sessionInformation(), 
[13:17:32.012]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.012]                   signalCondition(cond)
[13:17:32.012]                 }
[13:17:32.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.012]                 "immediateCondition"))) {
[13:17:32.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.012]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.012]                   if (TRUE && !signal) {
[13:17:32.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.012]                     {
[13:17:32.012]                       inherits <- base::inherits
[13:17:32.012]                       invokeRestart <- base::invokeRestart
[13:17:32.012]                       is.null <- base::is.null
[13:17:32.012]                       muffled <- FALSE
[13:17:32.012]                       if (inherits(cond, "message")) {
[13:17:32.012]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.012]                         if (muffled) 
[13:17:32.012]                           invokeRestart("muffleMessage")
[13:17:32.012]                       }
[13:17:32.012]                       else if (inherits(cond, "warning")) {
[13:17:32.012]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.012]                         if (muffled) 
[13:17:32.012]                           invokeRestart("muffleWarning")
[13:17:32.012]                       }
[13:17:32.012]                       else if (inherits(cond, "condition")) {
[13:17:32.012]                         if (!is.null(pattern)) {
[13:17:32.012]                           computeRestarts <- base::computeRestarts
[13:17:32.012]                           grepl <- base::grepl
[13:17:32.012]                           restarts <- computeRestarts(cond)
[13:17:32.012]                           for (restart in restarts) {
[13:17:32.012]                             name <- restart$name
[13:17:32.012]                             if (is.null(name)) 
[13:17:32.012]                               next
[13:17:32.012]                             if (!grepl(pattern, name)) 
[13:17:32.012]                               next
[13:17:32.012]                             invokeRestart(restart)
[13:17:32.012]                             muffled <- TRUE
[13:17:32.012]                             break
[13:17:32.012]                           }
[13:17:32.012]                         }
[13:17:32.012]                       }
[13:17:32.012]                       invisible(muffled)
[13:17:32.012]                     }
[13:17:32.012]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.012]                   }
[13:17:32.012]                 }
[13:17:32.012]                 else {
[13:17:32.012]                   if (TRUE) {
[13:17:32.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.012]                     {
[13:17:32.012]                       inherits <- base::inherits
[13:17:32.012]                       invokeRestart <- base::invokeRestart
[13:17:32.012]                       is.null <- base::is.null
[13:17:32.012]                       muffled <- FALSE
[13:17:32.012]                       if (inherits(cond, "message")) {
[13:17:32.012]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.012]                         if (muffled) 
[13:17:32.012]                           invokeRestart("muffleMessage")
[13:17:32.012]                       }
[13:17:32.012]                       else if (inherits(cond, "warning")) {
[13:17:32.012]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.012]                         if (muffled) 
[13:17:32.012]                           invokeRestart("muffleWarning")
[13:17:32.012]                       }
[13:17:32.012]                       else if (inherits(cond, "condition")) {
[13:17:32.012]                         if (!is.null(pattern)) {
[13:17:32.012]                           computeRestarts <- base::computeRestarts
[13:17:32.012]                           grepl <- base::grepl
[13:17:32.012]                           restarts <- computeRestarts(cond)
[13:17:32.012]                           for (restart in restarts) {
[13:17:32.012]                             name <- restart$name
[13:17:32.012]                             if (is.null(name)) 
[13:17:32.012]                               next
[13:17:32.012]                             if (!grepl(pattern, name)) 
[13:17:32.012]                               next
[13:17:32.012]                             invokeRestart(restart)
[13:17:32.012]                             muffled <- TRUE
[13:17:32.012]                             break
[13:17:32.012]                           }
[13:17:32.012]                         }
[13:17:32.012]                       }
[13:17:32.012]                       invisible(muffled)
[13:17:32.012]                     }
[13:17:32.012]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.012]                   }
[13:17:32.012]                 }
[13:17:32.012]             }
[13:17:32.012]         }))
[13:17:32.012]     }, error = function(ex) {
[13:17:32.012]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.012]                 ...future.rng), started = ...future.startTime, 
[13:17:32.012]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.012]             version = "1.8"), class = "FutureResult")
[13:17:32.012]     }, finally = {
[13:17:32.012]         if (!identical(...future.workdir, getwd())) 
[13:17:32.012]             setwd(...future.workdir)
[13:17:32.012]         {
[13:17:32.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.012]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.012]             }
[13:17:32.012]             base::options(...future.oldOptions)
[13:17:32.012]             if (.Platform$OS.type == "windows") {
[13:17:32.012]                 old_names <- names(...future.oldEnvVars)
[13:17:32.012]                 envs <- base::Sys.getenv()
[13:17:32.012]                 names <- names(envs)
[13:17:32.012]                 common <- intersect(names, old_names)
[13:17:32.012]                 added <- setdiff(names, old_names)
[13:17:32.012]                 removed <- setdiff(old_names, names)
[13:17:32.012]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.012]                   envs[common]]
[13:17:32.012]                 NAMES <- toupper(changed)
[13:17:32.012]                 args <- list()
[13:17:32.012]                 for (kk in seq_along(NAMES)) {
[13:17:32.012]                   name <- changed[[kk]]
[13:17:32.012]                   NAME <- NAMES[[kk]]
[13:17:32.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.012]                     next
[13:17:32.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.012]                 }
[13:17:32.012]                 NAMES <- toupper(added)
[13:17:32.012]                 for (kk in seq_along(NAMES)) {
[13:17:32.012]                   name <- added[[kk]]
[13:17:32.012]                   NAME <- NAMES[[kk]]
[13:17:32.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.012]                     next
[13:17:32.012]                   args[[name]] <- ""
[13:17:32.012]                 }
[13:17:32.012]                 NAMES <- toupper(removed)
[13:17:32.012]                 for (kk in seq_along(NAMES)) {
[13:17:32.012]                   name <- removed[[kk]]
[13:17:32.012]                   NAME <- NAMES[[kk]]
[13:17:32.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.012]                     next
[13:17:32.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.012]                 }
[13:17:32.012]                 if (length(args) > 0) 
[13:17:32.012]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.012]             }
[13:17:32.012]             else {
[13:17:32.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.012]             }
[13:17:32.012]             {
[13:17:32.012]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.012]                   0L) {
[13:17:32.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.012]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.012]                   base::options(opts)
[13:17:32.012]                 }
[13:17:32.012]                 {
[13:17:32.012]                   {
[13:17:32.012]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.012]                     NULL
[13:17:32.012]                   }
[13:17:32.012]                   options(future.plan = NULL)
[13:17:32.012]                   if (is.na(NA_character_)) 
[13:17:32.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.012]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:32.012]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:32.012]                     envir = parent.frame()) 
[13:17:32.012]                   {
[13:17:32.012]                     if (is.function(workers)) 
[13:17:32.012]                       workers <- workers()
[13:17:32.012]                     workers <- structure(as.integer(workers), 
[13:17:32.012]                       class = class(workers))
[13:17:32.012]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:32.012]                       workers >= 1)
[13:17:32.012]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:32.012]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:32.012]                     }
[13:17:32.012]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:32.012]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:32.012]                       envir = envir)
[13:17:32.012]                     if (!future$lazy) 
[13:17:32.012]                       future <- run(future)
[13:17:32.012]                     invisible(future)
[13:17:32.012]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.012]                 }
[13:17:32.012]             }
[13:17:32.012]         }
[13:17:32.012]     })
[13:17:32.012]     if (TRUE) {
[13:17:32.012]         base::sink(type = "output", split = FALSE)
[13:17:32.012]         if (TRUE) {
[13:17:32.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.012]         }
[13:17:32.012]         else {
[13:17:32.012]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.012]         }
[13:17:32.012]         base::close(...future.stdout)
[13:17:32.012]         ...future.stdout <- NULL
[13:17:32.012]     }
[13:17:32.012]     ...future.result$conditions <- ...future.conditions
[13:17:32.012]     ...future.result$finished <- base::Sys.time()
[13:17:32.012]     ...future.result
[13:17:32.012] }
[13:17:32.015] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:17:32.015] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:17:32.016] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:17:32.016] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:32.016] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:32.016] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:17:32.017] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:17:32.017] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:32.017] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:32.017] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:32.018] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:32.018] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:17:32.018] MultisessionFuture started
[13:17:32.018] - Launch lazy future ... done
[13:17:32.018] run() for ‘MultisessionFuture’ ... done
[13:17:32.019] Created future:
[13:17:32.019] MultisessionFuture:
[13:17:32.019] Label: ‘future_by-2’
[13:17:32.019] Expression:
[13:17:32.019] {
[13:17:32.019]     do.call(function(...) {
[13:17:32.019]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.019]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.019]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.019]             on.exit(options(oopts), add = TRUE)
[13:17:32.019]         }
[13:17:32.019]         {
[13:17:32.019]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.019]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.019]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.019]             })
[13:17:32.019]         }
[13:17:32.019]     }, args = future.call.arguments)
[13:17:32.019] }
[13:17:32.019] Lazy evaluation: FALSE
[13:17:32.019] Asynchronous evaluation: TRUE
[13:17:32.019] Local evaluation: TRUE
[13:17:32.019] Environment: 0x5609ebde37b8
[13:17:32.019] Capture standard output: TRUE
[13:17:32.019] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.019] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.019] Packages: <none>
[13:17:32.019] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.019] Resolved: FALSE
[13:17:32.019] Value: <not collected>
[13:17:32.019] Conditions captured: <none>
[13:17:32.019] Early signaling: FALSE
[13:17:32.019] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:32.019] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.030] Chunk #2 of 2 ... DONE
[13:17:32.030] Launching 2 futures (chunks) ... DONE
[13:17:32.031] Resolving 2 futures (chunks) ...
[13:17:32.031] resolve() on list ...
[13:17:32.031]  recursive: 0
[13:17:32.031]  length: 2
[13:17:32.031] 
[13:17:32.031] receiveMessageFromWorker() for ClusterFuture ...
[13:17:32.032] - Validating connection of MultisessionFuture
[13:17:32.032] - received message: FutureResult
[13:17:32.032] - Received FutureResult
[13:17:32.032] - Erased future from FutureRegistry
[13:17:32.032] result() for ClusterFuture ...
[13:17:32.032] - result already collected: FutureResult
[13:17:32.034] result() for ClusterFuture ... done
[13:17:32.034] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:32.035] Future #1
[13:17:32.035] result() for ClusterFuture ...
[13:17:32.035] - result already collected: FutureResult
[13:17:32.035] result() for ClusterFuture ... done
[13:17:32.035] result() for ClusterFuture ...
[13:17:32.035] - result already collected: FutureResult
[13:17:32.035] result() for ClusterFuture ... done
[13:17:32.035] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:32.035] - nx: 2
[13:17:32.035] - relay: TRUE
[13:17:32.035] - stdout: TRUE
[13:17:32.036] - signal: TRUE
[13:17:32.036] - resignal: FALSE
[13:17:32.036] - force: TRUE
[13:17:32.036] - relayed: [n=2] FALSE, FALSE
[13:17:32.036] - queued futures: [n=2] FALSE, FALSE
[13:17:32.036]  - until=1
[13:17:32.036]  - relaying element #1
[13:17:32.036] result() for ClusterFuture ...
[13:17:32.036] - result already collected: FutureResult
[13:17:32.036] result() for ClusterFuture ... done
[13:17:32.036] result() for ClusterFuture ...
[13:17:32.036] - result already collected: FutureResult
[13:17:32.037] result() for ClusterFuture ... done
[13:17:32.037] result() for ClusterFuture ...
[13:17:32.037] - result already collected: FutureResult
[13:17:32.037] result() for ClusterFuture ... done
[13:17:32.037] result() for ClusterFuture ...
[13:17:32.037] - result already collected: FutureResult
[13:17:32.037] result() for ClusterFuture ... done
[13:17:32.037] - relayed: [n=2] TRUE, FALSE
[13:17:32.037] - queued futures: [n=2] TRUE, FALSE
[13:17:32.037] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:32.037]  length: 1 (resolved future 1)
[13:17:32.067] receiveMessageFromWorker() for ClusterFuture ...
[13:17:32.067] - Validating connection of MultisessionFuture
[13:17:32.067] - received message: FutureResult
[13:17:32.067] - Received FutureResult
[13:17:32.068] - Erased future from FutureRegistry
[13:17:32.068] result() for ClusterFuture ...
[13:17:32.068] - result already collected: FutureResult
[13:17:32.068] result() for ClusterFuture ... done
[13:17:32.068] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:32.068] Future #2
[13:17:32.068] result() for ClusterFuture ...
[13:17:32.068] - result already collected: FutureResult
[13:17:32.068] result() for ClusterFuture ... done
[13:17:32.068] result() for ClusterFuture ...
[13:17:32.069] - result already collected: FutureResult
[13:17:32.069] result() for ClusterFuture ... done
[13:17:32.069] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:32.069] - nx: 2
[13:17:32.069] - relay: TRUE
[13:17:32.069] - stdout: TRUE
[13:17:32.069] - signal: TRUE
[13:17:32.069] - resignal: FALSE
[13:17:32.069] - force: TRUE
[13:17:32.069] - relayed: [n=2] TRUE, FALSE
[13:17:32.069] - queued futures: [n=2] TRUE, FALSE
[13:17:32.070]  - until=2
[13:17:32.070]  - relaying element #2
[13:17:32.070] result() for ClusterFuture ...
[13:17:32.070] - result already collected: FutureResult
[13:17:32.070] result() for ClusterFuture ... done
[13:17:32.070] result() for ClusterFuture ...
[13:17:32.070] - result already collected: FutureResult
[13:17:32.070] result() for ClusterFuture ... done
[13:17:32.070] result() for ClusterFuture ...
[13:17:32.070] - result already collected: FutureResult
[13:17:32.070] result() for ClusterFuture ... done
[13:17:32.071] result() for ClusterFuture ...
[13:17:32.071] - result already collected: FutureResult
[13:17:32.071] result() for ClusterFuture ... done
[13:17:32.071] - relayed: [n=2] TRUE, TRUE
[13:17:32.071] - queued futures: [n=2] TRUE, TRUE
[13:17:32.071] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:32.071]  length: 0 (resolved future 2)
[13:17:32.071] Relaying remaining futures
[13:17:32.071] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.071] - nx: 2
[13:17:32.071] - relay: TRUE
[13:17:32.072] - stdout: TRUE
[13:17:32.072] - signal: TRUE
[13:17:32.072] - resignal: FALSE
[13:17:32.072] - force: TRUE
[13:17:32.072] - relayed: [n=2] TRUE, TRUE
[13:17:32.072] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:32.072] - relayed: [n=2] TRUE, TRUE
[13:17:32.072] - queued futures: [n=2] TRUE, TRUE
[13:17:32.072] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.072] resolve() on list ... DONE
[13:17:32.072] result() for ClusterFuture ...
[13:17:32.072] - result already collected: FutureResult
[13:17:32.073] result() for ClusterFuture ... done
[13:17:32.073] result() for ClusterFuture ...
[13:17:32.073] - result already collected: FutureResult
[13:17:32.073] result() for ClusterFuture ... done
[13:17:32.073] result() for ClusterFuture ...
[13:17:32.073] - result already collected: FutureResult
[13:17:32.073] result() for ClusterFuture ... done
[13:17:32.073] result() for ClusterFuture ...
[13:17:32.073] - result already collected: FutureResult
[13:17:32.073] result() for ClusterFuture ... done
[13:17:32.073]  - Number of value chunks collected: 2
[13:17:32.074] Resolving 2 futures (chunks) ... DONE
[13:17:32.074] Reducing values from 2 chunks ...
[13:17:32.074]  - Number of values collected after concatenation: 3
[13:17:32.074]  - Number of values expected: 3
[13:17:32.074] Reducing values from 2 chunks ... DONE
[13:17:32.074] future_lapply() ... DONE
[13:17:32.074] future_by_internal() ... DONE
[13:17:32.075] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:17:32.075] future_lapply() ...
[13:17:32.079] Number of chunks: 2
[13:17:32.079] getGlobalsAndPackagesXApply() ...
[13:17:32.080]  - future.globals: TRUE
[13:17:32.080] getGlobalsAndPackages() ...
[13:17:32.080] Searching for globals...
[13:17:32.081] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.081] Searching for globals ... DONE
[13:17:32.081] Resolving globals: FALSE
[13:17:32.081] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:32.082] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:32.082] - globals: [1] ‘FUN’
[13:17:32.082] 
[13:17:32.082] getGlobalsAndPackages() ... DONE
[13:17:32.082]  - globals found/used: [n=1] ‘FUN’
[13:17:32.082]  - needed namespaces: [n=0] 
[13:17:32.082] Finding globals ... DONE
[13:17:32.082]  - use_args: TRUE
[13:17:32.082]  - Getting '...' globals ...
[13:17:32.083] resolve() on list ...
[13:17:32.083]  recursive: 0
[13:17:32.083]  length: 1
[13:17:32.083]  elements: ‘...’
[13:17:32.083]  length: 0 (resolved future 1)
[13:17:32.083] resolve() on list ... DONE
[13:17:32.083]    - '...' content: [n=0] 
[13:17:32.083] List of 1
[13:17:32.083]  $ ...: list()
[13:17:32.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.083]  - attr(*, "where")=List of 1
[13:17:32.083]   ..$ ...:<environment: 0x5609ec6a3948> 
[13:17:32.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.083]  - attr(*, "resolved")= logi TRUE
[13:17:32.083]  - attr(*, "total_size")= num NA
[13:17:32.086]  - Getting '...' globals ... DONE
[13:17:32.086] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.086] List of 2
[13:17:32.086]  $ ...future.FUN:function (object, ...)  
[13:17:32.086]  $ ...          : list()
[13:17:32.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.086]  - attr(*, "where")=List of 2
[13:17:32.086]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.086]   ..$ ...          :<environment: 0x5609ec6a3948> 
[13:17:32.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.086]  - attr(*, "resolved")= logi FALSE
[13:17:32.086]  - attr(*, "total_size")= num 1240
[13:17:32.089] Packages to be attached in all futures: [n=0] 
[13:17:32.089] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.089] Number of futures (= number of chunks): 2
[13:17:32.089] Launching 2 futures (chunks) ...
[13:17:32.089] Chunk #1 of 2 ...
[13:17:32.089]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.089] getGlobalsAndPackages() ...
[13:17:32.090] Searching for globals...
[13:17:32.090] 
[13:17:32.090] Searching for globals ... DONE
[13:17:32.090] - globals: [0] <none>
[13:17:32.090] getGlobalsAndPackages() ... DONE
[13:17:32.090]    + additional globals found: [n=0] 
[13:17:32.090]    + additional namespaces needed: [n=0] 
[13:17:32.090]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.090]  - seeds: <none>
[13:17:32.091] getGlobalsAndPackages() ...
[13:17:32.091] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.091] Resolving globals: FALSE
[13:17:32.091] Tweak future expression to call with '...' arguments ...
[13:17:32.091] {
[13:17:32.091]     do.call(function(...) {
[13:17:32.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.091]             on.exit(options(oopts), add = TRUE)
[13:17:32.091]         }
[13:17:32.091]         {
[13:17:32.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.091]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.091]             })
[13:17:32.091]         }
[13:17:32.091]     }, args = future.call.arguments)
[13:17:32.091] }
[13:17:32.091] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.092] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.092] 
[13:17:32.092] getGlobalsAndPackages() ... DONE
[13:17:32.092] run() for ‘Future’ ...
[13:17:32.092] - state: ‘created’
[13:17:32.092] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.106] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:32.107]   - Field: ‘node’
[13:17:32.107]   - Field: ‘label’
[13:17:32.107]   - Field: ‘local’
[13:17:32.107]   - Field: ‘owner’
[13:17:32.107]   - Field: ‘envir’
[13:17:32.107]   - Field: ‘workers’
[13:17:32.107]   - Field: ‘packages’
[13:17:32.107]   - Field: ‘gc’
[13:17:32.107]   - Field: ‘conditions’
[13:17:32.107]   - Field: ‘persistent’
[13:17:32.107]   - Field: ‘expr’
[13:17:32.108]   - Field: ‘uuid’
[13:17:32.108]   - Field: ‘seed’
[13:17:32.108]   - Field: ‘version’
[13:17:32.108]   - Field: ‘result’
[13:17:32.108]   - Field: ‘asynchronous’
[13:17:32.108]   - Field: ‘calls’
[13:17:32.108]   - Field: ‘globals’
[13:17:32.108]   - Field: ‘stdout’
[13:17:32.108]   - Field: ‘earlySignal’
[13:17:32.108]   - Field: ‘lazy’
[13:17:32.108]   - Field: ‘state’
[13:17:32.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:32.109] - Launch lazy future ...
[13:17:32.109] Packages needed by the future expression (n = 0): <none>
[13:17:32.109] Packages needed by future strategies (n = 0): <none>
[13:17:32.109] {
[13:17:32.109]     {
[13:17:32.109]         {
[13:17:32.109]             ...future.startTime <- base::Sys.time()
[13:17:32.109]             {
[13:17:32.109]                 {
[13:17:32.109]                   {
[13:17:32.109]                     {
[13:17:32.109]                       base::local({
[13:17:32.109]                         has_future <- base::requireNamespace("future", 
[13:17:32.109]                           quietly = TRUE)
[13:17:32.109]                         if (has_future) {
[13:17:32.109]                           ns <- base::getNamespace("future")
[13:17:32.109]                           version <- ns[[".package"]][["version"]]
[13:17:32.109]                           if (is.null(version)) 
[13:17:32.109]                             version <- utils::packageVersion("future")
[13:17:32.109]                         }
[13:17:32.109]                         else {
[13:17:32.109]                           version <- NULL
[13:17:32.109]                         }
[13:17:32.109]                         if (!has_future || version < "1.8.0") {
[13:17:32.109]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.109]                             "", base::R.version$version.string), 
[13:17:32.109]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.109]                               "release", "version")], collapse = " "), 
[13:17:32.109]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.109]                             info)
[13:17:32.109]                           info <- base::paste(info, collapse = "; ")
[13:17:32.109]                           if (!has_future) {
[13:17:32.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.109]                               info)
[13:17:32.109]                           }
[13:17:32.109]                           else {
[13:17:32.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.109]                               info, version)
[13:17:32.109]                           }
[13:17:32.109]                           base::stop(msg)
[13:17:32.109]                         }
[13:17:32.109]                       })
[13:17:32.109]                     }
[13:17:32.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.109]                     base::options(mc.cores = 1L)
[13:17:32.109]                   }
[13:17:32.109]                   options(future.plan = NULL)
[13:17:32.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.109]                 }
[13:17:32.109]                 ...future.workdir <- getwd()
[13:17:32.109]             }
[13:17:32.109]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.109]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.109]         }
[13:17:32.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:32.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.109]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.109]             base::names(...future.oldOptions))
[13:17:32.109]     }
[13:17:32.109]     if (FALSE) {
[13:17:32.109]     }
[13:17:32.109]     else {
[13:17:32.109]         if (TRUE) {
[13:17:32.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.109]                 open = "w")
[13:17:32.109]         }
[13:17:32.109]         else {
[13:17:32.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.109]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.109]         }
[13:17:32.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.109]             base::sink(type = "output", split = FALSE)
[13:17:32.109]             base::close(...future.stdout)
[13:17:32.109]         }, add = TRUE)
[13:17:32.109]     }
[13:17:32.109]     ...future.frame <- base::sys.nframe()
[13:17:32.109]     ...future.conditions <- base::list()
[13:17:32.109]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.109]     if (FALSE) {
[13:17:32.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.109]     }
[13:17:32.109]     ...future.result <- base::tryCatch({
[13:17:32.109]         base::withCallingHandlers({
[13:17:32.109]             ...future.value <- base::withVisible(base::local({
[13:17:32.109]                 ...future.makeSendCondition <- local({
[13:17:32.109]                   sendCondition <- NULL
[13:17:32.109]                   function(frame = 1L) {
[13:17:32.109]                     if (is.function(sendCondition)) 
[13:17:32.109]                       return(sendCondition)
[13:17:32.109]                     ns <- getNamespace("parallel")
[13:17:32.109]                     if (exists("sendData", mode = "function", 
[13:17:32.109]                       envir = ns)) {
[13:17:32.109]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:32.109]                         envir = ns)
[13:17:32.109]                       envir <- sys.frame(frame)
[13:17:32.109]                       master <- NULL
[13:17:32.109]                       while (!identical(envir, .GlobalEnv) && 
[13:17:32.109]                         !identical(envir, emptyenv())) {
[13:17:32.109]                         if (exists("master", mode = "list", envir = envir, 
[13:17:32.109]                           inherits = FALSE)) {
[13:17:32.109]                           master <- get("master", mode = "list", 
[13:17:32.109]                             envir = envir, inherits = FALSE)
[13:17:32.109]                           if (inherits(master, c("SOCKnode", 
[13:17:32.109]                             "SOCK0node"))) {
[13:17:32.109]                             sendCondition <<- function(cond) {
[13:17:32.109]                               data <- list(type = "VALUE", value = cond, 
[13:17:32.109]                                 success = TRUE)
[13:17:32.109]                               parallel_sendData(master, data)
[13:17:32.109]                             }
[13:17:32.109]                             return(sendCondition)
[13:17:32.109]                           }
[13:17:32.109]                         }
[13:17:32.109]                         frame <- frame + 1L
[13:17:32.109]                         envir <- sys.frame(frame)
[13:17:32.109]                       }
[13:17:32.109]                     }
[13:17:32.109]                     sendCondition <<- function(cond) NULL
[13:17:32.109]                   }
[13:17:32.109]                 })
[13:17:32.109]                 withCallingHandlers({
[13:17:32.109]                   {
[13:17:32.109]                     do.call(function(...) {
[13:17:32.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.109]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.109]                         ...future.globals.maxSize)) {
[13:17:32.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.109]                         on.exit(options(oopts), add = TRUE)
[13:17:32.109]                       }
[13:17:32.109]                       {
[13:17:32.109]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.109]                           FUN = function(jj) {
[13:17:32.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.109]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.109]                           })
[13:17:32.109]                       }
[13:17:32.109]                     }, args = future.call.arguments)
[13:17:32.109]                   }
[13:17:32.109]                 }, immediateCondition = function(cond) {
[13:17:32.109]                   sendCondition <- ...future.makeSendCondition()
[13:17:32.109]                   sendCondition(cond)
[13:17:32.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.109]                   {
[13:17:32.109]                     inherits <- base::inherits
[13:17:32.109]                     invokeRestart <- base::invokeRestart
[13:17:32.109]                     is.null <- base::is.null
[13:17:32.109]                     muffled <- FALSE
[13:17:32.109]                     if (inherits(cond, "message")) {
[13:17:32.109]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.109]                       if (muffled) 
[13:17:32.109]                         invokeRestart("muffleMessage")
[13:17:32.109]                     }
[13:17:32.109]                     else if (inherits(cond, "warning")) {
[13:17:32.109]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.109]                       if (muffled) 
[13:17:32.109]                         invokeRestart("muffleWarning")
[13:17:32.109]                     }
[13:17:32.109]                     else if (inherits(cond, "condition")) {
[13:17:32.109]                       if (!is.null(pattern)) {
[13:17:32.109]                         computeRestarts <- base::computeRestarts
[13:17:32.109]                         grepl <- base::grepl
[13:17:32.109]                         restarts <- computeRestarts(cond)
[13:17:32.109]                         for (restart in restarts) {
[13:17:32.109]                           name <- restart$name
[13:17:32.109]                           if (is.null(name)) 
[13:17:32.109]                             next
[13:17:32.109]                           if (!grepl(pattern, name)) 
[13:17:32.109]                             next
[13:17:32.109]                           invokeRestart(restart)
[13:17:32.109]                           muffled <- TRUE
[13:17:32.109]                           break
[13:17:32.109]                         }
[13:17:32.109]                       }
[13:17:32.109]                     }
[13:17:32.109]                     invisible(muffled)
[13:17:32.109]                   }
[13:17:32.109]                   muffleCondition(cond)
[13:17:32.109]                 })
[13:17:32.109]             }))
[13:17:32.109]             future::FutureResult(value = ...future.value$value, 
[13:17:32.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.109]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.109]                     ...future.globalenv.names))
[13:17:32.109]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.109]         }, condition = base::local({
[13:17:32.109]             c <- base::c
[13:17:32.109]             inherits <- base::inherits
[13:17:32.109]             invokeRestart <- base::invokeRestart
[13:17:32.109]             length <- base::length
[13:17:32.109]             list <- base::list
[13:17:32.109]             seq.int <- base::seq.int
[13:17:32.109]             signalCondition <- base::signalCondition
[13:17:32.109]             sys.calls <- base::sys.calls
[13:17:32.109]             `[[` <- base::`[[`
[13:17:32.109]             `+` <- base::`+`
[13:17:32.109]             `<<-` <- base::`<<-`
[13:17:32.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.109]                   3L)]
[13:17:32.109]             }
[13:17:32.109]             function(cond) {
[13:17:32.109]                 is_error <- inherits(cond, "error")
[13:17:32.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.109]                   NULL)
[13:17:32.109]                 if (is_error) {
[13:17:32.109]                   sessionInformation <- function() {
[13:17:32.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.109]                       search = base::search(), system = base::Sys.info())
[13:17:32.109]                   }
[13:17:32.109]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.109]                     cond$call), session = sessionInformation(), 
[13:17:32.109]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.109]                   signalCondition(cond)
[13:17:32.109]                 }
[13:17:32.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.109]                 "immediateCondition"))) {
[13:17:32.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.109]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.109]                   if (TRUE && !signal) {
[13:17:32.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.109]                     {
[13:17:32.109]                       inherits <- base::inherits
[13:17:32.109]                       invokeRestart <- base::invokeRestart
[13:17:32.109]                       is.null <- base::is.null
[13:17:32.109]                       muffled <- FALSE
[13:17:32.109]                       if (inherits(cond, "message")) {
[13:17:32.109]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.109]                         if (muffled) 
[13:17:32.109]                           invokeRestart("muffleMessage")
[13:17:32.109]                       }
[13:17:32.109]                       else if (inherits(cond, "warning")) {
[13:17:32.109]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.109]                         if (muffled) 
[13:17:32.109]                           invokeRestart("muffleWarning")
[13:17:32.109]                       }
[13:17:32.109]                       else if (inherits(cond, "condition")) {
[13:17:32.109]                         if (!is.null(pattern)) {
[13:17:32.109]                           computeRestarts <- base::computeRestarts
[13:17:32.109]                           grepl <- base::grepl
[13:17:32.109]                           restarts <- computeRestarts(cond)
[13:17:32.109]                           for (restart in restarts) {
[13:17:32.109]                             name <- restart$name
[13:17:32.109]                             if (is.null(name)) 
[13:17:32.109]                               next
[13:17:32.109]                             if (!grepl(pattern, name)) 
[13:17:32.109]                               next
[13:17:32.109]                             invokeRestart(restart)
[13:17:32.109]                             muffled <- TRUE
[13:17:32.109]                             break
[13:17:32.109]                           }
[13:17:32.109]                         }
[13:17:32.109]                       }
[13:17:32.109]                       invisible(muffled)
[13:17:32.109]                     }
[13:17:32.109]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.109]                   }
[13:17:32.109]                 }
[13:17:32.109]                 else {
[13:17:32.109]                   if (TRUE) {
[13:17:32.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.109]                     {
[13:17:32.109]                       inherits <- base::inherits
[13:17:32.109]                       invokeRestart <- base::invokeRestart
[13:17:32.109]                       is.null <- base::is.null
[13:17:32.109]                       muffled <- FALSE
[13:17:32.109]                       if (inherits(cond, "message")) {
[13:17:32.109]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.109]                         if (muffled) 
[13:17:32.109]                           invokeRestart("muffleMessage")
[13:17:32.109]                       }
[13:17:32.109]                       else if (inherits(cond, "warning")) {
[13:17:32.109]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.109]                         if (muffled) 
[13:17:32.109]                           invokeRestart("muffleWarning")
[13:17:32.109]                       }
[13:17:32.109]                       else if (inherits(cond, "condition")) {
[13:17:32.109]                         if (!is.null(pattern)) {
[13:17:32.109]                           computeRestarts <- base::computeRestarts
[13:17:32.109]                           grepl <- base::grepl
[13:17:32.109]                           restarts <- computeRestarts(cond)
[13:17:32.109]                           for (restart in restarts) {
[13:17:32.109]                             name <- restart$name
[13:17:32.109]                             if (is.null(name)) 
[13:17:32.109]                               next
[13:17:32.109]                             if (!grepl(pattern, name)) 
[13:17:32.109]                               next
[13:17:32.109]                             invokeRestart(restart)
[13:17:32.109]                             muffled <- TRUE
[13:17:32.109]                             break
[13:17:32.109]                           }
[13:17:32.109]                         }
[13:17:32.109]                       }
[13:17:32.109]                       invisible(muffled)
[13:17:32.109]                     }
[13:17:32.109]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.109]                   }
[13:17:32.109]                 }
[13:17:32.109]             }
[13:17:32.109]         }))
[13:17:32.109]     }, error = function(ex) {
[13:17:32.109]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.109]                 ...future.rng), started = ...future.startTime, 
[13:17:32.109]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.109]             version = "1.8"), class = "FutureResult")
[13:17:32.109]     }, finally = {
[13:17:32.109]         if (!identical(...future.workdir, getwd())) 
[13:17:32.109]             setwd(...future.workdir)
[13:17:32.109]         {
[13:17:32.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.109]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.109]             }
[13:17:32.109]             base::options(...future.oldOptions)
[13:17:32.109]             if (.Platform$OS.type == "windows") {
[13:17:32.109]                 old_names <- names(...future.oldEnvVars)
[13:17:32.109]                 envs <- base::Sys.getenv()
[13:17:32.109]                 names <- names(envs)
[13:17:32.109]                 common <- intersect(names, old_names)
[13:17:32.109]                 added <- setdiff(names, old_names)
[13:17:32.109]                 removed <- setdiff(old_names, names)
[13:17:32.109]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.109]                   envs[common]]
[13:17:32.109]                 NAMES <- toupper(changed)
[13:17:32.109]                 args <- list()
[13:17:32.109]                 for (kk in seq_along(NAMES)) {
[13:17:32.109]                   name <- changed[[kk]]
[13:17:32.109]                   NAME <- NAMES[[kk]]
[13:17:32.109]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.109]                     next
[13:17:32.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.109]                 }
[13:17:32.109]                 NAMES <- toupper(added)
[13:17:32.109]                 for (kk in seq_along(NAMES)) {
[13:17:32.109]                   name <- added[[kk]]
[13:17:32.109]                   NAME <- NAMES[[kk]]
[13:17:32.109]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.109]                     next
[13:17:32.109]                   args[[name]] <- ""
[13:17:32.109]                 }
[13:17:32.109]                 NAMES <- toupper(removed)
[13:17:32.109]                 for (kk in seq_along(NAMES)) {
[13:17:32.109]                   name <- removed[[kk]]
[13:17:32.109]                   NAME <- NAMES[[kk]]
[13:17:32.109]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.109]                     next
[13:17:32.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.109]                 }
[13:17:32.109]                 if (length(args) > 0) 
[13:17:32.109]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.109]             }
[13:17:32.109]             else {
[13:17:32.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.109]             }
[13:17:32.109]             {
[13:17:32.109]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.109]                   0L) {
[13:17:32.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.109]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.109]                   base::options(opts)
[13:17:32.109]                 }
[13:17:32.109]                 {
[13:17:32.109]                   {
[13:17:32.109]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.109]                     NULL
[13:17:32.109]                   }
[13:17:32.109]                   options(future.plan = NULL)
[13:17:32.109]                   if (is.na(NA_character_)) 
[13:17:32.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.109]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:32.109]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:32.109]                     envir = parent.frame()) 
[13:17:32.109]                   {
[13:17:32.109]                     if (is.function(workers)) 
[13:17:32.109]                       workers <- workers()
[13:17:32.109]                     workers <- structure(as.integer(workers), 
[13:17:32.109]                       class = class(workers))
[13:17:32.109]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:32.109]                       workers >= 1)
[13:17:32.109]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:32.109]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:32.109]                     }
[13:17:32.109]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:32.109]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:32.109]                       envir = envir)
[13:17:32.109]                     if (!future$lazy) 
[13:17:32.109]                       future <- run(future)
[13:17:32.109]                     invisible(future)
[13:17:32.109]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.109]                 }
[13:17:32.109]             }
[13:17:32.109]         }
[13:17:32.109]     })
[13:17:32.109]     if (TRUE) {
[13:17:32.109]         base::sink(type = "output", split = FALSE)
[13:17:32.109]         if (TRUE) {
[13:17:32.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.109]         }
[13:17:32.109]         else {
[13:17:32.109]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.109]         }
[13:17:32.109]         base::close(...future.stdout)
[13:17:32.109]         ...future.stdout <- NULL
[13:17:32.109]     }
[13:17:32.109]     ...future.result$conditions <- ...future.conditions
[13:17:32.109]     ...future.result$finished <- base::Sys.time()
[13:17:32.109]     ...future.result
[13:17:32.109] }
[13:17:32.112] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:17:32.112] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:17:32.113] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:17:32.113] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:32.113] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:32.114] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:17:32.114] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:17:32.114] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:32.115] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:32.115] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:32.115] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:32.115] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:17:32.116] MultisessionFuture started
[13:17:32.116] - Launch lazy future ... done
[13:17:32.116] run() for ‘MultisessionFuture’ ... done
[13:17:32.116] Created future:
[13:17:32.116] MultisessionFuture:
[13:17:32.116] Label: ‘future_by-1’
[13:17:32.116] Expression:
[13:17:32.116] {
[13:17:32.116]     do.call(function(...) {
[13:17:32.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.116]             on.exit(options(oopts), add = TRUE)
[13:17:32.116]         }
[13:17:32.116]         {
[13:17:32.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.116]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.116]             })
[13:17:32.116]         }
[13:17:32.116]     }, args = future.call.arguments)
[13:17:32.116] }
[13:17:32.116] Lazy evaluation: FALSE
[13:17:32.116] Asynchronous evaluation: TRUE
[13:17:32.116] Local evaluation: TRUE
[13:17:32.116] Environment: 0x5609ec6d68e0
[13:17:32.116] Capture standard output: TRUE
[13:17:32.116] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.116] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.116] Packages: <none>
[13:17:32.116] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.116] Resolved: FALSE
[13:17:32.116] Value: <not collected>
[13:17:32.116] Conditions captured: <none>
[13:17:32.116] Early signaling: FALSE
[13:17:32.116] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:32.116] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.128] Chunk #1 of 2 ... DONE
[13:17:32.128] Chunk #2 of 2 ...
[13:17:32.128]  - Finding globals in 'X' for chunk #2 ...
[13:17:32.128] getGlobalsAndPackages() ...
[13:17:32.128] Searching for globals...
[13:17:32.129] 
[13:17:32.129] Searching for globals ... DONE
[13:17:32.129] - globals: [0] <none>
[13:17:32.129] getGlobalsAndPackages() ... DONE
[13:17:32.129]    + additional globals found: [n=0] 
[13:17:32.129]    + additional namespaces needed: [n=0] 
[13:17:32.129]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:32.130]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:32.130]  - seeds: <none>
[13:17:32.130] getGlobalsAndPackages() ...
[13:17:32.130] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.130] Resolving globals: FALSE
[13:17:32.130] Tweak future expression to call with '...' arguments ...
[13:17:32.130] {
[13:17:32.130]     do.call(function(...) {
[13:17:32.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.130]             on.exit(options(oopts), add = TRUE)
[13:17:32.130]         }
[13:17:32.130]         {
[13:17:32.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.130]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.130]             })
[13:17:32.130]         }
[13:17:32.130]     }, args = future.call.arguments)
[13:17:32.130] }
[13:17:32.130] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.131] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.131] 
[13:17:32.131] getGlobalsAndPackages() ... DONE
[13:17:32.131] run() for ‘Future’ ...
[13:17:32.131] - state: ‘created’
[13:17:32.131] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:32.146]   - Field: ‘node’
[13:17:32.146]   - Field: ‘label’
[13:17:32.146]   - Field: ‘local’
[13:17:32.146]   - Field: ‘owner’
[13:17:32.146]   - Field: ‘envir’
[13:17:32.146]   - Field: ‘workers’
[13:17:32.146]   - Field: ‘packages’
[13:17:32.146]   - Field: ‘gc’
[13:17:32.146]   - Field: ‘conditions’
[13:17:32.146]   - Field: ‘persistent’
[13:17:32.147]   - Field: ‘expr’
[13:17:32.147]   - Field: ‘uuid’
[13:17:32.147]   - Field: ‘seed’
[13:17:32.147]   - Field: ‘version’
[13:17:32.147]   - Field: ‘result’
[13:17:32.147]   - Field: ‘asynchronous’
[13:17:32.147]   - Field: ‘calls’
[13:17:32.147]   - Field: ‘globals’
[13:17:32.147]   - Field: ‘stdout’
[13:17:32.147]   - Field: ‘earlySignal’
[13:17:32.147]   - Field: ‘lazy’
[13:17:32.148]   - Field: ‘state’
[13:17:32.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:32.148] - Launch lazy future ...
[13:17:32.148] Packages needed by the future expression (n = 0): <none>
[13:17:32.148] Packages needed by future strategies (n = 0): <none>
[13:17:32.149] {
[13:17:32.149]     {
[13:17:32.149]         {
[13:17:32.149]             ...future.startTime <- base::Sys.time()
[13:17:32.149]             {
[13:17:32.149]                 {
[13:17:32.149]                   {
[13:17:32.149]                     {
[13:17:32.149]                       base::local({
[13:17:32.149]                         has_future <- base::requireNamespace("future", 
[13:17:32.149]                           quietly = TRUE)
[13:17:32.149]                         if (has_future) {
[13:17:32.149]                           ns <- base::getNamespace("future")
[13:17:32.149]                           version <- ns[[".package"]][["version"]]
[13:17:32.149]                           if (is.null(version)) 
[13:17:32.149]                             version <- utils::packageVersion("future")
[13:17:32.149]                         }
[13:17:32.149]                         else {
[13:17:32.149]                           version <- NULL
[13:17:32.149]                         }
[13:17:32.149]                         if (!has_future || version < "1.8.0") {
[13:17:32.149]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.149]                             "", base::R.version$version.string), 
[13:17:32.149]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.149]                               "release", "version")], collapse = " "), 
[13:17:32.149]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.149]                             info)
[13:17:32.149]                           info <- base::paste(info, collapse = "; ")
[13:17:32.149]                           if (!has_future) {
[13:17:32.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.149]                               info)
[13:17:32.149]                           }
[13:17:32.149]                           else {
[13:17:32.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.149]                               info, version)
[13:17:32.149]                           }
[13:17:32.149]                           base::stop(msg)
[13:17:32.149]                         }
[13:17:32.149]                       })
[13:17:32.149]                     }
[13:17:32.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.149]                     base::options(mc.cores = 1L)
[13:17:32.149]                   }
[13:17:32.149]                   options(future.plan = NULL)
[13:17:32.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.149]                 }
[13:17:32.149]                 ...future.workdir <- getwd()
[13:17:32.149]             }
[13:17:32.149]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.149]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.149]         }
[13:17:32.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.149]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:32.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.149]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.149]             base::names(...future.oldOptions))
[13:17:32.149]     }
[13:17:32.149]     if (FALSE) {
[13:17:32.149]     }
[13:17:32.149]     else {
[13:17:32.149]         if (TRUE) {
[13:17:32.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.149]                 open = "w")
[13:17:32.149]         }
[13:17:32.149]         else {
[13:17:32.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.149]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.149]         }
[13:17:32.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.149]             base::sink(type = "output", split = FALSE)
[13:17:32.149]             base::close(...future.stdout)
[13:17:32.149]         }, add = TRUE)
[13:17:32.149]     }
[13:17:32.149]     ...future.frame <- base::sys.nframe()
[13:17:32.149]     ...future.conditions <- base::list()
[13:17:32.149]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.149]     if (FALSE) {
[13:17:32.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.149]     }
[13:17:32.149]     ...future.result <- base::tryCatch({
[13:17:32.149]         base::withCallingHandlers({
[13:17:32.149]             ...future.value <- base::withVisible(base::local({
[13:17:32.149]                 ...future.makeSendCondition <- local({
[13:17:32.149]                   sendCondition <- NULL
[13:17:32.149]                   function(frame = 1L) {
[13:17:32.149]                     if (is.function(sendCondition)) 
[13:17:32.149]                       return(sendCondition)
[13:17:32.149]                     ns <- getNamespace("parallel")
[13:17:32.149]                     if (exists("sendData", mode = "function", 
[13:17:32.149]                       envir = ns)) {
[13:17:32.149]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:32.149]                         envir = ns)
[13:17:32.149]                       envir <- sys.frame(frame)
[13:17:32.149]                       master <- NULL
[13:17:32.149]                       while (!identical(envir, .GlobalEnv) && 
[13:17:32.149]                         !identical(envir, emptyenv())) {
[13:17:32.149]                         if (exists("master", mode = "list", envir = envir, 
[13:17:32.149]                           inherits = FALSE)) {
[13:17:32.149]                           master <- get("master", mode = "list", 
[13:17:32.149]                             envir = envir, inherits = FALSE)
[13:17:32.149]                           if (inherits(master, c("SOCKnode", 
[13:17:32.149]                             "SOCK0node"))) {
[13:17:32.149]                             sendCondition <<- function(cond) {
[13:17:32.149]                               data <- list(type = "VALUE", value = cond, 
[13:17:32.149]                                 success = TRUE)
[13:17:32.149]                               parallel_sendData(master, data)
[13:17:32.149]                             }
[13:17:32.149]                             return(sendCondition)
[13:17:32.149]                           }
[13:17:32.149]                         }
[13:17:32.149]                         frame <- frame + 1L
[13:17:32.149]                         envir <- sys.frame(frame)
[13:17:32.149]                       }
[13:17:32.149]                     }
[13:17:32.149]                     sendCondition <<- function(cond) NULL
[13:17:32.149]                   }
[13:17:32.149]                 })
[13:17:32.149]                 withCallingHandlers({
[13:17:32.149]                   {
[13:17:32.149]                     do.call(function(...) {
[13:17:32.149]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.149]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.149]                         ...future.globals.maxSize)) {
[13:17:32.149]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.149]                         on.exit(options(oopts), add = TRUE)
[13:17:32.149]                       }
[13:17:32.149]                       {
[13:17:32.149]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.149]                           FUN = function(jj) {
[13:17:32.149]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.149]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.149]                           })
[13:17:32.149]                       }
[13:17:32.149]                     }, args = future.call.arguments)
[13:17:32.149]                   }
[13:17:32.149]                 }, immediateCondition = function(cond) {
[13:17:32.149]                   sendCondition <- ...future.makeSendCondition()
[13:17:32.149]                   sendCondition(cond)
[13:17:32.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.149]                   {
[13:17:32.149]                     inherits <- base::inherits
[13:17:32.149]                     invokeRestart <- base::invokeRestart
[13:17:32.149]                     is.null <- base::is.null
[13:17:32.149]                     muffled <- FALSE
[13:17:32.149]                     if (inherits(cond, "message")) {
[13:17:32.149]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.149]                       if (muffled) 
[13:17:32.149]                         invokeRestart("muffleMessage")
[13:17:32.149]                     }
[13:17:32.149]                     else if (inherits(cond, "warning")) {
[13:17:32.149]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.149]                       if (muffled) 
[13:17:32.149]                         invokeRestart("muffleWarning")
[13:17:32.149]                     }
[13:17:32.149]                     else if (inherits(cond, "condition")) {
[13:17:32.149]                       if (!is.null(pattern)) {
[13:17:32.149]                         computeRestarts <- base::computeRestarts
[13:17:32.149]                         grepl <- base::grepl
[13:17:32.149]                         restarts <- computeRestarts(cond)
[13:17:32.149]                         for (restart in restarts) {
[13:17:32.149]                           name <- restart$name
[13:17:32.149]                           if (is.null(name)) 
[13:17:32.149]                             next
[13:17:32.149]                           if (!grepl(pattern, name)) 
[13:17:32.149]                             next
[13:17:32.149]                           invokeRestart(restart)
[13:17:32.149]                           muffled <- TRUE
[13:17:32.149]                           break
[13:17:32.149]                         }
[13:17:32.149]                       }
[13:17:32.149]                     }
[13:17:32.149]                     invisible(muffled)
[13:17:32.149]                   }
[13:17:32.149]                   muffleCondition(cond)
[13:17:32.149]                 })
[13:17:32.149]             }))
[13:17:32.149]             future::FutureResult(value = ...future.value$value, 
[13:17:32.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.149]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.149]                     ...future.globalenv.names))
[13:17:32.149]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.149]         }, condition = base::local({
[13:17:32.149]             c <- base::c
[13:17:32.149]             inherits <- base::inherits
[13:17:32.149]             invokeRestart <- base::invokeRestart
[13:17:32.149]             length <- base::length
[13:17:32.149]             list <- base::list
[13:17:32.149]             seq.int <- base::seq.int
[13:17:32.149]             signalCondition <- base::signalCondition
[13:17:32.149]             sys.calls <- base::sys.calls
[13:17:32.149]             `[[` <- base::`[[`
[13:17:32.149]             `+` <- base::`+`
[13:17:32.149]             `<<-` <- base::`<<-`
[13:17:32.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.149]                   3L)]
[13:17:32.149]             }
[13:17:32.149]             function(cond) {
[13:17:32.149]                 is_error <- inherits(cond, "error")
[13:17:32.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.149]                   NULL)
[13:17:32.149]                 if (is_error) {
[13:17:32.149]                   sessionInformation <- function() {
[13:17:32.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.149]                       search = base::search(), system = base::Sys.info())
[13:17:32.149]                   }
[13:17:32.149]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.149]                     cond$call), session = sessionInformation(), 
[13:17:32.149]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.149]                   signalCondition(cond)
[13:17:32.149]                 }
[13:17:32.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.149]                 "immediateCondition"))) {
[13:17:32.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.149]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.149]                   if (TRUE && !signal) {
[13:17:32.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.149]                     {
[13:17:32.149]                       inherits <- base::inherits
[13:17:32.149]                       invokeRestart <- base::invokeRestart
[13:17:32.149]                       is.null <- base::is.null
[13:17:32.149]                       muffled <- FALSE
[13:17:32.149]                       if (inherits(cond, "message")) {
[13:17:32.149]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.149]                         if (muffled) 
[13:17:32.149]                           invokeRestart("muffleMessage")
[13:17:32.149]                       }
[13:17:32.149]                       else if (inherits(cond, "warning")) {
[13:17:32.149]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.149]                         if (muffled) 
[13:17:32.149]                           invokeRestart("muffleWarning")
[13:17:32.149]                       }
[13:17:32.149]                       else if (inherits(cond, "condition")) {
[13:17:32.149]                         if (!is.null(pattern)) {
[13:17:32.149]                           computeRestarts <- base::computeRestarts
[13:17:32.149]                           grepl <- base::grepl
[13:17:32.149]                           restarts <- computeRestarts(cond)
[13:17:32.149]                           for (restart in restarts) {
[13:17:32.149]                             name <- restart$name
[13:17:32.149]                             if (is.null(name)) 
[13:17:32.149]                               next
[13:17:32.149]                             if (!grepl(pattern, name)) 
[13:17:32.149]                               next
[13:17:32.149]                             invokeRestart(restart)
[13:17:32.149]                             muffled <- TRUE
[13:17:32.149]                             break
[13:17:32.149]                           }
[13:17:32.149]                         }
[13:17:32.149]                       }
[13:17:32.149]                       invisible(muffled)
[13:17:32.149]                     }
[13:17:32.149]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.149]                   }
[13:17:32.149]                 }
[13:17:32.149]                 else {
[13:17:32.149]                   if (TRUE) {
[13:17:32.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.149]                     {
[13:17:32.149]                       inherits <- base::inherits
[13:17:32.149]                       invokeRestart <- base::invokeRestart
[13:17:32.149]                       is.null <- base::is.null
[13:17:32.149]                       muffled <- FALSE
[13:17:32.149]                       if (inherits(cond, "message")) {
[13:17:32.149]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.149]                         if (muffled) 
[13:17:32.149]                           invokeRestart("muffleMessage")
[13:17:32.149]                       }
[13:17:32.149]                       else if (inherits(cond, "warning")) {
[13:17:32.149]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.149]                         if (muffled) 
[13:17:32.149]                           invokeRestart("muffleWarning")
[13:17:32.149]                       }
[13:17:32.149]                       else if (inherits(cond, "condition")) {
[13:17:32.149]                         if (!is.null(pattern)) {
[13:17:32.149]                           computeRestarts <- base::computeRestarts
[13:17:32.149]                           grepl <- base::grepl
[13:17:32.149]                           restarts <- computeRestarts(cond)
[13:17:32.149]                           for (restart in restarts) {
[13:17:32.149]                             name <- restart$name
[13:17:32.149]                             if (is.null(name)) 
[13:17:32.149]                               next
[13:17:32.149]                             if (!grepl(pattern, name)) 
[13:17:32.149]                               next
[13:17:32.149]                             invokeRestart(restart)
[13:17:32.149]                             muffled <- TRUE
[13:17:32.149]                             break
[13:17:32.149]                           }
[13:17:32.149]                         }
[13:17:32.149]                       }
[13:17:32.149]                       invisible(muffled)
[13:17:32.149]                     }
[13:17:32.149]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.149]                   }
[13:17:32.149]                 }
[13:17:32.149]             }
[13:17:32.149]         }))
[13:17:32.149]     }, error = function(ex) {
[13:17:32.149]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.149]                 ...future.rng), started = ...future.startTime, 
[13:17:32.149]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.149]             version = "1.8"), class = "FutureResult")
[13:17:32.149]     }, finally = {
[13:17:32.149]         if (!identical(...future.workdir, getwd())) 
[13:17:32.149]             setwd(...future.workdir)
[13:17:32.149]         {
[13:17:32.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.149]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.149]             }
[13:17:32.149]             base::options(...future.oldOptions)
[13:17:32.149]             if (.Platform$OS.type == "windows") {
[13:17:32.149]                 old_names <- names(...future.oldEnvVars)
[13:17:32.149]                 envs <- base::Sys.getenv()
[13:17:32.149]                 names <- names(envs)
[13:17:32.149]                 common <- intersect(names, old_names)
[13:17:32.149]                 added <- setdiff(names, old_names)
[13:17:32.149]                 removed <- setdiff(old_names, names)
[13:17:32.149]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.149]                   envs[common]]
[13:17:32.149]                 NAMES <- toupper(changed)
[13:17:32.149]                 args <- list()
[13:17:32.149]                 for (kk in seq_along(NAMES)) {
[13:17:32.149]                   name <- changed[[kk]]
[13:17:32.149]                   NAME <- NAMES[[kk]]
[13:17:32.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.149]                     next
[13:17:32.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.149]                 }
[13:17:32.149]                 NAMES <- toupper(added)
[13:17:32.149]                 for (kk in seq_along(NAMES)) {
[13:17:32.149]                   name <- added[[kk]]
[13:17:32.149]                   NAME <- NAMES[[kk]]
[13:17:32.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.149]                     next
[13:17:32.149]                   args[[name]] <- ""
[13:17:32.149]                 }
[13:17:32.149]                 NAMES <- toupper(removed)
[13:17:32.149]                 for (kk in seq_along(NAMES)) {
[13:17:32.149]                   name <- removed[[kk]]
[13:17:32.149]                   NAME <- NAMES[[kk]]
[13:17:32.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.149]                     next
[13:17:32.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.149]                 }
[13:17:32.149]                 if (length(args) > 0) 
[13:17:32.149]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.149]             }
[13:17:32.149]             else {
[13:17:32.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.149]             }
[13:17:32.149]             {
[13:17:32.149]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.149]                   0L) {
[13:17:32.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.149]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.149]                   base::options(opts)
[13:17:32.149]                 }
[13:17:32.149]                 {
[13:17:32.149]                   {
[13:17:32.149]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.149]                     NULL
[13:17:32.149]                   }
[13:17:32.149]                   options(future.plan = NULL)
[13:17:32.149]                   if (is.na(NA_character_)) 
[13:17:32.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.149]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:32.149]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:32.149]                     envir = parent.frame()) 
[13:17:32.149]                   {
[13:17:32.149]                     if (is.function(workers)) 
[13:17:32.149]                       workers <- workers()
[13:17:32.149]                     workers <- structure(as.integer(workers), 
[13:17:32.149]                       class = class(workers))
[13:17:32.149]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:32.149]                       workers >= 1)
[13:17:32.149]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:32.149]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:32.149]                     }
[13:17:32.149]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:32.149]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:32.149]                       envir = envir)
[13:17:32.149]                     if (!future$lazy) 
[13:17:32.149]                       future <- run(future)
[13:17:32.149]                     invisible(future)
[13:17:32.149]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.149]                 }
[13:17:32.149]             }
[13:17:32.149]         }
[13:17:32.149]     })
[13:17:32.149]     if (TRUE) {
[13:17:32.149]         base::sink(type = "output", split = FALSE)
[13:17:32.149]         if (TRUE) {
[13:17:32.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.149]         }
[13:17:32.149]         else {
[13:17:32.149]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.149]         }
[13:17:32.149]         base::close(...future.stdout)
[13:17:32.149]         ...future.stdout <- NULL
[13:17:32.149]     }
[13:17:32.149]     ...future.result$conditions <- ...future.conditions
[13:17:32.149]     ...future.result$finished <- base::Sys.time()
[13:17:32.149]     ...future.result
[13:17:32.149] }
[13:17:32.151] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:17:32.152] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:17:32.152] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:17:32.152] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:32.152] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:32.153] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:17:32.153] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:17:32.153] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:32.154] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:32.154] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:32.154] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:32.154] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:17:32.155] MultisessionFuture started
[13:17:32.155] - Launch lazy future ... done
[13:17:32.155] run() for ‘MultisessionFuture’ ... done
[13:17:32.155] Created future:
[13:17:32.155] MultisessionFuture:
[13:17:32.155] Label: ‘future_by-2’
[13:17:32.155] Expression:
[13:17:32.155] {
[13:17:32.155]     do.call(function(...) {
[13:17:32.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.155]             on.exit(options(oopts), add = TRUE)
[13:17:32.155]         }
[13:17:32.155]         {
[13:17:32.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.155]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.155]             })
[13:17:32.155]         }
[13:17:32.155]     }, args = future.call.arguments)
[13:17:32.155] }
[13:17:32.155] Lazy evaluation: FALSE
[13:17:32.155] Asynchronous evaluation: TRUE
[13:17:32.155] Local evaluation: TRUE
[13:17:32.155] Environment: 0x5609ec6d68e0
[13:17:32.155] Capture standard output: TRUE
[13:17:32.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.155] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.155] Packages: <none>
[13:17:32.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.155] Resolved: FALSE
[13:17:32.155] Value: <not collected>
[13:17:32.155] Conditions captured: <none>
[13:17:32.155] Early signaling: FALSE
[13:17:32.155] Owner process: 14730f42-950d-2283-df71-18f11ffa6395
[13:17:32.155] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.167] Chunk #2 of 2 ... DONE
[13:17:32.167] Launching 2 futures (chunks) ... DONE
[13:17:32.167] Resolving 2 futures (chunks) ...
[13:17:32.167] resolve() on list ...
[13:17:32.167]  recursive: 0
[13:17:32.167]  length: 2
[13:17:32.167] 
[13:17:32.168] receiveMessageFromWorker() for ClusterFuture ...
[13:17:32.168] - Validating connection of MultisessionFuture
[13:17:32.168] - received message: FutureResult
[13:17:32.168] - Received FutureResult
[13:17:32.168] - Erased future from FutureRegistry
[13:17:32.168] result() for ClusterFuture ...
[13:17:32.168] - result already collected: FutureResult
[13:17:32.168] result() for ClusterFuture ... done
[13:17:32.169] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:32.169] Future #1
[13:17:32.169] result() for ClusterFuture ...
[13:17:32.169] - result already collected: FutureResult
[13:17:32.169] result() for ClusterFuture ... done
[13:17:32.169] result() for ClusterFuture ...
[13:17:32.169] - result already collected: FutureResult
[13:17:32.169] result() for ClusterFuture ... done
[13:17:32.169] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:32.169] - nx: 2
[13:17:32.170] - relay: TRUE
[13:17:32.170] - stdout: TRUE
[13:17:32.170] - signal: TRUE
[13:17:32.170] - resignal: FALSE
[13:17:32.170] - force: TRUE
[13:17:32.170] - relayed: [n=2] FALSE, FALSE
[13:17:32.170] - queued futures: [n=2] FALSE, FALSE
[13:17:32.170]  - until=1
[13:17:32.170]  - relaying element #1
[13:17:32.170] result() for ClusterFuture ...
[13:17:32.170] - result already collected: FutureResult
[13:17:32.171] result() for ClusterFuture ... done
[13:17:32.171] result() for ClusterFuture ...
[13:17:32.171] - result already collected: FutureResult
[13:17:32.171] result() for ClusterFuture ... done
[13:17:32.171] result() for ClusterFuture ...
[13:17:32.171] - result already collected: FutureResult
[13:17:32.171] result() for ClusterFuture ... done
[13:17:32.171] result() for ClusterFuture ...
[13:17:32.171] - result already collected: FutureResult
[13:17:32.171] result() for ClusterFuture ... done
[13:17:32.171] - relayed: [n=2] TRUE, FALSE
[13:17:32.171] - queued futures: [n=2] TRUE, FALSE
[13:17:32.172] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:32.172]  length: 1 (resolved future 1)
[13:17:32.203] receiveMessageFromWorker() for ClusterFuture ...
[13:17:32.203] - Validating connection of MultisessionFuture
[13:17:32.203] - received message: FutureResult
[13:17:32.203] - Received FutureResult
[13:17:32.203] - Erased future from FutureRegistry
[13:17:32.203] result() for ClusterFuture ...
[13:17:32.203] - result already collected: FutureResult
[13:17:32.204] result() for ClusterFuture ... done
[13:17:32.204] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:32.204] Future #2
[13:17:32.204] result() for ClusterFuture ...
[13:17:32.204] - result already collected: FutureResult
[13:17:32.204] result() for ClusterFuture ... done
[13:17:32.204] result() for ClusterFuture ...
[13:17:32.204] - result already collected: FutureResult
[13:17:32.204] result() for ClusterFuture ... done
[13:17:32.204] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:32.204] - nx: 2
[13:17:32.205] - relay: TRUE
[13:17:32.205] - stdout: TRUE
[13:17:32.205] - signal: TRUE
[13:17:32.205] - resignal: FALSE
[13:17:32.205] - force: TRUE
[13:17:32.205] - relayed: [n=2] TRUE, FALSE
[13:17:32.205] - queued futures: [n=2] TRUE, FALSE
[13:17:32.205]  - until=2
[13:17:32.205]  - relaying element #2
[13:17:32.205] result() for ClusterFuture ...
[13:17:32.205] - result already collected: FutureResult
[13:17:32.206] result() for ClusterFuture ... done
[13:17:32.206] result() for ClusterFuture ...
[13:17:32.206] - result already collected: FutureResult
[13:17:32.206] result() for ClusterFuture ... done
[13:17:32.206] result() for ClusterFuture ...
[13:17:32.206] - result already collected: FutureResult
[13:17:32.206] result() for ClusterFuture ... done
[13:17:32.206] result() for ClusterFuture ...
[13:17:32.206] - result already collected: FutureResult
[13:17:32.206] result() for ClusterFuture ... done
[13:17:32.206] - relayed: [n=2] TRUE, TRUE
[13:17:32.207] - queued futures: [n=2] TRUE, TRUE
[13:17:32.207] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:32.207]  length: 0 (resolved future 2)
[13:17:32.207] Relaying remaining futures
[13:17:32.207] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.207] - nx: 2
[13:17:32.207] - relay: TRUE
[13:17:32.207] - stdout: TRUE
[13:17:32.207] - signal: TRUE
[13:17:32.207] - resignal: FALSE
[13:17:32.207] - force: TRUE
[13:17:32.207] - relayed: [n=2] TRUE, TRUE
[13:17:32.208] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:32.208] - relayed: [n=2] TRUE, TRUE
[13:17:32.208] - queued futures: [n=2] TRUE, TRUE
[13:17:32.208] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.208] resolve() on list ... DONE
[13:17:32.208] result() for ClusterFuture ...
[13:17:32.208] - result already collected: FutureResult
[13:17:32.208] result() for ClusterFuture ... done
[13:17:32.208] result() for ClusterFuture ...
[13:17:32.208] - result already collected: FutureResult
[13:17:32.208] result() for ClusterFuture ... done
[13:17:32.209] result() for ClusterFuture ...
[13:17:32.209] - result already collected: FutureResult
[13:17:32.209] result() for ClusterFuture ... done
[13:17:32.209] result() for ClusterFuture ...
[13:17:32.209] - result already collected: FutureResult
[13:17:32.209] result() for ClusterFuture ... done
[13:17:32.209]  - Number of value chunks collected: 2
[13:17:32.209] Resolving 2 futures (chunks) ... DONE
[13:17:32.209] Reducing values from 2 chunks ...
[13:17:32.210]  - Number of values collected after concatenation: 3
[13:17:32.210]  - Number of values expected: 3
[13:17:32.210] Reducing values from 2 chunks ... DONE
[13:17:32.210] future_lapply() ... DONE
[13:17:32.210] future_by_internal() ... DONE
[13:17:32.211] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[13:17:32.212] plan(): Setting new future strategy stack:
[13:17:32.212] List of future strategies:
[13:17:32.212] 1. FutureStrategy:
[13:17:32.212]    - args: function (..., envir = parent.frame())
[13:17:32.212]    - tweaked: FALSE
[13:17:32.212]    - call: future::plan(oplan)
[13:17:32.213] plan(): nbrOfWorkers() = 1
> 
